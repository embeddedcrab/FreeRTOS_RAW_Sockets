   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .eabi_attribute 28,1
   5              	 .fpu fpv4-sp-d16
   6              	 .eabi_attribute 23,1
   7              	 .eabi_attribute 24,1
   8              	 .eabi_attribute 25,1
   9              	 .eabi_attribute 26,1
  10              	 .eabi_attribute 30,1
  11              	 .eabi_attribute 34,1
  12              	 .eabi_attribute 18,4
  13              	 .thumb
  14              	 .file "FreeRTOS_Sockets.c"
  15              	 .text
  16              	.Ltext0:
  17              	 .cfi_sections .debug_frame
  18              	 .section .text.prvValidSocket,"ax",%progbits
  19              	 .align 2
  20              	 .thumb
  21              	 .thumb_func
  23              	prvValidSocket:
  24              	.LFB52:
  25              	 .file 1 "../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c"
   1:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*
   2:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * FreeRTOS+TCP V2.2.2
   3:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  *
   5:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * this software and associated documentation files (the "Software"), to deal in
   7:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * the Software without restriction, including without limitation the rights to
   8:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * subject to the following conditions:
  11:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  *
  12:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * The above copyright notice and this permission notice shall be included in all
  13:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * copies or substantial portions of the Software.
  14:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  *
  15:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  *
  22:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * http://aws.amazon.com/freertos
  23:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * http://www.FreeRTOS.org
  24:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  */
  25:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
  26:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /* Standard includes. */
  27:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #include <stdint.h>
  28:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #include <stdio.h>
  29:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
  30:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /* FreeRTOS includes. */
  31:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #include "FreeRTOS.h"
  32:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #include "task.h"
  33:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #include "queue.h"
  34:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #include "semphr.h"
  35:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
  36:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /* FreeRTOS+TCP includes. */
  37:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #include "FreeRTOS_UDP_IP.h"
  38:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #include "FreeRTOS_IP.h"
  39:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #include "FreeRTOS_Sockets.h"
  40:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #include "FreeRTOS_IP_Private.h"
  41:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #include "FreeRTOS_DNS.h"
  42:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #include "NetworkBufferManagement.h"
  43:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
  44:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /* A tool to measure RAM usage. By default, it is disabled
  45:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** and it won't add any code.
  46:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** See also tools/tcp_mem_stats.md */
  47:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
  48:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*lint -e766 Header files is sometimes not used, depending on the configuration. */
  49:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #include "tcp_mem_stats.h"
  50:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
  51:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /* The ItemValue of the sockets xBoundSocketListItem member holds the socket's
  52:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** port number. */
  53:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #define socketSET_SOCKET_PORT( pxSocket, usPort ) listSET_LIST_ITEM_VALUE( ( &( ( pxSocket )->xBoun
  54:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #define socketGET_SOCKET_PORT( pxSocket ) listGET_LIST_ITEM_VALUE( ( &( ( pxSocket )->xBoundSocketL
  55:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
  56:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /* Test if a socket it bound which means it is either included in
  57:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** xBoundUDPSocketsList or xBoundTCPSocketsList */
  58:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #define socketSOCKET_IS_BOUND( pxSocket )	  ( listLIST_ITEM_CONTAINER( & ( pxSocket )->xBoundSocket
  59:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
  60:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /* If FreeRTOS_sendto() is called on a socket that is not bound to a port
  61:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** number then, depending on the FreeRTOSIPConfig.h settings, it might be that a
  62:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** port number is automatically generated for the socket.  Automatically generated
  63:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** port numbers will be between socketAUTO_PORT_ALLOCATION_START_NUMBER and
  64:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 0xffff.
  65:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
  66:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** Per https://tools.ietf.org/html/rfc6056, "the dynamic ports consist of the range
  67:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 49152-65535. However, ephemeral port selection algorithms should use the whole
  68:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** range 1024-65535" excluding those already in use (inbound or outbound). */
  69:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if !defined( socketAUTO_PORT_ALLOCATION_START_NUMBER )
  70:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	#define socketAUTO_PORT_ALLOCATION_START_NUMBER ( ( uint16_t ) 0x0400 )
  71:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif
  72:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
  73:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #define socketAUTO_PORT_ALLOCATION_MAX_NUMBER   ( ( uint16_t ) 0xffff )
  74:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
  75:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /* The number of octets that make up an IP address. */
  76:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #define socketMAX_IP_ADDRESS_OCTETS		4U
  77:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
  78:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /* A block time of 0 simply means "don't block". */
  79:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #define socketDONT_BLOCK				( ( TickType_t ) 0 )
  80:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
  81:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ( ipconfigUSE_TCP == 1 ) && !defined( ipTCP_TIMER_PERIOD_MS ) )
  82:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	#define ipTCP_TIMER_PERIOD_MS	( 1000U )
  83:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif
  84:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
  85:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /* Some helper macro's for defining the 20/80 % limits of uxLittleSpace / uxEnoughSpace. */
  86:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #define sock20_PERCENT						20U
  87:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #define sock80_PERCENT						80U
  88:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #define sock100_PERCENT						100U
  89:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
  90:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigUSE_CALLBACKS != 0 )
  91:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	static portINLINE ipDECL_CAST_PTR_FUNC_FOR_TYPE( F_TCP_UDP_Handler_t )
  92:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
  93:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		return ( F_TCP_UDP_Handler_t *)pvArgument;
  94:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
  95:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	static portINLINE ipDECL_CAST_CONST_PTR_FUNC_FOR_TYPE( F_TCP_UDP_Handler_t )
  96:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{	
  97:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		return ( const F_TCP_UDP_Handler_t *) pvArgument;
  98:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
  99:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif
 100:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 101:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 102:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** static portINLINE ipDECL_CAST_PTR_FUNC_FOR_TYPE( NetworkBufferDescriptor_t )
 103:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** {
 104:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	return ( NetworkBufferDescriptor_t *)pvArgument;
 105:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** }
 106:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 107:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 108:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** static portINLINE ipDECL_CAST_PTR_FUNC_FOR_TYPE( StreamBuffer_t )
 109:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** {
 110:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	return ( StreamBuffer_t *)pvArgument;
 111:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** }
 112:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
 113:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 114:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*
 115:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * Allocate the next port number from the private allocation range.
 116:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * TCP and UDP each have their own series of port numbers
 117:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * ulProtocol is either ipPROTOCOL_UDP or ipPROTOCOL_TCP
 118:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  */
 119:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** static uint16_t prvGetPrivatePortNumber( BaseType_t xProtocol );
 120:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 121:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*
 122:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * Return the list item from within pxList that has an item value of
 123:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * xWantedItemValue.  If there is no such list item return NULL.
 124:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  */
 125:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** static const ListItem_t * pxListFindListItemWithValue( const List_t *pxList, TickType_t xWantedItem
 126:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 127:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*
 128:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * Return pdTRUE only if pxSocket is valid and bound, as far as can be
 129:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * determined.
 130:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  */
 131:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** static BaseType_t prvValidSocket( const FreeRTOS_Socket_t *pxSocket, BaseType_t xProtocol, BaseType
 132:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 133:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*
 134:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * Internal function prvSockopt_so_buffer(): sets FREERTOS_SO_SNDBUF or
 135:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * FREERTOS_SO_RCVBUF properties of a socket.
 136:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  */
 137:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** static BaseType_t prvSockopt_so_buffer( FreeRTOS_Socket_t *pxSocket, int32_t lOptionName, const voi
 138:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 139:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*
 140:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * Before creating a socket, check the validity of the parameters used
 141:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * and find the size of the socket space, which is different for UDP and TCP
 142:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  */
 143:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** static BaseType_t prvDetermineSocketSize( BaseType_t xDomain, BaseType_t xType, BaseType_t xProtoco
 144:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 145:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigUSE_TCP == 1 )
 146:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/*
 147:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 * Create a txStream or a rxStream, depending on the parameter 'xIsInputStream'
 148:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 */
 149:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	static StreamBuffer_t *prvTCPCreateStream (FreeRTOS_Socket_t *pxSocket, BaseType_t xIsInputStream 
 150:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigUSE_TCP == 1 */
 151:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 152:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigUSE_TCP == 1 )
 153:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/*
 154:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 * Called from FreeRTOS_send(): some checks which will be done before
 155:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 * sending a TCP packed.
 156:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 */
 157:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	static int32_t prvTCPSendCheck( FreeRTOS_Socket_t *pxSocket, size_t uxDataLength );
 158:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigUSE_TCP */
 159:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 160:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigUSE_TCP == 1 )
 161:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/*
 162:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 * When a child socket gets closed, make sure to update the child-count of the parent
 163:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 */
 164:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	static void prvTCPSetSocketCount( FreeRTOS_Socket_t const * pxSocketToDelete );
 165:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif  /* ipconfigUSE_TCP == 1 */
 166:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 167:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigUSE_TCP == 1 )
 168:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/*
 169:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 * Called from FreeRTOS_connect(): make some checks and if allowed, send a
 170:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 * message to the IP-task to start connecting to a remote socket
 171:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 */
 172:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	static BaseType_t prvTCPConnectStart( FreeRTOS_Socket_t * pxSocket, struct freertos_sockaddr const
 173:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigUSE_TCP */
 174:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 175:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigUSE_TCP == 1 )
 176:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/*
 177:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 * Check if it makes any sense to wait for a connect event.
 178:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 * It may return: -EINPROGRESS, -EAGAIN, or 0 for OK.
 179:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 */
 180:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	static BaseType_t bMayConnect( FreeRTOS_Socket_t const * pxSocket );
 181:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigUSE_TCP */
 182:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 183:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
 184:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 185:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* Executed by the IP-task, it will check all sockets belonging to a set */
 186:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	static void prvFindSelectedSocket( SocketSelect_t *pxSocketSet );
 187:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 188:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigSUPPORT_SELECT_FUNCTION == 1 */
 189:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
 190:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 191:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /* The list that contains mappings between sockets and port numbers.  Accesses
 192:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** to this list must be protected by critical sections of one kind or another. */
 193:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** static List_t xBoundUDPSocketsList;
 194:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** static List_t xBoundRAWSocketsList;
 195:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 196:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if ipconfigUSE_TCP == 1
 197:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	List_t xBoundTCPSocketsList;
 198:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigUSE_TCP == 1 */
 199:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 200:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
 201:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 202:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** static BaseType_t prvValidSocket( const FreeRTOS_Socket_t *pxSocket, BaseType_t xProtocol, BaseType
 203:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** {
  26              	 .loc 1 203 0
  27              	 .cfi_startproc
  28              	 
  29              	 
  30              	 
  31              	.LVL0:
 204:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** BaseType_t xReturn;
 205:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 206:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	if( ( pxSocket == NULL ) || ( pxSocket == FREERTOS_INVALID_SOCKET ) )
  32              	 .loc 1 206 0
  33 0000 431E     	 subs r3,r0,#1
  34 0002 13F1030F 	 cmn r3,#3
  35 0006 0AD8     	 bhi .L4
 207:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 208:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		xReturn = pdFALSE;
 209:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 210:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	else if( ( xIsBound != pdFALSE ) && !socketSOCKET_IS_BOUND( pxSocket ) )
  36              	 .loc 1 210 0
  37 0008 0AB1     	 cbz r2,.L3
  38              	 .loc 1 210 0 is_stmt 0 discriminator 1
  39 000a 8369     	 ldr r3,[r0,#24]
  40 000c 4BB1     	 cbz r3,.L5
  41              	.L3:
 211:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 212:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* The caller expects the socket to be bound, but it isn't. */
 213:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		xReturn = pdFALSE;
 214:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 215:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	else if( pxSocket->ucProtocol != ( uint8_t ) xProtocol )
  42              	 .loc 1 215 0 is_stmt 1
  43 000e 90F82730 	 ldrb r3,[r0,#39]
  44 0012 C8B2     	 uxtb r0,r1
  45              	.LVL1:
  46 0014 8342     	 cmp r3,r0
  47 0016 14BF     	 ite ne
  48 0018 0020     	 movne r0,#0
  49 001a 0120     	 moveq r0,#1
  50 001c 7047     	 bx lr
  51              	.LVL2:
  52              	.L4:
 208:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
  53              	 .loc 1 208 0
  54 001e 0020     	 movs r0,#0
  55              	.LVL3:
  56 0020 7047     	 bx lr
  57              	.LVL4:
  58              	.L5:
 213:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
  59              	 .loc 1 213 0
  60 0022 0020     	 movs r0,#0
  61              	.LVL5:
 216:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 217:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* Socket has a wrong type (UDP != TCP). */
 218:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		xReturn = pdFALSE;
 219:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 220:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	else
 221:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 222:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		xReturn = pdTRUE;
 223:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 224:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 225:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	return xReturn;
 226:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** }
  62              	 .loc 1 226 0
  63 0024 7047     	 bx lr
  64              	 .cfi_endproc
  65              	.LFE52:
  67 0026 00BF     	 .section .text.pxListFindListItemWithValue,"ax",%progbits
  68              	 .align 2
  69              	 .thumb
  70              	 .thumb_func
  72              	pxListFindListItemWithValue:
  73              	.LFB73:
 227:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
 228:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 229:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** void vNetworkSocketsInit( void )
 230:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** {
 231:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	vListInitialise( &xBoundUDPSocketsList );
 232:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	vListInitialise( &xBoundRAWSocketsList );
 233:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 234:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	#if( ipconfigUSE_TCP == 1 )
 235:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 236:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		vListInitialise( &xBoundTCPSocketsList );
 237:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 238:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	#endif  /* ipconfigUSE_TCP == 1 */
 239:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** }
 240:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
 241:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 242:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** static BaseType_t prvDetermineSocketSize( BaseType_t xDomain, BaseType_t xType, BaseType_t xProtoco
 243:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** {
 244:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** BaseType_t xReturn = pdPASS;
 245:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** FreeRTOS_Socket_t const *pxSocket ;
 246:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 247:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* Asserts must not appear before it has been determined that the network
 248:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	task is ready - otherwise the asserts will fail. */
 249:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	if( xIPIsNetworkTaskReady() == pdFALSE )
 250:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 251:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		xReturn = pdFAIL;
 252:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 253:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	else
 254:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 255:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* Only Ethernet is currently supported. */
 256:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		configASSERT( xDomain == FREERTOS_AF_INET );
 257:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 258:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* Check if the UDP socket-list has been initialised. */
 259:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		configASSERT( listLIST_IS_INITIALISED( &xBoundUDPSocketsList ) );
 260:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		configASSERT( listLIST_IS_INITIALISED( &xBoundRAWSocketsList ) );
 261:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		#if( ipconfigUSE_TCP == 1 )
 262:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 263:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Check if the TCP socket-list has been initialised. */
 264:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			configASSERT( listLIST_IS_INITIALISED( &xBoundTCPSocketsList ) );
 265:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 266:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		#endif  /* ipconfigUSE_TCP == 1 */
 267:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 268:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( xProtocol == FREERTOS_IPPROTO_UDP )
 269:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 270:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( (xType != FREERTOS_SOCK_DGRAM) && ( xType != FREERTOS_SOCK_RAW ) )
 271:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 272:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xReturn = pdFAIL;
 273:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				configASSERT( xReturn == pdPASS );
 274:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 275:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* In case a UDP socket is created, do not allocate space for TCP data */
 276:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( FREERTOS_SOCK_DGRAM == xType )
 277:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 278:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				*pxSocketSize = ( sizeof( *pxSocket ) - sizeof( pxSocket->u ) ) + sizeof( pxSocket->u.xUDP );
 279:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 280:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			else
 281:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 282:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				*pxSocketSize = ( sizeof( *pxSocket ) - sizeof( pxSocket->u ) ) + sizeof( pxSocket->u.xRAW );
 283:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 284:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 285:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else if( xProtocol == FREERTOS_IPPROTO_RAW )
 286:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 287:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( (xType != FREERTOS_SOCK_RAW) && (xType != FREERTOS_CAN_RAW) )
 288:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 289:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xReturn = pdFAIL;
 290:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				configASSERT( xReturn == pdPASS );
 291:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 292:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			else
 293:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 294:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( FREERTOS_SOCK_RAW == xType )
 295:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 296:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					*pxSocketSize = ( sizeof( *pxSocket ) - sizeof( pxSocket->u ) );
 297:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 298:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				else
 299:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 300:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* CAN RAW Socket */
 301:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 302:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 303:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 304:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigUSE_TCP == 1 )
 305:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else if( xProtocol == FREERTOS_IPPROTO_TCP )
 306:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 307:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( (xType != FREERTOS_SOCK_STREAM) )
 308:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 309:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xReturn = pdFAIL;
 310:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				configASSERT( xReturn == pdPASS );
 311:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 312:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 313:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			*pxSocketSize = ( sizeof( *pxSocket ) - sizeof( pxSocket->u ) ) + sizeof( pxSocket->u.xTCP );
 314:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 315:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif  /* ipconfigUSE_TCP == 1 */
 316:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else
 317:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 318:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xReturn = pdFAIL;
 319:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			configASSERT( xReturn == pdPASS );
 320:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 321:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 322:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* In case configASSERT() is not used */
 323:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	( void )xDomain;
 324:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	( void )pxSocket;	/* Was only use fot sizeof. */
 325:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	return xReturn;
 326:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** }
 327:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
 328:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 329:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /* FreeRTOS_socket() allocates and initiates a socket */
 330:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** Socket_t FreeRTOS_socket( BaseType_t xDomain, BaseType_t xType, BaseType_t xProtocol )
 331:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** {
 332:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** FreeRTOS_Socket_t *pxSocket;
 333:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** size_t uxSocketSize = 0;
 334:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** EventGroupHandle_t xEventGroup;
 335:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** Socket_t xReturn;
 336:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 337:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	if( prvDetermineSocketSize( xDomain, xType, xProtocol, &uxSocketSize ) == pdFAIL )
 338:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 339:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		xReturn = FREERTOS_INVALID_SOCKET;
 340:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 341:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	else
 342:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 343:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* Allocate the structure that will hold the socket information. The
 344:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		size depends on the type of socket: UDP sockets need less space. A
 345:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		define 'pvPortMallocSocket' will used to allocate the necessary space.
 346:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		By default it points to the FreeRTOS function 'pvPortMalloc()'. */
 347:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		pxSocket = ipCAST_PTR_TO_TYPE_PTR( FreeRTOS_Socket_t, pvPortMallocSocket( uxSocketSize ) );
 348:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 349:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( pxSocket == NULL )
 350:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 351:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xReturn = FREERTOS_INVALID_SOCKET;
 352:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			iptraceFAILED_TO_CREATE_SOCKET();
 353:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 354:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else
 355:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 356:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xEventGroup = xEventGroupCreate();
 357:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( xEventGroup == NULL )
 358:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 359:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				vPortFreeSocket( pxSocket );
 360:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xReturn = FREERTOS_INVALID_SOCKET;
 361:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				iptraceFAILED_TO_CREATE_EVENT_GROUP();
 362:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 363:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			else
 364:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 365:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( xProtocol == FREERTOS_IPPROTO_UDP )
 366:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 367:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					iptraceMEM_STATS_CREATE( tcpSOCKET_UDP, pxSocket, uxSocketSize + sizeof( StaticEventGroup_t ) 
 368:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}	
 369:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				else
 370:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 371:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Lint wants at least a comment, in case the macro is empty. */
 372:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					iptraceMEM_STATS_CREATE( tcpSOCKET_TCP, pxSocket, uxSocketSize + sizeof( StaticEventGroup_t ) 
 373:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 374:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 375:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* Clear the entire space to avoid nulling individual entries. */
 376:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				( void ) memset( pxSocket, 0, uxSocketSize );
 377:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 378:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocket->xEventGroup = xEventGroup;
 379:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 380:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* Initialise the socket's members.  The semaphore will be created
 381:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if the socket is bound to an address, for now the pointer to the
 382:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				semaphore is just set to NULL to show it has not been created. */
 383:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( xProtocol == FREERTOS_IPPROTO_UDP )
 384:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 385:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( FREERTOS_SOCK_DGRAM == xType )
 386:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 387:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						vListInitialise( &( pxSocket->u.xUDP.xWaitingPacketsList ) );
 388:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 389:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						#if( ipconfigUDP_MAX_RX_PACKETS > 0U )
 390:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						{
 391:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							pxSocket->u.xUDP.uxMaxPackets = ( UBaseType_t ) ipconfigUDP_MAX_RX_PACKETS;
 392:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						}
 393:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						#endif /* ipconfigUDP_MAX_RX_PACKETS > 0 */
 394:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
 395:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					else if( FREERTOS_SOCK_RAW == xType )
 396:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 397:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						vListInitialise( &( pxSocket->u.xRAW.xWaitingPacketsList ) );
 398:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
 399:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					else{ /* DO Nothing */ }
 400:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 401:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				else if( xProtocol == FREERTOS_IPPROTO_RAW )
 402:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 403:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* RAW protocol does not contain waiting list, Do Nothing */
 404:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				} else{ /* Do Nothing */ }
 405:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 406:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				vListInitialiseItem( &( pxSocket->xBoundSocketListItem ) );
 407:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				listSET_LIST_ITEM_OWNER( &( pxSocket->xBoundSocketListItem ), ipPOINTER_CAST( void *, pxSocket 
 408:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 409:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocket->xReceiveBlockTime = ipconfigSOCK_DEFAULT_RECEIVE_BLOCK_TIME;
 410:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocket->xSendBlockTime	= ipconfigSOCK_DEFAULT_SEND_BLOCK_TIME;
 411:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocket->ucSocketOptions   = ( uint8_t ) FREERTOS_SO_UDPCKSUM_OUT;
 412:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocket->ucProtocol		= ( uint8_t ) xProtocol; /* protocol: UDP or TCP or RAW */
 413:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocket->ucSocketType		= ( uint8_t ) xType;
 414:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 415:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				#if( ipconfigUSE_TCP == 1 )
 416:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 417:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( xProtocol == FREERTOS_IPPROTO_TCP )
 418:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 419:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						/* StreamSize is expressed in number of bytes */
 420:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						/* Round up buffer sizes to nearest multiple of MSS */
 421:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						pxSocket->u.xTCP.usCurMSS     = ( uint16_t ) ipconfigTCP_MSS;
 422:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						pxSocket->u.xTCP.usInitMSS    = ( uint16_t ) ipconfigTCP_MSS;
 423:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						pxSocket->u.xTCP.uxRxStreamSize = ( size_t ) ipconfigTCP_RX_BUFFER_LENGTH;
 424:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						pxSocket->u.xTCP.uxTxStreamSize = ( size_t ) FreeRTOS_round_up( ipconfigTCP_TX_BUFFER_LENGTH,
 425:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						/* Use half of the buffer size of the TCP windows */
 426:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						#if ( ipconfigUSE_TCP_WIN == 1 )
 427:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						{
 428:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							pxSocket->u.xTCP.uxRxWinSize  = FreeRTOS_max_uint32( 1UL, ( uint32_t ) ( pxSocket->u.xTCP.ux
 429:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							pxSocket->u.xTCP.uxTxWinSize  = FreeRTOS_max_uint32( 1UL, ( uint32_t ) ( pxSocket->u.xTCP.ux
 430:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						}
 431:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						#else
 432:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						{
 433:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							pxSocket->u.xTCP.uxRxWinSize  = 1U;
 434:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							pxSocket->u.xTCP.uxTxWinSize  = 1U;
 435:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						}
 436:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						#endif
 437:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						/* The above values are just defaults, and can be overridden by
 438:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						calling FreeRTOS_setsockopt().  No buffers will be allocated until a
 439:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						socket is connected and data is exchanged. */
 440:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
 441:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 442:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				#endif  /* ipconfigUSE_TCP == 1 */
 443:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xReturn = pxSocket;
 444:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 445:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 446:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 447:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* Remove compiler warnings in the case the configASSERT() is not defined. */
 448:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	( void ) xDomain;
 449:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 450:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	return xReturn;
 451:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** }
 452:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
 453:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 454:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
 455:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 456:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	SocketSet_t FreeRTOS_CreateSocketSet( void )
 457:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 458:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	SocketSelect_t *pxSocketSet;
 459:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 460:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		pxSocketSet = ipCAST_PTR_TO_TYPE_PTR( SocketSelect_t, pvPortMalloc( sizeof( *pxSocketSet ) ) );
 461:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 462:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( pxSocketSet != NULL )
 463:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 464:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			( void ) memset( pxSocketSet, 0, sizeof( *pxSocketSet ) );
 465:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pxSocketSet->xSelectGroup = xEventGroupCreate();
 466:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 467:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( pxSocketSet->xSelectGroup == NULL )
 468:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 469:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				vPortFree( pxSocketSet );
 470:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocketSet = NULL;
 471:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 472:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			else
 473:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 474:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* Lint wants at least a comment, in case the macro is empty. */
 475:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				iptraceMEM_STATS_CREATE( tcpSOCKET_SET, pxSocketSet, sizeof( *pxSocketSet ) + sizeof( StaticEve
 476:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 477:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 478:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 479:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		return ( SocketSet_t ) pxSocketSet;
 480:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 481:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 482:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigSUPPORT_SELECT_FUNCTION == 1 */
 483:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
 484:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 485:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
 486:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 487:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	void FreeRTOS_DeleteSocketSet( SocketSet_t xSocketSet )
 488:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 489:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		SocketSelect_t *pxSocketSet = ( SocketSelect_t*) xSocketSet;
 490:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 491:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		iptraceMEM_STATS_DELETE( pxSocketSet );
 492:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 493:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		vEventGroupDelete( pxSocketSet->xSelectGroup );
 494:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		vPortFree( pxSocketSet );
 495:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 496:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 497:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigSUPPORT_SELECT_FUNCTION == 1 */
 498:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
 499:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 500:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
 501:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 502:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* Add a socket to a set */
 503:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	void FreeRTOS_FD_SET( Socket_t xSocket, SocketSet_t xSocketSet, EventBits_t xBitsToSet )
 504:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 505:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
 506:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	SocketSelect_t *pxSocketSet = ( SocketSelect_t * ) xSocketSet;
 507:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 508:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		configASSERT( pxSocket != NULL );
 509:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		configASSERT( xSocketSet != NULL );
 510:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 511:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* Make sure we're not adding bits which are reserved for internal use,
 512:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		such as eSELECT_CALL_IP */
 513:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		pxSocket->xSelectBits |= xBitsToSet & ( ( EventBits_t ) eSELECT_ALL );
 514:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 515:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( ( pxSocket->xSelectBits & ( ( EventBits_t ) eSELECT_ALL ) ) != ( EventBits_t ) 0U )
 516:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 517:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Adding a socket to a socket set. */
 518:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pxSocket->pxSocketSet = ( SocketSelect_t * ) xSocketSet;
 519:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 520:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Now have the IP-task call vSocketSelect() to see if the set contains
 521:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			any sockets which are 'ready' and set the proper bits. */
 522:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			prvFindSelectedSocket( pxSocketSet );
 523:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 524:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 525:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 526:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigSUPPORT_SELECT_FUNCTION == 1 */
 527:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
 528:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 529:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
 530:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* Clear select bits for a socket
 531:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	If the mask becomes 0, remove the socket from the set */
 532:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	void FreeRTOS_FD_CLR( Socket_t xSocket, SocketSet_t xSocketSet, EventBits_t xBitsToClear )
 533:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 534:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
 535:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 536:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		configASSERT( pxSocket != NULL );
 537:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		configASSERT( xSocketSet != NULL );
 538:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 539:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		pxSocket->xSelectBits &= ~( xBitsToClear & ( ( EventBits_t ) eSELECT_ALL ) );
 540:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( ( pxSocket->xSelectBits & ( ( EventBits_t ) eSELECT_ALL ) ) != ( EventBits_t ) 0U )
 541:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 542:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pxSocket->pxSocketSet = ( SocketSelect_t *)xSocketSet;
 543:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 544:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else
 545:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 546:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* disconnect it from the socket set */
 547:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pxSocket->pxSocketSet = NULL;
 548:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 549:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 550:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 551:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigSUPPORT_SELECT_FUNCTION == 1 */
 552:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
 553:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 554:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 555:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
 556:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 557:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* Test if a socket belongs to a socket-set */
 558:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	EventBits_t FreeRTOS_FD_ISSET( Socket_t xSocket, SocketSet_t xSocketSet )
 559:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 560:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	EventBits_t xReturn;
 561:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	const FreeRTOS_Socket_t *pxSocket = ( const FreeRTOS_Socket_t * ) xSocket;
 562:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 563:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		configASSERT( pxSocket != NULL );
 564:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		configASSERT( xSocketSet != NULL );
 565:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 566:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( xSocketSet == ( SocketSet_t ) pxSocket->pxSocketSet )
 567:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 568:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Make sure we're not adding bits which are reserved for internal
 569:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			use. */
 570:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xReturn = pxSocket->xSocketBits & ( ( EventBits_t ) eSELECT_ALL );
 571:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 572:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else
 573:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 574:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xReturn = 0;
 575:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 576:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 577:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		return xReturn;
 578:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 579:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 580:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigSUPPORT_SELECT_FUNCTION == 1 */
 581:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
 582:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 583:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
 584:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 585:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* The select() statement: wait for an event to occur on any of the sockets
 586:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	included in a socket set */
 587:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t FreeRTOS_select( SocketSet_t xSocketSet, TickType_t xBlockTimeTicks )
 588:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 589:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	TimeOut_t xTimeOut;
 590:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	TickType_t xRemainingTime;
 591:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	SocketSelect_t *pxSocketSet = ( SocketSelect_t*) xSocketSet;
 592:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	EventBits_t uxResult;
 593:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 594:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		configASSERT( xSocketSet != NULL );
 595:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 596:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* Only in the first round, check for non-blocking */
 597:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		xRemainingTime = xBlockTimeTicks;
 598:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 599:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* Fetch the current time */
 600:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		vTaskSetTimeOutState( &xTimeOut );
 601:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 602:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		for( ;; )
 603:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 604:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Find a socket which might have triggered the bit
 605:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			This function might return immediately or block for a limited time */
 606:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			uxResult = xEventGroupWaitBits( pxSocketSet->xSelectGroup, ( ( EventBits_t ) eSELECT_ALL ), pdFA
 607:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 608:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			#if( ipconfigSUPPORT_SIGNALS != 0 )
 609:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 610:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( ( uxResult & ( ( EventBits_t ) eSELECT_INTR ) ) != 0U )
 611:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 612:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					( void ) xEventGroupClearBits( pxSocketSet->xSelectGroup, ( EventBits_t  ) eSELECT_INTR );
 613:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					FreeRTOS_debug_printf( ( "FreeRTOS_select: interrupted\n" ) );
 614:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					break;
 615:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 616:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 617:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			#endif /* ipconfigSUPPORT_SIGNALS */
 618:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 619:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Have the IP-task find the socket which had an event */
 620:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			prvFindSelectedSocket( pxSocketSet );
 621:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 622:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			uxResult = xEventGroupGetBits( pxSocketSet->xSelectGroup );
 623:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 624:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( uxResult != 0U )
 625:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 626:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				break;
 627:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 628:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 629:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Has the timeout been reached? */
 630:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( xTaskCheckForTimeOut( &xTimeOut, &xRemainingTime ) != pdFALSE )
 631:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 632:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				break;
 633:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 634:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 635:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 636:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		return ( BaseType_t ) uxResult;
 637:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 638:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 639:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigSUPPORT_SELECT_FUNCTION */
 640:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
 641:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 642:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
 643:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 644:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* Send a message to the IP-task to have it check all sockets belonging to
 645:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	'pxSocketSet' */
 646:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	static void prvFindSelectedSocket( SocketSelect_t *pxSocketSet )
 647:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 648:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	IPStackEvent_t xSelectEvent;
 649:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	#if( ipconfigSELECT_USES_NOTIFY != 0 )
 650:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	SocketSelectMessage_t xSelectMessage;
 651:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	#endif
 652:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 653:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		xSelectEvent.eEventType = eSocketSelectEvent;
 654:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		#if( ipconfigSELECT_USES_NOTIFY != 0 )
 655:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 656:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xSelectMessage.pxSocketSet = pxSocketSet;
 657:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xSelectMessage.xTaskhandle = xTaskGetCurrentTaskHandle();
 658:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xSelectEvent.pvData = &( xSelectMessage );
 659:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 660:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		#else
 661:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 662:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xSelectEvent.pvData = pxSocketSet;
 663:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 664:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* while the IP-task works on the request, the API will block on
 665:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			'eSELECT_CALL_IP'.  So clear it first. */
 666:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			( void ) xEventGroupClearBits( pxSocketSet->xSelectGroup, ( BaseType_t ) eSELECT_CALL_IP );
 667:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 668:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		#endif
 669:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 670:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 671:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* Now send the socket select event */
 672:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( xSendEventStructToIPTask( &xSelectEvent, ( TickType_t ) portMAX_DELAY ) == pdFAIL )
 673:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 674:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Oops, we failed to wake-up the IP task. No use to wait for it. */
 675:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			FreeRTOS_debug_printf( ( "prvFindSelectedSocket: failed\n" ) );
 676:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 677:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else
 678:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 679:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* As soon as the IP-task is ready, it will set 'eSELECT_CALL_IP' to
 680:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			wakeup the calling API */
 681:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			#if( ipconfigSELECT_USES_NOTIFY != 0 )
 682:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 683:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				( void ) ulTaskNotifyTake( pdFALSE, portMAX_DELAY );
 684:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 685:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			#else
 686:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 687:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				( void ) xEventGroupWaitBits( pxSocketSet->xSelectGroup, ( BaseType_t ) eSELECT_CALL_IP, pdTRUE
 688:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 689:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			#endif
 690:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 691:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 692:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 693:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigSUPPORT_SELECT_FUNCTION == 1 */
 694:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
 695:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 696:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*
 697:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * FreeRTOS_recvfrom: receive data from a bound socket
 698:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * In this library, the function can only be used with connectionsless sockets
 699:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * (UDP)
 700:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  */
 701:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** int32_t FreeRTOS_recvfrom( Socket_t xSocket, void *pvBuffer, size_t uxBufferLength, BaseType_t xFla
 702:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** {
 703:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** BaseType_t lPacketCount;
 704:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** NetworkBufferDescriptor_t *pxNetworkBuffer;
 705:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** const void *pvCopySource;
 706:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** FreeRTOS_Socket_t const * pxSocket = xSocket;
 707:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** TickType_t xRemainingTime = ( TickType_t ) 0; /* Obsolete assignment, but some compilers output a w
 708:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** BaseType_t xTimed = pdFALSE;
 709:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** TimeOut_t xTimeOut;
 710:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** int32_t lReturn;
 711:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** EventBits_t xEventBits = ( EventBits_t ) 0;
 712:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** size_t uxPayloadLength;
 713:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 714:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* RAW socket are send only (prvValidSocket( pxSocket, FREERTOS_IPPROTO_RAW, pdTRUE ) == pdFALSE) 
 715:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	if( (prvValidSocket( pxSocket, FREERTOS_IPPROTO_UDP, pdTRUE ) == pdFALSE) )
 716:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 717:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		lReturn = -pdFREERTOS_ERRNO_EINVAL;
 718:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 719:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	else
 720:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 721:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( FREERTOS_SOCK_DGRAM == pxSocket->ucSocketType )
 722:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 723:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			lPacketCount = ( BaseType_t ) listCURRENT_LIST_LENGTH( &( pxSocket->u.xUDP.xWaitingPacketsList )
 724:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 725:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else if( FREERTOS_SOCK_RAW == pxSocket->ucSocketType )
 726:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 727:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			lPacketCount = ( BaseType_t ) listCURRENT_LIST_LENGTH( &( pxSocket->u.xRAW.xWaitingPacketsList )
 728:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 729:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else{ /* Do Nothing */ }
 730:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 731:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* The function prototype is designed to maintain the expected Berkeley
 732:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		sockets standard, but this implementation does not use all the parameters. */
 733:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		( void ) pxSourceAddressLength;
 734:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 735:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		while( lPacketCount == 0 )
 736:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 737:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( xTimed == pdFALSE )
 738:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 739:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* Check to see if the socket is non blocking on the first
 740:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				iteration.  */
 741:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xRemainingTime = pxSocket->xReceiveBlockTime;
 742:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 743:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( xRemainingTime == ( TickType_t ) 0 )
 744:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 745:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					#if( ipconfigSUPPORT_SIGNALS != 0 )
 746:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 747:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						/* Just check for the interrupt flag. */
 748:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						xEventBits = xEventGroupWaitBits( pxSocket->xEventGroup, ( EventBits_t ) eSOCKET_INTR,
 749:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							pdTRUE /*xClearOnExit*/, pdFALSE /*xWaitAllBits*/, socketDONT_BLOCK );
 750:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
 751:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					#endif /* ipconfigSUPPORT_SIGNALS */
 752:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					break;
 753:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 754:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 755:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( ( ( ( UBaseType_t ) xFlags ) & ( ( UBaseType_t ) FREERTOS_MSG_DONTWAIT ) ) != 0U )
 756:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 757:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					break;
 758:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 759:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 760:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* To ensure this part only executes once. */
 761:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xTimed = pdTRUE;
 762:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 763:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* Fetch the current time. */
 764:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				vTaskSetTimeOutState( &xTimeOut );
 765:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 766:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 767:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Wait for arrival of data.  While waiting, the IP-task may set the
 768:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			'eSOCKET_RECEIVE' bit in 'xEventGroup', if it receives data for this
 769:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			socket, thus unblocking this API call. */
 770:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xEventBits = xEventGroupWaitBits( pxSocket->xEventGroup, ( ( EventBits_t ) eSOCKET_RECEIVE ) | (
 771:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pdTRUE /*xClearOnExit*/, pdFALSE /*xWaitAllBits*/, xRemainingTime );
 772:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 773:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			#if( ipconfigSUPPORT_SIGNALS != 0 )
 774:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 775:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( ( xEventBits & ( EventBits_t ) eSOCKET_INTR ) != 0U )
 776:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 777:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( ( xEventBits & ( EventBits_t ) eSOCKET_RECEIVE ) != 0U )
 778:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 779:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						/* Shouldn't have cleared the eSOCKET_RECEIVE flag. */
 780:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						( void ) xEventGroupSetBits( pxSocket->xEventGroup, ( EventBits_t ) eSOCKET_RECEIVE );
 781:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
 782:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					break;
 783:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 784:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 785:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			#else
 786:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 787:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				( void ) xEventBits;
 788:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 789:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			#endif /* ipconfigSUPPORT_SIGNALS */
 790:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 791:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( FREERTOS_SOCK_DGRAM == pxSocket->ucSocketType )
 792:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 793:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				lPacketCount = ( BaseType_t ) listCURRENT_LIST_LENGTH( &( pxSocket->u.xUDP.xWaitingPacketsList 
 794:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 795:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			else if( FREERTOS_SOCK_RAW == pxSocket->ucSocketType )
 796:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 797:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				lPacketCount = ( BaseType_t ) listCURRENT_LIST_LENGTH( &( pxSocket->u.xRAW.xWaitingPacketsList 
 798:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 799:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			else{ /* Do Nothing */ }
 800:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 801:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( lPacketCount != 0 )
 802:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 803:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				break;
 804:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 805:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 806:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Has the timeout been reached ? */
 807:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( xTaskCheckForTimeOut( &xTimeOut, &xRemainingTime ) != pdFALSE )
 808:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 809:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				break;
 810:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 811:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		} /* while( lPacketCount == 0 ) */
 812:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 813:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( lPacketCount != 0 )
 814:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 815:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			taskENTER_CRITICAL();
 816:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 817:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* The owner of the list item is the network buffer. */
 818:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( FREERTOS_SOCK_DGRAM == pxSocket->ucSocketType )
 819:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 820:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					pxNetworkBuffer = ipCAST_PTR_TO_TYPE_PTR( NetworkBufferDescriptor_t, listGET_OWNER_OF_HEAD_ENT
 821:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 822:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				else if( FREERTOS_SOCK_RAW == pxSocket->ucSocketType )
 823:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 824:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					pxNetworkBuffer = ipCAST_PTR_TO_TYPE_PTR( NetworkBufferDescriptor_t, listGET_OWNER_OF_HEAD_ENT
 825:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 826:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				else{ /* Do Nothing */ }
 827:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 828:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( ( ( UBaseType_t ) xFlags & ( UBaseType_t ) FREERTOS_MSG_PEEK ) == 0U )
 829:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 830:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Remove the network buffer from the list of buffers waiting to
 831:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					be processed by the socket. */
 832:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					( void ) uxListRemove( &( pxNetworkBuffer->xBufferListItem ) );
 833:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 834:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 835:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			taskEXIT_CRITICAL();
 836:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 837:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* The returned value is the length of the payload data, which is
 838:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			calculated at the total packet size minus the headers.
 839:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			The validity of `xDataLength` prvProcessIPPacket has been confirmed
 840:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			in 'prvProcessIPPacket()'. */
 841:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			uxPayloadLength = pxNetworkBuffer->xDataLength - sizeof( UDPPacket_t );
 842:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			lReturn = ( int32_t ) uxPayloadLength;
 843:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 844:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( pxSourceAddress != NULL )
 845:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 846:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSourceAddress->sin_port = pxNetworkBuffer->usPort;
 847:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSourceAddress->sin_addr = pxNetworkBuffer->ulIPAddress;
 848:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 849:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 850:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( ( ( UBaseType_t ) xFlags & ( UBaseType_t ) FREERTOS_ZERO_COPY ) == 0U )
 851:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 852:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* The zero copy flag is not set.  Truncate the length if it won't
 853:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				fit in the provided buffer. */
 854:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( lReturn > ( int32_t ) uxBufferLength )
 855:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 856:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					iptraceRECVFROM_DISCARDING_BYTES( ( uxBufferLength - lReturn ) );
 857:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					lReturn = ( int32_t ) uxBufferLength;
 858:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 859:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 860:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* Copy the received data into the provided buffer, then release the
 861:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				network buffer. */
 862:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pvCopySource = ( const void *) &pxNetworkBuffer->pucEthernetBuffer[ ipUDP_PAYLOAD_OFFSET_IPv4 ]
 863:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				( void ) memcpy( pvBuffer, pvCopySource, ( size_t )lReturn );
 864:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 865:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( ( ( UBaseType_t ) xFlags & ( UBaseType_t ) FREERTOS_MSG_PEEK ) == 0U )
 866:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 867:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 868:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 869:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 870:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			else
 871:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 872:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* The zero copy flag was set.  pvBuffer is not a buffer into which
 873:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				the received data can be copied, but a pointer that must be set to
 874:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				point to the buffer in which the received data has already been
 875:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				placed. */
 876:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				*( ( void** ) pvBuffer ) = ipPOINTER_CAST( void *, &( pxNetworkBuffer->pucEthernetBuffer[ ipUDP
 877:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 878:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 879:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 880:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	#if( ipconfigSUPPORT_SIGNALS != 0 )
 881:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else if( ( xEventBits & ( EventBits_t ) eSOCKET_INTR ) != 0U )
 882:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 883:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			lReturn = -pdFREERTOS_ERRNO_EINTR;
 884:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			iptraceRECVFROM_INTERRUPTED();
 885:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 886:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	#endif /* ipconfigSUPPORT_SIGNALS */
 887:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else
 888:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 889:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			lReturn = -pdFREERTOS_ERRNO_EWOULDBLOCK;
 890:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			iptraceRECVFROM_TIMEOUT();
 891:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 892:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 893:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 894:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	return lReturn;
 895:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** }
 896:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
 897:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 898:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** int32_t FreeRTOS_sendto( Socket_t xSocket, const void *pvBuffer, size_t uxTotalDataLength, BaseType
 899:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** {
 900:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** NetworkBufferDescriptor_t *pxNetworkBuffer;
 901:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** void *pvCopyDest;
 902:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** IPStackEvent_t xStackTxEvent = { eStackTxEvent, NULL };
 903:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** TimeOut_t xTimeOut;
 904:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** TickType_t xTicksToWait;
 905:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** int32_t lReturn = 0;
 906:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** FreeRTOS_Socket_t const * pxSocket;
 907:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** size_t uxMaxPayloadLength = ( size_t ) ipMAX_UDP_PAYLOAD_LENGTH;
 908:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** size_t uxPayloadOffset = ( size_t ) ipUDP_PAYLOAD_OFFSET_IPv4;
 909:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 910:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* The function prototype is designed to maintain the expected Berkeley
 911:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	sockets standard, but this implementation does not use all the
 912:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	parameters. */
 913:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	( void ) xDestinationAddressLength;
 914:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	configASSERT( pvBuffer != NULL );
 915:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	configASSERT( xSocket != NULL );
 916:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 917:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
 918:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 919:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* Check for RAW Sockets with RAW Protocol */
 920:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	if( FREERTOS_SOCK_RAW == pxSocket->ucSocketType )
 921:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 922:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		xStackTxEvent.eEventType = eStackRAWTxEvent;
 923:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		uxPayloadOffset = ( size_t ) 0;
 924:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		uxMaxPayloadLength = ( size_t ) ipMAX_RAW_PAYLOAD_LENGTH;
 925:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 926:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* TODO: Check validity of RAW packet before proceeding */
 927:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 928:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 929:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 930:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	if( uxTotalDataLength <= ( size_t ) uxMaxPayloadLength )
 931:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 932:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* If the socket is not already bound to an address, bind it now.
 933:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		Passing NULL as the address parameter tells FreeRTOS_bind() to select
 934:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		the address to bind to. */
 935:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( socketSOCKET_IS_BOUND( pxSocket ) ||
 936:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			( FreeRTOS_bind( xSocket, NULL, 0U ) == 0 ) )
 937:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 938:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xTicksToWait = pxSocket->xSendBlockTime;
 939:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 940:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			#if( ipconfigUSE_CALLBACKS != 0 )
 941:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 942:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( xIsCallingFromIPTask() != pdFALSE )
 943:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 944:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* If this send function is called from within a call-back
 945:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					handler it may not block, otherwise chances would be big to
 946:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					get a deadlock: the IP-task waiting for itself. */
 947:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					xTicksToWait = ( TickType_t )0;
 948:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 949:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 950:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			#endif /* ipconfigUSE_CALLBACKS */
 951:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 952:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( ( ( UBaseType_t ) xFlags & ( UBaseType_t ) FREERTOS_MSG_DONTWAIT ) != 0U )
 953:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 954:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xTicksToWait = ( TickType_t ) 0;
 955:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 956:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 957:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( ( ( UBaseType_t ) xFlags & ( UBaseType_t ) FREERTOS_ZERO_COPY ) == 0U )
 958:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 959:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* Zero copy is not set, so obtain a network buffer into
 960:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				which the payload will be copied. */
 961:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				vTaskSetTimeOutState( &xTimeOut );
 962:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 963:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* Block until a buffer becomes available, or until a
 964:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				timeout has been reached */
 965:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxNetworkBuffer = pxGetNetworkBufferWithDescriptor( uxPayloadOffset + uxTotalDataLength, xTicks
 966:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 967:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( pxNetworkBuffer != NULL )
 968:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 969:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					pvCopyDest = ( void * ) &pxNetworkBuffer->pucEthernetBuffer[ uxPayloadOffset ];
 970:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					( void ) memcpy( pvCopyDest, pvBuffer, uxTotalDataLength );
 971:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 972:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdTRUE )
 973:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 974:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						/* The entire block time has been used up. */
 975:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						xTicksToWait = ( TickType_t ) 0;
 976:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
 977:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 978:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 979:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			else
 980:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 981:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( eStackRAWTxEvent == xStackTxEvent.eEventType )
 982:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 983:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* TODO: Not using this functionality for RAW sockets */
 984:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 985:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				else
 986:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 987:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* When zero copy is used, pvBuffer is a pointer to the
 988:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					payload of a buffer that has already been obtained from the
 989:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					stack.  Obtain the network buffer pointer from the buffer. */
 990:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					pxNetworkBuffer = pxUDPPayloadBuffer_to_NetworkBuffer( pvBuffer );
 991:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 992:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 993:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 994:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( pxNetworkBuffer != NULL )
 995:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 996:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if(  FREERTOS_SOCK_RAW == pxSocket->ucSocketType )
 997:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 998:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Input buffer contains the 'IP Packet[Ethernet + IP Headers] + Payload' or
 999:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					 * 'UDP Packet[Ethernet + IP + UDP Headers] + Payload' */
1000:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					pxNetworkBuffer->xDataLength = uxTotalDataLength;
1001:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
1002:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				else
1003:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
1004:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* xDataLength is the size of the total packet, including the Ethernet header. */
1005:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( FREERTOS_IPPROTO_UDP == pxSocket->ucProtocol )
1006:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
1007:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						pxNetworkBuffer->xDataLength = uxTotalDataLength + sizeof( UDPPacket_t );
1008:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
1009:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
1010:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1011:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxNetworkBuffer->usPort = pxDestinationAddress->sin_port;
1012:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxNetworkBuffer->usBoundPort = ( uint16_t ) socketGET_SOCKET_PORT( pxSocket );
1013:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxNetworkBuffer->ulIPAddress = pxDestinationAddress->sin_addr;
1014:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1015:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* The socket options are passed to the IP layer in the
1016:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				space that will eventually get used by the Ethernet header. */
1017:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxNetworkBuffer->pucEthernetBuffer[ ipSOCKET_OPTIONS_OFFSET ] = pxSocket->ucSocketOptions;
1018:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1019:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* Tell the networking task that the packet needs sending. */
1020:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xStackTxEvent.pvData = pxNetworkBuffer;
1021:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1022:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* Ask the IP-task to send this packet */
1023:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( xSendEventStructToIPTask( &xStackTxEvent, xTicksToWait ) == pdPASS )
1024:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
1025:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* The packet was successfully sent to the IP task. */
1026:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					lReturn = ( int32_t ) uxTotalDataLength;
1027:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					#if( ipconfigUSE_CALLBACKS == 1 )
1028:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
1029:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						if( ipconfigIS_VALID_PROG_ADDRESS( pxSocket->u.xUDP.pxHandleSent ) )
1030:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						{
1031:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							pxSocket->u.xUDP.pxHandleSent( xSocket, uxTotalDataLength );
1032:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						}
1033:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
1034:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					#endif /* ipconfigUSE_CALLBACKS */
1035:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
1036:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				else
1037:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
1038:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* If the buffer was allocated in this function, release
1039:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					it. */
1040:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( ( ( UBaseType_t ) xFlags & ( UBaseType_t ) FREERTOS_ZERO_COPY ) == 0U )
1041:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
1042:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
1043:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
1044:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					iptraceSTACK_TX_EVENT_LOST( ipSTACK_TX_EVENT );
1045:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
1046:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
1047:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			else
1048:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
1049:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* If errno was available, errno would be set to
1050:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				FREERTOS_ENOPKTS.  As it is, the function must return the
1051:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				number of transmitted bytes, so the calling function knows
1052:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				how	much data was actually sent. */
1053:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				iptraceNO_BUFFER_FOR_SENDTO();
1054:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
1055:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
1056:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else
1057:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
1058:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* No comment. */
1059:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			iptraceSENDTO_SOCKET_NOT_BOUND();
1060:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
1061:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
1062:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	else
1063:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
1064:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* The data is longer than the available buffer space. */
1065:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		iptraceSENDTO_DATA_TOO_LONG();
1066:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
1067:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1068:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	return lReturn;
1069:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** } /* Tested */
1070:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
1071:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1072:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*
1073:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * FreeRTOS_bind() : binds a socket to a local port number.  If port 0 is
1074:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * provided, a system provided port number will be assigned.  This function can
1075:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * be used for both UDP and TCP sockets.  The actual binding will be performed
1076:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * by the IP-task to avoid mutual access to the bound-socket-lists
1077:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * (xBoundUDPSocketsList / xBoundRAWSocketsList / xBoundTCPSocketsList).
1078:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  */
1079:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** BaseType_t FreeRTOS_bind( Socket_t xSocket, struct freertos_sockaddr const * pxAddress, socklen_t x
1080:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** {
1081:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** IPStackEvent_t xBindEvent;
1082:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
1083:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** BaseType_t xReturn = 0;
1084:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1085:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	( void ) xAddressLength;
1086:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1087:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	configASSERT( xIsCallingFromIPTask() == pdFALSE );
1088:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1089:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	if( ( pxSocket == NULL ) || ( pxSocket == FREERTOS_INVALID_SOCKET ) )
1090:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
1091:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		xReturn = -pdFREERTOS_ERRNO_EINVAL;
1092:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
1093:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* Once a socket is bound to a port, it can not be bound to a different
1094:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	port number */
1095:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	else if( socketSOCKET_IS_BOUND( pxSocket) )
1096:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
1097:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* The socket is already bound. */
1098:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		FreeRTOS_debug_printf( ( "vSocketBind: Socket already bound to %d\n", pxSocket->usLocalPort ) );
1099:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		xReturn = -pdFREERTOS_ERRNO_EINVAL;
1100:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
1101:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	else
1102:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
1103:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* Prepare a messages to the IP-task in order to perform the binding.
1104:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		The desired port number will be passed in usLocalPort. */
1105:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		xBindEvent.eEventType = eSocketBindEvent;
1106:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		xBindEvent.pvData = xSocket;
1107:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( pxAddress != NULL )
1108:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
1109:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pxSocket->usLocalPort = FreeRTOS_ntohs( pxAddress->sin_port );
1110:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
1111:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else
1112:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
1113:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Caller wants to bind to a random port number. */
1114:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pxSocket->usLocalPort = 0U;
1115:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
1116:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1117:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* portMAX_DELAY is used as a the time-out parameter, as binding *must*
1118:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		succeed before the socket can be used.  _RB_ The use of an infinite
1119:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		block time needs be changed as it could result in the task hanging. */
1120:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( xSendEventStructToIPTask( &xBindEvent, ( TickType_t ) 0xFFFF/*portMAX_DELAY*/ ) == pdFAIL )
1121:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
1122:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Failed to wake-up the IP-task, no use to wait for it */
1123:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			FreeRTOS_debug_printf( ( "FreeRTOS_bind: send event failed\n" ) );
1124:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xReturn = -pdFREERTOS_ERRNO_ECANCELED;
1125:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
1126:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else
1127:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
1128:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* The IP-task will set the 'eSOCKET_BOUND' bit when it has done its
1129:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			job. */
1130:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			( void ) xEventGroupWaitBits( pxSocket->xEventGroup, ( EventBits_t ) eSOCKET_BOUND, pdTRUE /*xCl
1131:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( !socketSOCKET_IS_BOUND( pxSocket ) )
1132:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
1133:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xReturn = -pdFREERTOS_ERRNO_EINVAL;
1134:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
1135:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
1136:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
1137:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1138:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	return xReturn;
1139:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** }
1140:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1141:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*
1142:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * vSocketBind(): internal version of bind() that should not be called directly.
1143:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * 'xInternal' is used for TCP sockets only: it allows to have several
1144:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * (connected) child sockets bound to the same server port.
1145:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  */
1146:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** BaseType_t vSocketBind( FreeRTOS_Socket_t *pxSocket, struct freertos_sockaddr * pxBindAddress, size
1147:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** {
1148:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** BaseType_t xReturn = 0; /* In Berkeley sockets, 0 means pass for bind(). */
1149:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** List_t *pxSocketList;
1150:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** struct freertos_sockaddr * pxAddress = pxBindAddress;
1151:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigALLOW_SOCKET_SEND_WITHOUT_BIND == 1 )
1152:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	struct freertos_sockaddr xAddress;
1153:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigALLOW_SOCKET_SEND_WITHOUT_BIND */
1154:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1155:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigUSE_TCP == 1 )
1156:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_TCP )
1157:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
1158:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		pxSocketList = &xBoundTCPSocketsList;
1159:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
1160:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	else
1161:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif  /* ipconfigUSE_TCP == 1 */
1162:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
1163:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_UDP )
1164:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
1165:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pxSocketList = &xBoundUDPSocketsList;
1166:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
1167:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_RAW )
1168:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
1169:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pxSocketList = &xBoundRAWSocketsList;
1170:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
1171:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else
1172:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
1173:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Do Nothing */
1174:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
1175:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
1176:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1177:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* The function prototype is designed to maintain the expected Berkeley
1178:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	sockets standard, but this implementation does not use all the parameters. */
1179:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	( void ) uxAddressLength;
1180:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1181:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	configASSERT( pxSocket != NULL );
1182:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	configASSERT( pxSocket != FREERTOS_INVALID_SOCKET );
1183:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1184:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	#if( ipconfigALLOW_SOCKET_SEND_WITHOUT_BIND == 1 )
1185:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
1186:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* pxAddress will be NULL if sendto() was called on a socket without the
1187:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		socket being bound to an address. In this case, automatically allocate
1188:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		an address to the socket.  There is a small chance that the allocated
1189:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		port will already be in use - if that is the case, then the check below
1190:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		[pxListFindListItemWithValue()] will result in an error being returned. */
1191:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( pxAddress == NULL )
1192:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
1193:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pxAddress = &xAddress;
1194:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Put the port to zero to be assigned later. */
1195:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pxAddress->sin_port = 0U;
1196:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
1197:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
1198:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	#endif /* ipconfigALLOW_SOCKET_SEND_WITHOUT_BIND == 1 */
1199:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1200:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* Sockets must be bound before calling FreeRTOS_sendto() if
1201:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	ipconfigALLOW_SOCKET_SEND_WITHOUT_BIND is not set to 1. */
1202:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	configASSERT( pxAddress != NULL );
1203:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1204:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	#if( ipconfigALLOW_SOCKET_SEND_WITHOUT_BIND == 1 )
1205:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* pxAddress is not NULL, no testing needed. */
1206:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	#else
1207:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	if( pxAddress != NULL )
1208:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	#endif
1209:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
1210:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* Add a do-while loop to facilitate use of 'break' statements. */
1211:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		do
1212:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
1213:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( pxAddress->sin_port == 0U )
1214:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
1215:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxAddress->sin_port = prvGetPrivatePortNumber( ( BaseType_t ) pxSocket->ucProtocol );
1216:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( pxAddress->sin_port == ( uint16_t ) 0U )
1217:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
1218:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					xReturn = -pdFREERTOS_ERRNO_EADDRNOTAVAIL;
1219:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					break;
1220:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
1221:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
1222:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1223:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* If vSocketBind() is called from the API FreeRTOS_bind() it has been
1224:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			confirmed that the socket was not yet bound to a port.  If it is called
1225:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			from the IP-task, no such check is necessary. */
1226:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1227:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Check to ensure the port is not already in use.  If the bind is
1228:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			called internally, a port MAY be used by more than one socket. */
1229:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( ( ( xInternal == pdFALSE ) || ( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP ) )
1230:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				( pxListFindListItemWithValue( pxSocketList, ( TickType_t ) pxAddress->sin_port ) != NULL ) )
1231:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
1232:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				FreeRTOS_debug_printf( ( "vSocketBind: %sP port %d in use\n",
1233:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_TCP ) ? "TC" : "UD",
1234:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					FreeRTOS_ntohs( pxAddress->sin_port ) ) );
1235:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xReturn = -pdFREERTOS_ERRNO_EADDRINUSE;
1236:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
1237:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			else
1238:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
1239:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* Allocate the port number to the socket.
1240:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				This macro will set 'xBoundSocketListItem->xItemValue' */
1241:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				socketSET_SOCKET_PORT( pxSocket, pxAddress->sin_port );
1242:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1243:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* And also store it in a socket field 'usLocalPort' in host-byte-order,
1244:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				mostly used for logging and debugging purposes */
1245:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocket->usLocalPort = FreeRTOS_ntohs( pxAddress->sin_port );
1246:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1247:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* Add the socket to the list of bound ports. */
1248:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
1249:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* If the network driver can iterate through 'xBoundUDPSocketsList',
1250:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					by calling xPortHasUDPSocket() then the IP-task must temporarily
1251:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					suspend the scheduler to keep the list in a consistent state. */
1252:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					#if( ipconfigETHERNET_DRIVER_FILTERS_PACKETS == 1 )
1253:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
1254:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						vTaskSuspendAll();
1255:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
1256:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					#endif /* ipconfigETHERNET_DRIVER_FILTERS_PACKETS */
1257:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1258:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Add the socket to 'xBoundUDPSocketsList' or 'xBoundRAWSocketsList
1259:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					 * 'or 'xBoundTCPSocketsList' */
1260:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					vListInsertEnd( pxSocketList, &( pxSocket->xBoundSocketListItem ) );
1261:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1262:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					#if( ipconfigETHERNET_DRIVER_FILTERS_PACKETS == 1 )
1263:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
1264:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						( void ) xTaskResumeAll();
1265:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
1266:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					#endif /* ipconfigETHERNET_DRIVER_FILTERS_PACKETS */
1267:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
1268:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
1269:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		} while( ipFALSE_BOOL );
1270:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
1271:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	#if( ipconfigALLOW_SOCKET_SEND_WITHOUT_BIND == 0 )
1272:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	else
1273:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
1274:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		xReturn = -pdFREERTOS_ERRNO_EADDRNOTAVAIL;
1275:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		FreeRTOS_debug_printf( ( "vSocketBind: Socket no addr\n" ) );
1276:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
1277:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	#endif
1278:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1279:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	if( xReturn != 0 )
1280:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
1281:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		iptraceBIND_FAILED( xSocket, ( FreeRTOS_ntohs( pxAddress->sin_port ) ) );
1282:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
1283:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1284:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	return xReturn;
1285:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** } /* Tested */
1286:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
1287:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1288:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*
1289:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * Close a socket and free the allocated space
1290:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * In case of a TCP socket: the connection will not be closed automatically
1291:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * Subsequent messages for the closed socket will be responded to with a RST
1292:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * The IP-task will actually close the socket, after receiving a 'eSocketCloseEvent' message
1293:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  */
1294:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** BaseType_t FreeRTOS_closesocket( Socket_t xSocket )
1295:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** {
1296:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** BaseType_t xResult;
1297:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigUSE_TCP == 1 ) && ( ipconfigUSE_CALLBACKS == 1 )
1298:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * )xSocket;
1299:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif
1300:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** IPStackEvent_t xCloseEvent;
1301:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** xCloseEvent.eEventType = eSocketCloseEvent;
1302:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** xCloseEvent.pvData = xSocket;
1303:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1304:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	if( ( xSocket == NULL ) || ( xSocket == FREERTOS_INVALID_SOCKET ) )
1305:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
1306:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		xResult = 0;
1307:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
1308:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	else
1309:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
1310:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		#if( ( ipconfigUSE_TCP == 1 ) && ( ipconfigUSE_CALLBACKS == 1 ) )
1311:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
1312:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_TCP )
1313:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
1314:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* Make sure that IP-task won't call the user callback's anymore */
1315:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocket->u.xTCP.pxHandleConnected = NULL;
1316:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocket->u.xTCP.pxHandleReceive = NULL;
1317:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocket->u.xTCP.pxHandleSent = NULL;
1318:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
1319:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
1320:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		#endif  /* ( ( ipconfigUSE_TCP == 1 ) && ( ipconfigUSE_CALLBACKS == 1 ) ) */
1321:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1322:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* Let the IP task close the socket to keep it synchronised	with the
1323:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		packet handling. */
1324:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1325:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* Note when changing the time-out value below, it must be checked who is calling
1326:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		this function. If it is called by the IP-task, a deadlock could occur.
1327:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		The IP-task would only call it in case of a user call-back */
1328:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( xSendEventStructToIPTask( &xCloseEvent, ( TickType_t ) 0 ) == pdFAIL )
1329:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
1330:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			FreeRTOS_debug_printf( ( "FreeRTOS_closesocket: failed\n" ) );
1331:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xResult = -1;
1332:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
1333:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else
1334:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
1335:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xResult = 1;
1336:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
1337:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
1338:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1339:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	return xResult;
1340:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** }
1341:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1342:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /* This is the internal version of FreeRTOS_closesocket()
1343:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * It will be called by the IPtask only to avoid problems with synchronicity
1344:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  */
1345:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** void *vSocketClose( FreeRTOS_Socket_t *pxSocket )
1346:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** {
1347:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** NetworkBufferDescriptor_t *pxNetworkBuffer;
1348:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1349:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	#if( ipconfigUSE_TCP == 1 )
1350:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
1351:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* For TCP: clean up a little more. */
1352:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_TCP )
1353:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
1354:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			#if( ipconfigUSE_TCP_WIN == 1 )
1355:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
1356:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( pxSocket->u.xTCP.pxAckMessage != NULL )
1357:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
1358:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					vReleaseNetworkBufferAndDescriptor( pxSocket->u.xTCP.pxAckMessage );
1359:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
1360:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* Free the resources which were claimed by the tcpWin member */
1361:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				vTCPWindowDestroy( &pxSocket->u.xTCP.xTCPWindow );
1362:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
1363:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			#endif /* ipconfigUSE_TCP_WIN */
1364:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1365:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Free the input and output streams */
1366:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( pxSocket->u.xTCP.rxStream != NULL )
1367:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
1368:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				iptraceMEM_STATS_DELETE( pxSocket->u.xTCP.rxStream );
1369:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				vPortFreeLarge( pxSocket->u.xTCP.rxStream );
1370:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
1371:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1372:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( pxSocket->u.xTCP.txStream != NULL )
1373:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
1374:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				iptraceMEM_STATS_DELETE( pxSocket->u.xTCP.txStream );
1375:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				vPortFreeLarge( pxSocket->u.xTCP.txStream );
1376:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
1377:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1378:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* In case this is a child socket, make sure the child-count of the
1379:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			parent socket is decreased. */
1380:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			prvTCPSetSocketCount( pxSocket );
1381:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
1382:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
1383:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	#endif  /* ipconfigUSE_TCP == 1 */
1384:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1385:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* Socket must be unbound first, to ensure no more packets are queued on
1386:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	it. */
1387:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	if( socketSOCKET_IS_BOUND( pxSocket ) )
1388:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
1389:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* If the network driver can iterate through 'xBoundUDPSocketsList',
1390:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		by calling xPortHasUDPSocket(), then the IP-task must temporarily
1391:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		suspend the scheduler to keep the list in a consistent state. */
1392:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		#if( ipconfigETHERNET_DRIVER_FILTERS_PACKETS == 1 )
1393:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
1394:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			vTaskSuspendAll();
1395:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
1396:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		#endif /* ipconfigETHERNET_DRIVER_FILTERS_PACKETS */
1397:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1398:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		( void ) uxListRemove( &( pxSocket->xBoundSocketListItem ) );
1399:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1400:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		#if( ipconfigETHERNET_DRIVER_FILTERS_PACKETS == 1 )
1401:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
1402:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			( void ) xTaskResumeAll();
1403:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
1404:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		#endif /* ipconfigETHERNET_DRIVER_FILTERS_PACKETS */
1405:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
1406:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1407:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* Now the socket is not bound the list of waiting packets can be
1408:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	drained. */
1409:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_UDP )
1410:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
1411:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		while( listCURRENT_LIST_LENGTH( &( pxSocket->u.xUDP.xWaitingPacketsList ) ) > 0U )
1412:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
1413:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pxNetworkBuffer = ipCAST_PTR_TO_TYPE_PTR( NetworkBufferDescriptor_t, listGET_OWNER_OF_HEAD_ENTRY
1414:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			( void ) uxListRemove( &( pxNetworkBuffer->xBufferListItem ) );
1415:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
1416:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
1417:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
1418:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1419:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	if( pxSocket->xEventGroup != NULL )
1420:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
1421:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		vEventGroupDelete( pxSocket->xEventGroup );
1422:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
1423:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1424:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	#if( ipconfigUSE_TCP == 1 ) && ( ipconfigHAS_DEBUG_PRINTF != 0 )
1425:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
1426:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_TCP )
1427:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
1428:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			FreeRTOS_debug_printf( ( "FreeRTOS_closesocket[%u to %lxip:%u]: buffers %lu socks %lu\n",
1429:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocket->usLocalPort,
1430:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocket->u.xTCP.ulRemoteIP,
1431:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocket->u.xTCP.usRemotePort,
1432:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				uxGetNumberOfFreeNetworkBuffers(),
1433:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				listCURRENT_LIST_LENGTH( &xBoundTCPSocketsList ) ) );
1434:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
1435:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
1436:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	#endif /* ( ipconfigUSE_TCP == 1 ) && ( ipconfigHAS_DEBUG_PRINTF != 0 ) */
1437:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1438:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* Anf finally, after all resources have been freed, free the socket space */
1439:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	iptraceMEM_STATS_DELETE( pxSocket );
1440:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	vPortFreeSocket( pxSocket );
1441:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1442:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	return NULL;
1443:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** } /* Tested */
1444:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1445:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
1446:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1447:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if ipconfigUSE_TCP == 1
1448:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1449:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/*
1450:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 * When a child socket gets closed, make sure to update the child-count of the
1451:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 * parent.  When a listening parent socket is closed, make sure no child-sockets
1452:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 * keep a pointer to it.
1453:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 */
1454:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	static void prvTCPSetSocketCount( FreeRTOS_Socket_t const * pxSocketToDelete )
1455:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
1456:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	const ListItem_t *pxIterator;
1457:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	const ListItem_t *pxEnd = listGET_END_MARKER( &xBoundTCPSocketsList );
1458:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	FreeRTOS_Socket_t *pxOtherSocket;
1459:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	uint16_t usLocalPort = pxSocketToDelete->usLocalPort;
1460:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1461:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		for( pxIterator  = listGET_NEXT( pxEnd );
1462:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			 pxIterator != pxEnd;
1463:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			 pxIterator  = listGET_NEXT( pxIterator ) )
1464:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
1465:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pxOtherSocket = ipCAST_PTR_TO_TYPE_PTR( FreeRTOS_Socket_t, listGET_LIST_ITEM_OWNER( pxIterator )
1466:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( ( pxOtherSocket->u.xTCP.ucTCPState == ( uint8_t ) eTCP_LISTEN ) &&
1467:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				( pxOtherSocket->usLocalPort == usLocalPort ) &&
1468:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				( pxOtherSocket->u.xTCP.usChildCount != 0U ) )
1469:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
1470:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxOtherSocket->u.xTCP.usChildCount--;
1471:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				FreeRTOS_debug_printf( ( "Lost: Socket %u now has %u / %u child%s\n",
1472:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					pxOtherSocket->usLocalPort,
1473:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					pxOtherSocket->u.xTCP.usChildCount,
1474:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					pxOtherSocket->u.xTCP.usBacklog,
1475:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					( pxOtherSocket->u.xTCP.usChildCount == 1U ) ? "" : "ren" ) );
1476:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				break;
1477:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
1478:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
1479:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
1480:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1481:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigUSE_TCP == 1 */
1482:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1483:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
1484:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1485:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** static BaseType_t prvSockopt_so_buffer( FreeRTOS_Socket_t *pxSocket, int32_t lOptionName, const voi
1486:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** {
1487:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** uint32_t ulNewValue;
1488:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** BaseType_t xReturn;
1489:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1490:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
1491:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
1492:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		FreeRTOS_debug_printf( ( "Set SO_%sBUF: wrong socket type\n",
1493:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			( lOptionName == FREERTOS_SO_SNDBUF ) ? "SND" : "RCV" ) );
1494:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		xReturn = -pdFREERTOS_ERRNO_EINVAL;
1495:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
1496:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	else if( ( ( lOptionName == FREERTOS_SO_SNDBUF ) && ( pxSocket->u.xTCP.txStream != NULL ) ) ||
1497:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			( ( lOptionName == FREERTOS_SO_RCVBUF ) && ( pxSocket->u.xTCP.rxStream != NULL ) ) )
1498:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
1499:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		FreeRTOS_debug_printf( ( "Set SO_%sBUF: buffer already created\n",
1500:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			( lOptionName == FREERTOS_SO_SNDBUF ) ? "SND" : "RCV" ) );
1501:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		xReturn = -pdFREERTOS_ERRNO_EINVAL;
1502:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
1503:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	else
1504:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
1505:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		ulNewValue = *( ipPOINTER_CAST( const uint32_t *, pvOptionValue ) );
1506:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1507:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( lOptionName == FREERTOS_SO_SNDBUF )
1508:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
1509:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Round up to nearest MSS size */
1510:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			ulNewValue = FreeRTOS_round_up( ulNewValue, ( uint32_t ) pxSocket->u.xTCP.usInitMSS );
1511:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pxSocket->u.xTCP.uxTxStreamSize = ulNewValue;
1512:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
1513:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else
1514:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
1515:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pxSocket->u.xTCP.uxRxStreamSize = ulNewValue;
1516:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
1517:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		xReturn = 0;
1518:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
1519:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1520:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	return xReturn;
1521:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** }
1522:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
1523:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1524:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /* FreeRTOS_setsockopt calls itself, but in a very limited way,
1525:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** only when FREERTOS_SO_WIN_PROPERTIES is being set. */
1526:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** BaseType_t FreeRTOS_setsockopt( Socket_t xSocket, int32_t lLevel, int32_t lOptionName, const void *
1527:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** {
1528:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /* The standard Berkeley function returns 0 for success. */
1529:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** BaseType_t xReturn = -pdFREERTOS_ERRNO_EINVAL;
1530:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** FreeRTOS_Socket_t *pxSocket;
1531:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1532:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
1533:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1534:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* The function prototype is designed to maintain the expected Berkeley
1535:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	sockets standard, but this implementation does not use all the parameters. */
1536:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	( void ) lLevel;
1537:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	( void ) uxOptionLength;
1538:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	
1539:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	if( ( pxSocket == NULL ) || ( pxSocket == FREERTOS_INVALID_SOCKET ) )
1540:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
1541:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		xReturn = -pdFREERTOS_ERRNO_EINVAL;
1542:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		return xReturn;
1543:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
1544:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1545:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	switch( lOptionName )
1546:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
1547:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		case FREERTOS_SO_RCVTIMEO	:
1548:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Receive time out. */
1549:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pxSocket->xReceiveBlockTime = *( ( const TickType_t *) pvOptionValue );
1550:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xReturn = 0;
1551:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			break;
1552:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1553:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		case FREERTOS_SO_SNDTIMEO	:
1554:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pxSocket->xSendBlockTime = *( ( const TickType_t *) pvOptionValue );
1555:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_UDP )
1556:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
1557:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* The send time out is capped for the reason stated in the
1558:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				comments where ipconfigUDP_MAX_SEND_BLOCK_TIME_TICKS is defined
1559:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				in FreeRTOSIPConfig.h (assuming an official configuration file
1560:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				is being used. */
1561:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( pxSocket->xSendBlockTime > ( ( TickType_t ) ipconfigUDP_MAX_SEND_BLOCK_TIME_TICKS ) )
1562:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
1563:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					pxSocket->xSendBlockTime = ( ( TickType_t ) ipconfigUDP_MAX_SEND_BLOCK_TIME_TICKS );
1564:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
1565:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
1566:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			else if( ( uint8_t ) FREERTOS_IPPROTO_RAW == pxSocket->ucProtocol )
1567:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
1568:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( pxSocket->xSendBlockTime > ( ( TickType_t ) ipconfigRAW_MAX_SEND_BLOCK_TIME_TICKS ) )
1569:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
1570:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					pxSocket->xSendBlockTime = ( ( TickType_t ) ipconfigRAW_MAX_SEND_BLOCK_TIME_TICKS );
1571:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
1572:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
1573:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			else
1574:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
1575:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* For TCP socket, it isn't necessary to limit the blocking time
1576:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				because	the FreeRTOS_send() function does not wait for a network
1577:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				buffer to become available. */
1578:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
1579:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xReturn = 0;
1580:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			break;
1581:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		#if( ipconfigUDP_MAX_RX_PACKETS > 0U )
1582:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			case FREERTOS_SO_UDP_MAX_RX_PACKETS:
1583:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_UDP )
1584:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
1585:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					break;	/* will return -pdFREERTOS_ERRNO_EINVAL */
1586:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
1587:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocket->u.xUDP.uxMaxPackets = *( ( const UBaseType_t * ) pvOptionValue );
1588:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xReturn = 0;
1589:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				break;
1590:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		#endif /* ipconfigUDP_MAX_RX_PACKETS */
1591:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1592:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		case FREERTOS_SO_UDPCKSUM_OUT :/* Doing for all types of sockets */
1593:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Turn calculating of the UDP checksum on/off for this socket. If pvOptionValue
1594:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			 * is anything else than NULL, the checksum generation will be turned on. */
1595:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1596:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( pvOptionValue == NULL )
1597:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
1598:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocket->ucSocketOptions &= ~( ( uint8_t ) FREERTOS_SO_UDPCKSUM_OUT );
1599:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
1600:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			else
1601:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
1602:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocket->ucSocketOptions |= ( uint8_t ) FREERTOS_SO_UDPCKSUM_OUT;
1603:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
1604:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xReturn = 0;
1605:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			break;
1606:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1607:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		#if( ipconfigUSE_CALLBACKS == 1 )
1608:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			#if( ipconfigUSE_TCP == 1 )
1609:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				case FREERTOS_SO_TCP_CONN_HANDLER:	/* Set a callback for (dis)connection events */
1610:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				case FREERTOS_SO_TCP_RECV_HANDLER:	/* Install a callback for receiving TCP data. Supply pointer
1611:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				case FREERTOS_SO_TCP_SENT_HANDLER:	/* Install a callback for sending TCP data. Supply pointer t
1612:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			#endif /* ipconfigUSE_TCP */
1613:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				case FREERTOS_SO_UDP_RECV_HANDLER:	/* Install a callback for receiving UDP data. Supply pointer
1614:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				case FREERTOS_SO_UDP_SENT_HANDLER:	/* Install a callback for sending UDP data. Supply pointer t
1615:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
1616:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						#if( ipconfigUSE_TCP == 1 )
1617:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						{
1618:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							UBaseType_t uxProtocol;
1619:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							if( ( lOptionName == FREERTOS_SO_UDP_RECV_HANDLER ) ||
1620:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 								( lOptionName == FREERTOS_SO_UDP_SENT_HANDLER ) )
1621:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							{
1622:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 								uxProtocol = ( UBaseType_t ) FREERTOS_IPPROTO_UDP;
1623:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							}
1624:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							else
1625:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							{
1626:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 								uxProtocol = ( UBaseType_t ) FREERTOS_IPPROTO_TCP;
1627:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							}
1628:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1629:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							if( pxSocket->ucProtocol != ( uint8_t ) uxProtocol )
1630:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							{
1631:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 								break;	/* will return -pdFREERTOS_ERRNO_EINVAL */
1632:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							}
1633:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						}
1634:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						#else
1635:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						{
1636:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							/* No need to check if the socket has the right
1637:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							protocol, because only UDP socket can be created. */
1638:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						}
1639:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						#endif /* ipconfigUSE_TCP */
1640:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1641:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						switch( lOptionName )
1642:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						{
1643:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						#if ipconfigUSE_TCP == 1
1644:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							case FREERTOS_SO_TCP_CONN_HANDLER:
1645:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 								pxSocket->u.xTCP.pxHandleConnected = ipCAST_CONST_PTR_TO_CONST_TYPE_PTR( F_TCP_UDP_Handler_
1646:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 								break;
1647:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							case FREERTOS_SO_TCP_RECV_HANDLER:
1648:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 								pxSocket->u.xTCP.pxHandleReceive = ipCAST_CONST_PTR_TO_CONST_TYPE_PTR( F_TCP_UDP_Handler_t,
1649:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 								break;
1650:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							case FREERTOS_SO_TCP_SENT_HANDLER:
1651:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 								pxSocket->u.xTCP.pxHandleSent = ipCAST_CONST_PTR_TO_CONST_TYPE_PTR( F_TCP_UDP_Handler_t, pv
1652:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 								break;
1653:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						#endif /* ipconfigUSE_TCP */
1654:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						case FREERTOS_SO_UDP_RECV_HANDLER:
1655:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							pxSocket->u.xUDP.pxHandleReceive = ipCAST_CONST_PTR_TO_CONST_TYPE_PTR( F_TCP_UDP_Handler_t, 
1656:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							break;
1657:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						case FREERTOS_SO_UDP_SENT_HANDLER:
1658:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							pxSocket->u.xUDP.pxHandleSent = ipCAST_CONST_PTR_TO_CONST_TYPE_PTR( F_TCP_UDP_Handler_t, pvO
1659:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							break;
1660:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						default:
1661:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							/* Should it throw an error here? */
1662:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							break;
1663:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						}
1664:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
1665:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1666:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					xReturn = 0;
1667:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					break;
1668:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		#endif /* ipconfigUSE_CALLBACKS */
1669:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1670:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		#if( ipconfigUSE_TCP != 0 )
1671:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			#if( ipconfigSOCKET_HAS_USER_SEMAPHORE != 0 )
1672:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* Each socket has a semaphore on which the using task normally
1673:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				sleeps. */
1674:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				case FREERTOS_SO_SET_SEMAPHORE:
1675:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
1676:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						pxSocket->pxUserSemaphore = *( ipPOINTER_CAST( SemaphoreHandle_t *, pvOptionValue ) );
1677:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
1678:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					xReturn = 0;
1679:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					break;
1680:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			#endif /* ipconfigSOCKET_HAS_USER_SEMAPHORE */
1681:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1682:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			#if( ipconfigSOCKET_HAS_USER_WAKE_CALLBACK != 0 )
1683:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				case FREERTOS_SO_WAKEUP_CALLBACK:
1684:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
1685:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Each socket can have a callback function that is executed
1686:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					when there is an event the socket's owner might want to
1687:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					process. */
1688:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* The type cast of the pointer expression "A" to type "B" removes const qualifier from the po
1689:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					pxSocket->pxUserWakeCallback = ( const SocketWakeupCallback_t ) pvOptionValue;
1690:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					xReturn = 0;
1691:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
1692:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				break;
1693:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			#endif /* ipconfigSOCKET_HAS_USER_WAKE_CALLBACK */
1694:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1695:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			case FREERTOS_SO_SET_LOW_HIGH_WATER:
1696:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
1697:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				const LowHighWater_t *pxLowHighWater = ipPOINTER_CAST( const LowHighWater_t *, pvOptionValue );
1698:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1699:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
1700:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
1701:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						/* It is not allowed to access 'pxSocket->u.xTCP'. */
1702:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						FreeRTOS_debug_printf( ( "FREERTOS_SO_SET_LOW_HIGH_WATER: wrong socket type\n" ) );
1703:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						break;	/* will return -pdFREERTOS_ERRNO_EINVAL */
1704:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
1705:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( ( pxLowHighWater->uxLittleSpace >= pxLowHighWater->uxEnoughSpace ) ||
1706:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						( pxLowHighWater->uxEnoughSpace > pxSocket->u.xTCP.uxRxStreamSize ) )
1707:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
1708:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						/* Impossible values. */
1709:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						FreeRTOS_debug_printf( ( "FREERTOS_SO_SET_LOW_HIGH_WATER: bad values\n" ) );
1710:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						break;	/* will return -pdFREERTOS_ERRNO_EINVAL */
1711:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
1712:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Send a STOP when buffer space drops below 'uxLittleSpace' bytes. */
1713:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					pxSocket->u.xTCP.uxLittleSpace = pxLowHighWater->uxLittleSpace;
1714:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Send a GO when buffer space grows above 'uxEnoughSpace' bytes. */
1715:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					pxSocket->u.xTCP.uxEnoughSpace = pxLowHighWater->uxEnoughSpace;
1716:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					xReturn = 0;
1717:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
1718:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				break;
1719:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1720:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			case FREERTOS_SO_SNDBUF:	/* Set the size of the send buffer, in units of MSS (TCP only) */
1721:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			case FREERTOS_SO_RCVBUF:	/* Set the size of the receive buffer, in units of MSS (TCP only) */
1722:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
1723:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					xReturn = prvSockopt_so_buffer( pxSocket, lOptionName, pvOptionValue );
1724:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
1725:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				break;
1726:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1727:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			case FREERTOS_SO_WIN_PROPERTIES:	/* Set all buffer and window properties in one call, parameter 
1728:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
1729:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					const WinProperties_t* pxProps;
1730:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1731:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
1732:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
1733:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						FreeRTOS_debug_printf( ( "Set SO_WIN_PROP: wrong socket type\n" ) );
1734:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						break;	/* will return -pdFREERTOS_ERRNO_EINVAL */
1735:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
1736:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1737:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( ( pxSocket->u.xTCP.txStream != NULL ) || ( pxSocket->u.xTCP.rxStream != NULL ) )
1738:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
1739:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						FreeRTOS_debug_printf( ( "Set SO_WIN_PROP: buffer already created\n" ) );
1740:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						break;	/* will return -pdFREERTOS_ERRNO_EINVAL */
1741:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
1742:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1743:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					pxProps = ipPOINTER_CAST( const WinProperties_t *, pvOptionValue );
1744:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1745:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					xReturn = prvSockopt_so_buffer( pxSocket, FREERTOS_SO_SNDBUF, &( pxProps->lTxBufSize ) );
1746:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if ( xReturn != 0 )
1747:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
1748:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						break;	/* will return an error. */
1749:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
1750:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1751:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					xReturn = prvSockopt_so_buffer( pxSocket, FREERTOS_SO_RCVBUF, &( pxProps->lRxBufSize ) );
1752:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if ( xReturn != 0 )
1753:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
1754:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						break;	/* will return an error. */
1755:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
1756:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1757:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					#if( ipconfigUSE_TCP_WIN == 1 )
1758:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
1759:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						pxSocket->u.xTCP.uxRxWinSize = ( uint32_t )pxProps->lRxWinSize;	/* Fixed value: size of the T
1760:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						pxSocket->u.xTCP.uxTxWinSize = ( uint32_t )pxProps->lTxWinSize;	/* Fixed value: size of the T
1761:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
1762:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					#else
1763:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
1764:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						pxSocket->u.xTCP.uxRxWinSize = 1U;
1765:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						pxSocket->u.xTCP.uxTxWinSize = 1U;
1766:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
1767:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					#endif
1768:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1769:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* In case the socket has already initialised its tcpWin,
1770:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					adapt the window size parameters */
1771:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( pxSocket->u.xTCP.xTCPWindow.u.bits.bHasInit != pdFALSE_UNSIGNED )
1772:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
1773:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						pxSocket->u.xTCP.xTCPWindow.xSize.ulRxWindowLength = pxSocket->u.xTCP.uxRxWinSize * pxSocket-
1774:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						pxSocket->u.xTCP.xTCPWindow.xSize.ulTxWindowLength = pxSocket->u.xTCP.uxTxWinSize * pxSocket-
1775:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
1776:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
1777:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1778:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xReturn = 0;
1779:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				break;
1780:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1781:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			case FREERTOS_SO_REUSE_LISTEN_SOCKET:	/* If true, the server-socket will turn into a connected s
1782:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
1783:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
1784:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
1785:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						break;	/* will return -pdFREERTOS_ERRNO_EINVAL */
1786:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
1787:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( *( ( const BaseType_t * ) pvOptionValue ) != 0 )
1788:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
1789:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						pxSocket->u.xTCP.bits.bReuseSocket = pdTRUE;
1790:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
1791:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					else
1792:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
1793:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						pxSocket->u.xTCP.bits.bReuseSocket = pdFALSE;
1794:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
1795:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
1796:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xReturn = 0;
1797:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				break;
1798:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1799:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			case FREERTOS_SO_CLOSE_AFTER_SEND:		/* As soon as the last byte has been transmitted, finalise t
1800:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
1801:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
1802:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
1803:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						break;	/* will return -pdFREERTOS_ERRNO_EINVAL */
1804:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
1805:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1806:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( *( ( const BaseType_t * ) pvOptionValue ) != 0 )
1807:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
1808:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						pxSocket->u.xTCP.bits.bCloseAfterSend = pdTRUE;
1809:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
1810:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					else
1811:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
1812:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						pxSocket->u.xTCP.bits.bCloseAfterSend = pdFALSE;
1813:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
1814:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
1815:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xReturn = 0;
1816:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				break;
1817:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1818:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			case FREERTOS_SO_SET_FULL_SIZE:		/* Refuse to send packets smaller than MSS  */
1819:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
1820:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
1821:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
1822:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						break;	/* will return -pdFREERTOS_ERRNO_EINVAL */
1823:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
1824:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1825:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( *( ( const BaseType_t *) pvOptionValue ) != 0 )
1826:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
1827:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						pxSocket->u.xTCP.xTCPWindow.u.bits.bSendFullSize = pdTRUE;
1828:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
1829:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					else
1830:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
1831:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						pxSocket->u.xTCP.xTCPWindow.u.bits.bSendFullSize = pdFALSE;
1832:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
1833:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1834:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( ( pxSocket->u.xTCP.xTCPWindow.u.bits.bSendFullSize == pdFALSE_UNSIGNED ) &&
1835:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						( pxSocket->u.xTCP.ucTCPState >= ( uint8_t ) eESTABLISHED ) &&
1836:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						( FreeRTOS_outstanding( pxSocket ) != 0 ) )
1837:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
1838:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						pxSocket->u.xTCP.usTimeout = 1U; /* to set/clear bSendFullSize */
1839:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						( void ) xSendEventToIPTask( eTCPTimerEvent );
1840:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
1841:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
1842:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xReturn = 0;
1843:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				break;
1844:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1845:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			case FREERTOS_SO_STOP_RX:		/* Refuse to receive more packts */
1846:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
1847:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
1848:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
1849:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						break;	/* will return -pdFREERTOS_ERRNO_EINVAL */
1850:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
1851:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( *( ( const BaseType_t * ) pvOptionValue ) != 0 )
1852:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
1853:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						pxSocket->u.xTCP.bits.bRxStopped = pdTRUE;
1854:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
1855:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					else
1856:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
1857:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						pxSocket->u.xTCP.bits.bRxStopped = pdFALSE;
1858:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
1859:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1860:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					pxSocket->u.xTCP.bits.bWinChange = pdTRUE;
1861:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					pxSocket->u.xTCP.usTimeout = 1U; /* to set/clear bRxStopped */
1862:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					( void ) xSendEventToIPTask( eTCPTimerEvent );
1863:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
1864:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xReturn = 0;
1865:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				break;
1866:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1867:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		#endif  /* ipconfigUSE_TCP == 1 */
1868:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1869:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		default :
1870:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* No other options are handled. */
1871:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xReturn = -pdFREERTOS_ERRNO_ENOPROTOOPT;
1872:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			break;
1873:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
1874:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1875:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	return xReturn;
1876:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** } /* Tested */
1877:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1878:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
1879:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1880:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /* Find an available port number per https://tools.ietf.org/html/rfc6056. */
1881:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** static uint16_t prvGetPrivatePortNumber( BaseType_t xProtocol )
1882:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** {
1883:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** const uint16_t usEphemeralPortCount =
1884:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	socketAUTO_PORT_ALLOCATION_MAX_NUMBER - ( socketAUTO_PORT_ALLOCATION_START_NUMBER - 1U );
1885:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** uint16_t usIterations = usEphemeralPortCount;
1886:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** uint32_t ulRandomSeed = 0;
1887:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** uint16_t usResult = 0;
1888:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** const List_t *pxList;
1889:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1890:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	if( xProtocol == ( BaseType_t ) FREERTOS_IPPROTO_UDP )
1891:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
1892:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		pxList = &xBoundUDPSocketsList;
1893:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
1894:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if ipconfigUSE_TCP == 1
1895:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	else if( xProtocol == ( BaseType_t ) FREERTOS_IPPROTO_TCP )
1896:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
1897:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		pxList = &xBoundTCPSocketsList;
1898:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
1899:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif
1900:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	else if( xProtocol == ( BaseType_t ) FREERTOS_IPPROTO_RAW )
1901:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
1902:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		pxList = &xBoundRAWSocketsList;
1903:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
1904:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	else{ /* Do Nothing */ }
1905:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1906:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* Avoid compiler warnings if ipconfigUSE_TCP is not defined. */
1907:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	( void ) xProtocol;
1908:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1909:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* Find the next available port using the random seed as a starting
1910:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	point. */
1911:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	do
1912:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
1913:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* Only proceed if the random number generator succeeded. */
1914:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( xApplicationGetRandomNumber( &( ulRandomSeed ) ) == pdFALSE )
1915:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
1916:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			break;
1917:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
1918:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1919:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* Map the random to a candidate port. */
1920:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		usResult =
1921:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			socketAUTO_PORT_ALLOCATION_START_NUMBER +
1922:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			( ( ( uint16_t )ulRandomSeed ) % usEphemeralPortCount );
1923:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1924:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* Check if there's already an open socket with the same protocol
1925:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		and port. */
1926:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( NULL == pxListFindListItemWithValue(
1927:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pxList,
1928:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			( TickType_t )FreeRTOS_htons( usResult ) ) )
1929:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
1930:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			usResult = FreeRTOS_htons( usResult );
1931:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			break;
1932:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
1933:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else
1934:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
1935:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			usResult = 0;
1936:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
1937:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1938:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		usIterations--;
1939:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
1940:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	while( usIterations > 0U );
1941:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1942:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	return usResult;
1943:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** }
1944:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
1945:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1946:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /* pxListFindListItemWithValue: find a list item in a bound socket list
1947:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 'xWantedItemValue' refers to a port number */
1948:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** static const ListItem_t * pxListFindListItemWithValue( const List_t *pxList, TickType_t xWantedItem
1949:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** {
  74              	 .loc 1 1949 0
  75              	 .cfi_startproc
  76              	 
  77              	 
  78              	.LVL6:
  79 0000 38B5     	 push {r3,r4,r5,lr}
  80              	.LCFI0:
  81              	 .cfi_def_cfa_offset 16
  82              	 .cfi_offset 3,-16
  83              	 .cfi_offset 4,-12
  84              	 .cfi_offset 5,-8
  85              	 .cfi_offset 14,-4
  86 0002 0546     	 mov r5,r0
  87 0004 0C46     	 mov r4,r1
  88              	.LVL7:
1950:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** const ListItem_t * pxResult = NULL;
1951:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1952:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	if( ( xIPIsNetworkTaskReady() != pdFALSE ) && ( pxList != NULL ) )
  89              	 .loc 1 1952 0
  90 0006 FFF7FEFF 	 bl xIPIsNetworkTaskReady
  91              	.LVL8:
  92 000a 88B1     	 cbz r0,.L11
  93              	 .loc 1 1952 0 is_stmt 0 discriminator 1
  94 000c 95B1     	 cbz r5,.L12
  95              	.LBB164:
1953:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
1954:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		const ListItem_t *pxIterator;
1955:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		const ListItem_t *pxEnd = listGET_END_MARKER( pxList );
  96              	 .loc 1 1955 0 is_stmt 1
  97 000e 05F10802 	 add r2,r5,#8
  98              	.LVL9:
1956:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		for( pxIterator  = listGET_NEXT( pxEnd );
  99              	 .loc 1 1956 0
 100 0012 E868     	 ldr r0,[r5,#12]
 101              	.LVL10:
 102 0014 8242     	 cmp r2,r0
 103 0016 0FD0     	 beq .L13
1957:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			 pxIterator != pxEnd;
1958:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			 pxIterator  = listGET_NEXT( pxIterator ) )
1959:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
1960:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( listGET_LIST_ITEM_VALUE( pxIterator ) == xWantedItemValue )
 104              	 .loc 1 1960 0
 105 0018 0368     	 ldr r3,[r0]
 106 001a A342     	 cmp r3,r4
 107 001c 03D1     	 bne .L9
 108 001e 38BD     	 pop {r3,r4,r5,pc}
 109              	.LVL11:
 110              	.L10:
 111 0020 0368     	 ldr r3,[r0]
 112 0022 A342     	 cmp r3,r4
 113 0024 09D0     	 beq .L7
 114              	.L9:
1958:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 115              	 .loc 1 1958 0
 116 0026 4068     	 ldr r0,[r0,#4]
 117              	.LVL12:
1956:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		for( pxIterator  = listGET_NEXT( pxEnd );
 118              	 .loc 1 1956 0
 119 0028 8242     	 cmp r2,r0
 120 002a F9D1     	 bne .L10
 121              	.LBE164:
1950:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 122              	 .loc 1 1950 0
 123 002c 0020     	 movs r0,#0
 124              	.LVL13:
 125              	.LBB165:
 126 002e 38BD     	 pop {r3,r4,r5,pc}
 127              	.LVL14:
 128              	.L11:
 129              	.LBE165:
 130 0030 0020     	 movs r0,#0
 131 0032 38BD     	 pop {r3,r4,r5,pc}
 132              	.LVL15:
 133              	.L12:
 134 0034 0020     	 movs r0,#0
 135 0036 38BD     	 pop {r3,r4,r5,pc}
 136              	.LVL16:
 137              	.L13:
 138 0038 0020     	 movs r0,#0
 139              	.LVL17:
 140              	.L7:
1961:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
1962:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxResult = pxIterator;
1963:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				break;
1964:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
1965:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
1966:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
1967:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1968:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	return pxResult;
1969:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** } /* Tested */
 141              	 .loc 1 1969 0
 142 003a 38BD     	 pop {r3,r4,r5,pc}
 143              	 .cfi_endproc
 144              	.LFE73:
 146              	 .section .text.prvFindSelectedSocket,"ax",%progbits
 147              	 .align 2
 148              	 .thumb
 149              	 .thumb_func
 151              	prvFindSelectedSocket:
 152              	.LFB62:
 647:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	IPStackEvent_t xSelectEvent;
 153              	 .loc 1 647 0
 154              	 .cfi_startproc
 155              	 
 156              	 
 157              	.LVL18:
 158 0000 10B5     	 push {r4,lr}
 159              	.LCFI1:
 160              	 .cfi_def_cfa_offset 8
 161              	 .cfi_offset 4,-8
 162              	 .cfi_offset 14,-4
 163 0002 84B0     	 sub sp,sp,#16
 164              	.LCFI2:
 165              	 .cfi_def_cfa_offset 24
 166 0004 0446     	 mov r4,r0
 653:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		#if( ipconfigSELECT_USES_NOTIFY != 0 )
 167              	 .loc 1 653 0
 168 0006 0B23     	 movs r3,#11
 169 0008 8DF80830 	 strb r3,[sp,#8]
 662:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 170              	 .loc 1 662 0
 171 000c 0390     	 str r0,[sp,#12]
 666:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 172              	 .loc 1 666 0
 173 000e 0068     	 ldr r0,[r0]
 174              	.LVL19:
 175 0010 1021     	 movs r1,#16
 176 0012 FFF7FEFF 	 bl xEventGroupClearBits
 177              	.LVL20:
 672:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 178              	 .loc 1 672 0
 179 0016 02A8     	 add r0,sp,#8
 180 0018 4FF0FF31 	 mov r1,#-1
 181 001c FFF7FEFF 	 bl xSendEventStructToIPTask
 182              	.LVL21:
 183 0020 40B1     	 cbz r0,.L16
 687:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 184              	 .loc 1 687 0
 185 0022 2068     	 ldr r0,[r4]
 186 0024 4FF0FF33 	 mov r3,#-1
 187 0028 0093     	 str r3,[sp]
 188 002a 1021     	 movs r1,#16
 189 002c 0122     	 movs r2,#1
 190 002e 0023     	 movs r3,#0
 191 0030 FFF7FEFF 	 bl xEventGroupWaitBits
 192              	.LVL22:
 193              	.L16:
 691:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 194              	 .loc 1 691 0
 195 0034 04B0     	 add sp,sp,#16
 196              	.LCFI3:
 197              	 .cfi_def_cfa_offset 8
 198              	 
 199 0036 10BD     	 pop {r4,pc}
 200              	 .cfi_endproc
 201              	.LFE62:
 203              	 .section .text.vNetworkSocketsInit,"ax",%progbits
 204              	 .align 2
 205              	 .global vNetworkSocketsInit
 206              	 .thumb
 207              	 .thumb_func
 209              	vNetworkSocketsInit:
 210              	.LFB53:
 230:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	vListInitialise( &xBoundUDPSocketsList );
 211              	 .loc 1 230 0
 212              	 .cfi_startproc
 213              	 
 214              	 
 215 0000 08B5     	 push {r3,lr}
 216              	.LCFI4:
 217              	 .cfi_def_cfa_offset 8
 218              	 .cfi_offset 3,-8
 219              	 .cfi_offset 14,-4
 231:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	vListInitialise( &xBoundRAWSocketsList );
 220              	 .loc 1 231 0
 221 0002 0548     	 ldr r0,.L21
 222 0004 FFF7FEFF 	 bl vListInitialise
 223              	.LVL23:
 232:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 224              	 .loc 1 232 0
 225 0008 0448     	 ldr r0,.L21+4
 226 000a FFF7FEFF 	 bl vListInitialise
 227              	.LVL24:
 236:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 228              	 .loc 1 236 0
 229 000e 0448     	 ldr r0,.L21+8
 230 0010 FFF7FEFF 	 bl vListInitialise
 231              	.LVL25:
 232 0014 08BD     	 pop {r3,pc}
 233              	.L22:
 234 0016 00BF     	 .align 2
 235              	.L21:
 236 0018 00000000 	 .word .LANCHOR0
 237 001c 00000000 	 .word .LANCHOR1
 238 0020 00000000 	 .word xBoundTCPSocketsList
 239              	 .cfi_endproc
 240              	.LFE53:
 242              	 .section .text.FreeRTOS_socket,"ax",%progbits
 243              	 .align 2
 244              	 .global FreeRTOS_socket
 245              	 .thumb
 246              	 .thumb_func
 248              	FreeRTOS_socket:
 249              	.LFB55:
 331:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** FreeRTOS_Socket_t *pxSocket;
 250              	 .loc 1 331 0
 251              	 .cfi_startproc
 252              	 
 253              	 
 254              	.LVL26:
 255 0000 2DE9F041 	 push {r4,r5,r6,r7,r8,lr}
 256              	.LCFI5:
 257              	 .cfi_def_cfa_offset 24
 258              	 .cfi_offset 4,-24
 259              	 .cfi_offset 5,-20
 260              	 .cfi_offset 6,-16
 261              	 .cfi_offset 7,-12
 262              	 .cfi_offset 8,-8
 263              	 .cfi_offset 14,-4
 264 0004 0446     	 mov r4,r0
 265 0006 0D46     	 mov r5,r1
 266 0008 1646     	 mov r6,r2
 267              	.LVL27:
 268              	.LBB184:
 269              	.LBB185:
 249:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 270              	 .loc 1 249 0
 271 000a FFF7FEFF 	 bl xIPIsNetworkTaskReady
 272              	.LVL28:
 273 000e 0028     	 cmp r0,#0
 274 0010 00F0AF80 	 beq .L47
 256:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 275              	 .loc 1 256 0
 276 0014 022C     	 cmp r4,#2
 277 0016 08D0     	 beq .L25
 278              	.LBB186:
 279              	.LBB187:
 280              	 .file 2 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h"
   1:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*
   2:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * FreeRTOS Kernel V10.4.1
   3:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
   5:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * this software and associated documentation files (the "Software"), to deal in
   7:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * the Software without restriction, including without limitation the rights to
   8:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * subject to the following conditions:
  11:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  12:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * The above copyright notice and this permission notice shall be included in all
  13:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * copies or substantial portions of the Software.
  14:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  15:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  22:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * https://www.FreeRTOS.org
  23:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * https://github.com/FreeRTOS
  24:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  25:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * 1 tab == 4 spaces!
  26:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  */
  27:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  28:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  29:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** #ifndef PORTMACRO_H
  30:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define PORTMACRO_H
  31:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  32:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifdef __cplusplus
  33:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         extern "C" {
  34:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
  35:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  36:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------
  37:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * Port specific definitions.
  38:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  39:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * The settings in this file configure FreeRTOS correctly for the
  40:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * given hardware and compiler.
  41:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  42:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * These settings should not be altered.
  43:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *-----------------------------------------------------------
  44:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  */
  45:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  46:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Type definitions. */
  47:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portCHAR          char
  48:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portFLOAT         float
  49:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portDOUBLE        double
  50:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portLONG          long
  51:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portSHORT         short
  52:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portSTACK_TYPE    uint32_t
  53:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portBASE_TYPE     long
  54:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  55:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     typedef portSTACK_TYPE   StackType_t;
  56:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     typedef long             BaseType_t;
  57:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     typedef unsigned long    UBaseType_t;
  58:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  59:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #if ( configUSE_16_BIT_TICKS == 1 )
  60:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         typedef uint16_t     TickType_t;
  61:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portMAX_DELAY              ( TickType_t ) 0xffff
  62:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #else
  63:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         typedef uint32_t     TickType_t;
  64:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portMAX_DELAY              ( TickType_t ) 0xffffffffUL
  65:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  66:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
  67:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * not need to be guarded with a critical section. */
  68:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portTICK_TYPE_IS_ATOMIC    1
  69:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
  70:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
  71:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  72:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Architecture specifics. */
  73:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portSTACK_GROWTH      ( -1 )
  74:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portTICK_PERIOD_MS    ( ( TickType_t ) 1000 / configTICK_RATE_HZ )
  75:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portBYTE_ALIGNMENT    8
  76:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portDONT_DISCARD      __attribute__( ( used ) )
  77:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
  78:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  79:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Scheduler utilities. */
  80:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portYIELD()                                 \
  81:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     {                                                   \
  82:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         /* Set a PendSV to request a context switch. */ \
  83:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT; \
  84:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****                                                         \
  85:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         /* Barriers are normally not required but do ensure the code is completely \
  86:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****          * within the specified behaviour for the architecture. */ \
  87:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile ( "dsb" ::: "memory" );                     \
  88:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile ( "isb" );                                  \
  89:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     }
  90:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  91:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portNVIC_INT_CTRL_REG     ( *( ( volatile uint32_t * ) 0xe000ed04 ) )
  92:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portNVIC_PENDSVSET_BIT    ( 1UL << 28UL )
  93:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portEND_SWITCHING_ISR( xSwitchRequired )    if( xSwitchRequired != pdFALSE ) portYIELD(
  94:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portYIELD_FROM_ISR( x )                     portEND_SWITCHING_ISR( x )
  95:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
  96:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  97:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Critical section management. */
  98:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     extern void vPortEnterCritical( void );
  99:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     extern void vPortExitCritical( void );
 100:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portSET_INTERRUPT_MASK_FROM_ISR()         ulPortRaiseBASEPRI()
 101:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portCLEAR_INTERRUPT_MASK_FROM_ISR( x )    vPortSetBASEPRI( x )
 102:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portDISABLE_INTERRUPTS()                  vPortRaiseBASEPRI()
 103:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portENABLE_INTERRUPTS()                   vPortSetBASEPRI( 0 )
 104:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portENTER_CRITICAL()                      vPortEnterCritical()
 105:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portEXIT_CRITICAL()                       vPortExitCritical()
 106:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 107:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 108:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 109:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Task function macros as described on the FreeRTOS.org WEB site.  These are
 110:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * not necessary for to use this port.  They are defined so the common demo files
 111:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * (which build with all the ports) will build. */
 112:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portTASK_FUNCTION_PROTO( vFunction, pvParameters )    void vFunction( void * pvParamete
 113:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portTASK_FUNCTION( vFunction, pvParameters )          void vFunction( void * pvParamete
 114:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 115:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 116:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Tickless idle/low power functionality. */
 117:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifndef portSUPPRESS_TICKS_AND_SLEEP
 118:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
 119:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime )    vPortSuppressTicksAndSleep( xE
 120:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
 121:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 122:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 123:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Architecture specific optimisations. */
 124:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
 125:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define configUSE_PORT_OPTIMISED_TASK_SELECTION    1
 126:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
 127:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 128:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
 129:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 130:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Generic helper function. */
 131:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t 
 132:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         {
 133:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             uint8_t ucReturn;
 134:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 135:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             __asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 136:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 137:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             return ucReturn;
 138:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         }
 139:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 140:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Check the configuration. */
 141:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #if ( configMAX_PRIORITIES > 32 )
 142:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             #error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIO
 143:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #endif
 144:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 145:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Store/clear the ready priorities in a bit map. */
 146:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities )    ( uxReadyPriorities )
 147:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities )     ( uxReadyPriorities )
 148:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 149:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 150:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 151:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities )    uxTopPriority = ( 3
 152:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 153:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 154:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 155:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 156:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 157:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifdef configASSERT
 158:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         void vPortValidateInterruptPriority( void );
 159:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portASSERT_IF_INTERRUPT_PRIORITY_INVALID()    vPortValidateInterruptPriority()
 160:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
 161:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 162:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* portNOP() is not required by this port. */
 163:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portNOP()
 164:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 165:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portINLINE              __inline
 166:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 167:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifndef portFORCE_INLINE
 168:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portFORCE_INLINE    inline __attribute__( ( always_inline ) )
 169:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
 170:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 171:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     portFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )
 172:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     {
 173:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         uint32_t ulCurrentInterrupt;
 174:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         BaseType_t xReturn;
 175:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 176:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         /* Obtain the number of the currently executing interrupt. */
 177:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile ( "mrs %0, ipsr" : "=r" ( ulCurrentInterrupt )::"memory" );
 178:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 179:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         if( ulCurrentInterrupt == 0 )
 180:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         {
 181:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             xReturn = pdFALSE;
 182:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         }
 183:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         else
 184:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         {
 185:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             xReturn = pdTRUE;
 186:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         }
 187:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 188:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         return xReturn;
 189:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     }
 190:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 191:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 192:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 193:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     portFORCE_INLINE static void vPortRaiseBASEPRI( void )
 194:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     {
 195:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         uint32_t ulNewBASEPRI;
 196:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile
 281              	 .loc 2 197 0
 282              	
 283 0018 4FF01403 	 mov r3,#20
 284 001c 83F31188 	 msr basepri,r3
 285 0020 BFF36F8F 	 isb 
 286 0024 BFF34F8F 	 dsb 
 287              	
 288              	
 289              	.LVL29:
 290              	 .thumb
 291              	.L26:
 292 0028 FEE7     	 b .L26
 293              	.L25:
 294              	.LBE187:
 295              	.LBE186:
 259:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		configASSERT( listLIST_IS_INITIALISED( &xBoundRAWSocketsList ) );
 296              	 .loc 1 259 0
 297 002a 644B     	 ldr r3,.L55
 298 002c 9B68     	 ldr r3,[r3,#8]
 299 002e B3F1FF3F 	 cmp r3,#-1
 300 0032 08D0     	 beq .L27
 301              	.LBB188:
 302              	.LBB189:
 303              	 .loc 2 197 0
 304              	
 305 0034 4FF01403 	 mov r3,#20
 306 0038 83F31188 	 msr basepri,r3
 307 003c BFF36F8F 	 isb 
 308 0040 BFF34F8F 	 dsb 
 309              	
 310              	
 311              	.LVL30:
 312              	 .thumb
 313              	.L28:
 314 0044 FEE7     	 b .L28
 315              	.L27:
 316              	.LBE189:
 317              	.LBE188:
 260:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		#if( ipconfigUSE_TCP == 1 )
 318              	 .loc 1 260 0
 319 0046 5E4B     	 ldr r3,.L55+4
 320 0048 9B68     	 ldr r3,[r3,#8]
 321 004a B3F1FF3F 	 cmp r3,#-1
 322 004e 08D0     	 beq .L29
 323              	.LBB190:
 324              	.LBB191:
 325              	 .loc 2 197 0
 326              	
 327 0050 4FF01403 	 mov r3,#20
 328 0054 83F31188 	 msr basepri,r3
 329 0058 BFF36F8F 	 isb 
 330 005c BFF34F8F 	 dsb 
 331              	
 332              	
 333              	.LVL31:
 334              	 .thumb
 335              	.L30:
 336 0060 FEE7     	 b .L30
 337              	.L29:
 338              	.LBE191:
 339              	.LBE190:
 264:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 340              	 .loc 1 264 0
 341 0062 584B     	 ldr r3,.L55+8
 342 0064 9B68     	 ldr r3,[r3,#8]
 343 0066 B3F1FF3F 	 cmp r3,#-1
 344 006a 08D0     	 beq .L31
 345              	.LBB192:
 346              	.LBB193:
 347              	 .loc 2 197 0
 348              	
 349 006c 4FF01403 	 mov r3,#20
 350 0070 83F31188 	 msr basepri,r3
 351 0074 BFF36F8F 	 isb 
 352 0078 BFF34F8F 	 dsb 
 353              	
 354              	
 355              	.LVL32:
 356              	 .thumb
 357              	.L32:
 358 007c FEE7     	 b .L32
 359              	.L31:
 360              	.LBE193:
 361              	.LBE192:
 268:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 362              	 .loc 1 268 0
 363 007e 112E     	 cmp r6,#17
 364 0080 0BD1     	 bne .L33
 270:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 365              	 .loc 1 270 0
 366 0082 AB1E     	 subs r3,r5,#2
 367 0084 012B     	 cmp r3,#1
 368 0086 7AD9     	 bls .L48
 369              	.LVL33:
 370              	.LBB194:
 371              	.LBB195:
 372              	 .loc 2 197 0
 373              	
 374 0088 4FF01403 	 mov r3,#20
 375 008c 83F31188 	 msr basepri,r3
 376 0090 BFF36F8F 	 isb 
 377 0094 BFF34F8F 	 dsb 
 378              	
 379              	
 380              	.LVL34:
 381              	 .thumb
 382              	.L35:
 383 0098 FEE7     	 b .L35
 384              	.LVL35:
 385              	.L33:
 386              	.LBE195:
 387              	.LBE194:
 285:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 388              	 .loc 1 285 0
 389 009a FF2E     	 cmp r6,#255
 390 009c 10D1     	 bne .L36
 287:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 391              	 .loc 1 287 0
 392 009e EB1E     	 subs r3,r5,#3
 393 00a0 012B     	 cmp r3,#1
 394 00a2 08D9     	 bls .L37
 395              	.LVL36:
 396              	.LBB196:
 397              	.LBB197:
 398              	 .loc 2 197 0
 399              	
 400 00a4 4FF01403 	 mov r3,#20
 401 00a8 83F31188 	 msr basepri,r3
 402 00ac BFF36F8F 	 isb 
 403 00b0 BFF34F8F 	 dsb 
 404              	
 405              	
 406              	.LVL37:
 407              	 .thumb
 408              	.L38:
 409 00b4 FEE7     	 b .L38
 410              	.LVL38:
 411              	.L37:
 412              	.LBE197:
 413              	.LBE196:
 296:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 414              	 .loc 1 296 0
 415 00b6 032D     	 cmp r5,#3
 416 00b8 14BF     	 ite ne
 417 00ba 0027     	 movne r7,#0
 418 00bc 3827     	 moveq r7,#56
 419 00be 62E0     	 b .L34
 420              	.L36:
 305:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 421              	 .loc 1 305 0
 422 00c0 062E     	 cmp r6,#6
 423 00c2 0AD1     	 bne .L39
 307:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 424              	 .loc 1 307 0
 425 00c4 012D     	 cmp r5,#1
 426 00c6 5CD0     	 beq .L50
 427              	.LVL39:
 428              	.LBB198:
 429              	.LBB199:
 430              	 .loc 2 197 0
 431              	
 432 00c8 4FF01403 	 mov r3,#20
 433 00cc 83F31188 	 msr basepri,r3
 434 00d0 BFF36F8F 	 isb 
 435 00d4 BFF34F8F 	 dsb 
 436              	
 437              	
 438              	.LVL40:
 439              	 .thumb
 440              	.L40:
 441 00d8 FEE7     	 b .L40
 442              	.LVL41:
 443              	.L39:
 444              	.LBE199:
 445              	.LBE198:
 446              	.LBB200:
 447              	.LBB201:
 448              	
 449 00da 4FF01403 	 mov r3,#20
 450 00de 83F31188 	 msr basepri,r3
 451 00e2 BFF36F8F 	 isb 
 452 00e6 BFF34F8F 	 dsb 
 453              	
 454              	
 455              	.LVL42:
 456              	 .thumb
 457              	.L41:
 458 00ea FEE7     	 b .L41
 459              	.LVL43:
 460              	.L53:
 461              	.LBE201:
 462              	.LBE200:
 463              	.LBE185:
 464              	.LBE184:
 356:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( xEventGroup == NULL )
 465              	 .loc 1 356 0
 466 00ec FFF7FEFF 	 bl xEventGroupCreate
 467              	.LVL44:
 357:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 468              	 .loc 1 357 0
 469 00f0 8046     	 mov r8,r0
 470 00f2 28B9     	 cbnz r0,.L42
 359:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xReturn = FREERTOS_INVALID_SOCKET;
 471              	 .loc 1 359 0
 472 00f4 2046     	 mov r0,r4
 473              	.LVL45:
 474 00f6 FFF7FEFF 	 bl vPortFree
 475              	.LVL46:
 360:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				iptraceFAILED_TO_CREATE_EVENT_GROUP();
 476              	 .loc 1 360 0
 477 00fa 4FF0FF34 	 mov r4,#-1
 478              	.LVL47:
 479 00fe 5AE0     	 b .L52
 480              	.LVL48:
 481              	.L42:
 376:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 482              	 .loc 1 376 0
 483 0100 2046     	 mov r0,r4
 484              	.LVL49:
 485 0102 0021     	 movs r1,#0
 486 0104 3A46     	 mov r2,r7
 487 0106 FFF7FEFF 	 bl memset
 488              	.LVL50:
 378:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 489              	 .loc 1 378 0
 490 010a C4F80480 	 str r8,[r4,#4]
 383:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 491              	 .loc 1 383 0
 492 010e 112E     	 cmp r6,#17
 493 0110 0DD1     	 bne .L43
 385:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 494              	 .loc 1 385 0
 495 0112 022D     	 cmp r5,#2
 496 0114 04D1     	 bne .L44
 387:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 497              	 .loc 1 387 0
 498 0116 04F13800 	 add r0,r4,#56
 499 011a FFF7FEFF 	 bl vListInitialise
 500              	.LVL51:
 501 011e 39E0     	 b .L45
 502              	.L44:
 395:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 503              	 .loc 1 395 0
 504 0120 032D     	 cmp r5,#3
 505 0122 37D1     	 bne .L45
 397:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
 506              	 .loc 1 397 0
 507 0124 04F13800 	 add r0,r4,#56
 508 0128 FFF7FEFF 	 bl vListInitialise
 509              	.LVL52:
 510 012c 32E0     	 b .L45
 511              	.L43:
 406:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				listSET_LIST_ITEM_OWNER( &( pxSocket->xBoundSocketListItem ), ipPOINTER_CAST( void *, pxSocket 
 512              	 .loc 1 406 0
 513 012e 04F10800 	 add r0,r4,#8
 514 0132 FFF7FEFF 	 bl vListInitialiseItem
 515              	.LVL53:
 407:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 516              	 .loc 1 407 0
 517 0136 6461     	 str r4,[r4,#20]
 409:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocket->xSendBlockTime	= ipconfigSOCK_DEFAULT_SEND_BLOCK_TIME;
 518              	 .loc 1 409 0
 519 0138 41F28833 	 movw r3,#5000
 520 013c E361     	 str r3,[r4,#28]
 410:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocket->ucSocketOptions   = ( uint8_t ) FREERTOS_SO_UDPCKSUM_OUT;
 521              	 .loc 1 410 0
 522 013e 2362     	 str r3,[r4,#32]
 411:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocket->ucProtocol		= ( uint8_t ) xProtocol; /* protocol: UDP or TCP or RAW */
 523              	 .loc 1 411 0
 524 0140 0223     	 movs r3,#2
 525 0142 84F82630 	 strb r3,[r4,#38]
 412:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocket->ucSocketType		= ( uint8_t ) xType;
 526              	 .loc 1 412 0
 527 0146 84F82760 	 strb r6,[r4,#39]
 413:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 528              	 .loc 1 413 0
 529 014a 84F82850 	 strb r5,[r4,#40]
 417:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 530              	 .loc 1 417 0
 531 014e 062E     	 cmp r6,#6
 532 0150 31D1     	 bne .L52
 421:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						pxSocket->u.xTCP.usInitMSS    = ( uint16_t ) ipconfigTCP_MSS;
 533              	 .loc 1 421 0
 534 0152 4FF49163 	 mov r3,#1160
 535 0156 A4F84A30 	 strh r3,[r4,#74]
 422:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						pxSocket->u.xTCP.uxRxStreamSize = ( size_t ) ipconfigTCP_RX_BUFFER_LENGTH;
 536              	 .loc 1 422 0
 537 015a A4F84C30 	 strh r3,[r4,#76]
 423:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						pxSocket->u.xTCP.uxTxStreamSize = ( size_t ) FreeRTOS_round_up( ipconfigTCP_TX_BUFFER_LENGTH,
 538              	 .loc 1 423 0
 539 015e 4FF47A72 	 mov r2,#1000
 540 0162 E266     	 str r2,[r4,#108]
 541              	.LVL54:
 424:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						/* Use half of the buffer size of the TCP windows */
 542              	 .loc 1 424 0
 543 0164 2367     	 str r3,[r4,#112]
 544              	.LVL55:
 428:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							pxSocket->u.xTCP.uxTxWinSize  = FreeRTOS_max_uint32( 1UL, ( uint32_t ) ( pxSocket->u.xTCP.ux
 545              	 .loc 1 428 0
 546 0166 0123     	 movs r3,#1
 547 0168 C4F8D030 	 str r3,[r4,#208]
 548              	.LVL56:
 429:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						}
 549              	 .loc 1 429 0
 550 016c C4F8D430 	 str r3,[r4,#212]
 551 0170 21E0     	 b .L52
 552              	.LVL57:
 553              	.L47:
 339:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 554              	 .loc 1 339 0
 555 0172 4FF0FF34 	 mov r4,#-1
 556              	.LVL58:
 557 0176 1EE0     	 b .L52
 558              	.LVL59:
 559              	.L51:
 351:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			iptraceFAILED_TO_CREATE_SOCKET();
 560              	 .loc 1 351 0
 561 0178 4FF0FF34 	 mov r4,#-1
 562 017c 1BE0     	 b .L52
 563              	.LVL60:
 564              	.L48:
 565              	.LBB203:
 566              	.LBB202:
 278:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 567              	 .loc 1 278 0
 568 017e 4C27     	 movs r7,#76
 569 0180 01E0     	 b .L34
 570              	.L50:
 313:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 571              	 .loc 1 313 0
 572 0182 4FF4CC77 	 mov r7,#408
 573              	.L34:
 574              	.LVL61:
 575              	.LBE202:
 576              	.LBE203:
 347:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 577              	 .loc 1 347 0
 578 0186 3846     	 mov r0,r7
 579 0188 FFF7FEFF 	 bl pvPortMalloc
 580              	.LVL62:
 349:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 581              	 .loc 1 349 0
 582 018c 0446     	 mov r4,r0
 583              	.LVL63:
 584 018e 0028     	 cmp r0,#0
 585 0190 ACD1     	 bne .L53
 586 0192 F1E7     	 b .L51
 587              	.LVL64:
 588              	.L45:
 406:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				listSET_LIST_ITEM_OWNER( &( pxSocket->xBoundSocketListItem ), ipPOINTER_CAST( void *, pxSocket 
 589              	 .loc 1 406 0
 590 0194 04F10800 	 add r0,r4,#8
 591 0198 FFF7FEFF 	 bl vListInitialiseItem
 592              	.LVL65:
 407:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 593              	 .loc 1 407 0
 594 019c 6461     	 str r4,[r4,#20]
 409:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocket->xSendBlockTime	= ipconfigSOCK_DEFAULT_SEND_BLOCK_TIME;
 595              	 .loc 1 409 0
 596 019e 41F28833 	 movw r3,#5000
 597 01a2 E361     	 str r3,[r4,#28]
 410:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocket->ucSocketOptions   = ( uint8_t ) FREERTOS_SO_UDPCKSUM_OUT;
 598              	 .loc 1 410 0
 599 01a4 2362     	 str r3,[r4,#32]
 411:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocket->ucProtocol		= ( uint8_t ) xProtocol; /* protocol: UDP or TCP or RAW */
 600              	 .loc 1 411 0
 601 01a6 0223     	 movs r3,#2
 602 01a8 84F82630 	 strb r3,[r4,#38]
 412:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocket->ucSocketType		= ( uint8_t ) xType;
 603              	 .loc 1 412 0
 604 01ac 1123     	 movs r3,#17
 605 01ae 84F82730 	 strb r3,[r4,#39]
 413:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 606              	 .loc 1 413 0
 607 01b2 84F82850 	 strb r5,[r4,#40]
 608              	.LVL66:
 609              	.L52:
 451:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
 610              	 .loc 1 451 0
 611 01b6 2046     	 mov r0,r4
 612 01b8 BDE8F081 	 pop {r4,r5,r6,r7,r8,pc}
 613              	.LVL67:
 614              	.L56:
 615              	 .align 2
 616              	.L55:
 617 01bc 00000000 	 .word .LANCHOR0
 618 01c0 00000000 	 .word .LANCHOR1
 619 01c4 00000000 	 .word xBoundTCPSocketsList
 620              	 .cfi_endproc
 621              	.LFE55:
 623              	 .section .text.FreeRTOS_CreateSocketSet,"ax",%progbits
 624              	 .align 2
 625              	 .global FreeRTOS_CreateSocketSet
 626              	 .thumb
 627              	 .thumb_func
 629              	FreeRTOS_CreateSocketSet:
 630              	.LFB56:
 457:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	SocketSelect_t *pxSocketSet;
 631              	 .loc 1 457 0
 632              	 .cfi_startproc
 633              	 
 634              	 
 635 0000 10B5     	 push {r4,lr}
 636              	.LCFI6:
 637              	 .cfi_def_cfa_offset 8
 638              	 .cfi_offset 4,-8
 639              	 .cfi_offset 14,-4
 460:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 640              	 .loc 1 460 0
 641 0002 0420     	 movs r0,#4
 642 0004 FFF7FEFF 	 bl pvPortMalloc
 643              	.LVL68:
 462:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 644              	 .loc 1 462 0
 645 0008 0446     	 mov r4,r0
 646 000a 80B1     	 cbz r0,.L58
 464:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pxSocketSet->xSelectGroup = xEventGroupCreate();
 647              	 .loc 1 464 0
 648 000c 0022     	 movs r2,#0
 649 000e 0346     	 mov r3,r0
 650 0010 03F8012B 	 strb r2,[r3],#1
 651 0014 4270     	 strb r2,[r0,#1]
 652 0016 0133     	 adds r3,r3,#1
 653 0018 03F8012B 	 strb r2,[r3],#1
 654 001c 1A70     	 strb r2,[r3]
 465:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 655              	 .loc 1 465 0
 656 001e FFF7FEFF 	 bl xEventGroupCreate
 657              	.LVL69:
 658 0022 2060     	 str r0,[r4]
 467:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 659              	 .loc 1 467 0
 660 0024 18B9     	 cbnz r0,.L58
 469:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocketSet = NULL;
 661              	 .loc 1 469 0
 662 0026 2046     	 mov r0,r4
 663 0028 FFF7FEFF 	 bl vPortFree
 664              	.LVL70:
 470:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 665              	 .loc 1 470 0
 666 002c 0024     	 movs r4,#0
 667              	.LVL71:
 668              	.L58:
 480:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 669              	 .loc 1 480 0
 670 002e 2046     	 mov r0,r4
 671 0030 10BD     	 pop {r4,pc}
 672              	 .cfi_endproc
 673              	.LFE56:
 675 0032 00BF     	 .section .text.FreeRTOS_DeleteSocketSet,"ax",%progbits
 676              	 .align 2
 677              	 .global FreeRTOS_DeleteSocketSet
 678              	 .thumb
 679              	 .thumb_func
 681              	FreeRTOS_DeleteSocketSet:
 682              	.LFB57:
 488:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		SocketSelect_t *pxSocketSet = ( SocketSelect_t*) xSocketSet;
 683              	 .loc 1 488 0
 684              	 .cfi_startproc
 685              	 
 686              	 
 687              	.LVL72:
 688 0000 10B5     	 push {r4,lr}
 689              	.LCFI7:
 690              	 .cfi_def_cfa_offset 8
 691              	 .cfi_offset 4,-8
 692              	 .cfi_offset 14,-4
 693 0002 0446     	 mov r4,r0
 694              	.LVL73:
 493:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		vPortFree( pxSocketSet );
 695              	 .loc 1 493 0
 696 0004 0068     	 ldr r0,[r0]
 697              	.LVL74:
 698 0006 FFF7FEFF 	 bl vEventGroupDelete
 699              	.LVL75:
 494:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 700              	 .loc 1 494 0
 701 000a 2046     	 mov r0,r4
 702 000c FFF7FEFF 	 bl vPortFree
 703              	.LVL76:
 704 0010 10BD     	 pop {r4,pc}
 705              	 .cfi_endproc
 706              	.LFE57:
 708 0012 00BF     	 .section .text.FreeRTOS_FD_SET,"ax",%progbits
 709              	 .align 2
 710              	 .global FreeRTOS_FD_SET
 711              	 .thumb
 712              	 .thumb_func
 714              	FreeRTOS_FD_SET:
 715              	.LFB58:
 504:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
 716              	 .loc 1 504 0
 717              	 .cfi_startproc
 718              	 
 719              	 
 720              	.LVL77:
 721 0000 08B5     	 push {r3,lr}
 722              	.LCFI8:
 723              	 .cfi_def_cfa_offset 8
 724              	 .cfi_offset 3,-8
 725              	 .cfi_offset 14,-4
 726              	.LVL78:
 508:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		configASSERT( xSocketSet != NULL );
 727              	 .loc 1 508 0
 728 0002 40B9     	 cbnz r0,.L63
 729              	.LBB204:
 730              	.LBB205:
 731              	 .loc 2 197 0
 732              	
 733 0004 4FF01403 	 mov r3,#20
 734 0008 83F31188 	 msr basepri,r3
 735 000c BFF36F8F 	 isb 
 736 0010 BFF34F8F 	 dsb 
 737              	
 738              	
 739              	.LVL79:
 740              	 .thumb
 741              	.L64:
 742              	.LBE205:
 743              	.LBE204:
 508:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		configASSERT( xSocketSet != NULL );
 744              	 .loc 1 508 0 discriminator 1
 745 0014 FEE7     	 b .L64
 746              	.L63:
 747 0016 0346     	 mov r3,r0
 509:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 748              	 .loc 1 509 0
 749 0018 41B9     	 cbnz r1,.L65
 750              	.LBB206:
 751              	.LBB207:
 752              	 .loc 2 197 0
 753              	
 754 001a 4FF01403 	 mov r3,#20
 755 001e 83F31188 	 msr basepri,r3
 756 0022 BFF36F8F 	 isb 
 757 0026 BFF34F8F 	 dsb 
 758              	
 759              	
 760              	.LVL80:
 761              	 .thumb
 762              	.L66:
 763              	.LBE207:
 764              	.LBE206:
 509:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 765              	 .loc 1 509 0 discriminator 2
 766 002a FEE7     	 b .L66
 767              	.L65:
 513:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 768              	 .loc 1 513 0
 769 002c 02F00F00 	 and r0,r2,#15
 770              	.LVL81:
 771 0030 1A6B     	 ldr r2,[r3,#48]
 772              	.LVL82:
 773 0032 0243     	 orrs r2,r2,r0
 774 0034 1A63     	 str r2,[r3,#48]
 515:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 775              	 .loc 1 515 0
 776 0036 12F00F0F 	 tst r2,#15
 777 003a 03D0     	 beq .L62
 778 003c 0846     	 mov r0,r1
 518:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 779              	 .loc 1 518 0
 780 003e D962     	 str r1,[r3,#44]
 522:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 781              	 .loc 1 522 0
 782 0040 FFF7FEFF 	 bl prvFindSelectedSocket
 783              	.LVL83:
 784              	.L62:
 785 0044 08BD     	 pop {r3,pc}
 786              	 .cfi_endproc
 787              	.LFE58:
 789 0046 00BF     	 .section .text.FreeRTOS_FD_CLR,"ax",%progbits
 790              	 .align 2
 791              	 .global FreeRTOS_FD_CLR
 792              	 .thumb
 793              	 .thumb_func
 795              	FreeRTOS_FD_CLR:
 796              	.LFB59:
 533:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
 797              	 .loc 1 533 0
 798              	 .cfi_startproc
 799              	 
 800              	 
 801              	 
 802              	.LVL84:
 536:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		configASSERT( xSocketSet != NULL );
 803              	 .loc 1 536 0
 804 0000 0346     	 mov r3,r0
 805 0002 40B9     	 cbnz r0,.L70
 806              	.LBB208:
 807              	.LBB209:
 808              	 .loc 2 197 0
 809              	
 810 0004 4FF01403 	 mov r3,#20
 811 0008 83F31188 	 msr basepri,r3
 812 000c BFF36F8F 	 isb 
 813 0010 BFF34F8F 	 dsb 
 814              	
 815              	
 816              	.LVL85:
 817              	 .thumb
 818              	.L71:
 819              	.LBE209:
 820              	.LBE208:
 536:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		configASSERT( xSocketSet != NULL );
 821              	 .loc 1 536 0 discriminator 1
 822 0014 FEE7     	 b .L71
 823              	.L70:
 537:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 824              	 .loc 1 537 0
 825 0016 41B9     	 cbnz r1,.L72
 826              	.LBB210:
 827              	.LBB211:
 828              	 .loc 2 197 0
 829              	
 830 0018 4FF01403 	 mov r3,#20
 831 001c 83F31188 	 msr basepri,r3
 832 0020 BFF36F8F 	 isb 
 833 0024 BFF34F8F 	 dsb 
 834              	
 835              	
 836              	.LVL86:
 837              	 .thumb
 838              	.L73:
 839              	.LBE211:
 840              	.LBE210:
 537:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 841              	 .loc 1 537 0 discriminator 2
 842 0028 FEE7     	 b .L73
 843              	.L72:
 539:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( ( pxSocket->xSelectBits & ( ( EventBits_t ) eSELECT_ALL ) ) != ( EventBits_t ) 0U )
 844              	 .loc 1 539 0
 845 002a 02F00F00 	 and r0,r2,#15
 846              	.LVL87:
 847 002e 1A6B     	 ldr r2,[r3,#48]
 848              	.LVL88:
 849 0030 22EA0002 	 bic r2,r2,r0
 850 0034 1A63     	 str r2,[r3,#48]
 540:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 851              	 .loc 1 540 0
 852 0036 12F00F0F 	 tst r2,#15
 542:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 853              	 .loc 1 542 0
 854 003a 12BF     	 itee ne
 855 003c D962     	 strne r1,[r3,#44]
 547:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 856              	 .loc 1 547 0
 857 003e 0022     	 moveq r2,#0
 858 0040 DA62     	 streq r2,[r3,#44]
 859 0042 7047     	 bx lr
 860              	 .cfi_endproc
 861              	.LFE59:
 863              	 .section .text.FreeRTOS_FD_ISSET,"ax",%progbits
 864              	 .align 2
 865              	 .global FreeRTOS_FD_ISSET
 866              	 .thumb
 867              	 .thumb_func
 869              	FreeRTOS_FD_ISSET:
 870              	.LFB60:
 559:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	EventBits_t xReturn;
 871              	 .loc 1 559 0
 872              	 .cfi_startproc
 873              	 
 874              	 
 875              	 
 876              	.LVL89:
 563:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		configASSERT( xSocketSet != NULL );
 877              	 .loc 1 563 0
 878 0000 40B9     	 cbnz r0,.L77
 879              	.LBB212:
 880              	.LBB213:
 881              	 .loc 2 197 0
 882              	
 883 0002 4FF01403 	 mov r3,#20
 884 0006 83F31188 	 msr basepri,r3
 885 000a BFF36F8F 	 isb 
 886 000e BFF34F8F 	 dsb 
 887              	
 888              	
 889              	.LVL90:
 890              	 .thumb
 891              	.L78:
 892              	.LBE213:
 893              	.LBE212:
 563:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		configASSERT( xSocketSet != NULL );
 894              	 .loc 1 563 0 discriminator 1
 895 0012 FEE7     	 b .L78
 896              	.L77:
 564:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 897              	 .loc 1 564 0
 898 0014 41B9     	 cbnz r1,.L79
 899              	.LBB214:
 900              	.LBB215:
 901              	 .loc 2 197 0
 902              	
 903 0016 4FF01403 	 mov r3,#20
 904 001a 83F31188 	 msr basepri,r3
 905 001e BFF36F8F 	 isb 
 906 0022 BFF34F8F 	 dsb 
 907              	
 908              	
 909              	.LVL91:
 910              	 .thumb
 911              	.L80:
 912              	.LBE215:
 913              	.LBE214:
 564:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 914              	 .loc 1 564 0 discriminator 2
 915 0026 FEE7     	 b .L80
 916              	.L79:
 566:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 917              	 .loc 1 566 0
 918 0028 C26A     	 ldr r2,[r0,#44]
 919 002a 8A42     	 cmp r2,r1
 570:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 920              	 .loc 1 570 0
 921 002c 06BF     	 itte eq
 922 002e 406B     	 ldreq r0,[r0,#52]
 923              	.LVL92:
 924 0030 00F00F00 	 andeq r0,r0,#15
 925              	.LVL93:
 574:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 926              	 .loc 1 574 0
 927 0034 0020     	 movne r0,#0
 928              	.LVL94:
 578:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 929              	 .loc 1 578 0
 930 0036 7047     	 bx lr
 931              	 .cfi_endproc
 932              	.LFE60:
 934              	 .section .text.FreeRTOS_select,"ax",%progbits
 935              	 .align 2
 936              	 .global FreeRTOS_select
 937              	 .thumb
 938              	 .thumb_func
 940              	FreeRTOS_select:
 941              	.LFB61:
 588:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	TimeOut_t xTimeOut;
 942              	 .loc 1 588 0
 943              	 .cfi_startproc
 944              	 
 945              	 
 946              	.LVL95:
 594:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 947              	 .loc 1 594 0
 948 0000 40B9     	 cbnz r0,.L84
 949              	.LBB216:
 950              	.LBB217:
 951              	 .loc 2 197 0
 952              	
 953 0002 4FF01403 	 mov r3,#20
 954 0006 83F31188 	 msr basepri,r3
 955 000a BFF36F8F 	 isb 
 956 000e BFF34F8F 	 dsb 
 957              	
 958              	
 959              	.LVL96:
 960              	 .thumb
 961              	.L85:
 962              	.LBE217:
 963              	.LBE216:
 594:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 964              	 .loc 1 594 0 discriminator 1
 965 0012 FEE7     	 b .L85
 966              	.L84:
 588:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	TimeOut_t xTimeOut;
 967              	 .loc 1 588 0
 968 0014 F0B5     	 push {r4,r5,r6,r7,lr}
 969              	.LCFI9:
 970              	 .cfi_def_cfa_offset 20
 971              	 .cfi_offset 4,-20
 972              	 .cfi_offset 5,-16
 973              	 .cfi_offset 6,-12
 974              	 .cfi_offset 7,-8
 975              	 .cfi_offset 14,-4
 976 0016 87B0     	 sub sp,sp,#28
 977              	.LCFI10:
 978              	 .cfi_def_cfa_offset 48
 979 0018 0446     	 mov r4,r0
 597:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 980              	 .loc 1 597 0
 981 001a 0391     	 str r1,[sp,#12]
 600:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 982              	 .loc 1 600 0
 983 001c 04A8     	 add r0,sp,#16
 984              	.LVL97:
 985 001e FFF7FEFF 	 bl vTaskSetTimeOutState
 986              	.LVL98:
 606:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 987              	 .loc 1 606 0
 988 0022 0F27     	 movs r7,#15
 989 0024 0026     	 movs r6,#0
 990              	.L88:
 991 0026 2068     	 ldr r0,[r4]
 992 0028 039B     	 ldr r3,[sp,#12]
 993 002a 0093     	 str r3,[sp]
 994 002c 3946     	 mov r1,r7
 995 002e 3246     	 mov r2,r6
 996 0030 3346     	 mov r3,r6
 997 0032 FFF7FEFF 	 bl xEventGroupWaitBits
 998              	.LVL99:
 999 0036 0546     	 mov r5,r0
 1000              	.LVL100:
 610:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 1001              	 .loc 1 610 0
 1002 0038 10F0080F 	 tst r0,#8
 1003 003c 04D0     	 beq .L86
 612:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					FreeRTOS_debug_printf( ( "FreeRTOS_select: interrupted\n" ) );
 1004              	 .loc 1 612 0
 1005 003e 2068     	 ldr r0,[r4]
 1006              	.LVL101:
 1007 0040 0821     	 movs r1,#8
 1008 0042 FFF7FEFF 	 bl xEventGroupClearBits
 1009              	.LVL102:
 614:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 1010              	 .loc 1 614 0
 1011 0046 0EE0     	 b .L87
 1012              	.LVL103:
 1013              	.L86:
 620:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 1014              	 .loc 1 620 0
 1015 0048 2046     	 mov r0,r4
 1016              	.LVL104:
 1017 004a FFF7FEFF 	 bl prvFindSelectedSocket
 1018              	.LVL105:
 622:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 1019              	 .loc 1 622 0
 1020 004e 2068     	 ldr r0,[r4]
 1021 0050 3146     	 mov r1,r6
 1022 0052 FFF7FEFF 	 bl xEventGroupClearBits
 1023              	.LVL106:
 624:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 1024              	 .loc 1 624 0
 1025 0056 0546     	 mov r5,r0
 1026 0058 28B9     	 cbnz r0,.L87
 630:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 1027              	 .loc 1 630 0
 1028 005a 04A8     	 add r0,sp,#16
 1029              	.LVL107:
 1030 005c 03A9     	 add r1,sp,#12
 1031 005e FFF7FEFF 	 bl xTaskCheckForTimeOut
 1032              	.LVL108:
 1033 0062 0028     	 cmp r0,#0
 1034 0064 DFD0     	 beq .L88
 1035              	.L87:
 637:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 1036              	 .loc 1 637 0
 1037 0066 2846     	 mov r0,r5
 1038 0068 07B0     	 add sp,sp,#28
 1039              	.LCFI11:
 1040              	 .cfi_def_cfa_offset 20
 1041              	 
 1042 006a F0BD     	 pop {r4,r5,r6,r7,pc}
 1043              	 .cfi_endproc
 1044              	.LFE61:
 1046              	 .section .text.FreeRTOS_recvfrom,"ax",%progbits
 1047              	 .align 2
 1048              	 .global FreeRTOS_recvfrom
 1049              	 .thumb
 1050              	 .thumb_func
 1052              	FreeRTOS_recvfrom:
 1053              	.LFB63:
 702:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** BaseType_t lPacketCount;
 1054              	 .loc 1 702 0
 1055              	 .cfi_startproc
 1056              	 
 1057              	 
 1058              	.LVL109:
 1059 0000 2DE9F04F 	 push {r4,r5,r6,r7,r8,r9,r10,fp,lr}
 1060              	.LCFI12:
 1061              	 .cfi_def_cfa_offset 36
 1062              	 .cfi_offset 4,-36
 1063              	 .cfi_offset 5,-32
 1064              	 .cfi_offset 6,-28
 1065              	 .cfi_offset 7,-24
 1066              	 .cfi_offset 8,-20
 1067              	 .cfi_offset 9,-16
 1068              	 .cfi_offset 10,-12
 1069              	 .cfi_offset 11,-8
 1070              	 .cfi_offset 14,-4
 1071 0004 89B0     	 sub sp,sp,#36
 1072              	.LCFI13:
 1073              	 .cfi_def_cfa_offset 72
 1074 0006 0446     	 mov r4,r0
 1075 0008 0391     	 str r1,[sp,#12]
 1076 000a 9346     	 mov fp,r2
 1077 000c 9946     	 mov r9,r3
 1078              	.LVL110:
 707:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** BaseType_t xTimed = pdFALSE;
 1079              	 .loc 1 707 0
 1080 000e 0023     	 movs r3,#0
 1081              	.LVL111:
 1082 0010 0793     	 str r3,[sp,#28]
 1083              	.LVL112:
 715:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 1084              	 .loc 1 715 0
 1085 0012 1121     	 movs r1,#17
 1086              	.LVL113:
 1087 0014 0122     	 movs r2,#1
 1088              	.LVL114:
 1089 0016 FFF7FEFF 	 bl prvValidSocket
 1090              	.LVL115:
 1091 001a 0028     	 cmp r0,#0
 1092 001c 00F08980 	 beq .L111
 721:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 1093              	 .loc 1 721 0
 1094 0020 94F82830 	 ldrb r3,[r4,#40]
 1095 0024 022B     	 cmp r3,#2
 1096 0026 01D1     	 bne .L93
 723:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 1097              	 .loc 1 723 0
 1098 0028 A56B     	 ldr r5,[r4,#56]
 1099              	.LVL116:
 1100 002a 41E0     	 b .L94
 1101              	.LVL117:
 1102              	.L93:
 725:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 1103              	 .loc 1 725 0
 1104 002c 032B     	 cmp r3,#3
 1105 002e 3FD1     	 bne .L94
 727:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 1106              	 .loc 1 727 0
 1107 0030 A56B     	 ldr r5,[r4,#56]
 1108              	.LVL118:
 1109 0032 3DE0     	 b .L94
 1110              	.L113:
 735:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 1111              	 .loc 1 735 0
 1112 0034 0025     	 movs r5,#0
 1113              	.LVL119:
 1114 0036 2E46     	 mov r6,r5
 755:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 1115              	 .loc 1 755 0
 1116 0038 09F01008 	 and r8,r9,#16
 761:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 1117              	 .loc 1 761 0
 1118 003c 0127     	 movs r7,#1
 1119              	.LVL120:
 1120              	.L104:
 737:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 1121              	 .loc 1 737 0
 1122 003e 8EB9     	 cbnz r6,.L95
 1123              	.LVL121:
 741:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 1124              	 .loc 1 741 0
 1125 0040 E369     	 ldr r3,[r4,#28]
 1126 0042 0793     	 str r3,[sp,#28]
 743:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 1127              	 .loc 1 743 0
 1128 0044 3BB9     	 cbnz r3,.L96
 748:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							pdTRUE /*xClearOnExit*/, pdFALSE /*xWaitAllBits*/, socketDONT_BLOCK );
 1129              	 .loc 1 748 0
 1130 0046 6068     	 ldr r0,[r4,#4]
 1131 0048 0093     	 str r3,[sp]
 1132 004a 4021     	 movs r1,#64
 1133 004c 0122     	 movs r2,#1
 1134 004e FFF7FEFF 	 bl xEventGroupWaitBits
 1135              	.LVL122:
 1136 0052 0546     	 mov r5,r0
 752:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 1137              	 .loc 1 752 0
 1138 0054 2FE0     	 b .L97
 1139              	.LVL123:
 1140              	.L96:
 755:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 1141              	 .loc 1 755 0
 1142 0056 B8F1000F 	 cmp r8,#0
 1143 005a 2CD1     	 bne .L97
 1144              	.LVL124:
 764:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 1145              	 .loc 1 764 0
 1146 005c 05A8     	 add r0,sp,#20
 1147 005e FFF7FEFF 	 bl vTaskSetTimeOutState
 1148              	.LVL125:
 761:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 1149              	 .loc 1 761 0
 1150 0062 3E46     	 mov r6,r7
 1151              	.LVL126:
 1152              	.L95:
 770:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pdTRUE /*xClearOnExit*/, pdFALSE /*xWaitAllBits*/, xRemainingTime );
 1153              	 .loc 1 770 0
 1154 0064 079B     	 ldr r3,[sp,#28]
 1155 0066 0093     	 str r3,[sp]
 1156 0068 6068     	 ldr r0,[r4,#4]
 1157 006a 4121     	 movs r1,#65
 1158 006c 3A46     	 mov r2,r7
 1159 006e 0023     	 movs r3,#0
 1160 0070 FFF7FEFF 	 bl xEventGroupWaitBits
 1161              	.LVL127:
 1162 0074 0546     	 mov r5,r0
 775:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 1163              	 .loc 1 775 0
 1164 0076 10F0400F 	 tst r0,#64
 1165 007a 07D0     	 beq .L98
 777:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 1166              	 .loc 1 777 0
 1167 007c 10F0010F 	 tst r0,#1
 1168 0080 64D0     	 beq .L99
 780:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
 1169              	 .loc 1 780 0
 1170 0082 6068     	 ldr r0,[r4,#4]
 1171              	.LVL128:
 1172 0084 0121     	 movs r1,#1
 1173 0086 FFF7FEFF 	 bl xEventGroupSetBits
 1174              	.LVL129:
 1175 008a 5FE0     	 b .L99
 1176              	.LVL130:
 1177              	.L98:
 791:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 1178              	 .loc 1 791 0
 1179 008c 94F82830 	 ldrb r3,[r4,#40]
 1180 0090 022B     	 cmp r3,#2
 1181 0092 01D1     	 bne .L100
 793:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 1182              	 .loc 1 793 0
 1183 0094 A36B     	 ldr r3,[r4,#56]
 1184              	.LVL131:
 1185 0096 02E0     	 b .L101
 1186              	.LVL132:
 1187              	.L100:
 795:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 1188              	 .loc 1 795 0
 1189 0098 032B     	 cmp r3,#3
 1190 009a 02D1     	 bne .L102
 797:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 1191              	 .loc 1 797 0
 1192 009c A36B     	 ldr r3,[r4,#56]
 1193              	.LVL133:
 1194              	.L101:
 801:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 1195              	 .loc 1 801 0
 1196 009e 002B     	 cmp r3,#0
 1197 00a0 4DD1     	 bne .L103
 1198              	.LVL134:
 1199              	.L102:
 807:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 1200              	 .loc 1 807 0
 1201 00a2 05A8     	 add r0,sp,#20
 1202              	.LVL135:
 1203 00a4 07A9     	 add r1,sp,#28
 1204 00a6 FFF7FEFF 	 bl xTaskCheckForTimeOut
 1205              	.LVL136:
 1206 00aa 0028     	 cmp r0,#0
 1207 00ac C7D0     	 beq .L104
 1208 00ae 43E0     	 b .L112
 1209              	.LVL137:
 1210              	.L94:
 735:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 1211              	 .loc 1 735 0
 1212 00b0 002D     	 cmp r5,#0
 1213 00b2 BFD0     	 beq .L113
 1214 00b4 43E0     	 b .L103
 1215              	.LVL138:
 1216              	.L97:
 881:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 1217              	 .loc 1 881 0
 1218 00b6 05F04005 	 and r5,r5,#64
 889:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			iptraceRECVFROM_TIMEOUT();
 1219              	 .loc 1 889 0
 1220 00ba 002D     	 cmp r5,#0
 1221 00bc 14BF     	 ite ne
 1222 00be 6FF00304 	 mvnne r4,#3
 1223              	.LVL139:
 1224 00c2 6FF00A04 	 mvneq r4,#10
 1225 00c6 43E0     	 b .L115
 1226              	.LVL140:
 1227              	.L109:
 820:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 1228              	 .loc 1 820 0
 1229 00c8 636C     	 ldr r3,[r4,#68]
 1230 00ca D3F80CA0 	 ldr r10,[r3,#12]
 1231              	.LVL141:
 1232 00ce 04E0     	 b .L105
 1233              	.LVL142:
 1234              	.L116:
 822:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 1235              	 .loc 1 822 0
 1236 00d0 032B     	 cmp r3,#3
 824:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 1237              	 .loc 1 824 0
 1238 00d2 04BF     	 itt eq
 1239 00d4 636C     	 ldreq r3,[r4,#68]
 1240 00d6 D3F80CA0 	 ldreq r10,[r3,#12]
 1241              	.LVL143:
 1242              	.L105:
 828:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 1243              	 .loc 1 828 0
 1244 00da 19F00405 	 ands r5,r9,#4
 1245 00de 02D1     	 bne .L106
 832:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 1246              	 .loc 1 832 0
 1247 00e0 5046     	 mov r0,r10
 1248 00e2 FFF7FEFF 	 bl uxListRemove
 1249              	.LVL144:
 1250              	.L106:
 835:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 1251              	 .loc 1 835 0
 1252 00e6 FFF7FEFF 	 bl vPortExitCritical
 1253              	.LVL145:
 841:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			lReturn = ( int32_t ) uxPayloadLength;
 1254              	 .loc 1 841 0
 1255 00ea DAF81C40 	 ldr r4,[r10,#28]
 1256              	.LVL146:
 1257 00ee 2A3C     	 subs r4,r4,#42
 1258              	.LVL147:
 844:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 1259              	 .loc 1 844 0
 1260 00f0 129B     	 ldr r3,[sp,#72]
 1261 00f2 33B1     	 cbz r3,.L107
 846:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSourceAddress->sin_addr = pxNetworkBuffer->ulIPAddress;
 1262              	 .loc 1 846 0
 1263 00f4 BAF82030 	 ldrh r3,[r10,#32]
 1264 00f8 129A     	 ldr r2,[sp,#72]
 1265 00fa 5380     	 strh r3,[r2,#2]
 847:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 1266              	 .loc 1 847 0
 1267 00fc DAF81430 	 ldr r3,[r10,#20]
 1268 0100 5360     	 str r3,[r2,#4]
 1269              	.L107:
 850:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 1270              	 .loc 1 850 0
 1271 0102 19F0010F 	 tst r9,#1
 1272 0106 0ED1     	 bne .L108
 1273 0108 5C45     	 cmp r4,fp
 1274 010a A8BF     	 it ge
 1275 010c 5C46     	 movge r4,fp
 1276              	.LVL148:
 862:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				( void ) memcpy( pvBuffer, pvCopySource, ( size_t )lReturn );
 1277              	 .loc 1 862 0
 1278 010e DAF81810 	 ldr r1,[r10,#24]
 863:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 1279              	 .loc 1 863 0
 1280 0112 0398     	 ldr r0,[sp,#12]
 1281 0114 2A31     	 adds r1,r1,#42
 1282              	.LVL149:
 1283 0116 2246     	 mov r2,r4
 1284 0118 FFF7FEFF 	 bl memcpy
 1285              	.LVL150:
 865:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 1286              	 .loc 1 865 0
 1287 011c C5B9     	 cbnz r5,.L115
 867:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 1288              	 .loc 1 867 0
 1289 011e 5046     	 mov r0,r10
 1290 0120 FFF7FEFF 	 bl vReleaseNetworkBufferAndDescriptor
 1291              	.LVL151:
 1292 0124 14E0     	 b .L115
 1293              	.LVL152:
 1294              	.L108:
 876:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 1295              	 .loc 1 876 0
 1296 0126 DAF81830 	 ldr r3,[r10,#24]
 1297 012a 2A33     	 adds r3,r3,#42
 1298 012c 039A     	 ldr r2,[sp,#12]
 1299 012e 1360     	 str r3,[r2]
 1300 0130 0EE0     	 b .L115
 1301              	.LVL153:
 1302              	.L111:
 717:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 1303              	 .loc 1 717 0
 1304 0132 6FF01504 	 mvn r4,#21
 1305              	.LVL154:
 1306 0136 0BE0     	 b .L115
 1307              	.LVL155:
 1308              	.L112:
 889:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			iptraceRECVFROM_TIMEOUT();
 1309              	 .loc 1 889 0
 1310 0138 6FF00A04 	 mvn r4,#10
 1311              	.LVL156:
 1312 013c 08E0     	 b .L115
 1313              	.LVL157:
 1314              	.L103:
 815:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 1315              	 .loc 1 815 0
 1316 013e FFF7FEFF 	 bl vPortEnterCritical
 1317              	.LVL158:
 818:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 1318              	 .loc 1 818 0
 1319 0142 94F82830 	 ldrb r3,[r4,#40]
 1320 0146 022B     	 cmp r3,#2
 1321 0148 C2D1     	 bne .L116
 1322 014a BDE7     	 b .L109
 1323              	.LVL159:
 1324              	.L99:
 883:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			iptraceRECVFROM_INTERRUPTED();
 1325              	 .loc 1 883 0
 1326 014c 6FF00304 	 mvn r4,#3
 1327              	.LVL160:
 1328              	.L115:
 895:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
 1329              	 .loc 1 895 0
 1330 0150 2046     	 mov r0,r4
 1331 0152 09B0     	 add sp,sp,#36
 1332              	.LCFI14:
 1333              	 .cfi_def_cfa_offset 36
 1334              	 
 1335 0154 BDE8F08F 	 pop {r4,r5,r6,r7,r8,r9,r10,fp,pc}
 1336              	 .cfi_endproc
 1337              	.LFE63:
 1339              	 .section .text.FreeRTOS_bind,"ax",%progbits
 1340              	 .align 2
 1341              	 .global FreeRTOS_bind
 1342              	 .thumb
 1343              	 .thumb_func
 1345              	FreeRTOS_bind:
 1346              	.LFB65:
1080:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** IPStackEvent_t xBindEvent;
 1347              	 .loc 1 1080 0
 1348              	 .cfi_startproc
 1349              	 
 1350              	 
 1351              	.LVL161:
 1352 0000 30B5     	 push {r4,r5,lr}
 1353              	.LCFI15:
 1354              	 .cfi_def_cfa_offset 12
 1355              	 .cfi_offset 4,-12
 1356              	 .cfi_offset 5,-8
 1357              	 .cfi_offset 14,-4
 1358 0002 85B0     	 sub sp,sp,#20
 1359              	.LCFI16:
 1360              	 .cfi_def_cfa_offset 32
 1361 0004 0446     	 mov r4,r0
 1362 0006 0D46     	 mov r5,r1
 1363              	.LVL162:
1087:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 1364              	 .loc 1 1087 0
 1365 0008 FFF7FEFF 	 bl xIsCallingFromIPTask
 1366              	.LVL163:
 1367 000c 40B1     	 cbz r0,.L119
 1368              	.LBB218:
 1369              	.LBB219:
 1370              	 .loc 2 197 0
 1371              	
 1372 000e 4FF01403 	 mov r3,#20
 1373 0012 83F31188 	 msr basepri,r3
 1374 0016 BFF36F8F 	 isb 
 1375 001a BFF34F8F 	 dsb 
 1376              	
 1377              	
 1378              	.LVL164:
 1379              	 .thumb
 1380              	.L120:
 1381              	.LBE219:
 1382              	.LBE218:
1087:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 1383              	 .loc 1 1087 0 discriminator 1
 1384 001e FEE7     	 b .L120
 1385              	.L119:
1089:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 1386              	 .loc 1 1089 0
 1387 0020 631E     	 subs r3,r4,#1
 1388 0022 13F1030F 	 cmn r3,#3
 1389 0026 24D8     	 bhi .L124
1095:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 1390              	 .loc 1 1095 0
 1391 0028 A369     	 ldr r3,[r4,#24]
 1392 002a 2BBB     	 cbnz r3,.L125
1105:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		xBindEvent.pvData = xSocket;
 1393              	 .loc 1 1105 0
 1394 002c 0923     	 movs r3,#9
 1395 002e 8DF80830 	 strb r3,[sp,#8]
1106:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( pxAddress != NULL )
 1396              	 .loc 1 1106 0
 1397 0032 0394     	 str r4,[sp,#12]
1107:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 1398              	 .loc 1 1107 0
 1399 0034 2DB1     	 cbz r5,.L122
1109:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 1400              	 .loc 1 1109 0
 1401 0036 6A88     	 ldrh r2,[r5,#2]
 1402 0038 130A     	 lsrs r3,r2,#8
 1403 003a 43EA0223 	 orr r3,r3,r2,lsl#8
 1404 003e A384     	 strh r3,[r4,#36]
 1405 0040 01E0     	 b .L123
 1406              	.L122:
1114:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 1407              	 .loc 1 1114 0
 1408 0042 0023     	 movs r3,#0
 1409 0044 A384     	 strh r3,[r4,#36]
 1410              	.L123:
1120:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 1411              	 .loc 1 1120 0
 1412 0046 02A8     	 add r0,sp,#8
 1413 0048 4FF6FF71 	 movw r1,#65535
 1414 004c FFF7FEFF 	 bl xSendEventStructToIPTask
 1415              	.LVL165:
 1416 0050 A8B1     	 cbz r0,.L126
1130:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( !socketSOCKET_IS_BOUND( pxSocket ) )
 1417              	 .loc 1 1130 0
 1418 0052 4FF0FF33 	 mov r3,#-1
 1419 0056 0093     	 str r3,[sp]
 1420 0058 6068     	 ldr r0,[r4,#4]
 1421 005a 1021     	 movs r1,#16
 1422 005c 0122     	 movs r2,#1
 1423 005e 0023     	 movs r3,#0
 1424 0060 FFF7FEFF 	 bl xEventGroupWaitBits
 1425              	.LVL166:
1131:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 1426              	 .loc 1 1131 0
 1427 0064 A369     	 ldr r3,[r4,#24]
1133:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 1428              	 .loc 1 1133 0
 1429 0066 002B     	 cmp r3,#0
 1430 0068 14BF     	 ite ne
 1431 006a 0020     	 movne r0,#0
 1432 006c 6FF01500 	 mvneq r0,#21
 1433 0070 07E0     	 b .L121
 1434              	.L124:
1091:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 1435              	 .loc 1 1091 0
 1436 0072 6FF01500 	 mvn r0,#21
 1437 0076 04E0     	 b .L121
 1438              	.L125:
1099:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 1439              	 .loc 1 1099 0
 1440 0078 6FF01500 	 mvn r0,#21
 1441 007c 01E0     	 b .L121
 1442              	.L126:
1124:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 1443              	 .loc 1 1124 0
 1444 007e 6FF08B00 	 mvn r0,#139
 1445              	.L121:
 1446              	.LVL167:
1139:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 1447              	 .loc 1 1139 0
 1448 0082 05B0     	 add sp,sp,#20
 1449              	.LCFI17:
 1450              	 .cfi_def_cfa_offset 12
 1451              	 
 1452 0084 30BD     	 pop {r4,r5,pc}
 1453              	 .cfi_endproc
 1454              	.LFE65:
 1456 0086 00BF     	 .section .text.FreeRTOS_sendto,"ax",%progbits
 1457              	 .align 2
 1458              	 .global FreeRTOS_sendto
 1459              	 .thumb
 1460              	 .thumb_func
 1462              	FreeRTOS_sendto:
 1463              	.LFB64:
 899:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** NetworkBufferDescriptor_t *pxNetworkBuffer;
 1464              	 .loc 1 899 0
 1465              	 .cfi_startproc
 1466              	 
 1467              	 
 1468              	.LVL168:
 1469 0000 2DE9F047 	 push {r4,r5,r6,r7,r8,r9,r10,lr}
 1470              	.LCFI18:
 1471              	 .cfi_def_cfa_offset 32
 1472              	 .cfi_offset 4,-32
 1473              	 .cfi_offset 5,-28
 1474              	 .cfi_offset 6,-24
 1475              	 .cfi_offset 7,-20
 1476              	 .cfi_offset 8,-16
 1477              	 .cfi_offset 9,-12
 1478              	 .cfi_offset 10,-8
 1479              	 .cfi_offset 14,-4
 1480 0004 86B0     	 sub sp,sp,#24
 1481              	.LCFI19:
 1482              	 .cfi_def_cfa_offset 56
 1483 0006 DDF838A0 	 ldr r10,[sp,#56]
 902:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** TimeOut_t xTimeOut;
 1484              	 .loc 1 902 0
 1485 000a 0424     	 movs r4,#4
 1486 000c 8DF81040 	 strb r4,[sp,#16]
 1487 0010 0024     	 movs r4,#0
 1488 0012 0594     	 str r4,[sp,#20]
 1489              	.LVL169:
 914:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	configASSERT( xSocket != NULL );
 1490              	 .loc 1 914 0
 1491 0014 41B9     	 cbnz r1,.L130
 1492              	.LBB220:
 1493              	.LBB221:
 1494              	 .loc 2 197 0
 1495              	
 1496 0016 4FF01403 	 mov r3,#20
 1497 001a 83F31188 	 msr basepri,r3
 1498 001e BFF36F8F 	 isb 
 1499 0022 BFF34F8F 	 dsb 
 1500              	
 1501              	
 1502              	.LVL170:
 1503              	 .thumb
 1504              	.L131:
 1505              	.LBE221:
 1506              	.LBE220:
 914:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	configASSERT( xSocket != NULL );
 1507              	 .loc 1 914 0 discriminator 1
 1508 0026 FEE7     	 b .L131
 1509              	.LVL171:
 1510              	.L130:
 1511 0028 8846     	 mov r8,r1
 915:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 1512              	 .loc 1 915 0
 1513 002a 40B9     	 cbnz r0,.L132
 1514              	.LBB222:
 1515              	.LBB223:
 1516              	 .loc 2 197 0
 1517              	
 1518 002c 4FF01403 	 mov r3,#20
 1519 0030 83F31188 	 msr basepri,r3
 1520 0034 BFF36F8F 	 isb 
 1521 0038 BFF34F8F 	 dsb 
 1522              	
 1523              	
 1524              	.LVL172:
 1525              	 .thumb
 1526              	.L133:
 1527              	.LBE223:
 1528              	.LBE222:
 915:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 1529              	 .loc 1 915 0 discriminator 2
 1530 003c FEE7     	 b .L133
 1531              	.LVL173:
 1532              	.L132:
 920:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 1533              	 .loc 1 920 0
 1534 003e 90F82810 	 ldrb r1,[r0,#40]
 1535              	.LVL174:
 1536 0042 0329     	 cmp r1,#3
 1537 0044 07D1     	 bne .L146
 922:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		uxPayloadOffset = ( size_t ) 0;
 1538              	 .loc 1 922 0
 1539 0046 0D21     	 movs r1,#13
 1540 0048 8DF81010 	 strb r1,[sp,#16]
 1541              	.LVL175:
 923:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		uxMaxPayloadLength = ( size_t ) ipMAX_RAW_PAYLOAD_LENGTH;
 1542              	 .loc 1 923 0
 1543 004c 4FF00009 	 mov r9,#0
 924:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 1544              	 .loc 1 924 0
 1545 0050 4FF49661 	 mov r1,#1200
 1546 0054 03E0     	 b .L134
 1547              	.LVL176:
 1548              	.L146:
 908:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 1549              	 .loc 1 908 0
 1550 0056 4FF02A09 	 mov r9,#42
 907:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** size_t uxPayloadOffset = ( size_t ) ipUDP_PAYLOAD_OFFSET_IPv4;
 1551              	 .loc 1 907 0
 1552 005a 40F29441 	 movw r1,#1172
 1553              	.LVL177:
 1554              	.L134:
 930:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 1555              	 .loc 1 930 0
 1556 005e 9142     	 cmp r1,r2
 1557 0060 5ED3     	 bcc .L147
 1558 0062 1F46     	 mov r7,r3
 1559 0064 1446     	 mov r4,r2
 1560 0066 0646     	 mov r6,r0
 935:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			( FreeRTOS_bind( xSocket, NULL, 0U ) == 0 ) )
 1561              	 .loc 1 935 0
 1562 0068 8369     	 ldr r3,[r0,#24]
 1563              	.LVL178:
 1564 006a 2BB9     	 cbnz r3,.L136
 936:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 1565              	 .loc 1 936 0 discriminator 1
 1566 006c 0021     	 movs r1,#0
 1567              	.LVL179:
 1568 006e 0A46     	 mov r2,r1
 1569              	.LVL180:
 1570 0070 FFF7FEFF 	 bl FreeRTOS_bind
 1571              	.LVL181:
 935:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			( FreeRTOS_bind( xSocket, NULL, 0U ) == 0 ) )
 1572              	 .loc 1 935 0 discriminator 1
 1573 0074 0028     	 cmp r0,#0
 1574 0076 55D1     	 bne .L148
 1575              	.L136:
 938:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 1576              	 .loc 1 938 0
 1577 0078 336A     	 ldr r3,[r6,#32]
 952:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 1578              	 .loc 1 952 0
 1579 007a 17F0100F 	 tst r7,#16
 954:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 1580              	 .loc 1 954 0
 1581 007e 18BF     	 it ne
 1582 0080 0023     	 movne r3,#0
 1583 0082 0193     	 str r3,[sp,#4]
 957:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 1584              	 .loc 1 957 0
 1585 0084 17F00107 	 ands r7,r7,#1
 1586              	.LVL182:
 1587 0088 19D1     	 bne .L139
 961:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 1588              	 .loc 1 961 0
 1589 008a 02A8     	 add r0,sp,#8
 1590 008c FFF7FEFF 	 bl vTaskSetTimeOutState
 1591              	.LVL183:
 965:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 1592              	 .loc 1 965 0
 1593 0090 09EB0400 	 add r0,r9,r4
 1594 0094 0199     	 ldr r1,[sp,#4]
 1595 0096 FFF7FEFF 	 bl pxGetNetworkBufferWithDescriptor
 1596              	.LVL184:
 967:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 1597              	 .loc 1 967 0
 1598 009a 0546     	 mov r5,r0
 1599 009c 0028     	 cmp r0,#0
 1600 009e 43D0     	 beq .L149
 1601              	.LVL185:
 969:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					( void ) memcpy( pvCopyDest, pvBuffer, uxTotalDataLength );
 1602              	 .loc 1 969 0
 1603 00a0 8069     	 ldr r0,[r0,#24]
 1604              	.LVL186:
 970:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 1605              	 .loc 1 970 0
 1606 00a2 4844     	 add r0,r0,r9
 1607              	.LVL187:
 1608 00a4 4146     	 mov r1,r8
 1609 00a6 2246     	 mov r2,r4
 1610 00a8 FFF7FEFF 	 bl memcpy
 1611              	.LVL188:
 972:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 1612              	 .loc 1 972 0
 1613 00ac 02A8     	 add r0,sp,#8
 1614 00ae 01A9     	 add r1,sp,#4
 1615 00b0 FFF7FEFF 	 bl xTaskCheckForTimeOut
 1616              	.LVL189:
 1617 00b4 0128     	 cmp r0,#1
 1618 00b6 0BD1     	 bne .L145
 975:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
 1619              	 .loc 1 975 0
 1620 00b8 0023     	 movs r3,#0
 1621 00ba 0193     	 str r3,[sp,#4]
 1622 00bc 08E0     	 b .L145
 1623              	.LVL190:
 1624              	.L139:
 981:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 1625              	 .loc 1 981 0
 1626 00be 9DF91030 	 ldrsb r3,[sp,#16]
 1627 00c2 0D2B     	 cmp r3,#13
 1628 00c4 03D0     	 beq .L141
 990:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 1629              	 .loc 1 990 0
 1630 00c6 4046     	 mov r0,r8
 1631 00c8 FFF7FEFF 	 bl pxUDPPayloadBuffer_to_NetworkBuffer
 1632              	.LVL191:
 1633 00cc 0546     	 mov r5,r0
 1634              	.LVL192:
 1635              	.L141:
 994:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 1636              	 .loc 1 994 0
 1637 00ce 6DB3     	 cbz r5,.L150
 1638              	.L145:
 996:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 1639              	 .loc 1 996 0
 1640 00d0 96F82830 	 ldrb r3,[r6,#40]
 1641 00d4 032B     	 cmp r3,#3
 1642 00d6 01D1     	 bne .L142
1000:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 1643              	 .loc 1 1000 0
 1644 00d8 EC61     	 str r4,[r5,#28]
 1645 00da 06E0     	 b .L143
 1646              	.L142:
1005:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 1647              	 .loc 1 1005 0
 1648 00dc 96F82730 	 ldrb r3,[r6,#39]
 1649 00e0 112B     	 cmp r3,#17
1007:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
 1650              	 .loc 1 1007 0
 1651 00e2 04BF     	 itt eq
 1652 00e4 04F12A03 	 addeq r3,r4,#42
 1653 00e8 EB61     	 streq r3,[r5,#28]
 1654              	.L143:
1011:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxNetworkBuffer->usBoundPort = ( uint16_t ) socketGET_SOCKET_PORT( pxSocket );
 1655              	 .loc 1 1011 0
 1656 00ea BAF80230 	 ldrh r3,[r10,#2]
 1657 00ee 2B84     	 strh r3,[r5,#32]
1012:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxNetworkBuffer->ulIPAddress = pxDestinationAddress->sin_addr;
 1658              	 .loc 1 1012 0
 1659 00f0 B368     	 ldr r3,[r6,#8]
 1660 00f2 6B84     	 strh r3,[r5,#34]
1013:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 1661              	 .loc 1 1013 0
 1662 00f4 DAF80430 	 ldr r3,[r10,#4]
 1663 00f8 6B61     	 str r3,[r5,#20]
1017:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 1664              	 .loc 1 1017 0
 1665 00fa AB69     	 ldr r3,[r5,#24]
 1666 00fc 96F82620 	 ldrb r2,[r6,#38]
 1667 0100 9A71     	 strb r2,[r3,#6]
1020:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 1668              	 .loc 1 1020 0
 1669 0102 0595     	 str r5,[sp,#20]
1023:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 1670              	 .loc 1 1023 0
 1671 0104 04A8     	 add r0,sp,#16
 1672 0106 0199     	 ldr r1,[sp,#4]
 1673 0108 FFF7FEFF 	 bl xSendEventStructToIPTask
 1674              	.LVL193:
 1675 010c 0128     	 cmp r0,#1
 1676 010e 01D1     	 bne .L144
1026:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					#if( ipconfigUSE_CALLBACKS == 1 )
 1677              	 .loc 1 1026 0
 1678 0110 2046     	 mov r0,r4
 1679              	.LVL194:
 1680 0112 0EE0     	 b .L135
 1681              	.LVL195:
 1682              	.L144:
1040:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 1683              	 .loc 1 1040 0
 1684 0114 67B9     	 cbnz r7,.L151
1042:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
 1685              	 .loc 1 1042 0
 1686 0116 2846     	 mov r0,r5
 1687 0118 FFF7FEFF 	 bl vReleaseNetworkBufferAndDescriptor
 1688              	.LVL196:
 905:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** FreeRTOS_Socket_t const * pxSocket;
 1689              	 .loc 1 905 0
 1690 011c 0020     	 movs r0,#0
 1691 011e 08E0     	 b .L135
 1692              	.LVL197:
 1693              	.L147:
 1694 0120 0020     	 movs r0,#0
 1695              	.LVL198:
 1696 0122 06E0     	 b .L135
 1697              	.LVL199:
 1698              	.L148:
 1699 0124 0020     	 movs r0,#0
 1700 0126 04E0     	 b .L135
 1701              	.LVL200:
 1702              	.L149:
 1703 0128 0020     	 movs r0,#0
 1704              	.LVL201:
 1705 012a 02E0     	 b .L135
 1706              	.L150:
 1707 012c 0020     	 movs r0,#0
 1708 012e 00E0     	 b .L135
 1709              	.L151:
 1710 0130 0020     	 movs r0,#0
 1711              	.LVL202:
 1712              	.L135:
1069:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
 1713              	 .loc 1 1069 0
 1714 0132 06B0     	 add sp,sp,#24
 1715              	.LCFI20:
 1716              	 .cfi_def_cfa_offset 32
 1717              	 
 1718 0134 BDE8F087 	 pop {r4,r5,r6,r7,r8,r9,r10,pc}
 1719              	 .cfi_endproc
 1720              	.LFE64:
 1722              	 .section .text.vSocketBind,"ax",%progbits
 1723              	 .align 2
 1724              	 .global vSocketBind
 1725              	 .thumb
 1726              	 .thumb_func
 1728              	vSocketBind:
 1729              	.LFB66:
1147:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** BaseType_t xReturn = 0; /* In Berkeley sockets, 0 means pass for bind(). */
 1730              	 .loc 1 1147 0
 1731              	 .cfi_startproc
 1732              	 
 1733              	 
 1734              	.LVL203:
 1735 0000 2DE9F04F 	 push {r4,r5,r6,r7,r8,r9,r10,fp,lr}
 1736              	.LCFI21:
 1737              	 .cfi_def_cfa_offset 36
 1738              	 .cfi_offset 4,-36
 1739              	 .cfi_offset 5,-32
 1740              	 .cfi_offset 6,-28
 1741              	 .cfi_offset 7,-24
 1742              	 .cfi_offset 8,-20
 1743              	 .cfi_offset 9,-16
 1744              	 .cfi_offset 10,-12
 1745              	 .cfi_offset 11,-8
 1746              	 .cfi_offset 14,-4
 1747 0004 85B0     	 sub sp,sp,#20
 1748              	.LCFI22:
 1749              	 .cfi_def_cfa_offset 56
 1750 0006 0646     	 mov r6,r0
 1751 0008 0D46     	 mov r5,r1
 1752 000a 9946     	 mov r9,r3
 1753              	.LVL204:
1156:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 1754              	 .loc 1 1156 0
 1755 000c 90F82730 	 ldrb r3,[r0,#39]
 1756              	.LVL205:
 1757 0010 062B     	 cmp r3,#6
 1758 0012 06D0     	 beq .L169
1163:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 1759              	 .loc 1 1163 0
 1760 0014 112B     	 cmp r3,#17
 1761 0016 06D0     	 beq .L170
1169:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 1762              	 .loc 1 1169 0
 1763 0018 454F     	 ldr r7,.L178
 1764 001a FF2B     	 cmp r3,#255
 1765 001c 18BF     	 it ne
 1766 001e 0027     	 movne r7,#0
 1767 0020 02E0     	 b .L154
 1768              	.L169:
1158:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 1769              	 .loc 1 1158 0
 1770 0022 444F     	 ldr r7,.L178+4
 1771 0024 00E0     	 b .L154
 1772              	.L170:
1165:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 1773              	 .loc 1 1165 0
 1774 0026 444F     	 ldr r7,.L178+8
 1775              	.L154:
 1776              	.LVL206:
1181:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	configASSERT( pxSocket != FREERTOS_INVALID_SOCKET );
 1777              	 .loc 1 1181 0
 1778 0028 46B9     	 cbnz r6,.L155
 1779              	.LBB232:
 1780              	.LBB233:
 1781              	 .loc 2 197 0
 1782              	
 1783 002a 4FF01403 	 mov r3,#20
 1784 002e 83F31188 	 msr basepri,r3
 1785 0032 BFF36F8F 	 isb 
 1786 0036 BFF34F8F 	 dsb 
 1787              	
 1788              	
 1789              	.LVL207:
 1790              	 .thumb
 1791              	.L156:
 1792              	.LBE233:
 1793              	.LBE232:
1181:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	configASSERT( pxSocket != FREERTOS_INVALID_SOCKET );
 1794              	 .loc 1 1181 0 discriminator 1
 1795 003a FEE7     	 b .L156
 1796              	.L155:
1182:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 1797              	 .loc 1 1182 0
 1798 003c B6F1FF3F 	 cmp r6,#-1
 1799 0040 08D1     	 bne .L157
 1800              	.LBB234:
 1801              	.LBB235:
 1802              	 .loc 2 197 0
 1803              	
 1804 0042 4FF01403 	 mov r3,#20
 1805 0046 83F31188 	 msr basepri,r3
 1806 004a BFF36F8F 	 isb 
 1807 004e BFF34F8F 	 dsb 
 1808              	
 1809              	
 1810              	.LVL208:
 1811              	 .thumb
 1812              	.L158:
 1813              	.LBE235:
 1814              	.LBE234:
1182:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 1815              	 .loc 1 1182 0 discriminator 2
 1816 0052 FEE7     	 b .L158
 1817              	.L157:
1191:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 1818              	 .loc 1 1191 0
 1819 0054 002D     	 cmp r5,#0
 1820 0056 60D1     	 bne .L159
 1821              	.LVL209:
1195:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 1822              	 .loc 1 1195 0
 1823 0058 0022     	 movs r2,#0
 1824              	.LVL210:
 1825 005a ADF80A20 	 strh r2,[sp,#10]
1193:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Put the port to zero to be assigned later. */
 1826              	 .loc 1 1193 0
 1827 005e 02AD     	 add r5,sp,#8
 1828              	.LVL211:
 1829 0060 5BE0     	 b .L159
 1830              	.L168:
 1831              	.LVL212:
 1832              	.LBB236:
 1833              	.LBB237:
1886:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** uint16_t usResult = 0;
 1834              	 .loc 1 1886 0
 1835 0062 0022     	 movs r2,#0
 1836 0064 0192     	 str r2,[sp,#4]
 1837              	.LVL213:
1890:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 1838              	 .loc 1 1890 0
 1839 0066 112B     	 cmp r3,#17
 1840 0068 06D0     	 beq .L171
1895:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 1841              	 .loc 1 1895 0
 1842 006a 062B     	 cmp r3,#6
 1843 006c 06D0     	 beq .L172
1902:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 1844              	 .loc 1 1902 0
 1845 006e 304C     	 ldr r4,.L178
 1846 0070 FF2B     	 cmp r3,#255
 1847 0072 18BF     	 it ne
 1848 0074 1446     	 movne r4,r2
 1849 0076 02E0     	 b .L160
 1850              	.L171:
1892:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 1851              	 .loc 1 1892 0
 1852 0078 2F4C     	 ldr r4,.L178+8
 1853 007a 00E0     	 b .L160
 1854              	.L172:
1897:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 1855              	 .loc 1 1897 0
 1856 007c 2D4C     	 ldr r4,.L178+4
 1857              	.L160:
1902:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 1858              	 .loc 1 1902 0
 1859 007e 4FF47C48 	 mov r8,#64512
1920:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			socketAUTO_PORT_ALLOCATION_START_NUMBER +
 1860              	 .loc 1 1920 0
 1861 0082 DFF8B8A0 	 ldr r10,.L178+12
 1862              	.LVL214:
 1863              	.L165:
1914:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 1864              	 .loc 1 1914 0
 1865 0086 01A8     	 add r0,sp,#4
 1866 0088 FFF7FEFF 	 bl xApplicationGetRandomNumber
 1867              	.LVL215:
 1868 008c 0028     	 cmp r0,#0
 1869 008e 48D0     	 beq .L161
1920:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			socketAUTO_PORT_ALLOCATION_START_NUMBER +
 1870              	 .loc 1 1920 0
 1871 0090 BDF80430 	 ldrh r3,[sp,#4]
 1872 0094 9A0A     	 lsrs r2,r3,#10
 1873 0096 AAFB0212 	 umull r1,r2,r10,r2
 1874 009a 9101     	 lsls r1,r2,#6
 1875 009c 8A1A     	 subs r2,r1,r2
 1876 009e A3EB8223 	 sub r3,r3,r2,lsl#10
 1877 00a2 03F58063 	 add r3,r3,#1024
 1878 00a6 9BB2     	 uxth r3,r3
 1879              	.LVL216:
1928:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 1880              	 .loc 1 1928 0
 1881 00a8 4FEA132B 	 lsr fp,r3,#8
 1882 00ac 4BEA0323 	 orr r3,fp,r3,lsl#8
 1883              	.LVL217:
 1884 00b0 1FFA83FB 	 uxth fp,r3
1926:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pxList,
 1885              	 .loc 1 1926 0
 1886 00b4 2046     	 mov r0,r4
 1887 00b6 5946     	 mov r1,fp
 1888 00b8 FFF7FEFF 	 bl pxListFindListItemWithValue
 1889              	.LVL218:
 1890 00bc 28B9     	 cbnz r0,.L162
 1891              	.LVL219:
 1892              	.LBE237:
 1893              	.LBE236:
1215:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( pxAddress->sin_port == ( uint16_t ) 0U )
 1894              	 .loc 1 1215 0
 1895 00be A5F802B0 	 strh fp,[r5,#2]
1216:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 1896              	 .loc 1 1216 0
 1897 00c2 BBF1000F 	 cmp fp,#0
 1898 00c6 08D1     	 bne .L164
 1899 00c8 21E0     	 b .L173
 1900              	.LVL220:
 1901              	.L162:
 1902 00ca 08F1FF38 	 add r8,r8,#-1
 1903              	.LVL221:
 1904 00ce 1FFA88F8 	 uxth r8,r8
 1905              	.LBB239:
 1906              	.LBB238:
1940:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 1907              	 .loc 1 1940 0
 1908 00d2 B8F1000F 	 cmp r8,#0
 1909 00d6 D6D1     	 bne .L165
 1910 00d8 23E0     	 b .L161
 1911              	.LVL222:
 1912              	.L164:
 1913              	.LBE238:
 1914              	.LBE239:
1229:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				( pxListFindListItemWithValue( pxSocketList, ( TickType_t ) pxAddress->sin_port ) != NULL ) )
 1915              	 .loc 1 1229 0
 1916 00da B9F1000F 	 cmp r9,#0
 1917 00de 03D0     	 beq .L166
1229:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				( pxListFindListItemWithValue( pxSocketList, ( TickType_t ) pxAddress->sin_port ) != NULL ) )
 1918              	 .loc 1 1229 0 is_stmt 0 discriminator 2
 1919 00e0 96F82730 	 ldrb r3,[r6,#39]
 1920 00e4 062B     	 cmp r3,#6
 1921 00e6 04D0     	 beq .L167
 1922              	.L166:
1230:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 1923              	 .loc 1 1230 0 is_stmt 1 discriminator 3
 1924 00e8 3846     	 mov r0,r7
 1925 00ea 6988     	 ldrh r1,[r5,#2]
 1926 00ec FFF7FEFF 	 bl pxListFindListItemWithValue
 1927              	.LVL223:
1229:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				( pxListFindListItemWithValue( pxSocketList, ( TickType_t ) pxAddress->sin_port ) != NULL ) )
 1928              	 .loc 1 1229 0 discriminator 3
 1929 00f0 80B9     	 cbnz r0,.L174
 1930              	.L167:
1241:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 1931              	 .loc 1 1241 0
 1932 00f2 6B88     	 ldrh r3,[r5,#2]
 1933 00f4 B360     	 str r3,[r6,#8]
1245:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 1934              	 .loc 1 1245 0
 1935 00f6 6A88     	 ldrh r2,[r5,#2]
 1936 00f8 130A     	 lsrs r3,r2,#8
 1937 00fa 43EA0223 	 orr r3,r3,r2,lsl#8
 1938 00fe B384     	 strh r3,[r6,#36]
1260:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 1939              	 .loc 1 1260 0
 1940 0100 3846     	 mov r0,r7
 1941 0102 06F10801 	 add r1,r6,#8
 1942 0106 FFF7FEFF 	 bl vListInsertEnd
 1943              	.LVL224:
1148:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** List_t *pxSocketList;
 1944              	 .loc 1 1148 0
 1945 010a 0020     	 movs r0,#0
 1946 010c 0DE0     	 b .L176
 1947              	.LVL225:
 1948              	.L173:
1218:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					break;
 1949              	 .loc 1 1218 0
 1950 010e 6FF07C00 	 mvn r0,#124
 1951 0112 0AE0     	 b .L176
 1952              	.LVL226:
 1953              	.L174:
1235:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 1954              	 .loc 1 1235 0
 1955 0114 6FF06F00 	 mvn r0,#111
 1956 0118 07E0     	 b .L176
 1957              	.LVL227:
 1958              	.L159:
1213:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 1959              	 .loc 1 1213 0
 1960 011a 6A88     	 ldrh r2,[r5,#2]
 1961 011c 002A     	 cmp r2,#0
 1962 011e DCD1     	 bne .L164
 1963 0120 9FE7     	 b .L168
 1964              	.LVL228:
 1965              	.L161:
1215:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( pxAddress->sin_port == ( uint16_t ) 0U )
 1966              	 .loc 1 1215 0
 1967 0122 0023     	 movs r3,#0
 1968 0124 6B80     	 strh r3,[r5,#2]
1218:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					break;
 1969              	 .loc 1 1218 0
 1970 0126 6FF07C00 	 mvn r0,#124
 1971              	.LVL229:
 1972              	.L176:
1285:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
 1973              	 .loc 1 1285 0
 1974 012a 05B0     	 add sp,sp,#20
 1975              	.LCFI23:
 1976              	 .cfi_def_cfa_offset 36
 1977              	 
 1978 012c BDE8F08F 	 pop {r4,r5,r6,r7,r8,r9,r10,fp,pc}
 1979              	.LVL230:
 1980              	.L179:
 1981              	 .align 2
 1982              	.L178:
 1983 0130 00000000 	 .word .LANCHOR1
 1984 0134 00000000 	 .word xBoundTCPSocketsList
 1985 0138 00000000 	 .word .LANCHOR0
 1986 013c 14411004 	 .word 68174100
 1987              	 .cfi_endproc
 1988              	.LFE66:
 1990              	 .section .text.FreeRTOS_closesocket,"ax",%progbits
 1991              	 .align 2
 1992              	 .global FreeRTOS_closesocket
 1993              	 .thumb
 1994              	 .thumb_func
 1996              	FreeRTOS_closesocket:
 1997              	.LFB67:
1295:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** BaseType_t xResult;
 1998              	 .loc 1 1295 0
 1999              	 .cfi_startproc
 2000              	 
 2001              	 
 2002              	.LVL231:
 2003 0000 00B5     	 push {lr}
 2004              	.LCFI24:
 2005              	 .cfi_def_cfa_offset 4
 2006              	 .cfi_offset 14,-4
 2007 0002 83B0     	 sub sp,sp,#12
 2008              	.LCFI25:
 2009              	 .cfi_def_cfa_offset 16
1301:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** xCloseEvent.pvData = xSocket;
 2010              	 .loc 1 1301 0
 2011 0004 0A23     	 movs r3,#10
 2012 0006 8DF80030 	 strb r3,[sp]
1302:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 2013              	 .loc 1 1302 0
 2014 000a 0190     	 str r0,[sp,#4]
1304:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 2015              	 .loc 1 1304 0
 2016 000c 0138     	 subs r0,r0,#1
 2017              	.LVL232:
 2018 000e 10F1030F 	 cmn r0,#3
 2019 0012 09D8     	 bhi .L182
1328:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 2020              	 .loc 1 1328 0
 2021 0014 6846     	 mov r0,sp
 2022 0016 0021     	 movs r1,#0
 2023 0018 FFF7FEFF 	 bl xSendEventStructToIPTask
 2024              	.LVL233:
 2025 001c 0028     	 cmp r0,#0
1335:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 2026              	 .loc 1 1335 0
 2027 001e 0CBF     	 ite eq
 2028 0020 4FF0FF30 	 moveq r0,#-1
 2029 0024 0120     	 movne r0,#1
 2030 0026 00E0     	 b .L181
 2031              	.LVL234:
 2032              	.L182:
1306:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 2033              	 .loc 1 1306 0
 2034 0028 0020     	 movs r0,#0
 2035              	.LVL235:
 2036              	.L181:
1340:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 2037              	 .loc 1 1340 0
 2038 002a 03B0     	 add sp,sp,#12
 2039              	.LCFI26:
 2040              	 .cfi_def_cfa_offset 4
 2041              	 
 2042 002c 5DF804FB 	 ldr pc,[sp],#4
 2043              	 .cfi_endproc
 2044              	.LFE67:
 2046              	 .section .text.vSocketClose,"ax",%progbits
 2047              	 .align 2
 2048              	 .global vSocketClose
 2049              	 .thumb
 2050              	 .thumb_func
 2052              	vSocketClose:
 2053              	.LFB68:
1346:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** NetworkBufferDescriptor_t *pxNetworkBuffer;
 2054              	 .loc 1 1346 0
 2055              	 .cfi_startproc
 2056              	 
 2057              	 
 2058              	.LVL236:
 2059 0000 38B5     	 push {r3,r4,r5,lr}
 2060              	.LCFI27:
 2061              	 .cfi_def_cfa_offset 16
 2062              	 .cfi_offset 3,-16
 2063              	 .cfi_offset 4,-12
 2064              	 .cfi_offset 5,-8
 2065              	 .cfi_offset 14,-4
 2066 0002 0446     	 mov r4,r0
1352:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 2067              	 .loc 1 1352 0
 2068 0004 90F82730 	 ldrb r3,[r0,#39]
 2069 0008 062B     	 cmp r3,#6
 2070 000a 28D1     	 bne .L186
1356:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 2071              	 .loc 1 1356 0
 2072 000c C06F     	 ldr r0,[r0,#124]
 2073              	.LVL237:
 2074 000e 08B1     	 cbz r0,.L187
1358:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 2075              	 .loc 1 1358 0
 2076 0010 FFF7FEFF 	 bl vReleaseNetworkBufferAndDescriptor
 2077              	.LVL238:
 2078              	.L187:
1361:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 2079              	 .loc 1 1361 0
 2080 0014 04F1D800 	 add r0,r4,#216
 2081 0018 FFF7FEFF 	 bl vTCPWindowDestroy
 2082              	.LVL239:
1366:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 2083              	 .loc 1 1366 0
 2084 001c 606F     	 ldr r0,[r4,#116]
 2085 001e 08B1     	 cbz r0,.L188
1369:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 2086              	 .loc 1 1369 0
 2087 0020 FFF7FEFF 	 bl vPortFree
 2088              	.LVL240:
 2089              	.L188:
1372:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 2090              	 .loc 1 1372 0
 2091 0024 A06F     	 ldr r0,[r4,#120]
 2092 0026 08B1     	 cbz r0,.L189
1375:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 2093              	 .loc 1 1375 0
 2094 0028 FFF7FEFF 	 bl vPortFree
 2095              	.LVL241:
 2096              	.L189:
 2097              	.LBB242:
 2098              	.LBB243:
1459:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 2099              	 .loc 1 1459 0
 2100 002c A58C     	 ldrh r5,[r4,#36]
 2101              	.LVL242:
1461:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			 pxIterator != pxEnd;
 2102              	 .loc 1 1461 0
 2103 002e 1C4A     	 ldr r2,.L201
 2104 0030 D368     	 ldr r3,[r2,#12]
 2105              	.LVL243:
 2106 0032 0832     	 adds r2,r2,#8
 2107 0034 9342     	 cmp r3,r2
 2108 0036 12D0     	 beq .L186
 2109 0038 1046     	 mov r0,r2
 2110              	.L197:
1465:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( ( pxOtherSocket->u.xTCP.ucTCPState == ( uint8_t ) eTCP_LISTEN ) &&
 2111              	 .loc 1 1465 0
 2112 003a DA68     	 ldr r2,[r3,#12]
 2113              	.LVL244:
1466:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				( pxOtherSocket->usLocalPort == usLocalPort ) &&
 2114              	 .loc 1 1466 0
 2115 003c 92F85310 	 ldrb r1,[r2,#83]
 2116 0040 0129     	 cmp r1,#1
 2117 0042 09D1     	 bne .L190
 2118 0044 918C     	 ldrh r1,[r2,#36]
 2119 0046 A942     	 cmp r1,r5
 2120 0048 06D1     	 bne .L190
1468:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 2121              	 .loc 1 1468 0
 2122 004a B2F84E10 	 ldrh r1,[r2,#78]
1467:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				( pxOtherSocket->u.xTCP.usChildCount != 0U ) )
 2123              	 .loc 1 1467 0
 2124 004e 19B1     	 cbz r1,.L190
1470:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				FreeRTOS_debug_printf( ( "Lost: Socket %u now has %u / %u child%s\n",
 2125              	 .loc 1 1470 0
 2126 0050 0139     	 subs r1,r1,#1
 2127 0052 A2F84E10 	 strh r1,[r2,#78]
 2128 0056 02E0     	 b .L186
 2129              	.L190:
1463:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 2130              	 .loc 1 1463 0
 2131 0058 5B68     	 ldr r3,[r3,#4]
 2132              	.LVL245:
1461:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			 pxIterator != pxEnd;
 2133              	 .loc 1 1461 0
 2134 005a 8342     	 cmp r3,r0
 2135 005c EDD1     	 bne .L197
 2136              	.LVL246:
 2137              	.L186:
 2138              	.LBE243:
 2139              	.LBE242:
1387:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 2140              	 .loc 1 1387 0
 2141 005e A369     	 ldr r3,[r4,#24]
 2142 0060 1BB1     	 cbz r3,.L192
1398:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 2143              	 .loc 1 1398 0
 2144 0062 04F10800 	 add r0,r4,#8
 2145 0066 FFF7FEFF 	 bl uxListRemove
 2146              	.LVL247:
 2147              	.L192:
1409:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 2148              	 .loc 1 1409 0
 2149 006a 94F82730 	 ldrb r3,[r4,#39]
 2150 006e 112B     	 cmp r3,#17
 2151 0070 0CD1     	 bne .L193
1411:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 2152              	 .loc 1 1411 0
 2153 0072 A36B     	 ldr r3,[r4,#56]
 2154 0074 53B1     	 cbz r3,.L193
 2155              	.L196:
1413:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			( void ) uxListRemove( &( pxNetworkBuffer->xBufferListItem ) );
 2156              	 .loc 1 1413 0
 2157 0076 636C     	 ldr r3,[r4,#68]
 2158 0078 DD68     	 ldr r5,[r3,#12]
 2159              	.LVL248:
1414:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 2160              	 .loc 1 1414 0
 2161 007a 2846     	 mov r0,r5
 2162 007c FFF7FEFF 	 bl uxListRemove
 2163              	.LVL249:
1415:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 2164              	 .loc 1 1415 0
 2165 0080 2846     	 mov r0,r5
 2166 0082 FFF7FEFF 	 bl vReleaseNetworkBufferAndDescriptor
 2167              	.LVL250:
1411:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 2168              	 .loc 1 1411 0
 2169 0086 A36B     	 ldr r3,[r4,#56]
 2170 0088 002B     	 cmp r3,#0
 2171 008a F4D1     	 bne .L196
 2172              	.LVL251:
 2173              	.L193:
1419:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 2174              	 .loc 1 1419 0
 2175 008c 6068     	 ldr r0,[r4,#4]
 2176 008e 08B1     	 cbz r0,.L195
1421:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 2177              	 .loc 1 1421 0
 2178 0090 FFF7FEFF 	 bl vEventGroupDelete
 2179              	.LVL252:
 2180              	.L195:
1440:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 2181              	 .loc 1 1440 0
 2182 0094 2046     	 mov r0,r4
 2183 0096 FFF7FEFF 	 bl vPortFree
 2184              	.LVL253:
1443:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 2185              	 .loc 1 1443 0
 2186 009a 0020     	 movs r0,#0
 2187 009c 38BD     	 pop {r3,r4,r5,pc}
 2188              	.LVL254:
 2189              	.L202:
 2190 009e 00BF     	 .align 2
 2191              	.L201:
 2192 00a0 00000000 	 .word xBoundTCPSocketsList
 2193              	 .cfi_endproc
 2194              	.LFE68:
 2196              	 .section .text.pxUDPSocketLookup,"ax",%progbits
 2197              	 .align 2
 2198              	 .global pxUDPSocketLookup
 2199              	 .thumb
 2200              	 .thumb_func
 2202              	pxUDPSocketLookup:
 2203              	.LFB74:
1970:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1971:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
1972:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1973:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** FreeRTOS_Socket_t *pxUDPSocketLookup( UBaseType_t uxLocalPort )
1974:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** {
 2204              	 .loc 1 1974 0
 2205              	 .cfi_startproc
 2206              	 
 2207              	 
 2208              	.LVL255:
 2209 0000 08B5     	 push {r3,lr}
 2210              	.LCFI28:
 2211              	 .cfi_def_cfa_offset 8
 2212              	 .cfi_offset 3,-8
 2213              	 .cfi_offset 14,-4
 2214 0002 0146     	 mov r1,r0
 2215              	.LVL256:
1975:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** const ListItem_t *pxListItem;
1976:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** FreeRTOS_Socket_t *pxSocket = NULL;
1977:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1978:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* Looking up a socket is quite simple, find a match with the local port.
1979:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1980:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	See if there is a list item associated with the port number on the
1981:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	list of bound sockets. */
1982:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	pxListItem = pxListFindListItemWithValue( &xBoundUDPSocketsList, ( TickType_t ) uxLocalPort );
 2216              	 .loc 1 1982 0
 2217 0004 0848     	 ldr r0,.L208
 2218              	.LVL257:
 2219 0006 FFF7FEFF 	 bl pxListFindListItemWithValue
 2220              	.LVL258:
1983:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1984:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	if( pxListItem != NULL )
 2221              	 .loc 1 1984 0
 2222 000a 50B1     	 cbz r0,.L206
1985:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
1986:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* The owner of the list item is the socket itself. */
1987:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		pxSocket = ipCAST_PTR_TO_TYPE_PTR( FreeRTOS_Socket_t, listGET_LIST_ITEM_OWNER( pxListItem ) );
 2223              	 .loc 1 1987 0
 2224 000c C068     	 ldr r0,[r0,#12]
 2225              	.LVL259:
1988:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		configASSERT( pxSocket != NULL );
 2226              	 .loc 1 1988 0
 2227 000e 48B9     	 cbnz r0,.L204
 2228              	.LBB244:
 2229              	.LBB245:
 2230              	 .loc 2 197 0
 2231              	
 2232 0010 4FF01403 	 mov r3,#20
 2233 0014 83F31188 	 msr basepri,r3
 2234 0018 BFF36F8F 	 isb 
 2235 001c BFF34F8F 	 dsb 
 2236              	
 2237              	
 2238              	.LVL260:
 2239              	 .thumb
 2240              	.L205:
 2241              	.LBE245:
 2242              	.LBE244:
 2243              	 .loc 1 1988 0 discriminator 1
 2244 0020 FEE7     	 b .L205
 2245              	.LVL261:
 2246              	.L206:
1976:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 2247              	 .loc 1 1976 0
 2248 0022 0020     	 movs r0,#0
 2249              	.LVL262:
 2250              	.L204:
1989:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
1990:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	return pxSocket;
1991:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** }
 2251              	 .loc 1 1991 0
 2252 0024 08BD     	 pop {r3,pc}
 2253              	.L209:
 2254 0026 00BF     	 .align 2
 2255              	.L208:
 2256 0028 00000000 	 .word .LANCHOR0
 2257              	 .cfi_endproc
 2258              	.LFE74:
 2260              	 .section .text.FreeRTOS_inet_ntoa,"ax",%progbits
 2261              	 .align 2
 2262              	 .global FreeRTOS_inet_ntoa
 2263              	 .thumb
 2264              	 .thumb_func
 2266              	FreeRTOS_inet_ntoa:
 2267              	.LFB75:
1992:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1993:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
1994:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
1995:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** const char *FreeRTOS_inet_ntoa( uint32_t ulIPAddress, char *pcBuffer )
1996:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** {
 2268              	 .loc 1 1996 0
 2269              	 .cfi_startproc
 2270              	 
 2271              	 
 2272              	.LVL263:
 2273 0000 2DE9F047 	 push {r4,r5,r6,r7,r8,r9,r10,lr}
 2274              	.LCFI29:
 2275              	 .cfi_def_cfa_offset 32
 2276              	 .cfi_offset 4,-32
 2277              	 .cfi_offset 5,-28
 2278              	 .cfi_offset 6,-24
 2279              	 .cfi_offset 7,-20
 2280              	 .cfi_offset 8,-16
 2281              	 .cfi_offset 9,-12
 2282              	 .cfi_offset 10,-8
 2283              	 .cfi_offset 14,-4
 2284 0004 84B0     	 sub sp,sp,#16
 2285              	.LCFI30:
 2286              	 .cfi_def_cfa_offset 48
 2287 0006 0DF1100C 	 add ip,sp,#16
 2288 000a 4CF80C0D 	 str r0,[ip,#-12]!
 2289              	.LVL264:
1997:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** socklen_t uxNibble;
1998:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** socklen_t uxIndex = 0;
 2290              	 .loc 1 1998 0
 2291 000e 0022     	 movs r2,#0
1999:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** const uint8_t *pucAddress = ( const uint8_t * ) &( ulIPAddress );
2000:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** const char *pcResult = pcBuffer;
2001:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** const socklen_t uxSize = 16;
2002:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2003:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /* Each nibble is expressed in at most 3 digits, like e.g. "192". */
2004:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #define sockDIGIT_COUNT		( 3U )
2005:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2006:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	for( uxNibble = 0; uxNibble < ipSIZE_OF_IPv4_ADDRESS; uxNibble++ )
 2292              	 .loc 1 2006 0
 2293 0010 9646     	 mov lr,r2
 2294              	.LBB246:
2007:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
2008:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	uint8_t pucDigits[ sockDIGIT_COUNT ];
2009:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	uint8_t ucValue = pucAddress[ uxNibble ];
2010:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	socklen_t uxSource = ( socklen_t ) sockDIGIT_COUNT - ( socklen_t ) 1U;
2011:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	socklen_t uxNeeded;
2012:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2013:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		for( ;; )
2014:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
2015:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pucDigits[ uxSource ] = ucValue % ( uint8_t ) 10U;
 2295              	 .loc 1 2015 0
 2296 0012 2848     	 ldr r0,.L226
 2297              	.LVL265:
2016:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			ucValue /= ( uint8_t ) 10U;
2017:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( uxSource == 1U )
2018:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
2019:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				break;
2020:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
2021:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			uxSource--;
2022:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
2023:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		pucDigits[ 0 ] = ucValue;
2024:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2025:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* Skip leading zeros. */
2026:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		for( uxSource = 0; uxSource < ( ( socklen_t ) sockDIGIT_COUNT - ( socklen_t ) 1U ); uxSource++ )
 2298              	 .loc 1 2026 0
 2299 0014 9146     	 mov r9,r2
2027:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
2028:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( pucDigits[ uxSource ] != 0U )
2029:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
2030:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				break;
2031:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
2032:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
2033:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* Write e.g. "192.", which is 3 digits and a dot. */
2034:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		uxNeeded = ( ( socklen_t ) sockDIGIT_COUNT - uxSource ) + 1U;
2035:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( ( uxIndex + uxNeeded ) > uxSize )
2036:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
2037:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* The result won't fit. */
2038:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pcResult = NULL;
2039:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			break;
2040:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
2041:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	
2042:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		for( ; uxSource < ( socklen_t ) sockDIGIT_COUNT; uxSource++ )
2043:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
2044:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pcBuffer[ uxIndex ] = ( char ) ( pucDigits[ uxSource ] + ( char ) '0' );
2045:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			uxIndex++;
2046:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
2047:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( uxNibble < ( ipSIZE_OF_IPv4_ADDRESS - 1U ) )
2048:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
2049:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pcBuffer[ uxIndex ] = '.';
 2300              	 .loc 1 2049 0
 2301 0016 4FF02E08 	 mov r8,#46
 2302              	.LVL266:
 2303              	.L218:
2009:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	socklen_t uxSource = ( socklen_t ) sockDIGIT_COUNT - ( socklen_t ) 1U;
 2304              	 .loc 1 2009 0
 2305 001a 1CF8014B 	 ldrb r4,[ip],#1
 2306              	.LVL267:
2015:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			ucValue /= ( uint8_t ) 10U;
 2307              	 .loc 1 2015 0
 2308 001e A0FB0453 	 umull r5,r3,r0,r4
 2309 0022 DB08     	 lsrs r3,r3,#3
 2310 0024 03EB8305 	 add r5,r3,r3,lsl#2
 2311 0028 A4EB4504 	 sub r4,r4,r5,lsl#1
 2312              	.LVL268:
 2313 002c 8DF80E40 	 strb r4,[sp,#14]
2016:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( uxSource == 1U )
 2314              	 .loc 1 2016 0
 2315 0030 DBB2     	 uxtb r3,r3
 2316              	.LVL269:
2015:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			ucValue /= ( uint8_t ) 10U;
 2317              	 .loc 1 2015 0
 2318 0032 A0FB0354 	 umull r5,r4,r0,r3
 2319 0036 E408     	 lsrs r4,r4,#3
 2320 0038 04EB8405 	 add r5,r4,r4,lsl#2
 2321 003c A3EB4503 	 sub r3,r3,r5,lsl#1
 2322              	.LVL270:
 2323 0040 8DF80D30 	 strb r3,[sp,#13]
2016:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( uxSource == 1U )
 2324              	 .loc 1 2016 0
 2325 0044 E4B2     	 uxtb r4,r4
 2326              	.LVL271:
2023:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 2327              	 .loc 1 2023 0
 2328 0046 8DF80C40 	 strb r4,[sp,#12]
 2329              	.LVL272:
2028:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 2330              	 .loc 1 2028 0
 2331 004a 54BB     	 cbnz r4,.L211
 2332              	.LVL273:
 2333 004c DBB2     	 uxtb r3,r3
2026:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 2334              	 .loc 1 2026 0
 2335 004e 002B     	 cmp r3,#0
 2336 0050 14BF     	 ite ne
 2337 0052 0127     	 movne r7,#1
 2338 0054 0227     	 moveq r7,#2
 2339              	.LVL274:
 2340 0056 131D     	 adds r3,r2,#4
2035:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 2341              	 .loc 1 2035 0
 2342 0058 DB1B     	 subs r3,r3,r7
 2343 005a 102B     	 cmp r3,#16
 2344 005c 01D9     	 bls .L220
 2345              	.LVL275:
 2346              	.L219:
2038:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			break;
 2347              	 .loc 1 2038 0
 2348 005e 0021     	 movs r1,#0
 2349              	.LVL276:
 2350 0060 24E0     	 b .L224
 2351              	.LVL277:
 2352              	.L220:
 2353 0062 03AB     	 add r3,sp,#12
 2354 0064 DE19     	 adds r6,r3,r7
 2355 0066 8D18     	 adds r5,r1,r2
2026:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 2356              	 .loc 1 2026 0 discriminator 2
 2357 0068 1446     	 mov r4,r2
 2358              	.LVL278:
 2359 006a 00E0     	 b .L215
 2360              	.LVL279:
 2361              	.L222:
2045:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 2362              	 .loc 1 2045 0
 2363 006c 5446     	 mov r4,r10
 2364              	.LVL280:
 2365              	.L215:
2044:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			uxIndex++;
 2366              	 .loc 1 2044 0 discriminator 2
 2367 006e 16F8013B 	 ldrb r3,[r6],#1
 2368 0072 3033     	 adds r3,r3,#48
 2369 0074 05F8013B 	 strb r3,[r5],#1
2045:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 2370              	 .loc 1 2045 0 discriminator 2
 2371 0078 04F1010A 	 add r10,r4,#1
 2372              	.LVL281:
 2373 007c C2EB0A03 	 rsb r3,r2,r10
 2374 0080 3B44     	 add r3,r3,r7
 2375              	.LVL282:
2042:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 2376              	 .loc 1 2042 0 discriminator 2
 2377 0082 022B     	 cmp r3,#2
 2378 0084 F2D9     	 bls .L222
2047:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 2379              	 .loc 1 2047 0
 2380 0086 BEF1020F 	 cmp lr,#2
 2381              	 .loc 1 2049 0
 2382 008a 94BF     	 ite ls
 2383 008c 01F80A80 	 strbls r8,[r1,r10]
2050:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
2051:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else
2052:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
2053:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pcBuffer[ uxIndex ] = '\0';
 2384              	 .loc 1 2053 0
 2385 0090 01F80A90 	 strbhi r9,[r1,r10]
2054:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
2055:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		uxIndex++;
 2386              	 .loc 1 2055 0
 2387 0094 A21C     	 adds r2,r4,#2
 2388              	.LVL283:
 2389              	.LBE246:
2006:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 2390              	 .loc 1 2006 0
 2391 0096 0EF1010E 	 add lr,lr,#1
 2392              	.LVL284:
 2393 009a BEF1040F 	 cmp lr,#4
 2394 009e BCD1     	 bne .L218
 2395 00a0 04E0     	 b .L224
 2396              	.LVL285:
 2397              	.L211:
 2398              	.LBB247:
2035:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 2399              	 .loc 1 2035 0
 2400 00a2 131D     	 adds r3,r2,#4
 2401 00a4 102B     	 cmp r3,#16
 2402 00a6 DAD8     	 bhi .L219
2026:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 2403              	 .loc 1 2026 0
 2404 00a8 4F46     	 mov r7,r9
 2405 00aa DAE7     	 b .L220
 2406              	.LVL286:
 2407              	.L224:
 2408              	.LBE247:
2056:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
2057:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2058:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	return pcResult;
2059:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** }
 2409              	 .loc 1 2059 0
 2410 00ac 0846     	 mov r0,r1
 2411 00ae 04B0     	 add sp,sp,#16
 2412              	.LCFI31:
 2413              	 .cfi_def_cfa_offset 32
 2414              	.LVL287:
 2415              	 
 2416 00b0 BDE8F087 	 pop {r4,r5,r6,r7,r8,r9,r10,pc}
 2417              	.LVL288:
 2418              	.L227:
 2419              	 .align 2
 2420              	.L226:
 2421 00b4 CDCCCCCC 	 .word -858993459
 2422              	 .cfi_endproc
 2423              	.LFE75:
 2425              	 .section .text.FreeRTOS_inet_ntop4,"ax",%progbits
 2426              	 .align 2
 2427              	 .global FreeRTOS_inet_ntop4
 2428              	 .thumb
 2429              	 .thumb_func
 2431              	FreeRTOS_inet_ntop4:
 2432              	.LFB78:
2060:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
2061:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2062:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** BaseType_t FreeRTOS_inet_pton( BaseType_t xAddressFamily, const char *pcSource, void *pvDestination
2063:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** {
2064:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** BaseType_t xResult;
2065:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2066:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* Printable string to struct sockaddr. */
2067:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	switch( xAddressFamily )
2068:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
2069:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		case FREERTOS_AF_INET:
2070:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xResult = FreeRTOS_inet_pton4( pcSource, pvDestination );
2071:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			break;
2072:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		default:
2073:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xResult = -pdFREERTOS_ERRNO_EAFNOSUPPORT;
2074:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			break;
2075:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
2076:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	return xResult;
2077:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** }
2078:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
2079:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2080:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** const char *FreeRTOS_inet_ntop( BaseType_t xAddressFamily, const void *pvSource, char *pcDestinatio
2081:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** {
2082:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** const char *pcResult;
2083:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2084:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* Printable struct sockaddr to string. */
2085:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	switch( xAddressFamily )
2086:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
2087:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		case FREERTOS_AF_INET:
2088:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pcResult = FreeRTOS_inet_ntop4( pvSource, pcDestination, uxSize );
2089:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			break;
2090:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		default:
2091:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* errno should be set to pdFREERTOS_ERRNO_EAFNOSUPPORT. */
2092:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pcResult = NULL;
2093:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			break;
2094:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
2095:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	return pcResult;
2096:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** }
2097:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
2098:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2099:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** const char *FreeRTOS_inet_ntop4( const void *pvSource, char *pcDestination, socklen_t uxSize )
2100:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** {
 2433              	 .loc 1 2100 0
 2434              	 .cfi_startproc
 2435              	 
 2436              	 
 2437              	.LVL289:
 2438 0000 10B5     	 push {r4,lr}
 2439              	.LCFI32:
 2440              	 .cfi_def_cfa_offset 8
 2441              	 .cfi_offset 4,-8
 2442              	 .cfi_offset 14,-4
 2443 0002 82B0     	 sub sp,sp,#8
 2444              	.LCFI33:
 2445              	 .cfi_def_cfa_offset 16
2101:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** uint32_t ulIPAddress;
2102:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** void *pvCopyDest;
2103:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** const char *pcReturn;
2104:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2105:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	if( uxSize < 16U )
 2446              	 .loc 1 2105 0
 2447 0004 0F2A     	 cmp r2,#15
 2448 0006 06D9     	 bls .L230
 2449 0008 0C46     	 mov r4,r1
 2450              	.LVL290:
2106:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
2107:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* There must be space for "255.255.255.255". */
2108:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		pcReturn = NULL;
2109:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
2110:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	else
2111:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
2112:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		pvCopyDest = ( void * ) &ulIPAddress;
2113:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		( void ) memcpy( pvCopyDest, pvSource, sizeof( ulIPAddress ) );
 2451              	 .loc 1 2113 0
 2452 000a 0068     	 ldr r0,[r0]
 2453              	.LVL291:
 2454 000c 0190     	 str r0,[sp,#4]
2114:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		( void ) FreeRTOS_inet_ntoa( ulIPAddress, pcDestination );
 2455              	 .loc 1 2114 0
 2456 000e 0198     	 ldr r0,[sp,#4]
 2457 0010 FFF7FEFF 	 bl FreeRTOS_inet_ntoa
 2458              	.LVL292:
 2459 0014 00E0     	 b .L229
 2460              	.LVL293:
 2461              	.L230:
2108:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 2462              	 .loc 1 2108 0
 2463 0016 0024     	 movs r4,#0
 2464              	.LVL294:
 2465              	.L229:
2115:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		pcReturn = pcDestination;
2116:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
2117:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	return pcReturn;
2118:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** }
 2466              	 .loc 1 2118 0
 2467 0018 2046     	 mov r0,r4
 2468 001a 02B0     	 add sp,sp,#8
 2469              	.LCFI34:
 2470              	 .cfi_def_cfa_offset 8
 2471              	 
 2472 001c 10BD     	 pop {r4,pc}
 2473              	 .cfi_endproc
 2474              	.LFE78:
 2476 001e 00BF     	 .section .text.FreeRTOS_inet_ntop,"ax",%progbits
 2477              	 .align 2
 2478              	 .global FreeRTOS_inet_ntop
 2479              	 .thumb
 2480              	 .thumb_func
 2482              	FreeRTOS_inet_ntop:
 2483              	.LFB77:
2081:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** const char *pcResult;
 2484              	 .loc 1 2081 0
 2485              	 .cfi_startproc
 2486              	 
 2487              	 
 2488              	.LVL295:
2085:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 2489              	 .loc 1 2085 0
 2490 0000 0228     	 cmp r0,#2
 2491 0002 06D1     	 bne .L236
2081:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** const char *pcResult;
 2492              	 .loc 1 2081 0
 2493 0004 08B5     	 push {r3,lr}
 2494              	.LCFI35:
 2495              	 .cfi_def_cfa_offset 8
 2496              	 .cfi_offset 3,-8
 2497              	 .cfi_offset 14,-4
 2498 0006 0846     	 mov r0,r1
 2499              	.LVL296:
2088:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			break;
 2500              	 .loc 1 2088 0
 2501 0008 1146     	 mov r1,r2
 2502              	.LVL297:
 2503 000a 1A46     	 mov r2,r3
 2504              	.LVL298:
 2505 000c FFF7FEFF 	 bl FreeRTOS_inet_ntop4
 2506              	.LVL299:
2089:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		default:
 2507              	 .loc 1 2089 0
 2508 0010 08BD     	 pop {r3,pc}
 2509              	.LVL300:
 2510              	.L236:
 2511              	.LCFI36:
 2512              	 .cfi_def_cfa_offset 0
 2513              	 .cfi_restore 3
 2514              	 .cfi_restore 14
2092:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			break;
 2515              	 .loc 1 2092 0
 2516 0012 0020     	 movs r0,#0
 2517              	.LVL301:
 2518 0014 7047     	 bx lr
 2519              	 .cfi_endproc
 2520              	.LFE77:
 2522 0016 00BF     	 .section .text.FreeRTOS_inet_pton4,"ax",%progbits
 2523              	 .align 2
 2524              	 .global FreeRTOS_inet_pton4
 2525              	 .thumb
 2526              	 .thumb_func
 2528              	FreeRTOS_inet_pton4:
 2529              	.LFB79:
2119:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
2120:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2121:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** BaseType_t FreeRTOS_inet_pton4( const char *pcSource, void *pvDestination )
2122:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** {
 2530              	 .loc 1 2122 0
 2531              	 .cfi_startproc
 2532              	 
 2533              	 
 2534              	.LVL302:
 2535 0000 2DE9F041 	 push {r4,r5,r6,r7,r8,lr}
 2536              	.LCFI37:
 2537              	 .cfi_def_cfa_offset 24
 2538              	 .cfi_offset 4,-24
 2539              	 .cfi_offset 5,-20
 2540              	 .cfi_offset 6,-16
 2541              	 .cfi_offset 7,-12
 2542              	 .cfi_offset 8,-8
 2543              	 .cfi_offset 14,-4
 2544 0004 82B0     	 sub sp,sp,#8
 2545              	.LCFI38:
 2546              	 .cfi_def_cfa_offset 32
 2547              	.LVL303:
2123:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** const uint32_t ulDecimalBase = 10U;
2124:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** uint8_t ucOctet[ socketMAX_IP_ADDRESS_OCTETS ];
2125:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** uint32_t ulReturn = 0UL, ulValue;
 2548              	 .loc 1 2125 0
 2549 0006 0026     	 movs r6,#0
 2550 0008 0096     	 str r6,[sp]
 2551              	.LVL304:
 2552 000a 0DF1040E 	 add lr,sp,#4
2126:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** UBaseType_t uxOctetNumber;
2127:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** BaseType_t xResult = pdPASS;
2128:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** const char *pcIPAddress = pcSource;
 2553              	 .loc 1 2128 0
 2554 000e 0546     	 mov r5,r0
2127:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** const char *pcIPAddress = pcSource;
 2555              	 .loc 1 2127 0
 2556 0010 0127     	 movs r7,#1
2129:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** const void *pvCopySource;
2130:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2131:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* Translate "192.168.2.100" to a 32-bit number, network-endian. */
2132:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	for( uxOctetNumber = 0U; uxOctetNumber < socketMAX_IP_ADDRESS_OCTETS; uxOctetNumber++ )
2133:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
2134:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		ulValue = 0UL;
2135:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2136:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		while( ( *pcIPAddress >= '0' ) && ( *pcIPAddress <= '9' ) )
2137:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
2138:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		BaseType_t xChar;
2139:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Move previous read characters into the next decimal
2140:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			position. */
2141:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			ulValue *= ulDecimalBase;
2142:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2143:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Add the binary value of the ascii character. */
2144:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xChar = ( BaseType_t ) pcIPAddress[ 0 ];
2145:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xChar = xChar - ( BaseType_t ) '0';
2146:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			ulValue += ( uint32_t ) xChar;
2147:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2148:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Move to next character in the string. */
2149:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pcIPAddress++;
2150:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
2151:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2152:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* Check characters were read. */
2153:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( pcIPAddress == pcSource )
2154:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
2155:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xResult = pdFAIL;
2156:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
2157:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2158:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* Check the value fits in an 8-bit number. */
2159:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( ulValue > 0xffUL )
2160:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
2161:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xResult = pdFAIL;
2162:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
2163:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else
2164:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
2165:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			ucOctet[ uxOctetNumber ] = ( uint8_t ) ulValue;
 2557              	 .loc 1 2165 0
 2558 0012 B446     	 mov ip,r6
 2559              	.LBB248:
2149:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 2560              	 .loc 1 2149 0
 2561 0014 8046     	 mov r8,r0
 2562 0016 1EE0     	 b .L240
 2563              	.LVL305:
 2564              	.L241:
2141:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 2565              	 .loc 1 2141 0
 2566 0018 03EB8303 	 add r3,r3,r3,lsl#2
 2567              	.LVL306:
2145:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			ulValue += ( uint32_t ) xChar;
 2568              	 .loc 1 2145 0
 2569 001c 303A     	 subs r2,r2,#48
 2570              	.LVL307:
2146:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 2571              	 .loc 1 2146 0
 2572 001e 02EB4303 	 add r3,r2,r3,lsl#1
 2573              	.LVL308:
 2574              	.LBE248:
2136:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 2575              	 .loc 1 2136 0
 2576 0022 15F8012F 	 ldrb r2,[r5,#1]!
 2577              	.LVL309:
 2578 0026 A2F13004 	 sub r4,r2,#48
 2579 002a E4B2     	 uxtb r4,r4
 2580 002c 092C     	 cmp r4,#9
 2581 002e F3D9     	 bls .L241
2153:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 2582              	 .loc 1 2153 0
 2583 0030 8542     	 cmp r5,r0
 2584              	.LBB249:
2149:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 2585              	 .loc 1 2149 0
 2586 0032 04BF     	 itt eq
 2587 0034 4546     	 moveq r5,r8
 2588              	.LVL310:
 2589              	.LBE249:
2155:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 2590              	 .loc 1 2155 0
 2591 0036 6746     	 moveq r7,ip
 2592              	.LVL311:
2159:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 2593              	 .loc 1 2159 0
 2594 0038 FF2B     	 cmp r3,#255
 2595 003a 15D8     	 bhi .L251
 2596              	.LVL312:
 2597              	.L250:
 2598              	 .loc 1 2165 0
 2599 003c 0EF8013B 	 strb r3,[lr],#1
2166:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2167:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Check the next character is as expected. */
2168:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( uxOctetNumber < ( socketMAX_IP_ADDRESS_OCTETS - 1U ) )
 2600              	 .loc 1 2168 0
 2601 0040 022E     	 cmp r6,#2
 2602 0042 01D9     	 bls .L252
 2603 0044 03E0     	 b .L244
 2604              	.LVL313:
 2605              	.L258:
2155:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 2606              	 .loc 1 2155 0
 2607 0046 6746     	 mov r7,ip
 2608              	.LVL314:
 2609              	.L252:
2169:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
2170:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( *pcIPAddress != '.' )
 2610              	 .loc 1 2170 0
 2611 0048 2E2A     	 cmp r2,#46
 2612 004a 0DD1     	 bne .L251
2171:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
2172:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					xResult = pdFAIL;
2173:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
2174:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				else
2175:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
2176:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Move past the dot. */
2177:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					pcIPAddress++;
 2613              	 .loc 1 2177 0
 2614 004c 0135     	 adds r5,r5,#1
 2615              	.LVL315:
 2616              	.L244:
2178:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
2179:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
2180:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
2181:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2182:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( xResult == pdFAIL )
 2617              	 .loc 1 2182 0
 2618 004e 5FB1     	 cbz r7,.L251
2132:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 2619              	 .loc 1 2132 0 discriminator 2
 2620 0050 0136     	 adds r6,r6,#1
 2621              	.LVL316:
 2622 0052 042E     	 cmp r6,#4
 2623 0054 2DD0     	 beq .L246
 2624              	.LVL317:
 2625              	.L240:
2136:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 2626              	 .loc 1 2136 0
 2627 0056 2A78     	 ldrb r2,[r5]
 2628 0058 A2F13003 	 sub r3,r2,#48
 2629 005c DBB2     	 uxtb r3,r3
 2630 005e 092B     	 cmp r3,#9
 2631 0060 98BF     	 it ls
 2632 0062 6346     	 movls r3,ip
 2633 0064 D8D9     	 bls .L241
 2634 0066 1BE0     	 b .L261
 2635              	.LVL318:
 2636              	.L251:
2183:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
2184:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* No point going on. */
2185:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			break;
2186:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
2187:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
2188:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2189:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	if( *pcIPAddress != ( char ) 0 )
 2637              	 .loc 1 2189 0
 2638 0068 2B78     	 ldrb r3,[r5]
 2639 006a 9BB9     	 cbnz r3,.L256
2190:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
2191:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* Expected the end of the string. */
2192:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		xResult = pdFAIL;
2193:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
2194:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2195:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	if( uxOctetNumber != socketMAX_IP_ADDRESS_OCTETS )
 2640              	 .loc 1 2195 0
 2641 006c 042E     	 cmp r6,#4
 2642 006e 13D1     	 bne .L257
 2643 0070 0027     	 movs r7,#0
 2644              	.LVL319:
 2645              	.L254:
2196:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
2197:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* Didn't read enough octets. */
2198:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		xResult = pdFAIL;
2199:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
2200:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2201:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	if( xResult == pdPASS )
 2646              	 .loc 1 2201 0
 2647 0072 17B3     	 cbz r7,.L248
2202:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
2203:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* lint: ucOctet has been set because xResult == pdPASS. */
2204:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		ulReturn = FreeRTOS_inet_addr_quick( ucOctet[ 0 ], ucOctet[ 1 ], ucOctet[ 2 ], ucOctet[ 3 ] );
 2648              	 .loc 1 2204 0
 2649 0074 9DF80720 	 ldrb r2,[sp,#7]
 2650 0078 9DF80630 	 ldrb r3,[sp,#6]
 2651 007c 1B04     	 lsls r3,r3,#16
 2652 007e 43EA0262 	 orr r2,r3,r2,lsl#24
 2653 0082 9DF80430 	 ldrb r3,[sp,#4]
 2654 0086 1343     	 orrs r3,r3,r2
 2655 0088 9DF80520 	 ldrb r2,[sp,#5]
 2656 008c 43EA0223 	 orr r3,r3,r2,lsl#8
 2657 0090 0093     	 str r3,[sp]
 2658 0092 12E0     	 b .L248
 2659              	.LVL320:
 2660              	.L256:
2192:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 2661              	 .loc 1 2192 0
 2662 0094 0027     	 movs r7,#0
 2663 0096 10E0     	 b .L248
 2664              	.L257:
 2665 0098 0027     	 movs r7,#0
 2666 009a 0EE0     	 b .L248
 2667              	.LVL321:
 2668              	.L259:
 2669 009c 0027     	 movs r7,#0
 2670              	.LVL322:
 2671 009e 0CE0     	 b .L248
 2672              	.LVL323:
 2673              	.L261:
2153:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 2674              	 .loc 1 2153 0
 2675 00a0 A842     	 cmp r0,r5
 2676 00a2 01D0     	 beq .L249
 2677 00a4 6346     	 mov r3,ip
 2678 00a6 C9E7     	 b .L250
 2679              	.L249:
 2680              	.LVL324:
2165:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 2681              	 .loc 1 2165 0
 2682 00a8 0EF801CB 	 strb ip,[lr],#1
2168:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 2683              	 .loc 1 2168 0
 2684 00ac 022E     	 cmp r6,#2
 2685 00ae CAD9     	 bls .L258
 2686 00b0 DAE7     	 b .L251
 2687              	.LVL325:
 2688              	.L246:
2189:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 2689              	 .loc 1 2189 0
 2690 00b2 2B78     	 ldrb r3,[r5]
 2691 00b4 002B     	 cmp r3,#0
 2692 00b6 F1D1     	 bne .L259
 2693 00b8 DBE7     	 b .L254
 2694              	.LVL326:
 2695              	.L248:
2205:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
2206:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	else
2207:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
2208:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		ulReturn = 0UL;
2209:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
2210:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	pvCopySource = ( const void * ) &ulReturn;
2211:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	( void ) memcpy( pvDestination, pvCopySource, sizeof( ulReturn ) );
 2696              	 .loc 1 2211 0
 2697 00ba 0098     	 ldr r0,[sp]
 2698              	.LVL327:
 2699 00bc 0860     	 str r0,[r1]
2212:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2213:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	return xResult;
2214:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** }
 2700              	 .loc 1 2214 0
 2701 00be 3846     	 mov r0,r7
 2702 00c0 02B0     	 add sp,sp,#8
 2703              	.LCFI39:
 2704              	 .cfi_def_cfa_offset 24
 2705              	.LVL328:
 2706              	 
 2707 00c2 BDE8F081 	 pop {r4,r5,r6,r7,r8,pc}
 2708              	 .cfi_endproc
 2709              	.LFE79:
 2711 00c6 00BF     	 .section .text.FreeRTOS_inet_pton,"ax",%progbits
 2712              	 .align 2
 2713              	 .global FreeRTOS_inet_pton
 2714              	 .thumb
 2715              	 .thumb_func
 2717              	FreeRTOS_inet_pton:
 2718              	.LFB76:
2063:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** BaseType_t xResult;
 2719              	 .loc 1 2063 0
 2720              	 .cfi_startproc
 2721              	 
 2722              	 
 2723              	.LVL329:
2067:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 2724              	 .loc 1 2067 0
 2725 0000 0228     	 cmp r0,#2
 2726 0002 05D1     	 bne .L268
2063:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** BaseType_t xResult;
 2727              	 .loc 1 2063 0
 2728 0004 08B5     	 push {r3,lr}
 2729              	.LCFI40:
 2730              	 .cfi_def_cfa_offset 8
 2731              	 .cfi_offset 3,-8
 2732              	 .cfi_offset 14,-4
 2733 0006 0846     	 mov r0,r1
 2734              	.LVL330:
2070:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			break;
 2735              	 .loc 1 2070 0
 2736 0008 1146     	 mov r1,r2
 2737              	.LVL331:
 2738 000a FFF7FEFF 	 bl FreeRTOS_inet_pton4
 2739              	.LVL332:
2071:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		default:
 2740              	 .loc 1 2071 0
 2741 000e 08BD     	 pop {r3,pc}
 2742              	.LVL333:
 2743              	.L268:
 2744              	.LCFI41:
 2745              	 .cfi_def_cfa_offset 0
 2746              	 .cfi_restore 3
 2747              	 .cfi_restore 14
2073:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			break;
 2748              	 .loc 1 2073 0
 2749 0010 6FF06000 	 mvn r0,#96
 2750              	.LVL334:
 2751 0014 7047     	 bx lr
 2752              	 .cfi_endproc
 2753              	.LFE76:
 2755 0016 00BF     	 .section .text.FreeRTOS_inet_addr,"ax",%progbits
 2756              	 .align 2
 2757              	 .global FreeRTOS_inet_addr
 2758              	 .thumb
 2759              	 .thumb_func
 2761              	FreeRTOS_inet_addr:
 2762              	.LFB80:
2215:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
2216:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2217:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** uint32_t FreeRTOS_inet_addr( const char * pcIPAddress )
2218:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** {
 2763              	 .loc 1 2218 0
 2764              	 .cfi_startproc
 2765              	 
 2766              	 
 2767              	.LVL335:
 2768 0000 00B5     	 push {lr}
 2769              	.LCFI42:
 2770              	 .cfi_def_cfa_offset 4
 2771              	 .cfi_offset 14,-4
 2772 0002 83B0     	 sub sp,sp,#12
 2773              	.LCFI43:
 2774              	 .cfi_def_cfa_offset 16
2219:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** uint32_t ulReturn = 0UL;
 2775              	 .loc 1 2219 0
 2776 0004 02A9     	 add r1,sp,#8
 2777 0006 0023     	 movs r3,#0
 2778 0008 41F8043D 	 str r3,[r1,#-4]!
2220:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2221:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* inet_pton AF_INET target is a 4-byte 'struct in_addr'. */
2222:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	( void ) FreeRTOS_inet_pton4( pcIPAddress, &( ulReturn ) );
 2779              	 .loc 1 2222 0
 2780 000c FFF7FEFF 	 bl FreeRTOS_inet_pton4
 2781              	.LVL336:
2223:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2224:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	return ulReturn;
2225:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** }
 2782              	 .loc 1 2225 0
 2783 0010 0198     	 ldr r0,[sp,#4]
 2784 0012 03B0     	 add sp,sp,#12
 2785              	.LCFI44:
 2786              	 .cfi_def_cfa_offset 4
 2787              	 
 2788 0014 5DF804FB 	 ldr pc,[sp],#4
 2789              	 .cfi_endproc
 2790              	.LFE80:
 2792              	 .section .text.FreeRTOS_GetLocalAddress,"ax",%progbits
 2793              	 .align 2
 2794              	 .global FreeRTOS_GetLocalAddress
 2795              	 .thumb
 2796              	 .thumb_func
 2798              	FreeRTOS_GetLocalAddress:
 2799              	.LFB81:
2226:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
2227:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2228:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2229:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /* Function to get the local address and IP port */
2230:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** size_t FreeRTOS_GetLocalAddress( ConstSocket_t xSocket, struct freertos_sockaddr *pxAddress )
2231:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** {
 2800              	 .loc 1 2231 0
 2801              	 .cfi_startproc
 2802              	 
 2803              	 
 2804              	 
 2805              	.LVL337:
2232:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** const FreeRTOS_Socket_t *pxSocket = ( const FreeRTOS_Socket_t * ) xSocket;
2233:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2234:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* IP address of local machine. */
2235:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	pxAddress->sin_addr = *ipLOCAL_IP_ADDRESS_POINTER;
 2806              	 .loc 1 2235 0
 2807 0000 044B     	 ldr r3,.L274
 2808 0002 5B69     	 ldr r3,[r3,#20]
 2809 0004 4B60     	 str r3,[r1,#4]
2236:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2237:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* Local port on this machine. */
2238:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	pxAddress->sin_port = FreeRTOS_htons( pxSocket->usLocalPort );
 2810              	 .loc 1 2238 0
 2811 0006 828C     	 ldrh r2,[r0,#36]
 2812 0008 130A     	 lsrs r3,r2,#8
 2813 000a 43EA0223 	 orr r3,r3,r2,lsl#8
 2814 000e 4B80     	 strh r3,[r1,#2]
2239:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2240:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	return sizeof( *pxAddress );
2241:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** }
 2815              	 .loc 1 2241 0
 2816 0010 0820     	 movs r0,#8
 2817              	.LVL338:
 2818 0012 7047     	 bx lr
 2819              	.L275:
 2820              	 .align 2
 2821              	.L274:
 2822 0014 00000000 	 .word xDefaultPartUDPPacketHeader
 2823              	 .cfi_endproc
 2824              	.LFE81:
 2826              	 .section .text.vSocketWakeUpUser,"ax",%progbits
 2827              	 .align 2
 2828              	 .global vSocketWakeUpUser
 2829              	 .thumb
 2830              	 .thumb_func
 2832              	vSocketWakeUpUser:
 2833              	.LFB82:
2242:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2243:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
2244:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2245:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** void vSocketWakeUpUser( FreeRTOS_Socket_t *pxSocket )
2246:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** {
 2834              	 .loc 1 2246 0
 2835              	 .cfi_startproc
 2836              	 
 2837              	 
 2838              	.LVL339:
 2839 0000 10B5     	 push {r4,lr}
 2840              	.LCFI45:
 2841              	 .cfi_def_cfa_offset 8
 2842              	 .cfi_offset 4,-8
 2843              	 .cfi_offset 14,-4
 2844 0002 0446     	 mov r4,r0
2247:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /* _HT_ must work this out, now vSocketWakeUpUser will be called for any important
2248:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****  * event or transition */
2249:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	#if( ipconfigSOCKET_HAS_USER_SEMAPHORE == 1 )
2250:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
2251:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( pxSocket->pxUserSemaphore != NULL )
2252:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
2253:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			( void ) xSemaphoreGive( pxSocket->pxUserSemaphore );
2254:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
2255:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
2256:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	#endif /* ipconfigSOCKET_HAS_USER_SEMAPHORE */
2257:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2258:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	#if( ipconfigSOCKET_HAS_USER_WAKE_CALLBACK == 1 )
2259:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
2260:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( pxSocket->pxUserWakeCallback != NULL )
2261:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
2262:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pxSocket->pxUserWakeCallback( pxSocket );
2263:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
2264:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
2265:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	#endif /* ipconfigSOCKET_HAS_USER_WAKE_CALLBACK */
2266:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2267:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
2268:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
2269:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( pxSocket->pxSocketSet != NULL )
 2845              	 .loc 1 2269 0
 2846 0004 C36A     	 ldr r3,[r0,#44]
 2847 0006 4BB1     	 cbz r3,.L277
 2848              	.LBB250:
2270:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
2271:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			EventBits_t xSelectBits = ( pxSocket->xEventBits >> SOCKET_EVENT_BIT_COUNT ) & ( ( EventBits_t )
 2849              	 .loc 1 2271 0
 2850 0008 0168     	 ldr r1,[r0]
 2851 000a C1F30321 	 ubfx r1,r1,#8,#4
 2852              	.LVL340:
2272:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( xSelectBits != 0UL )
 2853              	 .loc 1 2272 0
 2854 000e 29B1     	 cbz r1,.L277
2273:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
2274:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocket->xSocketBits |= xSelectBits;
 2855              	 .loc 1 2274 0
 2856 0010 426B     	 ldr r2,[r0,#52]
 2857 0012 0A43     	 orrs r2,r2,r1
 2858 0014 4263     	 str r2,[r0,#52]
2275:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				( void ) xEventGroupSetBits( pxSocket->pxSocketSet->xSelectGroup, xSelectBits );
 2859              	 .loc 1 2275 0
 2860 0016 1868     	 ldr r0,[r3]
 2861              	.LVL341:
 2862 0018 FFF7FEFF 	 bl xEventGroupSetBits
 2863              	.LVL342:
 2864              	.L277:
 2865              	.LBE250:
2276:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
2277:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
2278:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2279:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		pxSocket->xEventBits &= ( EventBits_t ) eSOCKET_ALL;
 2866              	 .loc 1 2279 0
 2867 001c 2168     	 ldr r1,[r4]
 2868 001e 01F07F01 	 and r1,r1,#127
 2869 0022 2160     	 str r1,[r4]
2280:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
2281:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	#endif /* ipconfigSUPPORT_SELECT_FUNCTION */
2282:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2283:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	if( ( pxSocket->xEventGroup != NULL ) && ( pxSocket->xEventBits != 0U ) )
 2870              	 .loc 1 2283 0
 2871 0024 6068     	 ldr r0,[r4,#4]
 2872 0026 10B1     	 cbz r0,.L278
 2873              	 .loc 1 2283 0 is_stmt 0 discriminator 1
 2874 0028 09B1     	 cbz r1,.L278
2284:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
2285:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		( void ) xEventGroupSetBits( pxSocket->xEventGroup, pxSocket->xEventBits );
 2875              	 .loc 1 2285 0 is_stmt 1
 2876 002a FFF7FEFF 	 bl xEventGroupSetBits
 2877              	.LVL343:
 2878              	.L278:
2286:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
2287:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2288:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	pxSocket->xEventBits = 0UL;
 2879              	 .loc 1 2288 0
 2880 002e 0023     	 movs r3,#0
 2881 0030 2360     	 str r3,[r4]
 2882 0032 10BD     	 pop {r4,pc}
 2883              	 .cfi_endproc
 2884              	.LFE82:
 2886              	 .section .text.FreeRTOS_accept,"ax",%progbits
 2887              	 .align 2
 2888              	 .global FreeRTOS_accept
 2889              	 .thumb
 2890              	 .thumb_func
 2892              	FreeRTOS_accept:
 2893              	.LFB86:
2289:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** }
2290:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2291:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
2292:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2293:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigETHERNET_DRIVER_FILTERS_PACKETS == 1 )
2294:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2295:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* This define makes it possible for network-card drivers to inspect
2296:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 * UDP message and see if there is any UDP socket bound to a given port
2297:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 * number.
2298:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 * This is probably only useful in systems with a minimum of RAM and
2299:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 * when lots of anonymous broadcast messages come in
2300:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 */
2301:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t xPortHasUDPSocket( uint16_t usPortNr )
2302:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
2303:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t xFound = pdFALSE;
2304:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2305:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		vTaskSuspendAll();
2306:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
2307:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( ( pxListFindListItemWithValue( &xBoundUDPSocketsList, ( TickType_t ) usPortNr ) != NULL ) )
2308:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
2309:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xFound = pdTRUE;
2310:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
2311:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
2312:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		( void ) xTaskResumeAll();
2313:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2314:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		return xFound;
2315:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
2316:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2317:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigETHERNET_DRIVER_FILTERS_PACKETS */
2318:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2319:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
2320:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2321:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigUSE_TCP == 1 )
2322:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2323:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	static BaseType_t bMayConnect( FreeRTOS_Socket_t const * pxSocket )
2324:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
2325:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t xResult;
2326:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	eIPTCPState_t eState = ipNUMERIC_CAST( eIPTCPState_t, pxSocket->u.xTCP.ucTCPState );
2327:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2328:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		switch( eState )
2329:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
2330:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			case eCLOSED:
2331:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			case eCLOSE_WAIT:
2332:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xResult = 0;
2333:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				break;
2334:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			case eCONNECT_SYN:
2335:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xResult = -pdFREERTOS_ERRNO_EINPROGRESS;
2336:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				break;
2337:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			case eTCP_LISTEN:
2338:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			case eSYN_FIRST:
2339:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			case eSYN_RECEIVED:
2340:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			case eESTABLISHED:
2341:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			case eFIN_WAIT_1:
2342:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			case eFIN_WAIT_2:
2343:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			case eCLOSING:
2344:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			case eLAST_ACK:
2345:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			case eTIME_WAIT:
2346:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			default:
2347:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xResult = -pdFREERTOS_ERRNO_EAGAIN;
2348:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				break;
2349:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
2350:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		return xResult;
2351:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
2352:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2353:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigUSE_TCP */
2354:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
2355:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2356:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigUSE_TCP == 1 )
2357:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2358:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	static BaseType_t prvTCPConnectStart( FreeRTOS_Socket_t * pxSocket, struct freertos_sockaddr const
2359:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
2360:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t xResult = 0;
2361:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2362:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( pxAddress == NULL )
2363:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
2364:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* NULL address passed to the function. Invalid value. */
2365:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xResult = -pdFREERTOS_ERRNO_EINVAL;
2366:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
2367:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_TCP, pdFALSE ) == pdFALSE )
2368:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
2369:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Not a valid socket or wrong type */
2370:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xResult = -pdFREERTOS_ERRNO_EBADF;
2371:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
2372:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else if( FreeRTOS_issocketconnected( pxSocket ) > 0 )
2373:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
2374:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* The socket is already connected. */
2375:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xResult = -pdFREERTOS_ERRNO_EISCONN;
2376:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
2377:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else if( !socketSOCKET_IS_BOUND( pxSocket ) )
2378:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
2379:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Bind the socket to the port that the client task will send from.
2380:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			Non-standard, so the error returned is that returned by bind(). */
2381:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xResult = FreeRTOS_bind( pxSocket, NULL, 0U );
2382:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
2383:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else
2384:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
2385:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* The socket is valid, not yet connected, and already bound to a port number. */
2386:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
2387:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2388:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( xResult == 0 )
2389:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
2390:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Check if it makes any sense to wait for a connect event, this condition
2391:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			might change while sleeping, so it must be checked within each loop */
2392:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xResult = bMayConnect( pxSocket ); /* -EINPROGRESS, -EAGAIN, or 0 for OK */
2393:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2394:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Start the connect procedure, kernel will start working on it */
2395:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( xResult == 0 )
2396:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
2397:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocket->u.xTCP.bits.bConnPrepared = pdFALSE;
2398:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocket->u.xTCP.ucRepCount = 0U;
2399:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2400:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				FreeRTOS_debug_printf( ( "FreeRTOS_connect: %u to %lxip:%u\n",
2401:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					pxSocket->usLocalPort, FreeRTOS_ntohl( pxAddress->sin_addr ), FreeRTOS_ntohs( pxAddress->sin_p
2402:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2403:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* Port on remote machine. */
2404:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocket->u.xTCP.usRemotePort = FreeRTOS_ntohs( pxAddress->sin_port );
2405:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2406:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* IP address of remote machine. */
2407:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocket->u.xTCP.ulRemoteIP = FreeRTOS_ntohl( pxAddress->sin_addr );
2408:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2409:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* (client) internal state: socket wants to send a connect. */
2410:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				vTCPStateChange( pxSocket, eCONNECT_SYN );
2411:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2412:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* To start an active connect. */
2413:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocket->u.xTCP.usTimeout = 1U;
2414:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2415:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( xSendEventToIPTask( eTCPTimerEvent ) != pdPASS )
2416:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
2417:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					xResult = -pdFREERTOS_ERRNO_ECANCELED;
2418:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
2419:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
2420:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
2421:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2422:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		return xResult;
2423:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
2424:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2425:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigUSE_TCP */
2426:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
2427:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2428:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigUSE_TCP == 1 )
2429:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2430:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/*
2431:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 * FreeRTOS_connect: socket wants to connect to a remote port
2432:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 */
2433:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t FreeRTOS_connect( Socket_t xClientSocket, struct freertos_sockaddr *pxAddress, socklen_
2434:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
2435:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t* ) xClientSocket;
2436:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	TickType_t xRemainingTime;
2437:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t xTimed = pdFALSE;
2438:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t xResult = -pdFREERTOS_ERRNO_EINVAL;
2439:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	TimeOut_t xTimeOut;
2440:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2441:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		( void ) xAddressLength;
2442:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2443:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		xResult = prvTCPConnectStart( pxSocket, pxAddress );
2444:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2445:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( xResult == 0 )
2446:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
2447:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* And wait for the result */
2448:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			for( ;; )
2449:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
2450:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( xTimed == pdFALSE )
2451:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
2452:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Only in the first round, check for non-blocking */
2453:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					xRemainingTime = pxSocket->xReceiveBlockTime;
2454:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( xRemainingTime == ( TickType_t )0 )
2455:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
2456:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						/* Not yet connected, correct state, non-blocking. */
2457:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						xResult = -pdFREERTOS_ERRNO_EWOULDBLOCK;
2458:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						break;
2459:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
2460:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2461:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Don't get here a second time. */
2462:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					xTimed = pdTRUE;
2463:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2464:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Fetch the current time */
2465:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					vTaskSetTimeOutState( &xTimeOut );
2466:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
2467:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2468:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* Did it get connected while sleeping ? */
2469:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xResult = FreeRTOS_issocketconnected( pxSocket );
2470:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2471:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* Returns positive when connected, negative means an error */
2472:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( xResult < 0 )
2473:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
2474:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Return the error */
2475:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					break;
2476:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
2477:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2478:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( xResult > 0 )
2479:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
2480:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Socket now connected, return a zero */
2481:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					xResult = 0;
2482:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					break;
2483:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
2484:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2485:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* Is it allowed to sleep more? */
2486:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xRemainingTime ) != pdFALSE )
2487:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
2488:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					xResult = -pdFREERTOS_ERRNO_ETIMEDOUT;
2489:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					break;
2490:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
2491:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2492:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* Go sleeping until we get any down-stream event */
2493:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				( void ) xEventGroupWaitBits( pxSocket->xEventGroup, ( EventBits_t ) eSOCKET_CONNECT, pdTRUE /*
2494:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
2495:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
2496:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2497:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		return xResult;
2498:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
2499:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigUSE_TCP */
2500:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
2501:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2502:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigUSE_TCP == 1 )
2503:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2504:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/*
2505:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 * FreeRTOS_accept: can return a new connected socket
2506:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 * if the server socket is in listen mode and receives a connection request
2507:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 * The new socket will be bound already to the same port number as the listing
2508:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 * socket.
2509:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 */
2510:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	Socket_t FreeRTOS_accept( Socket_t xServerSocket, struct freertos_sockaddr *pxAddress, socklen_t *
2511:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 2894              	 .loc 1 2511 0
 2895              	 .cfi_startproc
 2896              	 
 2897              	 
 2898              	.LVL344:
 2899 0000 2DE9F04F 	 push {r4,r5,r6,r7,r8,r9,r10,fp,lr}
 2900              	.LCFI46:
 2901              	 .cfi_def_cfa_offset 36
 2902              	 .cfi_offset 4,-36
 2903              	 .cfi_offset 5,-32
 2904              	 .cfi_offset 6,-28
 2905              	 .cfi_offset 7,-24
 2906              	 .cfi_offset 8,-20
 2907              	 .cfi_offset 9,-16
 2908              	 .cfi_offset 10,-12
 2909              	 .cfi_offset 11,-8
 2910              	 .cfi_offset 14,-4
 2911 0004 8BB0     	 sub sp,sp,#44
 2912              	.LCFI47:
 2913              	 .cfi_def_cfa_offset 80
 2914 0006 0546     	 mov r5,r0
 2915 0008 0E46     	 mov r6,r1
 2916 000a 9046     	 mov r8,r2
 2917              	.LVL345:
2512:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xServerSocket;
2513:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	FreeRTOS_Socket_t *pxClientSocket = NULL;
2514:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	TickType_t xRemainingTime;
2515:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t xTimed = pdFALSE, xAsk = pdFALSE;
2516:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	TimeOut_t xTimeOut;
2517:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	IPStackEvent_t xAskEvent;
2518:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2519:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_TCP, pdTRUE ) == pdFALSE )
 2918              	 .loc 1 2519 0
 2919 000c 0621     	 movs r1,#6
 2920              	.LVL346:
 2921 000e 0122     	 movs r2,#1
 2922              	.LVL347:
 2923 0010 FFF7FEFF 	 bl prvValidSocket
 2924              	.LVL348:
 2925 0014 0028     	 cmp r0,#0
 2926 0016 71D0     	 beq .L291
2520:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
2521:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Not a valid socket or wrong type */
2522:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pxClientSocket = FREERTOS_INVALID_SOCKET;
2523:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
2524:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else if( ( pxSocket->u.xTCP.bits.bReuseSocket == pdFALSE_UNSIGNED ) &&
 2927              	 .loc 1 2524 0
 2928 0018 95F84030 	 ldrb r3,[r5,#64]
 2929 001c 13F0080F 	 tst r3,#8
 2930 0020 07D1     	 bne .L292
 2931              	 .loc 1 2524 0 is_stmt 0 discriminator 1
 2932 0022 95F85330 	 ldrb r3,[r5,#83]
 2933 0026 012B     	 cmp r3,#1
 2934 0028 6BD1     	 bne .L293
 2935 002a 4FF0000A 	 mov r10,#0
 2936 002e D146     	 mov r9,r10
 2937 0030 02E0     	 b .L282
 2938              	.L292:
 2939 0032 4FF0000A 	 mov r10,#0
 2940 0036 D146     	 mov r9,r10
 2941              	.L282:
2525:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				 ( pxSocket->u.xTCP.ucTCPState != ( uint8_t ) eTCP_LISTEN ) )
2526:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
2527:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Parent socket is not in listening mode */
2528:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pxClientSocket = FREERTOS_INVALID_SOCKET;
2529:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
2530:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else
2531:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
2532:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Loop will stop with breaks. */
2533:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			for( ; ; )
2534:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
2535:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* Is there a new client? */
2536:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				vTaskSuspendAll();
2537:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
2538:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( pxSocket->u.xTCP.bits.bReuseSocket == pdFALSE_UNSIGNED )
2539:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
2540:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						pxClientSocket = pxSocket->u.xTCP.pxPeerSocket;
2541:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
2542:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					else
2543:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
2544:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						pxClientSocket = pxSocket;
 2942              	 .loc 1 2544 0 is_stmt 1
 2943 0038 0395     	 str r5,[sp,#12]
 2944 003a 0027     	 movs r7,#0
2545:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
2546:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( pxClientSocket != NULL )
2547:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
2548:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						pxSocket->u.xTCP.pxPeerSocket = NULL;
2549:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2550:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						/* Is it still not taken ? */
2551:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						if( pxClientSocket->u.xTCP.bits.bPassAccept != pdFALSE_UNSIGNED )
2552:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						{
2553:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							pxClientSocket->u.xTCP.bits.bPassAccept = pdFALSE;
2554:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						}
2555:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						else
2556:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						{
2557:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							pxClientSocket = NULL;
2558:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						}
2559:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
2560:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
2561:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				( void ) xTaskResumeAll();
2562:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2563:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( pxClientSocket != NULL )
2564:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
2565:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( pxAddress != NULL )
2566:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
2567:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						/* IP address of remote machine. */
2568:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						pxAddress->sin_addr = FreeRTOS_ntohl( pxClientSocket->u.xTCP.ulRemoteIP );
2569:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2570:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						/* Port on remote machine. */
2571:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						pxAddress->sin_port = FreeRTOS_ntohs( pxClientSocket->u.xTCP.usRemotePort );
2572:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
2573:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( pxAddressLength != NULL )
2574:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
2575:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						*pxAddressLength = sizeof( *pxAddress );
2576:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
2577:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2578:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( pxSocket->u.xTCP.bits.bReuseSocket == pdFALSE_UNSIGNED )
2579:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
2580:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						xAsk = pdTRUE;
2581:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
2582:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
2583:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2584:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( xAsk != pdFALSE )
2585:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
2586:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Ask to set an event in 'xEventGroup' as soon as a new
2587:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					client gets connected for this listening socket. */
2588:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					xAskEvent.eEventType = eTCPAcceptEvent;
 2945              	 .loc 1 2588 0
 2946 003c 4FF0070B 	 mov fp,#7
 2947              	.LVL349:
 2948              	.L299:
2536:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 2949              	 .loc 1 2536 0
 2950 0040 FFF7FEFF 	 bl vTaskSuspendAll
 2951              	.LVL350:
2538:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 2952              	 .loc 1 2538 0
 2953 0044 95F84030 	 ldrb r3,[r5,#64]
 2954 0048 13F0080F 	 tst r3,#8
2540:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
 2955              	 .loc 1 2540 0
 2956 004c 0CBF     	 ite eq
 2957 004e 6C6D     	 ldreq r4,[r5,#84]
 2958              	.LVL351:
2544:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
 2959              	 .loc 1 2544 0
 2960 0050 039C     	 ldrne r4,[sp,#12]
 2961              	.LVL352:
2546:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 2962              	 .loc 1 2546 0
 2963 0052 002C     	 cmp r4,#0
 2964 0054 5CD0     	 beq .L284
2548:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 2965              	 .loc 1 2548 0
 2966 0056 6F65     	 str r7,[r5,#84]
2551:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						{
 2967              	 .loc 1 2551 0
 2968 0058 94F84030 	 ldrb r3,[r4,#64]
 2969 005c 13F0020F 	 tst r3,#2
 2970 0060 56D0     	 beq .L284
2553:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						}
 2971              	 .loc 1 2553 0
 2972 0062 94F84030 	 ldrb r3,[r4,#64]
 2973 0066 6FF34103 	 bfc r3,#1,#1
 2974 006a 84F84030 	 strb r3,[r4,#64]
2561:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 2975              	 .loc 1 2561 0
 2976 006e FFF7FEFF 	 bl xTaskResumeAll
 2977              	.LVL353:
2565:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 2978              	 .loc 1 2565 0
 2979 0072 8EB1     	 cbz r6,.L285
2568:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 2980              	 .loc 1 2568 0
 2981 0074 A16B     	 ldr r1,[r4,#56]
 2982 0076 0A06     	 lsls r2,r1,#24
 2983 0078 42EA1162 	 orr r2,r2,r1,lsr#24
 2984 007c 01F47F43 	 and r3,r1,#65280
 2985 0080 42EA0322 	 orr r2,r2,r3,lsl#8
 2986 0084 01F47F03 	 and r3,r1,#16711680
 2987 0088 42EA1323 	 orr r3,r2,r3,lsr#8
 2988 008c 7360     	 str r3,[r6,#4]
2571:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
 2989              	 .loc 1 2571 0
 2990 008e A28F     	 ldrh r2,[r4,#60]
 2991 0090 130A     	 lsrs r3,r2,#8
 2992 0092 43EA0223 	 orr r3,r3,r2,lsl#8
 2993 0096 7380     	 strh r3,[r6,#2]
 2994              	.L285:
2573:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 2995              	 .loc 1 2573 0
 2996 0098 B8F1000F 	 cmp r8,#0
 2997 009c 02D0     	 beq .L286
2575:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
 2998              	 .loc 1 2575 0
 2999 009e 0823     	 movs r3,#8
 3000 00a0 C8F80030 	 str r3,[r8]
 3001              	.L286:
2578:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 3002              	 .loc 1 2578 0
 3003 00a4 95F84030 	 ldrb r3,[r5,#64]
 3004 00a8 13F0080F 	 tst r3,#8
 3005 00ac 36D1     	 bne .L287
2580:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
 3006              	 .loc 1 2580 0
 3007 00ae 4FF0010A 	 mov r10,#1
 3008              	.LVL354:
 3009 00b2 00E0     	 b .L289
 3010              	.LVL355:
 3011              	.L297:
 3012 00b4 3C46     	 mov r4,r7
 3013              	.LVL356:
 3014              	.L289:
 3015              	 .loc 1 2588 0
 3016 00b6 8DF814B0 	 strb fp,[sp,#20]
2589:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					xAskEvent.pvData = pxSocket;
 3017              	 .loc 1 2589 0
 3018 00ba 039B     	 ldr r3,[sp,#12]
 3019 00bc 0693     	 str r3,[sp,#24]
2590:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					( void ) xSendEventStructToIPTask( &xAskEvent, portMAX_DELAY );
 3020              	 .loc 1 2590 0
 3021 00be 05A8     	 add r0,sp,#20
 3022 00c0 4FF0FF31 	 mov r1,#-1
 3023 00c4 FFF7FEFF 	 bl xSendEventStructToIPTask
 3024              	.LVL357:
2591:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
2592:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2593:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( pxClientSocket != NULL )
 3025              	 .loc 1 2593 0
 3026 00c8 5CBB     	 cbnz r4,.L298
 3027              	.L290:
2594:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
2595:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					break;
2596:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
2597:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2598:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( xTimed == pdFALSE )
 3028              	 .loc 1 2598 0
 3029 00ca B9F1000F 	 cmp r9,#0
 3030 00ce 07D1     	 bne .L288
2599:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
2600:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Only in the first round, check for non-blocking */
2601:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					xRemainingTime = pxSocket->xReceiveBlockTime;
 3031              	 .loc 1 2601 0
 3032 00d0 EB69     	 ldr r3,[r5,#28]
 3033 00d2 0993     	 str r3,[sp,#36]
2602:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( xRemainingTime == ( TickType_t ) 0 )
 3034              	 .loc 1 2602 0
 3035 00d4 C3B1     	 cbz r3,.L295
 3036              	.LVL358:
2603:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
2604:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						break;
2605:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
2606:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2607:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Don't get here a second time */
2608:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					xTimed = pdTRUE;
2609:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2610:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Fetch the current time */
2611:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					vTaskSetTimeOutState( &xTimeOut );
 3037              	 .loc 1 2611 0
 3038 00d6 07A8     	 add r0,sp,#28
 3039 00d8 FFF7FEFF 	 bl vTaskSetTimeOutState
 3040              	.LVL359:
2608:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 3041              	 .loc 1 2608 0
 3042 00dc 4FF00109 	 mov r9,#1
 3043              	.LVL360:
 3044              	.L288:
2612:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
2613:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2614:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* Has the timeout been reached? */
2615:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xRemainingTime ) != pdFALSE )
 3045              	 .loc 1 2615 0
 3046 00e0 07A8     	 add r0,sp,#28
 3047 00e2 09A9     	 add r1,sp,#36
 3048 00e4 FFF7FEFF 	 bl xTaskCheckForTimeOut
 3049              	.LVL361:
 3050 00e8 80B9     	 cbnz r0,.L296
2616:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
2617:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					break;
2618:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
2619:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2620:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* Go sleeping until we get any down-stream event */
2621:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				( void ) xEventGroupWaitBits( pxSocket->xEventGroup, ( EventBits_t ) eSOCKET_ACCEPT, pdTRUE /*x
 3051              	 .loc 1 2621 0
 3052 00ea 099B     	 ldr r3,[sp,#36]
 3053 00ec 0093     	 str r3,[sp]
 3054 00ee 6868     	 ldr r0,[r5,#4]
 3055 00f0 0421     	 movs r1,#4
 3056 00f2 0122     	 movs r2,#1
 3057 00f4 3B46     	 mov r3,r7
 3058 00f6 FFF7FEFF 	 bl xEventGroupWaitBits
 3059              	.LVL362:
2622:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 3060              	 .loc 1 2622 0
 3061 00fa A1E7     	 b .L299
 3062              	.LVL363:
 3063              	.L291:
2522:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 3064              	 .loc 1 2522 0
 3065 00fc 4FF0FF34 	 mov r4,#-1
 3066 0100 0FE0     	 b .L298
 3067              	.L293:
2528:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 3068              	 .loc 1 2528 0
 3069 0102 4FF0FF34 	 mov r4,#-1
 3070 0106 0CE0     	 b .L298
 3071              	.LVL364:
 3072              	.L295:
 3073 0108 0024     	 movs r4,#0
 3074 010a 0AE0     	 b .L298
 3075              	.L296:
 3076 010c 0024     	 movs r4,#0
 3077 010e 08E0     	 b .L298
 3078              	.LVL365:
 3079              	.L284:
2561:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 3080              	 .loc 1 2561 0
 3081 0110 FFF7FEFF 	 bl xTaskResumeAll
 3082              	.LVL366:
2584:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 3083              	 .loc 1 2584 0
 3084 0114 BAF1000F 	 cmp r10,#0
 3085 0118 D7D0     	 beq .L290
 3086 011a CBE7     	 b .L297
 3087              	.LVL367:
 3088              	.L287:
 3089 011c BAF1000F 	 cmp r10,#0
 3090 0120 C9D1     	 bne .L289
 3091              	.LVL368:
 3092              	.L298:
2623:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
2624:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2625:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		return pxClientSocket;
2626:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 3093              	 .loc 1 2626 0
 3094 0122 2046     	 mov r0,r4
 3095 0124 0BB0     	 add sp,sp,#44
 3096              	.LCFI48:
 3097              	 .cfi_def_cfa_offset 36
 3098              	 
 3099 0126 BDE8F08F 	 pop {r4,r5,r6,r7,r8,r9,r10,fp,pc}
 3100              	 .cfi_endproc
 3101              	.LFE86:
 3103 012a 00BF     	 .section .text.FreeRTOS_recv,"ax",%progbits
 3104              	 .align 2
 3105              	 .global FreeRTOS_recv
 3106              	 .thumb
 3107              	 .thumb_func
 3109              	FreeRTOS_recv:
 3110              	.LFB87:
2627:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigUSE_TCP */
2628:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
2629:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2630:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigUSE_TCP == 1 )
2631:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2632:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/*
2633:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 * Read incoming data from a TCP socket
2634:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 * Only after the last byte has been read, a close error might be returned
2635:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 */
2636:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t FreeRTOS_recv( Socket_t xSocket, void *pvBuffer, size_t uxBufferLength, BaseType_t xFla
2637:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 3111              	 .loc 1 2637 0
 3112              	 .cfi_startproc
 3113              	 
 3114              	 
 3115              	.LVL369:
 3116 0000 2DE9F04F 	 push {r4,r5,r6,r7,r8,r9,r10,fp,lr}
 3117              	.LCFI49:
 3118              	 .cfi_def_cfa_offset 36
 3119              	 .cfi_offset 4,-36
 3120              	 .cfi_offset 5,-32
 3121              	 .cfi_offset 6,-28
 3122              	 .cfi_offset 7,-24
 3123              	 .cfi_offset 8,-20
 3124              	 .cfi_offset 9,-16
 3125              	 .cfi_offset 10,-12
 3126              	 .cfi_offset 11,-8
 3127              	 .cfi_offset 14,-4
 3128 0004 89B0     	 sub sp,sp,#36
 3129              	.LCFI50:
 3130              	 .cfi_def_cfa_offset 72
 3131 0006 0446     	 mov r4,r0
 3132 0008 0291     	 str r1,[sp,#8]
 3133 000a 0392     	 str r2,[sp,#12]
 3134 000c 9A46     	 mov r10,r3
 3135              	.LVL370:
2638:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t xByteCount;
2639:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
2640:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	TickType_t xRemainingTime;
2641:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t xTimed = pdFALSE;
2642:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	TimeOut_t xTimeOut;
2643:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	EventBits_t xEventBits = ( EventBits_t ) 0;
2644:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2645:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* Check if the socket is valid, has type TCP and if it is bound to a
2646:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		port. */
2647:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_TCP, pdTRUE ) == pdFALSE )
 3136              	 .loc 1 2647 0
 3137 000e 0621     	 movs r1,#6
 3138              	.LVL371:
 3139 0010 0122     	 movs r2,#1
 3140              	.LVL372:
 3141 0012 FFF7FEFF 	 bl prvValidSocket
 3142              	.LVL373:
 3143 0016 0028     	 cmp r0,#0
 3144 0018 00F0BB80 	 beq .L319
2648:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
2649:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xByteCount = -pdFREERTOS_ERRNO_EINVAL;
2650:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
2651:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else if( ( ( ( uint32_t ) xFlags & ( uint32_t ) FREERTOS_ZERO_COPY ) != 0U ) &&
 3145              	 .loc 1 2651 0
 3146 001c D146     	 mov r9,r10
 3147 001e 1AF0010B 	 ands fp,r10,#1
 3148 0022 03D0     	 beq .L303
 3149              	 .loc 1 2651 0 is_stmt 0 discriminator 1
 3150 0024 029B     	 ldr r3,[sp,#8]
 3151 0026 002B     	 cmp r3,#0
 3152 0028 00F0B680 	 beq .L320
 3153              	.L303:
2652:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			 ( pvBuffer == NULL ) )
2653:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
2654:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* In zero-copy mode, pvBuffer is a pointer to a pointer ( not NULL ). */
2655:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xByteCount = -pdFREERTOS_ERRNO_EINVAL;
2656:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
2657:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else
2658:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
2659:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( pxSocket->u.xTCP.rxStream != NULL )
 3154              	 .loc 1 2659 0 is_stmt 1
 3155 002c 626F     	 ldr r2,[r4,#116]
 3156 002e 6AB1     	 cbz r2,.L321
 3157              	.LVL374:
 3158              	.LBB251:
 3159              	.LBB252:
 3160              	 .file 3 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include/FreeRTOS_Stream_Buffer.h"
   1:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** /*
   2:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  * FreeRTOS+TCP V2.2.2
   3:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  *
   5:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  * this software and associated documentation files (the "Software"), to deal in
   7:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  * the Software without restriction, including without limitation the rights to
   8:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  * subject to the following conditions:
  11:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  *
  12:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  * The above copyright notice and this permission notice shall be included in all
  13:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  * copies or substantial portions of the Software.
  14:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  *
  15:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  *
  22:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  * http://aws.amazon.com/freertos
  23:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  * http://www.FreeRTOS.org
  24:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  */
  25:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
  26:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** /*
  27:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  *	FreeRTOS_Stream_Buffer.h
  28:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  *
  29:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  *	A cicular character buffer
  30:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  *	An implementation of a circular buffer without a length field
  31:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  *	If LENGTH defines the size of the buffer, a maximum of (LENGT-1) bytes can be stored
  32:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  *	In order to add or read data from the buffer, memcpy() will be called at most 2 times
  33:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  */
  34:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
  35:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** #ifndef FREERTOS_STREAM_BUFFER_H
  36:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** #define	FREERTOS_STREAM_BUFFER_H
  37:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
  38:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** #ifdef __cplusplus
  39:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** extern "C" {
  40:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** #endif
  41:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
  42:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** typedef struct xSTREAM_BUFFER {
  43:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	volatile size_t uxTail;		/* next item to read */
  44:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	volatile size_t uxMid;		/* iterator within the valid items */
  45:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	volatile size_t uxHead;		/* next position store a new item */
  46:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	volatile size_t uxFront;	/* iterator within the free space */
  47:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	size_t LENGTH;				/* const value: number of reserved elements */
  48:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	uint8_t ucArray[ sizeof( size_t ) ];
  49:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** } StreamBuffer_t;
  50:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
  51:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** static portINLINE void vStreamBufferClear( StreamBuffer_t *pxBuffer );
  52:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** static portINLINE void vStreamBufferClear( StreamBuffer_t *pxBuffer )
  53:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** {
  54:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	/* Make the circular buffer empty */
  55:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	pxBuffer->uxHead = 0U;
  56:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	pxBuffer->uxTail = 0U;
  57:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	pxBuffer->uxFront = 0U;
  58:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	pxBuffer->uxMid = 0U;
  59:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** }
  60:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** /*-----------------------------------------------------------*/
  61:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
  62:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** static portINLINE size_t uxStreamBufferSpace( const StreamBuffer_t *pxBuffer, const size_t uxLower,
  63:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** static portINLINE size_t uxStreamBufferSpace( const StreamBuffer_t *pxBuffer, const size_t uxLower,
  64:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** {
  65:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** /* Returns the space between uxLower and uxUpper, which equals to the distance minus 1 */
  66:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxCount;
  67:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
  68:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	uxCount = pxBuffer->LENGTH + uxUpper - uxLower - 1U;
  69:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	if( uxCount >= pxBuffer->LENGTH )
  70:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	{
  71:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 		uxCount -= pxBuffer->LENGTH;
  72:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	}
  73:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
  74:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	return uxCount;
  75:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** }
  76:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** /*-----------------------------------------------------------*/
  77:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
  78:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** static portINLINE size_t uxStreamBufferDistance( const StreamBuffer_t *pxBuffer, const size_t uxLow
  79:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** static portINLINE size_t uxStreamBufferDistance( const StreamBuffer_t *pxBuffer, const size_t uxLow
  80:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** {
  81:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** /* Returns the distance between uxLower and uxUpper */
  82:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxCount;
  83:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
  84:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
  85:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	if ( uxCount >= pxBuffer->LENGTH )
  86:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	{
  87:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 		uxCount -= pxBuffer->LENGTH;
  88:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	}
  89:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
  90:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	return uxCount;
  91:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** }
  92:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** /*-----------------------------------------------------------*/
  93:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
  94:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** static portINLINE size_t uxStreamBufferGetSpace( const StreamBuffer_t *pxBuffer );
  95:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** static portINLINE size_t uxStreamBufferGetSpace( const StreamBuffer_t *pxBuffer )
  96:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** {
  97:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** /* Returns the number of items which can still be added to uxHead
  98:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** before hitting on uxTail */
  99:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxHead = pxBuffer->uxHead;
 100:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxTail = pxBuffer->uxTail;
 101:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
 102:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	return uxStreamBufferSpace( pxBuffer, uxHead, uxTail );
 103:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** }
 104:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** /*-----------------------------------------------------------*/
 105:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
 106:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** static portINLINE size_t uxStreamBufferFrontSpace( const StreamBuffer_t *pxBuffer );
 107:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** static portINLINE size_t uxStreamBufferFrontSpace( const StreamBuffer_t *pxBuffer )
 108:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** {
 109:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** /* Distance between uxFront and uxTail
 110:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** or the number of items which can still be added to uxFront,
 111:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** before hitting on uxTail */
 112:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
 113:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxFront = pxBuffer->uxFront;
 114:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxTail = pxBuffer->uxTail;
 115:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
 116:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	return uxStreamBufferSpace( pxBuffer, uxFront, uxTail );
 117:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** }
 118:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** /*-----------------------------------------------------------*/
 119:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
 120:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** static portINLINE size_t uxStreamBufferGetSize( const StreamBuffer_t *pxBuffer );
 121:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** static portINLINE size_t uxStreamBufferGetSize( const StreamBuffer_t *pxBuffer )
 122:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** {
 123:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** /* Returns the number of items which can be read from uxTail
 124:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** before reaching uxHead */
 125:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxHead = pxBuffer->uxHead;
 3161              	 .loc 3 125 0
 3162 0030 9368     	 ldr r3,[r2,#8]
 3163              	.LVL375:
 126:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxTail = pxBuffer->uxTail;
 3164              	 .loc 3 126 0
 3165 0032 1168     	 ldr r1,[r2]
 3166              	.LVL376:
 3167              	.LBB253:
 3168              	.LBB254:
  84:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	if ( uxCount >= pxBuffer->LENGTH )
 3169              	 .loc 3 84 0
 3170 0034 1269     	 ldr r2,[r2,#16]
 3171              	.LVL377:
 3172 0036 1344     	 add r3,r3,r2
 3173              	.LVL378:
 3174 0038 5B1A     	 subs r3,r3,r1
 3175              	.LVL379:
  85:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	{
 3176              	 .loc 3 85 0
 3177 003a 9A42     	 cmp r2,r3
  87:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	}
 3178              	 .loc 3 87 0
 3179 003c 98BF     	 it ls
 3180 003e 9B1A     	 subls r3,r3,r2
 3181              	.LVL380:
 3182              	.LBE254:
 3183              	.LBE253:
 3184              	.LBE252:
 3185              	.LBE251:
2660:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
2661:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xByteCount = ( BaseType_t )uxStreamBufferGetSize ( pxSocket->u.xTCP.rxStream );
 3186              	 .loc 1 2661 0
 3187 0040 1F46     	 mov r7,r3
 3188              	.LVL381:
2662:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
2663:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			else
2664:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
2665:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xByteCount = 0;
2666:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
2667:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2668:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			while( xByteCount == 0 )
 3189              	 .loc 1 2668 0
 3190 0042 002B     	 cmp r3,#0
 3191 0044 5DD1     	 bne .L318
 3192 0046 0025     	 movs r5,#0
 3193 0048 2E46     	 mov r6,r5
 3194 004a 01E0     	 b .L326
 3195              	.LVL382:
 3196              	.L321:
 3197 004c 0025     	 movs r5,#0
 3198 004e 2E46     	 mov r6,r5
 3199              	.L326:
2669:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
2670:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				switch( ipNUMERIC_CAST( eIPTCPState_t, pxSocket->u.xTCP.ucTCPState ) )
2671:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
2672:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				case eCLOSED:
2673:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				case eCLOSE_WAIT:	/* (server + client) waiting for a connection termination request from the lo
2674:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				case eCLOSING:		/* (server + client) waiting for a connection termination request acknowledgeme
2675:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( pxSocket->u.xTCP.bits.bMallocError != pdFALSE_UNSIGNED )
2676:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
2677:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						/* The no-memory error has priority above the non-connected error.
2678:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						Both are fatal and will elad to closing the socket. */
2679:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						xByteCount = -pdFREERTOS_ERRNO_ENOMEM;
2680:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
2681:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					else
2682:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
2683:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						xByteCount = -pdFREERTOS_ERRNO_ENOTCONN;
2684:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
2685:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					break;
2686:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2687:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				case eTCP_LISTEN:
2688:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				case eCONNECT_SYN:
2689:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				case eSYN_FIRST:
2690:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				case eSYN_RECEIVED:
2691:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				case eESTABLISHED:
2692:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				case eFIN_WAIT_1:
2693:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				case eFIN_WAIT_2:
2694:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				case eLAST_ACK:
2695:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				case eTIME_WAIT:
2696:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				default:
2697:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Nothing. */
2698:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					break;
2699:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
2700:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( xByteCount < 0 )
2701:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
2702:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					break;
2703:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
2704:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2705:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( xTimed == pdFALSE )
2706:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
2707:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Only in the first round, check for non-blocking. */
2708:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					xRemainingTime = pxSocket->xReceiveBlockTime;
2709:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2710:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( xRemainingTime == ( TickType_t ) 0 )
2711:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
2712:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						#if( ipconfigSUPPORT_SIGNALS != 0 )
2713:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						{
2714:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							/* Just check for the interrupt flag. */
2715:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							xEventBits = xEventGroupWaitBits( pxSocket->xEventGroup, ( EventBits_t ) eSOCKET_INTR,
2716:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 								pdTRUE /*xClearOnExit*/, pdFALSE /*xWaitAllBits*/, socketDONT_BLOCK );
2717:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						}
2718:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						#endif /* ipconfigSUPPORT_SIGNALS */
2719:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						break;
2720:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
2721:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2722:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( ( ( uint32_t ) xFlags & ( uint32_t ) FREERTOS_MSG_DONTWAIT ) != 0U )
 3200              	 .loc 1 2722 0
 3201 0050 09F01009 	 and r9,r9,#16
2723:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
2724:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						break;
2725:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
2726:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2727:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Don't get here a second time. */
2728:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					xTimed = pdTRUE;
 3202              	 .loc 1 2728 0
 3203 0054 4FF00108 	 mov r8,#1
 3204              	.LVL383:
 3205              	.L325:
2670:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 3206              	 .loc 1 2670 0
 3207 0058 94F85330 	 ldrb r3,[r4,#83]
 3208 005c 13B1     	 cbz r3,.L308
 3209 005e 083B     	 subs r3,r3,#8
 3210 0060 012B     	 cmp r3,#1
 3211 0062 0ED8     	 bhi .L307
 3212              	.L308:
2675:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 3213              	 .loc 1 2675 0
 3214 0064 94F84230 	 ldrb r3,[r4,#66]
 3215 0068 03F00803 	 and r3,r3,#8
 3216 006c DBB2     	 uxtb r3,r3
2683:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
 3217              	 .loc 1 2683 0
 3218 006e 002B     	 cmp r3,#0
 3219 0070 14BF     	 ite ne
 3220 0072 6FF00B07 	 mvnne r7,#11
 3221 0076 6FF07F07 	 mvneq r7,#127
 3222              	.LVL384:
2729:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2730:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Fetch the current time. */
2731:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					vTaskSetTimeOutState( &xTimeOut );
2732:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
2733:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2734:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* Has the timeout been reached? */
2735:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xRemainingTime ) != pdFALSE )
2736:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
2737:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					break;
2738:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
2739:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2740:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* Block until there is a down-stream event. */
2741:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xEventBits = xEventGroupWaitBits( pxSocket->xEventGroup,
2742:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					( EventBits_t ) eSOCKET_RECEIVE | ( EventBits_t ) eSOCKET_CLOSED | ( EventBits_t ) eSOCKET_INT
2743:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					pdTRUE /*xClearOnExit*/, pdFALSE /*xWaitAllBits*/, xRemainingTime );
2744:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				#if( ipconfigSUPPORT_SIGNALS != 0 )
2745:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
2746:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( ( xEventBits & ( EventBits_t ) eSOCKET_INTR ) != 0U )
2747:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
2748:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						break;
2749:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
2750:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
2751:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				#else
2752:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
2753:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					( void ) xEventBits;
2754:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
2755:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				#endif /* ipconfigSUPPORT_SIGNALS */
2756:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2757:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( pxSocket->u.xTCP.rxStream != NULL )
2758:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
2759:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					xByteCount = ( BaseType_t ) uxStreamBufferGetSize ( pxSocket->u.xTCP.rxStream );
2760:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
2761:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				else
2762:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
2763:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					xByteCount = 0;
2764:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
2765:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
2766:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2767:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		#if( ipconfigSUPPORT_SIGNALS != 0 )
2768:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( ( xEventBits & ( EventBits_t ) eSOCKET_INTR ) != 0U )
 3223              	 .loc 1 2768 0
 3224 007a 15F0400F 	 tst r5,#64
 3225 007e 35D1     	 bne .L313
 3226 0080 3FE0     	 b .L318
 3227              	.LVL385:
 3228              	.L307:
2705:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 3229              	 .loc 1 2705 0
 3230 0082 96B9     	 cbnz r6,.L310
2708:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 3231              	 .loc 1 2708 0
 3232 0084 E369     	 ldr r3,[r4,#28]
 3233 0086 0793     	 str r3,[sp,#28]
2710:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 3234              	 .loc 1 2710 0
 3235 0088 3BB9     	 cbnz r3,.L311
2715:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 								pdTRUE /*xClearOnExit*/, pdFALSE /*xWaitAllBits*/, socketDONT_BLOCK );
 3236              	 .loc 1 2715 0
 3237 008a 0093     	 str r3,[sp]
 3238 008c 6068     	 ldr r0,[r4,#4]
 3239 008e 4021     	 movs r1,#64
 3240 0090 0122     	 movs r2,#1
 3241 0092 FFF7FEFF 	 bl xEventGroupWaitBits
 3242              	.LVL386:
 3243 0096 0546     	 mov r5,r0
 3244              	.LVL387:
2719:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
 3245              	 .loc 1 2719 0
 3246 0098 84E0     	 b .L312
 3247              	.LVL388:
 3248              	.L311:
2722:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 3249              	 .loc 1 2722 0
 3250 009a B9F1000F 	 cmp r9,#0
 3251 009e 40F08180 	 bne .L312
 3252              	.LVL389:
2731:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 3253              	 .loc 1 2731 0
 3254 00a2 05A8     	 add r0,sp,#20
 3255 00a4 FFF7FEFF 	 bl vTaskSetTimeOutState
 3256              	.LVL390:
2728:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 3257              	 .loc 1 2728 0
 3258 00a8 4646     	 mov r6,r8
 3259              	.LVL391:
 3260              	.L310:
2735:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 3261              	 .loc 1 2735 0
 3262 00aa 05A8     	 add r0,sp,#20
 3263 00ac 07A9     	 add r1,sp,#28
 3264 00ae FFF7FEFF 	 bl xTaskCheckForTimeOut
 3265              	.LVL392:
 3266 00b2 0028     	 cmp r0,#0
 3267 00b4 76D1     	 bne .L312
2741:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					( EventBits_t ) eSOCKET_RECEIVE | ( EventBits_t ) eSOCKET_CLOSED | ( EventBits_t ) eSOCKET_INT
 3268              	 .loc 1 2741 0
 3269 00b6 079B     	 ldr r3,[sp,#28]
 3270 00b8 0093     	 str r3,[sp]
 3271 00ba 6068     	 ldr r0,[r4,#4]
 3272 00bc 6121     	 movs r1,#97
 3273 00be 4246     	 mov r2,r8
 3274 00c0 0023     	 movs r3,#0
 3275 00c2 FFF7FEFF 	 bl xEventGroupWaitBits
 3276              	.LVL393:
 3277 00c6 0546     	 mov r5,r0
 3278              	.LVL394:
2746:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 3279              	 .loc 1 2746 0
 3280 00c8 10F0400F 	 tst r0,#64
 3281 00cc 0ED1     	 bne .L313
2757:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 3282              	 .loc 1 2757 0
 3283 00ce 626F     	 ldr r2,[r4,#116]
 3284 00d0 002A     	 cmp r2,#0
 3285 00d2 C1D0     	 beq .L325
 3286              	.LVL395:
 3287              	.LBB255:
 3288              	.LBB256:
 125:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxTail = pxBuffer->uxTail;
 3289              	 .loc 3 125 0
 3290 00d4 9368     	 ldr r3,[r2,#8]
 3291              	.LVL396:
 3292              	 .loc 3 126 0
 3293 00d6 1168     	 ldr r1,[r2]
 3294              	.LVL397:
 3295              	.LBB257:
 3296              	.LBB258:
  84:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	if ( uxCount >= pxBuffer->LENGTH )
 3297              	 .loc 3 84 0
 3298 00d8 1269     	 ldr r2,[r2,#16]
 3299              	.LVL398:
 3300 00da 1344     	 add r3,r3,r2
 3301              	.LVL399:
 3302 00dc 5B1A     	 subs r3,r3,r1
 3303              	.LVL400:
  85:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	{
 3304              	 .loc 3 85 0
 3305 00de 9A42     	 cmp r2,r3
  87:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	}
 3306              	 .loc 3 87 0
 3307 00e0 98BF     	 it ls
 3308 00e2 9B1A     	 subls r3,r3,r2
 3309              	.LVL401:
 3310              	.LBE258:
 3311              	.LBE257:
 3312              	.LBE256:
 3313              	.LBE255:
2759:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 3314              	 .loc 1 2759 0
 3315 00e4 1F46     	 mov r7,r3
 3316              	.LVL402:
2668:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 3317              	 .loc 1 2668 0
 3318 00e6 002B     	 cmp r3,#0
 3319 00e8 B6D0     	 beq .L325
 3320 00ea 0AE0     	 b .L318
 3321              	.LVL403:
 3322              	.L313:
2769:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
2770:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( ( xEventBits & ( ( EventBits_t ) eSOCKET_RECEIVE | ( EventBits_t ) eSOCKET_CLOSED ) ) != 0U
 3323              	 .loc 1 2770 0
 3324 00ec 15F0210F 	 tst r5,#33
 3325 00f0 55D0     	 beq .L323
 3326              	.LVL404:
2771:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
2772:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Shouldn't have cleared other flags. */
2773:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					xEventBits &= ~( ( EventBits_t ) eSOCKET_INTR );
2774:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					( void ) xEventGroupSetBits( pxSocket->xEventGroup, xEventBits );
 3327              	 .loc 1 2774 0
 3328 00f2 6068     	 ldr r0,[r4,#4]
 3329 00f4 25F04001 	 bic r1,r5,#64
 3330              	.LVL405:
 3331 00f8 FFF7FEFF 	 bl xEventGroupSetBits
 3332              	.LVL406:
2775:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
2776:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xByteCount = -pdFREERTOS_ERRNO_EINTR;
 3333              	 .loc 1 2776 0
 3334 00fc 6FF00307 	 mvn r7,#3
 3335 0100 54E0     	 b .L324
 3336              	.LVL407:
 3337              	.L318:
2777:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
2778:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			else
2779:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		#endif /* ipconfigSUPPORT_SIGNALS */
2780:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( xByteCount > 0 )
 3338              	 .loc 1 2780 0
 3339 0102 002F     	 cmp r7,#0
 3340 0104 52DD     	 ble .L324
2781:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
2782:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( ( ( uint32_t ) xFlags & ( uint32_t ) FREERTOS_ZERO_COPY ) == 0U )
 3341              	 .loc 1 2782 0
 3342 0106 BBF1000F 	 cmp fp,#0
 3343 010a 2ED1     	 bne .L315
 3344              	.LVL408:
 3345              	.LBB259:
2783:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
2784:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				BaseType_t xIsPeek = ( ( ( uint32_t ) xFlags & ( uint32_t ) FREERTOS_MSG_PEEK ) != 0U ) ? 1L : 
 3346              	 .loc 1 2784 0
 3347 010c CAF38003 	 ubfx r3,r10,#2,#1
2785:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2786:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					xByteCount = ( BaseType_t )
2787:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						uxStreamBufferGet( pxSocket->u.xTCP.rxStream,
 3348              	 .loc 1 2787 0
 3349 0110 0093     	 str r3,[sp]
 3350 0112 606F     	 ldr r0,[r4,#116]
 3351 0114 0021     	 movs r1,#0
 3352 0116 029A     	 ldr r2,[sp,#8]
 3353 0118 039B     	 ldr r3,[sp,#12]
 3354 011a FFF7FEFF 	 bl uxStreamBufferGet
 3355              	.LVL409:
 3356 011e 0746     	 mov r7,r0
 3357              	.LVL410:
2788:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 										   0UL,
2789:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 										   ipPOINTER_CAST( uint8_t *, pvBuffer ),
2790:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 										   ( size_t ) uxBufferLength,
2791:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 										   xIsPeek );
2792:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( pxSocket->u.xTCP.bits.bLowWater != pdFALSE_UNSIGNED )
 3358              	 .loc 1 2792 0
 3359 0120 94F84030 	 ldrb r3,[r4,#64]
 3360 0124 13F0800F 	 tst r3,#128
 3361 0128 40D0     	 beq .L324
 3362              	.LBB260:
2793:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
2794:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						/* We had reached the low-water mark, now see if the flag
2795:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						can be cleared */
2796:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						size_t uxFrontSpace = uxStreamBufferFrontSpace( pxSocket->u.xTCP.rxStream );
 3363              	 .loc 1 2796 0
 3364 012a 626F     	 ldr r2,[r4,#116]
 3365              	.LVL411:
 3366              	.LBB261:
 3367              	.LBB262:
 113:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxTail = pxBuffer->uxTail;
 3368              	 .loc 3 113 0
 3369 012c D168     	 ldr r1,[r2,#12]
 3370              	.LVL412:
 114:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
 3371              	 .loc 3 114 0
 3372 012e 1368     	 ldr r3,[r2]
 3373              	.LVL413:
 3374              	.LBB263:
 3375              	.LBB264:
  68:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	if( uxCount >= pxBuffer->LENGTH )
 3376              	 .loc 3 68 0
 3377 0130 1269     	 ldr r2,[r2,#16]
 3378              	.LVL414:
 3379 0132 1344     	 add r3,r3,r2
 3380              	.LVL415:
 3381 0134 013B     	 subs r3,r3,#1
 3382 0136 5B1A     	 subs r3,r3,r1
 3383              	.LVL416:
  69:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	{
 3384              	 .loc 3 69 0
 3385 0138 9A42     	 cmp r2,r3
  71:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	}
 3386              	 .loc 3 71 0
 3387 013a 98BF     	 it ls
 3388 013c 9B1A     	 subls r3,r3,r2
 3389              	.LVL417:
 3390              	.LBE264:
 3391              	.LBE263:
 3392              	.LBE262:
 3393              	.LBE261:
2797:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2798:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						if( uxFrontSpace >= pxSocket->u.xTCP.uxEnoughSpace )
 3394              	 .loc 1 2798 0
 3395 013e A26E     	 ldr r2,[r4,#104]
 3396 0140 9A42     	 cmp r2,r3
 3397 0142 33D8     	 bhi .L324
2799:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						{
2800:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							pxSocket->u.xTCP.bits.bLowWater = pdFALSE;
 3398              	 .loc 1 2800 0
 3399 0144 94F84030 	 ldrb r3,[r4,#64]
 3400              	.LVL418:
 3401 0148 6FF3C713 	 bfc r3,#7,#1
 3402 014c 84F84030 	 strb r3,[r4,#64]
2801:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							pxSocket->u.xTCP.bits.bWinChange = pdTRUE;
 3403              	 .loc 1 2801 0
 3404 0150 94F84130 	 ldrb r3,[r4,#65]
 3405 0154 43F00103 	 orr r3,r3,#1
 3406 0158 84F84130 	 strb r3,[r4,#65]
 3407              	.LVL419:
2802:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							pxSocket->u.xTCP.usTimeout = 1U; /* because bLowWater is cleared. */
 3408              	 .loc 1 2802 0
 3409 015c 0123     	 movs r3,#1
 3410 015e A4F84830 	 strh r3,[r4,#72]
2803:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							( void ) xSendEventToIPTask( eTCPTimerEvent );
 3411              	 .loc 1 2803 0
 3412 0162 0620     	 movs r0,#6
 3413              	.LVL420:
 3414 0164 FFF7FEFF 	 bl xSendEventToIPTask
 3415              	.LVL421:
 3416 0168 20E0     	 b .L324
 3417              	.LVL422:
 3418              	.L315:
 3419              	.LBE260:
 3420              	.LBE259:
2804:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						}
2805:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
2806:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
2807:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				else
2808:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
2809:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Zero-copy reception of data: pvBuffer is a pointer to a pointer. */
2810:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					xByteCount = ( BaseType_t ) uxStreamBufferGetPtr( pxSocket->u.xTCP.rxStream, ipPOINTER_CAST( u
 3421              	 .loc 1 2810 0
 3422 016a 626F     	 ldr r2,[r4,#116]
 3423              	.LVL423:
 3424              	.LBB265:
 3425              	.LBB266:
 127:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
 128:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	return uxStreamBufferDistance( pxBuffer, uxTail, uxHead );
 129:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** }
 130:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** /*-----------------------------------------------------------*/
 131:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
 132:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** static portINLINE size_t uxStreamBufferMidSpace( const StreamBuffer_t *pxBuffer );
 133:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** static portINLINE size_t uxStreamBufferMidSpace( const StreamBuffer_t *pxBuffer )
 134:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** {
 135:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** /* Returns the distance between uxHead and uxMid */
 136:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxHead = pxBuffer->uxHead;
 137:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxMid = pxBuffer->uxMid;
 138:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
 139:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	return uxStreamBufferDistance( pxBuffer, uxMid, uxHead );
 140:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** }
 141:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** /*-----------------------------------------------------------*/
 142:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
 143:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** static portINLINE void vStreamBufferMoveMid( StreamBuffer_t *pxBuffer, size_t uxCount );
 144:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** static portINLINE void vStreamBufferMoveMid( StreamBuffer_t *pxBuffer, size_t uxCount )
 145:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** {
 146:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** /* Increment uxMid, but no further than uxHead */
 147:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxSize = uxStreamBufferMidSpace( pxBuffer );
 148:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxMoveCount = uxCount;
 149:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
 150:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	if( uxMoveCount > uxSize )
 151:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	{
 152:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 		uxMoveCount = uxSize;
 153:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	}
 154:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	pxBuffer->uxMid += uxMoveCount;
 155:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	if( pxBuffer->uxMid >= pxBuffer->LENGTH )
 156:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	{
 157:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 		pxBuffer->uxMid -= pxBuffer->LENGTH;
 158:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	}
 159:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** }
 160:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** /*-----------------------------------------------------------*/
 161:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
 162:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** static portINLINE BaseType_t xStreamBufferLessThenEqual( const StreamBuffer_t *pxBuffer, const size
 163:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** static portINLINE BaseType_t xStreamBufferLessThenEqual( const StreamBuffer_t *pxBuffer, const size
 164:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** {
 165:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** BaseType_t xReturn;
 166:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxTail = pxBuffer->uxTail;
 167:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
 168:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	/* Returns true if ( uxLeft < uxRight ) */
 169:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	if( ( ( ( uxLeft < uxTail ) ? 1U : 0U ) ^ ( ( uxRight < uxTail ) ? 1U : 0U )  ) != 0U )
 170:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	{
 171:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 		if( uxRight < uxTail )
 172:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 		{
 173:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 			xReturn = pdTRUE;
 174:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 		}
 175:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 		else
 176:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 		{
 177:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 			xReturn = pdFALSE;
 178:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 		}
 179:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	}
 180:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	else
 181:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	{
 182:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 		if( uxLeft <= uxRight )
 183:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 		{
 184:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 			xReturn = pdTRUE;
 185:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 		}
 186:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 		else
 187:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 		{
 188:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 			xReturn = pdFALSE;
 189:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 		}
 190:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	}
 191:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	return xReturn;
 192:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** }
 193:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** /*-----------------------------------------------------------*/
 194:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
 195:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** static portINLINE size_t uxStreamBufferGetPtr( StreamBuffer_t *pxBuffer, uint8_t **ppucData );
 196:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** static portINLINE size_t uxStreamBufferGetPtr( StreamBuffer_t *pxBuffer, uint8_t **ppucData )
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** {
 198:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxNextTail = pxBuffer->uxTail;
 3426              	 .loc 3 198 0
 3427 016c 1768     	 ldr r7,[r2]
 3428              	.LVL424:
 3429              	.LBB267:
 3430              	.LBB268:
 125:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxTail = pxBuffer->uxTail;
 3431              	 .loc 3 125 0
 3432 016e 9368     	 ldr r3,[r2,#8]
 3433              	.LVL425:
 126:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
 3434              	 .loc 3 126 0
 3435 0170 1068     	 ldr r0,[r2]
 3436              	.LVL426:
 3437              	.LBB269:
 3438              	.LBB270:
  84:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	if ( uxCount >= pxBuffer->LENGTH )
 3439              	 .loc 3 84 0
 3440 0172 1169     	 ldr r1,[r2,#16]
 3441 0174 0B44     	 add r3,r3,r1
 3442              	.LVL427:
 3443 0176 1B1A     	 subs r3,r3,r0
 3444              	.LVL428:
  85:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	{
 3445              	 .loc 3 85 0
 3446 0178 9942     	 cmp r1,r3
  87:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	}
 3447              	 .loc 3 87 0
 3448 017a 98BF     	 it ls
 3449 017c 5B1A     	 subls r3,r3,r1
 3450              	.LVL429:
 3451              	.LBE270:
 3452              	.LBE269:
 3453              	.LBE268:
 3454              	.LBE267:
 199:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxSize = uxStreamBufferGetSize( pxBuffer );
 200:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
 201:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	*ppucData = pxBuffer->ucArray + uxNextTail;
 3455              	 .loc 3 201 0
 3456 017e D119     	 adds r1,r2,r7
 3457 0180 1431     	 adds r1,r1,#20
 3458 0182 0298     	 ldr r0,[sp,#8]
 3459              	.LVL430:
 3460 0184 0160     	 str r1,[r0]
 3461              	.LVL431:
 202:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
 203:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	return FreeRTOS_min_uint32( uxSize, pxBuffer->LENGTH - uxNextTail );
 3462              	 .loc 3 203 0
 3463 0186 1269     	 ldr r2,[r2,#16]
 3464              	.LVL432:
 3465 0188 D71B     	 subs r7,r2,r7
 3466              	.LVL433:
 3467              	.LBB271:
 3468              	.LBB272:
 3469              	 .file 4 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include/FreeRTOS_IP.h"
   1:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /*
   2:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * FreeRTOS+TCP V2.2.2
   3:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  *
   5:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * this software and associated documentation files (the "Software"), to deal in
   7:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * the Software without restriction, including without limitation the rights to
   8:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * subject to the following conditions:
  11:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  *
  12:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * The above copyright notice and this permission notice shall be included in all
  13:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * copies or substantial portions of the Software.
  14:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  *
  15:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  *
  22:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * http://aws.amazon.com/freertos
  23:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * http://www.FreeRTOS.org
  24:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  */
  25:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  26:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #ifndef FREERTOS_IP_H
  27:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define FREERTOS_IP_H
  28:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  29:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #ifdef __cplusplus
  30:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** extern "C" {
  31:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #endif
  32:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  33:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #include "FreeRTOS.h"
  34:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #include "task.h"
  35:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  36:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /* Application level configuration options. */
  37:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #include "FreeRTOSIPConfig.h"
  38:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #include "FreeRTOSIPConfigDefaults.h"
  39:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #include "IPTraceMacroDefaults.h"
  40:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  41:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #ifdef __COVERITY__
  42:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	/* Coverity static checks don't like inlined functions.
  43:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	As it is up to the users to allow inlining, don't let
  44:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	let Coverity know about it. */
  45:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  46:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	#ifdef portINLINE
  47:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 		/* The usage of #undef violates the rule. */
  48:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 		#undef portINLINE
  49:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  50:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	#endif
  51:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  52:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	#define	portINLINE
  53:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #endif
  54:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  55:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /* Some constants defining the sizes of several parts of a packet.
  56:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** These defines come before inlucding the configuration header files. */
  57:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /* The size of the Ethernet header is 14, meaning that 802.1Q VLAN tags
  58:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** are not ( yet ) supported. */
  59:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipSIZE_OF_ETH_HEADER			14U
  60:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipSIZE_OF_IPv4_HEADER			20U
  61:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipSIZE_OF_IGMP_HEADER			8U
  62:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipSIZE_OF_ICMP_HEADER			8U
  63:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipSIZE_OF_UDP_HEADER			8U
  64:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipSIZE_OF_TCP_HEADER			20U
  65:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  66:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipSIZE_OF_IPv4_ADDRESS			4U
  67:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  68:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /*
  69:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * Generate a randomized TCP Initial Sequence Number per RFC.
  70:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * This function must be provided by the application builder.
  71:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  */
  72:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /* This function is defined generally by the application. */
  73:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** extern uint32_t ulApplicationGetNextSequenceNumber( uint32_t ulSourceAddress,
  74:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 													uint16_t usSourcePort,
  75:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 													uint32_t ulDestinationAddress,
  76:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 													uint16_t usDestinationPort );
  77:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  78:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /* The number of octets in the MAC and IP addresses respectively. */
  79:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipMAC_ADDRESS_LENGTH_BYTES ( 6 )
  80:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipIP_ADDRESS_LENGTH_BYTES ( 4 )
  81:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  82:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /* IP protocol definitions. */
  83:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipPROTOCOL_ICMP			( 1U )
  84:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipPROTOCOL_IGMP         ( 2U )
  85:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipPROTOCOL_TCP			( 6U )
  86:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipPROTOCOL_UDP			( 17U )
  87:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipPROTOCOL_RAW			( 255 )
  88:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  89:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /* The character used to fill ICMP echo requests, and therefore also the
  90:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** character expected to fill ICMP echo replies. */
  91:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipECHO_DATA_FILL_BYTE						'x'
  92:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  93:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /* Dimensions the buffers that are filled by received Ethernet frames. */
  94:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipSIZE_OF_ETH_CRC_BYTES					( 4UL )
  95:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipSIZE_OF_ETH_OPTIONAL_802_1Q_TAG_BYTES	( 4UL )
  96:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipTOTAL_ETHERNET_FRAME_SIZE				( ( ( uint32_t ) ipconfigNETWORK_MTU ) + ( ( uint32_t ) ipSI
  97:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  98:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  99:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /* Space left at the beginning of a network buffer storage area to store a
 100:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** pointer back to the network buffer.  Should be a multiple of 8 to ensure 8 byte
 101:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** alignment is maintained on architectures that require it.
 102:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 103:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** In order to get a 32-bit alignment of network packets, an offset of 2 bytes
 104:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** would be desirable, as defined by ipconfigPACKET_FILLER_SIZE.  So the malloc'd
 105:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** buffer will have the following contents:
 106:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	uint32_t pointer;	// word-aligned
 107:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	uchar_8 filler[6];
 108:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	<< ETH-header >>	// half-word-aligned
 109:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	uchar_8 dest[6];    // start of pucEthernetBuffer
 110:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	uchar_8 dest[6];
 111:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	uchar16_t type;
 112:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	<< IP-header >>		// word-aligned
 113:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	uint8_t ucVersionHeaderLength;
 114:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	etc
 115:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  */
 116:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 117:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #if( ipconfigBUFFER_PADDING != 0 )
 118:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****     #define ipBUFFER_PADDING    ipconfigBUFFER_PADDING
 119:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #else
 120:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****     #define ipBUFFER_PADDING    ( 8U + ipconfigPACKET_FILLER_SIZE )
 121:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #endif
 122:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 123:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /* The structure used to store buffers and pass them around the network stack.
 124:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** Buffers can be in use by the stack, in use by the network interface hardware
 125:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** driver, or free (not in use). */
 126:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** typedef struct xNETWORK_BUFFER
 127:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** {
 128:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	ListItem_t xBufferListItem; 	/* Used to reference the buffer form the free buffer list or a socket
 129:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	uint32_t ulIPAddress;			/* Source or destination IP address, depending on usage scenario. */
 130:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	uint8_t *pucEthernetBuffer; 	/* Pointer to the start of the Ethernet frame. */
 131:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	size_t xDataLength; 			/* Starts by holding the total Ethernet frame length, then the UDP/TCP payl
 132:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	uint16_t usPort;				/* Source or destination port, depending on usage scenario. */
 133:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	uint16_t usBoundPort;			/* The port to which a transmitting socket is bound. */
 134:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	#if( ipconfigUSE_LINKED_RX_MESSAGES != 0 )
 135:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 		struct xNETWORK_BUFFER *pxNextBuffer; /* Possible optimisation for expert users - requires networ
 136:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	#endif
 137:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** } NetworkBufferDescriptor_t;
 138:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 139:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #include "pack_struct_start.h"
 140:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** struct xMAC_ADDRESS
 141:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** {
 142:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	uint8_t ucBytes[ ipMAC_ADDRESS_LENGTH_BYTES ];
 143:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** }
 144:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #include "pack_struct_end.h"
 145:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 146:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** typedef struct xMAC_ADDRESS MACAddress_t;
 147:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 148:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** typedef enum eNETWORK_EVENTS
 149:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** {
 150:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	eNetworkUp,		/* The network is configured. */
 151:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	eNetworkDown	/* The network connection has been lost. */
 152:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** } eIPCallbackEvent_t;
 153:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 154:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /* MISRA check: some modules refer to this typedef even though
 155:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** ipconfigSUPPORT_OUTGOING_PINGS is not enabled. */
 156:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** typedef enum ePING_REPLY_STATUS
 157:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** {
 158:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	eSuccess = 0,		/* A correct reply has been received for an outgoing ping. */
 159:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	eInvalidChecksum,	/* A reply was received for an outgoing ping but the checksum of the reply was i
 160:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	eInvalidData		/* A reply was received to an outgoing ping but the payload of the reply was not cor
 161:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** } ePingReplyStatus_t;
 162:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 163:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** typedef struct xIP_TIMER
 164:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** {
 165:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	uint32_t
 166:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 		bActive : 1,	/* This timer is running and must be processed. */
 167:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 		bExpired : 1;	/* Timer has expired and a task must be processed. */
 168:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	TimeOut_t xTimeOut;
 169:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	TickType_t ulRemainingTime;
 170:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	TickType_t ulReloadTime;
 171:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** } IPTimer_t;
 172:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 173:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /* Endian related definitions. */
 174:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #if( ipconfigBYTE_ORDER == pdFREERTOS_LITTLE_ENDIAN )
 175:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 176:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	/* FreeRTOS_htons / FreeRTOS_htonl: some platforms might have built-in versions
 177:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	using a single instruction so allow these versions to be overridden. */
 178:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	#ifndef FreeRTOS_htons
 179:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 		#define FreeRTOS_htons( usIn ) ( (uint16_t) ( ( ( usIn ) << 8U ) | ( ( usIn ) >> 8U ) ) )
 180:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	#endif
 181:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 182:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	#ifndef	FreeRTOS_htonl
 183:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 		#define FreeRTOS_htonl( ulIn ) 											\
 184:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 			(																	\
 185:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 				( uint32_t ) 													\
 186:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 				( 																\
 187:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 					( ( ( ( uint32_t ) ( ulIn ) )                ) << 24  ) | 	\
 188:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 					( ( ( ( uint32_t ) ( ulIn ) ) & 0x0000ff00UL ) <<  8  ) | 	\
 189:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 					( ( ( ( uint32_t ) ( ulIn ) ) & 0x00ff0000UL ) >>  8  ) | 	\
 190:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 					( ( ( ( uint32_t ) ( ulIn ) )                ) >> 24  )  	\
 191:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 				) 																\
 192:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 			)
 193:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	#endif
 194:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 195:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #else /* ipconfigBYTE_ORDER */
 196:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	#define FreeRTOS_htons( x ) ( ( uint16_t ) ( x ) )
 198:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	#define FreeRTOS_htonl( x ) ( ( uint32_t ) ( x ) )
 199:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 200:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #endif /* ipconfigBYTE_ORDER == pdFREERTOS_LITTLE_ENDIAN */
 201:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 202:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define FreeRTOS_ntohs( x ) FreeRTOS_htons( x )
 203:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define FreeRTOS_ntohl( x ) FreeRTOS_htonl( x )
 204:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 205:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #if( ipconfigHAS_INLINE_FUNCTIONS == 1 )
 206:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 207:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	static portINLINE int32_t  FreeRTOS_max_int32  (int32_t  a, int32_t  b);
 208:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	static portINLINE uint32_t FreeRTOS_max_uint32 (uint32_t a, uint32_t b);
 209:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	static portINLINE int32_t  FreeRTOS_min_int32  (int32_t  a, int32_t  b);
 210:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	static portINLINE uint32_t FreeRTOS_min_uint32 (uint32_t a, uint32_t b);
 211:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	static portINLINE uint32_t FreeRTOS_round_up   (uint32_t a, uint32_t d);
 212:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	static portINLINE uint32_t FreeRTOS_round_down (uint32_t a, uint32_t d);
 213:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	static portINLINE BaseType_t  FreeRTOS_min_BaseType  (BaseType_t  a, BaseType_t  b);
 214:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 215:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	static portINLINE int32_t  FreeRTOS_max_int32  (int32_t  a, int32_t  b) { return ( a >= b ) ? a : 
 216:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	static portINLINE uint32_t FreeRTOS_max_uint32 (uint32_t a, uint32_t b) { return ( a >= b ) ? a : 
 217:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	static portINLINE int32_t  FreeRTOS_min_int32  (int32_t  a, int32_t  b) { return ( a <= b ) ? a : 
 218:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	static portINLINE uint32_t FreeRTOS_min_uint32 (uint32_t a, uint32_t b) { return ( a <= b ) ? a : 
 3470              	 .loc 4 218 0
 3471 018a 9F42     	 cmp r7,r3
 3472 018c 28BF     	 it cs
 3473 018e 1F46     	 movcs r7,r3
 3474              	.LVL434:
 3475 0190 0CE0     	 b .L324
 3476              	.LVL435:
 3477              	.L319:
 3478              	.LBE272:
 3479              	.LBE271:
 3480              	.LBE266:
 3481              	.LBE265:
2649:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 3482              	 .loc 1 2649 0
 3483 0192 6FF01507 	 mvn r7,#21
 3484 0196 09E0     	 b .L324
 3485              	.LVL436:
 3486              	.L320:
2655:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 3487              	 .loc 1 2655 0
 3488 0198 6FF01507 	 mvn r7,#21
 3489 019c 06E0     	 b .L324
 3490              	.LVL437:
 3491              	.L323:
2776:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 3492              	 .loc 1 2776 0
 3493 019e 6FF00307 	 mvn r7,#3
 3494 01a2 03E0     	 b .L324
 3495              	.LVL438:
 3496              	.L312:
2768:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 3497              	 .loc 1 2768 0
 3498 01a4 15F0400F 	 tst r5,#64
 3499 01a8 A0D1     	 bne .L313
 3500 01aa 0027     	 movs r7,#0
 3501              	.LVL439:
 3502              	.L324:
2811:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
2812:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
2813:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			else
2814:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
2815:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* Nothing. */
2816:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
2817:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		} /* prvValidSocket() */
2818:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2819:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		return xByteCount;
2820:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 3503              	 .loc 1 2820 0
 3504 01ac 3846     	 mov r0,r7
 3505 01ae 09B0     	 add sp,sp,#36
 3506              	.LCFI51:
 3507              	 .cfi_def_cfa_offset 36
 3508              	 
 3509 01b0 BDE8F08F 	 pop {r4,r5,r6,r7,r8,r9,r10,fp,pc}
 3510              	 .cfi_endproc
 3511              	.LFE87:
 3513              	 .section .text.FreeRTOS_get_tx_head,"ax",%progbits
 3514              	 .align 2
 3515              	 .global FreeRTOS_get_tx_head
 3516              	 .thumb
 3517              	 .thumb_func
 3519              	FreeRTOS_get_tx_head:
 3520              	.LFB89:
2821:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2822:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigUSE_TCP */
2823:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
2824:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2825:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigUSE_TCP == 1 )
2826:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2827:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	static int32_t prvTCPSendCheck( FreeRTOS_Socket_t *pxSocket, size_t uxDataLength )
2828:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
2829:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	int32_t xResult = 1;
2830:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2831:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* Is this a socket of type TCP and is it already bound to a port number ? */
2832:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_TCP, pdTRUE ) == pdFALSE )
2833:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
2834:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xResult = -pdFREERTOS_ERRNO_EINVAL;
2835:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
2836:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else if( pxSocket->u.xTCP.bits.bMallocError != pdFALSE_UNSIGNED )
2837:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
2838:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xResult = -pdFREERTOS_ERRNO_ENOMEM;
2839:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
2840:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else if( ( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eCLOSED ) ||
2841:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				 ( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eCLOSE_WAIT ) ||
2842:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				 ( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eCLOSING ) )
2843:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
2844:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xResult = -pdFREERTOS_ERRNO_ENOTCONN;
2845:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
2846:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else if( pxSocket->u.xTCP.bits.bFinSent != pdFALSE_UNSIGNED )
2847:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
2848:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* This TCP connection is closing already, the FIN flag has been sent.
2849:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			Maybe it is still delivering or receiving data.
2850:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			Return OK in order not to get closed/deleted too quickly */
2851:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xResult = 0;
2852:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
2853:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else if( uxDataLength == 0UL )
2854:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
2855:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* send() is being called to send zero bytes */
2856:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xResult = 0;
2857:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
2858:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else if( pxSocket->u.xTCP.txStream == NULL )
2859:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
2860:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Create the outgoing stream only when it is needed */
2861:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			( void ) prvTCPCreateStream( pxSocket, pdFALSE );
2862:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2863:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( pxSocket->u.xTCP.txStream == NULL )
2864:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
2865:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xResult = -pdFREERTOS_ERRNO_ENOMEM;
2866:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
2867:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
2868:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else
2869:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
2870:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Nothing. */
2871:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
2872:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2873:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		return xResult;
2874:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
2875:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2876:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigUSE_TCP */
2877:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
2878:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2879:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigUSE_TCP == 1 )
2880:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2881:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* Get a direct pointer to the circular transmit buffer.
2882:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	'*pxLength' will contain the number of bytes that may be written. */
2883:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	uint8_t *FreeRTOS_get_tx_head( ConstSocket_t xSocket, BaseType_t *pxLength )
2884:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 3521              	 .loc 1 2884 0
 3522              	 .cfi_startproc
 3523              	 
 3524              	 
 3525              	.LVL440:
 3526 0000 38B5     	 push {r3,r4,r5,lr}
 3527              	.LCFI52:
 3528              	 .cfi_def_cfa_offset 16
 3529              	 .cfi_offset 3,-16
 3530              	 .cfi_offset 4,-12
 3531              	 .cfi_offset 5,-8
 3532              	 .cfi_offset 14,-4
 3533 0002 0546     	 mov r5,r0
 3534 0004 0C46     	 mov r4,r1
 3535              	.LVL441:
2885:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****     uint8_t *pucReturn = NULL;
2886:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	const FreeRTOS_Socket_t *pxSocket = ( const FreeRTOS_Socket_t * ) xSocket;
2887:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	StreamBuffer_t *pxBuffer = NULL;
2888:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2889:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****         *pxLength = 0;
 3536              	 .loc 1 2889 0
 3537 0006 0022     	 movs r2,#0
 3538 0008 0A60     	 str r2,[r1]
2890:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2891:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****         /* Confirm that this is a TCP socket before dereferencing structure
2892:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****         member pointers. */
2893:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****         if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_TCP, pdFALSE ) == pdTRUE )
 3539              	 .loc 1 2893 0
 3540 000a 0621     	 movs r1,#6
 3541              	.LVL442:
 3542 000c FFF7FEFF 	 bl prvValidSocket
 3543              	.LVL443:
 3544 0010 0128     	 cmp r0,#1
 3545 0012 14D1     	 bne .L331
2894:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****         {
2895:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****             pxBuffer = pxSocket->u.xTCP.txStream;
 3546              	 .loc 1 2895 0
 3547 0014 A86F     	 ldr r0,[r5,#120]
 3548              	.LVL444:
2896:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( pxBuffer != NULL )
 3549              	 .loc 1 2896 0
 3550 0016 A0B1     	 cbz r0,.L332
 3551              	.LVL445:
 3552              	.LBB273:
 3553              	.LBB274:
 3554              	.LBB275:
  99:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxTail = pxBuffer->uxTail;
 3555              	 .loc 3 99 0
 3556 0018 8368     	 ldr r3,[r0,#8]
 3557              	.LVL446:
 100:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
 3558              	 .loc 3 100 0
 3559 001a 0268     	 ldr r2,[r0]
 3560              	.LVL447:
 3561              	.LBB276:
 3562              	.LBB277:
  68:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	if( uxCount >= pxBuffer->LENGTH )
 3563              	 .loc 3 68 0
 3564 001c 0169     	 ldr r1,[r0,#16]
 3565 001e 0A44     	 add r2,r2,r1
 3566              	.LVL448:
 3567 0020 013A     	 subs r2,r2,#1
 3568 0022 D31A     	 subs r3,r2,r3
 3569              	.LVL449:
  69:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	{
 3570              	 .loc 3 69 0
 3571 0024 9942     	 cmp r1,r3
  71:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	}
 3572              	 .loc 3 71 0
 3573 0026 98BF     	 it ls
 3574 0028 5B1A     	 subls r3,r3,r1
 3575              	.LVL450:
 3576              	.LBE277:
 3577              	.LBE276:
 3578              	.LBE275:
 3579              	.LBE274:
2897:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
2898:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			BaseType_t xSpace = ( BaseType_t ) uxStreamBufferGetSpace( pxBuffer );
2899:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			BaseType_t xRemain = ( BaseType_t ) pxBuffer->LENGTH - ( BaseType_t ) pxBuffer->uxHead;
 3580              	 .loc 1 2899 0
 3581 002a 8268     	 ldr r2,[r0,#8]
 3582              	.LVL451:
 3583 002c 891A     	 subs r1,r1,r2
 3584              	.LVL452:
 3585              	.LBB278:
 3586              	.LBB279:
 219:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	static portINLINE uint32_t FreeRTOS_round_up   (uint32_t a, uint32_t d) { return d * ( ( a + d - 1
 220:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	static portINLINE uint32_t FreeRTOS_round_down (uint32_t a, uint32_t d) { return d * ( a / d ); }
 221:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 222:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	static portINLINE BaseType_t  FreeRTOS_min_BaseType  (BaseType_t  a, BaseType_t  b) { return ( a <
 3587              	 .loc 4 222 0
 3588 002e 8B42     	 cmp r3,r1
 3589 0030 A8BF     	 it ge
 3590 0032 0B46     	 movge r3,r1
 3591              	.LVL453:
 3592              	.LBE279:
 3593              	.LBE278:
2900:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2901:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				*pxLength = FreeRTOS_min_BaseType( xSpace, xRemain );
 3594              	 .loc 1 2901 0
 3595 0034 2360     	 str r3,[r4]
2902:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pucReturn = &( pxBuffer->ucArray[ pxBuffer->uxHead ] );
 3596              	 .loc 1 2902 0
 3597 0036 8368     	 ldr r3,[r0,#8]
 3598 0038 1844     	 add r0,r0,r3
 3599              	.LVL454:
 3600 003a 1430     	 adds r0,r0,#20
 3601              	.LVL455:
 3602 003c 38BD     	 pop {r3,r4,r5,pc}
 3603              	.LVL456:
 3604              	.L331:
 3605              	.LBE273:
2885:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	const FreeRTOS_Socket_t *pxSocket = ( const FreeRTOS_Socket_t * ) xSocket;
 3606              	 .loc 1 2885 0
 3607 003e 0020     	 movs r0,#0
 3608 0040 38BD     	 pop {r3,r4,r5,pc}
 3609              	.LVL457:
 3610              	.L332:
 3611 0042 0020     	 movs r0,#0
 3612              	.LVL458:
2903:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
2904:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
2905:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2906:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		return pucReturn;
2907:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 3613              	 .loc 1 2907 0
 3614 0044 38BD     	 pop {r3,r4,r5,pc}
 3615              	 .cfi_endproc
 3616              	.LFE89:
 3618 0046 00BF     	 .section .text.FreeRTOS_send,"ax",%progbits
 3619              	 .align 2
 3620              	 .global FreeRTOS_send
 3621              	 .thumb
 3622              	 .thumb_func
 3624              	FreeRTOS_send:
 3625              	.LFB90:
2908:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigUSE_TCP */
2909:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
2910:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2911:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigUSE_TCP == 1 )
2912:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/*
2913:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 * Send data using a TCP socket.  It is not necessary to have the socket
2914:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 * connected already.  Outgoing data will be stored and delivered as soon as
2915:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 * the socket gets connected.
2916:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 */
2917:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t FreeRTOS_send( Socket_t xSocket, const void *pvBuffer, size_t uxDataLength, BaseType_t 
2918:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 3626              	 .loc 1 2918 0
 3627              	 .cfi_startproc
 3628              	 
 3629              	 
 3630              	.LVL459:
 3631 0000 2DE9F04F 	 push {r4,r5,r6,r7,r8,r9,r10,fp,lr}
 3632              	.LCFI53:
 3633              	 .cfi_def_cfa_offset 36
 3634              	 .cfi_offset 4,-36
 3635              	 .cfi_offset 5,-32
 3636              	 .cfi_offset 6,-28
 3637              	 .cfi_offset 7,-24
 3638              	 .cfi_offset 8,-20
 3639              	 .cfi_offset 9,-16
 3640              	 .cfi_offset 10,-12
 3641              	 .cfi_offset 11,-8
 3642              	 .cfi_offset 14,-4
 3643 0004 89B0     	 sub sp,sp,#36
 3644              	.LCFI54:
 3645              	 .cfi_def_cfa_offset 72
 3646 0006 1546     	 mov r5,r2
 3647 0008 0392     	 str r2,[sp,#12]
 3648              	.LVL460:
2919:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t xByteCount = -pdFREERTOS_ERRNO_EINVAL;
2920:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t xBytesLeft;
2921:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
2922:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	TickType_t xRemainingTime;
2923:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t xTimed = pdFALSE;
2924:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	TimeOut_t xTimeOut;
2925:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t xCloseAfterSend;
2926:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	const uint8_t *pucSource = ipPOINTER_CAST( const uint8_t *, pvBuffer );
2927:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2928:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* Prevent compiler warnings about unused parameters.  The parameter
2929:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		may be used in future versions. */
2930:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		( void ) xFlags;
2931:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		
2932:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( pvBuffer != NULL )
 3649              	 .loc 1 2932 0
 3650 000a 0029     	 cmp r1,#0
 3651 000c 00F0A580 	 beq .L352
 3652 0010 0446     	 mov r4,r0
 3653              	.LVL461:
 3654 0012 9B46     	 mov fp,r3
 3655 0014 0F46     	 mov r7,r1
 3656              	.LVL462:
 3657              	.LBB292:
 3658              	.LBB293:
2832:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 3659              	 .loc 1 2832 0
 3660 0016 0621     	 movs r1,#6
 3661              	.LVL463:
 3662 0018 0122     	 movs r2,#1
 3663              	.LVL464:
 3664 001a FFF7FEFF 	 bl prvValidSocket
 3665              	.LVL465:
 3666 001e 0028     	 cmp r0,#0
 3667 0020 00F09E80 	 beq .L353
2836:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 3668              	 .loc 1 2836 0
 3669 0024 94F84230 	 ldrb r3,[r4,#66]
 3670 0028 13F0080F 	 tst r3,#8
 3671 002c 40F09B80 	 bne .L354
2840:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				 ( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eCLOSE_WAIT ) ||
 3672              	 .loc 1 2840 0
 3673 0030 94F85330 	 ldrb r3,[r4,#83]
 3674 0034 002B     	 cmp r3,#0
 3675 0036 00F09980 	 beq .L355
 3676 003a 083B     	 subs r3,r3,#8
 3677 003c DBB2     	 uxtb r3,r3
 3678 003e 012B     	 cmp r3,#1
 3679 0040 40F29780 	 bls .L356
2846:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 3680              	 .loc 1 2846 0
 3681 0044 94F84130 	 ldrb r3,[r4,#65]
 3682 0048 13F0400F 	 tst r3,#64
 3683 004c 40F09480 	 bne .L357
2853:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 3684              	 .loc 1 2853 0
 3685 0050 002D     	 cmp r5,#0
 3686 0052 00F09380 	 beq .L358
2858:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 3687              	 .loc 1 2858 0
 3688 0056 A36F     	 ldr r3,[r4,#120]
 3689 0058 E3B9     	 cbnz r3,.L350
 3690              	.LVL466:
 3691              	.LBB294:
 3692              	.LBB295:
2933:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
2934:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xByteCount = ( BaseType_t ) prvTCPSendCheck( pxSocket, uxDataLength );
2935:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
2936:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2937:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( xByteCount > 0 )
2938:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
2939:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* xBytesLeft is number of bytes to send, will count to zero. */
2940:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xBytesLeft = ( BaseType_t ) uxDataLength;
2941:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2942:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* xByteCount is number of bytes that can be sent now. */
2943:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xByteCount = ( BaseType_t ) uxStreamBufferGetSpace( pxSocket->u.xTCP.txStream );
2944:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2945:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* While there are still bytes to be sent. */
2946:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			while( xBytesLeft > 0 )
2947:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
2948:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* If txStream has space. */
2949:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( xByteCount > 0 )
2950:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
2951:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Don't send more than necessary. */
2952:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( xByteCount > xBytesLeft )
2953:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
2954:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						xByteCount = xBytesLeft;
2955:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
2956:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2957:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Is the close-after-send flag set and is this really the
2958:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					last transmission? */
2959:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( ( pxSocket->u.xTCP.bits.bCloseAfterSend != pdFALSE_UNSIGNED ) && ( xByteCount == xBytesLef
2960:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
2961:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						xCloseAfterSend = pdTRUE;
2962:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
2963:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					else
2964:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
2965:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						xCloseAfterSend = pdFALSE;
2966:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
2967:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2968:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* The flag 'bCloseAfterSend' can be set before sending data
2969:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					using setsockopt()
2970:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2971:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					When the last data packet is being sent out, a FIN flag will
2972:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					be included to let the peer know that no more data is to be
2973:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					expected.  The use of 'bCloseAfterSend' is not mandatory, it
2974:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					is just a faster way of transferring files (e.g. when using
2975:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					FTP). */
2976:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( xCloseAfterSend != pdFALSE )
2977:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
2978:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						/* Now suspend the scheduler: sending the last data	and
2979:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						setting bCloseRequested must be done together */
2980:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						vTaskSuspendAll();
2981:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						pxSocket->u.xTCP.bits.bCloseRequested = pdTRUE;
2982:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
2983:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2984:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					xByteCount = ( BaseType_t ) uxStreamBufferAdd( pxSocket->u.xTCP.txStream, 0UL, pucSource, ( si
2985:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2986:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( xCloseAfterSend != pdFALSE )
2987:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
2988:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						/* Now when the IP-task transmits the data, it will also
2989:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						see	that bCloseRequested is true and include the FIN
2990:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						flag to start closure of the connection. */
2991:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						( void ) xTaskResumeAll();
2992:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
2993:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2994:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Send a message to the IP-task so it can work on this
2995:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					socket.  Data is sent, let the IP-task work on it. */
2996:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					pxSocket->u.xTCP.usTimeout = 1U;
2997:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
2998:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( xIsCallingFromIPTask() == pdFALSE )
2999:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
3000:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						/* Only send a TCP timer event when not called from the
3001:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						IP-task. */
3002:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						( void ) xSendEventToIPTask( eTCPTimerEvent );
3003:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
3004:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3005:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					xBytesLeft -= xByteCount;
3006:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3007:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( xBytesLeft == 0 )
3008:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
3009:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						break;
3010:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
3011:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3012:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* As there are still bytes left to be sent, increase the
3013:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					data pointer. */
3014:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					pucSource = &( pucSource [ xByteCount ] );
3015:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
3016:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3017:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* Not all bytes have been sent. In case the socket is marked as
3018:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				blocking sleep for a while. */
3019:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( xTimed == pdFALSE )
3020:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
3021:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Only in the first round, check for non-blocking. */
3022:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					xRemainingTime = pxSocket->xSendBlockTime;
3023:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3024:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					#if( ipconfigUSE_CALLBACKS != 0 )
3025:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
3026:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						if( xIsCallingFromIPTask() != pdFALSE )
3027:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						{
3028:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							/* If this send function is called from within a
3029:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							call-back handler it may not block, otherwise
3030:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							chances would be big to get a deadlock: the IP-task
3031:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							waiting for	itself. */
3032:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							xRemainingTime = ( TickType_t ) 0;
3033:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						}
3034:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
3035:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					#endif /* ipconfigUSE_CALLBACKS */
3036:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3037:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( xRemainingTime == ( TickType_t ) 0 )
3038:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
3039:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						break;
3040:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
3041:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3042:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( ( ( uint32_t ) xFlags & ( uint32_t ) FREERTOS_MSG_DONTWAIT ) != 0U )
3043:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
3044:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						break;
3045:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
3046:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3047:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Don't get here a second time. */
3048:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					xTimed = pdTRUE;
3049:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3050:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Fetch the current time. */
3051:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					vTaskSetTimeOutState( &xTimeOut );
3052:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
3053:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				else
3054:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
3055:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Has the timeout been reached? */
3056:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( xTaskCheckForTimeOut( &xTimeOut, &xRemainingTime ) != pdFALSE )
3057:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
3058:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						break;
3059:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
3060:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
3061:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3062:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* Go sleeping until down-stream events are received. */
3063:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				( void ) xEventGroupWaitBits( pxSocket->xEventGroup, ( EventBits_t ) eSOCKET_SEND | ( EventBits
3064:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					pdTRUE /*xClearOnExit*/, pdFALSE /*xWaitAllBits*/, xRemainingTime );
3065:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3066:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xByteCount = ( BaseType_t ) uxStreamBufferGetSpace( pxSocket->u.xTCP.txStream );
3067:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
3068:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3069:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* How much was actually sent? */
3070:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xByteCount = ( ( BaseType_t ) uxDataLength ) - xBytesLeft;
3071:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3072:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( xByteCount == 0 )
3073:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
3074:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( pxSocket->u.xTCP.ucTCPState > ( uint8_t ) eESTABLISHED )
3075:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
3076:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					xByteCount = ( BaseType_t ) -pdFREERTOS_ERRNO_ENOTCONN;
3077:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
3078:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				else
3079:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
3080:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( ipconfigTCP_MAY_LOG_PORT( pxSocket->usLocalPort ) )
3081:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
3082:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						FreeRTOS_debug_printf( ( "FreeRTOS_send: %u -> %lxip:%d: no space\n",
3083:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							pxSocket->usLocalPort,
3084:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							pxSocket->u.xTCP.ulRemoteIP,
3085:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							pxSocket->u.xTCP.usRemotePort ) );
3086:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
3087:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3088:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					xByteCount = ( BaseType_t ) -pdFREERTOS_ERRNO_ENOSPC;
3089:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
3090:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
3091:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
3092:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3093:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		return xByteCount;
3094:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
3095:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3096:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigUSE_TCP */
3097:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
3098:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3099:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigUSE_TCP == 1 )
3100:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3101:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/*
3102:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 * Request to put a socket in listen mode
3103:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 */
3104:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t FreeRTOS_listen( Socket_t xSocket, BaseType_t xBacklog )
3105:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
3106:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	FreeRTOS_Socket_t *pxSocket;
3107:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t xResult = 0;
3108:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3109:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
3110:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3111:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* listen() is allowed for a valid TCP socket in Closed state and already
3112:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		bound. */
3113:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_TCP, pdTRUE ) == pdFALSE )
3114:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
3115:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xResult = -pdFREERTOS_ERRNO_EOPNOTSUPP;
3116:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
3117:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else if( ( pxSocket->u.xTCP.ucTCPState != ( uint8_t ) eCLOSED ) && ( pxSocket->u.xTCP.ucTCPState 
3118:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
3119:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Socket is in a wrong state. */
3120:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xResult = -pdFREERTOS_ERRNO_EOPNOTSUPP;
3121:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
3122:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else
3123:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
3124:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Backlog is interpreted here as "the maximum number of child
3125:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			sockets. */
3126:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pxSocket->u.xTCP.usBacklog = ( uint16_t )FreeRTOS_min_int32( ( int32_t ) 0xffff, ( int32_t ) xBa
3127:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3128:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* This cleaning is necessary only if a listening socket is being
3129:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			reused as it might have had a previous connection. */
3130:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( pxSocket->u.xTCP.bits.bReuseSocket != pdFALSE_UNSIGNED )
3131:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
3132:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( pxSocket->u.xTCP.rxStream != NULL )
3133:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
3134:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					vStreamBufferClear( pxSocket->u.xTCP.rxStream );
3135:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
3136:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3137:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( pxSocket->u.xTCP.txStream != NULL )
3138:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
3139:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					vStreamBufferClear( pxSocket->u.xTCP.txStream );
3140:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
3141:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3142:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				( void ) memset( pxSocket->u.xTCP.xPacket.u.ucLastPacket, 0, sizeof( pxSocket->u.xTCP.xPacket.u
3143:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				( void ) memset( &pxSocket->u.xTCP.xTCPWindow, 0, sizeof( pxSocket->u.xTCP.xTCPWindow ) );
3144:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				( void ) memset( &pxSocket->u.xTCP.bits, 0, sizeof( pxSocket->u.xTCP.bits ) );
3145:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3146:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* Now set the bReuseSocket flag again, because the bits have
3147:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				just been cleared. */
3148:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocket->u.xTCP.bits.bReuseSocket = pdTRUE;
3149:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
3150:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3151:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			vTCPStateChange( pxSocket, eTCP_LISTEN );
3152:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
3153:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3154:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		return xResult;
3155:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
3156:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3157:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigUSE_TCP */
3158:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
3159:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3160:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigUSE_TCP == 1 )
3161:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3162:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* shutdown - shut down part of a full-duplex connection */
3163:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t FreeRTOS_shutdown( Socket_t xSocket, BaseType_t xHow )
3164:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
3165:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
3166:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t xResult;
3167:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3168:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_TCP, pdTRUE ) == pdFALSE )
3169:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
3170:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/*_RB_ Is this comment correct?  The socket is not of a type that
3171:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			supports the listen() operation. */
3172:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xResult = -pdFREERTOS_ERRNO_EOPNOTSUPP;
3173:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
3174:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else if ( pxSocket->u.xTCP.ucTCPState != ( uint8_t ) eESTABLISHED )
3175:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
3176:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/*_RB_ Is this comment correct?  The socket is not of a type that
3177:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			supports the listen() operation. */
3178:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xResult = -pdFREERTOS_ERRNO_EOPNOTSUPP;
3179:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
3180:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else
3181:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
3182:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pxSocket->u.xTCP.bits.bUserShutdown = pdTRUE_UNSIGNED;
3183:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3184:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Let the IP-task perform the shutdown of the connection. */
3185:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pxSocket->u.xTCP.usTimeout = 1U;
3186:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			( void ) xSendEventToIPTask( eTCPTimerEvent );
3187:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xResult = 0;
3188:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
3189:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		(void) xHow;
3190:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3191:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		return xResult;
3192:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
3193:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3194:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigUSE_TCP */
3195:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
3196:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3197:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigUSE_TCP == 1 )
3198:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3199:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/*
3200:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 * A TCP timer has expired, now check all TCP sockets for:
3201:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 * - Active connect
3202:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 * - Send a delayed ACK
3203:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 * - Send new data
3204:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 * - Send a keep-alive packet
3205:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 * - Check for timeout (in non-connected states only)
3206:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 */
3207:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	TickType_t xTCPTimerCheck( BaseType_t xWillSleep )
3208:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
3209:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	FreeRTOS_Socket_t *pxSocket;
3210:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	TickType_t xShortest = pdMS_TO_TICKS( ( TickType_t ) ipTCP_TIMER_PERIOD_MS );
3211:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	TickType_t xNow = xTaskGetTickCount();
3212:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	static TickType_t xLastTime = 0U;
3213:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	TickType_t xDelta = xNow - xLastTime;
3214:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	const ListItem_t* pxEnd = listGET_END_MARKER( &xBoundTCPSocketsList );
3215:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	const ListItem_t *pxIterator = ( const ListItem_t * ) listGET_HEAD_ENTRY( &xBoundTCPSocketsList );
3216:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3217:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		xLastTime = xNow;
3218:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3219:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( xDelta == 0U )
3220:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
3221:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xDelta = 1U;
3222:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
3223:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3224:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		while( pxIterator != pxEnd )
3225:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
3226:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pxSocket = ipCAST_PTR_TO_TYPE_PTR( FreeRTOS_Socket_t, listGET_LIST_ITEM_OWNER( pxIterator ) );
3227:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pxIterator = ( ListItem_t * ) listGET_NEXT( pxIterator );
3228:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3229:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Sockets with 'tmout == 0' do not need any regular attention. */
3230:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( pxSocket->u.xTCP.usTimeout == 0U )
3231:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
3232:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				continue;
3233:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
3234:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3235:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( xDelta < ( TickType_t ) pxSocket->u.xTCP.usTimeout )
3236:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
3237:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocket->u.xTCP.usTimeout = ( uint16_t ) ( ( ( TickType_t ) pxSocket->u.xTCP.usTimeout ) - xDe
3238:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
3239:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			else
3240:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
3241:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			BaseType_t xRc;
3242:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3243:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocket->u.xTCP.usTimeout = 0U;
3244:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xRc = xTCPSocketCheck( pxSocket );
3245:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3246:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* Within this function, the socket might want to send a delayed
3247:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				ack or send out data or whatever it needs to do. */
3248:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( xRc < 0 )
3249:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
3250:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Continue because the socket was deleted. */
3251:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					continue;
3252:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
3253:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
3254:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3255:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* In xEventBits the driver may indicate that the socket has
3256:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			important events for the user.  These are only done just before the
3257:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			IP-task goes to sleep. */
3258:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( pxSocket->xEventBits != 0U )
3259:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
3260:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( xWillSleep != pdFALSE )
3261:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
3262:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* The IP-task is about to go to sleep, so messages can be
3263:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					sent to the socket owners. */
3264:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					vSocketWakeUpUser( pxSocket );
3265:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
3266:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				else
3267:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
3268:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Or else make sure this will be called again to wake-up
3269:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					the sockets' owner. */
3270:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					xShortest = ( TickType_t ) 0;
3271:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
3272:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
3273:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3274:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( ( pxSocket->u.xTCP.usTimeout != 0U ) && ( xShortest > ( TickType_t ) pxSocket->u.xTCP.usTime
3275:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
3276:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xShortest = ( TickType_t ) pxSocket->u.xTCP.usTimeout;
3277:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
3278:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
3279:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3280:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		return xShortest;
3281:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
3282:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3283:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigUSE_TCP */
3284:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
3285:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3286:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigUSE_TCP == 1 )
3287:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3288:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/*
3289:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 * TCP: as multiple sockets may be bound to the same local port number
3290:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 * looking up a socket is a little more complex:
3291:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 * Both a local port, and a remote port and IP address are being used
3292:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 * For a socket in listening mode, the remote port and IP address are both 0
3293:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 */
3294:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	FreeRTOS_Socket_t *pxTCPSocketLookup( uint32_t ulLocalIP, UBaseType_t uxLocalPort, uint32_t ulRemo
3295:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
3296:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	const ListItem_t *pxIterator;
3297:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	FreeRTOS_Socket_t *pxResult = NULL, *pxListenSocket = NULL;
3298:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	const ListItem_t *pxEnd = listGET_END_MARKER( &xBoundTCPSocketsList );
3299:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3300:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* Parameter not yet supported. */
3301:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		( void ) ulLocalIP;
3302:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3303:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		for( pxIterator  = listGET_NEXT( pxEnd );
3304:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			 pxIterator != pxEnd;
3305:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			 pxIterator  = listGET_NEXT( pxIterator ) )
3306:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
3307:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			FreeRTOS_Socket_t *pxSocket = ipCAST_PTR_TO_TYPE_PTR( FreeRTOS_Socket_t, listGET_LIST_ITEM_OWNER
3308:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3309:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( pxSocket->usLocalPort == ( uint16_t ) uxLocalPort )
3310:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
3311:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eTCP_LISTEN )
3312:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
3313:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* If this is a socket listening to uxLocalPort, remember it
3314:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					in case there is no perfect match. */
3315:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					pxListenSocket = pxSocket;
3316:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
3317:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				else if( ( pxSocket->u.xTCP.usRemotePort == ( uint16_t ) uxRemotePort ) && ( pxSocket->u.xTCP.u
3318:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
3319:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* For sockets not in listening mode, find a match with
3320:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					xLocalPort, ulRemoteIP AND xRemotePort. */
3321:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					pxResult = pxSocket;
3322:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					break;
3323:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
3324:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				else
3325:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
3326:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* This 'pxSocket' doesn't match. */
3327:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
3328:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
3329:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
3330:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( pxResult == NULL )
3331:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
3332:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* An exact match was not found, maybe a listening socket was
3333:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			found. */
3334:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pxResult = pxListenSocket;
3335:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
3336:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3337:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		return pxResult;
3338:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
3339:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3340:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigUSE_TCP */
3341:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
3342:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3343:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigUSE_TCP == 1 )
3344:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* For the web server: borrow the circular Rx buffer for inspection
3345:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 * HTML driver wants to see if a sequence of 13/10/13/10 is available. */
3346:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	const struct xSTREAM_BUFFER *FreeRTOS_get_rx_buf( ConstSocket_t xSocket )
3347:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
3348:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	const FreeRTOS_Socket_t * pxSocket = ( const FreeRTOS_Socket_t * )xSocket;
3349:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****     const struct xSTREAM_BUFFER *pxReturn = NULL;
3350:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3351:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****         /* Confirm that this is a TCP socket before dereferencing structure
3352:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****         member pointers. */
3353:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****         if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_TCP, pdFALSE ) == pdTRUE )
3354:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****         {
3355:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****             pxReturn = pxSocket->u.xTCP.rxStream;
3356:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****         }
3357:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3358:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****         return pxReturn;
3359:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
3360:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3361:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigUSE_TCP */
3362:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
3363:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3364:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigUSE_TCP == 1 )
3365:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3366:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	static StreamBuffer_t *prvTCPCreateStream ( FreeRTOS_Socket_t *pxSocket, BaseType_t xIsInputStream
3367:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
3368:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	StreamBuffer_t *pxBuffer;
3369:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	size_t uxLength;
3370:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	size_t uxSize;
3371:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3372:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* Now that a stream is created, the maximum size is fixed before
3373:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		creation, it could still be changed with setsockopt(). */
3374:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( xIsInputStream != pdFALSE )
3375:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
3376:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			uxLength = pxSocket->u.xTCP.uxRxStreamSize;
3377:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3378:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( pxSocket->u.xTCP.uxLittleSpace == 0UL )
3379:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
3380:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocket->u.xTCP.uxLittleSpace  = ( sock20_PERCENT * pxSocket->u.xTCP.uxRxStreamSize ) / sock10
3381:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
3382:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3383:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( pxSocket->u.xTCP.uxEnoughSpace == 0UL )
3384:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
3385:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocket->u.xTCP.uxEnoughSpace = ( sock80_PERCENT * pxSocket->u.xTCP.uxRxStreamSize ) / sock100
3386:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
3387:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
3388:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else
3389:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
3390:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			uxLength = pxSocket->u.xTCP.uxTxStreamSize;
 3693              	 .loc 1 3390 0
 3694 005a 236F     	 ldr r3,[r4,#112]
 3695              	.LVL467:
3391:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
3392:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3393:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* Add an extra 4 (or 8) bytes. */
3394:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		uxLength += sizeof( size_t );
 3696              	 .loc 1 3394 0
 3697 005c 0433     	 adds r3,r3,#4
 3698              	.LVL468:
3395:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3396:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* And make the length a multiple of sizeof( size_t ). */
3397:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		uxLength &= ~( sizeof( size_t ) - 1U );
 3699              	 .loc 1 3397 0
 3700 005e 23F00305 	 bic r5,r3,#3
 3701              	.LVL469:
3398:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3399:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		uxSize = ( sizeof( *pxBuffer )  + uxLength ) - sizeof( pxBuffer->ucArray );
3400:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3401:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		pxBuffer = ipCAST_PTR_TO_TYPE_PTR( StreamBuffer_t, pvPortMallocLarge( uxSize ) );
 3702              	 .loc 1 3401 0
 3703 0062 05F11400 	 add r0,r5,#20
 3704              	.LVL470:
 3705 0066 FFF7FEFF 	 bl pvPortMalloc
 3706              	.LVL471:
3402:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3403:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( pxBuffer == NULL )
 3707              	 .loc 1 3403 0
 3708 006a 0646     	 mov r6,r0
 3709 006c 60B9     	 cbnz r0,.L337
3404:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
3405:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			FreeRTOS_debug_printf( ( "prvTCPCreateStream: malloc failed\n" ) );
3406:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pxSocket->u.xTCP.bits.bMallocError = pdTRUE;
 3710              	 .loc 1 3406 0
 3711 006e 94F84230 	 ldrb r3,[r4,#66]
 3712 0072 43F00803 	 orr r3,r3,#8
 3713 0076 84F84230 	 strb r3,[r4,#66]
 3714              	.LVL472:
3407:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			vTCPStateChange( pxSocket, eCLOSE_WAIT );
 3715              	 .loc 1 3407 0
 3716 007a 2046     	 mov r0,r4
 3717              	.LVL473:
 3718 007c 0821     	 movs r1,#8
 3719 007e FFF7FEFF 	 bl vTCPStateChange
 3720              	.LVL474:
 3721              	.LBE295:
 3722              	.LBE294:
2863:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 3723              	 .loc 1 2863 0
 3724 0082 A36F     	 ldr r3,[r4,#120]
 3725 0084 33B9     	 cbnz r3,.L350
 3726 0086 7BE0     	 b .L359
 3727              	.LVL475:
 3728              	.L337:
 3729              	.LBB297:
 3730              	.LBB296:
3408:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
3409:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else
3410:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
3411:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Clear the markers of the stream */
3412:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			( void ) memset( pxBuffer, 0, sizeof( *pxBuffer ) - sizeof( pxBuffer->ucArray ) );
 3731              	 .loc 1 3412 0
 3732 0088 0021     	 movs r1,#0
 3733 008a 1422     	 movs r2,#20
 3734 008c FFF7FEFF 	 bl memset
 3735              	.LVL476:
3413:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pxBuffer->LENGTH = ( size_t ) uxLength ;
 3736              	 .loc 1 3413 0
 3737 0090 3561     	 str r5,[r6,#16]
3414:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3415:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( xTCPWindowLoggingLevel != 0 )
3416:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
3417:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				FreeRTOS_debug_printf( ( "prvTCPCreateStream: %cxStream created %u bytes (total %u)\n", ( xIsIn
3418:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
3419:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3420:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( xIsInputStream != 0 )
3421:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
3422:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				iptraceMEM_STATS_CREATE( tcpRX_STREAM_BUFFER, pxBuffer, uxSize );
3423:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocket->u.xTCP.rxStream = pxBuffer;
3424:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
3425:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			else
3426:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
3427:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				iptraceMEM_STATS_CREATE( tcpTX_STREAM_BUFFER, pxBuffer, uxSize );
3428:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocket->u.xTCP.txStream = pxBuffer;
 3738              	 .loc 1 3428 0
 3739 0092 A667     	 str r6,[r4,#120]
 3740              	.LVL477:
 3741              	.L350:
 3742              	.LBE296:
 3743              	.LBE297:
 3744              	.LBE293:
 3745              	.LBE292:
2943:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 3746              	 .loc 1 2943 0
 3747 0094 A26F     	 ldr r2,[r4,#120]
 3748              	.LVL478:
 3749              	.LBB299:
 3750              	.LBB300:
  99:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxTail = pxBuffer->uxTail;
 3751              	 .loc 3 99 0
 3752 0096 9168     	 ldr r1,[r2,#8]
 3753              	.LVL479:
 100:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
 3754              	 .loc 3 100 0
 3755 0098 1368     	 ldr r3,[r2]
 3756              	.LVL480:
 3757              	.LBB301:
 3758              	.LBB302:
  68:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	if( uxCount >= pxBuffer->LENGTH )
 3759              	 .loc 3 68 0
 3760 009a 1269     	 ldr r2,[r2,#16]
 3761              	.LVL481:
 3762 009c 1344     	 add r3,r3,r2
 3763              	.LVL482:
 3764 009e 013B     	 subs r3,r3,#1
 3765 00a0 5B1A     	 subs r3,r3,r1
 3766              	.LVL483:
  69:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	{
 3767              	 .loc 3 69 0
 3768 00a2 9A42     	 cmp r2,r3
 3769              	.LVL484:
  71:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	}
 3770              	 .loc 3 71 0
 3771 00a4 98BF     	 it ls
 3772 00a6 9B1A     	 subls r3,r3,r2
 3773              	.LVL485:
 3774              	.LBE302:
 3775              	.LBE301:
 3776              	.LBE300:
 3777              	.LBE299:
2946:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 3778              	 .loc 1 2946 0
 3779 00a8 039A     	 ldr r2,[sp,#12]
 3780 00aa 002A     	 cmp r2,#0
 3781 00ac 4CDD     	 ble .L339
 3782 00ae 1546     	 mov r5,r2
 3783 00b0 4FF0000A 	 mov r10,#0
2996:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 3784              	 .loc 1 2996 0
 3785 00b4 0126     	 movs r6,#1
 3786              	.LVL486:
 3787              	.L348:
2949:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 3788              	 .loc 1 2949 0
 3789 00b6 002B     	 cmp r3,#0
 3790 00b8 1CDD     	 ble .L340
 3791 00ba AB42     	 cmp r3,r5
 3792 00bc A8BF     	 it ge
 3793 00be 2B46     	 movge r3,r5
 3794              	.LVL487:
2959:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 3795              	 .loc 1 2959 0
 3796 00c0 94F84020 	 ldrb r2,[r4,#64]
 3797 00c4 12F0100F 	 tst r2,#16
 3798 00c8 01D0     	 beq .L341
2959:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 3799              	 .loc 1 2959 0 is_stmt 0 discriminator 1
 3800 00ca 9D42     	 cmp r5,r3
 3801 00cc 5BD0     	 beq .L342
 3802              	.L341:
 3803              	.LVL488:
2984:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 3804              	 .loc 1 2984 0 is_stmt 1
 3805 00ce A06F     	 ldr r0,[r4,#120]
 3806 00d0 0021     	 movs r1,#0
 3807 00d2 3A46     	 mov r2,r7
 3808 00d4 FFF7FEFF 	 bl uxStreamBufferAdd
 3809              	.LVL489:
 3810 00d8 8146     	 mov r9,r0
 3811 00da 8046     	 mov r8,r0
 3812              	.LVL490:
 3813              	.L351:
2996:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 3814              	 .loc 1 2996 0
 3815 00dc A4F84860 	 strh r6,[r4,#72]
2998:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 3816              	 .loc 1 2998 0
 3817 00e0 FFF7FEFF 	 bl xIsCallingFromIPTask
 3818              	.LVL491:
 3819 00e4 10B9     	 cbnz r0,.L343
3002:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
 3820              	 .loc 1 3002 0
 3821 00e6 0620     	 movs r0,#6
 3822 00e8 FFF7FEFF 	 bl xSendEventToIPTask
 3823              	.LVL492:
 3824              	.L343:
3007:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 3825              	 .loc 1 3007 0
 3826 00ec B5EB0805 	 subs r5,r5,r8
 3827              	.LVL493:
 3828 00f0 27D0     	 beq .L344
3014:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 3829              	 .loc 1 3014 0
 3830 00f2 4F44     	 add r7,r7,r9
 3831              	.LVL494:
 3832              	.L340:
3019:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 3833              	 .loc 1 3019 0
 3834 00f4 BAF1000F 	 cmp r10,#0
 3835 00f8 0AD1     	 bne .L345
3022:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 3836              	 .loc 1 3022 0
 3837 00fa 236A     	 ldr r3,[r4,#32]
 3838 00fc 0793     	 str r3,[sp,#28]
3037:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 3839              	 .loc 1 3037 0
 3840 00fe 03B3     	 cbz r3,.L344
3042:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 3841              	 .loc 1 3042 0
 3842 0100 1BF0100F 	 tst fp,#16
 3843 0104 1DD1     	 bne .L344
 3844              	.LVL495:
3051:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 3845              	 .loc 1 3051 0
 3846 0106 05A8     	 add r0,sp,#20
 3847 0108 FFF7FEFF 	 bl vTaskSetTimeOutState
 3848              	.LVL496:
3048:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 3849              	 .loc 1 3048 0
 3850 010c B246     	 mov r10,r6
 3851 010e 04E0     	 b .L346
 3852              	.LVL497:
 3853              	.L345:
3056:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 3854              	 .loc 1 3056 0
 3855 0110 05A8     	 add r0,sp,#20
 3856 0112 07A9     	 add r1,sp,#28
 3857 0114 FFF7FEFF 	 bl xTaskCheckForTimeOut
 3858              	.LVL498:
 3859 0118 98B9     	 cbnz r0,.L344
 3860              	.LVL499:
 3861              	.L346:
3063:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					pdTRUE /*xClearOnExit*/, pdFALSE /*xWaitAllBits*/, xRemainingTime );
 3862              	 .loc 1 3063 0
 3863 011a 079B     	 ldr r3,[sp,#28]
 3864 011c 0093     	 str r3,[sp]
 3865 011e 6068     	 ldr r0,[r4,#4]
 3866 0120 2221     	 movs r1,#34
 3867 0122 3246     	 mov r2,r6
 3868 0124 0023     	 movs r3,#0
 3869 0126 FFF7FEFF 	 bl xEventGroupWaitBits
 3870              	.LVL500:
3066:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 3871              	 .loc 1 3066 0
 3872 012a A26F     	 ldr r2,[r4,#120]
 3873              	.LVL501:
 3874              	.LBB303:
 3875              	.LBB304:
  99:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxTail = pxBuffer->uxTail;
 3876              	 .loc 3 99 0
 3877 012c 9168     	 ldr r1,[r2,#8]
 3878              	.LVL502:
 100:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
 3879              	 .loc 3 100 0
 3880 012e 1368     	 ldr r3,[r2]
 3881              	.LVL503:
 3882              	.LBB305:
 3883              	.LBB306:
  68:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	if( uxCount >= pxBuffer->LENGTH )
 3884              	 .loc 3 68 0
 3885 0130 1269     	 ldr r2,[r2,#16]
 3886              	.LVL504:
 3887 0132 1344     	 add r3,r3,r2
 3888              	.LVL505:
 3889 0134 013B     	 subs r3,r3,#1
 3890 0136 5B1A     	 subs r3,r3,r1
 3891              	.LVL506:
  69:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	{
 3892              	 .loc 3 69 0
 3893 0138 9A42     	 cmp r2,r3
 3894              	.LVL507:
  71:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	}
 3895              	 .loc 3 71 0
 3896 013a 98BF     	 it ls
 3897 013c 9B1A     	 subls r3,r3,r2
 3898              	.LVL508:
 3899              	.LBE306:
 3900              	.LBE305:
 3901              	.LBE304:
 3902              	.LBE303:
2946:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 3903              	 .loc 1 2946 0
 3904 013e 002D     	 cmp r5,#0
 3905 0140 B9DC     	 bgt .L348
 3906              	.LVL509:
 3907              	.L344:
3072:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 3908              	 .loc 1 3072 0
 3909 0142 039B     	 ldr r3,[sp,#12]
 3910 0144 581B     	 subs r0,r3,r5
 3911              	.LVL510:
 3912 0146 31D1     	 bne .L361
 3913              	.LVL511:
 3914              	.L339:
3074:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 3915              	 .loc 1 3074 0
 3916 0148 94F85330 	 ldrb r3,[r4,#83]
3088:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 3917              	 .loc 1 3088 0
 3918 014c 052B     	 cmp r3,#5
 3919 014e 8CBF     	 ite hi
 3920 0150 6FF07F00 	 mvnhi r0,#127
 3921 0154 6FF01B00 	 mvnls r0,#27
 3922 0158 28E0     	 b .L361
 3923              	.LVL512:
 3924              	.L352:
2919:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t xBytesLeft;
 3925              	 .loc 1 2919 0
 3926 015a 6FF01500 	 mvn r0,#21
 3927              	.LVL513:
 3928 015e 25E0     	 b .L361
 3929              	.LVL514:
 3930              	.L353:
 3931              	.LBB307:
 3932              	.LBB298:
2834:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 3933              	 .loc 1 2834 0
 3934 0160 6FF01500 	 mvn r0,#21
 3935 0164 22E0     	 b .L361
 3936              	.L354:
2838:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 3937              	 .loc 1 2838 0
 3938 0166 6FF00B00 	 mvn r0,#11
 3939 016a 1FE0     	 b .L361
 3940              	.L355:
2844:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 3941              	 .loc 1 2844 0
 3942 016c 6FF07F00 	 mvn r0,#127
 3943 0170 1CE0     	 b .L361
 3944              	.L356:
 3945 0172 6FF07F00 	 mvn r0,#127
 3946 0176 19E0     	 b .L361
 3947              	.L357:
2851:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 3948              	 .loc 1 2851 0
 3949 0178 0020     	 movs r0,#0
 3950 017a 17E0     	 b .L361
 3951              	.L358:
2856:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 3952              	 .loc 1 2856 0
 3953 017c 0020     	 movs r0,#0
 3954 017e 15E0     	 b .L361
 3955              	.LVL515:
 3956              	.L359:
2865:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 3957              	 .loc 1 2865 0
 3958 0180 6FF00B00 	 mvn r0,#11
 3959              	.LVL516:
 3960 0184 12E0     	 b .L361
 3961              	.LVL517:
 3962              	.L342:
 3963              	.LBE298:
 3964              	.LBE307:
2980:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						pxSocket->u.xTCP.bits.bCloseRequested = pdTRUE;
 3965              	 .loc 1 2980 0
 3966 0186 FFF7FEFF 	 bl vTaskSuspendAll
 3967              	.LVL518:
2981:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
 3968              	 .loc 1 2981 0
 3969 018a 94F84030 	 ldrb r3,[r4,#64]
 3970 018e 43F04003 	 orr r3,r3,#64
 3971 0192 84F84030 	 strb r3,[r4,#64]
2984:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 3972              	 .loc 1 2984 0
 3973 0196 A06F     	 ldr r0,[r4,#120]
 3974 0198 0021     	 movs r1,#0
 3975 019a 3A46     	 mov r2,r7
 3976 019c 2B46     	 mov r3,r5
 3977 019e FFF7FEFF 	 bl uxStreamBufferAdd
 3978              	.LVL519:
 3979 01a2 8146     	 mov r9,r0
 3980 01a4 8046     	 mov r8,r0
 3981              	.LVL520:
2991:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
 3982              	 .loc 1 2991 0
 3983 01a6 FFF7FEFF 	 bl xTaskResumeAll
 3984              	.LVL521:
 3985 01aa 97E7     	 b .L351
 3986              	.LVL522:
 3987              	.L361:
3094:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 3988              	 .loc 1 3094 0
 3989 01ac 09B0     	 add sp,sp,#36
 3990              	.LCFI55:
 3991              	 .cfi_def_cfa_offset 36
 3992              	 
 3993 01ae BDE8F08F 	 pop {r4,r5,r6,r7,r8,r9,r10,fp,pc}
 3994              	 .cfi_endproc
 3995              	.LFE90:
 3997 01b2 00BF     	 .section .text.FreeRTOS_listen,"ax",%progbits
 3998              	 .align 2
 3999              	 .global FreeRTOS_listen
 4000              	 .thumb
 4001              	 .thumb_func
 4003              	FreeRTOS_listen:
 4004              	.LFB91:
3105:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	FreeRTOS_Socket_t *pxSocket;
 4005              	 .loc 1 3105 0
 4006              	 .cfi_startproc
 4007              	 
 4008              	 
 4009              	.LVL523:
 4010 0000 38B5     	 push {r3,r4,r5,lr}
 4011              	.LCFI56:
 4012              	 .cfi_def_cfa_offset 16
 4013              	 .cfi_offset 3,-16
 4014              	 .cfi_offset 4,-12
 4015              	 .cfi_offset 5,-8
 4016              	 .cfi_offset 14,-4
 4017 0002 0446     	 mov r4,r0
 4018 0004 0D46     	 mov r5,r1
 4019              	.LVL524:
3113:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 4020              	 .loc 1 3113 0
 4021 0006 0621     	 movs r1,#6
 4022              	.LVL525:
 4023 0008 0122     	 movs r2,#1
 4024 000a FFF7FEFF 	 bl prvValidSocket
 4025              	.LVL526:
 4026 000e 0028     	 cmp r0,#0
 4027 0010 3AD0     	 beq .L369
3117:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 4028              	 .loc 1 3117 0
 4029 0012 94F85330 	 ldrb r3,[r4,#83]
 4030 0016 13F0F70F 	 tst r3,#247
 4031 001a 38D1     	 bne .L370
 4032              	.LVL527:
 4033              	.LBB308:
 4034              	.LBB309:
 217:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	static portINLINE uint32_t FreeRTOS_min_uint32 (uint32_t a, uint32_t b) { return ( a <= b ) ? a : 
 4035              	 .loc 4 217 0
 4036 001c 4FF6FF71 	 movw r1,#65535
 4037 0020 A942     	 cmp r1,r5
 4038 0022 A8BF     	 it ge
 4039 0024 2946     	 movge r1,r5
 4040              	.LBE309:
 4041              	.LBE308:
3126:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 4042              	 .loc 1 3126 0
 4043 0026 A4F85010 	 strh r1,[r4,#80]
3130:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 4044              	 .loc 1 3130 0
 4045 002a 94F84030 	 ldrb r3,[r4,#64]
 4046 002e 13F0080F 	 tst r3,#8
 4047 0032 23D0     	 beq .L366
3132:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 4048              	 .loc 1 3132 0
 4049 0034 636F     	 ldr r3,[r4,#116]
 4050 0036 23B1     	 cbz r3,.L367
 4051              	.LVL528:
 4052              	.LBB310:
 4053              	.LBB311:
  55:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	pxBuffer->uxTail = 0U;
 4054              	 .loc 3 55 0
 4055 0038 0022     	 movs r2,#0
 4056 003a 9A60     	 str r2,[r3,#8]
  56:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	pxBuffer->uxFront = 0U;
 4057              	 .loc 3 56 0
 4058 003c 1A60     	 str r2,[r3]
  57:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	pxBuffer->uxMid = 0U;
 4059              	 .loc 3 57 0
 4060 003e DA60     	 str r2,[r3,#12]
  58:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** }
 4061              	 .loc 3 58 0
 4062 0040 5A60     	 str r2,[r3,#4]
 4063              	.LVL529:
 4064              	.L367:
 4065              	.LBE311:
 4066              	.LBE310:
3137:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 4067              	 .loc 1 3137 0
 4068 0042 A36F     	 ldr r3,[r4,#120]
 4069 0044 23B1     	 cbz r3,.L368
 4070              	.LVL530:
 4071              	.LBB312:
 4072              	.LBB313:
  55:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	pxBuffer->uxTail = 0U;
 4073              	 .loc 3 55 0
 4074 0046 0022     	 movs r2,#0
 4075 0048 9A60     	 str r2,[r3,#8]
  56:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	pxBuffer->uxFront = 0U;
 4076              	 .loc 3 56 0
 4077 004a 1A60     	 str r2,[r3]
  57:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	pxBuffer->uxMid = 0U;
 4078              	 .loc 3 57 0
 4079 004c DA60     	 str r2,[r3,#12]
  58:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** }
 4080              	 .loc 3 58 0
 4081 004e 5A60     	 str r2,[r3,#4]
 4082              	.LVL531:
 4083              	.L368:
 4084              	.LBE313:
 4085              	.LBE312:
3142:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				( void ) memset( &pxSocket->u.xTCP.xTCPWindow, 0, sizeof( pxSocket->u.xTCP.xTCPWindow ) );
 4086              	 .loc 1 3142 0
 4087 0050 04F18200 	 add r0,r4,#130
 4088 0054 0021     	 movs r1,#0
 4089 0056 4622     	 movs r2,#70
 4090 0058 FFF7FEFF 	 bl memset
 4091              	.LVL532:
3143:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				( void ) memset( &pxSocket->u.xTCP.bits, 0, sizeof( pxSocket->u.xTCP.bits ) );
 4092              	 .loc 1 3143 0
 4093 005c 04F1D800 	 add r0,r4,#216
 4094 0060 0021     	 movs r1,#0
 4095 0062 C022     	 movs r2,#192
 4096 0064 FFF7FEFF 	 bl memset
 4097              	.LVL533:
3144:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 4098              	 .loc 1 3144 0
 4099 0068 0023     	 movs r3,#0
 4100 006a 84F84130 	 strb r3,[r4,#65]
 4101 006e 84F84230 	 strb r3,[r4,#66]
 4102 0072 84F84330 	 strb r3,[r4,#67]
3148:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 4103              	 .loc 1 3148 0
 4104 0076 0823     	 movs r3,#8
 4105 0078 84F84030 	 strb r3,[r4,#64]
 4106              	.L366:
3151:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 4107              	 .loc 1 3151 0
 4108 007c 2046     	 mov r0,r4
 4109 007e 0121     	 movs r1,#1
 4110 0080 FFF7FEFF 	 bl vTCPStateChange
 4111              	.LVL534:
3107:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 4112              	 .loc 1 3107 0
 4113 0084 0020     	 movs r0,#0
 4114 0086 38BD     	 pop {r3,r4,r5,pc}
 4115              	.LVL535:
 4116              	.L369:
3115:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 4117              	 .loc 1 3115 0
 4118 0088 6FF05E00 	 mvn r0,#94
 4119 008c 38BD     	 pop {r3,r4,r5,pc}
 4120              	.LVL536:
 4121              	.L370:
3120:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 4122              	 .loc 1 3120 0
 4123 008e 6FF05E00 	 mvn r0,#94
 4124              	.LVL537:
3155:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 4125              	 .loc 1 3155 0
 4126 0092 38BD     	 pop {r3,r4,r5,pc}
 4127              	 .cfi_endproc
 4128              	.LFE91:
 4130              	 .section .text.FreeRTOS_shutdown,"ax",%progbits
 4131              	 .align 2
 4132              	 .global FreeRTOS_shutdown
 4133              	 .thumb
 4134              	 .thumb_func
 4136              	FreeRTOS_shutdown:
 4137              	.LFB92:
3164:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
 4138              	 .loc 1 3164 0
 4139              	 .cfi_startproc
 4140              	 
 4141              	 
 4142              	.LVL538:
 4143 0000 10B5     	 push {r4,lr}
 4144              	.LCFI57:
 4145              	 .cfi_def_cfa_offset 8
 4146              	 .cfi_offset 4,-8
 4147              	 .cfi_offset 14,-4
 4148 0002 0446     	 mov r4,r0
 4149              	.LVL539:
3168:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 4150              	 .loc 1 3168 0
 4151 0004 0621     	 movs r1,#6
 4152              	.LVL540:
 4153 0006 0122     	 movs r2,#1
 4154 0008 FFF7FEFF 	 bl prvValidSocket
 4155              	.LVL541:
 4156 000c 88B1     	 cbz r0,.L374
3174:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 4157              	 .loc 1 3174 0
 4158 000e 94F85330 	 ldrb r3,[r4,#83]
 4159 0012 052B     	 cmp r3,#5
 4160 0014 10D1     	 bne .L375
3182:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 4161              	 .loc 1 3182 0
 4162 0016 94F84030 	 ldrb r3,[r4,#64]
 4163 001a 43F02003 	 orr r3,r3,#32
 4164 001e 84F84030 	 strb r3,[r4,#64]
3185:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			( void ) xSendEventToIPTask( eTCPTimerEvent );
 4165              	 .loc 1 3185 0
 4166 0022 0123     	 movs r3,#1
 4167 0024 A4F84830 	 strh r3,[r4,#72]
3186:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xResult = 0;
 4168              	 .loc 1 3186 0
 4169 0028 0620     	 movs r0,#6
 4170 002a FFF7FEFF 	 bl xSendEventToIPTask
 4171              	.LVL542:
3187:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 4172              	 .loc 1 3187 0
 4173 002e 0020     	 movs r0,#0
 4174 0030 10BD     	 pop {r4,pc}
 4175              	.LVL543:
 4176              	.L374:
3172:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 4177              	 .loc 1 3172 0
 4178 0032 6FF05E00 	 mvn r0,#94
 4179 0036 10BD     	 pop {r4,pc}
 4180              	.LVL544:
 4181              	.L375:
3178:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 4182              	 .loc 1 3178 0
 4183 0038 6FF05E00 	 mvn r0,#94
 4184              	.LVL545:
3192:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 4185              	 .loc 1 3192 0
 4186 003c 10BD     	 pop {r4,pc}
 4187              	 .cfi_endproc
 4188              	.LFE92:
 4190 003e 00BF     	 .section .text.xTCPTimerCheck,"ax",%progbits
 4191              	 .align 2
 4192              	 .global xTCPTimerCheck
 4193              	 .thumb
 4194              	 .thumb_func
 4196              	xTCPTimerCheck:
 4197              	.LFB93:
3208:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	FreeRTOS_Socket_t *pxSocket;
 4198              	 .loc 1 3208 0
 4199              	 .cfi_startproc
 4200              	 
 4201              	 
 4202              	.LVL546:
 4203 0000 2DE9F047 	 push {r4,r5,r6,r7,r8,r9,r10,lr}
 4204              	.LCFI58:
 4205              	 .cfi_def_cfa_offset 32
 4206              	 .cfi_offset 4,-32
 4207              	 .cfi_offset 5,-28
 4208              	 .cfi_offset 6,-24
 4209              	 .cfi_offset 7,-20
 4210              	 .cfi_offset 8,-16
 4211              	 .cfi_offset 9,-12
 4212              	 .cfi_offset 10,-8
 4213              	 .cfi_offset 14,-4
 4214 0004 8246     	 mov r10,r0
 4215              	.LVL547:
3211:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	static TickType_t xLastTime = 0U;
 4216              	 .loc 1 3211 0
 4217 0006 FFF7FEFF 	 bl xTaskGetTickCount
 4218              	.LVL548:
3213:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	const ListItem_t* pxEnd = listGET_END_MARKER( &xBoundTCPSocketsList );
 4219              	 .loc 1 3213 0
 4220 000a 1E4B     	 ldr r3,.L389
 4221 000c 1E68     	 ldr r6,[r3]
 4222 000e 861B     	 subs r6,r0,r6
 4223              	.LVL549:
3215:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 4224              	 .loc 1 3215 0
 4225 0010 1D4A     	 ldr r2,.L389+4
 4226 0012 D468     	 ldr r4,[r2,#12]
 4227              	.LVL550:
3217:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 4228              	 .loc 1 3217 0
 4229 0014 1860     	 str r0,[r3]
3221:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 4230              	 .loc 1 3221 0
 4231 0016 002E     	 cmp r6,#0
 4232 0018 08BF     	 it eq
 4233 001a 0126     	 moveq r6,#1
 4234              	.LVL551:
3224:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 4235              	 .loc 1 3224 0
 4236 001c 02F10803 	 add r3,r2,#8
 4237 0020 9C42     	 cmp r4,r3
 4238 0022 29D0     	 beq .L385
 4239 0024 4FF47A78 	 mov r8,#1000
3270:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 4240              	 .loc 1 3270 0
 4241 0028 4FF00009 	 mov r9,#0
3224:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 4242              	 .loc 1 3224 0
 4243 002c 1F46     	 mov r7,r3
 4244              	.LVL552:
 4245              	.L384:
3226:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pxIterator = ( ListItem_t * ) listGET_NEXT( pxIterator );
 4246              	 .loc 1 3226 0
 4247 002e E568     	 ldr r5,[r4,#12]
 4248              	.LVL553:
3227:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 4249              	 .loc 1 3227 0
 4250 0030 6468     	 ldr r4,[r4,#4]
 4251              	.LVL554:
3230:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 4252              	 .loc 1 3230 0
 4253 0032 B5F84830 	 ldrh r3,[r5,#72]
 4254 0036 E3B1     	 cbz r3,.L380
3235:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 4255              	 .loc 1 3235 0
 4256 0038 B342     	 cmp r3,r6
 4257 003a 03D9     	 bls .L381
3237:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 4258              	 .loc 1 3237 0
 4259 003c 9B1B     	 subs r3,r3,r6
 4260 003e A5F84830 	 strh r3,[r5,#72]
 4261 0042 06E0     	 b .L382
 4262              	.L381:
 4263              	.LBB314:
3243:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xRc = xTCPSocketCheck( pxSocket );
 4264              	 .loc 1 3243 0
 4265 0044 A5F84890 	 strh r9,[r5,#72]
3244:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 4266              	 .loc 1 3244 0
 4267 0048 2846     	 mov r0,r5
 4268 004a FFF7FEFF 	 bl xTCPSocketCheck
 4269              	.LVL555:
3248:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 4270              	 .loc 1 3248 0
 4271 004e 0028     	 cmp r0,#0
 4272 0050 0FDB     	 blt .L380
 4273              	.LVL556:
 4274              	.L382:
 4275              	.LBE314:
3258:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 4276              	 .loc 1 3258 0
 4277 0052 2B68     	 ldr r3,[r5]
 4278 0054 3BB1     	 cbz r3,.L383
3260:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 4279              	 .loc 1 3260 0
 4280 0056 BAF1000F 	 cmp r10,#0
 4281 005a 03D0     	 beq .L386
3264:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 4282              	 .loc 1 3264 0
 4283 005c 2846     	 mov r0,r5
 4284 005e FFF7FEFF 	 bl vSocketWakeUpUser
 4285              	.LVL557:
 4286 0062 00E0     	 b .L383
 4287              	.L386:
3270:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 4288              	 .loc 1 3270 0
 4289 0064 C846     	 mov r8,r9
 4290              	.LVL558:
 4291              	.L383:
3274:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 4292              	 .loc 1 3274 0
 4293 0066 B5F84830 	 ldrh r3,[r5,#72]
 4294 006a 13B1     	 cbz r3,.L380
 4295 006c 9845     	 cmp r8,r3
 4296 006e 28BF     	 it cs
 4297 0070 9846     	 movcs r8,r3
 4298              	.LVL559:
 4299              	.L380:
3224:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 4300              	 .loc 1 3224 0
 4301 0072 BC42     	 cmp r4,r7
 4302 0074 DBD1     	 bne .L384
 4303 0076 01E0     	 b .L379
 4304              	.LVL560:
 4305              	.L385:
 4306 0078 4FF47A78 	 mov r8,#1000
 4307              	.LVL561:
 4308              	.L379:
3281:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 4309              	 .loc 1 3281 0
 4310 007c 4046     	 mov r0,r8
 4311 007e BDE8F087 	 pop {r4,r5,r6,r7,r8,r9,r10,pc}
 4312              	.LVL562:
 4313              	.L390:
 4314 0082 00BF     	 .align 2
 4315              	.L389:
 4316 0084 00000000 	 .word .LANCHOR2
 4317 0088 00000000 	 .word xBoundTCPSocketsList
 4318              	 .cfi_endproc
 4319              	.LFE93:
 4321              	 .section .text.pxTCPSocketLookup,"ax",%progbits
 4322              	 .align 2
 4323              	 .global pxTCPSocketLookup
 4324              	 .thumb
 4325              	 .thumb_func
 4327              	pxTCPSocketLookup:
 4328              	.LFB94:
3295:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	const ListItem_t *pxIterator;
 4329              	 .loc 1 3295 0
 4330              	 .cfi_startproc
 4331              	 
 4332              	 
 4333              	 
 4334              	.LVL563:
 4335 0000 F0B4     	 push {r4,r5,r6,r7}
 4336              	.LCFI59:
 4337              	 .cfi_def_cfa_offset 16
 4338              	 .cfi_offset 4,-16
 4339              	 .cfi_offset 5,-12
 4340              	 .cfi_offset 6,-8
 4341              	 .cfi_offset 7,-4
 4342              	.LVL564:
3303:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			 pxIterator != pxEnd;
 4343              	 .loc 1 3303 0
 4344 0002 1148     	 ldr r0,.L402
 4345              	.LVL565:
 4346 0004 C468     	 ldr r4,[r0,#12]
 4347              	.LVL566:
 4348 0006 0830     	 adds r0,r0,#8
 4349 0008 8442     	 cmp r4,r0
 4350 000a 1AD0     	 beq .L397
 4351 000c 0020     	 movs r0,#0
 4352              	.LBB315:
3309:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 4353              	 .loc 1 3309 0
 4354 000e 89B2     	 uxth r1,r1
 4355              	.LVL567:
3317:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 4356              	 .loc 1 3317 0
 4357 0010 9BB2     	 uxth r3,r3
 4358              	.LVL568:
 4359              	.LBE315:
3303:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			 pxIterator != pxEnd;
 4360              	 .loc 1 3303 0
 4361 0012 0E4F     	 ldr r7,.L402+4
 4362              	.LVL569:
 4363              	.L396:
 4364              	.LBB316:
3307:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 4365              	 .loc 1 3307 0
 4366 0014 E568     	 ldr r5,[r4,#12]
 4367              	.LVL570:
3309:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 4368              	 .loc 1 3309 0
 4369 0016 AE8C     	 ldrh r6,[r5,#36]
 4370 0018 8E42     	 cmp r6,r1
 4371 001a 0ED1     	 bne .L393
3311:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 4372              	 .loc 1 3311 0
 4373 001c 95F85360 	 ldrb r6,[r5,#83]
 4374 0020 012E     	 cmp r6,#1
 4375 0022 09D0     	 beq .L398
3317:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 4376              	 .loc 1 3317 0
 4377 0024 AE8F     	 ldrh r6,[r5,#60]
 4378 0026 9E42     	 cmp r6,r3
 4379 0028 07D1     	 bne .L393
3317:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 4380              	 .loc 1 3317 0 is_stmt 0 discriminator 1
 4381 002a AE6B     	 ldr r6,[r5,#56]
 4382 002c 9642     	 cmp r6,r2
 4383 002e 04D1     	 bne .L393
 4384              	.LVL571:
3307:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 4385              	 .loc 1 3307 0 is_stmt 1
 4386 0030 002D     	 cmp r5,#0
 4387 0032 18BF     	 it ne
 4388 0034 2846     	 movne r0,r5
 4389              	.LBE316:
 4390 0036 05E0     	 b .L399
 4391              	.LVL572:
 4392              	.L398:
 4393              	.LBB317:
 4394 0038 2846     	 mov r0,r5
 4395              	.L393:
 4396              	.LBE317:
3305:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 4397              	 .loc 1 3305 0
 4398 003a 6468     	 ldr r4,[r4,#4]
 4399              	.LVL573:
3303:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			 pxIterator != pxEnd;
 4400              	 .loc 1 3303 0
 4401 003c BC42     	 cmp r4,r7
 4402 003e E9D1     	 bne .L396
 4403 0040 00E0     	 b .L399
 4404              	.LVL574:
 4405              	.L397:
3297:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	const ListItem_t *pxEnd = listGET_END_MARKER( &xBoundTCPSocketsList );
 4406              	 .loc 1 3297 0
 4407 0042 0020     	 movs r0,#0
 4408              	.LVL575:
 4409              	.L399:
3338:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 4410              	 .loc 1 3338 0
 4411 0044 F0BC     	 pop {r4,r5,r6,r7}
 4412              	.LCFI60:
 4413              	 .cfi_restore 7
 4414              	 .cfi_restore 6
 4415              	 .cfi_restore 5
 4416              	 .cfi_restore 4
 4417              	 .cfi_def_cfa_offset 0
 4418              	.LVL576:
 4419 0046 7047     	 bx lr
 4420              	.L403:
 4421              	 .align 2
 4422              	.L402:
 4423 0048 00000000 	 .word xBoundTCPSocketsList
 4424 004c 08000000 	 .word xBoundTCPSocketsList+8
 4425              	 .cfi_endproc
 4426              	.LFE94:
 4428              	 .section .text.FreeRTOS_get_rx_buf,"ax",%progbits
 4429              	 .align 2
 4430              	 .global FreeRTOS_get_rx_buf
 4431              	 .thumb
 4432              	 .thumb_func
 4434              	FreeRTOS_get_rx_buf:
 4435              	.LFB95:
3347:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	const FreeRTOS_Socket_t * pxSocket = ( const FreeRTOS_Socket_t * )xSocket;
 4436              	 .loc 1 3347 0
 4437              	 .cfi_startproc
 4438              	 
 4439              	 
 4440              	.LVL577:
 4441 0000 10B5     	 push {r4,lr}
 4442              	.LCFI61:
 4443              	 .cfi_def_cfa_offset 8
 4444              	 .cfi_offset 4,-8
 4445              	 .cfi_offset 14,-4
 4446 0002 0446     	 mov r4,r0
 4447              	.LVL578:
3353:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****         {
 4448              	 .loc 1 3353 0
 4449 0004 0621     	 movs r1,#6
 4450 0006 0022     	 movs r2,#0
 4451 0008 FFF7FEFF 	 bl prvValidSocket
 4452              	.LVL579:
 4453 000c 0128     	 cmp r0,#1
3355:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c ****         }
 4454              	 .loc 1 3355 0
 4455 000e 0CBF     	 ite eq
 4456 0010 606F     	 ldreq r0,[r4,#116]
 4457              	.LVL580:
3349:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 4458              	 .loc 1 3349 0
 4459 0012 0020     	 movne r0,#0
 4460              	.LVL581:
3359:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 4461              	 .loc 1 3359 0
 4462 0014 10BD     	 pop {r4,pc}
 4463              	 .cfi_endproc
 4464              	.LFE95:
 4466 0016 00BF     	 .section .text.lTCPAddRxdata,"ax",%progbits
 4467              	 .align 2
 4468              	 .global lTCPAddRxdata
 4469              	 .thumb
 4470              	 .thumb_func
 4472              	lTCPAddRxdata:
 4473              	.LFB97:
3429:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
3430:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
3431:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3432:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		return pxBuffer;
3433:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
3434:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3435:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigUSE_TCP */
3436:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
3437:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3438:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigUSE_TCP == 1 )
3439:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3440:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/*
3441:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 * Add data to the RxStream.  When uxOffset > 0, data has come in out-of-order
3442:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 * and will be put in front of the head so it can not be popped by the user.
3443:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 */
3444:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	int32_t lTCPAddRxdata( FreeRTOS_Socket_t *pxSocket, size_t uxOffset, const uint8_t *pcData, uint32
3445:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 4474              	 .loc 1 3445 0
 4475              	 .cfi_startproc
 4476              	 
 4477              	 
 4478              	.LVL582:
 4479 0000 2DE9F843 	 push {r3,r4,r5,r6,r7,r8,r9,lr}
 4480              	.LCFI62:
 4481              	 .cfi_def_cfa_offset 32
 4482              	 .cfi_offset 3,-32
 4483              	 .cfi_offset 4,-28
 4484              	 .cfi_offset 5,-24
 4485              	 .cfi_offset 6,-20
 4486              	 .cfi_offset 7,-16
 4487              	 .cfi_offset 8,-12
 4488              	 .cfi_offset 9,-8
 4489              	 .cfi_offset 14,-4
 4490 0004 0446     	 mov r4,r0
 4491 0006 0E46     	 mov r6,r1
 4492 0008 9046     	 mov r8,r2
 4493 000a 1F46     	 mov r7,r3
3446:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	StreamBuffer_t *pxStream = pxSocket->u.xTCP.rxStream;
 4494              	 .loc 1 3446 0
 4495 000c 456F     	 ldr r5,[r0,#116]
 4496              	.LVL583:
3447:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	int32_t xResult = 0;
3448:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	#if( ipconfigUSE_CALLBACKS == 1 )
3449:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		BaseType_t bHasHandler = ipconfigIS_VALID_PROG_ADDRESS( pxSocket->u.xTCP.pxHandleReceive )  ? pdT
3450:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		const uint8_t *pucBuffer = NULL;
3451:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	#endif /* ipconfigUSE_CALLBACKS */
3452:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3453:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* int32_t uxStreamBufferAdd( pxBuffer, uxOffset, pucData, aCount )
3454:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( pucData != NULL ) copy data the the buffer
3455:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( pucData == NULL ) no copying, just advance rxHead
3456:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( uxOffset != 0 ) Just store data which has come out-of-order
3457:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( uxOffset == 0 ) Also advance rxHead */
3458:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( pxStream == NULL )
 4497              	 .loc 1 3458 0
 4498 000e 9DBB     	 cbnz r5,.L409
 4499              	.LVL584:
 4500              	.LBB325:
 4501              	.LBB326:
3376:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 4502              	 .loc 1 3376 0
 4503 0010 C36E     	 ldr r3,[r0,#108]
 4504              	.LVL585:
3378:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 4505              	 .loc 1 3378 0
 4506 0012 426E     	 ldr r2,[r0,#100]
 4507              	.LVL586:
 4508 0014 3AB9     	 cbnz r2,.L410
3380:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 4509              	 .loc 1 3380 0
 4510 0016 03EB8302 	 add r2,r3,r3,lsl#2
 4511 001a 9200     	 lsls r2,r2,#2
 4512 001c 3449     	 ldr r1,.L417
 4513              	.LVL587:
 4514 001e A1FB0212 	 umull r1,r2,r1,r2
 4515 0022 5209     	 lsrs r2,r2,#5
 4516 0024 4266     	 str r2,[r0,#100]
 4517              	.L410:
3383:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 4518              	 .loc 1 3383 0
 4519 0026 A26E     	 ldr r2,[r4,#104]
 4520 0028 3AB9     	 cbnz r2,.L411
3385:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 4521              	 .loc 1 3385 0
 4522 002a 03EB8302 	 add r2,r3,r3,lsl#2
 4523 002e 1201     	 lsls r2,r2,#4
 4524 0030 2F49     	 ldr r1,.L417
 4525 0032 A1FB0212 	 umull r1,r2,r1,r2
 4526 0036 5209     	 lsrs r2,r2,#5
 4527 0038 A266     	 str r2,[r4,#104]
 4528              	.L411:
3394:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 4529              	 .loc 1 3394 0
 4530 003a 0433     	 adds r3,r3,#4
 4531              	.LVL588:
3397:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 4532              	 .loc 1 3397 0
 4533 003c 23F00309 	 bic r9,r3,#3
 4534              	.LVL589:
3401:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 4535              	 .loc 1 3401 0
 4536 0040 09F11400 	 add r0,r9,#20
 4537              	.LVL590:
 4538 0044 FFF7FEFF 	 bl pvPortMalloc
 4539              	.LVL591:
3403:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 4540              	 .loc 1 3403 0
 4541 0048 0546     	 mov r5,r0
 4542 004a 70B9     	 cbnz r0,.L412
3406:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			vTCPStateChange( pxSocket, eCLOSE_WAIT );
 4543              	 .loc 1 3406 0
 4544 004c 94F84230 	 ldrb r3,[r4,#66]
 4545 0050 43F00803 	 orr r3,r3,#8
 4546 0054 84F84230 	 strb r3,[r4,#66]
3407:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 4547              	 .loc 1 3407 0
 4548 0058 2046     	 mov r0,r4
 4549              	.LVL592:
 4550 005a 0821     	 movs r1,#8
 4551 005c FFF7FEFF 	 bl vTCPStateChange
 4552              	.LVL593:
 4553              	.LBE326:
 4554              	.LBE325:
3459:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
3460:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pxStream = prvTCPCreateStream( pxSocket, pdTRUE );
3461:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( pxStream == NULL )
 4555              	 .loc 1 3461 0
 4556 0060 B5FA85F5 	 clz r5,r5
 4557              	.LVL594:
 4558 0064 6D09     	 lsrs r5,r5,#5
 4559 0066 6D42     	 negs r5,r5
 4560              	.LVL595:
 4561 0068 3FE0     	 b .L413
 4562              	.LVL596:
 4563              	.L412:
 4564              	.LBB328:
 4565              	.LBB327:
3412:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pxBuffer->LENGTH = ( size_t ) uxLength ;
 4566              	 .loc 1 3412 0
 4567 006a 0021     	 movs r1,#0
 4568 006c 1422     	 movs r2,#20
 4569 006e FFF7FEFF 	 bl memset
 4570              	.LVL597:
3413:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 4571              	 .loc 1 3413 0
 4572 0072 C5F81090 	 str r9,[r5,#16]
3423:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 4573              	 .loc 1 3423 0
 4574 0076 6567     	 str r5,[r4,#116]
 4575              	.LVL598:
 4576              	.L409:
 4577              	.LBE327:
 4578              	.LBE328:
3462:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
3463:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xResult = -1;
3464:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
3465:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
3466:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3467:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( xResult >= 0 )
3468:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
3469:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			#if( ipconfigUSE_CALLBACKS == 1 )
3470:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
3471:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( ( bHasHandler != pdFALSE ) && ( uxStreamBufferGetSize( pxStream ) == 0U ) && ( uxOffset == 
3472:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
3473:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Data can be passed directly to the user */
3474:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					pucBuffer = pcData;
3475:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3476:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					pcData = NULL;
3477:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
3478:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
3479:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			#endif /* ipconfigUSE_CALLBACKS */
3480:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3481:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xResult = ( int32_t ) uxStreamBufferAdd( pxStream, uxOffset, pcData, ( size_t ) ulByteCount );
 4579              	 .loc 1 3481 0
 4580 0078 2846     	 mov r0,r5
 4581 007a 3146     	 mov r1,r6
 4582 007c 4246     	 mov r2,r8
 4583 007e 3B46     	 mov r3,r7
 4584 0080 FFF7FEFF 	 bl uxStreamBufferAdd
 4585              	.LVL599:
 4586 0084 0546     	 mov r5,r0
 4587              	.LVL600:
3482:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3483:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			#if( ipconfigHAS_DEBUG_PRINTF != 0 )
3484:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
3485:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( xResult != ( int32_t ) ulByteCount )
3486:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
3487:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					FreeRTOS_debug_printf( ( "lTCPAddRxdata: at %u: %d/%u bytes (tail %u head %u space %u front %u
3488:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						( UBaseType_t ) uxOffset,
3489:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						( BaseType_t ) xResult,
3490:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						( UBaseType_t ) ulByteCount,
3491:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						( UBaseType_t ) pxStream->uxTail,
3492:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						( UBaseType_t ) pxStream->uxHead,
3493:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						( UBaseType_t ) uxStreamBufferFrontSpace( pxStream ),
3494:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						( UBaseType_t ) pxStream->uxFront ) );
3495:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
3496:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
3497:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			#endif /* ipconfigHAS_DEBUG_PRINTF */
3498:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3499:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( uxOffset == 0U )
 4588              	 .loc 1 3499 0
 4589 0086 86BB     	 cbnz r6,.L413
3500:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
3501:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* Data is being added to rxStream at the head (offs = 0) */
3502:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				#if( ipconfigUSE_CALLBACKS == 1 )
3503:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( bHasHandler != pdFALSE )
3504:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
3505:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* The socket owner has installed an OnReceive handler. Pass the
3506:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					Rx data, without copying from the rxStream, to the user. */
3507:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					for (;;)
3508:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
3509:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						uint8_t *ucReadPtr = NULL;
3510:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						uint32_t ulCount;
3511:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						if( pucBuffer != NULL )
3512:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						{
3513:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							ucReadPtr = ipPOINTER_CAST( uint8_t *, pucBuffer );
3514:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							ulCount = ulByteCount;
3515:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							pucBuffer = NULL;
3516:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						}
3517:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						else
3518:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						{
3519:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							ulCount = ( uint32_t ) uxStreamBufferGetPtr( pxStream, &( ucReadPtr ) );
3520:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						}
3521:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3522:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						if( ulCount == 0UL )
3523:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						{
3524:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							break;
3525:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						}
3526:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3527:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						( void ) pxSocket->u.xTCP.pxHandleReceive( pxSocket, ucReadPtr, ( size_t ) ulCount );
3528:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						( void ) uxStreamBufferGet( pxStream, 0UL, NULL, ( size_t ) ulCount, pdFALSE );
3529:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
3530:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				} else
3531:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				#endif /* ipconfigUSE_CALLBACKS */
3532:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
3533:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* See if running out of space. */
3534:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( pxSocket->u.xTCP.bits.bLowWater == pdFALSE_UNSIGNED )
 4590              	 .loc 1 3534 0
 4591 0088 94F84030 	 ldrb r3,[r4,#64]
 4592 008c 13F0800F 	 tst r3,#128
 4593 0090 1ED1     	 bne .L414
 4594              	.LBB329:
3535:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
3536:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						size_t uxFrontSpace = uxStreamBufferFrontSpace( pxSocket->u.xTCP.rxStream );
 4595              	 .loc 1 3536 0
 4596 0092 626F     	 ldr r2,[r4,#116]
 4597              	.LVL601:
 4598              	.LBB330:
 4599              	.LBB331:
 113:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxTail = pxBuffer->uxTail;
 4600              	 .loc 3 113 0
 4601 0094 D168     	 ldr r1,[r2,#12]
 4602              	.LVL602:
 114:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
 4603              	 .loc 3 114 0
 4604 0096 1368     	 ldr r3,[r2]
 4605              	.LVL603:
 4606              	.LBB332:
 4607              	.LBB333:
  68:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	if( uxCount >= pxBuffer->LENGTH )
 4608              	 .loc 3 68 0
 4609 0098 1269     	 ldr r2,[r2,#16]
 4610              	.LVL604:
 4611 009a 1344     	 add r3,r3,r2
 4612              	.LVL605:
 4613 009c 013B     	 subs r3,r3,#1
 4614 009e 5B1A     	 subs r3,r3,r1
 4615              	.LVL606:
  69:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	{
 4616              	 .loc 3 69 0
 4617 00a0 9A42     	 cmp r2,r3
  71:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	}
 4618              	 .loc 3 71 0
 4619 00a2 98BF     	 it ls
 4620 00a4 9B1A     	 subls r3,r3,r2
 4621              	.LVL607:
 4622              	.LBE333:
 4623              	.LBE332:
 4624              	.LBE331:
 4625              	.LBE330:
3537:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						if( uxFrontSpace <= pxSocket->u.xTCP.uxLittleSpace  )
 4626              	 .loc 1 3537 0
 4627 00a6 626E     	 ldr r2,[r4,#100]
 4628 00a8 9A42     	 cmp r2,r3
 4629 00aa 11D3     	 bcc .L414
3538:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						{
3539:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							pxSocket->u.xTCP.bits.bLowWater = pdTRUE;
 4630              	 .loc 1 3539 0
 4631 00ac 94F84030 	 ldrb r3,[r4,#64]
 4632              	.LVL608:
 4633 00b0 43F08003 	 orr r3,r3,#128
 4634 00b4 84F84030 	 strb r3,[r4,#64]
3540:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							pxSocket->u.xTCP.bits.bWinChange = pdTRUE;
 4635              	 .loc 1 3540 0
 4636 00b8 94F84130 	 ldrb r3,[r4,#65]
 4637 00bc 43F00103 	 orr r3,r3,#1
 4638 00c0 84F84130 	 strb r3,[r4,#65]
3541:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3542:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							/* bLowWater was reached, send the changed window size. */
3543:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							pxSocket->u.xTCP.usTimeout = 1U;
 4639              	 .loc 1 3543 0
 4640 00c4 0123     	 movs r3,#1
 4641 00c6 A4F84830 	 strh r3,[r4,#72]
3544:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							( void ) xSendEventToIPTask( eTCPTimerEvent );
 4642              	 .loc 1 3544 0
 4643 00ca 0620     	 movs r0,#6
 4644              	.LVL609:
 4645 00cc FFF7FEFF 	 bl xSendEventToIPTask
 4646              	.LVL610:
 4647              	.L414:
 4648              	.LBE329:
3545:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						}
3546:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
3547:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3548:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* New incoming data is available, wake up the user.   User's
3549:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					semaphores will be set just before the IP-task goes asleep. */
3550:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					pxSocket->xEventBits |= ( EventBits_t ) eSOCKET_RECEIVE;
 4649              	 .loc 1 3550 0
 4650 00d0 2368     	 ldr r3,[r4]
 4651 00d2 43F00102 	 orr r2,r3,#1
 4652 00d6 2260     	 str r2,[r4]
3551:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3552:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					#if ipconfigSUPPORT_SELECT_FUNCTION == 1
3553:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
3554:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						if( ( pxSocket->xSelectBits & ( EventBits_t ) eSELECT_READ ) != 0U )
 4653              	 .loc 1 3554 0
 4654 00d8 226B     	 ldr r2,[r4,#48]
 4655 00da 12F0010F 	 tst r2,#1
 4656 00de 04D0     	 beq .L413
3555:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						{
3556:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							pxSocket->xEventBits |= ( ( ( EventBits_t ) eSELECT_READ ) << SOCKET_EVENT_BIT_COUNT );
 4657              	 .loc 1 3556 0
 4658 00e0 43F48073 	 orr r3,r3,#256
 4659 00e4 43F00103 	 orr r3,r3,#1
 4660 00e8 2360     	 str r3,[r4]
 4661              	.L413:
3557:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						}
3558:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
3559:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					#endif
3560:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
3561:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
3562:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
3563:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3564:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		return xResult;
3565:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 4662              	 .loc 1 3565 0
 4663 00ea 2846     	 mov r0,r5
 4664 00ec BDE8F883 	 pop {r3,r4,r5,r6,r7,r8,r9,pc}
 4665              	.LVL611:
 4666              	.L418:
 4667              	 .align 2
 4668              	.L417:
 4669 00f0 1F85EB51 	 .word 1374389535
 4670              	 .cfi_endproc
 4671              	.LFE97:
 4673              	 .section .text.FreeRTOS_GetRemoteAddress,"ax",%progbits
 4674              	 .align 2
 4675              	 .global FreeRTOS_GetRemoteAddress
 4676              	 .thumb
 4677              	 .thumb_func
 4679              	FreeRTOS_GetRemoteAddress:
 4680              	.LFB98:
3566:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3567:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigUSE_TCP */
3568:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
3569:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3570:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigUSE_TCP == 1 )
3571:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3572:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* Function to get the remote address and IP port */
3573:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t FreeRTOS_GetRemoteAddress( ConstSocket_t xSocket, struct freertos_sockaddr *pxAddress )
3574:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 4681              	 .loc 1 3574 0
 4682              	 .cfi_startproc
 4683              	 
 4684              	 
 4685              	 
 4686              	.LVL612:
3575:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	const FreeRTOS_Socket_t *pxSocket = ( const FreeRTOS_Socket_t * ) xSocket;
3576:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t xResult;
3577:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3578:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 4687              	 .loc 1 3578 0
 4688 0000 90F82730 	 ldrb r3,[r0,#39]
 4689 0004 062B     	 cmp r3,#6
 4690 0006 14D1     	 bne .L421
3574:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	const FreeRTOS_Socket_t *pxSocket = ( const FreeRTOS_Socket_t * ) xSocket;
 4691              	 .loc 1 3574 0
 4692 0008 10B4     	 push {r4}
 4693              	.LCFI63:
 4694              	 .cfi_def_cfa_offset 4
 4695              	 .cfi_offset 4,-4
3579:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
3580:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xResult = -pdFREERTOS_ERRNO_EINVAL;
3581:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
3582:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else
3583:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
3584:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* BSD style sockets communicate IP and port addresses in network
3585:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			byte order.
3586:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			IP address of remote machine. */
3587:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pxAddress->sin_addr = FreeRTOS_htonl ( pxSocket->u.xTCP.ulRemoteIP );
 4696              	 .loc 1 3587 0
 4697 000a 846B     	 ldr r4,[r0,#56]
 4698 000c 2206     	 lsls r2,r4,#24
 4699 000e 42EA1462 	 orr r2,r2,r4,lsr#24
 4700 0012 04F47F43 	 and r3,r4,#65280
 4701 0016 42EA0322 	 orr r2,r2,r3,lsl#8
 4702 001a 04F47F03 	 and r3,r4,#16711680
 4703 001e 42EA1323 	 orr r3,r2,r3,lsr#8
 4704 0022 4B60     	 str r3,[r1,#4]
3588:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3589:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Port on remote machine. */
3590:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pxAddress->sin_port = FreeRTOS_htons ( pxSocket->u.xTCP.usRemotePort );
 4705              	 .loc 1 3590 0
 4706 0024 828F     	 ldrh r2,[r0,#60]
 4707 0026 130A     	 lsrs r3,r2,#8
 4708 0028 43EA0223 	 orr r3,r3,r2,lsl#8
 4709 002c 4B80     	 strh r3,[r1,#2]
 4710              	.LVL613:
3591:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3592:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xResult = ( BaseType_t ) sizeof( *pxAddress );
 4711              	 .loc 1 3592 0
 4712 002e 0820     	 movs r0,#8
 4713              	.LVL614:
 4714 0030 02E0     	 b .L420
 4715              	.LVL615:
 4716              	.L421:
 4717              	.LCFI64:
 4718              	 .cfi_def_cfa_offset 0
 4719              	 .cfi_restore 4
3580:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 4720              	 .loc 1 3580 0
 4721 0032 6FF01500 	 mvn r0,#21
 4722              	.LVL616:
 4723 0036 7047     	 bx lr
 4724              	.LVL617:
 4725              	.L420:
 4726              	.LCFI65:
 4727              	 .cfi_def_cfa_offset 4
 4728              	 .cfi_offset 4,-4
3593:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
3594:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3595:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		return xResult;
3596:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 4729              	 .loc 1 3596 0
 4730 0038 5DF8044B 	 ldr r4,[sp],#4
 4731              	.LCFI66:
 4732              	 .cfi_restore 4
 4733              	 .cfi_def_cfa_offset 0
 4734 003c 7047     	 bx lr
 4735              	 .cfi_endproc
 4736              	.LFE98:
 4738 003e 00BF     	 .section .text.FreeRTOS_maywrite,"ax",%progbits
 4739              	 .align 2
 4740              	 .global FreeRTOS_maywrite
 4741              	 .thumb
 4742              	 .thumb_func
 4744              	FreeRTOS_maywrite:
 4745              	.LFB99:
3597:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3598:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigUSE_TCP */
3599:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3600:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
3601:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3602:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigUSE_TCP == 1 )
3603:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3604:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* Returns the number of bytes that may be added to txStream */
3605:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t FreeRTOS_maywrite( ConstSocket_t xSocket )
3606:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 4746              	 .loc 1 3606 0
 4747              	 .cfi_startproc
 4748              	 
 4749              	 
 4750              	 
 4751              	.LVL618:
3607:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	const FreeRTOS_Socket_t *pxSocket = ( const FreeRTOS_Socket_t * ) xSocket;
3608:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t xResult;
3609:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3610:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 4752              	 .loc 1 3610 0
 4753 0000 90F82730 	 ldrb r3,[r0,#39]
 4754 0004 062B     	 cmp r3,#6
 4755 0006 19D1     	 bne .L429
3611:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
3612:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xResult = -pdFREERTOS_ERRNO_EINVAL;
3613:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
3614:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else if( pxSocket->u.xTCP.ucTCPState != ( uint8_t ) eESTABLISHED )
 4756              	 .loc 1 3614 0
 4757 0008 90F85330 	 ldrb r3,[r0,#83]
 4758 000c 052B     	 cmp r3,#5
 4759 000e 07D0     	 beq .L426
3615:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
3616:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( ( pxSocket->u.xTCP.ucTCPState < ( uint8_t ) eCONNECT_SYN ) || ( pxSocket->u.xTCP.ucTCPState 
 4760              	 .loc 1 3616 0
 4761 0010 981E     	 subs r0,r3,#2
 4762              	.LVL619:
 4763 0012 C0B2     	 uxtb r0,r0
 4764 0014 0328     	 cmp r0,#3
 4765 0016 4FF0FF30 	 mov r0,#-1
 4766 001a 98BF     	 it ls
 4767 001c 0020     	 movls r0,#0
 4768 001e 7047     	 bx lr
 4769              	.LVL620:
 4770              	.L426:
3617:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
3618:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xResult = -1;
3619:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
3620:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			else
3621:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
3622:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xResult = 0;
3623:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
3624:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
3625:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else if( pxSocket->u.xTCP.txStream == NULL )
 4771              	 .loc 1 3625 0
 4772 0020 826F     	 ldr r2,[r0,#120]
 4773 0022 0AB9     	 cbnz r2,.L427
3626:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
3627:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xResult = ( BaseType_t ) pxSocket->u.xTCP.uxTxStreamSize;
 4774              	 .loc 1 3627 0
 4775 0024 006F     	 ldr r0,[r0,#112]
 4776              	.LVL621:
 4777 0026 7047     	 bx lr
 4778              	.LVL622:
 4779              	.L427:
 4780              	.LBB334:
 4781              	.LBB335:
  99:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxTail = pxBuffer->uxTail;
 4782              	 .loc 3 99 0
 4783 0028 9068     	 ldr r0,[r2,#8]
 4784              	.LVL623:
 100:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
 4785              	 .loc 3 100 0
 4786 002a 1368     	 ldr r3,[r2]
 4787              	.LVL624:
 4788              	.LBB336:
 4789              	.LBB337:
  68:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	if( uxCount >= pxBuffer->LENGTH )
 4790              	 .loc 3 68 0
 4791 002c 1269     	 ldr r2,[r2,#16]
 4792              	.LVL625:
 4793 002e 1344     	 add r3,r3,r2
 4794              	.LVL626:
 4795 0030 013B     	 subs r3,r3,#1
 4796 0032 181A     	 subs r0,r3,r0
 4797              	.LVL627:
  69:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	{
 4798              	 .loc 3 69 0
 4799 0034 8242     	 cmp r2,r0
 4800 0036 03D8     	 bhi .L425
 4801              	.LVL628:
  71:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	}
 4802              	 .loc 3 71 0
 4803 0038 801A     	 subs r0,r0,r2
 4804              	.LVL629:
 4805 003a 7047     	 bx lr
 4806              	.LVL630:
 4807              	.L429:
 4808              	.LBE337:
 4809              	.LBE336:
 4810              	.LBE335:
 4811              	.LBE334:
3612:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 4812              	 .loc 1 3612 0
 4813 003c 6FF01500 	 mvn r0,#21
 4814              	.LVL631:
 4815              	.L425:
3628:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
3629:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else
3630:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
3631:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xResult = ( BaseType_t ) uxStreamBufferGetSpace( pxSocket->u.xTCP.txStream );
3632:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
3633:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3634:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		return xResult;
3635:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 4816              	 .loc 1 3635 0
 4817 0040 7047     	 bx lr
 4818              	 .cfi_endproc
 4819              	.LFE99:
 4821 0042 00BF     	 .section .text.FreeRTOS_tx_space,"ax",%progbits
 4822              	 .align 2
 4823              	 .global FreeRTOS_tx_space
 4824              	 .thumb
 4825              	 .thumb_func
 4827              	FreeRTOS_tx_space:
 4828              	.LFB100:
3636:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3637:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigUSE_TCP */
3638:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
3639:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3640:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigUSE_TCP == 1 )
3641:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3642:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t FreeRTOS_tx_space( ConstSocket_t xSocket )
3643:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 4829              	 .loc 1 3643 0
 4830              	 .cfi_startproc
 4831              	 
 4832              	 
 4833              	 
 4834              	.LVL632:
3644:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	const FreeRTOS_Socket_t *pxSocket = ( const FreeRTOS_Socket_t * ) xSocket;
3645:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t xReturn;
3646:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3647:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 4835              	 .loc 1 3647 0
 4836 0000 90F82730 	 ldrb r3,[r0,#39]
 4837 0004 062B     	 cmp r3,#6
 4838 0006 0DD1     	 bne .L434
3648:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
3649:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xReturn = -pdFREERTOS_ERRNO_EINVAL;
3650:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
3651:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else
3652:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
3653:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( pxSocket->u.xTCP.txStream != NULL )
 4839              	 .loc 1 3653 0
 4840 0008 826F     	 ldr r2,[r0,#120]
 4841 000a 4AB1     	 cbz r2,.L432
 4842              	.LVL633:
 4843              	.LBB338:
 4844              	.LBB339:
  99:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxTail = pxBuffer->uxTail;
 4845              	 .loc 3 99 0
 4846 000c 9068     	 ldr r0,[r2,#8]
 4847              	.LVL634:
 100:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
 4848              	 .loc 3 100 0
 4849 000e 1368     	 ldr r3,[r2]
 4850              	.LVL635:
 4851              	.LBB340:
 4852              	.LBB341:
  68:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	if( uxCount >= pxBuffer->LENGTH )
 4853              	 .loc 3 68 0
 4854 0010 1269     	 ldr r2,[r2,#16]
 4855              	.LVL636:
 4856 0012 1344     	 add r3,r3,r2
 4857              	.LVL637:
 4858 0014 013B     	 subs r3,r3,#1
 4859 0016 181A     	 subs r0,r3,r0
 4860              	.LVL638:
  69:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	{
 4861              	 .loc 3 69 0
 4862 0018 8242     	 cmp r2,r0
 4863 001a 05D8     	 bhi .L431
 4864              	.LVL639:
  71:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	}
 4865              	 .loc 3 71 0
 4866 001c 801A     	 subs r0,r0,r2
 4867              	.LVL640:
 4868              	.LBE341:
 4869              	.LBE340:
 4870              	.LBE339:
 4871              	.LBE338:
 4872 001e 7047     	 bx lr
 4873              	.LVL641:
 4874              	.L432:
3654:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
3655:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xReturn = ( BaseType_t ) uxStreamBufferGetSpace ( pxSocket->u.xTCP.txStream );
3656:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
3657:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			else
3658:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
3659:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xReturn = ( BaseType_t ) pxSocket->u.xTCP.uxTxStreamSize;
 4875              	 .loc 1 3659 0
 4876 0020 006F     	 ldr r0,[r0,#112]
 4877              	.LVL642:
 4878 0022 7047     	 bx lr
 4879              	.LVL643:
 4880              	.L434:
3649:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 4881              	 .loc 1 3649 0
 4882 0024 6FF01500 	 mvn r0,#21
 4883              	.LVL644:
 4884              	.L431:
3660:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
3661:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
3662:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3663:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		return xReturn;
3664:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 4885              	 .loc 1 3664 0
 4886 0028 7047     	 bx lr
 4887              	 .cfi_endproc
 4888              	.LFE100:
 4890 002a 00BF     	 .section .text.FreeRTOS_tx_size,"ax",%progbits
 4891              	 .align 2
 4892              	 .global FreeRTOS_tx_size
 4893              	 .thumb
 4894              	 .thumb_func
 4896              	FreeRTOS_tx_size:
 4897              	.LFB101:
3665:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3666:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigUSE_TCP */
3667:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
3668:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3669:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigUSE_TCP == 1 )
3670:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3671:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t FreeRTOS_tx_size( ConstSocket_t xSocket )
3672:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 4898              	 .loc 1 3672 0
 4899              	 .cfi_startproc
 4900              	 
 4901              	 
 4902              	 
 4903              	.LVL645:
3673:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	const FreeRTOS_Socket_t *pxSocket = ( const FreeRTOS_Socket_t * ) xSocket;
3674:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t xReturn;
3675:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3676:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 4904              	 .loc 1 3676 0
 4905 0000 90F82730 	 ldrb r3,[r0,#39]
 4906 0004 062B     	 cmp r3,#6
 4907 0006 0AD1     	 bne .L438
3677:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
3678:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xReturn = -pdFREERTOS_ERRNO_EINVAL;
3679:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
3680:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else
3681:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
3682:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( pxSocket->u.xTCP.txStream != NULL )
 4908              	 .loc 1 3682 0
 4909 0008 836F     	 ldr r3,[r0,#120]
 4910 000a 5BB1     	 cbz r3,.L439
 4911              	.LVL646:
 4912              	.LBB342:
 4913              	.LBB343:
 125:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxTail = pxBuffer->uxTail;
 4914              	 .loc 3 125 0
 4915 000c 9868     	 ldr r0,[r3,#8]
 4916              	.LVL647:
 126:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
 4917              	 .loc 3 126 0
 4918 000e 1A68     	 ldr r2,[r3]
 4919              	.LVL648:
 4920              	.LBB344:
 4921              	.LBB345:
  84:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	if ( uxCount >= pxBuffer->LENGTH )
 4922              	 .loc 3 84 0
 4923 0010 1B69     	 ldr r3,[r3,#16]
 4924              	.LVL649:
 4925 0012 1844     	 add r0,r0,r3
 4926              	.LVL650:
 4927 0014 801A     	 subs r0,r0,r2
 4928              	.LVL651:
  85:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	{
 4929              	 .loc 3 85 0
 4930 0016 8342     	 cmp r3,r0
 4931 0018 05D8     	 bhi .L436
 4932              	.LVL652:
  87:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	}
 4933              	 .loc 3 87 0
 4934 001a C01A     	 subs r0,r0,r3
 4935              	.LVL653:
 4936              	.LBE345:
 4937              	.LBE344:
 4938              	.LBE343:
 4939              	.LBE342:
 4940 001c 7047     	 bx lr
 4941              	.LVL654:
 4942              	.L438:
3678:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 4943              	 .loc 1 3678 0
 4944 001e 6FF01500 	 mvn r0,#21
 4945              	.LVL655:
 4946 0022 7047     	 bx lr
 4947              	.LVL656:
 4948              	.L439:
3683:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
3684:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xReturn = ( BaseType_t ) uxStreamBufferGetSize ( pxSocket->u.xTCP.txStream );
3685:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
3686:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			else
3687:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
3688:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xReturn = 0;
 4949              	 .loc 1 3688 0
 4950 0024 0020     	 movs r0,#0
 4951              	.LVL657:
 4952              	.L436:
3689:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
3690:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
3691:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3692:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		return xReturn;
3693:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 4953              	 .loc 1 3693 0
 4954 0026 7047     	 bx lr
 4955              	 .cfi_endproc
 4956              	.LFE101:
 4958              	 .section .text.FreeRTOS_setsockopt,"ax",%progbits
 4959              	 .align 2
 4960              	 .global FreeRTOS_setsockopt
 4961              	 .thumb
 4962              	 .thumb_func
 4964              	FreeRTOS_setsockopt:
 4965              	.LFB71:
1527:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /* The standard Berkeley function returns 0 for success. */
 4966              	 .loc 1 1527 0
 4967              	 .cfi_startproc
 4968              	 
 4969              	 
 4970              	.LVL658:
1539:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 4971              	 .loc 1 1539 0
 4972 0000 411E     	 subs r1,r0,#1
 4973              	.LVL659:
 4974 0002 11F1030F 	 cmn r1,#3
 4975 0006 00F22281 	 bhi .L467
1527:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /* The standard Berkeley function returns 0 for success. */
 4976              	 .loc 1 1527 0
 4977 000a 10B5     	 push {r4,lr}
 4978              	.LCFI67:
 4979              	 .cfi_def_cfa_offset 8
 4980              	 .cfi_offset 4,-8
 4981              	 .cfi_offset 14,-4
 4982 000c 0446     	 mov r4,r0
1545:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 4983              	 .loc 1 1545 0
 4984 000e 122A     	 cmp r2,#18
 4985 0010 00F22181 	 bhi .L468
 4986 0014 DFE812F0 	 tbh [pc,r2,lsl#1]
 4987              	.L443:
 4988 0018 1300     	 .2byte (.L442-.L443)/2
 4989 001a 1700     	 .2byte (.L444-.L443)/2
 4990 001c 3000     	 .2byte (.L445-.L443)/2
 4991 001e 1F01     	 .2byte (.L468-.L443)/2
 4992 0020 5400     	 .2byte (.L446-.L443)/2
 4993 0022 5400     	 .2byte (.L446-.L443)/2
 4994 0024 1F01     	 .2byte (.L468-.L443)/2
 4995 0026 1F01     	 .2byte (.L468-.L443)/2
 4996 0028 1F01     	 .2byte (.L468-.L443)/2
 4997 002a 1F01     	 .2byte (.L468-.L443)/2
 4998 002c 1F01     	 .2byte (.L468-.L443)/2
 4999 002e A400     	 .2byte (.L447-.L443)/2
 5000 0030 BA00     	 .2byte (.L448-.L443)/2
 5001 0032 7300     	 .2byte (.L449-.L443)/2
 5002 0034 D000     	 .2byte (.L450-.L443)/2
 5003 0036 FA00     	 .2byte (.L451-.L443)/2
 5004 0038 1F01     	 .2byte (.L468-.L443)/2
 5005 003a 1F01     	 .2byte (.L468-.L443)/2
 5006 003c 4100     	 .2byte (.L452-.L443)/2
 5007              	 .p2align 1
 5008              	.L442:
1549:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xReturn = 0;
 5009              	 .loc 1 1549 0
 5010 003e 1B68     	 ldr r3,[r3]
 5011              	.LVL660:
 5012 0040 C361     	 str r3,[r0,#28]
 5013              	.LVL661:
1550:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			break;
 5014              	 .loc 1 1550 0
 5015 0042 0023     	 movs r3,#0
1551:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 5016              	 .loc 1 1551 0
 5017 0044 44E1     	 b .L488
 5018              	.LVL662:
 5019              	.L444:
1554:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_UDP )
 5020              	 .loc 1 1554 0
 5021 0046 1A68     	 ldr r2,[r3]
 5022              	.LVL663:
 5023 0048 0262     	 str r2,[r0,#32]
1555:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 5024              	 .loc 1 1555 0
 5025 004a 90F82730 	 ldrb r3,[r0,#39]
 5026              	.LVL664:
 5027 004e 112B     	 cmp r3,#17
 5028 0050 07D1     	 bne .L453
1561:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 5029              	 .loc 1 1561 0
 5030 0052 41F28833 	 movw r3,#5000
 5031 0056 9A42     	 cmp r2,r3
 5032 0058 40F20081 	 bls .L469
1563:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 5033              	 .loc 1 1563 0
 5034 005c 0362     	 str r3,[r0,#32]
1579:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			break;
 5035              	 .loc 1 1579 0
 5036 005e 0023     	 movs r3,#0
 5037 0060 36E1     	 b .L488
 5038              	.L453:
1566:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 5039              	 .loc 1 1566 0
 5040 0062 FF2B     	 cmp r3,#255
 5041 0064 40F0FC80 	 bne .L470
1568:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 5042              	 .loc 1 1568 0
 5043 0068 41F28833 	 movw r3,#5000
 5044 006c 9A42     	 cmp r2,r3
 5045 006e 40F2F980 	 bls .L471
1570:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 5046              	 .loc 1 1570 0
 5047 0072 0362     	 str r3,[r0,#32]
1579:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			break;
 5048              	 .loc 1 1579 0
 5049 0074 0023     	 movs r3,#0
 5050 0076 2BE1     	 b .L488
 5051              	.LVL665:
 5052              	.L445:
1596:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 5053              	 .loc 1 1596 0
 5054 0078 3BB9     	 cbnz r3,.L454
1598:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 5055              	 .loc 1 1598 0
 5056 007a 90F82630 	 ldrb r3,[r0,#38]
 5057              	.LVL666:
 5058 007e 23F00203 	 bic r3,r3,#2
 5059 0082 80F82630 	 strb r3,[r0,#38]
1604:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			break;
 5060              	 .loc 1 1604 0
 5061 0086 0023     	 movs r3,#0
 5062 0088 22E1     	 b .L488
 5063              	.LVL667:
 5064              	.L454:
1602:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 5065              	 .loc 1 1602 0
 5066 008a 90F82630 	 ldrb r3,[r0,#38]
 5067              	.LVL668:
 5068 008e 43F00203 	 orr r3,r3,#2
 5069 0092 80F82630 	 strb r3,[r0,#38]
1604:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			break;
 5070              	 .loc 1 1604 0
 5071 0096 0023     	 movs r3,#0
 5072 0098 1AE1     	 b .L488
 5073              	.LVL669:
 5074              	.L452:
 5075              	.LBB360:
1699:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 5076              	 .loc 1 1699 0
 5077 009a 90F82720 	 ldrb r2,[r0,#39]
 5078              	.LVL670:
 5079 009e 062A     	 cmp r2,#6
 5080 00a0 40F0E280 	 bne .L472
1705:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						( pxLowHighWater->uxEnoughSpace > pxSocket->u.xTCP.uxRxStreamSize ) )
 5081              	 .loc 1 1705 0
 5082 00a4 1968     	 ldr r1,[r3]
 5083 00a6 5A68     	 ldr r2,[r3,#4]
 5084 00a8 9142     	 cmp r1,r2
 5085 00aa 80F0E080 	 bcs .L473
1705:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						( pxLowHighWater->uxEnoughSpace > pxSocket->u.xTCP.uxRxStreamSize ) )
 5086              	 .loc 1 1705 0 is_stmt 0 discriminator 1
 5087 00ae C06E     	 ldr r0,[r0,#108]
 5088              	.LVL671:
 5089 00b0 8242     	 cmp r2,r0
 5090 00b2 00F2DF80 	 bhi .L474
1713:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Send a GO when buffer space grows above 'uxEnoughSpace' bytes. */
 5091              	 .loc 1 1713 0 is_stmt 1
 5092 00b6 6166     	 str r1,[r4,#100]
1715:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					xReturn = 0;
 5093              	 .loc 1 1715 0
 5094 00b8 5B68     	 ldr r3,[r3,#4]
 5095              	.LVL672:
 5096 00ba A366     	 str r3,[r4,#104]
 5097              	.LVL673:
1716:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 5098              	 .loc 1 1716 0
 5099 00bc 0023     	 movs r3,#0
 5100              	.LBE360:
1718:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 5101              	 .loc 1 1718 0
 5102 00be 07E1     	 b .L488
 5103              	.LVL674:
 5104              	.L446:
 5105              	.LBB361:
 5106              	.LBB362:
1490:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 5107              	 .loc 1 1490 0
 5108 00c0 90F82710 	 ldrb r1,[r0,#39]
 5109 00c4 0629     	 cmp r1,#6
 5110 00c6 40F0D880 	 bne .L475
1496:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			( ( lOptionName == FREERTOS_SO_RCVBUF ) && ( pxSocket->u.xTCP.rxStream != NULL ) ) )
 5111              	 .loc 1 1496 0
 5112 00ca 042A     	 cmp r2,#4
 5113 00cc 40F0FB80 	 bne .L455
 5114 00d0 826F     	 ldr r2,[r0,#120]
 5115              	.LVL675:
 5116 00d2 2AB1     	 cbz r2,.L489
 5117 00d4 D4E0     	 b .L476
 5118              	.LVL676:
 5119              	.L465:
1497:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 5120              	 .loc 1 1497 0
 5121 00d6 626F     	 ldr r2,[r4,#116]
 5122              	.LVL677:
 5123 00d8 002A     	 cmp r2,#0
 5124 00da 00F0F780 	 beq .L490
 5125 00de D2E0     	 b .L477
 5126              	.L489:
 5127              	.LVL678:
1510:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pxSocket->u.xTCP.uxTxStreamSize = ulNewValue;
 5128              	 .loc 1 1510 0
 5129 00e0 B0F84C20 	 ldrh r2,[r0,#76]
 5130              	.LVL679:
 5131 00e4 511E     	 subs r1,r2,#1
 5132              	.LBB363:
 5133              	.LBB364:
 219:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	static portINLINE uint32_t FreeRTOS_round_down (uint32_t a, uint32_t d) { return d * ( a / d ); }
 5134              	 .loc 4 219 0
 5135 00e6 1B68     	 ldr r3,[r3]
 5136              	.LVL680:
 5137 00e8 0B44     	 add r3,r3,r1
 5138              	.LVL681:
 5139 00ea B3FBF2F3 	 udiv r3,r3,r2
 5140 00ee 02FB03F2 	 mul r2,r2,r3
 5141              	.LVL682:
 5142              	.LBE364:
 5143              	.LBE363:
1511:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 5144              	 .loc 1 1511 0
 5145 00f2 0267     	 str r2,[r0,#112]
 5146              	.LVL683:
1517:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 5147              	 .loc 1 1517 0
 5148 00f4 0023     	 movs r3,#0
 5149 00f6 EBE0     	 b .L488
 5150              	.LVL684:
 5151              	.L464:
1515:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 5152              	 .loc 1 1515 0
 5153 00f8 E366     	 str r3,[r4,#108]
1517:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 5154              	 .loc 1 1517 0
 5155 00fa 0023     	 movs r3,#0
 5156              	.LVL685:
 5157 00fc E8E0     	 b .L488
 5158              	.LVL686:
 5159              	.L449:
 5160              	.LBE362:
 5161              	.LBE361:
 5162              	.LBB367:
1731:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 5163              	 .loc 1 1731 0
 5164 00fe 90F82720 	 ldrb r2,[r0,#39]
 5165              	.LVL687:
 5166 0102 062A     	 cmp r2,#6
 5167 0104 40F0C280 	 bne .L478
1737:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 5168              	 .loc 1 1737 0
 5169 0108 826F     	 ldr r2,[r0,#120]
 5170 010a 002A     	 cmp r2,#0
 5171 010c 40F0C180 	 bne .L479
1737:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 5172              	 .loc 1 1737 0 is_stmt 0 discriminator 1
 5173 0110 426F     	 ldr r2,[r0,#116]
 5174 0112 002A     	 cmp r2,#0
 5175 0114 40F0C080 	 bne .L480
 5176              	.LVL688:
 5177              	.LBB368:
 5178              	.LBB369:
1510:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			pxSocket->u.xTCP.uxTxStreamSize = ulNewValue;
 5179              	 .loc 1 1510 0 is_stmt 1
 5180 0118 B0F84C20 	 ldrh r2,[r0,#76]
 5181              	.LVL689:
 5182 011c 501E     	 subs r0,r2,#1
 5183              	.LVL690:
 5184              	.LBB370:
 5185              	.LBB371:
 219:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	static portINLINE uint32_t FreeRTOS_round_down (uint32_t a, uint32_t d) { return d * ( a / d ); }
 5186              	 .loc 4 219 0
 5187 011e 1968     	 ldr r1,[r3]
 5188 0120 0144     	 add r1,r1,r0
 5189 0122 B1FBF2F1 	 udiv r1,r1,r2
 5190 0126 02FB01F2 	 mul r2,r2,r1
 5191              	.LVL691:
 5192              	.LBE371:
 5193              	.LBE370:
1511:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 5194              	 .loc 1 1511 0
 5195 012a 2267     	 str r2,[r4,#112]
 5196              	.LVL692:
 5197              	.LBE369:
 5198              	.LBE368:
 5199              	.LBB372:
 5200              	.LBB373:
1505:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 5201              	 .loc 1 1505 0
 5202 012c 9A68     	 ldr r2,[r3,#8]
 5203              	.LVL693:
1515:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 5204              	 .loc 1 1515 0
 5205 012e E266     	 str r2,[r4,#108]
 5206              	.LVL694:
 5207              	.LBE373:
 5208              	.LBE372:
1759:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						pxSocket->u.xTCP.uxTxWinSize = ( uint32_t )pxProps->lTxWinSize;	/* Fixed value: size of the T
 5209              	 .loc 1 1759 0
 5210 0130 DA68     	 ldr r2,[r3,#12]
 5211              	.LVL695:
 5212 0132 C4F8D020 	 str r2,[r4,#208]
1760:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
 5213              	 .loc 1 1760 0
 5214 0136 5B68     	 ldr r3,[r3,#4]
 5215              	.LVL696:
 5216 0138 C4F8D430 	 str r3,[r4,#212]
1771:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 5217              	 .loc 1 1771 0
 5218 013c 94F8D810 	 ldrb r1,[r4,#216]
 5219 0140 11F0010F 	 tst r1,#1
 5220 0144 00F0AB80 	 beq .L481
1773:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						pxSocket->u.xTCP.xTCPWindow.xSize.ulTxWindowLength = pxSocket->u.xTCP.uxTxWinSize * pxSocket-
 5221              	 .loc 1 1773 0
 5222 0148 B4F84C10 	 ldrh r1,[r4,#76]
 5223 014c 02FB01F2 	 mul r2,r2,r1
 5224 0150 C4F8DC20 	 str r2,[r4,#220]
1774:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
 5225              	 .loc 1 1774 0
 5226 0154 03FB01F3 	 mul r3,r3,r1
 5227 0158 C4F8E030 	 str r3,[r4,#224]
 5228              	.LBE367:
1778:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				break;
 5229              	 .loc 1 1778 0
 5230 015c 0023     	 movs r3,#0
 5231 015e B7E0     	 b .L488
 5232              	.LVL697:
 5233              	.L447:
1783:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 5234              	 .loc 1 1783 0
 5235 0160 90F82720 	 ldrb r2,[r0,#39]
 5236              	.LVL698:
 5237 0164 062A     	 cmp r2,#6
 5238 0166 40F09C80 	 bne .L482
1787:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 5239              	 .loc 1 1787 0
 5240 016a 1B68     	 ldr r3,[r3]
 5241              	.LVL699:
 5242 016c 3BB1     	 cbz r3,.L458
1789:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
 5243              	 .loc 1 1789 0
 5244 016e 90F84030 	 ldrb r3,[r0,#64]
 5245 0172 43F00803 	 orr r3,r3,#8
 5246 0176 80F84030 	 strb r3,[r0,#64]
1796:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				break;
 5247              	 .loc 1 1796 0
 5248 017a 0023     	 movs r3,#0
 5249 017c A8E0     	 b .L488
 5250              	.L458:
1793:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
 5251              	 .loc 1 1793 0
 5252 017e 90F84020 	 ldrb r2,[r0,#64]
 5253 0182 6FF3C302 	 bfc r2,#3,#1
 5254 0186 80F84020 	 strb r2,[r0,#64]
 5255 018a A1E0     	 b .L488
 5256              	.LVL700:
 5257              	.L448:
1801:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 5258              	 .loc 1 1801 0
 5259 018c 90F82720 	 ldrb r2,[r0,#39]
 5260              	.LVL701:
 5261 0190 062A     	 cmp r2,#6
 5262 0192 40F08980 	 bne .L483
1806:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 5263              	 .loc 1 1806 0
 5264 0196 1B68     	 ldr r3,[r3]
 5265              	.LVL702:
 5266 0198 3BB1     	 cbz r3,.L459
1808:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
 5267              	 .loc 1 1808 0
 5268 019a 90F84030 	 ldrb r3,[r0,#64]
 5269 019e 43F01003 	 orr r3,r3,#16
 5270 01a2 80F84030 	 strb r3,[r0,#64]
1815:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				break;
 5271              	 .loc 1 1815 0
 5272 01a6 0023     	 movs r3,#0
 5273 01a8 92E0     	 b .L488
 5274              	.L459:
1812:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
 5275              	 .loc 1 1812 0
 5276 01aa 90F84020 	 ldrb r2,[r0,#64]
 5277 01ae 6FF30412 	 bfc r2,#4,#1
 5278 01b2 80F84020 	 strb r2,[r0,#64]
 5279 01b6 8BE0     	 b .L488
 5280              	.LVL703:
 5281              	.L450:
1820:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 5282              	 .loc 1 1820 0
 5283 01b8 90F82720 	 ldrb r2,[r0,#39]
 5284              	.LVL704:
 5285 01bc 062A     	 cmp r2,#6
 5286 01be 76D1     	 bne .L484
1825:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 5287              	 .loc 1 1825 0
 5288 01c0 1B68     	 ldr r3,[r3]
 5289              	.LVL705:
 5290 01c2 33B1     	 cbz r3,.L460
1827:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
 5291              	 .loc 1 1827 0
 5292 01c4 90F8D830 	 ldrb r3,[r0,#216]
 5293 01c8 43F00203 	 orr r3,r3,#2
 5294 01cc 80F8D830 	 strb r3,[r0,#216]
 5295 01d0 05E0     	 b .L461
 5296              	.L460:
1831:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
 5297              	 .loc 1 1831 0
 5298 01d2 90F8D830 	 ldrb r3,[r0,#216]
 5299 01d6 6FF34103 	 bfc r3,#1,#1
 5300 01da 80F8D830 	 strb r3,[r0,#216]
 5301              	.L461:
1834:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						( pxSocket->u.xTCP.ucTCPState >= ( uint8_t ) eESTABLISHED ) &&
 5302              	 .loc 1 1834 0
 5303 01de 94F8D830 	 ldrb r3,[r4,#216]
 5304 01e2 13F0020F 	 tst r3,#2
 5305 01e6 65D1     	 bne .L485
1834:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						( pxSocket->u.xTCP.ucTCPState >= ( uint8_t ) eESTABLISHED ) &&
 5306              	 .loc 1 1834 0 is_stmt 0 discriminator 1
 5307 01e8 94F85330 	 ldrb r3,[r4,#83]
 5308 01ec 042B     	 cmp r3,#4
 5309 01ee 63D9     	 bls .L486
1836:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 5310              	 .loc 1 1836 0 is_stmt 1
 5311 01f0 2046     	 mov r0,r4
 5312              	.LVL706:
 5313 01f2 FFF7FEFF 	 bl FreeRTOS_tx_size
 5314              	.LVL707:
1835:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						( FreeRTOS_outstanding( pxSocket ) != 0 ) )
 5315              	 .loc 1 1835 0
 5316 01f6 0346     	 mov r3,r0
 5317 01f8 0028     	 cmp r0,#0
 5318 01fa 69D0     	 beq .L488
1838:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						( void ) xSendEventToIPTask( eTCPTimerEvent );
 5319              	 .loc 1 1838 0
 5320 01fc 0123     	 movs r3,#1
 5321 01fe A4F84830 	 strh r3,[r4,#72]
1839:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
 5322              	 .loc 1 1839 0
 5323 0202 0620     	 movs r0,#6
 5324 0204 FFF7FEFF 	 bl xSendEventToIPTask
 5325              	.LVL708:
1842:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				break;
 5326              	 .loc 1 1842 0
 5327 0208 0023     	 movs r3,#0
 5328 020a 61E0     	 b .L488
 5329              	.LVL709:
 5330              	.L451:
1847:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 5331              	 .loc 1 1847 0
 5332 020c 90F82720 	 ldrb r2,[r0,#39]
 5333              	.LVL710:
 5334 0210 062A     	 cmp r2,#6
 5335 0212 53D1     	 bne .L487
1851:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 5336              	 .loc 1 1851 0
 5337 0214 1B68     	 ldr r3,[r3]
 5338              	.LVL711:
 5339 0216 33B1     	 cbz r3,.L462
1853:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
 5340              	 .loc 1 1853 0
 5341 0218 90F84230 	 ldrb r3,[r0,#66]
 5342 021c 43F00403 	 orr r3,r3,#4
 5343 0220 80F84230 	 strb r3,[r0,#66]
 5344              	.LVL712:
 5345 0224 05E0     	 b .L463
 5346              	.LVL713:
 5347              	.L462:
1857:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
 5348              	 .loc 1 1857 0
 5349 0226 90F84230 	 ldrb r3,[r0,#66]
 5350 022a 6FF38203 	 bfc r3,#2,#1
 5351 022e 80F84230 	 strb r3,[r0,#66]
 5352              	.LVL714:
 5353              	.L463:
1860:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					pxSocket->u.xTCP.usTimeout = 1U; /* to set/clear bRxStopped */
 5354              	 .loc 1 1860 0
 5355 0232 94F84130 	 ldrb r3,[r4,#65]
 5356 0236 43F00103 	 orr r3,r3,#1
 5357 023a 84F84130 	 strb r3,[r4,#65]
1861:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					( void ) xSendEventToIPTask( eTCPTimerEvent );
 5358              	 .loc 1 1861 0
 5359 023e 0123     	 movs r3,#1
 5360 0240 A4F84830 	 strh r3,[r4,#72]
1862:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 5361              	 .loc 1 1862 0
 5362 0244 0620     	 movs r0,#6
 5363              	.LVL715:
 5364 0246 FFF7FEFF 	 bl xSendEventToIPTask
 5365              	.LVL716:
1864:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				break;
 5366              	 .loc 1 1864 0
 5367 024a 0023     	 movs r3,#0
1865:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 5368              	 .loc 1 1865 0
 5369 024c 40E0     	 b .L488
 5370              	.LVL717:
 5371              	.L467:
 5372              	.LCFI68:
 5373              	 .cfi_def_cfa_offset 0
 5374              	 .cfi_restore 4
 5375              	 .cfi_restore 14
1542:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 5376              	 .loc 1 1542 0
 5377 024e 6FF01503 	 mvn r3,#21
 5378              	.LVL718:
1876:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 5379              	 .loc 1 1876 0
 5380 0252 1846     	 mov r0,r3
 5381              	.LVL719:
 5382 0254 7047     	 bx lr
 5383              	.LVL720:
 5384              	.L468:
 5385              	.LCFI69:
 5386              	 .cfi_def_cfa_offset 8
 5387              	 .cfi_offset 4,-8
 5388              	 .cfi_offset 14,-4
1871:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			break;
 5389              	 .loc 1 1871 0
 5390 0256 6FF06C03 	 mvn r3,#108
 5391              	.LVL721:
 5392 025a 39E0     	 b .L488
 5393              	.LVL722:
 5394              	.L469:
1579:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			break;
 5395              	 .loc 1 1579 0
 5396 025c 0023     	 movs r3,#0
 5397 025e 37E0     	 b .L488
 5398              	.L470:
 5399 0260 0023     	 movs r3,#0
 5400 0262 35E0     	 b .L488
 5401              	.L471:
 5402 0264 0023     	 movs r3,#0
 5403 0266 33E0     	 b .L488
 5404              	.LVL723:
 5405              	.L472:
1529:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** FreeRTOS_Socket_t *pxSocket;
 5406              	 .loc 1 1529 0
 5407 0268 6FF01503 	 mvn r3,#21
 5408              	.LVL724:
 5409 026c 30E0     	 b .L488
 5410              	.LVL725:
 5411              	.L473:
 5412 026e 6FF01503 	 mvn r3,#21
 5413              	.LVL726:
 5414 0272 2DE0     	 b .L488
 5415              	.LVL727:
 5416              	.L474:
 5417 0274 6FF01503 	 mvn r3,#21
 5418              	.LVL728:
 5419 0278 2AE0     	 b .L488
 5420              	.LVL729:
 5421              	.L475:
 5422              	.LBB374:
 5423              	.LBB365:
1494:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 5424              	 .loc 1 1494 0
 5425 027a 6FF01503 	 mvn r3,#21
 5426              	.LVL730:
 5427 027e 27E0     	 b .L488
 5428              	.LVL731:
 5429              	.L476:
1501:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 5430              	 .loc 1 1501 0
 5431 0280 6FF01503 	 mvn r3,#21
 5432              	.LVL732:
 5433 0284 24E0     	 b .L488
 5434              	.LVL733:
 5435              	.L477:
 5436 0286 6FF01503 	 mvn r3,#21
 5437              	.LVL734:
 5438 028a 21E0     	 b .L488
 5439              	.LVL735:
 5440              	.L478:
 5441              	.LBE365:
 5442              	.LBE374:
1529:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** FreeRTOS_Socket_t *pxSocket;
 5443              	 .loc 1 1529 0
 5444 028c 6FF01503 	 mvn r3,#21
 5445              	.LVL736:
 5446 0290 1EE0     	 b .L488
 5447              	.LVL737:
 5448              	.L479:
 5449 0292 6FF01503 	 mvn r3,#21
 5450              	.LVL738:
 5451 0296 1BE0     	 b .L488
 5452              	.LVL739:
 5453              	.L480:
 5454 0298 6FF01503 	 mvn r3,#21
 5455              	.LVL740:
 5456 029c 18E0     	 b .L488
 5457              	.LVL741:
 5458              	.L481:
1778:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				break;
 5459              	 .loc 1 1778 0
 5460 029e 0023     	 movs r3,#0
 5461 02a0 16E0     	 b .L488
 5462              	.LVL742:
 5463              	.L482:
1529:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** FreeRTOS_Socket_t *pxSocket;
 5464              	 .loc 1 1529 0
 5465 02a2 6FF01503 	 mvn r3,#21
 5466              	.LVL743:
 5467 02a6 13E0     	 b .L488
 5468              	.LVL744:
 5469              	.L483:
 5470 02a8 6FF01503 	 mvn r3,#21
 5471              	.LVL745:
 5472 02ac 10E0     	 b .L488
 5473              	.LVL746:
 5474              	.L484:
 5475 02ae 6FF01503 	 mvn r3,#21
 5476              	.LVL747:
 5477 02b2 0DE0     	 b .L488
 5478              	.L485:
1842:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				break;
 5479              	 .loc 1 1842 0
 5480 02b4 0023     	 movs r3,#0
 5481 02b6 0BE0     	 b .L488
 5482              	.L486:
 5483 02b8 0023     	 movs r3,#0
 5484 02ba 09E0     	 b .L488
 5485              	.LVL748:
 5486              	.L487:
1529:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** FreeRTOS_Socket_t *pxSocket;
 5487              	 .loc 1 1529 0
 5488 02bc 6FF01503 	 mvn r3,#21
 5489              	.LVL749:
 5490 02c0 06E0     	 b .L488
 5491              	.LVL750:
 5492              	.L491:
 5493              	.LBB375:
 5494              	.LBB366:
1505:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 5495              	 .loc 1 1505 0
 5496 02c2 1B68     	 ldr r3,[r3]
 5497              	.LVL751:
 5498 02c4 18E7     	 b .L464
 5499              	.LVL752:
 5500              	.L455:
1496:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			( ( lOptionName == FREERTOS_SO_RCVBUF ) && ( pxSocket->u.xTCP.rxStream != NULL ) ) )
 5501              	 .loc 1 1496 0
 5502 02c6 052A     	 cmp r2,#5
 5503 02c8 FBD1     	 bne .L491
 5504 02ca 04E7     	 b .L465
 5505              	.LVL753:
 5506              	.L490:
1505:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 5507              	 .loc 1 1505 0
 5508 02cc 1B68     	 ldr r3,[r3]
 5509              	.LVL754:
 5510 02ce 13E7     	 b .L464
 5511              	.LVL755:
 5512              	.L488:
 5513              	.LBE366:
 5514              	.LBE375:
1876:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 5515              	 .loc 1 1876 0
 5516 02d0 1846     	 mov r0,r3
 5517 02d2 10BD     	 pop {r4,pc}
 5518              	 .cfi_endproc
 5519              	.LFE71:
 5521              	 .section .text.FreeRTOS_issocketconnected,"ax",%progbits
 5522              	 .align 2
 5523              	 .global FreeRTOS_issocketconnected
 5524              	 .thumb
 5525              	 .thumb_func
 5527              	FreeRTOS_issocketconnected:
 5528              	.LFB102:
3694:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3695:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigUSE_TCP */
3696:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
3697:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3698:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigUSE_TCP == 1 )
3699:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3700:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* Returns pdTRUE if TCP socket is connected. */
3701:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t FreeRTOS_issocketconnected( ConstSocket_t xSocket )
3702:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 5529              	 .loc 1 3702 0
 5530              	 .cfi_startproc
 5531              	 
 5532              	 
 5533              	 
 5534              	.LVL756:
3703:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	const FreeRTOS_Socket_t *pxSocket = ( const FreeRTOS_Socket_t * ) xSocket;
3704:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t xReturn = pdFALSE;
3705:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3706:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 5535              	 .loc 1 3706 0
 5536 0000 90F82730 	 ldrb r3,[r0,#39]
 5537 0004 062B     	 cmp r3,#6
 5538 0006 08D1     	 bne .L495
3707:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
3708:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xReturn = -pdFREERTOS_ERRNO_EINVAL;
3709:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
3710:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else
3711:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
3712:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( pxSocket->u.xTCP.ucTCPState >= ( uint8_t ) eESTABLISHED )
 5539              	 .loc 1 3712 0
 5540 0008 90F85300 	 ldrb r0,[r0,#83]
 5541              	.LVL757:
 5542 000c 0538     	 subs r0,r0,#5
 5543 000e C0B2     	 uxtb r0,r0
 5544 0010 0228     	 cmp r0,#2
 5545 0012 8CBF     	 ite hi
 5546 0014 0020     	 movhi r0,#0
 5547 0016 0120     	 movls r0,#1
 5548 0018 7047     	 bx lr
 5549              	.LVL758:
 5550              	.L495:
3708:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 5551              	 .loc 1 3708 0
 5552 001a 6FF01500 	 mvn r0,#21
 5553              	.LVL759:
3713:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
3714:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( pxSocket->u.xTCP.ucTCPState < ( uint8_t ) eCLOSE_WAIT )
3715:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
3716:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					xReturn = pdTRUE;
3717:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
3718:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
3719:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
3720:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3721:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		return xReturn;
3722:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 5554              	 .loc 1 3722 0
 5555 001e 7047     	 bx lr
 5556              	 .cfi_endproc
 5557              	.LFE102:
 5559              	 .section .text.FreeRTOS_connect,"ax",%progbits
 5560              	 .align 2
 5561              	 .global FreeRTOS_connect
 5562              	 .thumb
 5563              	 .thumb_func
 5565              	FreeRTOS_connect:
 5566              	.LFB85:
2434:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t* ) xClientSocket;
 5567              	 .loc 1 2434 0
 5568              	 .cfi_startproc
 5569              	 
 5570              	 
 5571              	.LVL760:
 5572              	.LBB380:
 5573              	.LBB381:
2362:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 5574              	 .loc 1 2362 0
 5575 0000 0029     	 cmp r1,#0
 5576 0002 6FD0     	 beq .L507
 5577              	.LBE381:
 5578              	.LBE380:
2434:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t* ) xClientSocket;
 5579              	 .loc 1 2434 0
 5580 0004 70B5     	 push {r4,r5,r6,lr}
 5581              	.LCFI70:
 5582              	 .cfi_def_cfa_offset 16
 5583              	 .cfi_offset 4,-16
 5584              	 .cfi_offset 5,-12
 5585              	 .cfi_offset 6,-8
 5586              	 .cfi_offset 14,-4
 5587 0006 86B0     	 sub sp,sp,#24
 5588              	.LCFI71:
 5589              	 .cfi_def_cfa_offset 40
 5590 0008 0D46     	 mov r5,r1
 5591 000a 0446     	 mov r4,r0
 5592              	.LBB389:
 5593              	.LBB386:
2367:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 5594              	 .loc 1 2367 0
 5595 000c 0621     	 movs r1,#6
 5596              	.LVL761:
 5597 000e 0022     	 movs r2,#0
 5598              	.LVL762:
 5599 0010 FFF7FEFF 	 bl prvValidSocket
 5600              	.LVL763:
 5601 0014 0028     	 cmp r0,#0
 5602 0016 69D0     	 beq .L508
2372:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 5603              	 .loc 1 2372 0
 5604 0018 2046     	 mov r0,r4
 5605 001a FFF7FEFF 	 bl FreeRTOS_issocketconnected
 5606              	.LVL764:
 5607 001e 0028     	 cmp r0,#0
 5608 0020 67DC     	 bgt .L509
2377:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 5609              	 .loc 1 2377 0
 5610 0022 A369     	 ldr r3,[r4,#24]
 5611 0024 3BB9     	 cbnz r3,.L498
2381:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 5612              	 .loc 1 2381 0
 5613 0026 2046     	 mov r0,r4
 5614 0028 0021     	 movs r1,#0
 5615 002a 0A46     	 mov r2,r1
 5616 002c FFF7FEFF 	 bl FreeRTOS_bind
 5617              	.LVL765:
2388:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 5618              	 .loc 1 2388 0
 5619 0030 0346     	 mov r3,r0
 5620 0032 0028     	 cmp r0,#0
 5621 0034 65D1     	 bne .L515
 5622              	.LVL766:
 5623              	.L498:
 5624              	.LBB382:
 5625              	.LBB383:
2328:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 5626              	 .loc 1 2328 0
 5627 0036 94F85330 	 ldrb r3,[r4,#83]
 5628 003a 022B     	 cmp r3,#2
 5629 003c 5CD0     	 beq .L510
 5630 003e 082B     	 cmp r3,#8
 5631 0040 03D0     	 beq .L502
 5632 0042 13B1     	 cbz r3,.L502
2347:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				break;
 5633              	 .loc 1 2347 0
 5634 0044 6FF00A03 	 mvn r3,#10
 5635 0048 5BE0     	 b .L515
 5636              	.L502:
 5637              	.LVL767:
 5638              	.LBE383:
 5639              	.LBE382:
2397:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocket->u.xTCP.ucRepCount = 0U;
 5640              	 .loc 1 2397 0
 5641 004a 94F84130 	 ldrb r3,[r4,#65]
 5642 004e 6FF3C303 	 bfc r3,#3,#1
 5643 0052 84F84130 	 strb r3,[r4,#65]
2398:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 5644              	 .loc 1 2398 0
 5645 0056 0023     	 movs r3,#0
 5646 0058 84F85230 	 strb r3,[r4,#82]
2404:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 5647              	 .loc 1 2404 0
 5648 005c 6A88     	 ldrh r2,[r5,#2]
 5649 005e 130A     	 lsrs r3,r2,#8
 5650 0060 43EA0223 	 orr r3,r3,r2,lsl#8
 5651 0064 A387     	 strh r3,[r4,#60]
2407:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 5652              	 .loc 1 2407 0
 5653 0066 6968     	 ldr r1,[r5,#4]
 5654 0068 0A06     	 lsls r2,r1,#24
 5655 006a 42EA1162 	 orr r2,r2,r1,lsr#24
 5656 006e 01F47F43 	 and r3,r1,#65280
 5657 0072 42EA0322 	 orr r2,r2,r3,lsl#8
 5658 0076 01F47F03 	 and r3,r1,#16711680
 5659 007a 42EA1323 	 orr r3,r2,r3,lsr#8
 5660 007e A363     	 str r3,[r4,#56]
2410:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 5661              	 .loc 1 2410 0
 5662 0080 2046     	 mov r0,r4
 5663 0082 0221     	 movs r1,#2
 5664 0084 FFF7FEFF 	 bl vTCPStateChange
 5665              	.LVL768:
2413:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 5666              	 .loc 1 2413 0
 5667 0088 0123     	 movs r3,#1
 5668 008a A4F84830 	 strh r3,[r4,#72]
2415:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 5669              	 .loc 1 2415 0
 5670 008e 0620     	 movs r0,#6
 5671 0090 FFF7FEFF 	 bl xSendEventToIPTask
 5672              	.LVL769:
 5673 0094 0128     	 cmp r0,#1
 5674 0096 32D1     	 bne .L511
 5675 0098 0025     	 movs r5,#0
 5676              	.LVL770:
 5677              	.LBE386:
 5678              	.LBE389:
2462:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 5679              	 .loc 1 2462 0
 5680 009a 0126     	 movs r6,#1
 5681              	.LVL771:
 5682              	.L503:
2450:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 5683              	 .loc 1 2450 0
 5684 009c 35B9     	 cbnz r5,.L505
 5685              	.LVL772:
2453:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( xRemainingTime == ( TickType_t )0 )
 5686              	 .loc 1 2453 0
 5687 009e E369     	 ldr r3,[r4,#28]
 5688 00a0 0593     	 str r3,[sp,#20]
2454:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
 5689              	 .loc 1 2454 0
 5690 00a2 BBB1     	 cbz r3,.L512
 5691              	.LVL773:
2465:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 5692              	 .loc 1 2465 0
 5693 00a4 03A8     	 add r0,sp,#12
 5694 00a6 FFF7FEFF 	 bl vTaskSetTimeOutState
 5695              	.LVL774:
2462:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 5696              	 .loc 1 2462 0
 5697 00aa 3546     	 mov r5,r6
 5698              	.LVL775:
 5699              	.L505:
2469:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 5700              	 .loc 1 2469 0
 5701 00ac 2046     	 mov r0,r4
 5702 00ae FFF7FEFF 	 bl FreeRTOS_issocketconnected
 5703              	.LVL776:
2472:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 5704              	 .loc 1 2472 0
 5705 00b2 031E     	 subs r3,r0,#0
 5706 00b4 25DB     	 blt .L515
2478:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 5707              	 .loc 1 2478 0
 5708 00b6 10DC     	 bgt .L513
2486:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
 5709              	 .loc 1 2486 0
 5710 00b8 03A8     	 add r0,sp,#12
 5711              	.LVL777:
 5712 00ba 05A9     	 add r1,sp,#20
 5713 00bc FFF7FEFF 	 bl xTaskCheckForTimeOut
 5714              	.LVL778:
 5715 00c0 68B9     	 cbnz r0,.L514
2493:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 5716              	 .loc 1 2493 0
 5717 00c2 059B     	 ldr r3,[sp,#20]
 5718 00c4 0093     	 str r3,[sp]
 5719 00c6 6068     	 ldr r0,[r4,#4]
 5720 00c8 0821     	 movs r1,#8
 5721 00ca 3246     	 mov r2,r6
 5722 00cc 0023     	 movs r3,#0
 5723 00ce FFF7FEFF 	 bl xEventGroupWaitBits
 5724              	.LVL779:
2494:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 5725              	 .loc 1 2494 0
 5726 00d2 E3E7     	 b .L503
 5727              	.LVL780:
 5728              	.L512:
2457:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						break;
 5729              	 .loc 1 2457 0
 5730 00d4 6FF00A03 	 mvn r3,#10
 5731 00d8 13E0     	 b .L515
 5732              	.LVL781:
 5733              	.L513:
2481:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					break;
 5734              	 .loc 1 2481 0
 5735 00da 0023     	 movs r3,#0
 5736 00dc 11E0     	 b .L515
 5737              	.LVL782:
 5738              	.L514:
2488:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					break;
 5739              	 .loc 1 2488 0
 5740 00de 6FF07303 	 mvn r3,#115
 5741 00e2 0EE0     	 b .L515
 5742              	.LVL783:
 5743              	.L507:
 5744              	.LCFI72:
 5745              	 .cfi_def_cfa_offset 0
 5746              	 .cfi_restore 4
 5747              	 .cfi_restore 5
 5748              	 .cfi_restore 6
 5749              	 .cfi_restore 14
 5750              	.LBB390:
 5751              	.LBB387:
2365:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 5752              	 .loc 1 2365 0
 5753 00e4 6FF01503 	 mvn r3,#21
 5754              	.LBE387:
 5755              	.LBE390:
2498:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigUSE_TCP */
 5756              	 .loc 1 2498 0
 5757 00e8 1846     	 mov r0,r3
 5758              	.LVL784:
 5759 00ea 7047     	 bx lr
 5760              	.LVL785:
 5761              	.L508:
 5762              	.LCFI73:
 5763              	 .cfi_def_cfa_offset 40
 5764              	 .cfi_offset 4,-16
 5765              	 .cfi_offset 5,-12
 5766              	 .cfi_offset 6,-8
 5767              	 .cfi_offset 14,-4
 5768              	.LBB391:
 5769              	.LBB388:
2370:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 5770              	 .loc 1 2370 0
 5771 00ec 6FF00803 	 mvn r3,#8
 5772 00f0 07E0     	 b .L515
 5773              	.L509:
2375:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 5774              	 .loc 1 2375 0
 5775 00f2 6FF07E03 	 mvn r3,#126
 5776              	.LVL786:
 5777 00f6 04E0     	 b .L515
 5778              	.LVL787:
 5779              	.L510:
 5780              	.LBB385:
 5781              	.LBB384:
2335:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				break;
 5782              	 .loc 1 2335 0
 5783 00f8 6FF07603 	 mvn r3,#118
 5784              	.LVL788:
 5785 00fc 01E0     	 b .L515
 5786              	.LVL789:
 5787              	.L511:
 5788              	.LBE384:
 5789              	.LBE385:
2417:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
 5790              	 .loc 1 2417 0
 5791 00fe 6FF08B03 	 mvn r3,#139
 5792              	.LVL790:
 5793              	.L515:
 5794              	.LBE388:
 5795              	.LBE391:
2498:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigUSE_TCP */
 5796              	 .loc 1 2498 0
 5797 0102 1846     	 mov r0,r3
 5798 0104 06B0     	 add sp,sp,#24
 5799              	.LCFI74:
 5800              	 .cfi_def_cfa_offset 16
 5801              	 
 5802 0106 70BD     	 pop {r4,r5,r6,pc}
 5803              	 .cfi_endproc
 5804              	.LFE85:
 5806              	 .section .text.FreeRTOS_mss,"ax",%progbits
 5807              	 .align 2
 5808              	 .global FreeRTOS_mss
 5809              	 .thumb
 5810              	 .thumb_func
 5812              	FreeRTOS_mss:
 5813              	.LFB103:
3723:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3724:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigUSE_TCP */
3725:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
3726:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3727:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigUSE_TCP == 1 )
3728:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3729:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* Returns the actual size of MSS being used. */
3730:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t FreeRTOS_mss( ConstSocket_t xSocket )
3731:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 5814              	 .loc 1 3731 0
 5815              	 .cfi_startproc
 5816              	 
 5817              	 
 5818              	 
 5819              	.LVL791:
3732:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	const FreeRTOS_Socket_t *pxSocket = ( const FreeRTOS_Socket_t * ) xSocket;
3733:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t xReturn;
3734:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3735:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 5820              	 .loc 1 3735 0
 5821 0000 90F82730 	 ldrb r3,[r0,#39]
 5822 0004 062B     	 cmp r3,#6
3736:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
3737:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xReturn = -pdFREERTOS_ERRNO_EINVAL;
3738:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
3739:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else
3740:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
3741:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* usCurMSS is declared as uint16_t to save space.  FreeRTOS_mss()
3742:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			will often be used in signed native-size expressions cast it to
3743:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			BaseType_t. */
3744:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xReturn = ( BaseType_t ) ( pxSocket->u.xTCP.usCurMSS );
 5823              	 .loc 1 3744 0
 5824 0006 0CBF     	 ite eq
 5825 0008 B0F84A00 	 ldrheq r0,[r0,#74]
 5826              	.LVL792:
3737:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 5827              	 .loc 1 3737 0
 5828 000c 6FF01500 	 mvnne r0,#21
 5829              	.LVL793:
3745:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
3746:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3747:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		return xReturn;
3748:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 5830              	 .loc 1 3748 0
 5831 0010 7047     	 bx lr
 5832              	 .cfi_endproc
 5833              	.LFE103:
 5835 0012 00BF     	 .section .text.FreeRTOS_connstatus,"ax",%progbits
 5836              	 .align 2
 5837              	 .global FreeRTOS_connstatus
 5838              	 .thumb
 5839              	 .thumb_func
 5841              	FreeRTOS_connstatus:
 5842              	.LFB104:
3749:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3750:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigUSE_TCP */
3751:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
3752:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3753:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigUSE_TCP == 1 )
3754:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3755:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* For internal use only: return the connection status. */
3756:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t FreeRTOS_connstatus( ConstSocket_t xSocket )
3757:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 5843              	 .loc 1 3757 0
 5844              	 .cfi_startproc
 5845              	 
 5846              	 
 5847              	 
 5848              	.LVL794:
3758:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	const FreeRTOS_Socket_t *pxSocket = ( const FreeRTOS_Socket_t * ) xSocket;
3759:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t xReturn;
3760:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3761:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 5849              	 .loc 1 3761 0
 5850 0000 90F82730 	 ldrb r3,[r0,#39]
 5851 0004 062B     	 cmp r3,#6
3762:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
3763:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xReturn = -pdFREERTOS_ERRNO_EINVAL;
3764:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
3765:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else
3766:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
3767:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Cast it to BaseType_t. */
3768:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xReturn = ( BaseType_t ) ( pxSocket->u.xTCP.ucTCPState );
 5852              	 .loc 1 3768 0
 5853 0006 0CBF     	 ite eq
 5854 0008 90F85300 	 ldrbeq r0,[r0,#83]
 5855              	.LVL795:
3763:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 5856              	 .loc 1 3763 0
 5857 000c 6FF01500 	 mvnne r0,#21
 5858              	.LVL796:
3769:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
3770:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3771:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		return xReturn;
3772:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 5859              	 .loc 1 3772 0
 5860 0010 7047     	 bx lr
 5861              	 .cfi_endproc
 5862              	.LFE104:
 5864 0012 00BF     	 .section .text.FreeRTOS_rx_size,"ax",%progbits
 5865              	 .align 2
 5866              	 .global FreeRTOS_rx_size
 5867              	 .thumb
 5868              	 .thumb_func
 5870              	FreeRTOS_rx_size:
 5871              	.LFB105:
3773:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3774:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigUSE_TCP */
3775:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
3776:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3777:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigUSE_TCP == 1 )
3778:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3779:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/*
3780:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 * Returns the number of bytes which can be read.
3781:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	 */
3782:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t FreeRTOS_rx_size( ConstSocket_t xSocket )
3783:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 5872              	 .loc 1 3783 0
 5873              	 .cfi_startproc
 5874              	 
 5875              	 
 5876              	 
 5877              	.LVL797:
3784:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	const FreeRTOS_Socket_t *pxSocket = ( const FreeRTOS_Socket_t * ) xSocket;
3785:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t xReturn;
3786:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3787:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 5878              	 .loc 1 3787 0
 5879 0000 90F82730 	 ldrb r3,[r0,#39]
 5880 0004 062B     	 cmp r3,#6
 5881 0006 0AD1     	 bne .L526
3788:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
3789:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xReturn = -pdFREERTOS_ERRNO_EINVAL;
3790:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
3791:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else if( pxSocket->u.xTCP.rxStream != NULL )
 5882              	 .loc 1 3791 0
 5883 0008 436F     	 ldr r3,[r0,#116]
 5884 000a 5BB1     	 cbz r3,.L527
 5885              	.LVL798:
 5886              	.LBB392:
 5887              	.LBB393:
 125:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxTail = pxBuffer->uxTail;
 5888              	 .loc 3 125 0
 5889 000c 9868     	 ldr r0,[r3,#8]
 5890              	.LVL799:
 126:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
 5891              	 .loc 3 126 0
 5892 000e 1A68     	 ldr r2,[r3]
 5893              	.LVL800:
 5894              	.LBB394:
 5895              	.LBB395:
  84:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	if ( uxCount >= pxBuffer->LENGTH )
 5896              	 .loc 3 84 0
 5897 0010 1B69     	 ldr r3,[r3,#16]
 5898              	.LVL801:
 5899 0012 1844     	 add r0,r0,r3
 5900              	.LVL802:
 5901 0014 801A     	 subs r0,r0,r2
 5902              	.LVL803:
  85:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	{
 5903              	 .loc 3 85 0
 5904 0016 8342     	 cmp r3,r0
 5905 0018 05D8     	 bhi .L524
 5906              	.LVL804:
  87:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	}
 5907              	 .loc 3 87 0
 5908 001a C01A     	 subs r0,r0,r3
 5909              	.LVL805:
 5910              	.LBE395:
 5911              	.LBE394:
 5912              	.LBE393:
 5913              	.LBE392:
 5914 001c 7047     	 bx lr
 5915              	.LVL806:
 5916              	.L526:
3789:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 5917              	 .loc 1 3789 0
 5918 001e 6FF01500 	 mvn r0,#21
 5919              	.LVL807:
 5920 0022 7047     	 bx lr
 5921              	.LVL808:
 5922              	.L527:
3792:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
3793:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xReturn = ( BaseType_t ) uxStreamBufferGetSize( pxSocket->u.xTCP.rxStream );
3794:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
3795:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else
3796:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
3797:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xReturn = 0;
 5923              	 .loc 1 3797 0
 5924 0024 0020     	 movs r0,#0
 5925              	.LVL809:
 5926              	.L524:
3798:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
3799:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3800:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		return xReturn;
3801:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 5927              	 .loc 1 3801 0
 5928 0026 7047     	 bx lr
 5929              	 .cfi_endproc
 5930              	.LFE105:
 5932              	 .section .text.FreeRTOS_netstat,"ax",%progbits
 5933              	 .align 2
 5934              	 .global FreeRTOS_netstat
 5935              	 .thumb
 5936              	 .thumb_func
 5938              	FreeRTOS_netstat:
 5939              	.LFB106:
3802:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3803:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigUSE_TCP */
3804:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
3805:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3806:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if 0
3807:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** BaseType_t FreeRTOS_udp_rx_size( Socket_t xSocket )
3808:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** {
3809:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t xReturn = 0;
3810:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	const FreeRTOS_Socket_t *pxSocket = ( const FreeRTOS_Socket_t * ) xSocket;
3811:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3812:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_UDP )
3813:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
3814:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		xReturn = ( BaseType_t ) listCURRENT_LIST_LENGTH( &( pxSocket->u.xUDP.xWaitingPacketsList ) );
3815:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
3816:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	else
3817:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
3818:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		xReturn = -pdFREERTOS_ERRNO_EINVAL;
3819:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
3820:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	return xReturn;
3821:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** }
3822:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* 0 */
3823:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3824:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigUSE_TCP == 1 )
3825:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3826:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	void FreeRTOS_netstat( void )
3827:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 5940              	 .loc 1 3827 0
 5941              	 .cfi_startproc
 5942              	 
 5943              	 
 5944 0000 00B5     	 push {lr}
 5945              	.LCFI75:
 5946              	 .cfi_def_cfa_offset 4
 5947              	 .cfi_offset 14,-4
 5948 0002 83B0     	 sub sp,sp,#12
 5949              	.LCFI76:
 5950              	 .cfi_def_cfa_offset 16
3828:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	IPStackEvent_t xAskEvent;
3829:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3830:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* Ask the IP-task to call vTCPNetStat()
3831:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		 * to avoid accessing xBoundTCPSocketsList
3832:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		 */
3833:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		xAskEvent.eEventType = eTCPNetStat;
 5951              	 .loc 1 3833 0
 5952 0004 0823     	 movs r3,#8
 5953 0006 8DF80030 	 strb r3,[sp]
3834:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		xAskEvent.pvData = ( void * ) NULL;
 5954              	 .loc 1 3834 0
 5955 000a 0023     	 movs r3,#0
 5956 000c 0193     	 str r3,[sp,#4]
3835:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		( void ) xSendEventStructToIPTask( &xAskEvent, pdMS_TO_TICKS( 1000U ) );
 5957              	 .loc 1 3835 0
 5958 000e 6846     	 mov r0,sp
 5959 0010 4FF47A71 	 mov r1,#1000
 5960 0014 FFF7FEFF 	 bl xSendEventStructToIPTask
 5961              	.LVL810:
3836:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 5962              	 .loc 1 3836 0
 5963 0018 03B0     	 add sp,sp,#12
 5964              	.LCFI77:
 5965              	 .cfi_def_cfa_offset 4
 5966              	 
 5967 001a 5DF804FB 	 ldr pc,[sp],#4
 5968              	 .cfi_endproc
 5969              	.LFE106:
 5971 001e 00BF     	 .section .text.vSocketSelect,"ax",%progbits
 5972              	 .align 2
 5973              	 .global vSocketSelect
 5974              	 .thumb
 5975              	 .thumb_func
 5977              	vSocketSelect:
 5978              	.LFB107:
3837:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3838:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigUSE_TCP */
3839:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
3840:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3841:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ( ipconfigHAS_PRINTF != 0 ) && ( ipconfigUSE_TCP == 1 ) )
3842:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3843:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	void vTCPNetStat( void )
3844:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
3845:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* Show a simple listing of all created sockets and their connections */
3846:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	const ListItem_t *pxIterator;
3847:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t count = 0;
3848:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	size_t uxMinimum = uxGetMinimumFreeNetworkBuffers();
3849:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	size_t uxCurrent = uxGetNumberOfFreeNetworkBuffers();
3850:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3851:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( !listLIST_IS_INITIALISED( &xBoundTCPSocketsList ) )
3852:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
3853:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			FreeRTOS_printf( ( "PLUS-TCP not initialized\n" ) );
3854:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
3855:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else
3856:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
3857:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		const ListItem_t *pxEndTCP = listGET_END_MARKER( &xBoundTCPSocketsList );
3858:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		const ListItem_t *pxEndUDP = listGET_END_MARKER( &xBoundUDPSocketsList );
3859:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			FreeRTOS_printf( ( "Prot Port IP-Remote       : Port  R/T Status       Alive  tmout Child\n" ) )
3860:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			for( pxIterator  = listGET_HEAD_ENTRY( &xBoundTCPSocketsList );
3861:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				 pxIterator != pxEndTCP;
3862:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				 pxIterator  = listGET_NEXT( pxIterator ) )
3863:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
3864:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				const FreeRTOS_Socket_t *pxSocket = ipCAST_CONST_PTR_TO_CONST_TYPE_PTR( FreeRTOS_Socket_t, list
3865:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				#if( ipconfigTCP_KEEP_ALIVE == 1 )
3866:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					TickType_t age = xTaskGetTickCount() - pxSocket->u.xTCP.xLastAliveTime;
3867:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				#else
3868:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					TickType_t age = 0U;
3869:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				#endif
3870:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3871:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				char ucChildText[16] = "";
3872:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if (pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eTCP_LISTEN)
3873:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
3874:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Using function "snprintf". */
3875:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					const int32_t copied_len = snprintf( ucChildText, sizeof( ucChildText ), " %d/%d",
3876:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						( int32_t ) pxSocket->u.xTCP.usChildCount,
3877:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						( int32_t ) pxSocket->u.xTCP.usBacklog);
3878:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					( void )copied_len;
3879:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* These should never evaluate to false since the buffers are both shorter than 5-6 characters
3880:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					configASSERT( copied_len >= 0 );
3881:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					configASSERT( copied_len < ( int32_t ) sizeof( ucChildText ) );
3882:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
3883:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				FreeRTOS_printf( ( "TCP %5d %-16lxip:%5d %d/%d %-13.13s %6lu %6u%s\n",
3884:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					pxSocket->usLocalPort,		/* Local port on this machine */
3885:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					pxSocket->u.xTCP.ulRemoteIP,	/* IP address of remote machine */
3886:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					pxSocket->u.xTCP.usRemotePort,	/* Port on remote machine */
3887:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					( pxSocket->u.xTCP.rxStream != NULL ) ? 1 : 0,
3888:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					( pxSocket->u.xTCP.txStream != NULL ) ? 1 : 0,
3889:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					FreeRTOS_GetTCPStateName( pxSocket->u.xTCP.ucTCPState ),
3890:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					( age > 999999u ) ? 999999u : age, /* Format 'age' for printing */
3891:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					pxSocket->u.xTCP.usTimeout,
3892:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					ucChildText ) );
3893:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				count++;
3894:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
3895:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3896:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			for( pxIterator  = listGET_HEAD_ENTRY( &xBoundUDPSocketsList );
3897:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				 pxIterator != pxEndUDP;
3898:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				 pxIterator  = listGET_NEXT( pxIterator ) )
3899:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
3900:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* Local port on this machine */
3901:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				FreeRTOS_printf( ( "UDP Port %5u\n",
3902:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					FreeRTOS_ntohs( listGET_LIST_ITEM_VALUE( pxIterator ) ) ) );
3903:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				count++;
3904:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
3905:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3906:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			FreeRTOS_printf( ( "FreeRTOS_netstat: %lu sockets %lu < %lu < %ld buffers free\n",
3907:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				( UBaseType_t ) count,
3908:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				( UBaseType_t ) uxMinimum,
3909:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				( UBaseType_t ) uxCurrent,
3910:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				( BaseType_t ) ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS ) );
3911:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
3912:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
3913:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3914:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ( ( ipconfigHAS_PRINTF != 0 ) && ( ipconfigUSE_TCP == 1 ) ) */
3915:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
3916:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3917:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
3918:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3919:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	void vSocketSelect( SocketSelect_t *pxSocketSet )
3920:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 5979              	 .loc 1 3920 0
 5980              	 .cfi_startproc
 5981              	 
 5982              	 
 5983              	.LVL811:
 5984 0000 2DE9F04F 	 push {r4,r5,r6,r7,r8,r9,r10,fp,lr}
 5985              	.LCFI78:
 5986              	 .cfi_def_cfa_offset 36
 5987              	 .cfi_offset 4,-36
 5988              	 .cfi_offset 5,-32
 5989              	 .cfi_offset 6,-28
 5990              	 .cfi_offset 7,-24
 5991              	 .cfi_offset 8,-20
 5992              	 .cfi_offset 9,-16
 5993              	 .cfi_offset 10,-12
 5994              	 .cfi_offset 11,-8
 5995              	 .cfi_offset 14,-4
 5996 0004 85B0     	 sub sp,sp,#20
 5997              	.LCFI79:
 5998              	 .cfi_def_cfa_offset 56
 5999 0006 0646     	 mov r6,r0
 6000              	.LVL812:
 6001              	 .loc 1 3920 0
 6002 0008 4FF0010B 	 mov fp,#1
 6003 000c 4FF00009 	 mov r9,#0
3921:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t xRound;
3922:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	EventBits_t xSocketBits, xBitsToClear;
3923:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	#if ipconfigUSE_TCP == 1
3924:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		BaseType_t xLastRound = 2;
3925:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	#else
3926:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		BaseType_t xLastRound = 1;
3927:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	#endif
3928:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3929:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* These flags will be switched on after checking the socket status. */
3930:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		EventBits_t xGroupBits = 0;
 6004              	 .loc 1 3930 0
 6005 0010 CA46     	 mov r10,r9
 6006              	.LBB396:
3931:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3932:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		for( xRound = 0; xRound <= xLastRound; xRound++ )
3933:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
3934:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			const ListItem_t *pxIterator;
3935:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			const ListItem_t *pxEnd;
3936:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			if( xRound == 0 )
3937:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
3938:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxEnd = listGET_END_MARKER( &xBoundUDPSocketsList );
3939:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
3940:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			else if( 1 == xRound )
3941:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
3942:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxEnd = listGET_END_MARKER( &xBoundRAWSocketsList );
3943:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
3944:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		#if ipconfigUSE_TCP == 1
3945:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			else
3946:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
3947:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxEnd = listGET_END_MARKER( &xBoundTCPSocketsList );
3948:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
3949:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		#endif /* ipconfigUSE_TCP == 1 */
3950:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			for( pxIterator = listGET_NEXT( pxEnd );
 6007              	 .loc 1 3950 0
 6008 0012 5F4B     	 ldr r3,.L558
 6009 0014 0833     	 adds r3,r3,#8
 6010 0016 0393     	 str r3,[sp,#12]
 6011 0018 5E4B     	 ldr r3,.L558+4
 6012 001a 0833     	 adds r3,r3,#8
 6013 001c 0193     	 str r3,[sp,#4]
 6014 001e 03E0     	 b .L531
 6015              	.LVL813:
 6016              	.L545:
 6017 0020 09F10109 	 add r9,r9,#1
 6018 0024 0BF1010B 	 add fp,fp,#1
 6019              	.LVL814:
 6020              	.L531:
3936:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 6021              	 .loc 1 3936 0
 6022 0028 B9F1000F 	 cmp r9,#0
 6023 002c 00F09F80 	 beq .L532
3940:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 6024              	 .loc 1 3940 0
 6025 0030 B9F1010F 	 cmp r9,#1
 6026 0034 00F09480 	 beq .L533
 6027              	.LVL815:
 6028              	 .loc 1 3950 0
 6029 0038 564B     	 ldr r3,.L558+4
 6030 003a DC68     	 ldr r4,[r3,#12]
 6031              	.LVL816:
 6032 003c 019B     	 ldr r3,[sp,#4]
 6033 003e 9C42     	 cmp r4,r3
 6034 0040 78D0     	 beq .L534
3947:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 6035              	 .loc 1 3947 0
 6036 0042 554F     	 ldr r7,.L558+8
 6037              	.LVL817:
 6038 0044 04E0     	 b .L544
 6039              	.LVL818:
 6040              	.L553:
3942:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 6041              	 .loc 1 3942 0
 6042 0046 554B     	 ldr r3,.L558+12
 6043 0048 03F10807 	 add r7,r3,#8
 6044 004c 00E0     	 b .L544
 6045              	.LVL819:
 6046              	.L554:
3938:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}
 6047              	 .loc 1 3938 0
 6048 004e 039F     	 ldr r7,[sp,#12]
 6049              	.LVL820:
 6050              	.L544:
 6051              	.LBB397:
3951:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				 pxIterator != pxEnd;
3952:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				 pxIterator = listGET_NEXT( pxIterator ) )
3953:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
3954:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				FreeRTOS_Socket_t *pxSocket =  ipCAST_PTR_TO_TYPE_PTR( FreeRTOS_Socket_t, listGET_LIST_ITEM_OWN
 6052              	 .loc 1 3954 0
 6053 0050 E568     	 ldr r5,[r4,#12]
 6054              	.LVL821:
3955:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( pxSocket->pxSocketSet != pxSocketSet )
 6055              	 .loc 1 3955 0
 6056 0052 EB6A     	 ldr r3,[r5,#44]
 6057 0054 B342     	 cmp r3,r6
 6058 0056 6AD1     	 bne .L535
 6059              	.LVL822:
3956:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
3957:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Socket does not belong to this select group. */
3958:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					continue;
3959:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
3960:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xSocketBits = 0;
3961:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3962:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			#if( ipconfigUSE_TCP == 1 )
3963:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_TCP )
 6060              	 .loc 1 3963 0
 6061 0058 95F82730 	 ldrb r3,[r5,#39]
 6062 005c 062B     	 cmp r3,#6
 6063 005e 55D1     	 bne .L536
 6064              	.LVL823:
 6065              	.LBB398:
3964:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
3965:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Check if the socket has already been accepted by the
3966:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					owner.  If not, it is useless to return it from a
3967:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					select(). */
3968:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					BaseType_t bAccepted = pdFALSE;
3969:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3970:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( pxSocket->u.xTCP.bits.bPassQueued == pdFALSE_UNSIGNED )
 6066              	 .loc 1 3970 0
 6067 0060 95F84020 	 ldrb r2,[r5,#64]
3971:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
3972:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						if( pxSocket->u.xTCP.bits.bPassAccept == pdFALSE_UNSIGNED )
 6068              	 .loc 1 3972 0
 6069 0064 12F0060F 	 tst r2,#6
 6070 0068 0CBF     	 ite eq
 6071 006a 0123     	 moveq r3,#1
 6072 006c 0023     	 movne r3,#0
 6073 006e 0293     	 str r3,[sp,#8]
 6074              	.LVL824:
3973:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						{
3974:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							bAccepted = pdTRUE;
3975:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						}
3976:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
3977:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
3978:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Is the set owner interested in READ events? */
3979:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( ( pxSocket->xSelectBits & ( EventBits_t ) eSELECT_READ ) != ( EventBits_t ) 0U )
 6075              	 .loc 1 3979 0
 6076 0070 2B6B     	 ldr r3,[r5,#48]
 6077              	.LVL825:
 6078 0072 13F0010F 	 tst r3,#1
 6079 0076 1BD0     	 beq .L548
3980:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
3981:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						if( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eTCP_LISTEN )
 6080              	 .loc 1 3981 0
 6081 0078 95F85310 	 ldrb r1,[r5,#83]
 6082 007c 0129     	 cmp r1,#1
 6083 007e 07D1     	 bne .L538
3982:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						{
3983:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							if( ( pxSocket->u.xTCP.pxPeerSocket != NULL ) && ( pxSocket->u.xTCP.pxPeerSocket->u.xTCP.bit
 6084              	 .loc 1 3983 0
 6085 0080 6A6D     	 ldr r2,[r5,#84]
 6086 0082 002A     	 cmp r2,#0
 6087 0084 7AD0     	 beq .L549
 6088              	 .loc 1 3983 0 is_stmt 0 discriminator 1
 6089 0086 92F84080 	 ldrb r8,[r2,#64]
 6090 008a C8F34008 	 ubfx r8,r8,#1,#1
 6091 008e 22E0     	 b .L540
 6092              	.L538:
3984:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							{
3985:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 								xSocketBits |= ( EventBits_t ) eSELECT_READ;
3986:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							}
3987:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						}
3988:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						else if( ( pxSocket->u.xTCP.bits.bReuseSocket != pdFALSE_UNSIGNED ) && ( pxSocket->u.xTCP.bit
 6093              	 .loc 1 3988 0 is_stmt 1
 6094 0090 02F00A02 	 and r2,r2,#10
 6095 0094 0A2A     	 cmp r2,#10
 6096 0096 0ED0     	 beq .L550
3989:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						{
3990:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							/* This socket has the re-use flag. After connecting it turns into
3991:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							aconnected socket. Set the READ event, so that accept() will be called. */
3992:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							xSocketBits |= ( EventBits_t ) eSELECT_READ;
3993:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						}
3994:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						else if( ( bAccepted != 0 ) && ( FreeRTOS_recvcount( pxSocket ) > 0 ) )
 6097              	 .loc 1 3994 0
 6098 0098 029B     	 ldr r3,[sp,#8]
 6099 009a 7BB1     	 cbz r3,.L551
 6100              	 .loc 1 3994 0 is_stmt 0 discriminator 1
 6101 009c 2846     	 mov r0,r5
 6102 009e FFF7FEFF 	 bl FreeRTOS_rx_size
 6103              	.LVL826:
 6104 00a2 0028     	 cmp r0,#0
 6105 00a4 D4BF     	 ite le
 6106 00a6 4FF00008 	 movle r8,#0
 6107 00aa 4FF00108 	 movgt r8,#1
 6108 00ae 07E0     	 b .L537
 6109              	.L548:
 6110              	.LBE398:
3960:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 6111              	 .loc 1 3960 0 is_stmt 1
 6112 00b0 4FF00008 	 mov r8,#0
 6113 00b4 04E0     	 b .L537
 6114              	.L550:
 6115              	.LBB401:
3992:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						}
 6116              	 .loc 1 3992 0
 6117 00b6 4FF00108 	 mov r8,#1
 6118 00ba 01E0     	 b .L537
 6119              	.L551:
 6120              	.LBE401:
3960:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 6121              	 .loc 1 3960 0
 6122 00bc 4FF00008 	 mov r8,#0
 6123              	.L537:
 6124              	.LVL827:
 6125              	.LBB402:
3995:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						{
3996:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							xSocketBits |= ( EventBits_t ) eSELECT_READ;
3997:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						}
3998:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						else
3999:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						{
4000:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							/* Nothing. */
4001:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						}
4002:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
4003:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Is the set owner interested in EXCEPTION events? */
4004:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( ( pxSocket->xSelectBits & ( EventBits_t ) eSELECT_EXCEPT ) != 0U )
 6126              	 .loc 1 4004 0
 6127 00c0 2B6B     	 ldr r3,[r5,#48]
 6128 00c2 13F0040F 	 tst r3,#4
 6129 00c6 06D0     	 beq .L540
4005:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
4006:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						if( ( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eCLOSE_WAIT ) || ( pxSocket->u.xTCP.ucTCPSta
 6130              	 .loc 1 4006 0
 6131 00c8 95F85320 	 ldrb r2,[r5,#83]
 6132 00cc 12F0F70F 	 tst r2,#247
4007:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						{
4008:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							xSocketBits |= ( EventBits_t ) eSELECT_EXCEPT;
 6133              	 .loc 1 4008 0
 6134 00d0 08BF     	 it eq
 6135 00d2 48F00408 	 orreq r8,r8,#4
 6136              	.LVL828:
 6137              	.L540:
4009:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						}
4010:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
4011:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
4012:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Is the set owner interested in WRITE events? */
4013:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( ( pxSocket->xSelectBits & ( EventBits_t ) eSELECT_WRITE ) != 0U )
 6138              	 .loc 1 4013 0
 6139 00d6 13F0020F 	 tst r3,#2
 6140 00da 24D0     	 beq .L541
 6141              	.LVL829:
 6142              	.LBB399:
4014:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
4015:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						BaseType_t bMatch = pdFALSE;
4016:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
4017:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						if( bAccepted != 0 )
 6143              	 .loc 1 4017 0
 6144 00dc 029B     	 ldr r3,[sp,#8]
 6145 00de 23B1     	 cbz r3,.L542
4018:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						{
4019:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							if( FreeRTOS_tx_space( pxSocket ) > 0 )
 6146              	 .loc 1 4019 0
 6147 00e0 2846     	 mov r0,r5
 6148 00e2 FFF7FEFF 	 bl FreeRTOS_tx_space
 6149              	.LVL830:
4020:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							{
4021:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 								bMatch = pdTRUE;
4022:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							}
4023:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						}
4024:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
4025:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						if( bMatch == pdFALSE )
 6150              	 .loc 1 4025 0
 6151 00e6 0028     	 cmp r0,#0
 6152 00e8 4BDC     	 bgt .L543
 6153              	.LVL831:
 6154              	.L542:
4026:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						{
4027:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							if( ( pxSocket->u.xTCP.bits.bConnPrepared != pdFALSE_UNSIGNED ) &&
 6155              	 .loc 1 4027 0
 6156 00ea 95F84130 	 ldrb r3,[r5,#65]
 6157 00ee 13F0080F 	 tst r3,#8
 6158 00f2 18D0     	 beq .L541
 6159              	 .loc 1 4027 0 is_stmt 0 discriminator 1
 6160 00f4 95F85320 	 ldrb r2,[r5,#83]
 6161 00f8 042A     	 cmp r2,#4
 6162 00fa 14D9     	 bls .L541
4028:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 								( pxSocket->u.xTCP.ucTCPState >= ( uint8_t ) eESTABLISHED ) &&
 6163              	 .loc 1 4028 0 is_stmt 1
 6164 00fc 13F0100F 	 tst r3,#16
 6165 0100 11D1     	 bne .L541
4029:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 								( pxSocket->u.xTCP.bits.bConnPassed == pdFALSE_UNSIGNED ) )
4030:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							{
4031:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 								pxSocket->u.xTCP.bits.bConnPassed = pdTRUE;
 6166              	 .loc 1 4031 0
 6167 0102 43F01003 	 orr r3,r3,#16
 6168 0106 85F84130 	 strb r3,[r5,#65]
 6169              	.LVL832:
 6170 010a 3AE0     	 b .L543
 6171              	.LVL833:
 6172              	.L536:
 6173              	.LBE399:
 6174              	.LBE402:
4032:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 								bMatch = pdTRUE;
4033:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							}
4034:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						}
4035:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
4036:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						if( bMatch != pdFALSE )
4037:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						{
4038:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 							xSocketBits |= ( EventBits_t ) eSELECT_WRITE;
4039:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						}
4040:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
4041:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}
4042:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				else
4043:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			#endif /* ipconfigUSE_TCP == 1 */
4044:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				{
4045:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* Select events for UDP are simpler. */
4046:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					if( ( ( pxSocket->xSelectBits & ( EventBits_t ) eSELECT_READ ) != 0U ) &&
 6175              	 .loc 1 4046 0
 6176 010c 2B6B     	 ldr r3,[r5,#48]
 6177 010e 13F0010F 	 tst r3,#1
 6178 0112 06D0     	 beq .L552
4047:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						( listCURRENT_LIST_LENGTH( &( pxSocket->u.xUDP.xWaitingPacketsList ) ) > 0U ) )
 6179              	 .loc 1 4047 0 discriminator 1
 6180 0114 AB6B     	 ldr r3,[r5,#56]
4046:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						( listCURRENT_LIST_LENGTH( &( pxSocket->u.xUDP.xWaitingPacketsList ) ) > 0U ) )
 6181              	 .loc 1 4046 0 discriminator 1
 6182 0116 13F10008 	 adds r8,r3,#0
 6183 011a 18BF     	 it ne
 6184 011c 4FF00108 	 movne r8,#1
 6185 0120 01E0     	 b .L541
 6186              	.L552:
3960:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 6187              	 .loc 1 3960 0
 6188 0122 4FF00008 	 mov r8,#0
 6189              	.LVL834:
 6190              	.L541:
4048:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					{
4049:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						xSocketBits |= ( EventBits_t ) eSELECT_READ;
4050:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					}
4051:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 					/* The WRITE and EXCEPT bits are not used for UDP */
4052:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				}	/* if( pxSocket->ucProtocol == FREERTOS_IPPROTO_TCP ) */
4053:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
4054:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* Each socket keeps its own event flags, which are looked-up
4055:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				by FreeRTOS_FD_ISSSET() */
4056:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				pxSocket->xSocketBits = xSocketBits;
 6191              	 .loc 1 4056 0
 6192 0126 C5F83480 	 str r8,[r5,#52]
4057:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
4058:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				/* The ORed value will be used to set the bits in the event
4059:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				group. */
4060:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				xGroupBits |= xSocketBits;
 6193              	 .loc 1 4060 0
 6194 012a 4AEA080A 	 orr r10,r10,r8
 6195              	.LVL835:
 6196              	.L535:
 6197              	.LBE397:
3952:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			{
 6198              	 .loc 1 3952 0
 6199 012e 6468     	 ldr r4,[r4,#4]
 6200              	.LVL836:
3950:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				 pxIterator != pxEnd;
 6201              	 .loc 1 3950 0
 6202 0130 A742     	 cmp r7,r4
 6203 0132 8DD1     	 bne .L544
 6204              	.LVL837:
 6205              	.L534:
 6206              	.LBE396:
3932:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
 6207              	 .loc 1 3932 0 discriminator 2
 6208 0134 BBF1020F 	 cmp fp,#2
 6209 0138 7FF772AF 	 ble .L545
4061:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
4062:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			}	/* for( pxIterator ... ) */
4063:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}	/* for( xRound = 0; xRound <= xLastRound; xRound++ ) */
4064:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
4065:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		xBitsToClear = xEventGroupGetBits( pxSocketSet->xSelectGroup );
 6210              	 .loc 1 4065 0
 6211 013c 3068     	 ldr r0,[r6]
 6212 013e 0021     	 movs r1,#0
 6213 0140 FFF7FEFF 	 bl xEventGroupClearBits
 6214              	.LVL838:
 6215 0144 00F00700 	 and r0,r0,#7
 6216              	.LVL839:
4066:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
4067:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* Now set the necessary bits. */
4068:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		xBitsToClear = ( xBitsToClear & ~xGroupBits ) & ( ( EventBits_t ) eSELECT_ALL );
4069:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
4070:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		#if( ipconfigSUPPORT_SIGNALS != 0 )
4071:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
4072:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			/* Maybe the socketset was signalled, but don't
4073:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			clear the 'eSELECT_INTR' bit here, as it will be used
4074:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			and cleared in FreeRTOS_select(). */
4075:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xBitsToClear &= ~( ( EventBits_t ) eSELECT_INTR );
4076:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
4077:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		#endif /* ipconfigSUPPORT_SIGNALS */
4078:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
4079:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( xBitsToClear != 0U )
 6217              	 .loc 1 4079 0
 6218 0148 30EA0A01 	 bics r1,r0,r10
 6219              	.LVL840:
 6220 014c 02D0     	 beq .L546
4080:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
4081:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			( void ) xEventGroupClearBits( pxSocketSet->xSelectGroup, xBitsToClear );
 6221              	 .loc 1 4081 0
 6222 014e 3068     	 ldr r0,[r6]
 6223 0150 FFF7FEFF 	 bl xEventGroupClearBits
 6224              	.LVL841:
 6225              	.L546:
4082:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
4083:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
4084:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* Now include eSELECT_CALL_IP to wakeup the caller. */
4085:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		( void ) xEventGroupSetBits( pxSocketSet->xSelectGroup, xGroupBits | ( EventBits_t ) eSELECT_CALL
 6226              	 .loc 1 4085 0
 6227 0154 3068     	 ldr r0,[r6]
 6228 0156 4AF01001 	 orr r1,r10,#16
 6229 015a FFF7FEFF 	 bl xEventGroupSetBits
 6230              	.LVL842:
 6231 015e 13E0     	 b .L556
 6232              	.LVL843:
 6233              	.L533:
 6234              	.LBB405:
3950:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 				 pxIterator != pxEnd;
 6235              	 .loc 1 3950 0
 6236 0160 0E4B     	 ldr r3,.L558+12
 6237 0162 DC68     	 ldr r4,[r3,#12]
 6238              	.LVL844:
 6239 0164 0833     	 adds r3,r3,#8
 6240 0166 9C42     	 cmp r4,r3
 6241 0168 7FF46DAF 	 bne .L553
 6242 016c 58E7     	 b .L545
 6243              	.LVL845:
 6244              	.L532:
 6245 016e 084B     	 ldr r3,.L558
 6246 0170 DC68     	 ldr r4,[r3,#12]
 6247              	.LVL846:
 6248 0172 039B     	 ldr r3,[sp,#12]
 6249 0174 9C42     	 cmp r4,r3
 6250 0176 7FF46AAF 	 bne .L554
 6251 017a 51E7     	 b .L545
 6252              	.LVL847:
 6253              	.L549:
 6254              	.LBB404:
3960:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
 6255              	 .loc 1 3960 0
 6256 017c 4FF00008 	 mov r8,#0
 6257 0180 A9E7     	 b .L540
 6258              	.LVL848:
 6259              	.L543:
 6260              	.LBB403:
 6261              	.LBB400:
4038:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 						}
 6262              	 .loc 1 4038 0
 6263 0182 48F00208 	 orr r8,r8,#2
 6264              	.LVL849:
 6265 0186 CEE7     	 b .L541
 6266              	.LVL850:
 6267              	.L556:
 6268              	.LBE400:
 6269              	.LBE403:
 6270              	.LBE404:
 6271              	.LBE405:
4086:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 6272              	 .loc 1 4086 0
 6273 0188 05B0     	 add sp,sp,#20
 6274              	.LCFI80:
 6275              	 .cfi_def_cfa_offset 36
 6276              	 
 6277 018a BDE8F08F 	 pop {r4,r5,r6,r7,r8,r9,r10,fp,pc}
 6278              	.LVL851:
 6279              	.L559:
 6280 018e 00BF     	 .align 2
 6281              	.L558:
 6282 0190 00000000 	 .word .LANCHOR0
 6283 0194 00000000 	 .word xBoundTCPSocketsList
 6284 0198 08000000 	 .word xBoundTCPSocketsList+8
 6285 019c 00000000 	 .word .LANCHOR1
 6286              	 .cfi_endproc
 6287              	.LFE107:
 6289              	 .section .text.FreeRTOS_SignalSocket,"ax",%progbits
 6290              	 .align 2
 6291              	 .global FreeRTOS_SignalSocket
 6292              	 .thumb
 6293              	 .thumb_func
 6295              	FreeRTOS_SignalSocket:
 6296              	.LFB108:
4087:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
4088:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigSUPPORT_SELECT_FUNCTION == 1 */
4089:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
4090:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
4091:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigSUPPORT_SIGNALS != 0 )
4092:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
4093:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* Send a signal to the task which reads from this socket. */
4094:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t FreeRTOS_SignalSocket( Socket_t xSocket )
4095:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 6297              	 .loc 1 4095 0
 6298              	 .cfi_startproc
 6299              	 
 6300              	 
 6301              	.LVL852:
4096:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
4097:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t xReturn;
4098:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
4099:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( pxSocket == NULL )
 6302              	 .loc 1 4099 0
 6303 0000 88B1     	 cbz r0,.L563
4095:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
 6304              	 .loc 1 4095 0
 6305 0002 08B5     	 push {r3,lr}
 6306              	.LCFI81:
 6307              	 .cfi_def_cfa_offset 8
 6308              	 .cfi_offset 3,-8
 6309              	 .cfi_offset 14,-4
 6310 0004 0346     	 mov r3,r0
4100:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
4101:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xReturn = -pdFREERTOS_ERRNO_EINVAL;
4102:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
4103:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else
4104:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
4105:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( ( pxSocket->pxSocketSet != NULL ) && ( pxSocket->pxSocketSet->xSelectGroup != NULL ) )
 6311              	 .loc 1 4105 0
 6312 0006 C26A     	 ldr r2,[r0,#44]
 6313 0008 32B1     	 cbz r2,.L562
 6314              	 .loc 1 4105 0 is_stmt 0 discriminator 1
 6315 000a 1068     	 ldr r0,[r2]
 6316              	.LVL853:
 6317 000c 20B1     	 cbz r0,.L562
4106:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
4107:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			( void ) xEventGroupSetBits( pxSocket->pxSocketSet->xSelectGroup, ( EventBits_t ) eSELECT_INTR )
 6318              	 .loc 1 4107 0 is_stmt 1
 6319 000e 0821     	 movs r1,#8
 6320 0010 FFF7FEFF 	 bl xEventGroupSetBits
 6321              	.LVL854:
4108:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xReturn = 0;
 6322              	 .loc 1 4108 0
 6323 0014 0020     	 movs r0,#0
 6324 0016 08BD     	 pop {r3,pc}
 6325              	.LVL855:
 6326              	.L562:
4109:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
4110:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else
4111:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	#endif /* ipconfigSUPPORT_SELECT_FUNCTION */
4112:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		if( pxSocket->xEventGroup != NULL )
 6327              	 .loc 1 4112 0
 6328 0018 5868     	 ldr r0,[r3,#4]
 6329 001a 38B1     	 cbz r0,.L564
4113:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
4114:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			( void ) xEventGroupSetBits( pxSocket->xEventGroup, ( EventBits_t ) eSOCKET_INTR );
 6330              	 .loc 1 4114 0
 6331 001c 4021     	 movs r1,#64
 6332 001e FFF7FEFF 	 bl xEventGroupSetBits
 6333              	.LVL856:
4115:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xReturn = 0;
 6334              	 .loc 1 4115 0
 6335 0022 0020     	 movs r0,#0
 6336 0024 08BD     	 pop {r3,pc}
 6337              	.LVL857:
 6338              	.L563:
 6339              	.LCFI82:
 6340              	 .cfi_def_cfa_offset 0
 6341              	 .cfi_restore 3
 6342              	 .cfi_restore 14
4101:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 6343              	 .loc 1 4101 0
 6344 0026 6FF01500 	 mvn r0,#21
 6345              	.LVL858:
4116:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
4117:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		else
4118:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		{
4119:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 			xReturn = -pdFREERTOS_ERRNO_EINVAL;
4120:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
4121:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
4122:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		return xReturn;
4123:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 6346              	 .loc 1 4123 0
 6347 002a 7047     	 bx lr
 6348              	.LVL859:
 6349              	.L564:
 6350              	.LCFI83:
 6351              	 .cfi_def_cfa_offset 8
 6352              	 .cfi_offset 3,-8
 6353              	 .cfi_offset 14,-4
4119:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		}
 6354              	 .loc 1 4119 0
 6355 002c 6FF01500 	 mvn r0,#21
 6356              	.LVL860:
 6357              	 .loc 1 4123 0
 6358 0030 08BD     	 pop {r3,pc}
 6359              	 .cfi_endproc
 6360              	.LFE108:
 6362 0032 00BF     	 .section .text.FreeRTOS_SignalSocketFromISR,"ax",%progbits
 6363              	 .align 2
 6364              	 .global FreeRTOS_SignalSocketFromISR
 6365              	 .thumb
 6366              	 .thumb_func
 6368              	FreeRTOS_SignalSocketFromISR:
 6369              	.LFB109:
4124:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
4125:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #endif /* ipconfigSUPPORT_SIGNALS */
4126:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** /*-----------------------------------------------------------*/
4127:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
4128:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** #if( ipconfigSUPPORT_SIGNALS != 0 )
4129:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
4130:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	/* Send a signal to the task which reads from this socket (FromISR version). */
4131:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t FreeRTOS_SignalSocketFromISR( Socket_t xSocket, BaseType_t *pxHigherPriorityTaskWoken )
4132:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	{
 6370              	 .loc 1 4132 0
 6371              	 .cfi_startproc
 6372              	 
 6373              	 
 6374              	.LVL861:
4133:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
4134:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	BaseType_t xReturn;
4135:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	IPStackEvent_t xEvent;
4136:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
4137:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		configASSERT( pxSocket != NULL );
 6375              	 .loc 1 4137 0
 6376 0000 40B9     	 cbnz r0,.L567
 6377              	.LBB406:
 6378              	.LBB407:
 6379              	 .loc 2 197 0
 6380              	
 6381 0002 4FF01403 	 mov r3,#20
 6382 0006 83F31188 	 msr basepri,r3
 6383 000a BFF36F8F 	 isb 
 6384 000e BFF34F8F 	 dsb 
 6385              	
 6386              	
 6387              	.LVL862:
 6388              	 .thumb
 6389              	.L568:
 6390              	.LBE407:
 6391              	.LBE406:
 6392              	 .loc 1 4137 0 discriminator 1
 6393 0012 FEE7     	 b .L568
 6394              	.L567:
4138:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		configASSERT( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_TCP );
 6395              	 .loc 1 4138 0
 6396 0014 90F82720 	 ldrb r2,[r0,#39]
 6397 0018 062A     	 cmp r2,#6
 6398 001a 08D0     	 beq .L569
 6399              	.LBB408:
 6400              	.LBB409:
 6401              	 .loc 2 197 0
 6402              	
 6403 001c 4FF01403 	 mov r3,#20
 6404 0020 83F31188 	 msr basepri,r3
 6405 0024 BFF36F8F 	 isb 
 6406 0028 BFF34F8F 	 dsb 
 6407              	
 6408              	
 6409              	.LVL863:
 6410              	 .thumb
 6411              	.L570:
 6412              	.LBE409:
 6413              	.LBE408:
 6414              	 .loc 1 4138 0 discriminator 2
 6415 002c FEE7     	 b .L570
 6416              	.L569:
4139:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		configASSERT( pxSocket->xEventGroup != NULL );
 6417              	 .loc 1 4139 0
 6418 002e 4268     	 ldr r2,[r0,#4]
 6419 0030 42B9     	 cbnz r2,.L571
 6420              	.LBB410:
 6421              	.LBB411:
 6422              	 .loc 2 197 0
 6423              	
 6424 0032 4FF01403 	 mov r3,#20
 6425 0036 83F31188 	 msr basepri,r3
 6426 003a BFF36F8F 	 isb 
 6427 003e BFF34F8F 	 dsb 
 6428              	
 6429              	
 6430              	.LVL864:
 6431              	 .thumb
 6432              	.L572:
 6433              	.LBE411:
 6434              	.LBE410:
 6435              	 .loc 1 4139 0 discriminator 3
 6436 0042 FEE7     	 b .L572
 6437              	.L571:
4132:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
 6438              	 .loc 1 4132 0
 6439 0044 00B5     	 push {lr}
 6440              	.LCFI84:
 6441              	 .cfi_def_cfa_offset 4
 6442              	 .cfi_offset 14,-4
 6443 0046 83B0     	 sub sp,sp,#12
 6444              	.LCFI85:
 6445              	 .cfi_def_cfa_offset 16
 6446 0048 0A46     	 mov r2,r1
4140:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
4141:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		xEvent.eEventType = eSocketSignalEvent;
 6447              	 .loc 1 4141 0
 6448 004a 0C21     	 movs r1,#12
 6449              	.LVL865:
 6450 004c 8DF80010 	 strb r1,[sp]
4142:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		xEvent.pvData = pxSocket;
 6451              	 .loc 1 4142 0
 6452 0050 0190     	 str r0,[sp,#4]
4143:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
4144:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		/* The IP-task will call FreeRTOS_SignalSocket for this socket. */
4145:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		xReturn = xQueueSendToBackFromISR( xNetworkEventQueue, &xEvent, pxHigherPriorityTaskWoken );
 6453              	 .loc 1 4145 0
 6454 0052 044B     	 ldr r3,.L574
 6455 0054 1868     	 ldr r0,[r3]
 6456              	.LVL866:
 6457 0056 6946     	 mov r1,sp
 6458 0058 0023     	 movs r3,#0
 6459 005a FFF7FEFF 	 bl xQueueGenericSendFromISR
 6460              	.LVL867:
4146:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 
4147:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 		return xReturn;
4148:../FreeRTOS-Plus-TCP/FreeRTOS_Sockets.c **** 	}
 6461              	 .loc 1 4148 0
 6462 005e 03B0     	 add sp,sp,#12
 6463              	.LCFI86:
 6464              	 .cfi_def_cfa_offset 4
 6465              	 
 6466 0060 5DF804FB 	 ldr pc,[sp],#4
 6467              	.L575:
 6468              	 .align 2
 6469              	.L574:
 6470 0064 00000000 	 .word xNetworkEventQueue
 6471              	 .cfi_endproc
 6472              	.LFE109:
 6474              	 .comm xBoundTCPSocketsList,20,4
 6475              	 .section .bss.xLastTime.7250,"aw",%nobits
 6476              	 .align 2
 6477              	 .set .LANCHOR2,.+0
 6480              	xLastTime.7250:
 6481 0000 00000000 	 .space 4
 6482              	 .section .bss.xBoundUDPSocketsList,"aw",%nobits
 6483              	 .align 2
 6484              	 .set .LANCHOR0,.+0
 6487              	xBoundUDPSocketsList:
 6488 0000 00000000 	 .space 20
 6488      00000000 
 6488      00000000 
 6488      00000000 
 6488      00000000 
 6489              	 .section .bss.xBoundRAWSocketsList,"aw",%nobits
 6490              	 .align 2
 6491              	 .set .LANCHOR1,.+0
 6494              	xBoundRAWSocketsList:
 6495 0000 00000000 	 .space 20
 6495      00000000 
 6495      00000000 
 6495      00000000 
 6495      00000000 
 6496              	 .text
 6497              	.Letext0:
 6498              	 .file 5 "e:\\embedded\\dave_4-4-2_64bit_2018-02-23\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 6499              	 .file 6 "e:\\embedded\\dave_4-4-2_64bit_2018-02-23\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 6500              	 .file 7 "e:\\embedded\\dave_4-4-2_64bit_2018-02-23\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\lib\\gcc\\arm-none-eabi\\4.9.3\\include\\stddef.h"
 6501              	 .file 8 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/include/list.h"
 6502              	 .file 9 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/include/task.h"
 6503              	 .file 10 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/include/queue.h"
 6504              	 .file 11 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/include/event_groups.h"
 6505              	 .file 12 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include/FreeRTOS_Sockets.h"
 6506              	 .file 13 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include/FreeRTOS_IP_Private.h"
 6507              	 .file 14 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include/FreeRTOS_TCP_WIN.h"
 6508              	 .file 15 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include/FreeRTOS_TCP_IP.h"
 6509              	 .file 16 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/include/portable.h"
 6510              	 .file 17 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include/NetworkBufferManagement.h"
DEFINED SYMBOLS
                            *ABS*:00000000 FreeRTOS_Sockets.c
    {standard input}:19     .text.prvValidSocket:00000000 $t
    {standard input}:23     .text.prvValidSocket:00000000 prvValidSocket
    {standard input}:68     .text.pxListFindListItemWithValue:00000000 $t
    {standard input}:72     .text.pxListFindListItemWithValue:00000000 pxListFindListItemWithValue
    {standard input}:147    .text.prvFindSelectedSocket:00000000 $t
    {standard input}:151    .text.prvFindSelectedSocket:00000000 prvFindSelectedSocket
    {standard input}:204    .text.vNetworkSocketsInit:00000000 $t
    {standard input}:209    .text.vNetworkSocketsInit:00000000 vNetworkSocketsInit
    {standard input}:236    .text.vNetworkSocketsInit:00000018 $d
                            *COM*:00000014 xBoundTCPSocketsList
    {standard input}:243    .text.FreeRTOS_socket:00000000 $t
    {standard input}:248    .text.FreeRTOS_socket:00000000 FreeRTOS_socket
    {standard input}:617    .text.FreeRTOS_socket:000001bc $d
    {standard input}:624    .text.FreeRTOS_CreateSocketSet:00000000 $t
    {standard input}:629    .text.FreeRTOS_CreateSocketSet:00000000 FreeRTOS_CreateSocketSet
    {standard input}:676    .text.FreeRTOS_DeleteSocketSet:00000000 $t
    {standard input}:681    .text.FreeRTOS_DeleteSocketSet:00000000 FreeRTOS_DeleteSocketSet
    {standard input}:709    .text.FreeRTOS_FD_SET:00000000 $t
    {standard input}:714    .text.FreeRTOS_FD_SET:00000000 FreeRTOS_FD_SET
    {standard input}:790    .text.FreeRTOS_FD_CLR:00000000 $t
    {standard input}:795    .text.FreeRTOS_FD_CLR:00000000 FreeRTOS_FD_CLR
    {standard input}:864    .text.FreeRTOS_FD_ISSET:00000000 $t
    {standard input}:869    .text.FreeRTOS_FD_ISSET:00000000 FreeRTOS_FD_ISSET
    {standard input}:935    .text.FreeRTOS_select:00000000 $t
    {standard input}:940    .text.FreeRTOS_select:00000000 FreeRTOS_select
    {standard input}:1047   .text.FreeRTOS_recvfrom:00000000 $t
    {standard input}:1052   .text.FreeRTOS_recvfrom:00000000 FreeRTOS_recvfrom
    {standard input}:1340   .text.FreeRTOS_bind:00000000 $t
    {standard input}:1345   .text.FreeRTOS_bind:00000000 FreeRTOS_bind
    {standard input}:1457   .text.FreeRTOS_sendto:00000000 $t
    {standard input}:1462   .text.FreeRTOS_sendto:00000000 FreeRTOS_sendto
    {standard input}:1723   .text.vSocketBind:00000000 $t
    {standard input}:1728   .text.vSocketBind:00000000 vSocketBind
    {standard input}:1983   .text.vSocketBind:00000130 $d
    {standard input}:1991   .text.FreeRTOS_closesocket:00000000 $t
    {standard input}:1996   .text.FreeRTOS_closesocket:00000000 FreeRTOS_closesocket
    {standard input}:2047   .text.vSocketClose:00000000 $t
    {standard input}:2052   .text.vSocketClose:00000000 vSocketClose
    {standard input}:2192   .text.vSocketClose:000000a0 $d
    {standard input}:2197   .text.pxUDPSocketLookup:00000000 $t
    {standard input}:2202   .text.pxUDPSocketLookup:00000000 pxUDPSocketLookup
    {standard input}:2256   .text.pxUDPSocketLookup:00000028 $d
    {standard input}:2261   .text.FreeRTOS_inet_ntoa:00000000 $t
    {standard input}:2266   .text.FreeRTOS_inet_ntoa:00000000 FreeRTOS_inet_ntoa
    {standard input}:2421   .text.FreeRTOS_inet_ntoa:000000b4 $d
    {standard input}:2426   .text.FreeRTOS_inet_ntop4:00000000 $t
    {standard input}:2431   .text.FreeRTOS_inet_ntop4:00000000 FreeRTOS_inet_ntop4
    {standard input}:2477   .text.FreeRTOS_inet_ntop:00000000 $t
    {standard input}:2482   .text.FreeRTOS_inet_ntop:00000000 FreeRTOS_inet_ntop
    {standard input}:2523   .text.FreeRTOS_inet_pton4:00000000 $t
    {standard input}:2528   .text.FreeRTOS_inet_pton4:00000000 FreeRTOS_inet_pton4
    {standard input}:2712   .text.FreeRTOS_inet_pton:00000000 $t
    {standard input}:2717   .text.FreeRTOS_inet_pton:00000000 FreeRTOS_inet_pton
    {standard input}:2756   .text.FreeRTOS_inet_addr:00000000 $t
    {standard input}:2761   .text.FreeRTOS_inet_addr:00000000 FreeRTOS_inet_addr
    {standard input}:2793   .text.FreeRTOS_GetLocalAddress:00000000 $t
    {standard input}:2798   .text.FreeRTOS_GetLocalAddress:00000000 FreeRTOS_GetLocalAddress
    {standard input}:2822   .text.FreeRTOS_GetLocalAddress:00000014 $d
    {standard input}:2827   .text.vSocketWakeUpUser:00000000 $t
    {standard input}:2832   .text.vSocketWakeUpUser:00000000 vSocketWakeUpUser
    {standard input}:2887   .text.FreeRTOS_accept:00000000 $t
    {standard input}:2892   .text.FreeRTOS_accept:00000000 FreeRTOS_accept
    {standard input}:3104   .text.FreeRTOS_recv:00000000 $t
    {standard input}:3109   .text.FreeRTOS_recv:00000000 FreeRTOS_recv
    {standard input}:3514   .text.FreeRTOS_get_tx_head:00000000 $t
    {standard input}:3519   .text.FreeRTOS_get_tx_head:00000000 FreeRTOS_get_tx_head
    {standard input}:3619   .text.FreeRTOS_send:00000000 $t
    {standard input}:3624   .text.FreeRTOS_send:00000000 FreeRTOS_send
    {standard input}:3998   .text.FreeRTOS_listen:00000000 $t
    {standard input}:4003   .text.FreeRTOS_listen:00000000 FreeRTOS_listen
    {standard input}:4131   .text.FreeRTOS_shutdown:00000000 $t
    {standard input}:4136   .text.FreeRTOS_shutdown:00000000 FreeRTOS_shutdown
    {standard input}:4191   .text.xTCPTimerCheck:00000000 $t
    {standard input}:4196   .text.xTCPTimerCheck:00000000 xTCPTimerCheck
    {standard input}:4316   .text.xTCPTimerCheck:00000084 $d
    {standard input}:4322   .text.pxTCPSocketLookup:00000000 $t
    {standard input}:4327   .text.pxTCPSocketLookup:00000000 pxTCPSocketLookup
    {standard input}:4423   .text.pxTCPSocketLookup:00000048 $d
    {standard input}:4429   .text.FreeRTOS_get_rx_buf:00000000 $t
    {standard input}:4434   .text.FreeRTOS_get_rx_buf:00000000 FreeRTOS_get_rx_buf
    {standard input}:4467   .text.lTCPAddRxdata:00000000 $t
    {standard input}:4472   .text.lTCPAddRxdata:00000000 lTCPAddRxdata
    {standard input}:4669   .text.lTCPAddRxdata:000000f0 $d
    {standard input}:4674   .text.FreeRTOS_GetRemoteAddress:00000000 $t
    {standard input}:4679   .text.FreeRTOS_GetRemoteAddress:00000000 FreeRTOS_GetRemoteAddress
    {standard input}:4739   .text.FreeRTOS_maywrite:00000000 $t
    {standard input}:4744   .text.FreeRTOS_maywrite:00000000 FreeRTOS_maywrite
    {standard input}:4822   .text.FreeRTOS_tx_space:00000000 $t
    {standard input}:4827   .text.FreeRTOS_tx_space:00000000 FreeRTOS_tx_space
    {standard input}:4891   .text.FreeRTOS_tx_size:00000000 $t
    {standard input}:4896   .text.FreeRTOS_tx_size:00000000 FreeRTOS_tx_size
    {standard input}:4959   .text.FreeRTOS_setsockopt:00000000 $t
    {standard input}:4964   .text.FreeRTOS_setsockopt:00000000 FreeRTOS_setsockopt
    {standard input}:4988   .text.FreeRTOS_setsockopt:00000018 $d
    {standard input}:5007   .text.FreeRTOS_setsockopt:0000003e $t
    {standard input}:5522   .text.FreeRTOS_issocketconnected:00000000 $t
    {standard input}:5527   .text.FreeRTOS_issocketconnected:00000000 FreeRTOS_issocketconnected
    {standard input}:5560   .text.FreeRTOS_connect:00000000 $t
    {standard input}:5565   .text.FreeRTOS_connect:00000000 FreeRTOS_connect
    {standard input}:5807   .text.FreeRTOS_mss:00000000 $t
    {standard input}:5812   .text.FreeRTOS_mss:00000000 FreeRTOS_mss
    {standard input}:5836   .text.FreeRTOS_connstatus:00000000 $t
    {standard input}:5841   .text.FreeRTOS_connstatus:00000000 FreeRTOS_connstatus
    {standard input}:5865   .text.FreeRTOS_rx_size:00000000 $t
    {standard input}:5870   .text.FreeRTOS_rx_size:00000000 FreeRTOS_rx_size
    {standard input}:5933   .text.FreeRTOS_netstat:00000000 $t
    {standard input}:5938   .text.FreeRTOS_netstat:00000000 FreeRTOS_netstat
    {standard input}:5972   .text.vSocketSelect:00000000 $t
    {standard input}:5977   .text.vSocketSelect:00000000 vSocketSelect
    {standard input}:6282   .text.vSocketSelect:00000190 $d
    {standard input}:6290   .text.FreeRTOS_SignalSocket:00000000 $t
    {standard input}:6295   .text.FreeRTOS_SignalSocket:00000000 FreeRTOS_SignalSocket
    {standard input}:6363   .text.FreeRTOS_SignalSocketFromISR:00000000 $t
    {standard input}:6368   .text.FreeRTOS_SignalSocketFromISR:00000000 FreeRTOS_SignalSocketFromISR
    {standard input}:6470   .text.FreeRTOS_SignalSocketFromISR:00000064 $d
    {standard input}:6476   .bss.xLastTime.7250:00000000 $d
    {standard input}:6480   .bss.xLastTime.7250:00000000 xLastTime.7250
    {standard input}:6483   .bss.xBoundUDPSocketsList:00000000 $d
    {standard input}:6487   .bss.xBoundUDPSocketsList:00000000 xBoundUDPSocketsList
    {standard input}:6490   .bss.xBoundRAWSocketsList:00000000 $d
    {standard input}:6494   .bss.xBoundRAWSocketsList:00000000 xBoundRAWSocketsList
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.0.3466fc6a3db32493c997d085de4c7a28
                           .group:00000000 wm4.features.h.22.bee0aee4a3878f51861c775df98fa3ea
                           .group:00000000 wm4._default_types.h.15.933e8edd27a65e0b69af4a865eb623d2
                           .group:00000000 wm4._intsup.h.10.ca9f32a61b410c270a48d1161ca2c217
                           .group:00000000 wm4.stdint.h.22.f4a337c398d8b6d821a97202448bc0d0
                           .group:00000000 wm4.newlib.h.8.fe7d912fc917043c98742c35eddd8cff
                           .group:00000000 wm4.config.h.216.aad1ef7bee4fb69981cb38ce62f84d9c
                           .group:00000000 wm4._ansi.h.23.9f8fcfa20193763fcf364fb91705c94b
                           .group:00000000 wm4.stdio.h.31.7c0e28c411445f3f9c5b11accf882760
                           .group:00000000 wm4.stddef.h.184.159df79b4ca79c76561572a55985524c
                           .group:00000000 wm4.cdefs.h.47.4002528de975c0fcce6c551c15d87b8c
                           .group:00000000 wm4.stddef.h.39.fb88e218f22ad7a0ab38f3d93c6eb3e4
                           .group:00000000 wm4.stdarg.h.34.3a23a216c0c293b3d2ea2e89281481e6
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4._types.h.54.d3d34a3b7f3cc230cd159baf022b4b08
                           .group:00000000 wm4.stddef.h.158.61317cdbfb4026324507d123a50b0fd6
                           .group:00000000 wm4.reent.h.17.8bd9e4098e0428508c282cad794fae43
                           .group:00000000 wm4.types.h.23.0d949686bbcadd1621462d4fa1f884f9
                           .group:00000000 wm4.types.h.2.e9cec8c90ab35f77d9f499e06ae02400
                           .group:00000000 wm4.types.h.80.56707660962b21991903f1fee7c13bb3
                           .group:00000000 wm4.stdio.h.2.4aa87247282eca6c8f36f9de33d8df1a
                           .group:00000000 wm4.stdio.h.65.7c7009d79fb33c27bcf8e2214c76b343
                           .group:00000000 wm4.FreeRTOSConfig.h.30.aa43eb1cb33228d5c7e359a94d48589b
                           .group:00000000 wm4.projdefs.h.28.d6a7c9061b707820f2fcf4c2ff5d9f24
                           .group:00000000 wm4.portmacro.h.30.2ddc2eaf2e032c76c597fb78c4365041
                           .group:00000000 wm4.portable.h.63.e9cc508c3850f44ce542149380c67812
                           .group:00000000 wm4.mpu_wrappers.h.28.163fb40577cf8d1578015ea3f2ff4cdb
                           .group:00000000 wm4.FreeRTOS.h.67.9945f39eea4ddeb224c0782392206292
                           .group:00000000 wm4.list.h.57.02ec67e07eacffe5ca7cfb7326896236
                           .group:00000000 wm4.task.h.47.2d3fe49a094b8ec1e3e6aac441e8db21
                           .group:00000000 wm4.queue.h.66.45d4a3cf5de24cde7e732f8dad25383c
                           .group:00000000 wm4.semphr.h.38.96f44691bfa19eb833944d3a35b81e54
                           .group:00000000 wm4.FreeRTOSIPConfig.h.37.3f9c1db988571ff1f3dec4c7e54978d6
                           .group:00000000 wm4.FreeRTOS_errno_TCP.h.27.708877b341d0e6bcb4ba112b2ad8082a
                           .group:00000000 wm4.FreeRTOSIPConfigDefaults.h.41.f972b11d9b1eba5383080cfaef1fd740
                           .group:00000000 wm4.IPTraceMacroDefaults.h.31.69642530b5a79c93e762c9b09ac0d1d5
                           .group:00000000 wm4.FreeRTOS_IP.h.27.bae156c5eba2da2689f75aad27aa76da
                           .group:00000000 wm4.FreeRTOS_IP.h.179.e5077063e624bc5d3f02542470d6ea94
                           .group:00000000 wm4.string.h.8.c4b8571ce60dff2817f43fec8b86aecd
                           .group:00000000 wm4.stddef.h.158.a7efb00f6cbc6f43213b50e183c9830c
                           .group:00000000 wm4.timers.h.29.025d268d6baf57298309e7b498ee1cc7
                           .group:00000000 wm4.FreeRTOS_Sockets.h.58.61d472da32c0e0f5bc49c368f15d0ac5
                           .group:00000000 wm4.FreeRTOS_TCP_WIN.h.32.f3cfab69924f28284deb16cc1a30fb93
                           .group:00000000 wm4.FreeRTOS_IP_Private.h.52.551f932b14473cea139893dda31b3fa0
                           .group:00000000 wm4.FreeRTOS_IP_Private.h.328.b5788f8d626a4cf16b8282f9399f3f55
                           .group:00000000 wm4.FreeRTOS_DNS.h.27.8432bc3440a9cfc56281e07613f9ce59

UNDEFINED SYMBOLS
xIPIsNetworkTaskReady
xEventGroupClearBits
xSendEventStructToIPTask
xEventGroupWaitBits
vListInitialise
xEventGroupCreate
vPortFree
memset
vListInitialiseItem
pvPortMalloc
vEventGroupDelete
vTaskSetTimeOutState
xTaskCheckForTimeOut
xEventGroupSetBits
uxListRemove
vPortExitCritical
memcpy
vReleaseNetworkBufferAndDescriptor
vPortEnterCritical
xIsCallingFromIPTask
pxGetNetworkBufferWithDescriptor
pxUDPPayloadBuffer_to_NetworkBuffer
xApplicationGetRandomNumber
vListInsertEnd
vTCPWindowDestroy
xDefaultPartUDPPacketHeader
vTaskSuspendAll
xTaskResumeAll
uxStreamBufferGet
xSendEventToIPTask
vTCPStateChange
uxStreamBufferAdd
xTaskGetTickCount
xTCPSocketCheck
xQueueGenericSendFromISR
xNetworkEventQueue
