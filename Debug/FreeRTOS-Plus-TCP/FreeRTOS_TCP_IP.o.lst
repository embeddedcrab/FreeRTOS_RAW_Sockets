   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .eabi_attribute 28,1
   5              	 .fpu fpv4-sp-d16
   6              	 .eabi_attribute 23,1
   7              	 .eabi_attribute 24,1
   8              	 .eabi_attribute 25,1
   9              	 .eabi_attribute 26,1
  10              	 .eabi_attribute 30,1
  11              	 .eabi_attribute 34,1
  12              	 .eabi_attribute 18,4
  13              	 .thumb
  14              	 .file "FreeRTOS_TCP_IP.c"
  15              	 .text
  16              	.Ltext0:
  17              	 .cfi_sections .debug_frame
  18              	 .section .text.prvTCPAddTxData,"ax",%progbits
  19              	 .align 2
  20              	 .thumb
  21              	 .thumb_func
  23              	prvTCPAddTxData:
  24              	.LFB68:
  25              	 .file 1 "../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c"
   1:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
   2:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * FreeRTOS+TCP V2.2.2
   3:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  *
   5:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * this software and associated documentation files (the "Software"), to deal in
   7:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * the Software without restriction, including without limitation the rights to
   8:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * subject to the following conditions:
  11:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  *
  12:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * The above copyright notice and this permission notice shall be included in all
  13:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * copies or substantial portions of the Software.
  14:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  *
  15:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  *
  22:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * http://aws.amazon.com/freertos
  23:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * http://www.FreeRTOS.org
  24:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
  25:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
  26:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
  27:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * FreeRTOS_TCP_IP.c
  28:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Module which handles the TCP connections for FreeRTOS+TCP.
  29:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * It depends on  FreeRTOS_TCP_WIN.c, which handles the TCP windowing
  30:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * schemes.
  31:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  *
  32:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Endianness: in this module all ports and IP addresses are stored in
  33:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * host byte-order, except fields in the IP-packets
  34:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
  35:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
  36:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /* Standard includes. */
  37:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #include <stdint.h>
  38:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #include <stdio.h>
  39:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
  40:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /* FreeRTOS includes. */
  41:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #include "FreeRTOS.h"
  42:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #include "task.h"
  43:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #include "queue.h"
  44:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #include "semphr.h"
  45:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
  46:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /* FreeRTOS+TCP includes. */
  47:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #include "FreeRTOS_IP.h"
  48:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #include "FreeRTOS_Sockets.h"
  49:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #include "FreeRTOS_IP_Private.h"
  50:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #include "FreeRTOS_UDP_IP.h"
  51:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #include "FreeRTOS_DHCP.h"
  52:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #include "NetworkInterface.h"
  53:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #include "NetworkBufferManagement.h"
  54:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #include "FreeRTOS_ARP.h"
  55:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
  56:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
  57:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #include "FreeRTOSIPConfigDefaults.h"
  58:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
  59:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
  60:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /* Just make sure the contents doesn't get compiled if TCP is not enabled. */
  61:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #if ipconfigUSE_TCP == 1
  62:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
  63:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*lint -e750  local macro not referenced [MISRA 2012 Rule 2.5, advisory] */
  64:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
  65:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
  66:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * The meaning of the TCP flags:
  67:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
  68:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #define tcpTCP_FLAG_FIN				( ( uint8_t ) 0x01U ) /* No more data from sender */
  69:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #define tcpTCP_FLAG_SYN				( ( uint8_t ) 0x02U ) /* Synchronize sequence numbers */
  70:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #define tcpTCP_FLAG_RST				( ( uint8_t ) 0x04U ) /* Reset the connection */
  71:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #define tcpTCP_FLAG_PSH				( ( uint8_t ) 0x08U ) /* Push function: please push buffered data to the
  72:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #define tcpTCP_FLAG_ACK				( ( uint8_t ) 0x10U ) /* Acknowledgment field is significant */
  73:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #define tcpTCP_FLAG_URG				( ( uint8_t ) 0x20U ) /* Urgent pointer field is significant */
  74:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #define tcpTCP_FLAG_ECN				( ( uint8_t ) 0x40U ) /* ECN-Echo */
  75:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #define tcpTCP_FLAG_CWR				( ( uint8_t ) 0x80U ) /* Congestion Window Reduced */
  76:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
  77:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /* A mask to filter all protocol flags. */
  78:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #define tcpTCP_FLAG_CTRL			( ( uint8_t ) 0x1FU )
  79:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
  80:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
  81:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * A few values of the TCP options:
  82:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
  83:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #define tcpTCP_OPT_END				0U   /* End of TCP options list */
  84:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #define tcpTCP_OPT_NOOP				1U   /* "No-operation" TCP option */
  85:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #define tcpTCP_OPT_MSS				2U   /* Maximum segment size TCP option */
  86:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #define tcpTCP_OPT_WSOPT			3U   /* TCP Window Scale Option (3-byte long) */
  87:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #define tcpTCP_OPT_SACK_P			4U   /* Advertize that SACK is permitted */
  88:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #define tcpTCP_OPT_SACK_A			5U   /* SACK option with first/last */
  89:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #define tcpTCP_OPT_TIMESTAMP		8U   /* Time-stamp option */
  90:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
  91:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #define tcpTCP_OPT_MSS_LEN			4U   /* Length of TCP MSS option. */
  92:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #define tcpTCP_OPT_WSOPT_LEN		3U   /* Length of TCP WSOPT option. */
  93:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
  94:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #define tcpTCP_OPT_TIMESTAMP_LEN	10	/* fixed length of the time-stamp option */
  95:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
  96:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #ifndef ipconfigTCP_ACK_EARLIER_PACKET
  97:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#define ipconfigTCP_ACK_EARLIER_PACKET		1
  98:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #endif
  99:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 100:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 101:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * The macro tcpNOW_CONNECTED() is use to determine if the connection makes a
 102:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * transition from connected to non-connected and vice versa.
 103:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * tcpNOW_CONNECTED() returns true when the status has one of these values:
 104:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * eESTABLISHED, eFIN_WAIT_1, eFIN_WAIT_2, eCLOSING, eLAST_ACK, eTIME_WAIT
 105:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Technically the connection status is closed earlier, but the library wants
 106:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * to prevent that the socket will be deleted before the last ACK has been
 107:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * and thus causing a 'RST' packet on either side.
 108:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 109:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #define tcpNOW_CONNECTED( status )\
 110:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	( ( ( ( status ) >= ( BaseType_t ) eESTABLISHED ) && ( ( status ) != ( BaseType_t ) eCLOSE_WAIT ) 
 111:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 112:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 113:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * The highest 4 bits in the TCP offset byte indicate the total length of the
 114:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * TCP header, divided by 4.
 115:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 116:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #define tcpVALID_BITS_IN_TCP_OFFSET_BYTE	( 0xF0U )
 117:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 118:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 119:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Acknowledgements to TCP data packets may be delayed as long as more is being expected.
 120:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * A normal delay would be 200ms.  Here a much shorter delay of 20 ms is being used to
 121:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * gain performance.
 122:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 123:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #define tcpDELAYED_ACK_SHORT_DELAY_MS			( 2 )	/* Should not become smaller than 1. */
 124:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #define tcpDELAYED_ACK_LONGER_DELAY_MS			( 20 )
 125:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 126:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 127:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * The MSS (Maximum Segment Size) will be taken as large as possible. However, packets with
 128:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * an MSS of 1460 bytes won't be transported through the internet.  The MSS will be reduced
 129:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * to 1400 bytes.
 130:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 131:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #define tcpREDUCED_MSS_THROUGH_INTERNET		( 1400 )
 132:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 133:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 134:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * When there are no TCP options, the TCP offset equals 20 bytes, which is stored as
 135:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * the number 5 (words) in the higher niblle of the TCP-offset byte.
 136:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 137:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #define tcpTCP_OFFSET_LENGTH_BITS			( 0xf0U )
 138:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #define tcpTCP_OFFSET_STANDARD_LENGTH		( 0x50U )
 139:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 140:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 141:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Each TCP socket is checked regularly to see if it can send data packets.
 142:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * By default, the maximum number of packets sent during one check is limited to 8.
 143:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * This amount may be further limited by setting the socket's TX window size.
 144:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 145:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #if( !defined( SEND_REPEATED_COUNT ) )
 146:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#define SEND_REPEATED_COUNT		( 8 )
 147:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #endif /* !defined( SEND_REPEATED_COUNT ) */
 148:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 149:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 150:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Define a maximum perdiod of time (ms) to leave a TCP-socket unattended.
 151:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * When a TCP timer expires, retries and keep-alive messages will be checked.
 152:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 153:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #ifndef	tcpMAXIMUM_TCP_WAKEUP_TIME_MS
 154:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#define	tcpMAXIMUM_TCP_WAKEUP_TIME_MS		20000U
 155:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #endif
 156:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 157:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /* Two macro's that were introduced to work with both IPv4 and IPv6. */
 158:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #define xIPHeaderSize( pxNetworkBuffer )	( ipSIZE_OF_IPv4_HEADER )
 159:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #define uxIPHeaderSizeSocket( pxSocket )	( ipSIZE_OF_IPv4_HEADER )
 160:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 161:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 162:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Returns true if the socket must be checked.  Non-active sockets are waiting
 163:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * for user action, either connect() or close().
 164:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 165:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static BaseType_t prvTCPSocketIsActive( eIPTCPState_t xStatus );
 166:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 167:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 168:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Either sends a SYN or calls prvTCPSendRepeated (for regular messages).
 169:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 170:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static int32_t prvTCPSendPacket( FreeRTOS_Socket_t *pxSocket );
 171:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 172:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 173:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Try to send a series of messages.
 174:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 175:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static int32_t prvTCPSendRepeated( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **ppxNetw
 176:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 177:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 178:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Return or send a packet to the other party.
 179:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 180:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static void prvTCPReturnPacket( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t *pxDescripto
 181:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	uint32_t ulLen, BaseType_t xReleaseAfterSend );
 182:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 183:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 184:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Initialise the data structures which keep track of the TCP windowing system.
 185:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 186:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static void prvTCPCreateWindow( FreeRTOS_Socket_t *pxSocket );
 187:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 188:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 189:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Let ARP look-up the MAC-address of the peer and initialise the first SYN
 190:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * packet.
 191:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 192:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static BaseType_t prvTCPPrepareConnect( FreeRTOS_Socket_t *pxSocket );
 193:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 194:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #if( ipconfigHAS_DEBUG_PRINTF != 0 )
 195:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	/*
 196:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	 * For logging and debugging: make a string showing the TCP flags.
 197:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	 */
 198:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	static const char *prvTCPFlagMeaning( UBaseType_t xFlags);
 199:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #endif /* ipconfigHAS_DEBUG_PRINTF != 0 */
 200:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 201:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 202:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Parse the TCP option(s) received, if present.
 203:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 204:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** _static void prvCheckOptions( FreeRTOS_Socket_t *pxSocket, const NetworkBufferDescriptor_t *pxNetwo
 205:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 206:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 207:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Identify and deal with a single TCP header option, advancing the pointer to
 208:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * the header. This function returns pdTRUE or pdFALSE depending on whether the
 209:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * caller should continue to parse more header options or break the loop.
 210:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 211:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** _static size_t prvSingleStepTCPHeaderOptions( const uint8_t * const pucPtr,
 212:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 											 size_t uxTotalLength,
 213:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 											 FreeRTOS_Socket_t * const pxSocket,
 214:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 											 BaseType_t xHasSYNFlag );
 215:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 216:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #if( ipconfigUSE_TCP_WIN == 1 )
 217:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	/*
 218:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	 * Skip past TCP header options when doing Selective ACK, until there are no
 219:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	 * more options left.
 220:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	 */
 221:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	_static void prvReadSackOption( const uint8_t * const pucPtr,
 222:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 								   size_t uxIndex,
 223:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 								   FreeRTOS_Socket_t * const pxSocket );
 224:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #endif/* ( ipconfigUSE_TCP_WIN == 1 ) */
 225:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 226:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 227:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 228:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Set the initial properties in the options fields, like the preferred
 229:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * value of MSS and whether SACK allowed.  Will be transmitted in the state
 230:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * 'eCONNECT_SYN'.
 231:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 232:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static UBaseType_t prvSetSynAckOptions( FreeRTOS_Socket_t *pxSocket, TCPHeader_t *pxTCPHeader );
 233:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 234:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 235:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * For anti-hang protection and TCP keep-alive messages.  Called in two places:
 236:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * after receiving a packet and after a state change.  The socket's alive timer
 237:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * may be reset.
 238:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 239:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static void prvTCPTouchSocket( FreeRTOS_Socket_t *pxSocket );
 240:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 241:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 242:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Prepare an outgoing message, if anything has to be sent.
 243:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 244:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static int32_t prvTCPPrepareSend( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **ppxNetwo
 245:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 246:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 247:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Calculate when this socket needs to be checked to do (re-)transmissions.
 248:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 249:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static TickType_t prvTCPNextTimeout( FreeRTOS_Socket_t *pxSocket );
 250:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 251:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 252:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * The API FreeRTOS_send() adds data to the TX stream.  Add
 253:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * this data to the windowing system to it can be transmitted.
 254:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 255:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static void prvTCPAddTxData( FreeRTOS_Socket_t *pxSocket );
 256:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 257:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 258:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  *  Called to handle the closure of a TCP connection.
 259:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 260:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static BaseType_t prvTCPHandleFin( FreeRTOS_Socket_t *pxSocket, const NetworkBufferDescriptor_t *px
 261:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 262:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 263:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Called from prvTCPHandleState().  Find the TCP payload data and check and
 264:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * return its length.
 265:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 266:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static BaseType_t prvCheckRxData( const NetworkBufferDescriptor_t *pxNetworkBuffer, uint8_t **ppucR
 267:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 268:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 269:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Called from prvTCPHandleState().  Check if the payload data may be accepted.
 270:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * If so, it will be added to the socket's reception queue.
 271:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 272:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static BaseType_t prvStoreRxData( FreeRTOS_Socket_t *pxSocket, const uint8_t *pucRecvData,
 273:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	NetworkBufferDescriptor_t *pxNetworkBuffer, uint32_t ulReceiveLength );
 274:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 275:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 276:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Set the TCP options (if any) for the outgoing packet.
 277:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 278:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static UBaseType_t prvSetOptions( FreeRTOS_Socket_t *pxSocket, const NetworkBufferDescriptor_t *pxN
 279:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 280:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 281:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Called from prvTCPHandleState() as long as the TCP status is eSYN_RECEIVED to
 282:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * eCONNECT_SYN.
 283:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 284:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static BaseType_t prvHandleSynReceived( FreeRTOS_Socket_t *pxSocket, const NetworkBufferDescriptor_
 285:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	uint32_t ulReceiveLength, UBaseType_t uxOptionsLength );
 286:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 287:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 288:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Called from prvTCPHandleState() as long as the TCP status is eESTABLISHED.
 289:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 290:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static BaseType_t prvHandleEstablished( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **pp
 291:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	uint32_t ulReceiveLength, UBaseType_t uxOptionsLength );
 292:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 293:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 294:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Called from prvTCPHandleState().  There is data to be sent.
 295:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * If ipconfigUSE_TCP_WIN is defined, and if only an ACK must be sent, it will
 296:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * be checked if it would better be postponed for efficiency.
 297:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 298:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static BaseType_t prvSendData( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **ppxNetworkB
 299:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	uint32_t ulReceiveLength, BaseType_t xByteCount );
 300:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 301:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 302:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * The heart of all: check incoming packet for valid data and acks and do what
 303:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * is necessary in each state.
 304:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 305:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static BaseType_t prvTCPHandleState( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **ppxNe
 306:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 307:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 308:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Common code for sending a TCP protocol control packet (i.e. no options, no
 309:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * payload, just flags).
 310:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 311:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static BaseType_t prvTCPSendSpecialPacketHelper( NetworkBufferDescriptor_t *pxNetworkBuffer,
 312:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 												 uint8_t ucTCPFlags );
 313:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 314:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 315:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * A "challenge ACK" is as per https://tools.ietf.org/html/rfc5961#section-3.2,
 316:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * case #3. In summary, an RST was received with a sequence number that is
 317:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * unexpected but still within the window.
 318:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 319:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static BaseType_t prvTCPSendChallengeAck( NetworkBufferDescriptor_t *pxNetworkBuffer );
 320:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 321:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 322:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Reply to a peer with the RST flag on, in case a packet can not be handled.
 323:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 324:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static BaseType_t prvTCPSendReset( NetworkBufferDescriptor_t *pxNetworkBuffer );
 325:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 326:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 327:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Set the initial value for MSS (Maximum Segment Size) to be used.
 328:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 329:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static void prvSocketSetMSS( FreeRTOS_Socket_t *pxSocket );
 330:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 331:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 332:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Return either a newly created socket, or the current socket in a connected
 333:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * state (depends on the 'bReuseSocket' flag).
 334:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 335:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static FreeRTOS_Socket_t *prvHandleListen( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t *
 336:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 337:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 338:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * After a listening socket receives a new connection, it may duplicate itself.
 339:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * The copying takes place in prvTCPSocketCopy.
 340:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 341:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static BaseType_t prvTCPSocketCopy( FreeRTOS_Socket_t *pxNewSocket, FreeRTOS_Socket_t *pxSocket );
 342:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 343:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 344:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * prvTCPStatusAgeCheck() will see if the socket has been in a non-connected
 345:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * state for too long.  If so, the socket will be closed, and -1 will be
 346:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * returned.
 347:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 348:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #if( ipconfigTCP_HANG_PROTECTION == 1 )
 349:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	static BaseType_t prvTCPStatusAgeCheck( FreeRTOS_Socket_t *pxSocket );
 350:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #endif
 351:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 352:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static NetworkBufferDescriptor_t *prvTCPBufferResize( const FreeRTOS_Socket_t *pxSocket, NetworkBuf
 353:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	int32_t lDataLen, UBaseType_t uxOptionsLength );
 354:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 355:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #if( ipconfigUSE_TCP_WIN != 0 )
 356:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	static uint8_t prvWinScaleFactor( const FreeRTOS_Socket_t *pxSocket );
 357:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #endif
 358:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 359:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
 360:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 361:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /* prvTCPSocketIsActive() returns true if the socket must be checked.
 362:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Non-active sockets are waiting for user action, either connect()
 363:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * or close(). */
 364:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static BaseType_t prvTCPSocketIsActive( eIPTCPState_t xStatus )
 365:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** {
 366:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** BaseType_t xResult;
 367:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	switch( xStatus )
 368:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 369:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	case eCLOSED:
 370:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	case eCLOSE_WAIT:
 371:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	case eFIN_WAIT_2:
 372:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	case eCLOSING:
 373:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	case eTIME_WAIT:
 374:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		xResult = pdFALSE;
 375:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		break;
 376:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	case eTCP_LISTEN:
 377:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	case eCONNECT_SYN:
 378:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	case eSYN_FIRST:
 379:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	case eSYN_RECEIVED:
 380:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	case eESTABLISHED:
 381:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	case eFIN_WAIT_1:
 382:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	case eLAST_ACK:
 383:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	default:
 384:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		xResult = pdTRUE;
 385:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		break;
 386:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 387:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	return xResult;
 388:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** }
 389:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
 390:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 391:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #if( ipconfigTCP_HANG_PROTECTION == 1 )
 392:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 393:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	static BaseType_t prvTCPStatusAgeCheck( FreeRTOS_Socket_t *pxSocket )
 394:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 395:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	BaseType_t xResult;
 396:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	eIPTCPState_t eState = ipNUMERIC_CAST( eIPTCPState_t, pxSocket->u.xTCP.ucTCPState );
 397:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 398:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		switch( eState )
 399:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 400:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		case eESTABLISHED:
 401:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* If the 'ipconfigTCP_KEEP_ALIVE' option is enabled, sockets in
 402:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			state ESTABLISHED can be protected using keep-alive messages. */
 403:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			xResult = pdFALSE;
 404:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			break;
 405:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		case eCLOSED:
 406:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		case eTCP_LISTEN:
 407:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		case eCLOSE_WAIT:
 408:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* These 3 states may last for ever, up to the owner. */
 409:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			xResult = pdFALSE;
 410:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			break;
 411:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		case eCONNECT_SYN:
 412:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		case eSYN_FIRST:
 413:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		case eSYN_RECEIVED:
 414:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		case eFIN_WAIT_1:
 415:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		case eFIN_WAIT_2:
 416:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		case eCLOSING:
 417:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		case eLAST_ACK:
 418:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		case eTIME_WAIT:
 419:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		default:
 420:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* All other (non-connected) states will get anti-hanging
 421:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			protection. */
 422:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			xResult = pdTRUE;
 423:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			break;
 424:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 425:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( xResult != pdFALSE )
 426:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 427:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* How much time has past since the last active moment which is
 428:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			defined as A) a state change or B) a packet has arrived. */
 429:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			TickType_t xAge = xTaskGetTickCount( ) - pxSocket->u.xTCP.xLastActTime;
 430:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 431:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* ipconfigTCP_HANG_PROTECTION_TIME is in units of seconds. */
 432:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( xAge > ( ( TickType_t ) ipconfigTCP_HANG_PROTECTION_TIME * ( TickType_t ) configTICK_RATE_HZ
 433:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 434:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				#if( ipconfigHAS_DEBUG_PRINTF == 1 )
 435:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
 436:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					FreeRTOS_debug_printf( ( "Inactive socket closed: port %u rem %lxip:%u status %s\n",
 437:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						pxSocket->usLocalPort,
 438:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						pxSocket->u.xTCP.ulRemoteIP,
 439:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						pxSocket->u.xTCP.usRemotePort,
 440:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						FreeRTOS_GetTCPStateName( ( UBaseType_t ) pxSocket->u.xTCP.ucTCPState ) ) );
 441:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
 442:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				#endif /* ipconfigHAS_DEBUG_PRINTF */
 443:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 444:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				/* Move to eCLOSE_WAIT, user may close the socket. */
 445:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				vTCPStateChange( pxSocket, eCLOSE_WAIT );
 446:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 447:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				/* When 'bPassQueued' true, this socket is an orphan until it
 448:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				gets connected. */
 449:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				if( pxSocket->u.xTCP.bits.bPassQueued != pdFALSE_UNSIGNED )
 450:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
 451:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					if( pxSocket->u.xTCP.bits.bReuseSocket == pdFALSE_UNSIGNED )
 452:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					{
 453:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						/* As it did not get connected, and the user can never
 454:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						accept() it anymore, it will be deleted now.  Called from
 455:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						the IP-task, so it's safe to call the internal Close
 456:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						function: vSocketClose(). */
 457:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						( void ) vSocketClose( pxSocket );
 458:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					}
 459:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					/* Return a negative value to tell to inform the caller
 460:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					xTCPTimerCheck()
 461:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					that the socket got closed and may not be accessed anymore. */
 462:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					xResult = -1;
 463:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
 464:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 465:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 466:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		return xResult;
 467:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 468:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	/*-----------------------------------------------------------*/
 469:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 470:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #endif
 471:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 472:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 473:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * As soon as a TCP socket timer expires, this function xTCPSocketCheck
 474:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * will be called (from xTCPTimerCheck)
 475:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * It can send a delayed ACK or new data
 476:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Sequence of calling (normally) :
 477:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * IP-Task:
 478:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  *		xTCPTimerCheck()				// Check all sockets ( declared in FreeRTOS_Sockets.c )
 479:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  *		xTCPSocketCheck()				// Either send a delayed ACK or call prvTCPSendPacket()
 480:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  *		prvTCPSendPacket()				// Either send a SYN or call prvTCPSendRepeated ( regular messages )
 481:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  *		prvTCPSendRepeated()			// Send at most 8 messages on a row
 482:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  *			prvTCPReturnPacket()		// Prepare for returning
 483:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  *			xNetworkInterfaceOutput()	// Sends data to the NIC ( declared in portable/NetworkInterface/xxx
 484:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 485:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** BaseType_t xTCPSocketCheck( FreeRTOS_Socket_t *pxSocket )
 486:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** {
 487:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** BaseType_t xResult = 0;
 488:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** BaseType_t xReady = pdFALSE;
 489:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 490:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( ( pxSocket->u.xTCP.ucTCPState >= ( uint8_t ) eESTABLISHED ) && ( pxSocket->u.xTCP.txStream != 
 491:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 492:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* The API FreeRTOS_send() might have added data to the TX stream.  Add
 493:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		this data to the windowing system so it can be transmitted. */
 494:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		prvTCPAddTxData( pxSocket );
 495:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 496:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 497:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#if( ipconfigUSE_TCP_WIN == 1 )
 498:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 499:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( pxSocket->u.xTCP.pxAckMessage != NULL )
 500:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 501:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* The first task of this regular socket check is to send-out delayed
 502:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			ACK's. */
 503:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( pxSocket->u.xTCP.bits.bUserShutdown == pdFALSE_UNSIGNED )
 504:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 505:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				/* Earlier data was received but not yet acknowledged.  This
 506:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				function is called when the TCP timer for the socket expires, the
 507:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				ACK may be sent now. */
 508:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				if( pxSocket->u.xTCP.ucTCPState != ( uint8_t ) eCLOSED )
 509:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
 510:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					if( ( xTCPWindowLoggingLevel > 1 ) && ipconfigTCP_MAY_LOG_PORT( pxSocket->usLocalPort ) )
 511:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					{
 512:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						FreeRTOS_debug_printf( ( "Send[%u->%u] del ACK %lu SEQ %lu (len %u)\n",
 513:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							pxSocket->usLocalPort,
 514:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							pxSocket->u.xTCP.usRemotePort,
 515:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber - pxSocket->u.xTCP.xTCPWindow.rx.ulFi
 516:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber   - pxSocket->u.xTCP.xTCPWindow.tx.ulFirstSe
 517:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							( unsigned ) ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER ) );
 518:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					}
 519:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 520:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					prvTCPReturnPacket( pxSocket, pxSocket->u.xTCP.pxAckMessage, ipSIZE_OF_IPv4_HEADER + ipSIZE_OF
 521:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 522:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					#if( ipconfigZERO_COPY_TX_DRIVER != 0 )
 523:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					{
 524:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						/* The ownership has been passed to the SEND routine,
 525:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						clear the pointer to it. */
 526:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						pxSocket->u.xTCP.pxAckMessage = NULL;
 527:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					}
 528:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					#endif /* ipconfigZERO_COPY_TX_DRIVER */
 529:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
 530:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				if( prvTCPNextTimeout( pxSocket ) > 1U )
 531:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
 532:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					/* Tell the code below that this function is ready. */
 533:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					xReady = pdTRUE;
 534:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
 535:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 536:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			else
 537:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 538:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				/* The user wants to perform an active shutdown(), skip sending
 539:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				the	delayed	ACK.  The function prvTCPSendPacket() will send the
 540:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				FIN	along with the ACK's. */
 541:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 542:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 543:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( pxSocket->u.xTCP.pxAckMessage != NULL )
 544:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 545:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				vReleaseNetworkBufferAndDescriptor( pxSocket->u.xTCP.pxAckMessage );
 546:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxSocket->u.xTCP.pxAckMessage = NULL;
 547:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 548:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 549:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 550:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#endif /* ipconfigUSE_TCP_WIN */
 551:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 552:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( xReady == pdFALSE )
 553:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 554:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* The second task of this regular socket check is sending out data. */
 555:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( ( pxSocket->u.xTCP.ucTCPState >= ( uint8_t ) eESTABLISHED ) ||
 556:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eCONNECT_SYN ) )
 557:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 558:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( void ) prvTCPSendPacket( pxSocket );
 559:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 560:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 561:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Set the time-out for the next wakeup for this socket. */
 562:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		( void ) prvTCPNextTimeout( pxSocket );
 563:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 564:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		#if( ipconfigTCP_HANG_PROTECTION == 1 )
 565:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 566:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* In all (non-connected) states in which keep-alive messages can not be sent
 567:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			the anti-hang protocol will close sockets that are 'hanging'. */
 568:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			xResult = prvTCPStatusAgeCheck( pxSocket );
 569:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 570:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		#endif
 571:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 572:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 573:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	return xResult;
 574:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** }
 575:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
 576:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 577:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 578:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * prvTCPSendPacket() will be called when the socket time-out has been reached.
 579:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * It is only called by xTCPSocketCheck().
 580:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 581:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static int32_t prvTCPSendPacket( FreeRTOS_Socket_t *pxSocket )
 582:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** {
 583:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** int32_t lResult = 0;
 584:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** UBaseType_t uxOptionsLength, uxIntermediateResult = 0;
 585:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** NetworkBufferDescriptor_t *pxNetworkBuffer;
 586:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 587:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( pxSocket->u.xTCP.ucTCPState != ( uint8_t ) eCONNECT_SYN )
 588:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 589:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* The connection is in a state other than SYN. */
 590:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxNetworkBuffer = NULL;
 591:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 592:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* prvTCPSendRepeated() will only create a network buffer if necessary,
 593:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		i.e. when data must be sent to the peer. */
 594:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		lResult = prvTCPSendRepeated( pxSocket, &pxNetworkBuffer );
 595:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 596:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( pxNetworkBuffer != NULL )
 597:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 598:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 599:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 600:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 601:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	else
 602:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 603:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( pxSocket->u.xTCP.ucRepCount >= 3U )
 604:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 605:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* The connection is in the SYN status. The packet will be repeated
 606:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			to most 3 times.  When there is no response, the socket get the
 607:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			status 'eCLOSE_WAIT'. */
 608:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			FreeRTOS_debug_printf( ( "Connect: giving up %lxip:%u\n",
 609:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxSocket->u.xTCP.ulRemoteIP,		/* IP address of remote machine. */
 610:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxSocket->u.xTCP.usRemotePort ) );	/* Port on remote machine. */
 611:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			vTCPStateChange( pxSocket, eCLOSE_WAIT );
 612:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 613:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		else if( ( pxSocket->u.xTCP.bits.bConnPrepared != pdFALSE_UNSIGNED ) || ( prvTCPPrepareConnect( p
 614:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 615:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		ProtocolHeaders_t *pxProtocolHeaders;
 616:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		const UBaseType_t uxHeaderSize = ipSIZE_OF_IPv4_HEADER;
 617:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* Or else, if the connection has been prepared, or can be prepared
 618:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			now, proceed to send the packet with the SYN flag.
 619:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			prvTCPPrepareConnect() prepares 'xPacket' and returns pdTRUE if
 620:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			the Ethernet address of the peer or the gateway is found. */
 621:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxProtocolHeaders = ipCAST_PTR_TO_TYPE_PTR( ProtocolHeaders_t, &( pxSocket->u.xTCP.xPacket.u.ucL
 622:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 623:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* About to send a SYN packet.  Call prvSetSynAckOptions() to set
 624:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			the proper options: The size of MSS and whether SACK's are
 625:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			allowed. */
 626:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			uxOptionsLength = prvSetSynAckOptions( pxSocket, &( pxProtocolHeaders->xTCPHeader ) );
 627:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 628:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* Return the number of bytes to be sent. */
 629:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			uxIntermediateResult = uxIPHeaderSizeSocket( pxSocket ) + ipSIZE_OF_TCP_HEADER + uxOptionsLength
 630:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			lResult = ( int32_t ) uxIntermediateResult;
 631:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 632:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* Set the TCP offset field:  ipSIZE_OF_TCP_HEADER equals 20 and
 633:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			uxOptionsLength is always a multiple of 4.  The complete expression
 634:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			would be:
 635:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			ucTCPOffset = ( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) / 4 ) << 4 */
 636:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxProtocolHeaders->xTCPHeader.ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLengt
 637:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 638:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* Repeat Count is used for a connecting socket, to limit the number
 639:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			of tries. */
 640:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxSocket->u.xTCP.ucRepCount++;
 641:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 642:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* Send the SYN message to make a connection.  The messages is
 643:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			stored in the socket field 'xPacket'.  It will be wrapped in a
 644:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pseudo network buffer descriptor before it will be sent. */
 645:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			prvTCPReturnPacket( pxSocket, NULL, ( uint32_t ) lResult, pdFALSE );
 646:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 647:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		else
 648:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 649:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* Nothing to do. */
 650:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 651:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 652:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 653:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	/* Return the total number of bytes sent. */
 654:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	return lResult;
 655:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** }
 656:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
 657:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 658:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 659:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * prvTCPSendRepeated will try to send a series of messages, as long as there is
 660:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * data to be sent and as long as the transmit window isn't full.
 661:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 662:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static int32_t prvTCPSendRepeated( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **ppxNetw
 663:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** {
 664:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** UBaseType_t uxIndex;
 665:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** int32_t lResult = 0;
 666:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** UBaseType_t uxOptionsLength = 0U;
 667:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** int32_t xSendLength;
 668:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 669:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	for( uxIndex = 0U; uxIndex < ( UBaseType_t ) SEND_REPEATED_COUNT; uxIndex++ )
 670:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 671:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* prvTCPPrepareSend() might allocate a network buffer if there is data
 672:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		to be sent. */
 673:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		xSendLength = prvTCPPrepareSend( pxSocket, ppxNetworkBuffer, uxOptionsLength );
 674:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( xSendLength <= 0 )
 675:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 676:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			break;
 677:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 678:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 679:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* And return the packet to the peer. */
 680:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		prvTCPReturnPacket( pxSocket, *ppxNetworkBuffer, ( uint32_t ) xSendLength, ipconfigZERO_COPY_TX_D
 681:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 682:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		#if( ipconfigZERO_COPY_TX_DRIVER != 0 )
 683:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 684:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			*ppxNetworkBuffer = NULL;
 685:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 686:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		#endif /* ipconfigZERO_COPY_TX_DRIVER */
 687:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 688:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		lResult += xSendLength;
 689:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 690:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 691:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	/* Return the total number of bytes sent. */
 692:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	return lResult;
 693:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** }
 694:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
 695:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 696:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 697:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Return (or send) a packet the the peer.  The data is stored in pxBuffer,
 698:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * which may either point to a real network buffer or to a TCP socket field
 699:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * called 'xTCP.xPacket'.   A temporary xNetworkBuffer will be used to pass
 700:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * the data to the NIC.
 701:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 702:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static void prvTCPReturnPacket( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t *pxDescripto
 703:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** {
 704:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** TCPPacket_t * pxTCPPacket;
 705:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** IPHeader_t *pxIPHeader;
 706:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** BaseType_t xDoRelease = xReleaseAfterSend;
 707:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** EthernetHeader_t *pxEthernetHeader;
 708:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint32_t ulFrontSpace, ulSpace, ulSourceAddress, ulWinSize;
 709:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** const TCPWindow_t *pxTCPWindow;
 710:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** NetworkBufferDescriptor_t *pxNetworkBuffer = pxDescriptor;
 711:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** NetworkBufferDescriptor_t xTempBuffer;
 712:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /* For sending, a pseudo network buffer will be used, as explained above. */
 713:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 714:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( pxNetworkBuffer == NULL )
 715:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 716:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxNetworkBuffer = &xTempBuffer;
 717:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 718:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		#if( ipconfigUSE_LINKED_RX_MESSAGES != 0 )
 719:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 720:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxNetworkBuffer->pxNextBuffer = NULL;
 721:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 722:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		#endif
 723:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxNetworkBuffer->pucEthernetBuffer = pxSocket->u.xTCP.xPacket.u.ucLastPacket;
 724:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxNetworkBuffer->xDataLength = sizeof( pxSocket->u.xTCP.xPacket.u.ucLastPacket );
 725:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		xDoRelease = pdFALSE;
 726:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 727:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 728:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#if( ipconfigZERO_COPY_TX_DRIVER != 0 )
 729:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 730:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( xDoRelease == pdFALSE )
 731:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 732:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxNetworkBuffer = pxDuplicateNetworkBufferWithDescriptor( pxNetworkBuffer, ( size_t ) pxNetworkB
 733:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( pxNetworkBuffer == NULL )
 734:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 735:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				FreeRTOS_debug_printf( ( "prvTCPReturnPacket: duplicate failed\n" ) );
 736:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 737:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			xDoRelease = pdTRUE;
 738:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 739:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 740:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#endif /* ipconfigZERO_COPY_TX_DRIVER */
 741:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 742:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#ifndef __COVERITY__
 743:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( pxNetworkBuffer != NULL )
 744:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#endif
 745:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 746:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Map the ethernet buffer onto a TCPPacket_t struct for easy access to the fields. */
 747:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPPacket = ipCAST_PTR_TO_TYPE_PTR( TCPPacket_t, pxNetworkBuffer->pucEthernetBuffer );
 748:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxIPHeader = &pxTCPPacket->xIPHeader;
 749:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxEthernetHeader = &pxTCPPacket->xEthernetHeader;
 750:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 751:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Fill the packet, using hton translations. */
 752:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( pxSocket != NULL )
 753:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 754:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* Calculate the space in the RX buffer in order to advertise the
 755:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			size of this socket's reception window. */
 756:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxTCPWindow = &( pxSocket->u.xTCP.xTCPWindow );
 757:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 758:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( pxSocket->u.xTCP.rxStream != NULL )
 759:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 760:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				/* An RX stream was created already, see how much space is
 761:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				available. */
 762:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				ulFrontSpace = ( uint32_t ) uxStreamBufferFrontSpace( pxSocket->u.xTCP.rxStream );
 763:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 764:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			else
 765:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 766:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				/* No RX stream has been created, the full stream size is
 767:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				available. */
 768:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				ulFrontSpace = ( uint32_t ) pxSocket->u.xTCP.uxRxStreamSize;
 769:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 770:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 771:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* Take the minimum of the RX buffer space and the RX window size. */
 772:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			ulSpace = FreeRTOS_min_uint32( pxTCPWindow->xSize.ulRxWindowLength, ulFrontSpace );
 773:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 774:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( ( pxSocket->u.xTCP.bits.bLowWater != pdFALSE_UNSIGNED ) || ( pxSocket->u.xTCP.bits.bRxStoppe
 775:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 776:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				/* The low-water mark was reached, meaning there was little
 777:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				space left.  The socket will wait until the application has read
 778:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				or flushed the incoming data, and 'zero-window' will be
 779:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				advertised. */
 780:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				ulSpace = 0U;
 781:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 782:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 783:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* If possible, advertise an RX window size of at least 1 MSS, otherwise
 784:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			the peer might start 'zero window probing', i.e. sending small packets
 785:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			(1, 2, 4, 8... bytes). */
 786:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( ( ulSpace < pxSocket->u.xTCP.usCurMSS ) && ( ulFrontSpace >= pxSocket->u.xTCP.usCurMSS ) )
 787:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 788:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				ulSpace = pxSocket->u.xTCP.usCurMSS;
 789:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 790:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 791:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* Avoid overflow of the 16-bit win field. */
 792:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			#if( ipconfigUSE_TCP_WIN != 0 )
 793:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 794:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				ulWinSize = ( ulSpace >> pxSocket->u.xTCP.ucMyWinScaleFactor );
 795:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 796:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			#else
 797:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 798:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				ulWinSize = ulSpace;
 799:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 800:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			#endif
 801:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( ulWinSize > 0xfffcUL )
 802:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 803:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				ulWinSize = 0xfffcUL;
 804:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 805:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 806:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxTCPPacket->xTCPHeader.usWindow = FreeRTOS_htons( ( uint16_t ) ulWinSize );
 807:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 808:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* The new window size has been advertised, switch off the flag. */
 809:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxSocket->u.xTCP.bits.bWinChange = pdFALSE_UNSIGNED;
 810:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 811:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* Later on, when deciding to delay an ACK, a precise estimate is needed
 812:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			of the free RX space.  At this moment, 'ulHighestRxAllowed' would be the
 813:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			highest sequence number minus 1 that the socket will accept. */
 814:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxSocket->u.xTCP.ulHighestRxAllowed = pxTCPWindow->rx.ulCurrentSequenceNumber + ulSpace;
 815:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 816:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		#if( ipconfigTCP_KEEP_ALIVE == 1 )
 817:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( pxSocket->u.xTCP.bits.bSendKeepAlive != pdFALSE_UNSIGNED )
 818:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 819:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				/* Sending a keep-alive packet, send the current sequence number
 820:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				minus 1, which will	be recognised as a keep-alive packet an
 821:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				responded to by acknowledging the last byte. */
 822:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxSocket->u.xTCP.bits.bSendKeepAlive = pdFALSE_UNSIGNED;
 823:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxSocket->u.xTCP.bits.bWaitKeepAlive = pdTRUE_UNSIGNED;
 824:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 825:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxTCPPacket->xTCPHeader.ulSequenceNumber = pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber - 1U
 826:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxTCPPacket->xTCPHeader.ulSequenceNumber = FreeRTOS_htonl( pxTCPPacket->xTCPHeader.ulSequenceNu
 827:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 828:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			else
 829:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		#endif
 830:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 831:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxTCPPacket->xTCPHeader.ulSequenceNumber = FreeRTOS_htonl( pxSocket->u.xTCP.xTCPWindow.ulOurSeq
 832:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 833:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				if( ( pxTCPPacket->xTCPHeader.ucTCPFlags & ( uint8_t ) tcpTCP_FLAG_FIN ) != 0U )
 834:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
 835:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					/* Suppress FIN in case this packet carries earlier data to be
 836:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					retransmitted. */
 837:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					uint32_t ulDataLen = ( uint32_t ) ( ulLen - ( ipSIZE_OF_TCP_HEADER + ipSIZE_OF_IPv4_HEADER ) )
 838:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					if( ( pxTCPWindow->ulOurSequenceNumber + ulDataLen ) != pxTCPWindow->tx.ulFINSequenceNumber )
 839:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					{
 840:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						pxTCPPacket->xTCPHeader.ucTCPFlags &= ( ( uint8_t ) ~tcpTCP_FLAG_FIN );
 841:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						FreeRTOS_debug_printf( ( "Suppress FIN for %lu + %lu < %lu\n",
 842:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							pxTCPWindow->ulOurSequenceNumber - pxTCPWindow->tx.ulFirstSequenceNumber,
 843:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							ulDataLen,
 844:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							pxTCPWindow->tx.ulFINSequenceNumber - pxTCPWindow->tx.ulFirstSequenceNumber ) );
 845:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					}
 846:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
 847:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 848:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 849:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* Tell which sequence number is expected next time */
 850:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxTCPPacket->xTCPHeader.ulAckNr = FreeRTOS_htonl( pxTCPWindow->rx.ulCurrentSequenceNumber );
 851:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 852:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		else
 853:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 854:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* Sending data without a socket, probably replying with a RST flag
 855:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			Just swap the two sequence numbers. */
 856:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			vFlip_32( pxTCPPacket->xTCPHeader.ulSequenceNumber, pxTCPPacket->xTCPHeader.ulAckNr );
 857:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 858:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 859:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxIPHeader->ucTimeToLive		   = ( uint8_t ) ipconfigTCP_TIME_TO_LIVE;
 860:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxIPHeader->usLength			   = FreeRTOS_htons( ulLen );
 861:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( ( pxSocket == NULL ) || ( *ipLOCAL_IP_ADDRESS_POINTER == 0UL ) )
 862:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 863:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* When pxSocket is NULL, this function is called by prvTCPSendReset()
 864:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			and the IP-addresses must be swapped.
 865:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			Also swap the IP-addresses in case the IP-tack doesn't have an
 866:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			IP-address yet, i.e. when ( *ipLOCAL_IP_ADDRESS_POINTER == 0UL ). */
 867:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			ulSourceAddress = pxIPHeader->ulDestinationIPAddress;
 868:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 869:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		else
 870:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 871:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			ulSourceAddress = *ipLOCAL_IP_ADDRESS_POINTER;
 872:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 873:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxIPHeader->ulDestinationIPAddress = pxIPHeader->ulSourceIPAddress;
 874:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxIPHeader->ulSourceIPAddress = ulSourceAddress;
 875:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		vFlip_16( pxTCPPacket->xTCPHeader.usSourcePort, pxTCPPacket->xTCPHeader.usDestinationPort );
 876:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 877:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Just an increasing number. */
 878:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxIPHeader->usIdentification = FreeRTOS_htons( usPacketIdentifier );
 879:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		usPacketIdentifier++;
 880:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxIPHeader->usFragmentOffset = 0U;
 881:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 882:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Important: tell NIC driver how many bytes must be sent. */
 883:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxNetworkBuffer->xDataLength = ulLen + ipSIZE_OF_ETH_HEADER;
 884:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 885:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		#if( ipconfigDRIVER_INCLUDED_TX_IP_CHECKSUM == 0 )
 886:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 887:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* calculate the IP header checksum, in case the driver won't do that. */
 888:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxIPHeader->usHeaderChecksum = 0x00U;
 889:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxIPHeader->usHeaderChecksum = usGenerateChecksum( 0U, ( uint8_t * ) &( pxIPHeader->ucVersionHea
 890:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxIPHeader->usHeaderChecksum = ~FreeRTOS_htons( pxIPHeader->usHeaderChecksum );
 891:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 892:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* calculate the TCP checksum for an outgoing packet. */
 893:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( void ) usGenerateProtocolChecksum( ( uint8_t * ) pxTCPPacket, pxNetworkBuffer->xDataLength, pd
 894:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 895:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* A calculated checksum of 0 must be inverted as 0 means the checksum
 896:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			is disabled. */
 897:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( pxTCPPacket->xTCPHeader.usChecksum == 0U )
 898:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 899:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxTCPPacket->xTCPHeader.usChecksum = 0xffffU;
 900:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 901:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 902:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		#endif
 903:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 904:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		#if( ipconfigUSE_LINKED_RX_MESSAGES != 0 )
 905:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 906:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxNetworkBuffer->pxNextBuffer = NULL;
 907:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 908:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		#endif
 909:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 910:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Fill in the destination MAC addresses. */
 911:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		( void ) memcpy( ( void * ) ( &( pxEthernetHeader->xDestinationAddress ) ),
 912:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						 ( const void * ) ( &( pxEthernetHeader->xSourceAddress ) ),
 913:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						 sizeof( pxEthernetHeader->xDestinationAddress ) );
 914:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 915:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* The source MAC addresses is fixed to 'ipLOCAL_MAC_ADDRESS'. */
 916:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		( void ) memcpy( ( void * ) ( &( pxEthernetHeader->xSourceAddress ) ), ( const void * ) ipLOCAL_M
 917:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  
 918:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		#if defined( ipconfigETHERNET_MINIMUM_PACKET_BYTES )
 919:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 920:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( pxNetworkBuffer->xDataLength < ( size_t ) ipconfigETHERNET_MINIMUM_PACKET_BYTES )
 921:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 922:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			BaseType_t xIndex;
 923:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 924:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				for( xIndex = ( BaseType_t ) pxNetworkBuffer->xDataLength; xIndex < ( BaseType_t ) ipconfigETHE
 925:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
 926:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					pxNetworkBuffer->pucEthernetBuffer[ xIndex ] = 0U;
 927:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
 928:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxNetworkBuffer->xDataLength = ( size_t ) ipconfigETHERNET_MINIMUM_PACKET_BYTES;
 929:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 930:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 931:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		#endif
 932:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 933:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Send! */
 934:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		( void ) xNetworkInterfaceOutput( pxNetworkBuffer, xDoRelease );
 935:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 936:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( xDoRelease == pdFALSE )
 937:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 938:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* Swap-back some fields, as pxBuffer probably points to a socket field
 939:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			containing the packet header. */
 940:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			vFlip_16( pxTCPPacket->xTCPHeader.usSourcePort, pxTCPPacket->xTCPHeader.usDestinationPort);
 941:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxTCPPacket->xIPHeader.ulSourceIPAddress = pxTCPPacket->xIPHeader.ulDestinationIPAddress;
 942:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( void ) memcpy( ( void * ) ( pxEthernetHeader->xSourceAddress.ucBytes ), ( const void * ) ( pxE
 943:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 944:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		else
 945:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 946:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* Nothing to do: the buffer has been passed to DMA and will be released after use */
 947:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 948:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	} /* if( pxNetworkBuffer != NULL ) */
 949:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** }
 950:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
 951:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 952:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 953:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * The SYN event is very important: the sequence numbers, which have a kind of
 954:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * random starting value, are being synchronised.  The sliding window manager
 955:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * (in FreeRTOS_TCP_WIN.c) needs to know them, along with the Maximum Segment
 956:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Size (MSS) in use.
 957:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 958:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static void prvTCPCreateWindow( FreeRTOS_Socket_t *pxSocket )
 959:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** {
 960:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( xTCPWindowLoggingLevel != 0 )
 961:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 962:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		FreeRTOS_debug_printf( ( "Limits (using): TCP Win size %u Water %u <= %u <= %u\n",
 963:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( unsigned ) pxSocket->u.xTCP.uxRxWinSize * ipconfigTCP_MSS,
 964:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( unsigned ) pxSocket->u.xTCP.uxLittleSpace ,
 965:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( unsigned ) pxSocket->u.xTCP.uxEnoughSpace,
 966:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( unsigned ) pxSocket->u.xTCP.uxRxStreamSize ) );
 967:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 968:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	vTCPWindowCreate(
 969:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		&pxSocket->u.xTCP.xTCPWindow,
 970:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		( ( size_t ) ipconfigTCP_MSS ) * pxSocket->u.xTCP.uxRxWinSize,
 971:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		( ( size_t ) ipconfigTCP_MSS ) * pxSocket->u.xTCP.uxTxWinSize,
 972:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber,
 973:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber,
 974:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		( uint32_t ) pxSocket->u.xTCP.usInitMSS );
 975:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** }
 976:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
 977:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 978:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
 979:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Connecting sockets have a special state: eCONNECT_SYN.  In this phase,
 980:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * the Ethernet address of the target will be found using ARP.  In case the
 981:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * target IP address is not within the netmask, the hardware address of the
 982:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * gateway will be used.
 983:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
 984:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static BaseType_t prvTCPPrepareConnect( FreeRTOS_Socket_t *pxSocket )
 985:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** {
 986:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** TCPPacket_t *pxTCPPacket;
 987:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** IPHeader_t *pxIPHeader;
 988:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** eARPLookupResult_t eReturned;
 989:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint32_t ulRemoteIP;
 990:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** MACAddress_t xEthAddress;
 991:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** BaseType_t xReturn = pdTRUE;
 992:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint32_t ulInitialSequenceNumber = 0;
 993:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 994:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#if( ipconfigHAS_PRINTF != 0 )
 995:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 996:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Only necessary for nicer logging. */
 997:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		( void ) memset( xEthAddress.ucBytes, 0, sizeof( xEthAddress.ucBytes ) );
 998:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 999:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#endif /* ipconfigHAS_PRINTF != 0 */
1000:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1001:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	ulRemoteIP = FreeRTOS_htonl( pxSocket->u.xTCP.ulRemoteIP );
1002:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1003:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	/* Determine the ARP cache status for the requested IP address. */
1004:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	eReturned = eARPGetCacheEntry( &( ulRemoteIP ), &( xEthAddress ) );
1005:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1006:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	switch( eReturned )
1007:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
1008:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	case eARPCacheHit:		/* An ARP table lookup found a valid entry. */
1009:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		break;				/* We can now prepare the SYN packet. */
1010:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	case eARPCacheMiss:		/* An ARP table lookup did not find a valid entry. */
1011:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	case eCantSendPacket:	/* There is no IP address, or an ARP is still in progress. */
1012:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	default:
1013:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Count the number of times it couldn't find the ARP address. */
1014:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxSocket->u.xTCP.ucRepCount++;
1015:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1016:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		FreeRTOS_debug_printf( ( "ARP for %lxip (using %lxip): rc=%d %02X:%02X:%02X %02X:%02X:%02X\n",
1017:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxSocket->u.xTCP.ulRemoteIP,
1018:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			FreeRTOS_htonl( ulRemoteIP ),
1019:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			eReturned,
1020:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			xEthAddress.ucBytes[ 0 ],
1021:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			xEthAddress.ucBytes[ 1 ],
1022:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			xEthAddress.ucBytes[ 2 ],
1023:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			xEthAddress.ucBytes[ 3 ],
1024:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			xEthAddress.ucBytes[ 4 ],
1025:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			xEthAddress.ucBytes[ 5 ] ) );
1026:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1027:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* And issue a (new) ARP request */
1028:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		FreeRTOS_OutputARPRequest( ulRemoteIP );
1029:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		xReturn = pdFALSE;
1030:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		break;
1031:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
1032:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1033:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( xReturn != pdFALSE )
1034:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
1035:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Get a difficult-to-predict initial sequence number for this 4-tuple. */
1036:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		ulInitialSequenceNumber = ulApplicationGetNextSequenceNumber( *ipLOCAL_IP_ADDRESS_POINTER,
1037:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 																	  pxSocket->usLocalPort,
1038:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 																	  pxSocket->u.xTCP.ulRemoteIP,
1039:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 																	  pxSocket->u.xTCP.usRemotePort );
1040:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1041:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Check for a random number generation error. */
1042:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( ulInitialSequenceNumber == 0UL )
1043:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
1044:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			xReturn = pdFALSE;
1045:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
1046:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
1047:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1048:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( xReturn != pdFALSE )
1049:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
1050:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	uint16_t usLength;
1051:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1052:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* The MAC-address of the peer (or gateway) has been found,
1053:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		 * now prepare the initial TCP packet and some fields in the socket. Map
1054:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		 * the buffer onto the TCPPacket_t struct to easily access it's field. */
1055:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPPacket = ipCAST_PTR_TO_TYPE_PTR( TCPPacket_t, pxSocket->u.xTCP.xPacket.u.ucLastPacket );
1056:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxIPHeader = &pxTCPPacket->xIPHeader;
1057:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1058:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* reset the retry counter to zero. */
1059:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxSocket->u.xTCP.ucRepCount = 0U;
1060:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1061:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* And remember that the connect/SYN data are prepared. */
1062:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxSocket->u.xTCP.bits.bConnPrepared = pdTRUE_UNSIGNED;
1063:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1064:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Now that the Ethernet address is known, the initial packet can be
1065:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		prepared. */
1066:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		( void ) memset( pxSocket->u.xTCP.xPacket.u.ucLastPacket, 0, sizeof( pxSocket->u.xTCP.xPacket.u.u
1067:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1068:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Write the Ethernet address in Source, because it will be swapped by
1069:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		prvTCPReturnPacket(). */
1070:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		( void ) memcpy( ( void * ) ( &pxTCPPacket->xEthernetHeader.xSourceAddress ), ( const void * ) ( 
1071:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1072:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* 'ipIPv4_FRAME_TYPE' is already in network-byte-order. */
1073:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPPacket->xEthernetHeader.usFrameType = ipIPv4_FRAME_TYPE;
1074:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1075:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxIPHeader->ucVersionHeaderLength = 0x45U;
1076:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		usLength = ( uint16_t ) ( sizeof( TCPPacket_t ) - sizeof( pxTCPPacket->xEthernetHeader ) );
1077:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxIPHeader->usLength = FreeRTOS_htons( usLength );
1078:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxIPHeader->ucTimeToLive = ( uint8_t ) ipconfigTCP_TIME_TO_LIVE;
1079:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1080:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxIPHeader->ucProtocol = ( uint8_t ) ipPROTOCOL_TCP;
1081:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1082:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Addresses and ports will be stored swapped because prvTCPReturnPacket
1083:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		will swap them back while replying. */
1084:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxIPHeader->ulDestinationIPAddress = *ipLOCAL_IP_ADDRESS_POINTER;
1085:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxIPHeader->ulSourceIPAddress = FreeRTOS_htonl( pxSocket->u.xTCP.ulRemoteIP );
1086:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1087:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPPacket->xTCPHeader.usSourcePort = FreeRTOS_htons( pxSocket->u.xTCP.usRemotePort );
1088:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPPacket->xTCPHeader.usDestinationPort = FreeRTOS_htons( pxSocket->usLocalPort );
1089:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1090:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* We are actively connecting, so the peer's Initial Sequence Number (ISN)
1091:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		isn't known yet. */
1092:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber = 0UL;
1093:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1094:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Start with ISN (Initial Sequence Number). */
1095:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber = ulInitialSequenceNumber;
1096:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1097:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* The TCP header size is 20 bytes, divided by 4 equals 5, which is put in
1098:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		the high nibble of the TCP offset field. */
1099:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPPacket->xTCPHeader.ucTCPOffset = 0x50U;
1100:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1101:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Only set the SYN flag. */
1102:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPPacket->xTCPHeader.ucTCPFlags = tcpTCP_FLAG_SYN;
1103:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1104:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Set the values of usInitMSS / usCurMSS for this socket. */
1105:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		prvSocketSetMSS( pxSocket );
1106:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1107:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* The initial sequence numbers at our side are known.  Later
1108:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		vTCPWindowInit() will be called to fill in the peer's sequence numbers, but
1109:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		first wait for a SYN+ACK reply. */
1110:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		prvTCPCreateWindow( pxSocket );
1111:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
1112:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1113:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	return xReturn;
1114:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** }
1115:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
1116:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1117:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /* For logging and debugging: make a string showing the TCP flags
1118:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** */
1119:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #if( ipconfigHAS_DEBUG_PRINTF != 0 )
1120:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1121:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	static const char *prvTCPFlagMeaning( UBaseType_t xFlags )
1122:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
1123:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		static char retString[10];
1124:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		size_t uxFlags = ( size_t ) xFlags;
1125:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		( void ) snprintf(retString,
1126:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			sizeof( retString ), "%c%c%c%c%c%c%c%c",
1127:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( ( uxFlags & ( size_t ) tcpTCP_FLAG_FIN ) != 0 )   ? 'F' : '.',	/* 0x0001: No more data from se
1128:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( ( uxFlags & ( size_t ) tcpTCP_FLAG_SYN ) != 0 )   ? 'S' : '.',	/* 0x0002: Synchronize sequence
1129:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( ( uxFlags & ( size_t ) tcpTCP_FLAG_RST ) != 0 )   ? 'R' : '.',	/* 0x0004: Reset the connection
1130:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( ( uxFlags & ( size_t ) tcpTCP_FLAG_PSH ) != 0 )   ? 'P' : '.',	/* 0x0008: Push function: pleas
1131:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( ( uxFlags & ( size_t ) tcpTCP_FLAG_ACK ) != 0 )   ? 'A' : '.',	/* 0x0010: Acknowledgment field
1132:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( ( uxFlags & ( size_t ) tcpTCP_FLAG_URG ) != 0 )   ? 'U' : '.',	/* 0x0020: Urgent pointer field
1133:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( ( uxFlags & ( size_t ) tcpTCP_FLAG_ECN ) != 0 )   ? 'E' : '.',	/* 0x0040: ECN-Echo */
1134:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( ( uxFlags & ( size_t ) tcpTCP_FLAG_CWR ) != 0 )   ? 'C' : '.');	/* 0x0080: Congestion Window R
1135:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		return retString;
1136:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
1137:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	/*-----------------------------------------------------------*/
1138:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1139:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #endif /* ipconfigHAS_DEBUG_PRINTF */
1140:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1141:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
1142:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Parse the TCP option(s) received, if present.  It has already been verified
1143:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * that: ((pxTCPHeader->ucTCPOffset & 0xf0) > 0x50), meaning that the TP header
1144:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * is longer than the usual 20 (5 x 4) bytes.
1145:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
1146:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** _static void prvCheckOptions( FreeRTOS_Socket_t *pxSocket, const NetworkBufferDescriptor_t *pxNetwo
1147:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** {
1148:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** size_t uxTCPHeaderOffset = ipSIZE_OF_ETH_HEADER + xIPHeaderSize( pxNetworkBuffer );
1149:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** const ProtocolHeaders_t *pxProtocolHeaders = ipCAST_PTR_TO_TYPE_PTR( ProtocolHeaders_t,
1150:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	&( pxNetworkBuffer->pucEthernetBuffer[ uxTCPHeaderOffset ] ) );
1151:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** const TCPHeader_t * pxTCPHeader;
1152:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** const uint8_t *pucPtr;
1153:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** BaseType_t xHasSYNFlag;
1154:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /* Offset in the network packet where the first option byte is stored. */
1155:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** size_t uxOptionOffset = uxTCPHeaderOffset + ( sizeof( TCPHeader_t ) - sizeof( pxTCPHeader->ucOptdat
1156:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** size_t uxOptionsLength;
1157:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** size_t uxResult;
1158:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint8_t ucLength;
1159:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1160:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	pxTCPHeader = &( pxProtocolHeaders->xTCPHeader );
1161:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1162:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1163:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	/* A character pointer to iterate through the option data */
1164:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	pucPtr = pxTCPHeader->ucOptdata;
1165:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( pxTCPHeader->ucTCPOffset <= ( 5U << 4U ) )
1166:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
1167:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Avoid integer underflow in computation of ucLength. */
1168:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
1169:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	else
1170:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
1171:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		ucLength = ( ( ( pxTCPHeader->ucTCPOffset >> 4U ) - 5U ) << 2U );
1172:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		uxOptionsLength = ( size_t ) ucLength;
1173:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( pxNetworkBuffer->xDataLength > uxOptionOffset )
1174:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
1175:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* Validate options size calculation. */
1176:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( ( pxNetworkBuffer->xDataLength > uxOptionOffset ) &&
1177:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				( uxOptionsLength <= ( pxNetworkBuffer->xDataLength - uxOptionOffset ) ) )
1178:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
1179:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				if( ( pxTCPHeader->ucTCPFlags & tcpTCP_FLAG_SYN ) != ( uint8_t ) 0U )
1180:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
1181:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					xHasSYNFlag = pdTRUE;
1182:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
1183:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				else
1184:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
1185:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					xHasSYNFlag = pdFALSE;
1186:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
1187:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				/* The length check is only necessary in case the option data are
1188:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				corrupted, we don't like to run into invalid memory and crash. */
1189:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				for( ;; )
1190:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
1191:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					if( uxOptionsLength == 0U )
1192:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					{
1193:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						/* coverity[break_stmt] : Break statement terminating the loop */
1194:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						break;
1195:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					}
1196:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					uxResult = prvSingleStepTCPHeaderOptions( pucPtr, uxOptionsLength, pxSocket, xHasSYNFlag );
1197:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					if( uxResult == 0UL )
1198:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					{
1199:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						break;
1200:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					}
1201:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					uxOptionsLength -= uxResult;
1202:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					pucPtr = &( pucPtr[ uxResult ] );
1203:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
1204:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
1205:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
1206:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
1207:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1208:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	return;
1209:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** }
1210:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
1211:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1212:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** _static size_t prvSingleStepTCPHeaderOptions( const uint8_t * const pucPtr,
1213:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 											 size_t uxTotalLength,
1214:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 											 FreeRTOS_Socket_t * const pxSocket,
1215:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 											 BaseType_t xHasSYNFlag )
1216:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** {
1217:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** UBaseType_t uxNewMSS;
1218:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** size_t uxRemainingOptionsBytes = uxTotalLength;
1219:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint8_t ucLen;
1220:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** size_t uxIndex;
1221:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** TCPWindow_t *pxTCPWindow = &( pxSocket->u.xTCP.xTCPWindow );
1222:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** BaseType_t xReturn = pdFALSE;
1223:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1224:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( pucPtr[ 0U ] == tcpTCP_OPT_END )
1225:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
1226:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* End of options. */
1227:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		uxIndex = 0U;
1228:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
1229:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	else if( pucPtr[ 0U ] == tcpTCP_OPT_NOOP )
1230:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
1231:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* NOP option, inserted to make the length a multiple of 4. */
1232:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		uxIndex = 1U;
1233:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
1234:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	else if( uxRemainingOptionsBytes < 2U )
1235:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
1236:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Any other well-formed option must be at least two bytes: the option
1237:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		type byte followed by a length byte. */
1238:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		uxIndex = 0U;
1239:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
1240:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #if( ipconfigUSE_TCP_WIN != 0 )
1241:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	else if( pucPtr[ 0 ] == tcpTCP_OPT_WSOPT )
1242:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
1243:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* The TCP Window Scale Option. */
1244:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Confirm that the option fits in the remaining buffer space. */
1245:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( ( uxRemainingOptionsBytes < tcpTCP_OPT_WSOPT_LEN ) || ( pucPtr[ 1 ] != tcpTCP_OPT_WSOPT_LEN )
1246:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
1247:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			uxIndex = 0U;
1248:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
1249:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		else
1250:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
1251:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* Option is only valid in SYN phase. */
1252:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( xHasSYNFlag != 0 )
1253:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
1254:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxSocket->u.xTCP.ucPeerWinScaleFactor = pucPtr[ 2 ];
1255:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxSocket->u.xTCP.bits.bWinScaling = pdTRUE_UNSIGNED;
1256:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
1257:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			uxIndex = tcpTCP_OPT_WSOPT_LEN;
1258:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
1259:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
1260:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #endif	/* ipconfigUSE_TCP_WIN */
1261:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	else if( pucPtr[ 0 ] == tcpTCP_OPT_MSS )
1262:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
1263:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Confirm that the option fits in the remaining buffer space. */
1264:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( ( uxRemainingOptionsBytes < tcpTCP_OPT_MSS_LEN ) || ( pucPtr[ 1 ] != tcpTCP_OPT_MSS_LEN ) )
1265:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
1266:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			uxIndex = 0U;
1267:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
1268:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		else
1269:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
1270:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* An MSS option with the correct option length.  FreeRTOS_htons()
1271:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			is not needed here because usChar2u16() already returns a host
1272:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			endian number. */
1273:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			uxNewMSS = usChar2u16( &( pucPtr[ 2 ] ) );
1274:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1275:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( pxSocket->u.xTCP.usInitMSS != uxNewMSS )
1276:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
1277:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				/* Perform a basic check on the the new MSS. */
1278:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				if( uxNewMSS == 0U )
1279:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
1280:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					uxIndex = 0U;
1281:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1282:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					/* Return Condition found. */
1283:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					xReturn = pdTRUE;
1284:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
1285:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				else
1286:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
1287:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					FreeRTOS_debug_printf( ( "MSS change %u -> %lu\n", pxSocket->u.xTCP.usInitMSS, uxNewMSS ) );
1288:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
1289:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
1290:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1291:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* If a 'return' condition has not been found. */
1292:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( xReturn == pdFALSE )
1293:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
1294:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				if( pxSocket->u.xTCP.usInitMSS > uxNewMSS )
1295:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
1296:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					/* our MSS was bigger than the MSS of the other party: adapt it. */
1297:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					pxSocket->u.xTCP.bits.bMssChange = pdTRUE_UNSIGNED;
1298:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					if( pxSocket->u.xTCP.usCurMSS > uxNewMSS )
1299:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					{
1300:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						/* The peer advertises a smaller MSS than this socket was
1301:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						using.  Use that as well. */
1302:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						FreeRTOS_debug_printf( ( "Change mss %d => %lu\n", pxSocket->u.xTCP.usCurMSS, uxNewMSS ) );
1303:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						pxSocket->u.xTCP.usCurMSS = ( uint16_t ) uxNewMSS;
1304:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					}
1305:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					pxTCPWindow->xSize.ulRxWindowLength = ( ( uint32_t ) uxNewMSS ) * ( pxTCPWindow->xSize.ulRxWin
1306:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					pxTCPWindow->usMSSInit = ( uint16_t ) uxNewMSS;
1307:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					pxTCPWindow->usMSS = ( uint16_t ) uxNewMSS;
1308:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					pxSocket->u.xTCP.usInitMSS = ( uint16_t ) uxNewMSS;
1309:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					pxSocket->u.xTCP.usCurMSS = ( uint16_t ) uxNewMSS;
1310:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
1311:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1312:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				uxIndex = tcpTCP_OPT_MSS_LEN;
1313:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
1314:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
1315:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
1316:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	else
1317:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
1318:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* All other options have a length field, so that we easily
1319:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		can skip past them. */
1320:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		ucLen = pucPtr[ 1 ];
1321:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( ( ucLen < ( uint8_t ) 2U ) || ( uxRemainingOptionsBytes < ( size_t ) ucLen ) )
1322:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
1323:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* If the length field is too small or too big, the options are
1324:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			 * malformed, don't process them further.
1325:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			 */
1326:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			uxIndex = 0U;
1327:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
1328:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		else
1329:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
1330:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			uxIndex = 0U;
1331:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			
1332:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			#if( ipconfigUSE_TCP_WIN == 1 )
1333:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
1334:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				/* Selective ACK: the peer has received a packet but it is missing
1335:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				 * earlier packets. At least this packet does not need retransmission
1336:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				 * anymore. ulTCPWindowTxSack( ) takes care of this administration.
1337:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				 */
1338:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				if( pucPtr[ 0U ] == tcpTCP_OPT_SACK_A )
1339:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
1340:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					ucLen -= 2U;
1341:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					uxIndex += 2U;
1342:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1343:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					while( ucLen >= ( uint8_t ) 8U )
1344:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					{
1345:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						prvReadSackOption( pucPtr, uxIndex, pxSocket );
1346:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						uxIndex += 8U;
1347:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						ucLen -= 8U;
1348:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					}
1349:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					/* ucLen should be 0 by now. */
1350:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
1351:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
1352:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			#endif	/* ipconfigUSE_TCP_WIN == 1 */
1353:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1354:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			uxIndex += ( size_t ) ucLen;
1355:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
1356:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
1357:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	return uxIndex;
1358:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** }
1359:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
1360:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1361:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #if( ipconfigUSE_TCP_WIN == 1 )
1362:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	_static void prvReadSackOption( const uint8_t * const pucPtr,
1363:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 								   size_t uxIndex,
1364:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 								   FreeRTOS_Socket_t * const pxSocket )
1365:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
1366:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	uint32_t ulFirst = ulChar2u32( &( pucPtr[ uxIndex ] ) );
1367:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	uint32_t ulLast  = ulChar2u32( &( pucPtr[ uxIndex + 4U ] ) );
1368:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	uint32_t ulCount = ulTCPWindowTxSack( &( pxSocket->u.xTCP.xTCPWindow ), ulFirst, ulLast );;
1369:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1370:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* ulTCPWindowTxSack( ) returns the number of bytes which have been acked
1371:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		 * starting from the head position.  Advance the tail pointer in txStream.
1372:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		 */
1373:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( ( pxSocket->u.xTCP.txStream  != NULL ) && ( ulCount > 0U ) )
1374:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
1375:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* Just advancing the tail index, 'ulCount' bytes have been confirmed. */
1376:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( void ) uxStreamBufferGet( pxSocket->u.xTCP.txStream, 0, NULL, ( size_t ) ulCount, pdFALSE );
1377:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxSocket->xEventBits |= ( EventBits_t ) eSOCKET_SEND;
1378:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1379:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			#if ipconfigSUPPORT_SELECT_FUNCTION == 1
1380:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
1381:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				if( ( pxSocket->xSelectBits & ( EventBits_t ) eSELECT_WRITE ) != 0U )
1382:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
1383:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					/* The field 'xEventBits' is used to store regular socket events
1384:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					 * (at most 8), as well as 'select events', which will be left-shifted.
1385:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					 */
1386:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					pxSocket->xEventBits |= ( ( EventBits_t ) eSELECT_WRITE ) << SOCKET_EVENT_BIT_COUNT;
1387:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
1388:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
1389:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			#endif
1390:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1391:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* In case the socket owner has installed an OnSent handler,
1392:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			call it now. */
1393:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			#if( ipconfigUSE_CALLBACKS == 1 )
1394:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
1395:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				if( ipconfigIS_VALID_PROG_ADDRESS( pxSocket->u.xTCP.pxHandleSent ) )
1396:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
1397:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					pxSocket->u.xTCP.pxHandleSent( pxSocket, ulCount );
1398:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
1399:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
1400:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			#endif /* ipconfigUSE_CALLBACKS == 1  */
1401:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
1402:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
1403:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1404:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #endif	/* ( ipconfigUSE_TCP_WIN != 0 ) */
1405:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
1406:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1407:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #if( ipconfigUSE_TCP_WIN != 0 )
1408:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1409:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	static uint8_t prvWinScaleFactor( const FreeRTOS_Socket_t *pxSocket )
1410:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
1411:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	size_t uxWinSize;
1412:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	uint8_t ucFactor;
1413:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1414:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* 'xTCP.uxRxWinSize' is the size of the reception window in units of MSS. */
1415:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		uxWinSize = pxSocket->u.xTCP.uxRxWinSize * ( size_t ) pxSocket->u.xTCP.usInitMSS;
1416:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		ucFactor = 0U;
1417:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		while( uxWinSize > 0xffffUL )
1418:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
1419:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* Divide by two and increase the binary factor by 1. */
1420:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			uxWinSize >>= 1;
1421:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			ucFactor++;
1422:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
1423:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1424:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		FreeRTOS_debug_printf( ( "prvWinScaleFactor: uxRxWinSize %u MSS %u Factor %u\n",
1425:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( unsigned ) pxSocket->u.xTCP.uxRxWinSize,
1426:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( unsigned ) pxSocket->u.xTCP.usInitMSS,
1427:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			ucFactor ) );
1428:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1429:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		return ucFactor;
1430:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
1431:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1432:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #endif
1433:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
1434:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1435:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
1436:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * When opening a TCP connection, while SYN's are being sent, the  parties may
1437:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * communicate what MSS (Maximum Segment Size) they intend to use.   MSS is the
1438:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * nett size of the payload, always smaller than MTU.
1439:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** */
1440:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static UBaseType_t prvSetSynAckOptions( FreeRTOS_Socket_t *pxSocket, TCPHeader_t * pxTCPHeader )
1441:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** {
1442:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint16_t usMSS = pxSocket->u.xTCP.usInitMSS;
1443:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** UBaseType_t uxOptionsLength;
1444:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1445:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	/* We send out the TCP Maximum Segment Size option with our SYN[+ACK]. */
1446:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1447:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	pxTCPHeader->ucOptdata[ 0 ] = ( uint8_t ) tcpTCP_OPT_MSS;
1448:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	pxTCPHeader->ucOptdata[ 1 ] = ( uint8_t ) tcpTCP_OPT_MSS_LEN;
1449:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	pxTCPHeader->ucOptdata[ 2 ] = ( uint8_t ) ( usMSS >> 8 );
1450:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	pxTCPHeader->ucOptdata[ 3 ] = ( uint8_t ) ( usMSS & 0xffU );
1451:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1452:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#if( ipconfigUSE_TCP_WIN != 0 )
1453:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
1454:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxSocket->u.xTCP.ucMyWinScaleFactor = prvWinScaleFactor( pxSocket );
1455:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1456:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPHeader->ucOptdata[ 4 ] = tcpTCP_OPT_NOOP;
1457:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPHeader->ucOptdata[ 5 ] = ( uint8_t ) ( tcpTCP_OPT_WSOPT );
1458:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPHeader->ucOptdata[ 6 ] = ( uint8_t ) ( tcpTCP_OPT_WSOPT_LEN );
1459:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPHeader->ucOptdata[ 7 ] = ( uint8_t ) pxSocket->u.xTCP.ucMyWinScaleFactor;
1460:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		uxOptionsLength = 8U;
1461:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
1462:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#else
1463:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
1464:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		uxOptionsLength = 4U;
1465:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
1466:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#endif
1467:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1468:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#if( ipconfigUSE_TCP_WIN != 0 )
1469:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
1470:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPHeader->ucOptdata[ uxOptionsLength      ] = tcpTCP_OPT_NOOP;
1471:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPHeader->ucOptdata[ uxOptionsLength + 1U ] = tcpTCP_OPT_NOOP;
1472:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPHeader->ucOptdata[ uxOptionsLength + 2U ] = tcpTCP_OPT_SACK_P;	/* 4: Sack-Permitted Option. 
1473:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPHeader->ucOptdata[ uxOptionsLength + 3U ] = 2U;	/* 2: length of this option. */
1474:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		uxOptionsLength += 4U;
1475:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1476:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
1477:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#endif	/* ipconfigUSE_TCP_WIN == 0 */
1478:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	return uxOptionsLength; /* bytes, not words. */
1479:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** }
1480:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1481:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
1482:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * For anti-hanging protection and TCP keep-alive messages.  Called in two
1483:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * places: after receiving a packet and after a state change.  The socket's
1484:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * alive timer may be reset.
1485:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
1486:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static void prvTCPTouchSocket( FreeRTOS_Socket_t *pxSocket )
1487:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** {
1488:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#if( ipconfigTCP_HANG_PROTECTION == 1 )
1489:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
1490:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxSocket->u.xTCP.xLastActTime = xTaskGetTickCount( );
1491:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
1492:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#endif
1493:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1494:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#if( ipconfigTCP_KEEP_ALIVE == 1 )
1495:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
1496:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxSocket->u.xTCP.bits.bWaitKeepAlive = pdFALSE_UNSIGNED;
1497:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxSocket->u.xTCP.bits.bSendKeepAlive = pdFALSE_UNSIGNED;
1498:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxSocket->u.xTCP.ucKeepRepCount = 0U;
1499:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxSocket->u.xTCP.xLastAliveTime = xTaskGetTickCount();
1500:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
1501:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#endif
1502:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1503:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	( void ) pxSocket;
1504:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** }
1505:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
1506:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1507:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
1508:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Changing to a new state. Centralised here to do specific actions such as
1509:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * resetting the alive timer, calling the user's OnConnect handler to notify
1510:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * that a socket has got (dis)connected, and setting bit to unblock a call to
1511:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * FreeRTOS_select()
1512:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
1513:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** void vTCPStateChange( FreeRTOS_Socket_t *pxSocket, enum eTCP_STATE eTCPState )
1514:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** {
1515:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** FreeRTOS_Socket_t *xParent = NULL;
1516:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** BaseType_t bBefore = ipNUMERIC_CAST( BaseType_t, tcpNOW_CONNECTED( ( BaseType_t ) pxSocket->u.xTCP.
1517:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** BaseType_t bAfter  = ipNUMERIC_CAST( BaseType_t, tcpNOW_CONNECTED( ( BaseType_t ) eTCPState ) );			
1518:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #if( ipconfigHAS_DEBUG_PRINTF != 0 )
1519:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	BaseType_t xPreviousState = ( BaseType_t ) pxSocket->u.xTCP.ucTCPState;
1520:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #endif
1521:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #if( ipconfigUSE_CALLBACKS == 1 )
1522:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	FreeRTOS_Socket_t *xConnected = NULL;
1523:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #endif
1524:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1525:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	/* Has the connected status changed? */
1526:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( bBefore != bAfter )
1527:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
1528:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Is the socket connected now ? */
1529:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( bAfter != pdFALSE )
1530:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
1531:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* if bPassQueued is true, this socket is an orphan until it gets connected. */
1532:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( pxSocket->u.xTCP.bits.bPassQueued != pdFALSE_UNSIGNED )
1533:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
1534:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				/* Now that it is connected, find it's parent. */
1535:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				if( pxSocket->u.xTCP.bits.bReuseSocket != pdFALSE_UNSIGNED )
1536:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
1537:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					xParent = pxSocket;
1538:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
1539:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				else
1540:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
1541:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					xParent = pxSocket->u.xTCP.pxPeerSocket;
1542:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					configASSERT( xParent != NULL );
1543:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
1544:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				if( xParent != NULL )
1545:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
1546:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					if( xParent->u.xTCP.pxPeerSocket == NULL )
1547:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					{
1548:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						xParent->u.xTCP.pxPeerSocket = pxSocket;
1549:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					}
1550:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1551:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					xParent->xEventBits |= ( EventBits_t ) eSOCKET_ACCEPT;
1552:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1553:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
1554:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					{
1555:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						/* Library support FreeRTOS_select().  Receiving a new
1556:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						connection is being translated as a READ event. */
1557:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						if( ( xParent->xSelectBits & ( ( EventBits_t ) eSELECT_READ ) ) != 0U )
1558:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						{
1559:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							xParent->xEventBits |= ( ( EventBits_t ) eSELECT_READ ) << SOCKET_EVENT_BIT_COUNT;
1560:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						}
1561:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					}
1562:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					#endif
1563:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1564:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					#if( ipconfigUSE_CALLBACKS == 1 )
1565:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					{
1566:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						if( ( ipconfigIS_VALID_PROG_ADDRESS( xParent->u.xTCP.pxHandleConnected ) ) &&
1567:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							( xParent->u.xTCP.bits.bReuseSocket == pdFALSE_UNSIGNED ) )
1568:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						{
1569:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							/* The listening socket does not become connected itself, in stead
1570:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							a child socket is created.
1571:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							Postpone a call the OnConnect event until the end of this function. */
1572:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							xConnected = xParent;
1573:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						}
1574:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					}
1575:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					#endif
1576:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
1577:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1578:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				/* Don't need to access the parent socket anymore, so the
1579:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				reference 'pxPeerSocket' may be cleared. */
1580:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxSocket->u.xTCP.pxPeerSocket = NULL;
1581:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxSocket->u.xTCP.bits.bPassQueued = pdFALSE_UNSIGNED;
1582:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1583:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				/* When true, this socket may be returned in a call to accept(). */
1584:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxSocket->u.xTCP.bits.bPassAccept = pdTRUE_UNSIGNED;
1585:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
1586:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			else
1587:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
1588:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxSocket->xEventBits |= ( EventBits_t ) eSOCKET_CONNECT;
1589:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1590:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
1591:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
1592:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					if( ( pxSocket->xSelectBits & ( ( EventBits_t ) eSELECT_WRITE ) ) != 0U )
1593:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					{
1594:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						pxSocket->xEventBits |= ( ( EventBits_t ) eSELECT_WRITE ) << SOCKET_EVENT_BIT_COUNT;
1595:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					}
1596:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
1597:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				#endif
1598:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
1599:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
1600:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		else  /* bAfter == pdFALSE, connection is closed. */
1601:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
1602:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* Notify/wake-up the socket-owner by setting a semaphore. */
1603:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxSocket->xEventBits |= ( EventBits_t ) eSOCKET_CLOSED;
1604:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1605:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
1606:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
1607:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				if( ( pxSocket->xSelectBits & ( EventBits_t ) eSELECT_EXCEPT ) != 0U )
1608:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
1609:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					pxSocket->xEventBits |= ( ( EventBits_t ) eSELECT_EXCEPT ) << SOCKET_EVENT_BIT_COUNT;
1610:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
1611:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
1612:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			#endif
1613:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
1614:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		#if( ipconfigUSE_CALLBACKS == 1 )
1615:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
1616:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( ( ipconfigIS_VALID_PROG_ADDRESS( pxSocket->u.xTCP.pxHandleConnected ) ) && ( xConnected == N
1617:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
1618:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				/* The 'connected' state has changed, call the user handler. */
1619:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				xConnected = pxSocket;
1620:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
1621:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
1622:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		#endif /* ipconfigUSE_CALLBACKS */
1623:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1624:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( prvTCPSocketIsActive( ipNUMERIC_CAST( eIPTCPState_t, pxSocket->u.xTCP.ucTCPState ) ) == 0 )
1625:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
1626:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* Now the socket isn't in an active state anymore so it
1627:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			won't need further attention of the IP-task.
1628:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			Setting time-out to zero means that the socket won't get checked during
1629:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			timer events. */
1630:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxSocket->u.xTCP.usTimeout = 0U;
1631:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
1632:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
1633:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	else
1634:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
1635:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( ( ( BaseType_t ) eTCPState ) ==  ( ( BaseType_t ) eCLOSED ) )
1636:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
1637:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* Socket goes to status eCLOSED because of a RST.
1638:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			When nobody owns the socket yet, delete it. */
1639:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( ( pxSocket->u.xTCP.bits.bPassQueued != pdFALSE_UNSIGNED ) ||
1640:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				( pxSocket->u.xTCP.bits.bPassAccept != pdFALSE_UNSIGNED ) )
1641:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
1642:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				FreeRTOS_debug_printf( ( "vTCPStateChange: Closing socket\n" ) );
1643:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				if( pxSocket->u.xTCP.bits.bReuseSocket == pdFALSE_UNSIGNED )
1644:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
1645:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					( void ) FreeRTOS_closesocket( pxSocket );
1646:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
1647:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
1648:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
1649:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
1650:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1651:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	/* Fill in the new state. */
1652:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	pxSocket->u.xTCP.ucTCPState = ( uint8_t ) eTCPState;
1653:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1654:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	/* Touch the alive timers because moving to another state. */
1655:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	prvTCPTouchSocket( pxSocket );
1656:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1657:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#if( ipconfigHAS_DEBUG_PRINTF == 1 )
1658:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
1659:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( ( xTCPWindowLoggingLevel >= 0 ) && ( ipconfigTCP_MAY_LOG_PORT( pxSocket->usLocalPort ) ) )
1660:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
1661:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			FreeRTOS_debug_printf( ( "Socket %d -> %lxip:%u State %s->%s\n",
1662:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxSocket->usLocalPort,
1663:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxSocket->u.xTCP.ulRemoteIP,
1664:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxSocket->u.xTCP.usRemotePort,
1665:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				FreeRTOS_GetTCPStateName( ( UBaseType_t ) xPreviousState ),
1666:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				FreeRTOS_GetTCPStateName( ( UBaseType_t ) eTCPState ) ) );
1667:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
1668:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
1669:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#endif /* ipconfigHAS_DEBUG_PRINTF */
1670:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1671:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#if( ipconfigUSE_CALLBACKS == 1 )
1672:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
1673:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( xConnected != NULL )
1674:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
1675:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* The 'connected' state has changed, call the OnConnect handler of the parent. */
1676:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			xConnected->u.xTCP.pxHandleConnected( ( Socket_t ) xConnected, bAfter );
1677:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
1678:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
1679:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#endif
1680:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( xParent != NULL )
1681:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
1682:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		vSocketWakeUpUser( xParent );
1683:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
1684:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** }
1685:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
1686:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1687:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static NetworkBufferDescriptor_t *prvTCPBufferResize( const FreeRTOS_Socket_t *pxSocket, NetworkBuf
1688:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	int32_t lDataLen, UBaseType_t uxOptionsLength )
1689:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** {
1690:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** NetworkBufferDescriptor_t *pxReturn;
1691:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** size_t uxNeeded;
1692:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** BaseType_t xResize;
1693:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1694:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( xBufferAllocFixedSize != pdFALSE )
1695:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
1696:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Network buffers are created with a fixed size and can hold the largest
1697:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		MTU. */
1698:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		uxNeeded = ( size_t ) ipTOTAL_ETHERNET_FRAME_SIZE;
1699:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* and therefore, the buffer won't be too small.
1700:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		Only ask for a new network buffer in case none was supplied. */
1701:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( pxNetworkBuffer == NULL )
1702:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
1703:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			xResize = pdTRUE;
1704:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
1705:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		else
1706:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
1707:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			xResize = pdFALSE;
1708:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
1709:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
1710:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	else
1711:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
1712:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Network buffers are created with a variable size. See if it must
1713:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		grow. */
1714:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		uxNeeded = ipNUMERIC_CAST( size_t, ipSIZE_OF_ETH_HEADER + uxIPHeaderSizeSocket( pxSocket ) + ipSI
1715:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1716:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( uxNeeded < sizeof( pxSocket->u.xTCP.xPacket.u.ucLastPacket ) )
1717:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
1718:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			uxNeeded = sizeof( pxSocket->u.xTCP.xPacket.u.ucLastPacket );
1719:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
1720:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1721:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* In case we were called from a TCP timer event, a buffer must be
1722:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		created.  Otherwise, test 'xDataLength' of the provided buffer. */
1723:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( ( pxNetworkBuffer == NULL ) || ( pxNetworkBuffer->xDataLength < uxNeeded ) )
1724:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
1725:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			xResize = pdTRUE;
1726:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
1727:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		else
1728:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
1729:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			xResize = pdFALSE;
1730:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
1731:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
1732:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1733:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( xResize != pdFALSE )
1734:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
1735:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* The caller didn't provide a network buffer or the provided buffer is
1736:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		too small.  As we must send-out a data packet, a buffer will be created
1737:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		here. */
1738:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxReturn = pxGetNetworkBufferWithDescriptor( uxNeeded, 0U );
1739:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1740:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( pxReturn != NULL )
1741:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
1742:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* Set the actual packet size, in case the returned buffer is larger. */
1743:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxReturn->xDataLength = uxNeeded;
1744:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1745:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* Copy the existing data to the new created buffer. */
1746:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( pxNetworkBuffer != NULL )
1747:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
1748:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				/* Either from the previous buffer... */
1749:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				( void ) memcpy( pxReturn->pucEthernetBuffer, pxNetworkBuffer->pucEthernetBuffer, pxNetworkBuff
1750:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1751:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				/* ...and release it. */
1752:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
1753:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
1754:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			else
1755:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
1756:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				/* Or from the socket field 'xTCP.xPacket'. */
1757:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				( void ) memcpy( pxReturn->pucEthernetBuffer, pxSocket->u.xTCP.xPacket.u.ucLastPacket, sizeof( 
1758:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
1759:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
1760:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
1761:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	else
1762:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
1763:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* xResize is false, the network buffer provided was big enough. */
1764:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		configASSERT( pxNetworkBuffer != NULL );	/* to tell lint: when xResize is false, pxNetworkBuffer 
1765:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxReturn = pxNetworkBuffer;
1766:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1767:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Thanks to Andrey Ivanov from swissEmbedded for reporting that the
1768:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		xDataLength member must get the correct length too! */
1769:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxNetworkBuffer->xDataLength = ( size_t ) ( ipSIZE_OF_ETH_HEADER + uxIPHeaderSizeSocket( pxSocket
1770:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
1771:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1772:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	return pxReturn;
1773:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** }
1774:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
1775:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1776:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
1777:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Prepare an outgoing message, in case anything has to be sent.
1778:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
1779:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static int32_t prvTCPPrepareSend( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **ppxNetwo
1780:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** {
1781:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** int32_t lDataLen;
1782:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint8_t *pucEthernetBuffer, *pucSendData;
1783:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** ProtocolHeaders_t *pxProtocolHeaders;
1784:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** size_t uxOffset;
1785:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint32_t ulDataGot, ulDistance;
1786:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** TCPWindow_t *pxTCPWindow;
1787:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** NetworkBufferDescriptor_t *pxNewBuffer;
1788:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** int32_t lStreamPos;
1789:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** UBaseType_t uxIntermediateResult = 0;
1790:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1791:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( ( *ppxNetworkBuffer ) != NULL )
1792:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
1793:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* A network buffer descriptor was already supplied */
1794:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pucEthernetBuffer = ( *ppxNetworkBuffer )->pucEthernetBuffer;
1795:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
1796:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	else
1797:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
1798:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* For now let it point to the last packet header */
1799:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pucEthernetBuffer = pxSocket->u.xTCP.xPacket.u.ucLastPacket;
1800:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
1801:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1802:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	/* Map the ethernet buffer onto the ProtocolHeader_t struct for easy access to the fields. */
1803:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	pxProtocolHeaders = ipCAST_PTR_TO_TYPE_PTR( ProtocolHeaders_t, &( pucEthernetBuffer[ ipSIZE_OF_ETH
1804:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	pxTCPWindow = &( pxSocket->u.xTCP.xTCPWindow );
1805:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	lDataLen = 0;
1806:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	lStreamPos = 0;
1807:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	pxProtocolHeaders->xTCPHeader.ucTCPFlags |= tcpTCP_FLAG_ACK;
1808:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1809:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( pxSocket->u.xTCP.txStream != NULL )
1810:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
1811:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* ulTCPWindowTxGet will return the amount of data which may be sent
1812:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		along with the position in the txStream.
1813:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		Why check for MSS > 1 ?
1814:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		Because some TCP-stacks (like uIP) use it for flow-control. */
1815:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( pxSocket->u.xTCP.usCurMSS > 1U )
1816:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
1817:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			lDataLen = ( int32_t ) ulTCPWindowTxGet( pxTCPWindow, pxSocket->u.xTCP.ulWindowSize, &lStreamPos
1818:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
1819:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1820:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( lDataLen > 0 )
1821:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
1822:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* Check if the current network buffer is big enough, if not,
1823:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			resize it. */
1824:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxNewBuffer = prvTCPBufferResize( pxSocket, *ppxNetworkBuffer, lDataLen, uxOptionsLength );
1825:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1826:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( pxNewBuffer != NULL )
1827:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
1828:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				*ppxNetworkBuffer = pxNewBuffer;
1829:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pucEthernetBuffer = pxNewBuffer->pucEthernetBuffer;
1830:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1831:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				/* Map the byte stream onto ProtocolHeaders_t struct for easy
1832:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				 * access to the fields. */
1833:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxProtocolHeaders = ipCAST_PTR_TO_TYPE_PTR( ProtocolHeaders_t, &( pucEthernetBuffer[ ipSIZE_OF_
1834:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1835:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pucSendData = &( pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + uxIPHeaderSizeSocket( pxSocket ) + i
1836:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1837:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				/* Translate the position in txStream to an offset from the tail
1838:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				marker. */
1839:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				uxOffset = uxStreamBufferDistance( pxSocket->u.xTCP.txStream, pxSocket->u.xTCP.txStream->uxTail
1840:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1841:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				/* Here data is copied from the txStream in 'peek' mode.  Only
1842:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				when the packets are acked, the tail marker will be updated. */
1843:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				ulDataGot = ( uint32_t ) uxStreamBufferGet( pxSocket->u.xTCP.txStream, uxOffset, pucSendData, (
1844:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1845:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				#if( ipconfigHAS_DEBUG_PRINTF != 0 )
1846:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
1847:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					if( ulDataGot != ( uint32_t ) lDataLen )
1848:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					{
1849:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						FreeRTOS_debug_printf( ( "uxStreamBufferGet: pos %d offs %u only %u != %d\n",
1850:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							( int ) lStreamPos, ( unsigned ) uxOffset, ( unsigned ) ulDataGot, ( int ) lDataLen ) );
1851:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					}
1852:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
1853:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				#endif
1854:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1855:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				/* If the owner of the socket requests a closure, add the FIN
1856:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				flag to the last packet. */
1857:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				if( ( pxSocket->u.xTCP.bits.bCloseRequested != pdFALSE_UNSIGNED ) && ( pxSocket->u.xTCP.bits.bF
1858:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
1859:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					ulDistance = ( uint32_t ) uxStreamBufferDistance( pxSocket->u.xTCP.txStream, ( size_t ) lStrea
1860:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1861:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					if( ulDistance == ulDataGot )
1862:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					{
1863:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						#if (ipconfigHAS_DEBUG_PRINTF == 1)
1864:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						{
1865:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						/* the order of volatile accesses is undefined
1866:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							so such workaround */
1867:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							size_t uxHead = pxSocket->u.xTCP.txStream->uxHead;
1868:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							size_t uxMid = pxSocket->u.xTCP.txStream->uxMid;
1869:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							size_t uxTail = pxSocket->u.xTCP.txStream->uxTail;
1870:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1871:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							FreeRTOS_debug_printf( ( "CheckClose %u <= %u (%u <= %u <= %u)\n",
1872:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 								( unsigned ) ulDataGot, ( unsigned ) ulDistance,
1873:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 								( unsigned ) uxTail, ( unsigned ) uxMid, ( unsigned ) uxHead ) );
1874:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						}
1875:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						#endif
1876:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						/* Although the socket sends a FIN, it will stay in
1877:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						ESTABLISHED until all current data has been received or
1878:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						delivered. */
1879:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						pxProtocolHeaders->xTCPHeader.ucTCPFlags |= tcpTCP_FLAG_FIN;
1880:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						pxTCPWindow->tx.ulFINSequenceNumber = pxTCPWindow->ulOurSequenceNumber + ( uint32_t ) lDataLe
1881:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						pxSocket->u.xTCP.bits.bFinSent = pdTRUE_UNSIGNED;
1882:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					}
1883:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
1884:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
1885:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			else
1886:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
1887:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				lDataLen = -1;
1888:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
1889:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
1890:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
1891:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1892:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( ( lDataLen >= 0 ) && ( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eESTABLISHED ) )
1893:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
1894:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* See if the socket owner wants to shutdown this connection. */
1895:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( ( pxSocket->u.xTCP.bits.bUserShutdown != pdFALSE_UNSIGNED ) &&
1896:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( xTCPWindowTxDone( pxTCPWindow ) != pdFALSE ) )
1897:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
1898:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxSocket->u.xTCP.bits.bUserShutdown = pdFALSE_UNSIGNED;
1899:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxProtocolHeaders->xTCPHeader.ucTCPFlags |= tcpTCP_FLAG_FIN;
1900:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxSocket->u.xTCP.bits.bFinSent = pdTRUE_UNSIGNED;
1901:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxSocket->u.xTCP.bits.bWinChange = pdTRUE_UNSIGNED;
1902:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxTCPWindow->tx.ulFINSequenceNumber = pxTCPWindow->tx.ulCurrentSequenceNumber;
1903:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			vTCPStateChange( pxSocket, eFIN_WAIT_1 );
1904:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
1905:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1906:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		#if( ipconfigTCP_KEEP_ALIVE != 0 )
1907:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
1908:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( pxSocket->u.xTCP.ucKeepRepCount > 3U ) /*_RB_ Magic number. */
1909:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
1910:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				FreeRTOS_debug_printf( ( "keep-alive: giving up %lxip:%u\n",
1911:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					pxSocket->u.xTCP.ulRemoteIP,			/* IP address of remote machine. */
1912:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					pxSocket->u.xTCP.usRemotePort ) );	/* Port on remote machine. */
1913:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				vTCPStateChange( pxSocket, eCLOSE_WAIT );
1914:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				lDataLen = -1;
1915:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
1916:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( ( lDataLen == 0 ) && ( pxSocket->u.xTCP.bits.bWinChange == pdFALSE_UNSIGNED ) )
1917:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
1918:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				/* If there is no data to be sent, and no window-update message,
1919:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				we might want to send a keep-alive message. */
1920:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				TickType_t xAge = xTaskGetTickCount( ) - pxSocket->u.xTCP.xLastAliveTime;
1921:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				TickType_t xMax;
1922:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				xMax = ( ( TickType_t ) ipconfigTCP_KEEP_ALIVE_INTERVAL * ( TickType_t ) configTICK_RATE_HZ );
1923:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				if( pxSocket->u.xTCP.ucKeepRepCount != ( uint8_t ) 0U )
1924:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
1925:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					xMax = ( TickType_t ) ( 3U * configTICK_RATE_HZ );
1926:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
1927:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				if( xAge > xMax )
1928:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
1929:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					pxSocket->u.xTCP.xLastAliveTime = xTaskGetTickCount( );
1930:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					if( xTCPWindowLoggingLevel != 0 )
1931:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					{
1932:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						FreeRTOS_debug_printf( ( "keep-alive: %lxip:%u count %u\n",
1933:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							pxSocket->u.xTCP.ulRemoteIP,
1934:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							pxSocket->u.xTCP.usRemotePort,
1935:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							pxSocket->u.xTCP.ucKeepRepCount ) );
1936:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					}
1937:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					pxSocket->u.xTCP.bits.bSendKeepAlive = pdTRUE_UNSIGNED;
1938:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					pxSocket->u.xTCP.usTimeout = ( ( uint16_t ) pdMS_TO_TICKS( 2500U ) );
1939:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					pxSocket->u.xTCP.ucKeepRepCount++;
1940:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
1941:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
1942:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
1943:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		#endif /* ipconfigTCP_KEEP_ALIVE */
1944:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
1945:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1946:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	/* Anything to send, a change of the advertised window size, or maybe send a
1947:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	keep-alive message? */
1948:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( ( lDataLen > 0 ) ||
1949:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		( pxSocket->u.xTCP.bits.bWinChange != pdFALSE_UNSIGNED ) ||
1950:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		( pxSocket->u.xTCP.bits.bSendKeepAlive != pdFALSE_UNSIGNED ) )
1951:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
1952:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxProtocolHeaders->xTCPHeader.ucTCPFlags &= ( ( uint8_t ) ~tcpTCP_FLAG_PSH );
1953:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxProtocolHeaders->xTCPHeader.ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength
1954:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1955:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxProtocolHeaders->xTCPHeader.ucTCPFlags |= ( uint8_t ) tcpTCP_FLAG_ACK;
1956:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1957:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( lDataLen != 0L )
1958:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
1959:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxProtocolHeaders->xTCPHeader.ucTCPFlags |= ( uint8_t ) tcpTCP_FLAG_PSH;
1960:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
1961:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1962:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		uxIntermediateResult = uxIPHeaderSizeSocket( pxSocket ) + ipSIZE_OF_TCP_HEADER + uxOptionsLength;
1963:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		lDataLen += ( int32_t ) uxIntermediateResult;
1964:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
1965:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1966:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	return lDataLen;
1967:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** }
1968:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
1969:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1970:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
1971:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Calculate after how much time this socket needs to be checked again.
1972:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
1973:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static TickType_t prvTCPNextTimeout ( FreeRTOS_Socket_t *pxSocket )
1974:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** {
1975:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** TickType_t ulDelayMs = ( TickType_t ) tcpMAXIMUM_TCP_WAKEUP_TIME_MS;
1976:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1977:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eCONNECT_SYN )
1978:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
1979:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* The socket is actively connecting to a peer. */
1980:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( pxSocket->u.xTCP.bits.bConnPrepared != pdFALSE_UNSIGNED )
1981:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
1982:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* Ethernet address has been found, use progressive timeout for
1983:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			active connect(). */
1984:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( pxSocket->u.xTCP.ucRepCount < 3U )
1985:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
1986:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				ulDelayMs = ( 3000UL << ( pxSocket->u.xTCP.ucRepCount - 1U ) );
1987:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
1988:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			else
1989:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
1990:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				ulDelayMs = 11000UL;
1991:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
1992:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
1993:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		else
1994:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
1995:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* Still in the ARP phase: check every half second. */
1996:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			ulDelayMs = 500UL;
1997:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
1998:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
1999:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		FreeRTOS_debug_printf( ( "Connect[%lxip:%u]: next timeout %u: %lu ms\n",
2000:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxSocket->u.xTCP.ulRemoteIP, pxSocket->u.xTCP.usRemotePort,
2001:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxSocket->u.xTCP.ucRepCount, ulDelayMs ) );
2002:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxSocket->u.xTCP.usTimeout = ( uint16_t )ipMS_TO_MIN_TICKS( ulDelayMs );
2003:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
2004:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	else if( pxSocket->u.xTCP.usTimeout == 0U )
2005:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
2006:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Let the sliding window mechanism decide what time-out is appropriate. */
2007:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		BaseType_t xResult = xTCPWindowTxHasData( &pxSocket->u.xTCP.xTCPWindow, pxSocket->u.xTCP.ulWindow
2008:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( ulDelayMs == 0U )
2009:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
2010:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( xResult != ( BaseType_t )0 )
2011:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
2012:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				ulDelayMs = 1UL;
2013:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
2014:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			else
2015:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
2016:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				ulDelayMs = tcpMAXIMUM_TCP_WAKEUP_TIME_MS;
2017:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
2018:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
2019:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		else
2020:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
2021:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* ulDelayMs contains the time to wait before a re-transmission. */
2022:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
2023:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxSocket->u.xTCP.usTimeout = ( uint16_t ) ipMS_TO_MIN_TICKS( ulDelayMs );
2024:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
2025:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	else
2026:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
2027:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* field '.usTimeout' has already been set (by the
2028:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		keep-alive/delayed-ACK mechanism). */
2029:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
2030:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2031:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	/* Return the number of clock ticks before the timer expires. */
2032:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	return ( TickType_t ) pxSocket->u.xTCP.usTimeout;
2033:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** }
2034:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
2035:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2036:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static void prvTCPAddTxData( FreeRTOS_Socket_t *pxSocket )
2037:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** {
  26              	 .loc 1 2037 0
  27              	 .cfi_startproc
  28              	 
  29              	 
  30              	.LVL0:
  31 0000 10B5     	 push {r4,lr}
  32              	.LCFI0:
  33              	 .cfi_def_cfa_offset 8
  34              	 .cfi_offset 4,-8
  35              	 .cfi_offset 14,-4
2038:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** int32_t lCount, lLength;
2039:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2040:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	/* A txStream has been created already, see if the socket has new data for
2041:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	the sliding window.
2042:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2043:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	uxStreamBufferMidSpace() returns the distance between rxHead and rxMid.  It
2044:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	contains new Tx data which has not been passed to the sliding window yet.
2045:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	The oldest data not-yet-confirmed can be found at rxTail. */
2046:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	lLength = ( int32_t ) uxStreamBufferMidSpace( pxSocket->u.xTCP.txStream );
  36              	 .loc 1 2046 0
  37 0002 826F     	 ldr r2,[r0,#120]
  38              	.LVL1:
  39              	.LBB117:
  40              	.LBB118:
  41              	 .file 2 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include/FreeRTOS_Stream_Buffer.h"
   1:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** /*
   2:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  * FreeRTOS+TCP V2.2.2
   3:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  *
   5:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  * this software and associated documentation files (the "Software"), to deal in
   7:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  * the Software without restriction, including without limitation the rights to
   8:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  * subject to the following conditions:
  11:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  *
  12:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  * The above copyright notice and this permission notice shall be included in all
  13:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  * copies or substantial portions of the Software.
  14:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  *
  15:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  *
  22:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  * http://aws.amazon.com/freertos
  23:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  * http://www.FreeRTOS.org
  24:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  */
  25:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
  26:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** /*
  27:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  *	FreeRTOS_Stream_Buffer.h
  28:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  *
  29:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  *	A cicular character buffer
  30:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  *	An implementation of a circular buffer without a length field
  31:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  *	If LENGTH defines the size of the buffer, a maximum of (LENGT-1) bytes can be stored
  32:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  *	In order to add or read data from the buffer, memcpy() will be called at most 2 times
  33:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h ****  */
  34:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
  35:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** #ifndef FREERTOS_STREAM_BUFFER_H
  36:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** #define	FREERTOS_STREAM_BUFFER_H
  37:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
  38:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** #ifdef __cplusplus
  39:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** extern "C" {
  40:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** #endif
  41:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
  42:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** typedef struct xSTREAM_BUFFER {
  43:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	volatile size_t uxTail;		/* next item to read */
  44:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	volatile size_t uxMid;		/* iterator within the valid items */
  45:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	volatile size_t uxHead;		/* next position store a new item */
  46:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	volatile size_t uxFront;	/* iterator within the free space */
  47:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	size_t LENGTH;				/* const value: number of reserved elements */
  48:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	uint8_t ucArray[ sizeof( size_t ) ];
  49:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** } StreamBuffer_t;
  50:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
  51:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** static portINLINE void vStreamBufferClear( StreamBuffer_t *pxBuffer );
  52:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** static portINLINE void vStreamBufferClear( StreamBuffer_t *pxBuffer )
  53:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** {
  54:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	/* Make the circular buffer empty */
  55:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	pxBuffer->uxHead = 0U;
  56:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	pxBuffer->uxTail = 0U;
  57:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	pxBuffer->uxFront = 0U;
  58:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	pxBuffer->uxMid = 0U;
  59:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** }
  60:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** /*-----------------------------------------------------------*/
  61:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
  62:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** static portINLINE size_t uxStreamBufferSpace( const StreamBuffer_t *pxBuffer, const size_t uxLower,
  63:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** static portINLINE size_t uxStreamBufferSpace( const StreamBuffer_t *pxBuffer, const size_t uxLower,
  64:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** {
  65:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** /* Returns the space between uxLower and uxUpper, which equals to the distance minus 1 */
  66:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxCount;
  67:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
  68:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	uxCount = pxBuffer->LENGTH + uxUpper - uxLower - 1U;
  69:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	if( uxCount >= pxBuffer->LENGTH )
  70:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	{
  71:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 		uxCount -= pxBuffer->LENGTH;
  72:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	}
  73:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
  74:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	return uxCount;
  75:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** }
  76:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** /*-----------------------------------------------------------*/
  77:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
  78:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** static portINLINE size_t uxStreamBufferDistance( const StreamBuffer_t *pxBuffer, const size_t uxLow
  79:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** static portINLINE size_t uxStreamBufferDistance( const StreamBuffer_t *pxBuffer, const size_t uxLow
  80:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** {
  81:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** /* Returns the distance between uxLower and uxUpper */
  82:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxCount;
  83:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
  84:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
  85:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	if ( uxCount >= pxBuffer->LENGTH )
  86:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	{
  87:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 		uxCount -= pxBuffer->LENGTH;
  88:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	}
  89:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
  90:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	return uxCount;
  91:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** }
  92:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** /*-----------------------------------------------------------*/
  93:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
  94:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** static portINLINE size_t uxStreamBufferGetSpace( const StreamBuffer_t *pxBuffer );
  95:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** static portINLINE size_t uxStreamBufferGetSpace( const StreamBuffer_t *pxBuffer )
  96:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** {
  97:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** /* Returns the number of items which can still be added to uxHead
  98:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** before hitting on uxTail */
  99:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxHead = pxBuffer->uxHead;
 100:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxTail = pxBuffer->uxTail;
 101:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
 102:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	return uxStreamBufferSpace( pxBuffer, uxHead, uxTail );
 103:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** }
 104:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** /*-----------------------------------------------------------*/
 105:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
 106:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** static portINLINE size_t uxStreamBufferFrontSpace( const StreamBuffer_t *pxBuffer );
 107:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** static portINLINE size_t uxStreamBufferFrontSpace( const StreamBuffer_t *pxBuffer )
 108:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** {
 109:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** /* Distance between uxFront and uxTail
 110:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** or the number of items which can still be added to uxFront,
 111:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** before hitting on uxTail */
 112:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
 113:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxFront = pxBuffer->uxFront;
 114:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxTail = pxBuffer->uxTail;
 115:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
 116:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	return uxStreamBufferSpace( pxBuffer, uxFront, uxTail );
 117:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** }
 118:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** /*-----------------------------------------------------------*/
 119:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
 120:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** static portINLINE size_t uxStreamBufferGetSize( const StreamBuffer_t *pxBuffer );
 121:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** static portINLINE size_t uxStreamBufferGetSize( const StreamBuffer_t *pxBuffer )
 122:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** {
 123:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** /* Returns the number of items which can be read from uxTail
 124:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** before reaching uxHead */
 125:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxHead = pxBuffer->uxHead;
 126:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxTail = pxBuffer->uxTail;
 127:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
 128:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	return uxStreamBufferDistance( pxBuffer, uxTail, uxHead );
 129:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** }
 130:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** /*-----------------------------------------------------------*/
 131:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
 132:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** static portINLINE size_t uxStreamBufferMidSpace( const StreamBuffer_t *pxBuffer );
 133:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** static portINLINE size_t uxStreamBufferMidSpace( const StreamBuffer_t *pxBuffer )
 134:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** {
 135:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** /* Returns the distance between uxHead and uxMid */
 136:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxHead = pxBuffer->uxHead;
  42              	 .loc 2 136 0
  43 0004 9168     	 ldr r1,[r2,#8]
  44              	.LVL2:
 137:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxMid = pxBuffer->uxMid;
  45              	 .loc 2 137 0
  46 0006 5468     	 ldr r4,[r2,#4]
  47              	.LVL3:
  48              	.LBB119:
  49              	.LBB120:
  84:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	if ( uxCount >= pxBuffer->LENGTH )
  50              	 .loc 2 84 0
  51 0008 1369     	 ldr r3,[r2,#16]
  52 000a 1944     	 add r1,r1,r3
  53              	.LVL4:
  54 000c 091B     	 subs r1,r1,r4
  55              	.LVL5:
  85:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	{
  56              	 .loc 2 85 0
  57 000e 8B42     	 cmp r3,r1
  87:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	}
  58              	 .loc 2 87 0
  59 0010 98BF     	 it ls
  60 0012 C91A     	 subls r1,r1,r3
  61              	.LVL6:
  62              	.LBE120:
  63              	.LBE119:
  64              	.LBE118:
  65              	.LBE117:
2047:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2048:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( lLength > 0 )
  66              	 .loc 1 2048 0
  67 0014 0029     	 cmp r1,#0
  68 0016 1BDD     	 ble .L1
  69 0018 0446     	 mov r4,r0
  70              	.LVL7:
2049:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
2050:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* All data between txMid and rxHead will now be passed to the sliding
2051:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		window manager, so it can start transmitting them.
2052:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2053:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		Hand over the new data to the sliding window handler.  It will be
2054:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		split-up in chunks of 1460 bytes each (or less, depending on
2055:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		ipconfigTCP_MSS). */
2056:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		lCount = lTCPWindowTxAdd(	&pxSocket->u.xTCP.xTCPWindow,
2057:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 								( uint32_t ) lLength,
2058:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 								( int32_t ) pxSocket->u.xTCP.txStream->uxMid,
  71              	 .loc 1 2058 0
  72 001a 5268     	 ldr r2,[r2,#4]
  73              	.LVL8:
2056:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 								( uint32_t ) lLength,
  74              	 .loc 1 2056 0
  75 001c D830     	 adds r0,r0,#216
  76              	.LVL9:
  77 001e FFF7FEFF 	 bl lTCPWindowTxAdd
  78              	.LVL10:
2059:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 								( int32_t ) pxSocket->u.xTCP.txStream->LENGTH );
2060:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2061:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Move the rxMid pointer forward up to rxHead. */
2062:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( lCount > 0 )
  79              	 .loc 1 2062 0
  80 0022 0028     	 cmp r0,#0
  81 0024 14DD     	 ble .L1
2063:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
2064:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			vStreamBufferMoveMid( pxSocket->u.xTCP.txStream, ( size_t ) lCount );
  82              	 .loc 1 2064 0
  83 0026 A36F     	 ldr r3,[r4,#120]
  84              	.LVL11:
  85              	.LBB121:
  86              	.LBB122:
  87              	.LBB123:
  88              	.LBB124:
 136:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxMid = pxBuffer->uxMid;
  89              	 .loc 2 136 0
  90 0028 9968     	 ldr r1,[r3,#8]
  91              	.LVL12:
  92              	 .loc 2 137 0
  93 002a 5A68     	 ldr r2,[r3,#4]
  94              	.LVL13:
  95              	.LBB125:
  96              	.LBB126:
  84:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	if ( uxCount >= pxBuffer->LENGTH )
  97              	 .loc 2 84 0
  98 002c 1C69     	 ldr r4,[r3,#16]
  99              	.LVL14:
 100 002e 2144     	 add r1,r1,r4
 101              	.LVL15:
 102 0030 8A1A     	 subs r2,r1,r2
 103              	.LVL16:
  85:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	{
 104              	 .loc 2 85 0
 105 0032 9442     	 cmp r4,r2
  87:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	}
 106              	 .loc 2 87 0
 107 0034 98BF     	 it ls
 108 0036 121B     	 subls r2,r2,r4
 109              	.LVL17:
 110              	.LBE126:
 111              	.LBE125:
 112              	.LBE124:
 113              	.LBE123:
 138:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
 139:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	return uxStreamBufferDistance( pxBuffer, uxMid, uxHead );
 140:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** }
 141:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** /*-----------------------------------------------------------*/
 142:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
 143:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** static portINLINE void vStreamBufferMoveMid( StreamBuffer_t *pxBuffer, size_t uxCount );
 144:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** static portINLINE void vStreamBufferMoveMid( StreamBuffer_t *pxBuffer, size_t uxCount )
 145:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** {
 146:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** /* Increment uxMid, but no further than uxHead */
 147:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxSize = uxStreamBufferMidSpace( pxBuffer );
 148:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxMoveCount = uxCount;
 149:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
 150:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	if( uxMoveCount > uxSize )
 151:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	{
 152:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 		uxMoveCount = uxSize;
 153:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	}
 154:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	pxBuffer->uxMid += uxMoveCount;
 114              	 .loc 2 154 0
 115 0038 5968     	 ldr r1,[r3,#4]
 116 003a 8242     	 cmp r2,r0
 117 003c 94BF     	 ite ls
 118 003e 8A18     	 addls r2,r1,r2
 119 0040 0A18     	 addhi r2,r1,r0
 120              	.LVL18:
 121 0042 5A60     	 str r2,[r3,#4]
 155:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	if( pxBuffer->uxMid >= pxBuffer->LENGTH )
 122              	 .loc 2 155 0
 123 0044 5A68     	 ldr r2,[r3,#4]
 124 0046 9442     	 cmp r4,r2
 125 0048 02D8     	 bhi .L1
 156:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	{
 157:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 		pxBuffer->uxMid -= pxBuffer->LENGTH;
 126              	 .loc 2 157 0
 127 004a 5A68     	 ldr r2,[r3,#4]
 128 004c 141B     	 subs r4,r2,r4
 129 004e 5C60     	 str r4,[r3,#4]
 130              	.LVL19:
 131              	.L1:
 132 0050 10BD     	 pop {r4,pc}
 133              	.LBE122:
 134              	.LBE121:
 135              	 .cfi_endproc
 136              	.LFE68:
 138 0052 00BF     	 .section .text.prvTCPReturnPacket,"ax",%progbits
 139              	 .align 2
 140              	 .thumb
 141              	 .thumb_func
 143              	prvTCPReturnPacket:
 144              	.LFB55:
 703:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** TCPPacket_t * pxTCPPacket;
 145              	 .loc 1 703 0
 146              	 .cfi_startproc
 147              	 
 148              	 
 149              	.LVL20:
 150 0000 2DE9F041 	 push {r4,r5,r6,r7,r8,lr}
 151              	.LCFI1:
 152              	 .cfi_def_cfa_offset 24
 153              	 .cfi_offset 4,-24
 154              	 .cfi_offset 5,-20
 155              	 .cfi_offset 6,-16
 156              	 .cfi_offset 7,-12
 157              	 .cfi_offset 8,-8
 158              	 .cfi_offset 14,-4
 159 0004 8AB0     	 sub sp,sp,#40
 160              	.LCFI2:
 161              	 .cfi_def_cfa_offset 64
 162 0006 1E46     	 mov r6,r3
 163              	.LVL21:
 714:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 164              	 .loc 1 714 0
 165 0008 0D46     	 mov r5,r1
 166 000a 0029     	 cmp r1,#0
 167 000c 40F0F380 	 bne .L7
 168              	.LVL22:
 723:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxNetworkBuffer->xDataLength = sizeof( pxSocket->u.xTCP.xPacket.u.ucLastPacket );
 169              	 .loc 1 723 0
 170 0010 00F18203 	 add r3,r0,#130
 171              	.LVL23:
 172 0014 0793     	 str r3,[sp,#28]
 724:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		xDoRelease = pdFALSE;
 173              	 .loc 1 724 0
 174 0016 4623     	 movs r3,#70
 175 0018 0893     	 str r3,[sp,#32]
 176              	.LVL24:
 716:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 177              	 .loc 1 716 0
 178 001a 01AD     	 add r5,sp,#4
 179              	.LVL25:
 725:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 180              	 .loc 1 725 0
 181 001c 0026     	 movs r6,#0
 182              	.LVL26:
 183 001e EAE0     	 b .L7
 184              	.LVL27:
 185              	.L18:
 758:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 186              	 .loc 1 758 0
 187 0020 416F     	 ldr r1,[r0,#116]
 188              	.LVL28:
 189 0022 49B1     	 cbz r1,.L8
 190              	.LVL29:
 191              	.LBB127:
 192              	.LBB128:
 113:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxTail = pxBuffer->uxTail;
 193              	 .loc 2 113 0
 194 0024 CF68     	 ldr r7,[r1,#12]
 195              	.LVL30:
 114:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
 196              	 .loc 2 114 0
 197 0026 0B68     	 ldr r3,[r1]
 198              	.LVL31:
 199              	.LBB129:
 200              	.LBB130:
  68:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	if( uxCount >= pxBuffer->LENGTH )
 201              	 .loc 2 68 0
 202 0028 0969     	 ldr r1,[r1,#16]
 203              	.LVL32:
 204 002a 0B44     	 add r3,r3,r1
 205              	.LVL33:
 206 002c 013B     	 subs r3,r3,#1
 207 002e DB1B     	 subs r3,r3,r7
 208              	.LVL34:
  69:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	{
 209              	 .loc 2 69 0
 210 0030 9942     	 cmp r1,r3
 211 0032 02D8     	 bhi .L9
  71:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	}
 212              	 .loc 2 71 0
 213 0034 5B1A     	 subs r3,r3,r1
 214              	.LVL35:
 215 0036 00E0     	 b .L9
 216              	.LVL36:
 217              	.L8:
 218              	.LBE130:
 219              	.LBE129:
 220              	.LBE128:
 221              	.LBE127:
 768:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 222              	 .loc 1 768 0
 223 0038 C36E     	 ldr r3,[r0,#108]
 224              	.LVL37:
 225              	.L9:
 772:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 226              	 .loc 1 772 0
 227 003a D0F8DCE0 	 ldr lr,[r0,#220]
 228              	.LVL38:
 774:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 229              	 .loc 1 774 0
 230 003e 724F     	 ldr r7,.L23
 231 0040 016C     	 ldr r1,[r0,#64]
 232 0042 0F40     	 ands r7,r7,r1
 233 0044 27B9     	 cbnz r7,.L20
 234              	.LBB131:
 235              	.LBB132:
 236              	 .file 3 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include/FreeRTOS_IP.h"
   1:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /*
   2:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * FreeRTOS+TCP V2.2.2
   3:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  *
   5:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * this software and associated documentation files (the "Software"), to deal in
   7:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * the Software without restriction, including without limitation the rights to
   8:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * subject to the following conditions:
  11:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  *
  12:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * The above copyright notice and this permission notice shall be included in all
  13:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * copies or substantial portions of the Software.
  14:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  *
  15:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  *
  22:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * http://aws.amazon.com/freertos
  23:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * http://www.FreeRTOS.org
  24:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  */
  25:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  26:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #ifndef FREERTOS_IP_H
  27:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define FREERTOS_IP_H
  28:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  29:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #ifdef __cplusplus
  30:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** extern "C" {
  31:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #endif
  32:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  33:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #include "FreeRTOS.h"
  34:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #include "task.h"
  35:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  36:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /* Application level configuration options. */
  37:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #include "FreeRTOSIPConfig.h"
  38:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #include "FreeRTOSIPConfigDefaults.h"
  39:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #include "IPTraceMacroDefaults.h"
  40:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  41:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #ifdef __COVERITY__
  42:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	/* Coverity static checks don't like inlined functions.
  43:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	As it is up to the users to allow inlining, don't let
  44:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	let Coverity know about it. */
  45:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  46:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	#ifdef portINLINE
  47:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 		/* The usage of #undef violates the rule. */
  48:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 		#undef portINLINE
  49:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  50:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	#endif
  51:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  52:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	#define	portINLINE
  53:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #endif
  54:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  55:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /* Some constants defining the sizes of several parts of a packet.
  56:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** These defines come before inlucding the configuration header files. */
  57:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /* The size of the Ethernet header is 14, meaning that 802.1Q VLAN tags
  58:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** are not ( yet ) supported. */
  59:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipSIZE_OF_ETH_HEADER			14U
  60:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipSIZE_OF_IPv4_HEADER			20U
  61:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipSIZE_OF_IGMP_HEADER			8U
  62:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipSIZE_OF_ICMP_HEADER			8U
  63:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipSIZE_OF_UDP_HEADER			8U
  64:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipSIZE_OF_TCP_HEADER			20U
  65:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  66:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipSIZE_OF_IPv4_ADDRESS			4U
  67:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  68:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /*
  69:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * Generate a randomized TCP Initial Sequence Number per RFC.
  70:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * This function must be provided by the application builder.
  71:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  */
  72:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /* This function is defined generally by the application. */
  73:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** extern uint32_t ulApplicationGetNextSequenceNumber( uint32_t ulSourceAddress,
  74:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 													uint16_t usSourcePort,
  75:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 													uint32_t ulDestinationAddress,
  76:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 													uint16_t usDestinationPort );
  77:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  78:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /* The number of octets in the MAC and IP addresses respectively. */
  79:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipMAC_ADDRESS_LENGTH_BYTES ( 6 )
  80:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipIP_ADDRESS_LENGTH_BYTES ( 4 )
  81:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  82:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /* IP protocol definitions. */
  83:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipPROTOCOL_ICMP			( 1U )
  84:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipPROTOCOL_IGMP         ( 2U )
  85:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipPROTOCOL_TCP			( 6U )
  86:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipPROTOCOL_UDP			( 17U )
  87:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipPROTOCOL_RAW			( 255 )
  88:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  89:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /* The character used to fill ICMP echo requests, and therefore also the
  90:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** character expected to fill ICMP echo replies. */
  91:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipECHO_DATA_FILL_BYTE						'x'
  92:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  93:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /* Dimensions the buffers that are filled by received Ethernet frames. */
  94:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipSIZE_OF_ETH_CRC_BYTES					( 4UL )
  95:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipSIZE_OF_ETH_OPTIONAL_802_1Q_TAG_BYTES	( 4UL )
  96:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipTOTAL_ETHERNET_FRAME_SIZE				( ( ( uint32_t ) ipconfigNETWORK_MTU ) + ( ( uint32_t ) ipSI
  97:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  98:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  99:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /* Space left at the beginning of a network buffer storage area to store a
 100:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** pointer back to the network buffer.  Should be a multiple of 8 to ensure 8 byte
 101:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** alignment is maintained on architectures that require it.
 102:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 103:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** In order to get a 32-bit alignment of network packets, an offset of 2 bytes
 104:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** would be desirable, as defined by ipconfigPACKET_FILLER_SIZE.  So the malloc'd
 105:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** buffer will have the following contents:
 106:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	uint32_t pointer;	// word-aligned
 107:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	uchar_8 filler[6];
 108:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	<< ETH-header >>	// half-word-aligned
 109:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	uchar_8 dest[6];    // start of pucEthernetBuffer
 110:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	uchar_8 dest[6];
 111:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	uchar16_t type;
 112:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	<< IP-header >>		// word-aligned
 113:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	uint8_t ucVersionHeaderLength;
 114:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	etc
 115:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  */
 116:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 117:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #if( ipconfigBUFFER_PADDING != 0 )
 118:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****     #define ipBUFFER_PADDING    ipconfigBUFFER_PADDING
 119:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #else
 120:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****     #define ipBUFFER_PADDING    ( 8U + ipconfigPACKET_FILLER_SIZE )
 121:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #endif
 122:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 123:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /* The structure used to store buffers and pass them around the network stack.
 124:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** Buffers can be in use by the stack, in use by the network interface hardware
 125:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** driver, or free (not in use). */
 126:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** typedef struct xNETWORK_BUFFER
 127:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** {
 128:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	ListItem_t xBufferListItem; 	/* Used to reference the buffer form the free buffer list or a socket
 129:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	uint32_t ulIPAddress;			/* Source or destination IP address, depending on usage scenario. */
 130:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	uint8_t *pucEthernetBuffer; 	/* Pointer to the start of the Ethernet frame. */
 131:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	size_t xDataLength; 			/* Starts by holding the total Ethernet frame length, then the UDP/TCP payl
 132:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	uint16_t usPort;				/* Source or destination port, depending on usage scenario. */
 133:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	uint16_t usBoundPort;			/* The port to which a transmitting socket is bound. */
 134:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	#if( ipconfigUSE_LINKED_RX_MESSAGES != 0 )
 135:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 		struct xNETWORK_BUFFER *pxNextBuffer; /* Possible optimisation for expert users - requires networ
 136:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	#endif
 137:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** } NetworkBufferDescriptor_t;
 138:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 139:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #include "pack_struct_start.h"
 140:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** struct xMAC_ADDRESS
 141:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** {
 142:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	uint8_t ucBytes[ ipMAC_ADDRESS_LENGTH_BYTES ];
 143:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** }
 144:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #include "pack_struct_end.h"
 145:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 146:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** typedef struct xMAC_ADDRESS MACAddress_t;
 147:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 148:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** typedef enum eNETWORK_EVENTS
 149:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** {
 150:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	eNetworkUp,		/* The network is configured. */
 151:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	eNetworkDown	/* The network connection has been lost. */
 152:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** } eIPCallbackEvent_t;
 153:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 154:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /* MISRA check: some modules refer to this typedef even though
 155:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** ipconfigSUPPORT_OUTGOING_PINGS is not enabled. */
 156:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** typedef enum ePING_REPLY_STATUS
 157:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** {
 158:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	eSuccess = 0,		/* A correct reply has been received for an outgoing ping. */
 159:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	eInvalidChecksum,	/* A reply was received for an outgoing ping but the checksum of the reply was i
 160:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	eInvalidData		/* A reply was received to an outgoing ping but the payload of the reply was not cor
 161:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** } ePingReplyStatus_t;
 162:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 163:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** typedef struct xIP_TIMER
 164:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** {
 165:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	uint32_t
 166:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 		bActive : 1,	/* This timer is running and must be processed. */
 167:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 		bExpired : 1;	/* Timer has expired and a task must be processed. */
 168:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	TimeOut_t xTimeOut;
 169:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	TickType_t ulRemainingTime;
 170:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	TickType_t ulReloadTime;
 171:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** } IPTimer_t;
 172:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 173:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /* Endian related definitions. */
 174:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #if( ipconfigBYTE_ORDER == pdFREERTOS_LITTLE_ENDIAN )
 175:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 176:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	/* FreeRTOS_htons / FreeRTOS_htonl: some platforms might have built-in versions
 177:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	using a single instruction so allow these versions to be overridden. */
 178:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	#ifndef FreeRTOS_htons
 179:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 		#define FreeRTOS_htons( usIn ) ( (uint16_t) ( ( ( usIn ) << 8U ) | ( ( usIn ) >> 8U ) ) )
 180:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	#endif
 181:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 182:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	#ifndef	FreeRTOS_htonl
 183:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 		#define FreeRTOS_htonl( ulIn ) 											\
 184:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 			(																	\
 185:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 				( uint32_t ) 													\
 186:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 				( 																\
 187:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 					( ( ( ( uint32_t ) ( ulIn ) )                ) << 24  ) | 	\
 188:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 					( ( ( ( uint32_t ) ( ulIn ) ) & 0x0000ff00UL ) <<  8  ) | 	\
 189:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 					( ( ( ( uint32_t ) ( ulIn ) ) & 0x00ff0000UL ) >>  8  ) | 	\
 190:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 					( ( ( ( uint32_t ) ( ulIn ) )                ) >> 24  )  	\
 191:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 				) 																\
 192:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 			)
 193:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	#endif
 194:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 195:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #else /* ipconfigBYTE_ORDER */
 196:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	#define FreeRTOS_htons( x ) ( ( uint16_t ) ( x ) )
 198:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	#define FreeRTOS_htonl( x ) ( ( uint32_t ) ( x ) )
 199:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 200:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #endif /* ipconfigBYTE_ORDER == pdFREERTOS_LITTLE_ENDIAN */
 201:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 202:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define FreeRTOS_ntohs( x ) FreeRTOS_htons( x )
 203:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define FreeRTOS_ntohl( x ) FreeRTOS_htonl( x )
 204:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 205:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #if( ipconfigHAS_INLINE_FUNCTIONS == 1 )
 206:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 207:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	static portINLINE int32_t  FreeRTOS_max_int32  (int32_t  a, int32_t  b);
 208:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	static portINLINE uint32_t FreeRTOS_max_uint32 (uint32_t a, uint32_t b);
 209:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	static portINLINE int32_t  FreeRTOS_min_int32  (int32_t  a, int32_t  b);
 210:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	static portINLINE uint32_t FreeRTOS_min_uint32 (uint32_t a, uint32_t b);
 211:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	static portINLINE uint32_t FreeRTOS_round_up   (uint32_t a, uint32_t d);
 212:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	static portINLINE uint32_t FreeRTOS_round_down (uint32_t a, uint32_t d);
 213:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	static portINLINE BaseType_t  FreeRTOS_min_BaseType  (BaseType_t  a, BaseType_t  b);
 214:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 215:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	static portINLINE int32_t  FreeRTOS_max_int32  (int32_t  a, int32_t  b) { return ( a >= b ) ? a : 
 216:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	static portINLINE uint32_t FreeRTOS_max_uint32 (uint32_t a, uint32_t b) { return ( a >= b ) ? a : 
 217:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	static portINLINE int32_t  FreeRTOS_min_int32  (int32_t  a, int32_t  b) { return ( a <= b ) ? a : 
 218:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	static portINLINE uint32_t FreeRTOS_min_uint32 (uint32_t a, uint32_t b) { return ( a <= b ) ? a : 
 237              	 .loc 3 218 0
 238 0046 7146     	 mov r1,lr
 239 0048 9E45     	 cmp lr,r3
 240 004a 28BF     	 it cs
 241 004c 1946     	 movcs r1,r3
 242 004e 00E0     	 b .L10
 243              	.L20:
 244              	.LBE132:
 245              	.LBE131:
 780:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 246              	 .loc 1 780 0
 247 0050 0021     	 movs r1,#0
 248              	.L10:
 249              	.LVL39:
 786:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 250              	 .loc 1 786 0
 251 0052 B0F84A70 	 ldrh r7,[r0,#74]
 252 0056 B942     	 cmp r1,r7
 253 0058 02D2     	 bcs .L11
 788:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 254              	 .loc 1 788 0 discriminator 1
 255 005a BB42     	 cmp r3,r7
 256 005c 28BF     	 it cs
 257 005e 3946     	 movcs r1,r7
 258              	.LVL40:
 259              	.L11:
 794:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 260              	 .loc 1 794 0
 261 0060 90F8C930 	 ldrb r3,[r0,#201]
 262              	.LVL41:
 263 0064 21FA03F7 	 lsr r7,r1,r3
 264              	.LVL42:
 265 0068 4FF6FC73 	 movw r3,#65532
 266 006c BB42     	 cmp r3,r7
 267 006e 28BF     	 it cs
 268 0070 3B46     	 movcs r3,r7
 269              	.LVL43:
 270 0072 9BB2     	 uxth r3,r3
 271              	.LVL44:
 806:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 272              	 .loc 1 806 0
 273 0074 1F0A     	 lsrs r7,r3,#8
 274              	.LVL45:
 275 0076 47EA0323 	 orr r3,r7,r3,lsl#8
 276 007a 2386     	 strh r3,[r4,#48]
 277              	.LVL46:
 809:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 278              	 .loc 1 809 0
 279 007c 90F84130 	 ldrb r3,[r0,#65]
 280 0080 6FF30003 	 bfc r3,#0,#1
 281 0084 80F84130 	 strb r3,[r0,#65]
 814:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 282              	 .loc 1 814 0
 283 0088 D0F8E870 	 ldr r7,[r0,#232]
 284 008c 3944     	 add r1,r1,r7
 285              	.LVL47:
 286 008e 4164     	 str r1,[r0,#68]
 817:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 287              	 .loc 1 817 0
 288 0090 13F0020F 	 tst r3,#2
 289 0094 17D0     	 beq .L12
 822:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxSocket->u.xTCP.bits.bWaitKeepAlive = pdTRUE_UNSIGNED;
 290              	 .loc 1 822 0
 291 0096 DBB2     	 uxtb r3,r3
 823:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 292              	 .loc 1 823 0
 293 0098 03F0FD03 	 and r3,r3,#253
 294 009c 43F00403 	 orr r3,r3,#4
 295 00a0 80F84130 	 strb r3,[r0,#65]
 825:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxTCPPacket->xTCPHeader.ulSequenceNumber = FreeRTOS_htonl( pxTCPPacket->xTCPHeader.ulSequenceNu
 296              	 .loc 1 825 0
 297 00a4 D0F80431 	 ldr r3,[r0,#260]
 298 00a8 013B     	 subs r3,r3,#1
 826:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 299              	 .loc 1 826 0
 300 00aa 1906     	 lsls r1,r3,#24
 301 00ac 41EA1361 	 orr r1,r1,r3,lsr#24
 302 00b0 03F47F47 	 and r7,r3,#65280
 303 00b4 41EA0721 	 orr r1,r1,r7,lsl#8
 304 00b8 03F47F03 	 and r3,r3,#16711680
 305 00bc 41EA1323 	 orr r3,r1,r3,lsr#8
 306 00c0 C4F82630 	 str r3,[r4,#38]
 307 00c4 1FE0     	 b .L13
 308              	.L12:
 831:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 309              	 .loc 1 831 0
 310 00c6 D0F80471 	 ldr r7,[r0,#260]
 311 00ca 3906     	 lsls r1,r7,#24
 312 00cc 41EA1761 	 orr r1,r1,r7,lsr#24
 313 00d0 07F47F43 	 and r3,r7,#65280
 314 00d4 41EA0321 	 orr r1,r1,r3,lsl#8
 315 00d8 07F47F03 	 and r3,r7,#16711680
 316 00dc 41EA1323 	 orr r3,r1,r3,lsr#8
 317 00e0 C4F82630 	 str r3,[r4,#38]
 833:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
 318              	 .loc 1 833 0
 319 00e4 94F82F30 	 ldrb r3,[r4,#47]
 320 00e8 13F0010F 	 tst r3,#1
 321 00ec 0BD0     	 beq .L13
 322              	.LVL48:
 323 00ee D0F80411 	 ldr r1,[r0,#260]
 324 00f2 2839     	 subs r1,r1,#40
 325              	.LBB133:
 838:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					{
 326              	 .loc 1 838 0
 327 00f4 1144     	 add r1,r1,r2
 328 00f6 D0F8FC70 	 ldr r7,[r0,#252]
 329 00fa B942     	 cmp r1,r7
 840:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						FreeRTOS_debug_printf( ( "Suppress FIN for %lu + %lu < %lu\n",
 330              	 .loc 1 840 0
 331 00fc 1CBF     	 itt ne
 332 00fe 23F00103 	 bicne r3,r3,#1
 333 0102 84F82F30 	 strbne r3,[r4,#47]
 334              	.LVL49:
 335              	.L13:
 336              	.LBE133:
 850:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 337              	 .loc 1 850 0
 338 0106 D0F8E800 	 ldr r0,[r0,#232]
 339              	.LVL50:
 340 010a 0106     	 lsls r1,r0,#24
 341 010c 41EA1061 	 orr r1,r1,r0,lsr#24
 342 0110 00F47F43 	 and r3,r0,#65280
 343 0114 41EA0321 	 orr r1,r1,r3,lsl#8
 344 0118 00F47F03 	 and r3,r0,#16711680
 345 011c 41EA1323 	 orr r3,r1,r3,lsr#8
 346 0120 C4F82A30 	 str r3,[r4,#42]
 859:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxIPHeader->usLength			   = FreeRTOS_htons( ulLen );
 347              	 .loc 1 859 0
 348 0124 8023     	 movs r3,#128
 349 0126 A375     	 strb r3,[r4,#22]
 860:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( ( pxSocket == NULL ) || ( *ipLOCAL_IP_ADDRESS_POINTER == 0UL ) )
 350              	 .loc 1 860 0
 351 0128 1302     	 lsls r3,r2,#8
 352 012a 43EA1223 	 orr r3,r3,r2,lsr#8
 353 012e 2382     	 strh r3,[r4,#16]
 861:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 354              	 .loc 1 861 0
 355 0130 364B     	 ldr r3,.L23+4
 356 0132 5B69     	 ldr r3,[r3,#20]
 357 0134 73B1     	 cbz r3,.L14
 358 0136 0FE0     	 b .L15
 359              	.LVL51:
 360              	.L21:
 361              	.LBB134:
 856:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 362              	 .loc 1 856 0
 363 0138 D4F82630 	 ldr r3,[r4,#38]
 364              	.LVL52:
 365 013c D4F82A10 	 ldr r1,[r4,#42]
 366              	.LVL53:
 367 0140 C4F82610 	 str r1,[r4,#38]
 368 0144 C4F82A30 	 str r3,[r4,#42]
 369              	.LBE134:
 859:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxIPHeader->usLength			   = FreeRTOS_htons( ulLen );
 370              	 .loc 1 859 0
 371 0148 8023     	 movs r3,#128
 372              	.LVL54:
 373 014a A375     	 strb r3,[r4,#22]
 860:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( ( pxSocket == NULL ) || ( *ipLOCAL_IP_ADDRESS_POINTER == 0UL ) )
 374              	 .loc 1 860 0
 375 014c 1302     	 lsls r3,r2,#8
 376 014e 43EA1223 	 orr r3,r3,r2,lsr#8
 377 0152 2382     	 strh r3,[r4,#16]
 378              	.LVL55:
 379              	.L14:
 867:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 380              	 .loc 1 867 0
 381 0154 D4F81E30 	 ldr r3,[r4,#30]
 382              	.LVL56:
 383              	.L15:
 873:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxIPHeader->ulSourceIPAddress = ulSourceAddress;
 384              	 .loc 1 873 0
 385 0158 D4F81A10 	 ldr r1,[r4,#26]
 386 015c C4F81E10 	 str r1,[r4,#30]
 874:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		vFlip_16( pxTCPPacket->xTCPHeader.usSourcePort, pxTCPPacket->xTCPHeader.usDestinationPort );
 387              	 .loc 1 874 0
 388 0160 C4F81A30 	 str r3,[r4,#26]
 389              	.LBB135:
 875:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 390              	 .loc 1 875 0
 391 0164 638C     	 ldrh r3,[r4,#34]
 392              	.LVL57:
 393 0166 A18C     	 ldrh r1,[r4,#36]
 394 0168 6184     	 strh r1,[r4,#34]
 395 016a A384     	 strh r3,[r4,#36]
 396              	.LBE135:
 878:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		usPacketIdentifier++;
 397              	 .loc 1 878 0
 398 016c 2848     	 ldr r0,.L23+8
 399 016e 0388     	 ldrh r3,[r0]
 400              	.LVL58:
 401 0170 190A     	 lsrs r1,r3,#8
 402 0172 41EA0321 	 orr r1,r1,r3,lsl#8
 403 0176 6182     	 strh r1,[r4,#18]
 879:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxIPHeader->usFragmentOffset = 0U;
 404              	 .loc 1 879 0
 405 0178 0133     	 adds r3,r3,#1
 406 017a 0380     	 strh r3,[r0]
 880:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 407              	 .loc 1 880 0
 408 017c 0020     	 movs r0,#0
 409 017e 2075     	 strb r0,[r4,#20]
 410 0180 6075     	 strb r0,[r4,#21]
 883:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 411              	 .loc 1 883 0
 412 0182 0E32     	 adds r2,r2,#14
 413              	.LVL59:
 414 0184 EA61     	 str r2,[r5,#28]
 888:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxIPHeader->usHeaderChecksum = usGenerateChecksum( 0U, ( uint8_t * ) &( pxIPHeader->ucVersionHea
 415              	 .loc 1 888 0
 416 0186 2076     	 strb r0,[r4,#24]
 417 0188 6076     	 strb r0,[r4,#25]
 889:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxIPHeader->usHeaderChecksum = ~FreeRTOS_htons( pxIPHeader->usHeaderChecksum );
 418              	 .loc 1 889 0
 419 018a 04F10E01 	 add r1,r4,#14
 420 018e 1422     	 movs r2,#20
 421              	.LVL60:
 422 0190 FFF7FEFF 	 bl usGenerateChecksum
 423              	.LVL61:
 890:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 424              	 .loc 1 890 0
 425 0194 030A     	 lsrs r3,r0,#8
 426 0196 43EA0020 	 orr r0,r3,r0,lsl#8
 427 019a C043     	 mvns r0,r0
 428 019c 2083     	 strh r0,[r4,#24]
 893:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 429              	 .loc 1 893 0
 430 019e 2046     	 mov r0,r4
 431 01a0 E969     	 ldr r1,[r5,#28]
 432 01a2 0122     	 movs r2,#1
 433 01a4 FFF7FEFF 	 bl usGenerateProtocolChecksum
 434              	.LVL62:
 897:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 435              	 .loc 1 897 0
 436 01a8 638E     	 ldrh r3,[r4,#50]
 437 01aa 2BB9     	 cbnz r3,.L16
 899:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 438              	 .loc 1 899 0
 439 01ac 4FF0FF33 	 mov r3,#-1
 440 01b0 84F83230 	 strb r3,[r4,#50]
 441 01b4 84F83330 	 strb r3,[r4,#51]
 442              	.L16:
 912:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						 sizeof( pxEthernetHeader->xDestinationAddress ) );
 443              	 .loc 1 912 0
 444 01b8 2746     	 mov r7,r4
 911:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						 ( const void * ) ( &( pxEthernetHeader->xSourceAddress ) ),
 445              	 .loc 1 911 0
 446 01ba 57F8063F 	 ldr r3,[r7,#6]!
 447 01be 2360     	 str r3,[r4]
 448 01c0 BB88     	 ldrh r3,[r7,#4]
 449 01c2 A380     	 strh r3,[r4,#4]
 916:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  
 450              	 .loc 1 916 0
 451 01c4 114B     	 ldr r3,.L23+4
 452 01c6 1868     	 ldr r0,[r3]
 453 01c8 C4F80600 	 str r0,[r4,#6]
 454 01cc 9B88     	 ldrh r3,[r3,#4]
 455 01ce BB80     	 strh r3,[r7,#4]
 934:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 456              	 .loc 1 934 0
 457 01d0 2846     	 mov r0,r5
 458 01d2 3146     	 mov r1,r6
 459 01d4 FFF7FEFF 	 bl xNetworkInterfaceOutput
 460              	.LVL63:
 936:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 461              	 .loc 1 936 0
 462 01d8 96B9     	 cbnz r6,.L6
 463              	.LBB136:
 940:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxTCPPacket->xIPHeader.ulSourceIPAddress = pxTCPPacket->xIPHeader.ulDestinationIPAddress;
 464              	 .loc 1 940 0
 465 01da 638C     	 ldrh r3,[r4,#34]
 466              	.LVL64:
 467 01dc A28C     	 ldrh r2,[r4,#36]
 468 01de 6284     	 strh r2,[r4,#34]
 469 01e0 A384     	 strh r3,[r4,#36]
 470              	.LBE136:
 941:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( void ) memcpy( ( void * ) ( pxEthernetHeader->xSourceAddress.ucBytes ), ( const void * ) ( pxE
 471              	 .loc 1 941 0
 472 01e2 D4F81E30 	 ldr r3,[r4,#30]
 473              	.LVL65:
 474 01e6 C4F81A30 	 str r3,[r4,#26]
 942:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 475              	 .loc 1 942 0
 476 01ea 2368     	 ldr r3,[r4]
 477 01ec C4F80630 	 str r3,[r4,#6]
 478 01f0 A388     	 ldrh r3,[r4,#4]
 479 01f2 BB80     	 strh r3,[r7,#4]
 480 01f4 04E0     	 b .L6
 481              	.LVL66:
 482              	.L7:
 747:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxIPHeader = &pxTCPPacket->xIPHeader;
 483              	 .loc 1 747 0
 484 01f6 AC69     	 ldr r4,[r5,#24]
 485              	.LVL67:
 752:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 486              	 .loc 1 752 0
 487 01f8 0028     	 cmp r0,#0
 488 01fa 7FF411AF 	 bne .L18
 489 01fe 9BE7     	 b .L21
 490              	.LVL68:
 491              	.L6:
 949:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
 492              	 .loc 1 949 0
 493 0200 0AB0     	 add sp,sp,#40
 494              	.LCFI3:
 495              	 .cfi_def_cfa_offset 24
 496              	 
 497 0202 BDE8F081 	 pop {r4,r5,r6,r7,r8,pc}
 498              	.LVL69:
 499              	.L24:
 500 0206 00BF     	 .align 2
 501              	.L23:
 502 0208 80000400 	 .word 262272
 503 020c 00000000 	 .word xDefaultPartUDPPacketHeader
 504 0210 00000000 	 .word usPacketIdentifier
 505              	 .cfi_endproc
 506              	.LFE55:
 508              	 .section .text.prvTCPSendReset,"ax",%progbits
 509              	 .align 2
 510              	 .thumb
 511              	 .thumb_func
 513              	prvTCPSendReset:
 514              	.LFB79:
2065:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
2066:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
2067:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** }
2068:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
2069:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2070:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
2071:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * prvTCPHandleFin() will be called to handle socket closure
2072:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * The Closure starts when either a FIN has been received and accepted,
2073:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Or when the socket has sent a FIN flag to the peer
2074:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Before being called, it has been checked that both reception and transmission
2075:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * are complete.
2076:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
2077:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static BaseType_t prvTCPHandleFin( FreeRTOS_Socket_t *pxSocket, const NetworkBufferDescriptor_t *px
2078:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** {
2079:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /* Map the ethernet buffer onto the ProtocolHeader_t struct for easy access to the fields. */
2080:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** ProtocolHeaders_t *pxProtocolHeaders = ipCAST_PTR_TO_TYPE_PTR( ProtocolHeaders_t,
2081:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	&( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + xIPHeaderSize( pxNetworkBuffer ) ] )
2082:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** TCPHeader_t *pxTCPHeader = &( pxProtocolHeaders->xTCPHeader );
2083:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint8_t ucIntermediateResult = 0, ucTCPFlags = pxTCPHeader->ucTCPFlags;
2084:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** TCPWindow_t *pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
2085:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** BaseType_t xSendLength = 0;
2086:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint32_t ulAckNr = FreeRTOS_ntohl( pxTCPHeader->ulAckNr );
2087:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2088:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( ( ucTCPFlags & tcpTCP_FLAG_FIN ) != 0U )
2089:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
2090:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPWindow->rx.ulCurrentSequenceNumber = pxTCPWindow->rx.ulFINSequenceNumber + 1U;
2091:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
2092:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED )
2093:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
2094:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* We haven't yet replied with a FIN, do so now. */
2095:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPWindow->tx.ulFINSequenceNumber = pxTCPWindow->tx.ulCurrentSequenceNumber;
2096:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxSocket->u.xTCP.bits.bFinSent = pdTRUE_UNSIGNED;
2097:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
2098:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	else
2099:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
2100:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* We did send a FIN already, see if it's ACK'd. */
2101:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( ulAckNr == ( pxTCPWindow->tx.ulFINSequenceNumber + 1UL ) )
2102:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
2103:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxSocket->u.xTCP.bits.bFinAcked = pdTRUE_UNSIGNED;
2104:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
2105:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
2106:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2107:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( pxSocket->u.xTCP.bits.bFinAcked == pdFALSE_UNSIGNED )
2108:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
2109:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPWindow->tx.ulCurrentSequenceNumber = pxTCPWindow->tx.ulFINSequenceNumber;
2110:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPHeader->ucTCPFlags = ( uint8_t ) tcpTCP_FLAG_ACK | ( uint8_t ) tcpTCP_FLAG_FIN;
2111:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2112:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* And wait for the final ACK. */
2113:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		vTCPStateChange( pxSocket, eLAST_ACK );
2114:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
2115:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	else
2116:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
2117:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Our FIN has been ACK'd, the outgoing sequence number is now fixed. */
2118:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPWindow->tx.ulCurrentSequenceNumber = pxTCPWindow->tx.ulFINSequenceNumber + 1U;
2119:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( pxSocket->u.xTCP.bits.bFinRecv == pdFALSE_UNSIGNED )
2120:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
2121:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* We have sent out a FIN but the peer hasn't replied with a FIN
2122:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			yet. Do nothing for the moment. */
2123:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxTCPHeader->ucTCPFlags = 0U;
2124:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
2125:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		else
2126:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
2127:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( pxSocket->u.xTCP.bits.bFinLast == pdFALSE_UNSIGNED )
2128:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
2129:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				/* This is the third of the three-way hand shake: the last
2130:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				ACK. */
2131:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxTCPHeader->ucTCPFlags = tcpTCP_FLAG_ACK;
2132:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
2133:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			else
2134:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
2135:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				/* The other party started the closure, so we just wait for the
2136:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				last ACK. */
2137:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxTCPHeader->ucTCPFlags = 0U;
2138:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
2139:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2140:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* And wait for the user to close this socket. */
2141:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			vTCPStateChange( pxSocket, eCLOSE_WAIT );
2142:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
2143:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
2144:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2145:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	pxTCPWindow->ulOurSequenceNumber = pxTCPWindow->tx.ulCurrentSequenceNumber;
2146:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2147:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( pxTCPHeader->ucTCPFlags != 0U )
2148:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
2149:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		ucIntermediateResult = uxIPHeaderSizeSocket( pxSocket ) + ipSIZE_OF_TCP_HEADER + pxTCPWindow->ucO
2150:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		xSendLength = ( BaseType_t ) ucIntermediateResult;
2151:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
2152:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2153:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	pxTCPHeader->ucTCPOffset = ( uint8_t ) ( ( ipSIZE_OF_TCP_HEADER + pxTCPWindow->ucOptionLength ) <<
2154:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2155:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( xTCPWindowLoggingLevel != 0 )
2156:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
2157:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		FreeRTOS_debug_printf( ( "TCP: send FIN+ACK (ack %lu, cur/nxt %lu/%lu) ourSeqNr %lu | Rx %lu\n",
2158:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			ulAckNr - pxTCPWindow->tx.ulFirstSequenceNumber,
2159:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxTCPWindow->tx.ulCurrentSequenceNumber - pxTCPWindow->tx.ulFirstSequenceNumber,
2160:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxTCPWindow->ulNextTxSequenceNumber - pxTCPWindow->tx.ulFirstSequenceNumber,
2161:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxTCPWindow->ulOurSequenceNumber - pxTCPWindow->tx.ulFirstSequenceNumber,
2162:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxTCPWindow->rx.ulCurrentSequenceNumber - pxTCPWindow->rx.ulFirstSequenceNumber ) );
2163:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
2164:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2165:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	return xSendLength;
2166:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** }
2167:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
2168:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2169:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
2170:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * prvCheckRxData(): called from prvTCPHandleState()
2171:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  *
2172:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * The first thing that will be done is find the TCP payload data
2173:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * and check the length of this data.
2174:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
2175:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static BaseType_t prvCheckRxData( const NetworkBufferDescriptor_t *pxNetworkBuffer, uint8_t **ppucR
2176:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** {
2177:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /* Map the ethernet buffer onto the ProtocolHeader_t struct for easy access to the fields. */
2178:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** const ProtocolHeaders_t *pxProtocolHeaders = ipCAST_PTR_TO_TYPE_PTR( ProtocolHeaders_t,
2179:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	&( pxNetworkBuffer->pucEthernetBuffer[ ( size_t ) ipSIZE_OF_ETH_HEADER + xIPHeaderSize( pxNetworkB
2180:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** const TCPHeader_t *pxTCPHeader = &( pxProtocolHeaders->xTCPHeader );
2181:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** int32_t lLength, lTCPHeaderLength, lReceiveLength, lUrgentLength;
2182:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2183:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /* Map the buffer onto an IPHeader_t struct for easy access to fields. */
2184:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** const IPHeader_t *pxIPHeader = ipCAST_CONST_PTR_TO_CONST_TYPE_PTR( IPHeader_t, &( pxNetworkBuffer->
2185:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** const size_t xIPHeaderLength = ipSIZE_OF_IPv4_HEADER;
2186:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint16_t usLength;
2187:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint8_t ucIntermediateResult = 0;
2188:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2189:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	/* Determine the length and the offset of the user-data sent to this
2190:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	node.
2191:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2192:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	The size of the TCP header is given in a multiple of 4-byte words (single
2193:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	byte, needs no ntoh() translation).  A shift-right 2: is the same as
2194:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	(offset >> 4) * 4. */
2195:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	ucIntermediateResult = ( pxTCPHeader->ucTCPOffset & tcpVALID_BITS_IN_TCP_OFFSET_BYTE ) >> 2;
2196:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	lTCPHeaderLength = ( int32_t ) ucIntermediateResult;
2197:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2198:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	/* Let pucRecvData point to the first byte received. */
2199:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	*ppucRecvData = &( pxNetworkBuffer->pucEthernetBuffer[ ( size_t ) ipSIZE_OF_ETH_HEADER + xIPHeader
2200:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2201:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	/* Calculate lReceiveLength - the length of the TCP data received.  This is
2202:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	equal to the total packet length minus:
2203:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	( LinkLayer length (14) + IP header length (20) + size of TCP header(20 +) ).*/
2204:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	lReceiveLength = ipNUMERIC_CAST( int32_t, pxNetworkBuffer->xDataLength ) - ( int32_t ) ipSIZE_OF_E
2205:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2206:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	usLength = FreeRTOS_htons( pxIPHeader->usLength );
2207:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	lLength =  ( int32_t ) usLength;
2208:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2209:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( lReceiveLength > lLength )
2210:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
2211:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* More bytes were received than the reported length, often because of
2212:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		padding bytes at the end. */
2213:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		lReceiveLength = lLength;
2214:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
2215:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2216:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	/* Subtract the size of the TCP and IP headers and the actual data size is
2217:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	known. */
2218:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( lReceiveLength > ( lTCPHeaderLength + ( int32_t ) xIPHeaderLength ) )
2219:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
2220:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		lReceiveLength -= ( lTCPHeaderLength + ( int32_t ) xIPHeaderLength );
2221:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
2222:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	else
2223:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
2224:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		lReceiveLength = 0;
2225:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
2226:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2227:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	/* Urgent Pointer:
2228:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	This field communicates the current value of the urgent pointer as a
2229:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	positive offset from the sequence number in this segment.  The urgent
2230:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	pointer points to the sequence number of the octet following the urgent
2231:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	data.  This field is only be interpreted in segments with the URG control
2232:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	bit set. */
2233:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( ( pxTCPHeader->ucTCPFlags & tcpTCP_FLAG_URG ) != 0U )
2234:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
2235:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Although we ignore the urgent data, we have to skip it. */
2236:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		lUrgentLength = ( int32_t ) FreeRTOS_htons( pxTCPHeader->usUrgent );
2237:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		*ppucRecvData += lUrgentLength;
2238:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		lReceiveLength -= FreeRTOS_min_int32( lReceiveLength, lUrgentLength );
2239:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
2240:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2241:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	return ( BaseType_t ) lReceiveLength;
2242:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** }
2243:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
2244:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2245:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
2246:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * prvStoreRxData(): called from prvTCPHandleState()
2247:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  *
2248:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * The second thing is to do is check if the payload data may be accepted
2249:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * If so, they will be added to the reception queue.
2250:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
2251:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static BaseType_t prvStoreRxData( FreeRTOS_Socket_t *pxSocket, const uint8_t *pucRecvData,
2252:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	NetworkBufferDescriptor_t *pxNetworkBuffer, uint32_t ulReceiveLength )
2253:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** {
2254:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /* Map the ethernet buffer onto the ProtocolHeader_t struct for easy access to the fields. */
2255:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** const ProtocolHeaders_t *pxProtocolHeaders = ipCAST_CONST_PTR_TO_CONST_TYPE_PTR( ProtocolHeaders_t,
2256:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	&( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + xIPHeaderSize( pxNetworkBuffer ) ] )
2257:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** const TCPHeader_t *pxTCPHeader = &pxProtocolHeaders->xTCPHeader;
2258:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** TCPWindow_t *pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
2259:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint32_t ulSequenceNumber, ulSpace;
2260:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** int32_t lOffset, lStored;
2261:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** BaseType_t xResult = 0;
2262:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2263:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	ulSequenceNumber = FreeRTOS_ntohl( pxTCPHeader->ulSequenceNumber );
2264:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2265:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( ( ulReceiveLength > 0U ) && ( pxSocket->u.xTCP.ucTCPState >= ( uint8_t ) eSYN_RECEIVED ) )
2266:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
2267:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* See if way may accept the data contents and forward it to the socket
2268:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		owner.
2269:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2270:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		If it can't be "accept"ed it may have to be stored and send a selective
2271:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		ack (SACK) option to confirm it.  In that case, lTCPAddRxdata() will be
2272:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		called later to store an out-of-order packet (in case lOffset is
2273:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		negative). */
2274:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if ( pxSocket->u.xTCP.rxStream != NULL )
2275:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
2276:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			ulSpace = ( uint32_t )uxStreamBufferGetSpace ( pxSocket->u.xTCP.rxStream );
2277:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
2278:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		else
2279:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
2280:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			ulSpace = ( uint32_t )pxSocket->u.xTCP.uxRxStreamSize;
2281:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
2282:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2283:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		lOffset = lTCPWindowRxCheck( pxTCPWindow, ulSequenceNumber, ulReceiveLength, ulSpace );
2284:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2285:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( lOffset >= 0 )
2286:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
2287:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* New data has arrived and may be made available to the user.  See
2288:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if the head marker in rxStream may be advanced,	only if lOffset == 0.
2289:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			In case the low-water mark is reached, bLowWater will be set
2290:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			"low-water" here stands for "little space". */
2291:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			lStored = lTCPAddRxdata( pxSocket, ( uint32_t ) lOffset, pucRecvData, ulReceiveLength );
2292:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2293:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( lStored != ( int32_t ) ulReceiveLength )
2294:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
2295:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				FreeRTOS_debug_printf( ( "lTCPAddRxdata: stored %ld / %lu bytes? ?\n", lStored, ulReceiveLength
2296:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2297:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				/* Received data could not be stored.  The socket's flag
2298:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				bMallocError has been set.  The socket now has the status
2299:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				eCLOSE_WAIT and a RST packet will be sent back. */
2300:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				( void ) prvTCPSendReset( pxNetworkBuffer );
2301:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				xResult = -1;
2302:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
2303:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
2304:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2305:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* After a missing packet has come in, higher packets may be passed to
2306:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		the user. */
2307:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		#if( ipconfigUSE_TCP_WIN == 1 )
2308:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
2309:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* Now lTCPAddRxdata() will move the rxHead pointer forward
2310:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			so data becomes available to the user immediately
2311:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			In case the low-water mark is reached, bLowWater will be set. */
2312:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( ( xResult == 0 ) && ( pxTCPWindow->ulUserDataLength > 0UL ) )
2313:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
2314:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				( void ) lTCPAddRxdata( pxSocket, 0UL, NULL, pxTCPWindow->ulUserDataLength );
2315:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxTCPWindow->ulUserDataLength = 0;
2316:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
2317:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
2318:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		#endif /* ipconfigUSE_TCP_WIN */
2319:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
2320:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	else
2321:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
2322:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPWindow->ucOptionLength = 0U;
2323:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
2324:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2325:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	return xResult;
2326:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** }
2327:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
2328:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2329:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /* Set the TCP options (if any) for the outgoing packet. */
2330:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static UBaseType_t prvSetOptions( FreeRTOS_Socket_t *pxSocket, const NetworkBufferDescriptor_t *pxN
2331:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** {
2332:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /* Map the ethernet buffer onto the ProtocolHeader_t struct for easy access to the fields. */
2333:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** ProtocolHeaders_t *pxProtocolHeaders = ipCAST_PTR_TO_TYPE_PTR( ProtocolHeaders_t,
2334:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	&( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + xIPHeaderSize( pxNetworkBuffer ) ] )
2335:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** TCPHeader_t *pxTCPHeader = &pxProtocolHeaders->xTCPHeader;
2336:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** const TCPWindow_t *pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
2337:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** UBaseType_t uxOptionsLength = pxTCPWindow->ucOptionLength;
2338:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2339:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #if(	ipconfigUSE_TCP_WIN == 1 )
2340:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( uxOptionsLength != 0U )
2341:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
2342:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* TCP options must be sent because a packet which is out-of-order
2343:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		was received. */
2344:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( xTCPWindowLoggingLevel >= 0 )
2345:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
2346:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			FreeRTOS_debug_printf( ( "SACK[%d,%d]: optlen %lu sending %lu - %lu\n",
2347:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxSocket->usLocalPort,
2348:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxSocket->u.xTCP.usRemotePort,
2349:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				uxOptionsLength,
2350:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				FreeRTOS_ntohl( pxTCPWindow->ulOptionsData[ 1 ] ) - pxSocket->u.xTCP.xTCPWindow.rx.ulFirstSeque
2351:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				FreeRTOS_ntohl( pxTCPWindow->ulOptionsData[ 2 ] ) - pxSocket->u.xTCP.xTCPWindow.rx.ulFirstSeque
2352:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
2353:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		( void ) memcpy( ( void * ) ( pxTCPHeader->ucOptdata ), ( const void * ) ( pxTCPWindow->ulOptions
2354:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2355:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* The header length divided by 4, goes into the higher nibble,
2356:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		effectively a shift-left 2. */
2357:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPHeader->ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
2358:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
2359:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	else
2360:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #endif	/* ipconfigUSE_TCP_WIN */
2361:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( ( pxSocket->u.xTCP.ucTCPState >= ( EventBits_t ) eESTABLISHED ) && ( pxSocket->u.xTCP.bits.bMs
2362:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
2363:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* TCP options must be sent because the MSS has changed. */
2364:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxSocket->u.xTCP.bits.bMssChange = pdFALSE_UNSIGNED;
2365:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( xTCPWindowLoggingLevel >= 0 )
2366:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
2367:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			FreeRTOS_debug_printf( ( "MSS: sending %d\n", pxSocket->u.xTCP.usCurMSS ) );
2368:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
2369:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2370:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPHeader->ucOptdata[ 0 ] = tcpTCP_OPT_MSS;
2371:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPHeader->ucOptdata[ 1 ] = tcpTCP_OPT_MSS_LEN;
2372:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPHeader->ucOptdata[ 2 ] = ( uint8_t ) ( ( pxSocket->u.xTCP.usCurMSS ) >> 8 );
2373:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPHeader->ucOptdata[ 3 ] = ( uint8_t ) ( ( pxSocket->u.xTCP.usCurMSS ) & 0xffU );
2374:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		uxOptionsLength = 4U;
2375:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPHeader->ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
2376:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
2377:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	else
2378:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
2379:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Nothing. */
2380:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
2381:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2382:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	return uxOptionsLength;
2383:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** }
2384:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
2385:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2386:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
2387:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * prvHandleSynReceived(): called from prvTCPHandleState()
2388:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  *
2389:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Called from the states: eSYN_RECEIVED and eCONNECT_SYN
2390:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * If the flags received are correct, the socket will move to eESTABLISHED.
2391:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
2392:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static BaseType_t prvHandleSynReceived( FreeRTOS_Socket_t *pxSocket, const NetworkBufferDescriptor_
2393:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	uint32_t ulReceiveLength, UBaseType_t uxOptionsLength )
2394:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** {
2395:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /* Map the ethernet buffer onto the ProtocolHeader_t struct for easy access to the fields. */
2396:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** ProtocolHeaders_t *pxProtocolHeaders = ipCAST_PTR_TO_TYPE_PTR( ProtocolHeaders_t,
2397:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	&( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + uxIPHeaderSizeSocket( pxSocket ) ] )
2398:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** TCPHeader_t *pxTCPHeader = &pxProtocolHeaders->xTCPHeader;
2399:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** TCPWindow_t *pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
2400:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint8_t ucTCPFlags = pxTCPHeader->ucTCPFlags;
2401:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint32_t ulSequenceNumber = FreeRTOS_ntohl( pxTCPHeader->ulSequenceNumber );
2402:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** BaseType_t xSendLength = 0;
2403:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** UBaseType_t uxIntermediateResult = 0;
2404:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2405:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	/* Either expect a ACK or a SYN+ACK. */
2406:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	uint8_t ucExpect = tcpTCP_FLAG_ACK;
2407:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eCONNECT_SYN )
2408:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
2409:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		ucExpect |= tcpTCP_FLAG_SYN;
2410:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
2411:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2412:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	const uint8_t ucFlagsMask = tcpTCP_FLAG_ACK | tcpTCP_FLAG_RST | tcpTCP_FLAG_SYN | tcpTCP_FLAG_FIN;
2413:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2414:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( ( ucTCPFlags & ucFlagsMask ) != ucExpect )
2415:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
2416:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* eSYN_RECEIVED: flags 0010 expected, not 0002. */
2417:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* eSYN_RECEIVED: flags ACK  expected, not SYN. */
2418:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		FreeRTOS_debug_printf( ( "%s: flags %04X expected, not %04X\n",
2419:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eSYN_RECEIVED ) ? "eSYN_RECEIVED" : "eCONNECT_SYN",
2420:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			ucExpect, ucTCPFlags ) );
2421:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		vTCPStateChange( pxSocket, eCLOSE_WAIT );
2422:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Send RST with the expected sequence and ACK numbers,
2423:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		otherwise the packet will be ignored. */
2424:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPWindow->ulOurSequenceNumber = FreeRTOS_htonl( pxTCPHeader->ulAckNr );
2425:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPWindow->rx.ulCurrentSequenceNumber = ulSequenceNumber;
2426:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2427:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPHeader->ucTCPFlags |= tcpTCP_FLAG_RST;
2428:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2429:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		uxIntermediateResult = uxIPHeaderSizeSocket( pxSocket ) + ipSIZE_OF_TCP_HEADER + uxOptionsLength;
2430:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		xSendLength = ( BaseType_t ) uxIntermediateResult;
2431:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2432:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPHeader->ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
2433:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
2434:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	else
2435:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
2436:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPWindow->usPeerPortNumber = pxSocket->u.xTCP.usRemotePort;
2437:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPWindow->usOurPortNumber = pxSocket->usLocalPort;
2438:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2439:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eCONNECT_SYN )
2440:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
2441:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Map the Last packet onto the ProtocolHeader_t struct for easy access to the fields. */
2442:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		ProtocolHeaders_t *pxLastHeaders = ipCAST_PTR_TO_TYPE_PTR( ProtocolHeaders_t,
2443:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			&( pxSocket->u.xTCP.xPacket.u.ucLastPacket[ ipSIZE_OF_ETH_HEADER + uxIPHeaderSizeSocket( pxSocke
2444:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2445:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* Clear the SYN flag in lastPacket. */
2446:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxLastHeaders->xTCPHeader.ucTCPFlags = tcpTCP_FLAG_ACK;
2447:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxProtocolHeaders->xTCPHeader.ucTCPFlags = tcpTCP_FLAG_ACK;
2448:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2449:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* This socket was the one connecting actively so now perform the
2450:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			synchronisation. */
2451:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			vTCPWindowInit( &pxSocket->u.xTCP.xTCPWindow,
2452:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				ulSequenceNumber, pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber, ( uint32_t ) pxSocket->u.xTC
2453:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxTCPWindow->rx.ulHighestSequenceNumber = ulSequenceNumber + 1U;
2454:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxTCPWindow->rx.ulCurrentSequenceNumber = ulSequenceNumber + 1U;
2455:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxTCPWindow->tx.ulCurrentSequenceNumber++; /* because we send a TCP_SYN [ | TCP_ACK ]; */
2456:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxTCPWindow->ulNextTxSequenceNumber++;
2457:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
2458:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		else if( ulReceiveLength == 0U )
2459:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
2460:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxTCPWindow->rx.ulCurrentSequenceNumber = ulSequenceNumber;
2461:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
2462:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		else
2463:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
2464:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* Nothing. */
2465:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
2466:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2467:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* The SYN+ACK has been confirmed, increase the next sequence number by
2468:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		1. */
2469:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPWindow->ulOurSequenceNumber = pxTCPWindow->tx.ulFirstSequenceNumber + 1U;
2470:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2471:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		#if( ipconfigUSE_TCP_WIN == 1 )
2472:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
2473:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			FreeRTOS_debug_printf( ( "TCP: %s %d => %lxip:%d set ESTAB (scaling %u)\n",
2474:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				( pxSocket->u.xTCP.ucTCPState == ( uint8_t )  eCONNECT_SYN ) ? "active" : "passive",
2475:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxSocket->usLocalPort,
2476:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxSocket->u.xTCP.ulRemoteIP,
2477:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxSocket->u.xTCP.usRemotePort,
2478:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				( unsigned ) pxSocket->u.xTCP.bits.bWinScaling ) );
2479:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
2480:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		#endif /* ipconfigUSE_TCP_WIN */
2481:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2482:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( ( pxSocket->u.xTCP.ucTCPState == ( EventBits_t ) eCONNECT_SYN ) || ( ulReceiveLength != 0UL )
2483:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
2484:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxTCPHeader->ucTCPFlags = tcpTCP_FLAG_ACK;
2485:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2486:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			uxIntermediateResult = uxIPHeaderSizeSocket( pxSocket ) + ( size_t ) ipSIZE_OF_TCP_HEADER + uxOp
2487:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			xSendLength = ( BaseType_t ) uxIntermediateResult;
2488:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxTCPHeader->ucTCPOffset = ( uint8_t ) ( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
2489:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
2490:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		#if( ipconfigUSE_TCP_WIN != 0 )
2491:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
2492:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( pxSocket->u.xTCP.bits.bWinScaling == pdFALSE_UNSIGNED )
2493:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
2494:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				/* The other party did not send a scaling factor.
2495:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				A shifting factor in this side must be canceled. */
2496:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxSocket->u.xTCP.ucMyWinScaleFactor = 0;
2497:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxSocket->u.xTCP.ucPeerWinScaleFactor = 0;
2498:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
2499:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
2500:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		#endif /* ipconfigUSE_TCP_WIN */
2501:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* This was the third step of connecting: SYN, SYN+ACK, ACK	so now the
2502:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		connection is established. */
2503:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		vTCPStateChange( pxSocket, eESTABLISHED );
2504:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
2505:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2506:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	return xSendLength;
2507:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** }
2508:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
2509:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2510:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
2511:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * prvHandleEstablished(): called from prvTCPHandleState()
2512:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  *
2513:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Called if the status is eESTABLISHED.  Data reception has been handled
2514:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * earlier.  Here the ACK's from peer will be checked, and if a FIN is received,
2515:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * the code will check if it may be accepted, i.e. if all expected data has been
2516:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * completely received.
2517:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
2518:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static BaseType_t prvHandleEstablished( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **pp
2519:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	uint32_t ulReceiveLength, UBaseType_t uxOptionsLength )
2520:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** {
2521:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /* Map the buffer onto the ProtocolHeader_t struct for easy access to the fields. */
2522:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** ProtocolHeaders_t *pxProtocolHeaders = ipCAST_PTR_TO_TYPE_PTR( ProtocolHeaders_t,
2523:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	&( ( *ppxNetworkBuffer )->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + uxIPHeaderSizeSocket( pxSocket
2524:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** TCPHeader_t *pxTCPHeader = &pxProtocolHeaders->xTCPHeader;
2525:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** TCPWindow_t *pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
2526:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint8_t ucTCPFlags = pxTCPHeader->ucTCPFlags;
2527:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint32_t ulSequenceNumber = FreeRTOS_ntohl( pxTCPHeader->ulSequenceNumber ), ulCount, ulIntermediat
2528:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** BaseType_t xSendLength = 0, xMayClose = pdFALSE, bRxComplete, bTxDone;
2529:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** int32_t lDistance, lSendResult;
2530:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint16_t usWindow;
2531:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** UBaseType_t uxIntermediateResult = 0;
2532:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2533:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	/* Remember the window size the peer is advertising. */
2534:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	usWindow = FreeRTOS_ntohs( pxTCPHeader->usWindow );
2535:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	pxSocket->u.xTCP.ulWindowSize = ( uint32_t ) usWindow;
2536:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#if( ipconfigUSE_TCP_WIN != 0 )
2537:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
2538:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxSocket->u.xTCP.ulWindowSize =
2539:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( pxSocket->u.xTCP.ulWindowSize << pxSocket->u.xTCP.ucPeerWinScaleFactor );
2540:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
2541:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#endif /* ipconfigUSE_TCP_WIN */
2542:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2543:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( ( ucTCPFlags & ( uint8_t ) tcpTCP_FLAG_ACK ) != 0U )
2544:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
2545:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		ulCount = ulTCPWindowTxAck( pxTCPWindow, FreeRTOS_ntohl( pxTCPHeader->ulAckNr ) );
2546:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2547:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* ulTCPWindowTxAck() returns the number of bytes which have been acked,
2548:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		starting at 'tx.ulCurrentSequenceNumber'.  Advance the tail pointer in
2549:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		txStream. */
2550:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( ( pxSocket->u.xTCP.txStream != NULL ) && ( ulCount > 0U ) )
2551:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
2552:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* Just advancing the tail index, 'ulCount' bytes have been
2553:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			confirmed, and because there is new space in the txStream, the
2554:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			user/owner should be woken up. */
2555:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* _HT_ : only in case the socket's waiting? */
2556:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( uxStreamBufferGet( pxSocket->u.xTCP.txStream, 0U, NULL, ( size_t ) ulCount, pdFALSE ) != 0U 
2557:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
2558:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxSocket->xEventBits |= ( EventBits_t ) eSOCKET_SEND;
2559:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2560:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				#if ipconfigSUPPORT_SELECT_FUNCTION == 1
2561:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
2562:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					if( ( pxSocket->xSelectBits & ( ( EventBits_t ) eSELECT_WRITE ) ) != 0U )
2563:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					{
2564:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						pxSocket->xEventBits |= ( ( EventBits_t ) eSELECT_WRITE ) << SOCKET_EVENT_BIT_COUNT;
2565:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					}
2566:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
2567:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				#endif
2568:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				/* In case the socket owner has installed an OnSent handler,
2569:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				call it now. */
2570:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				#if( ipconfigUSE_CALLBACKS == 1 )
2571:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
2572:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					if( ipconfigIS_VALID_PROG_ADDRESS( pxSocket->u.xTCP.pxHandleSent ) )
2573:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					{
2574:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						pxSocket->u.xTCP.pxHandleSent( ( Socket_t ) pxSocket, ulCount );
2575:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					}
2576:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
2577:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				#endif /* ipconfigUSE_CALLBACKS == 1  */
2578:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
2579:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
2580:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
2581:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2582:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	/* If this socket has a stream for transmission, add the data to the
2583:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	outgoing segment(s). */
2584:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( pxSocket->u.xTCP.txStream != NULL )
2585:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
2586:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		prvTCPAddTxData( pxSocket );
2587:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
2588:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2589:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber = pxTCPWindow->tx.ulCurrentSequenceNumber;
2590:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2591:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( ( pxSocket->u.xTCP.bits.bFinAccepted != pdFALSE_UNSIGNED ) || ( ( ucTCPFlags & ( uint8_t ) tcp
2592:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
2593:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Peer is requesting to stop, see if we're really finished. */
2594:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		xMayClose = pdTRUE;
2595:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2596:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Checks are only necessary if we haven't sent a FIN yet. */
2597:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED )
2598:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
2599:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* xTCPWindowTxDone returns true when all Tx queues are empty. */
2600:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			bRxComplete = xTCPWindowRxEmpty( pxTCPWindow );
2601:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			bTxDone		= xTCPWindowTxDone( pxTCPWindow );
2602:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2603:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( ( bRxComplete == 0 ) || ( bTxDone == 0 ) )
2604:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
2605:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				/* Refusing FIN: Rx incomp 1 optlen 4 tx done 1. */
2606:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				FreeRTOS_debug_printf( ( "Refusing FIN[%u,%u]: RxCompl %lu tx done %ld\n",
2607:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					pxSocket->usLocalPort,
2608:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					pxSocket->u.xTCP.usRemotePort,
2609:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					bRxComplete, bTxDone ) );
2610:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				xMayClose = pdFALSE;
2611:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
2612:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			else
2613:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
2614:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				ulIntermediateResult = ulSequenceNumber + ulReceiveLength - pxTCPWindow->rx.ulCurrentSequenceNu
2615:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				lDistance = ( int32_t ) ulIntermediateResult;
2616:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2617:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				if( lDistance > 1 )
2618:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
2619:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					FreeRTOS_debug_printf( ( "Refusing FIN: Rx not complete %ld (cur %lu high %lu)\n",
2620:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						lDistance, pxTCPWindow->rx.ulCurrentSequenceNumber - pxTCPWindow->rx.ulFirstSequenceNumber,
2621:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						pxTCPWindow->rx.ulHighestSequenceNumber - pxTCPWindow->rx.ulFirstSequenceNumber ) );
2622:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2623:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					xMayClose = pdFALSE;
2624:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
2625:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
2626:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
2627:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2628:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( xTCPWindowLoggingLevel > 0 )
2629:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
2630:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			FreeRTOS_debug_printf( ( "TCP: FIN received, mayClose = %ld (Rx %lu Len %ld, Tx %lu)\n",
2631:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				xMayClose, ulSequenceNumber - pxSocket->u.xTCP.xTCPWindow.rx.ulFirstSequenceNumber, ulReceiveLe
2632:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxTCPWindow->tx.ulCurrentSequenceNumber - pxSocket->u.xTCP.xTCPWindow.tx.ulFirstSequenceNumber 
2633:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
2634:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2635:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( xMayClose != pdFALSE )
2636:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
2637:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxSocket->u.xTCP.bits.bFinAccepted = pdTRUE_UNSIGNED;
2638:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			xSendLength = prvTCPHandleFin( pxSocket, *ppxNetworkBuffer );
2639:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
2640:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
2641:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2642:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( xMayClose == pdFALSE )
2643:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
2644:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPHeader->ucTCPFlags = tcpTCP_FLAG_ACK;
2645:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2646:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( ulReceiveLength != 0U )
2647:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
2648:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			uxIntermediateResult = uxIPHeaderSizeSocket( pxSocket ) + ipSIZE_OF_TCP_HEADER + uxOptionsLength
2649:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			xSendLength = ( BaseType_t ) uxIntermediateResult;
2650:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* TCP-offsett equals '( ( length / 4 ) << 4 )', resulting in a shift-left 2 */
2651:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxTCPHeader->ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
2652:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2653:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( pxSocket->u.xTCP.bits.bFinSent != pdFALSE_UNSIGNED )
2654:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
2655:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxTCPWindow->tx.ulCurrentSequenceNumber = pxTCPWindow->tx.ulFINSequenceNumber;
2656:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
2657:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
2658:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2659:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Now get data to be transmitted. */
2660:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* _HT_ patch: since the MTU has be fixed at 1500 in stead of 1526, TCP
2661:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		can not	send-out both TCP options and also a full packet. Sending
2662:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		options (SACK) is always more urgent than sending data, which can be
2663:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		sent later. */
2664:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( uxOptionsLength == 0U )
2665:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
2666:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* prvTCPPrepareSend might allocate a bigger network buffer, if
2667:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			necessary. */
2668:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			lSendResult = prvTCPPrepareSend( pxSocket, ppxNetworkBuffer, uxOptionsLength );
2669:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( lSendResult > 0 )
2670:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
2671:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				xSendLength = ( BaseType_t ) lSendResult;
2672:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
2673:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
2674:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
2675:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2676:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	return xSendLength;
2677:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** }
2678:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
2679:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2680:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
2681:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Called from prvTCPHandleState().  There is data to be sent.  If
2682:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * ipconfigUSE_TCP_WIN is defined, and if only an ACK must be sent, it will be
2683:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * checked if it would better be postponed for efficiency.
2684:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
2685:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static BaseType_t prvSendData( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **ppxNetworkB
2686:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	uint32_t ulReceiveLength, BaseType_t xByteCount )
2687:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** {
2688:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /* Map the buffer onto the ProtocolHeader_t struct for easy access to the fields. */
2689:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** const ProtocolHeaders_t *pxProtocolHeaders = ipCAST_PTR_TO_TYPE_PTR( ProtocolHeaders_t,
2690:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	&( ( *ppxNetworkBuffer )->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + xIPHeaderSize( *ppxNetworkBuff
2691:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** const TCPHeader_t *pxTCPHeader = &pxProtocolHeaders->xTCPHeader;
2692:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** const TCPWindow_t *pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
2693:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /* Find out what window size we may advertised. */
2694:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** int32_t lRxSpace;
2695:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** BaseType_t xSendLength = xByteCount;
2696:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint32_t ulRxBufferSpace;
2697:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2698:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #if( ipconfigUSE_TCP_WIN == 1 )
2699:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#if( ipconfigTCP_ACK_EARLIER_PACKET == 0 )
2700:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		const int32_t lMinLength = 0;
2701:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#else
2702:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		int32_t lMinLength;
2703:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#endif
2704:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #endif
2705:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2706:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	/* Set the time-out field, so that we'll be called by the IP-task in case no
2707:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	next message will be received. */
2708:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	ulRxBufferSpace = pxSocket->u.xTCP.ulHighestRxAllowed - pxTCPWindow->rx.ulCurrentSequenceNumber;
2709:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	lRxSpace = ( int32_t ) ulRxBufferSpace;
2710:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2711:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#if ipconfigUSE_TCP_WIN == 1
2712:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
2713:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2714:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		#if( ipconfigTCP_ACK_EARLIER_PACKET != 0 )
2715:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
2716:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			lMinLength = ( ( int32_t ) 2 ) * ( ( int32_t ) pxSocket->u.xTCP.usCurMSS );
2717:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
2718:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		#endif /* ipconfigTCP_ACK_EARLIER_PACKET */
2719:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2720:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* In case we're receiving data continuously, we might postpone sending
2721:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		an ACK to gain performance. */
2722:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* lint e9007 is OK because 'uxIPHeaderSizeSocket()' has no side-effects. */
2723:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( ( ulReceiveLength > 0U ) &&							/* Data was sent to this socket. */
2724:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( lRxSpace >= lMinLength ) &&						/* There is Rx space for more data. */
2725:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED ) &&	/* Not in a closure phase. */
2726:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( xSendLength == ipNUMERIC_CAST( BaseType_t, uxIPHeaderSizeSocket( pxSocket ) + ipSIZE_OF_TCP_HE
2727:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eESTABLISHED ) &&	/* Connection established. */
2728:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( pxTCPHeader->ucTCPFlags == tcpTCP_FLAG_ACK ) )		/* There are no other flags than an ACK. */
2729:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
2730:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( pxSocket->u.xTCP.pxAckMessage != *ppxNetworkBuffer )
2731:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
2732:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				/* There was still a delayed in queue, delete it. */
2733:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				if( pxSocket->u.xTCP.pxAckMessage != NULL )
2734:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
2735:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					vReleaseNetworkBufferAndDescriptor( pxSocket->u.xTCP.pxAckMessage );
2736:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
2737:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2738:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxSocket->u.xTCP.pxAckMessage = *ppxNetworkBuffer;
2739:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
2740:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( ( ulReceiveLength < ( uint32_t ) pxSocket->u.xTCP.usCurMSS ) ||	/* Received a small message.
2741:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				( lRxSpace < ipNUMERIC_CAST( int32_t, 2U * pxSocket->u.xTCP.usCurMSS ) ) )	/* There are less th
2742:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
2743:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxSocket->u.xTCP.usTimeout = ( uint16_t ) tcpDELAYED_ACK_SHORT_DELAY_MS;
2744:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
2745:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			else
2746:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
2747:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				/* Normally a delayed ACK should wait 200 ms for a next incoming
2748:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				packet.  Only wait 20 ms here to gain performance.  A slow ACK
2749:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				for full-size message. */
2750:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxSocket->u.xTCP.usTimeout = ( uint16_t ) ipMS_TO_MIN_TICKS( tcpDELAYED_ACK_LONGER_DELAY_MS );
2751:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
2752:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2753:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( ( xTCPWindowLoggingLevel > 1 ) && ( ipconfigTCP_MAY_LOG_PORT( pxSocket->usLocalPort ) ) )
2754:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
2755:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				FreeRTOS_debug_printf( ( "Send[%u->%u] del ACK %lu SEQ %lu (len %lu) tmout %u d %lu\n",
2756:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					pxSocket->usLocalPort,
2757:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					pxSocket->u.xTCP.usRemotePort,
2758:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					pxTCPWindow->rx.ulCurrentSequenceNumber - pxTCPWindow->rx.ulFirstSequenceNumber,
2759:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber - pxTCPWindow->tx.ulFirstSequenceNumber,
2760:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					xSendLength,
2761:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					pxSocket->u.xTCP.usTimeout, lRxSpace ) );
2762:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
2763:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2764:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			*ppxNetworkBuffer = NULL;
2765:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			xSendLength = 0;
2766:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
2767:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		else if( pxSocket->u.xTCP.pxAckMessage != NULL )
2768:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
2769:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* As an ACK is not being delayed, remove any earlier delayed ACK
2770:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			message. */
2771:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( pxSocket->u.xTCP.pxAckMessage != *ppxNetworkBuffer )
2772:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
2773:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				vReleaseNetworkBufferAndDescriptor( pxSocket->u.xTCP.pxAckMessage );
2774:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
2775:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2776:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxSocket->u.xTCP.pxAckMessage = NULL;
2777:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
2778:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		else
2779:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
2780:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* The ack will not be postponed, and there was no stored ack ( in 'pxAckMessage' ). */
2781:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
2782:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
2783:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#else
2784:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
2785:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Remove compiler warnings. */
2786:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		( void ) ulReceiveLength;
2787:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		( void ) pxTCPHeader;
2788:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		( void ) lRxSpace;
2789:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
2790:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#endif /* ipconfigUSE_TCP_WIN */
2791:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2792:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( xSendLength != 0 )
2793:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
2794:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( ( xTCPWindowLoggingLevel > 1 ) && ( ipconfigTCP_MAY_LOG_PORT( pxSocket->usLocalPort ) ) )
2795:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
2796:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			FreeRTOS_debug_printf( ( "Send[%u->%u] imm ACK %lu SEQ %lu (len %lu)\n",
2797:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxSocket->usLocalPort,
2798:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxSocket->u.xTCP.usRemotePort,
2799:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxTCPWindow->rx.ulCurrentSequenceNumber - pxTCPWindow->rx.ulFirstSequenceNumber,
2800:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxTCPWindow->ulOurSequenceNumber - pxTCPWindow->tx.ulFirstSequenceNumber,
2801:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				xSendLength ) );
2802:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
2803:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2804:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Set the parameter 'xReleaseAfterSend' to the value of
2805:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		ipconfigZERO_COPY_TX_DRIVER. */
2806:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		prvTCPReturnPacket( pxSocket, *ppxNetworkBuffer, ( uint32_t ) xSendLength, ipconfigZERO_COPY_TX_D
2807:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		#if( ipconfigZERO_COPY_TX_DRIVER != 0 )
2808:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
2809:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* The driver has taken ownership of the Network Buffer. */
2810:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			*ppxNetworkBuffer = NULL;
2811:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
2812:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		#endif
2813:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
2814:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2815:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	return xSendLength;
2816:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** }
2817:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
2818:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2819:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
2820:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * prvTCPHandleState()
2821:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * is the most important function of this TCP stack
2822:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * We've tried to keep it (relatively short) by putting a lot of code in
2823:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * the static functions above:
2824:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  *
2825:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  *		prvCheckRxData()
2826:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  *		prvStoreRxData()
2827:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  *		prvSetOptions()
2828:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  *		prvHandleSynReceived()
2829:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  *		prvHandleEstablished()
2830:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  *		prvSendData()
2831:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  *
2832:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * As these functions are declared static, and they're called from one location
2833:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * only, most compilers will inline them, thus avoiding a call and return.
2834:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
2835:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static BaseType_t prvTCPHandleState( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **ppxNe
2836:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** {
2837:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /* Map the buffer onto the ProtocolHeader_t struct for easy access to the fields. */
2838:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** ProtocolHeaders_t *pxProtocolHeaders = ipCAST_PTR_TO_TYPE_PTR( ProtocolHeaders_t,
2839:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	&( ( *ppxNetworkBuffer )->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + xIPHeaderSize( *ppxNetworkBuff
2840:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** TCPHeader_t *pxTCPHeader = &( pxProtocolHeaders->xTCPHeader );
2841:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** BaseType_t xSendLength = 0;
2842:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint32_t ulReceiveLength;	/* Number of bytes contained in the TCP message. */
2843:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint8_t *pucRecvData;
2844:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint32_t ulSequenceNumber = FreeRTOS_ntohl (pxTCPHeader->ulSequenceNumber);
2845:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2846:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	/* uxOptionsLength: the size of the options to be sent (always a multiple of
2847:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	4 bytes)
2848:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	1. in the SYN phase, we shall communicate the MSS
2849:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	2. in case of a SACK, Selective ACK, ack a segment which comes in
2850:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	out-of-order. */
2851:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** UBaseType_t uxOptionsLength = 0U;
2852:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint8_t ucTCPFlags = pxTCPHeader->ucTCPFlags;
2853:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** TCPWindow_t *pxTCPWindow = &( pxSocket->u.xTCP.xTCPWindow );
2854:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** UBaseType_t uxIntermediateResult = 0;
2855:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2856:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	/* First get the length and the position of the received data, if any.
2857:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	pucRecvData will point to the first byte of the TCP payload. */
2858:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	ulReceiveLength = ( uint32_t ) prvCheckRxData( *ppxNetworkBuffer, &pucRecvData );
2859:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2860:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( pxSocket->u.xTCP.ucTCPState >= ( uint8_t ) eESTABLISHED )
2861:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
2862:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if ( pxTCPWindow->rx.ulCurrentSequenceNumber == ( ulSequenceNumber + 1UL ) )
2863:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
2864:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* This is most probably a keep-alive message from peer.  Setting
2865:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			'bWinChange' doesn't cause a window-size-change, the flag is used
2866:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			here to force sending an immediate ACK. */
2867:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxSocket->u.xTCP.bits.bWinChange = pdTRUE_UNSIGNED;
2868:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
2869:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
2870:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2871:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	/* Keep track of the highest sequence number that might be expected within
2872:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	this connection. */
2873:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( ( ipNUMERIC_CAST( int32_t, ulSequenceNumber + ulReceiveLength - pxTCPWindow->rx.ulHighestSeque
2874:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
2875:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPWindow->rx.ulHighestSequenceNumber = ulSequenceNumber + ulReceiveLength;
2876:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
2877:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2878:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	/* Storing data may result in a fatal error if malloc() fails. */
2879:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( prvStoreRxData( pxSocket, pucRecvData, *ppxNetworkBuffer, ulReceiveLength ) < 0 )
2880:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
2881:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		xSendLength = -1;
2882:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
2883:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	else
2884:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
2885:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		uxOptionsLength = prvSetOptions( pxSocket, *ppxNetworkBuffer );
2886:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2887:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( ( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eSYN_RECEIVED ) && ( ( ucTCPFlags & ( uint8_t ) 
2888:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
2889:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			FreeRTOS_debug_printf( ( "eSYN_RECEIVED: ACK expected, not SYN: peer missed our SYN+ACK\n" ) );
2890:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2891:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* In eSYN_RECEIVED a simple ACK is expected, but apparently the
2892:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			'SYN+ACK' didn't arrive.  Step back to the previous state in which
2893:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			a first incoming SYN is handled.  The SYN was counted already so
2894:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			decrease it first. */
2895:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			vTCPStateChange( pxSocket, eSYN_FIRST );
2896:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
2897:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2898:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( ( ( ucTCPFlags & tcpTCP_FLAG_FIN ) != 0U ) && ( pxSocket->u.xTCP.bits.bFinRecv == pdFALSE_UNS
2899:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
2900:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* It's the first time a FIN has been received, remember its
2901:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			sequence number. */
2902:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxTCPWindow->rx.ulFINSequenceNumber = ulSequenceNumber + ulReceiveLength;
2903:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxSocket->u.xTCP.bits.bFinRecv = pdTRUE_UNSIGNED;
2904:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2905:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* Was peer the first one to send a FIN? */
2906:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED )
2907:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
2908:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				/* If so, don't send the-last-ACK. */
2909:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxSocket->u.xTCP.bits.bFinLast = pdTRUE_UNSIGNED;
2910:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
2911:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
2912:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2913:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		switch( ipNUMERIC_CAST( eIPTCPState_t, pxSocket->u.xTCP.ucTCPState ) )
2914:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
2915:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		case eCLOSED:		/* (server + client) no connection state at all. */
2916:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* Nothing to do for a closed socket, except waiting for the
2917:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			owner. */
2918:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			break;
2919:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2920:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		case eTCP_LISTEN:	/* (server) waiting for a connection request from
2921:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							any remote TCP and port. */
2922:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* The listen state was handled in xProcessReceivedTCPPacket().
2923:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			Should not come here. */
2924:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			break;
2925:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2926:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		case eSYN_FIRST:	/* (server) Just received a SYN request for a server
2927:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							socket. */
2928:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
2929:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				/* A new socket has been created, reply with a SYN+ACK.
2930:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				Acknowledge with seq+1 because the SYN is seen as pseudo data
2931:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				with len = 1. */
2932:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				uxOptionsLength = prvSetSynAckOptions( pxSocket, pxTCPHeader );
2933:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxTCPHeader->ucTCPFlags = ( uint8_t ) tcpTCP_FLAG_SYN | ( uint8_t ) tcpTCP_FLAG_ACK;
2934:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2935:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				uxIntermediateResult = uxIPHeaderSizeSocket( pxSocket ) + ipSIZE_OF_TCP_HEADER + uxOptionsLengt
2936:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				xSendLength = ( BaseType_t ) uxIntermediateResult;
2937:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2938:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				/* Set the TCP offset field:  ipSIZE_OF_TCP_HEADER equals 20 and
2939:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				uxOptionsLength is a multiple of 4.  The complete expression is:
2940:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				ucTCPOffset = ( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) / 4 ) << 4 */
2941:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxTCPHeader->ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
2942:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				vTCPStateChange( pxSocket, eSYN_RECEIVED );
2943:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2944:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxTCPWindow->rx.ulHighestSequenceNumber = ulSequenceNumber + 1UL;
2945:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxTCPWindow->rx.ulCurrentSequenceNumber = ulSequenceNumber + 1UL;
2946:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxTCPWindow->ulNextTxSequenceNumber     = pxTCPWindow->tx.ulFirstSequenceNumber + 1UL;
2947:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxTCPWindow->tx.ulCurrentSequenceNumber = pxTCPWindow->tx.ulFirstSequenceNumber + 1UL; /* becau
2948:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
2949:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			break;
2950:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2951:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		case eCONNECT_SYN:	/* (client) also called SYN_SENT: we've just send a
2952:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							SYN, expect	a SYN+ACK and send a ACK now. */
2953:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* Fall through */
2954:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		case eSYN_RECEIVED:	/* (server) we've had a SYN, replied with SYN+SCK
2955:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							expect a ACK and do nothing. */
2956:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			xSendLength = prvHandleSynReceived( pxSocket, *( ppxNetworkBuffer ), ulReceiveLength, uxOptionsL
2957:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			break;
2958:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2959:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		case eESTABLISHED:	/* (server + client) an open connection, data
2960:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							received can be	delivered to the user. The normal
2961:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							state for the data transfer phase of the connection
2962:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							The closing states are also handled here with the
2963:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							use of some flags. */
2964:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			xSendLength = prvHandleEstablished( pxSocket, ppxNetworkBuffer, ulReceiveLength, uxOptionsLength
2965:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			break;
2966:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2967:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		case eLAST_ACK:		/* (server + client) waiting for an acknowledgement
2968:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							of the connection termination request previously
2969:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							sent to the remote TCP (which includes an
2970:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							acknowledgement of its connection termination
2971:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							request). */
2972:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* Fall through */
2973:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		case eFIN_WAIT_1:	/* (server + client) waiting for a connection termination request from the remo
2974:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							 * or an acknowledgement of the connection termination request previously sent. */
2975:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* Fall through */
2976:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		case eFIN_WAIT_2:	/* (server + client) waiting for a connection termination request from the remo
2977:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			xSendLength = prvTCPHandleFin( pxSocket, *ppxNetworkBuffer );
2978:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			break;
2979:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2980:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		case eCLOSE_WAIT:	/* (server + client) waiting for a connection
2981:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							termination request from the local user.  Nothing to
2982:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							do, connection is closed, wait for owner to close
2983:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							this socket. */
2984:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			break;
2985:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2986:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		case eCLOSING:		/* (server + client) waiting for a connection
2987:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							termination request acknowledgement from the remote
2988:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							TCP. */
2989:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			break;
2990:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
2991:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		case eTIME_WAIT:	/* (either server or client) waiting for enough time
2992:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							to pass to be sure the remote TCP received the
2993:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							acknowledgement of its connection termination
2994:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							request. [According to RFC 793 a connection can stay
2995:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							in TIME-WAIT for a maximum of four minutes known as
2996:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							a MSL (maximum segment lifetime).]  These states are
2997:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							implemented implicitly by settings flags like
2998:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							'bFinSent', 'bFinRecv', and 'bFinAcked'. */
2999:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			break;
3000:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		default:
3001:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* No more known states. */
3002:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			break;
3003:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
3004:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
3005:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3006:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( xSendLength > 0 )
3007:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
3008:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		xSendLength = prvSendData( pxSocket, ppxNetworkBuffer, ulReceiveLength, xSendLength );
3009:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
3010:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3011:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	return xSendLength;
3012:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** }
3013:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
3014:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3015:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static BaseType_t prvTCPSendSpecialPacketHelper( NetworkBufferDescriptor_t *pxNetworkBuffer,
3016:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 												 uint8_t ucTCPFlags )
3017:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** {
3018:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #if( ipconfigIGNORE_UNKNOWN_PACKETS == 1 )
3019:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	/* Configured to ignore unknown packets just suppress a compiler warning. */
3020:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	( void ) pxNetworkBuffer;
3021:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	( void ) ucTCPFlags;
3022:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #else
3023:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
3024:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Map the ethernet buffer onto the TCPPacket_t struct for easy access to the fields. */
3025:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		TCPPacket_t *pxTCPPacket = ipCAST_PTR_TO_TYPE_PTR( TCPPacket_t, pxNetworkBuffer->pucEthernetBuffe
3026:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		const uint32_t ulSendLength = ( uint32_t )
3027:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER ); /* Plus 0 options. */
3028:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3029:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPPacket->xTCPHeader.ucTCPFlags = ucTCPFlags;
3030:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPPacket->xTCPHeader.ucTCPOffset = ( ipSIZE_OF_TCP_HEADER ) << 2;
3031:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3032:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		prvTCPReturnPacket( NULL, pxNetworkBuffer, ulSendLength, pdFALSE );
3033:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
3034:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #endif /* !ipconfigIGNORE_UNKNOWN_PACKETS */
3035:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3036:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	/* The packet was not consumed. */
3037:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	return pdFAIL;
3038:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** }
3039:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
3040:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3041:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static BaseType_t prvTCPSendChallengeAck( NetworkBufferDescriptor_t *pxNetworkBuffer )
3042:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** {
3043:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	return prvTCPSendSpecialPacketHelper( pxNetworkBuffer, tcpTCP_FLAG_ACK );
3044:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** }
3045:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
3046:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3047:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static BaseType_t prvTCPSendReset( NetworkBufferDescriptor_t *pxNetworkBuffer )
3048:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** {
 515              	 .loc 1 3048 0
 516              	 .cfi_startproc
 517              	 
 518              	 
 519              	.LVL70:
 520 0000 08B5     	 push {r3,lr}
 521              	.LCFI4:
 522              	 .cfi_def_cfa_offset 8
 523              	 .cfi_offset 3,-8
 524              	 .cfi_offset 14,-4
 525 0002 0146     	 mov r1,r0
 526              	.LVL71:
 527              	.LBB140:
 528              	.LBB141:
3025:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		const uint32_t ulSendLength = ( uint32_t )
 529              	 .loc 1 3025 0
 530 0004 8369     	 ldr r3,[r0,#24]
 531              	.LVL72:
3029:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPPacket->xTCPHeader.ucTCPOffset = ( ipSIZE_OF_TCP_HEADER ) << 2;
 532              	 .loc 1 3029 0
 533 0006 1422     	 movs r2,#20
 534 0008 83F82F20 	 strb r2,[r3,#47]
3030:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 535              	 .loc 1 3030 0
 536 000c 5022     	 movs r2,#80
 537 000e 83F82E20 	 strb r2,[r3,#46]
3032:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 538              	 .loc 1 3032 0
 539 0012 0020     	 movs r0,#0
 540              	.LVL73:
 541 0014 2822     	 movs r2,#40
 542 0016 0346     	 mov r3,r0
 543              	.LVL74:
 544 0018 FFF7FEFF 	 bl prvTCPReturnPacket
 545              	.LVL75:
 546              	.LBE141:
 547              	.LBE140:
3049:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	return prvTCPSendSpecialPacketHelper( pxNetworkBuffer,
3050:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 										  ( uint8_t ) tcpTCP_FLAG_ACK | ( uint8_t ) tcpTCP_FLAG_RST );
3051:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** }
 548              	 .loc 1 3051 0
 549 001c 0020     	 movs r0,#0
 550 001e 08BD     	 pop {r3,pc}
 551              	 .cfi_endproc
 552              	.LFE79:
 554              	 .section .text.prvTCPCreateWindow,"ax",%progbits
 555              	 .align 2
 556              	 .thumb
 557              	 .thumb_func
 559              	prvTCPCreateWindow:
 560              	.LFB56:
 959:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( xTCPWindowLoggingLevel != 0 )
 561              	 .loc 1 959 0
 562              	 .cfi_startproc
 563              	 
 564              	 
 565              	.LVL76:
 566 0000 30B5     	 push {r4,r5,lr}
 567              	.LCFI5:
 568              	 .cfi_def_cfa_offset 12
 569              	 .cfi_offset 4,-12
 570              	 .cfi_offset 5,-8
 571              	 .cfi_offset 14,-4
 572 0002 83B0     	 sub sp,sp,#12
 573              	.LCFI6:
 574              	 .cfi_def_cfa_offset 24
 970:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		( ( size_t ) ipconfigTCP_MSS ) * pxSocket->u.xTCP.uxTxWinSize,
 575              	 .loc 1 970 0
 576 0004 D0F8D010 	 ldr r1,[r0,#208]
 577 0008 4FF49162 	 mov r2,#1160
 971:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber,
 578              	 .loc 1 971 0
 579 000c D0F8D440 	 ldr r4,[r0,#212]
 968:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		&pxSocket->u.xTCP.xTCPWindow,
 580              	 .loc 1 968 0
 581 0010 D0F8E830 	 ldr r3,[r0,#232]
 582 0014 D0F80451 	 ldr r5,[r0,#260]
 583 0018 0095     	 str r5,[sp]
 584 001a B0F84C50 	 ldrh r5,[r0,#76]
 585 001e 0195     	 str r5,[sp,#4]
 586 0020 D830     	 adds r0,r0,#216
 587              	.LVL77:
 588 0022 02FB01F1 	 mul r1,r2,r1
 589 0026 02FB04F2 	 mul r2,r2,r4
 590 002a FFF7FEFF 	 bl vTCPWindowCreate
 591              	.LVL78:
 975:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
 592              	 .loc 1 975 0
 593 002e 03B0     	 add sp,sp,#12
 594              	.LCFI7:
 595              	 .cfi_def_cfa_offset 12
 596              	 
 597 0030 30BD     	 pop {r4,r5,pc}
 598              	 .cfi_endproc
 599              	.LFE56:
 601 0032 00BF     	 .section .text.prvTCPNextTimeout,"ax",%progbits
 602              	 .align 2
 603              	 .thumb
 604              	 .thumb_func
 606              	prvTCPNextTimeout:
 607              	.LFB67:
1974:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** TickType_t ulDelayMs = ( TickType_t ) tcpMAXIMUM_TCP_WAKEUP_TIME_MS;
 608              	 .loc 1 1974 0
 609              	 .cfi_startproc
 610              	 
 611              	 
 612              	.LVL79:
 613 0000 10B5     	 push {r4,lr}
 614              	.LCFI8:
 615              	 .cfi_def_cfa_offset 8
 616              	 .cfi_offset 4,-8
 617              	 .cfi_offset 14,-4
 618 0002 82B0     	 sub sp,sp,#8
 619              	.LCFI9:
 620              	 .cfi_def_cfa_offset 16
 621 0004 0446     	 mov r4,r0
1975:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 622              	 .loc 1 1975 0
 623 0006 44F62063 	 movw r3,#20000
 624 000a 0193     	 str r3,[sp,#4]
1977:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 625              	 .loc 1 1977 0
 626 000c 90F85330 	 ldrb r3,[r0,#83]
 627 0010 022B     	 cmp r3,#2
 628 0012 24D1     	 bne .L30
1980:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 629              	 .loc 1 1980 0
 630 0014 90F84130 	 ldrb r3,[r0,#65]
 631 0018 13F0080F 	 tst r3,#8
 632 001c 13D0     	 beq .L31
1984:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 633              	 .loc 1 1984 0
 634 001e 90F85230 	 ldrb r3,[r0,#82]
 635 0022 022B     	 cmp r3,#2
 636 0024 0BD8     	 bhi .L32
1986:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 637              	 .loc 1 1986 0
 638 0026 5A1E     	 subs r2,r3,#1
 639 0028 40F6B833 	 movw r3,#3000
 640 002c 9340     	 lsls r3,r3,r2
2002:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 641              	 .loc 1 2002 0
 642 002e 4FF47A72 	 mov r2,#1000
 643 0032 02FB03F3 	 mul r3,r2,r3
 644 0036 9342     	 cmp r3,r2
 645 0038 09D2     	 bcs .L33
 646 003a 0123     	 movs r3,#1
 647 003c 0CE0     	 b .L34
 648              	.L32:
1990:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 649              	 .loc 1 1990 0
 650 003e 42F6F823 	 movw r3,#11000
 651 0042 0193     	 str r3,[sp,#4]
 652 0044 30E0     	 b .L35
 653              	.L31:
1996:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 654              	 .loc 1 1996 0
 655 0046 4FF4FA73 	 mov r3,#500
 656 004a 0193     	 str r3,[sp,#4]
 657 004c 2CE0     	 b .L35
 658              	.L33:
2002:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 659              	 .loc 1 2002 0 discriminator 1
 660 004e 1E4A     	 ldr r2,.L45
 661 0050 A2FB0323 	 umull r2,r3,r2,r3
 662 0054 C3F38F13 	 ubfx r3,r3,#6,#16
 663              	.L34:
2002:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 664              	 .loc 1 2002 0 is_stmt 0 discriminator 4
 665 0058 A4F84830 	 strh r3,[r4,#72]
 666 005c 30E0     	 b .L36
 667              	.L30:
2004:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 668              	 .loc 1 2004 0 is_stmt 1
 669 005e B0F84830 	 ldrh r3,[r0,#72]
 670 0062 6BBB     	 cbnz r3,.L36
 671              	.LBB142:
2007:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( ulDelayMs == 0U )
 672              	 .loc 1 2007 0
 673 0064 D830     	 adds r0,r0,#216
 674              	.LVL80:
 675 0066 D4F8CC10 	 ldr r1,[r4,#204]
 676 006a 01AA     	 add r2,sp,#4
 677 006c FFF7FEFF 	 bl xTCPWindowTxHasData
 678              	.LVL81:
2008:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 679              	 .loc 1 2008 0
 680 0070 019A     	 ldr r2,[sp,#4]
 681 0072 3AB9     	 cbnz r2,.L37
2010:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 682              	 .loc 1 2010 0
 683 0074 10B1     	 cbz r0,.L38
2012:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 684              	 .loc 1 2012 0
 685 0076 0123     	 movs r3,#1
 686 0078 0193     	 str r3,[sp,#4]
 687 007a 1BE0     	 b .L39
 688              	.L38:
2016:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 689              	 .loc 1 2016 0
 690 007c 44F62063 	 movw r3,#20000
 691 0080 0193     	 str r3,[sp,#4]
 692 0082 17E0     	 b .L39
 693              	.L37:
2023:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 694              	 .loc 1 2023 0
 695 0084 4FF47A73 	 mov r3,#1000
 696 0088 03FB02F3 	 mul r3,r3,r2
 697 008c B3F57A7F 	 cmp r3,#1000
 698 0090 38BF     	 it cc
 699 0092 0123     	 movcc r3,#1
 700 0094 05D3     	 bcc .L40
 701              	.L41:
2023:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 702              	 .loc 1 2023 0 is_stmt 0 discriminator 1
 703 0096 0C4A     	 ldr r2,.L45
 704 0098 A2FB0323 	 umull r2,r3,r2,r3
 705 009c C3F38F13 	 ubfx r3,r3,#6,#16
 706 00a0 FFE7     	 b .L40
 707              	.L40:
2023:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 708              	 .loc 1 2023 0 discriminator 4
 709 00a2 A4F84830 	 strh r3,[r4,#72]
 710              	.LBE142:
 711 00a6 0BE0     	 b .L36
 712              	.LVL82:
 713              	.L35:
2002:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 714              	 .loc 1 2002 0 is_stmt 1
 715 00a8 4FF47A73 	 mov r3,#1000
 716 00ac 019A     	 ldr r2,[sp,#4]
 717 00ae 03FB02F3 	 mul r3,r3,r2
 718 00b2 CCE7     	 b .L33
 719              	.LVL83:
 720              	.L39:
 721              	.LBB143:
2023:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 722              	 .loc 1 2023 0
 723 00b4 4FF47A73 	 mov r3,#1000
 724 00b8 019A     	 ldr r2,[sp,#4]
 725 00ba 03FB02F3 	 mul r3,r3,r2
 726 00be EAE7     	 b .L41
 727              	.LVL84:
 728              	.L36:
 729              	.LBE143:
2032:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** }
 730              	 .loc 1 2032 0
 731 00c0 B4F84800 	 ldrh r0,[r4,#72]
2033:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
 732              	 .loc 1 2033 0
 733 00c4 02B0     	 add sp,sp,#8
 734              	.LCFI10:
 735              	 .cfi_def_cfa_offset 8
 736              	 
 737 00c6 10BD     	 pop {r4,pc}
 738              	.LVL85:
 739              	.L46:
 740              	 .align 2
 741              	.L45:
 742 00c8 D34D6210 	 .word 274877907
 743              	 .cfi_endproc
 744              	.LFE67:
 746              	 .section .text.vTCPStateChange,"ax",%progbits
 747              	 .align 2
 748              	 .global vTCPStateChange
 749              	 .thumb
 750              	 .thumb_func
 752              	vTCPStateChange:
 753              	.LFB64:
1514:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** FreeRTOS_Socket_t *xParent = NULL;
 754              	 .loc 1 1514 0
 755              	 .cfi_startproc
 756              	 
 757              	 
 758              	.LVL86:
 759 0000 70B5     	 push {r4,r5,r6,lr}
 760              	.LCFI11:
 761              	 .cfi_def_cfa_offset 16
 762              	 .cfi_offset 4,-16
 763              	 .cfi_offset 5,-12
 764              	 .cfi_offset 6,-8
 765              	 .cfi_offset 14,-4
 766 0002 0446     	 mov r4,r0
 767 0004 0D46     	 mov r5,r1
 768              	.LVL87:
1516:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** BaseType_t bAfter  = ipNUMERIC_CAST( BaseType_t, tcpNOW_CONNECTED( ( BaseType_t ) eTCPState ) );			
 769              	 .loc 1 1516 0
 770 0006 90F85330 	 ldrb r3,[r0,#83]
 771 000a 042B     	 cmp r3,#4
 772 000c 7BD9     	 bls .L48
1516:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** BaseType_t bAfter  = ipNUMERIC_CAST( BaseType_t, tcpNOW_CONNECTED( ( BaseType_t ) eTCPState ) );			
 773              	 .loc 1 1516 0 is_stmt 0 discriminator 1
 774 000e 082B     	 cmp r3,#8
 775 0010 7CD1     	 bne .L49
 776 0012 78E0     	 b .L48
 777              	.LVL88:
 778              	.L66:
1532:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 779              	 .loc 1 1532 0 is_stmt 1
 780 0014 94F84030 	 ldrb r3,[r4,#64]
 781 0018 13F0040F 	 tst r3,#4
 782 001c 35D0     	 beq .L50
1535:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
 783              	 .loc 1 1535 0
 784 001e 13F0080F 	 tst r3,#8
 785 0022 0AD1     	 bne .L51
1541:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					configASSERT( xParent != NULL );
 786              	 .loc 1 1541 0
 787 0024 666D     	 ldr r6,[r4,#84]
 788              	.LVL89:
1542:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
 789              	 .loc 1 1542 0
 790 0026 56B9     	 cbnz r6,.L52
 791              	.LBB150:
 792              	.LBB151:
 793              	 .file 4 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h"
   1:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*
   2:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * FreeRTOS Kernel V10.4.1
   3:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
   5:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * this software and associated documentation files (the "Software"), to deal in
   7:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * the Software without restriction, including without limitation the rights to
   8:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * subject to the following conditions:
  11:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  12:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * The above copyright notice and this permission notice shall be included in all
  13:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * copies or substantial portions of the Software.
  14:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  15:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  22:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * https://www.FreeRTOS.org
  23:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * https://github.com/FreeRTOS
  24:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  25:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * 1 tab == 4 spaces!
  26:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  */
  27:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  28:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  29:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** #ifndef PORTMACRO_H
  30:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define PORTMACRO_H
  31:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  32:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifdef __cplusplus
  33:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         extern "C" {
  34:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
  35:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  36:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------
  37:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * Port specific definitions.
  38:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  39:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * The settings in this file configure FreeRTOS correctly for the
  40:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * given hardware and compiler.
  41:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  42:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * These settings should not be altered.
  43:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *-----------------------------------------------------------
  44:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  */
  45:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  46:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Type definitions. */
  47:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portCHAR          char
  48:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portFLOAT         float
  49:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portDOUBLE        double
  50:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portLONG          long
  51:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portSHORT         short
  52:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portSTACK_TYPE    uint32_t
  53:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portBASE_TYPE     long
  54:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  55:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     typedef portSTACK_TYPE   StackType_t;
  56:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     typedef long             BaseType_t;
  57:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     typedef unsigned long    UBaseType_t;
  58:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  59:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #if ( configUSE_16_BIT_TICKS == 1 )
  60:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         typedef uint16_t     TickType_t;
  61:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portMAX_DELAY              ( TickType_t ) 0xffff
  62:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #else
  63:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         typedef uint32_t     TickType_t;
  64:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portMAX_DELAY              ( TickType_t ) 0xffffffffUL
  65:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  66:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
  67:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * not need to be guarded with a critical section. */
  68:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portTICK_TYPE_IS_ATOMIC    1
  69:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
  70:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
  71:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  72:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Architecture specifics. */
  73:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portSTACK_GROWTH      ( -1 )
  74:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portTICK_PERIOD_MS    ( ( TickType_t ) 1000 / configTICK_RATE_HZ )
  75:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portBYTE_ALIGNMENT    8
  76:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portDONT_DISCARD      __attribute__( ( used ) )
  77:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
  78:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  79:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Scheduler utilities. */
  80:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portYIELD()                                 \
  81:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     {                                                   \
  82:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         /* Set a PendSV to request a context switch. */ \
  83:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT; \
  84:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****                                                         \
  85:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         /* Barriers are normally not required but do ensure the code is completely \
  86:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****          * within the specified behaviour for the architecture. */ \
  87:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile ( "dsb" ::: "memory" );                     \
  88:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile ( "isb" );                                  \
  89:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     }
  90:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  91:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portNVIC_INT_CTRL_REG     ( *( ( volatile uint32_t * ) 0xe000ed04 ) )
  92:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portNVIC_PENDSVSET_BIT    ( 1UL << 28UL )
  93:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portEND_SWITCHING_ISR( xSwitchRequired )    if( xSwitchRequired != pdFALSE ) portYIELD(
  94:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portYIELD_FROM_ISR( x )                     portEND_SWITCHING_ISR( x )
  95:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
  96:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  97:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Critical section management. */
  98:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     extern void vPortEnterCritical( void );
  99:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     extern void vPortExitCritical( void );
 100:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portSET_INTERRUPT_MASK_FROM_ISR()         ulPortRaiseBASEPRI()
 101:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portCLEAR_INTERRUPT_MASK_FROM_ISR( x )    vPortSetBASEPRI( x )
 102:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portDISABLE_INTERRUPTS()                  vPortRaiseBASEPRI()
 103:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portENABLE_INTERRUPTS()                   vPortSetBASEPRI( 0 )
 104:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portENTER_CRITICAL()                      vPortEnterCritical()
 105:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portEXIT_CRITICAL()                       vPortExitCritical()
 106:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 107:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 108:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 109:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Task function macros as described on the FreeRTOS.org WEB site.  These are
 110:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * not necessary for to use this port.  They are defined so the common demo files
 111:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * (which build with all the ports) will build. */
 112:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portTASK_FUNCTION_PROTO( vFunction, pvParameters )    void vFunction( void * pvParamete
 113:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portTASK_FUNCTION( vFunction, pvParameters )          void vFunction( void * pvParamete
 114:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 115:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 116:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Tickless idle/low power functionality. */
 117:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifndef portSUPPRESS_TICKS_AND_SLEEP
 118:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
 119:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime )    vPortSuppressTicksAndSleep( xE
 120:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
 121:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 122:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 123:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Architecture specific optimisations. */
 124:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
 125:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define configUSE_PORT_OPTIMISED_TASK_SELECTION    1
 126:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
 127:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 128:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
 129:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 130:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Generic helper function. */
 131:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t 
 132:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         {
 133:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             uint8_t ucReturn;
 134:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 135:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             __asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 136:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 137:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             return ucReturn;
 138:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         }
 139:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 140:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Check the configuration. */
 141:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #if ( configMAX_PRIORITIES > 32 )
 142:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             #error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIO
 143:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #endif
 144:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 145:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Store/clear the ready priorities in a bit map. */
 146:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities )    ( uxReadyPriorities )
 147:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities )     ( uxReadyPriorities )
 148:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 149:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 150:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 151:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities )    uxTopPriority = ( 3
 152:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 153:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 154:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 155:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 156:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 157:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifdef configASSERT
 158:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         void vPortValidateInterruptPriority( void );
 159:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portASSERT_IF_INTERRUPT_PRIORITY_INVALID()    vPortValidateInterruptPriority()
 160:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
 161:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 162:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* portNOP() is not required by this port. */
 163:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portNOP()
 164:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 165:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portINLINE              __inline
 166:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 167:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifndef portFORCE_INLINE
 168:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portFORCE_INLINE    inline __attribute__( ( always_inline ) )
 169:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
 170:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 171:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     portFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )
 172:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     {
 173:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         uint32_t ulCurrentInterrupt;
 174:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         BaseType_t xReturn;
 175:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 176:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         /* Obtain the number of the currently executing interrupt. */
 177:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile ( "mrs %0, ipsr" : "=r" ( ulCurrentInterrupt )::"memory" );
 178:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 179:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         if( ulCurrentInterrupt == 0 )
 180:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         {
 181:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             xReturn = pdFALSE;
 182:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         }
 183:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         else
 184:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         {
 185:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             xReturn = pdTRUE;
 186:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         }
 187:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 188:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         return xReturn;
 189:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     }
 190:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 191:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 192:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 193:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     portFORCE_INLINE static void vPortRaiseBASEPRI( void )
 194:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     {
 195:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         uint32_t ulNewBASEPRI;
 196:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile
 794              	 .loc 4 197 0
 795              	
 796 0028 4FF01403 	 mov r3,#20
 797 002c 83F31188 	 msr basepri,r3
 798 0030 BFF36F8F 	 isb 
 799 0034 BFF34F8F 	 dsb 
 800              	
 801              	
 802              	.LVL90:
 803              	 .thumb
 804              	.L53:
 805              	.LBE151:
 806              	.LBE150:
1542:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
 807              	 .loc 1 1542 0 discriminator 1
 808 0038 FEE7     	 b .L53
 809              	.LVL91:
 810              	.L51:
1544:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
 811              	 .loc 1 1544 0
 812 003a 7CB1     	 cbz r4,.L70
1537:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
 813              	 .loc 1 1537 0
 814 003c 2646     	 mov r6,r4
 815              	.LVL92:
 816              	.L52:
1546:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					{
 817              	 .loc 1 1546 0
 818 003e 736D     	 ldr r3,[r6,#84]
 819 0040 03B9     	 cbnz r3,.L55
1548:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					}
 820              	 .loc 1 1548 0
 821 0042 7465     	 str r4,[r6,#84]
 822              	.L55:
1551:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 823              	 .loc 1 1551 0
 824 0044 3368     	 ldr r3,[r6]
 825 0046 43F00402 	 orr r2,r3,#4
 826 004a 3260     	 str r2,[r6]
1557:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						{
 827              	 .loc 1 1557 0
 828 004c 326B     	 ldr r2,[r6,#48]
 829 004e 12F0010F 	 tst r2,#1
 830 0052 04D0     	 beq .L54
1559:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						}
 831              	 .loc 1 1559 0
 832 0054 43F48273 	 orr r3,r3,#260
 833 0058 3360     	 str r3,[r6]
 834 005a 00E0     	 b .L54
 835              	.LVL93:
 836              	.L70:
1537:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
 837              	 .loc 1 1537 0
 838 005c 2646     	 mov r6,r4
 839              	.LVL94:
 840              	.L54:
1580:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxSocket->u.xTCP.bits.bPassQueued = pdFALSE_UNSIGNED;
 841              	 .loc 1 1580 0
 842 005e 0023     	 movs r3,#0
 843 0060 6365     	 str r3,[r4,#84]
1581:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 844              	 .loc 1 1581 0
 845 0062 94F84030 	 ldrb r3,[r4,#64]
1584:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 846              	 .loc 1 1584 0
 847 0066 03F0FB03 	 and r3,r3,#251
 848 006a 43F00203 	 orr r3,r3,#2
 849 006e 84F84030 	 strb r3,[r4,#64]
 850              	.LVL95:
 851              	.LBB152:
 852              	.LBB153:
 367:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 853              	 .loc 1 367 0
 854 0072 94F85330 	 ldrb r3,[r4,#83]
 855 0076 0B2B     	 cmp r3,#11
 856 0078 2CD8     	 bhi .L56
 857 007a DFE803F0 	 tbb [pc,r3]
 858              	.L58:
 859 007e 4E       	 .byte (.L57-.L58)/2
 860 007f 2B       	 .byte (.L56-.L58)/2
 861 0080 2B       	 .byte (.L56-.L58)/2
 862 0081 2B       	 .byte (.L56-.L58)/2
 863 0082 2B       	 .byte (.L56-.L58)/2
 864 0083 2B       	 .byte (.L56-.L58)/2
 865 0084 2B       	 .byte (.L56-.L58)/2
 866 0085 4E       	 .byte (.L57-.L58)/2
 867 0086 4E       	 .byte (.L57-.L58)/2
 868 0087 4E       	 .byte (.L57-.L58)/2
 869 0088 2B       	 .byte (.L56-.L58)/2
 870 0089 4E       	 .byte (.L57-.L58)/2
 871              	.LVL96:
 872              	 .p2align 1
 873              	.L50:
 874              	.LBE153:
 875              	.LBE152:
1588:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 876              	 .loc 1 1588 0
 877 008a 2368     	 ldr r3,[r4]
 878 008c 43F00802 	 orr r2,r3,#8
 879 0090 2260     	 str r2,[r4]
1592:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					{
 880              	 .loc 1 1592 0
 881 0092 226B     	 ldr r2,[r4,#48]
 882 0094 12F0020F 	 tst r2,#2
 883 0098 74D0     	 beq .L59
1594:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					}
 884              	 .loc 1 1594 0
 885 009a 43F40273 	 orr r3,r3,#520
 886 009e 2360     	 str r3,[r4]
 887 00a0 70E0     	 b .L59
 888              	.LVL97:
 889              	.L65:
1603:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 890              	 .loc 1 1603 0
 891 00a2 2368     	 ldr r3,[r4]
 892 00a4 43F02002 	 orr r2,r3,#32
 893 00a8 2260     	 str r2,[r4]
1607:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
 894              	 .loc 1 1607 0
 895 00aa 226B     	 ldr r2,[r4,#48]
 896 00ac 12F0040F 	 tst r2,#4
 897 00b0 68D0     	 beq .L59
1609:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
 898              	 .loc 1 1609 0
 899 00b2 43F48463 	 orr r3,r3,#1056
 900 00b6 2360     	 str r3,[r4]
 901 00b8 64E0     	 b .L59
 902              	.LVL98:
 903              	.L63:
1635:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 904              	 .loc 1 1635 0
 905 00ba 95BB     	 cbnz r5,.L60
1639:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				( pxSocket->u.xTCP.bits.bPassAccept != pdFALSE_UNSIGNED ) )
 906              	 .loc 1 1639 0
 907 00bc 94F84030 	 ldrb r3,[r4,#64]
 908 00c0 13F0060F 	 tst r3,#6
 909 00c4 2DD0     	 beq .L60
1643:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
 910              	 .loc 1 1643 0
 911 00c6 13F0080F 	 tst r3,#8
 912 00ca 2AD1     	 bne .L60
1645:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
 913              	 .loc 1 1645 0
 914 00cc 2046     	 mov r0,r4
 915              	.LVL99:
 916 00ce FFF7FEFF 	 bl FreeRTOS_closesocket
 917              	.LVL100:
 918 00d2 26E0     	 b .L60
 919              	.LVL101:
 920              	.L56:
1652:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 921              	 .loc 1 1652 0
 922 00d4 84F85350 	 strb r5,[r4,#83]
 923              	.LVL102:
 924              	.LBB156:
 925              	.LBB157:
1490:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 926              	 .loc 1 1490 0
 927 00d8 FFF7FEFF 	 bl xTaskGetTickCount
 928              	.LVL103:
 929 00dc 2066     	 str r0,[r4,#96]
1496:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxSocket->u.xTCP.bits.bSendKeepAlive = pdFALSE_UNSIGNED;
 930              	 .loc 1 1496 0
 931 00de 94F84130 	 ldrb r3,[r4,#65]
1497:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxSocket->u.xTCP.ucKeepRepCount = 0U;
 932              	 .loc 1 1497 0
 933 00e2 03F0FB03 	 and r3,r3,#251
 934 00e6 6FF34103 	 bfc r3,#1,#1
 935 00ea 84F84130 	 strb r3,[r4,#65]
1498:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxSocket->u.xTCP.xLastAliveTime = xTaskGetTickCount();
 936              	 .loc 1 1498 0
 937 00ee 0023     	 movs r3,#0
 938 00f0 84F85830 	 strb r3,[r4,#88]
1499:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 939              	 .loc 1 1499 0
 940 00f4 FFF7FEFF 	 bl xTaskGetTickCount
 941              	.LVL104:
 942 00f8 E065     	 str r0,[r4,#92]
 943              	.LBE157:
 944              	.LBE156:
1680:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 945              	 .loc 1 1680 0
 946 00fa 002E     	 cmp r6,#0
 947 00fc 62D0     	 beq .L47
1682:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 948              	 .loc 1 1682 0
 949 00fe 3046     	 mov r0,r6
 950 0100 FFF7FEFF 	 bl vSocketWakeUpUser
 951              	.LVL105:
 952 0104 70BD     	 pop {r4,r5,r6,pc}
 953              	.LVL106:
 954              	.L48:
1517:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #if( ipconfigHAS_DEBUG_PRINTF != 0 )
 955              	 .loc 1 1517 0
 956 0106 042D     	 cmp r5,#4
 957 0108 1FD8     	 bhi .L62
 958 010a D6E7     	 b .L63
 959              	.LVL107:
 960              	.L49:
 961 010c 0429     	 cmp r1,#4
 962 010e 21D8     	 bhi .L64
 963 0110 C7E7     	 b .L65
 964              	.LVL108:
 965              	.L67:
1526:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 966              	 .loc 1 1526 0
 967 0112 002B     	 cmp r3,#0
 968 0114 C5D1     	 bne .L65
 969 0116 04E0     	 b .L60
 970              	.LVL109:
 971              	.L71:
 972              	.LBB160:
 973              	.LBB154:
 367:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 974              	 .loc 1 367 0
 975 0118 0026     	 movs r6,#0
 976              	.LVL110:
 977              	.L57:
 978              	.LBE154:
 979              	.LBE160:
1630:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 980              	 .loc 1 1630 0
 981 011a 0023     	 movs r3,#0
 982 011c A4F84830 	 strh r3,[r4,#72]
 983 0120 D8E7     	 b .L56
 984              	.LVL111:
 985              	.L60:
1652:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 986              	 .loc 1 1652 0
 987 0122 84F85350 	 strb r5,[r4,#83]
 988              	.LVL112:
 989              	.LBB161:
 990              	.LBB158:
1490:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 991              	 .loc 1 1490 0
 992 0126 FFF7FEFF 	 bl xTaskGetTickCount
 993              	.LVL113:
 994 012a 2066     	 str r0,[r4,#96]
1496:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxSocket->u.xTCP.bits.bSendKeepAlive = pdFALSE_UNSIGNED;
 995              	 .loc 1 1496 0
 996 012c 94F84130 	 ldrb r3,[r4,#65]
1497:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxSocket->u.xTCP.ucKeepRepCount = 0U;
 997              	 .loc 1 1497 0
 998 0130 03F0FB03 	 and r3,r3,#251
 999 0134 6FF34103 	 bfc r3,#1,#1
 1000 0138 84F84130 	 strb r3,[r4,#65]
1498:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxSocket->u.xTCP.xLastAliveTime = xTaskGetTickCount();
 1001              	 .loc 1 1498 0
 1002 013c 0023     	 movs r3,#0
 1003 013e 84F85830 	 strb r3,[r4,#88]
1499:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 1004              	 .loc 1 1499 0
 1005 0142 FFF7FEFF 	 bl xTaskGetTickCount
 1006              	.LVL114:
 1007 0146 E065     	 str r0,[r4,#92]
 1008 0148 70BD     	 pop {r4,r5,r6,pc}
 1009              	.LVL115:
 1010              	.L62:
 1011              	.LBE158:
 1012              	.LBE161:
1517:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #if( ipconfigHAS_DEBUG_PRINTF != 0 )
 1013              	 .loc 1 1517 0
 1014 014a 082D     	 cmp r5,#8
 1015 014c 7FF462AF 	 bne .L66
 1016 0150 0023     	 movs r3,#0
 1017 0152 DEE7     	 b .L67
 1018              	.LVL116:
 1019              	.L64:
 1020 0154 0829     	 cmp r1,#8
 1021 0156 B0D1     	 bne .L63
1516:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** BaseType_t bAfter  = ipNUMERIC_CAST( BaseType_t, tcpNOW_CONNECTED( ( BaseType_t ) eTCPState ) );			
 1022              	 .loc 1 1516 0
 1023 0158 0123     	 movs r3,#1
 1024 015a DAE7     	 b .L67
 1025              	.LVL117:
 1026              	.L68:
1652:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1027              	 .loc 1 1652 0
 1028 015c 84F85350 	 strb r5,[r4,#83]
 1029              	.LVL118:
 1030              	.LBB162:
 1031              	.LBB159:
1490:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 1032              	 .loc 1 1490 0
 1033 0160 FFF7FEFF 	 bl xTaskGetTickCount
 1034              	.LVL119:
 1035 0164 2066     	 str r0,[r4,#96]
1496:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxSocket->u.xTCP.bits.bSendKeepAlive = pdFALSE_UNSIGNED;
 1036              	 .loc 1 1496 0
 1037 0166 94F84130 	 ldrb r3,[r4,#65]
1497:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxSocket->u.xTCP.ucKeepRepCount = 0U;
 1038              	 .loc 1 1497 0
 1039 016a 03F0FB03 	 and r3,r3,#251
 1040 016e 6FF34103 	 bfc r3,#1,#1
 1041 0172 84F84130 	 strb r3,[r4,#65]
1498:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxSocket->u.xTCP.xLastAliveTime = xTaskGetTickCount();
 1042              	 .loc 1 1498 0
 1043 0176 0023     	 movs r3,#0
 1044 0178 84F85830 	 strb r3,[r4,#88]
1499:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 1045              	 .loc 1 1499 0
 1046 017c FFF7FEFF 	 bl xTaskGetTickCount
 1047              	.LVL120:
 1048 0180 E065     	 str r0,[r4,#92]
 1049 0182 70BD     	 pop {r4,r5,r6,pc}
 1050              	.LVL121:
 1051              	.L59:
 1052              	.LBE159:
 1053              	.LBE162:
 1054              	.LBB163:
 1055              	.LBB155:
 367:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 1056              	 .loc 1 367 0
 1057 0184 94F85330 	 ldrb r3,[r4,#83]
 1058 0188 0B2B     	 cmp r3,#11
 1059 018a E7D8     	 bhi .L68
 1060 018c 01A2     	 adr r2,.L69
 1061 018e 52F823F0 	 ldr pc,[r2,r3,lsl#2]
 1062 0192 00BF     	 .p2align 2
 1063              	.L69:
 1064 0194 19010000 	 .word .L71+1
 1065 0198 5D010000 	 .word .L68+1
 1066 019c 5D010000 	 .word .L68+1
 1067 01a0 5D010000 	 .word .L68+1
 1068 01a4 5D010000 	 .word .L68+1
 1069 01a8 5D010000 	 .word .L68+1
 1070 01ac 5D010000 	 .word .L68+1
 1071 01b0 19010000 	 .word .L71+1
 1072 01b4 19010000 	 .word .L71+1
 1073 01b8 19010000 	 .word .L71+1
 1074 01bc 5D010000 	 .word .L68+1
 1075 01c0 19010000 	 .word .L71+1
 1076              	.LVL122:
 1077              	 .p2align 1
 1078              	.L47:
 1079 01c4 70BD     	 pop {r4,r5,r6,pc}
 1080              	.LBE155:
 1081              	.LBE163:
 1082              	 .cfi_endproc
 1083              	.LFE64:
 1085 01c6 00BF     	 .section .text.prvTCPPrepareSend,"ax",%progbits
 1086              	 .align 2
 1087              	 .thumb
 1088              	 .thumb_func
 1090              	prvTCPPrepareSend:
 1091              	.LFB66:
1780:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** int32_t lDataLen;
 1092              	 .loc 1 1780 0
 1093              	 .cfi_startproc
 1094              	 
 1095              	 
 1096              	.LVL123:
 1097 0000 2DE9F04F 	 push {r4,r5,r6,r7,r8,r9,r10,fp,lr}
 1098              	.LCFI12:
 1099              	 .cfi_def_cfa_offset 36
 1100              	 .cfi_offset 4,-36
 1101              	 .cfi_offset 5,-32
 1102              	 .cfi_offset 6,-28
 1103              	 .cfi_offset 7,-24
 1104              	 .cfi_offset 8,-20
 1105              	 .cfi_offset 9,-16
 1106              	 .cfi_offset 10,-12
 1107              	 .cfi_offset 11,-8
 1108              	 .cfi_offset 14,-4
 1109 0004 87B0     	 sub sp,sp,#28
 1110              	.LCFI13:
 1111              	 .cfi_def_cfa_offset 64
 1112 0006 0446     	 mov r4,r0
 1113 0008 8B46     	 mov fp,r1
 1114 000a 9046     	 mov r8,r2
 1115              	.LVL124:
1791:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 1116              	 .loc 1 1791 0
 1117 000c 0B68     	 ldr r3,[r1]
 1118 000e 0BB1     	 cbz r3,.L74
1794:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 1119              	 .loc 1 1794 0
 1120 0010 9E69     	 ldr r6,[r3,#24]
 1121              	.LVL125:
 1122 0012 01E0     	 b .L75
 1123              	.LVL126:
 1124              	.L74:
1799:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 1125              	 .loc 1 1799 0
 1126 0014 00F18206 	 add r6,r0,#130
 1127              	.LVL127:
 1128              	.L75:
1803:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	pxTCPWindow = &( pxSocket->u.xTCP.xTCPWindow );
 1129              	 .loc 1 1803 0
 1130 0018 06F12205 	 add r5,r6,#34
 1131              	.LVL128:
1804:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	lDataLen = 0;
 1132              	 .loc 1 1804 0
 1133 001c 04F1D803 	 add r3,r4,#216
 1134 0020 1846     	 mov r0,r3
 1135              	.LVL129:
 1136 0022 0393     	 str r3,[sp,#12]
 1137              	.LVL130:
1806:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	pxProtocolHeaders->xTCPHeader.ucTCPFlags |= tcpTCP_FLAG_ACK;
 1138              	 .loc 1 1806 0
 1139 0024 0023     	 movs r3,#0
 1140 0026 0593     	 str r3,[sp,#20]
1807:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1141              	 .loc 1 1807 0
 1142 0028 96F82F30 	 ldrb r3,[r6,#47]
 1143 002c 43F01003 	 orr r3,r3,#16
 1144 0030 86F82F30 	 strb r3,[r6,#47]
1809:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 1145              	 .loc 1 1809 0
 1146 0034 A36F     	 ldr r3,[r4,#120]
 1147 0036 002B     	 cmp r3,#0
 1148 0038 00F0DF80 	 beq .L105
1815:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 1149              	 .loc 1 1815 0
 1150 003c B4F84A30 	 ldrh r3,[r4,#74]
 1151 0040 012B     	 cmp r3,#1
 1152 0042 44D9     	 bls .L106
1817:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 1153              	 .loc 1 1817 0
 1154 0044 D4F8CC10 	 ldr r1,[r4,#204]
 1155              	.LVL131:
 1156 0048 05AA     	 add r2,sp,#20
 1157              	.LVL132:
 1158 004a FFF7FEFF 	 bl ulTCPWindowTxGet
 1159              	.LVL133:
 1160 004e 8246     	 mov r10,r0
 1161 0050 0746     	 mov r7,r0
 1162              	.LVL134:
1820:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 1163              	 .loc 1 1820 0
 1164 0052 0028     	 cmp r0,#0
 1165 0054 40F3D380 	 ble .L78
1824:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1166              	 .loc 1 1824 0
 1167 0058 DBF80060 	 ldr r6,[fp]
 1168              	.LVL135:
 1169              	.LBB173:
 1170              	.LBB174:
1694:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 1171              	 .loc 1 1694 0
 1172 005c 9A4B     	 ldr r3,.L113
 1173 005e 1B68     	 ldr r3,[r3]
 1174 0060 0BB1     	 cbz r3,.L79
 1175              	.LVL136:
1733:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 1176              	 .loc 1 1733 0
 1177 0062 7EB9     	 cbnz r6,.L81
 1178 0064 FDE0     	 b .L107
 1179              	.LVL137:
 1180              	.L79:
 1181 0066 08F13609 	 add r9,r8,#54
1714:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1182              	 .loc 1 1714 0
 1183 006a 8144     	 add r9,r9,r0
 1184              	.LVL138:
1718:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 1185              	 .loc 1 1718 0
 1186 006c B9F1450F 	 cmp r9,#69
 1187 0070 98BF     	 it ls
 1188 0072 4FF04609 	 movls r9,#70
 1189              	.LVL139:
1723:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 1190              	 .loc 1 1723 0
 1191 0076 002E     	 cmp r6,#0
 1192 0078 00F0F580 	 beq .L80
 1193              	.LVL140:
1733:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 1194              	 .loc 1 1733 0
 1195 007c F369     	 ldr r3,[r6,#28]
 1196 007e 4B45     	 cmp r3,r9
 1197 0080 C0F0DE80 	 bcc .L83
 1198              	.LVL141:
 1199              	.L81:
 1200 0084 08F13603 	 add r3,r8,#54
1769:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 1201              	 .loc 1 1769 0
 1202 0088 5344     	 add r3,r3,r10
 1203 008a F361     	 str r3,[r6,#28]
 1204 008c 91E0     	 b .L84
 1205              	.LVL142:
 1206              	.L110:
 1207              	.LBE174:
 1208              	.LBE173:
1859:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1209              	 .loc 1 1859 0
 1210 008e A26F     	 ldr r2,[r4,#120]
 1211 0090 9368     	 ldr r3,[r2,#8]
 1212              	.LVL143:
 1213              	.LBB176:
 1214              	.LBB177:
  84:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	if ( uxCount >= pxBuffer->LENGTH )
 1215              	 .loc 2 84 0
 1216 0092 1269     	 ldr r2,[r2,#16]
 1217              	.LVL144:
 1218 0094 1344     	 add r3,r3,r2
 1219              	.LVL145:
 1220 0096 0599     	 ldr r1,[sp,#20]
 1221 0098 5B1A     	 subs r3,r3,r1
 1222              	.LVL146:
  85:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	{
 1223              	 .loc 2 85 0
 1224 009a 9A42     	 cmp r2,r3
  87:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	}
 1225              	 .loc 2 87 0
 1226 009c 98BF     	 it ls
 1227 009e 9B1A     	 subls r3,r3,r2
 1228              	.LVL147:
 1229              	.LBE177:
 1230              	.LBE176:
1861:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					{
 1231              	 .loc 1 1861 0
 1232 00a0 9842     	 cmp r0,r3
 1233 00a2 15D1     	 bne .L77
1879:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						pxTCPWindow->tx.ulFINSequenceNumber = pxTCPWindow->ulOurSequenceNumber + ( uint32_t ) lDataLe
 1234              	 .loc 1 1879 0
 1235 00a4 96F82F30 	 ldrb r3,[r6,#47]
 1236              	.LVL148:
 1237 00a8 43F00103 	 orr r3,r3,#1
 1238 00ac 86F82F30 	 strb r3,[r6,#47]
 1239              	.LVL149:
1880:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						pxSocket->u.xTCP.bits.bFinSent = pdTRUE_UNSIGNED;
 1240              	 .loc 1 1880 0
 1241 00b0 D4F80431 	 ldr r3,[r4,#260]
 1242 00b4 5344     	 add r3,r3,r10
 1243 00b6 C4F8FC30 	 str r3,[r4,#252]
1881:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					}
 1244              	 .loc 1 1881 0
 1245 00ba 94F84130 	 ldrb r3,[r4,#65]
 1246 00be 43F04003 	 orr r3,r3,#64
 1247 00c2 84F84130 	 strb r3,[r4,#65]
 1248              	.LVL150:
 1249 00c6 03E0     	 b .L77
 1250              	.LVL151:
 1251              	.L101:
 1252              	.LBB178:
 1253 00c8 4FF0FF37 	 mov r7,#-1
 1254              	.LVL152:
 1255 00cc 57E0     	 b .L86
 1256              	.LVL153:
 1257              	.L106:
 1258              	.LBE178:
1805:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	lStreamPos = 0;
 1259              	 .loc 1 1805 0
 1260 00ce 0027     	 movs r7,#0
 1261              	.LVL154:
 1262              	.L77:
1892:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 1263              	 .loc 1 1892 0 discriminator 1
 1264 00d0 94F85330 	 ldrb r3,[r4,#83]
 1265 00d4 052B     	 cmp r3,#5
 1266 00d6 52D1     	 bne .L86
 1267              	.LVL155:
 1268              	.L103:
1895:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( xTCPWindowTxDone( pxTCPWindow ) != pdFALSE ) )
 1269              	 .loc 1 1895 0
 1270 00d8 94F84030 	 ldrb r3,[r4,#64]
 1271 00dc 13F0200F 	 tst r3,#32
 1272 00e0 1BD0     	 beq .L87
1896:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 1273              	 .loc 1 1896 0 discriminator 1
 1274 00e2 0398     	 ldr r0,[sp,#12]
 1275 00e4 FFF7FEFF 	 bl xTCPWindowTxDone
 1276              	.LVL156:
1895:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( xTCPWindowTxDone( pxTCPWindow ) != pdFALSE ) )
 1277              	 .loc 1 1895 0 discriminator 1
 1278 00e8 B8B1     	 cbz r0,.L87
1898:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxProtocolHeaders->xTCPHeader.ucTCPFlags |= tcpTCP_FLAG_FIN;
 1279              	 .loc 1 1898 0
 1280 00ea 94F84030 	 ldrb r3,[r4,#64]
 1281 00ee 6FF34513 	 bfc r3,#5,#1
 1282 00f2 84F84030 	 strb r3,[r4,#64]
1899:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxSocket->u.xTCP.bits.bFinSent = pdTRUE_UNSIGNED;
 1283              	 .loc 1 1899 0
 1284 00f6 6B7B     	 ldrb r3,[r5,#13]
 1285 00f8 43F00103 	 orr r3,r3,#1
 1286 00fc 6B73     	 strb r3,[r5,#13]
1900:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxSocket->u.xTCP.bits.bWinChange = pdTRUE_UNSIGNED;
 1287              	 .loc 1 1900 0
 1288 00fe 94F84130 	 ldrb r3,[r4,#65]
1901:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxTCPWindow->tx.ulFINSequenceNumber = pxTCPWindow->tx.ulCurrentSequenceNumber;
 1289              	 .loc 1 1901 0
 1290 0102 43F04103 	 orr r3,r3,#65
 1291 0106 84F84130 	 strb r3,[r4,#65]
1902:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			vTCPStateChange( pxSocket, eFIN_WAIT_1 );
 1292              	 .loc 1 1902 0
 1293 010a D4F8F830 	 ldr r3,[r4,#248]
 1294 010e C4F8FC30 	 str r3,[r4,#252]
1903:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 1295              	 .loc 1 1903 0
 1296 0112 2046     	 mov r0,r4
 1297 0114 0621     	 movs r1,#6
 1298 0116 FFF7FEFF 	 bl vTCPStateChange
 1299              	.LVL157:
 1300              	.L87:
1908:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 1301              	 .loc 1 1908 0
 1302 011a 94F85830 	 ldrb r3,[r4,#88]
 1303 011e 032B     	 cmp r3,#3
 1304 0120 06D9     	 bls .L88
1913:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				lDataLen = -1;
 1305              	 .loc 1 1913 0
 1306 0122 2046     	 mov r0,r4
 1307 0124 0821     	 movs r1,#8
 1308 0126 FFF7FEFF 	 bl vTCPStateChange
 1309              	.LVL158:
1914:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 1310              	 .loc 1 1914 0
 1311 012a 4FF0FF37 	 mov r7,#-1
 1312 012e 28E0     	 b .L89
 1313              	.LVL159:
 1314              	.L88:
1916:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 1315              	 .loc 1 1916 0
 1316 0130 2FBB     	 cbnz r7,.L86
1916:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 1317              	 .loc 1 1916 0 is_stmt 0 discriminator 1
 1318 0132 94F84130 	 ldrb r3,[r4,#65]
 1319 0136 13F0010F 	 tst r3,#1
 1320 013a 63D1     	 bne .L90
 1321              	.LBB179:
1920:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				TickType_t xMax;
 1322              	 .loc 1 1920 0 is_stmt 1
 1323 013c FFF7FEFF 	 bl xTaskGetTickCount
 1324              	.LVL160:
 1325 0140 E36D     	 ldr r3,[r4,#92]
 1326 0142 C31A     	 subs r3,r0,r3
 1327              	.LVL161:
1923:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
 1328              	 .loc 1 1923 0
 1329 0144 94F85800 	 ldrb r0,[r4,#88]
1925:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
 1330              	 .loc 1 1925 0
 1331 0148 40F6B832 	 movw r2,#3000
 1332 014c 5F49     	 ldr r1,.L113+4
 1333 014e 0028     	 cmp r0,#0
 1334 0150 08BF     	 it eq
 1335 0152 0A46     	 moveq r2,r1
 1336              	.LVL162:
1927:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
 1337              	 .loc 1 1927 0
 1338 0154 9A42     	 cmp r2,r3
 1339 0156 55D2     	 bcs .L90
1929:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					if( xTCPWindowLoggingLevel != 0 )
 1340              	 .loc 1 1929 0
 1341 0158 FFF7FEFF 	 bl xTaskGetTickCount
 1342              	.LVL163:
 1343 015c E065     	 str r0,[r4,#92]
1937:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					pxSocket->u.xTCP.usTimeout = ( ( uint16_t ) pdMS_TO_TICKS( 2500U ) );
 1344              	 .loc 1 1937 0
 1345 015e 94F84130 	 ldrb r3,[r4,#65]
 1346 0162 43F00203 	 orr r3,r3,#2
 1347 0166 84F84130 	 strb r3,[r4,#65]
1938:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					pxSocket->u.xTCP.ucKeepRepCount++;
 1348              	 .loc 1 1938 0
 1349 016a 40F6C413 	 movw r3,#2500
 1350 016e A4F84830 	 strh r3,[r4,#72]
1939:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
 1351              	 .loc 1 1939 0
 1352 0172 94F85830 	 ldrb r3,[r4,#88]
 1353 0176 0133     	 adds r3,r3,#1
 1354 0178 84F85830 	 strb r3,[r4,#88]
 1355 017c 42E0     	 b .L90
 1356              	.LVL164:
 1357              	.L86:
 1358              	.LBE179:
1948:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		( pxSocket->u.xTCP.bits.bWinChange != pdFALSE_UNSIGNED ) ||
 1359              	 .loc 1 1948 0
 1360 017e 002F     	 cmp r7,#0
 1361 0180 46DC     	 bgt .L92
 1362              	.LVL165:
 1363              	.L89:
1949:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		( pxSocket->u.xTCP.bits.bSendKeepAlive != pdFALSE_UNSIGNED ) )
 1364              	 .loc 1 1949 0
 1365 0182 94F84130 	 ldrb r3,[r4,#65]
 1366 0186 13F0030F 	 tst r3,#3
 1367 018a 00F09880 	 beq .L109
1952:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxProtocolHeaders->xTCPHeader.ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength
 1368              	 .loc 1 1952 0
 1369 018e 6B7B     	 ldrb r3,[r5,#13]
 1370 0190 03F0F703 	 and r3,r3,#247
1953:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1371              	 .loc 1 1953 0
 1372 0194 08F11402 	 add r2,r8,#20
 1373 0198 9200     	 lsls r2,r2,#2
 1374 019a 2A73     	 strb r2,[r5,#12]
1955:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1375              	 .loc 1 1955 0
 1376 019c 43F01002 	 orr r2,r3,#16
 1377 01a0 6A73     	 strb r2,[r5,#13]
1957:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 1378              	 .loc 1 1957 0
 1379 01a2 17B1     	 cbz r7,.L94
 1380              	.LVL166:
 1381              	.L99:
1959:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 1382              	 .loc 1 1959 0
 1383 01a4 43F01803 	 orr r3,r3,#24
 1384 01a8 6B73     	 strb r3,[r5,#13]
 1385              	.L94:
 1386              	.LVL167:
1962:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		lDataLen += ( int32_t ) uxIntermediateResult;
 1387              	 .loc 1 1962 0
 1388 01aa 08F12808 	 add r8,r8,#40
 1389              	.LVL168:
1963:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 1390              	 .loc 1 1963 0
 1391 01ae 4744     	 add r7,r7,r8
 1392              	.LVL169:
 1393 01b0 85E0     	 b .L109
 1394              	.LVL170:
 1395              	.L84:
1828:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pucEthernetBuffer = pxNewBuffer->pucEthernetBuffer;
 1396              	 .loc 1 1828 0
 1397 01b2 CBF80060 	 str r6,[fp]
1829:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1398              	 .loc 1 1829 0
 1399 01b6 B669     	 ldr r6,[r6,#24]
 1400              	.LVL171:
1833:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1401              	 .loc 1 1833 0
 1402 01b8 06F12205 	 add r5,r6,#34
 1403              	.LVL172:
1835:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1404              	 .loc 1 1835 0
 1405 01bc 08F1360E 	 add lr,r8,#54
1839:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1406              	 .loc 1 1839 0
 1407 01c0 A06F     	 ldr r0,[r4,#120]
 1408 01c2 0168     	 ldr r1,[r0]
 1409              	.LVL173:
 1410              	.LBB180:
 1411              	.LBB181:
  84:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	if ( uxCount >= pxBuffer->LENGTH )
 1412              	 .loc 2 84 0
 1413 01c4 0269     	 ldr r2,[r0,#16]
 1414 01c6 059B     	 ldr r3,[sp,#20]
 1415 01c8 5B1A     	 subs r3,r3,r1
 1416              	.LVL174:
 1417 01ca 9A18     	 adds r2,r3,r2
 1418              	.LVL175:
 1419              	.LBE181:
 1420              	.LBE180:
1843:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1421              	 .loc 1 1843 0
 1422 01cc 4FF00101 	 mov r1,#1
 1423              	.LVL176:
 1424 01d0 0091     	 str r1,[sp]
 1425              	.LVL177:
 1426 01d2 34BF     	 ite cc
 1427 01d4 1946     	 movcc r1,r3
 1428 01d6 1146     	 movcs r1,r2
 1429 01d8 7246     	 mov r2,lr
 1430              	.LVL178:
 1431 01da 3244     	 add r2,r2,r6
 1432 01dc 5346     	 mov r3,r10
 1433 01de FFF7FEFF 	 bl uxStreamBufferGet
 1434              	.LVL179:
1857:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
 1435              	 .loc 1 1857 0
 1436 01e2 B4F84030 	 ldrh r3,[r4,#64]
 1437 01e6 23F47E53 	 bic r3,r3,#16256
 1438 01ea 23F03F03 	 bic r3,r3,#63
 1439 01ee 5B04     	 lsls r3,r3,#17
 1440 01f0 5B0C     	 lsrs r3,r3,#17
 1441 01f2 402B     	 cmp r3,#64
 1442 01f4 7FF46CAF 	 bne .L77
 1443 01f8 49E7     	 b .L110
 1444              	.LVL180:
 1445              	.L105:
1805:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	lStreamPos = 0;
 1446              	 .loc 1 1805 0
 1447 01fa 0027     	 movs r7,#0
 1448              	.LVL181:
 1449 01fc 68E7     	 b .L77
 1450              	.LVL182:
 1451              	.L78:
1892:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 1452              	 .loc 1 1892 0
 1453 01fe 0028     	 cmp r0,#0
 1454 0200 4CDB     	 blt .L111
 1455 0202 38E0     	 b .L96
 1456              	.LVL183:
 1457              	.L90:
1949:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		( pxSocket->u.xTCP.bits.bSendKeepAlive != pdFALSE_UNSIGNED ) )
 1458              	 .loc 1 1949 0
 1459 0204 94F84130 	 ldrb r3,[r4,#65]
 1460 0208 13F0030F 	 tst r3,#3
 1461 020c 4CD1     	 bne .L98
 1462 020e 56E0     	 b .L109
 1463              	.LVL184:
 1464              	.L92:
1952:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxProtocolHeaders->xTCPHeader.ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength
 1465              	 .loc 1 1952 0
 1466 0210 6B7B     	 ldrb r3,[r5,#13]
 1467 0212 03F0F703 	 and r3,r3,#247
1953:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1468              	 .loc 1 1953 0
 1469 0216 08F11402 	 add r2,r8,#20
 1470 021a 9200     	 lsls r2,r2,#2
 1471 021c 2A73     	 strb r2,[r5,#12]
1955:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1472              	 .loc 1 1955 0
 1473 021e 43F01002 	 orr r2,r3,#16
 1474 0222 6A73     	 strb r2,[r5,#13]
 1475 0224 BEE7     	 b .L99
 1476              	.LVL185:
 1477              	.L100:
 1478              	.LBB182:
 1479              	.LBB175:
1743:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1480              	 .loc 1 1743 0
 1481 0226 1D46     	 mov r5,r3
 1482              	.LVL186:
 1483 0228 C3F81C90 	 str r9,[r3,#28]
1749:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1484              	 .loc 1 1749 0
 1485 022c 9869     	 ldr r0,[r3,#24]
 1486              	.LVL187:
 1487 022e B169     	 ldr r1,[r6,#24]
 1488 0230 F269     	 ldr r2,[r6,#28]
 1489 0232 FFF7FEFF 	 bl memcpy
 1490              	.LVL188:
1752:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 1491              	 .loc 1 1752 0
 1492 0236 3046     	 mov r0,r6
 1493 0238 FFF7FEFF 	 bl vReleaseNetworkBufferAndDescriptor
 1494              	.LVL189:
1738:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1495              	 .loc 1 1738 0
 1496 023c 2E46     	 mov r6,r5
 1497              	.LVL190:
 1498 023e B8E7     	 b .L84
 1499              	.LVL191:
 1500              	.L83:
 1501 0240 4846     	 mov r0,r9
 1502              	.LVL192:
 1503 0242 0021     	 movs r1,#0
 1504 0244 FFF7FEFF 	 bl pxGetNetworkBufferWithDescriptor
 1505              	.LVL193:
1740:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 1506              	 .loc 1 1740 0
 1507 0248 0346     	 mov r3,r0
 1508 024a 0028     	 cmp r0,#0
 1509 024c EBD1     	 bne .L100
 1510 024e 3BE7     	 b .L101
 1511              	.LVL194:
 1512              	.L102:
1743:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1513              	 .loc 1 1743 0
 1514 0250 C6F81C90 	 str r9,[r6,#28]
1757:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 1515              	 .loc 1 1757 0
 1516 0254 B069     	 ldr r0,[r6,#24]
 1517              	.LVL195:
 1518 0256 04F18201 	 add r1,r4,#130
 1519 025a 4622     	 movs r2,#70
 1520 025c FFF7FEFF 	 bl memcpy
 1521              	.LVL196:
 1522 0260 A7E7     	 b .L84
 1523              	.LVL197:
 1524              	.L107:
1698:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* and therefore, the buffer won't be too small.
 1525              	 .loc 1 1698 0
 1526 0262 40F2C649 	 movw r9,#1222
 1527              	.LVL198:
 1528              	.L80:
1738:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1529              	 .loc 1 1738 0
 1530 0266 4846     	 mov r0,r9
 1531              	.LVL199:
 1532 0268 0021     	 movs r1,#0
 1533 026a FFF7FEFF 	 bl pxGetNetworkBufferWithDescriptor
 1534              	.LVL200:
1740:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 1535              	 .loc 1 1740 0
 1536 026e 0646     	 mov r6,r0
 1537              	.LVL201:
 1538 0270 0028     	 cmp r0,#0
 1539 0272 EDD1     	 bne .L102
 1540 0274 28E7     	 b .L101
 1541              	.LVL202:
 1542              	.L96:
 1543              	.LBE175:
 1544              	.LBE182:
1892:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 1545              	 .loc 1 1892 0
 1546 0276 94F85330 	 ldrb r3,[r4,#83]
 1547 027a 052B     	 cmp r3,#5
 1548 027c 81D1     	 bne .L89
 1549 027e 2BE7     	 b .L103
 1550              	.L104:
1952:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxProtocolHeaders->xTCPHeader.ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength
 1551              	 .loc 1 1952 0
 1552 0280 96F82F30 	 ldrb r3,[r6,#47]
 1553 0284 03F0F703 	 and r3,r3,#247
1953:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1554              	 .loc 1 1953 0
 1555 0288 08F11402 	 add r2,r8,#20
 1556 028c 9200     	 lsls r2,r2,#2
 1557 028e 86F82E20 	 strb r2,[r6,#46]
1955:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1558              	 .loc 1 1955 0
 1559 0292 43F01002 	 orr r2,r3,#16
 1560 0296 86F82F20 	 strb r2,[r6,#47]
 1561 029a 83E7     	 b .L99
 1562              	.L111:
1949:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		( pxSocket->u.xTCP.bits.bSendKeepAlive != pdFALSE_UNSIGNED ) )
 1563              	 .loc 1 1949 0
 1564 029c 94F84130 	 ldrb r3,[r4,#65]
 1565 02a0 13F0030F 	 tst r3,#3
 1566 02a4 ECD1     	 bne .L104
 1567 02a6 0AE0     	 b .L109
 1568              	.LVL203:
 1569              	.L98:
1952:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxProtocolHeaders->xTCPHeader.ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength
 1570              	 .loc 1 1952 0
 1571 02a8 6B7B     	 ldrb r3,[r5,#13]
 1572 02aa 03F0F703 	 and r3,r3,#247
1953:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1573              	 .loc 1 1953 0
 1574 02ae 08F11402 	 add r2,r8,#20
 1575 02b2 9200     	 lsls r2,r2,#2
 1576 02b4 2A73     	 strb r2,[r5,#12]
1955:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1577              	 .loc 1 1955 0
 1578 02b6 43F01003 	 orr r3,r3,#16
 1579 02ba 6B73     	 strb r3,[r5,#13]
 1580 02bc 75E7     	 b .L94
 1581              	.LVL204:
 1582              	.L109:
1967:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
 1583              	 .loc 1 1967 0
 1584 02be 3846     	 mov r0,r7
 1585 02c0 07B0     	 add sp,sp,#28
 1586              	.LCFI14:
 1587              	 .cfi_def_cfa_offset 36
 1588              	 
 1589 02c2 BDE8F08F 	 pop {r4,r5,r6,r7,r8,r9,r10,fp,pc}
 1590              	.LVL205:
 1591              	.L114:
 1592 02c6 00BF     	 .align 2
 1593              	.L113:
 1594 02c8 00000000 	 .word xBufferAllocFixedSize
 1595 02cc C0D40100 	 .word 120000
 1596              	 .cfi_endproc
 1597              	.LFE66:
 1599              	 .section .text.prvTCPSendRepeated,"ax",%progbits
 1600              	 .align 2
 1601              	 .thumb
 1602              	 .thumb_func
 1604              	prvTCPSendRepeated:
 1605              	.LFB54:
 663:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** UBaseType_t uxIndex;
 1606              	 .loc 1 663 0
 1607              	 .cfi_startproc
 1608              	 
 1609              	 
 1610              	.LVL206:
 1611 0000 2DE9F843 	 push {r3,r4,r5,r6,r7,r8,r9,lr}
 1612              	.LCFI15:
 1613              	 .cfi_def_cfa_offset 32
 1614              	 .cfi_offset 3,-32
 1615              	 .cfi_offset 4,-28
 1616              	 .cfi_offset 5,-24
 1617              	 .cfi_offset 6,-20
 1618              	 .cfi_offset 7,-16
 1619              	 .cfi_offset 8,-12
 1620              	 .cfi_offset 9,-8
 1621              	 .cfi_offset 14,-4
 1622 0004 8146     	 mov r9,r0
 1623 0006 8846     	 mov r8,r1
 1624              	.LVL207:
 663:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** UBaseType_t uxIndex;
 1625              	 .loc 1 663 0
 1626 0008 0824     	 movs r4,#8
 665:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** UBaseType_t uxOptionsLength = 0U;
 1627              	 .loc 1 665 0
 1628 000a 0026     	 movs r6,#0
 673:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( xSendLength <= 0 )
 1629              	 .loc 1 673 0
 1630 000c 3746     	 mov r7,r6
 1631              	.LVL208:
 1632              	.L117:
 1633 000e 4846     	 mov r0,r9
 1634 0010 4146     	 mov r1,r8
 1635 0012 3A46     	 mov r2,r7
 1636 0014 FFF7FEFF 	 bl prvTCPPrepareSend
 1637              	.LVL209:
 674:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 1638              	 .loc 1 674 0
 1639 0018 051E     	 subs r5,r0,#0
 1640 001a 09DD     	 ble .L116
 680:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1641              	 .loc 1 680 0 discriminator 2
 1642 001c 4846     	 mov r0,r9
 1643              	.LVL210:
 1644 001e D8F80010 	 ldr r1,[r8]
 1645 0022 2A46     	 mov r2,r5
 1646 0024 3B46     	 mov r3,r7
 1647 0026 FFF7FEFF 	 bl prvTCPReturnPacket
 1648              	.LVL211:
 688:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 1649              	 .loc 1 688 0 discriminator 2
 1650 002a 2E44     	 add r6,r6,r5
 1651              	.LVL212:
 669:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 1652              	 .loc 1 669 0 discriminator 2
 1653 002c 013C     	 subs r4,r4,#1
 1654              	.LVL213:
 1655 002e EED1     	 bne .L117
 1656              	.LVL214:
 1657              	.L116:
 693:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
 1658              	 .loc 1 693 0
 1659 0030 3046     	 mov r0,r6
 1660 0032 BDE8F883 	 pop {r3,r4,r5,r6,r7,r8,r9,pc}
 1661              	 .cfi_endproc
 1662              	.LFE54:
 1664 0036 00BF     	 .section .text.xTCPSocketCheck,"ax",%progbits
 1665              	 .align 2
 1666              	 .global xTCPSocketCheck
 1667              	 .thumb
 1668              	 .thumb_func
 1670              	xTCPSocketCheck:
 1671              	.LFB52:
 486:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** BaseType_t xResult = 0;
 1672              	 .loc 1 486 0
 1673              	 .cfi_startproc
 1674              	 
 1675              	 
 1676              	.LVL215:
 1677 0000 70B5     	 push {r4,r5,r6,lr}
 1678              	.LCFI16:
 1679              	 .cfi_def_cfa_offset 16
 1680              	 .cfi_offset 4,-16
 1681              	 .cfi_offset 5,-12
 1682              	 .cfi_offset 6,-8
 1683              	 .cfi_offset 14,-4
 1684 0002 84B0     	 sub sp,sp,#16
 1685              	.LCFI17:
 1686              	 .cfi_def_cfa_offset 32
 1687 0004 0446     	 mov r4,r0
 1688              	.LVL216:
 490:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 1689              	 .loc 1 490 0
 1690 0006 90F85330 	 ldrb r3,[r0,#83]
 1691 000a 042B     	 cmp r3,#4
 1692 000c 40F26081 	 bls .L121
 490:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 1693              	 .loc 1 490 0 is_stmt 0 discriminator 1
 1694 0010 836F     	 ldr r3,[r0,#120]
 1695 0012 002B     	 cmp r3,#0
 1696 0014 00F05481 	 beq .L122
 494:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 1697              	 .loc 1 494 0 is_stmt 1
 1698 0018 FFF7FEFF 	 bl prvTCPAddTxData
 1699              	.LVL217:
 499:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 1700              	 .loc 1 499 0
 1701 001c E16F     	 ldr r1,[r4,#124]
 1702 001e F9B1     	 cbz r1,.L123
 1703              	.L142:
 503:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 1704              	 .loc 1 503 0
 1705 0020 94F84030 	 ldrb r3,[r4,#64]
 1706 0024 13F0200F 	 tst r3,#32
 1707 0028 11D1     	 bne .L146
 508:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
 1708              	 .loc 1 508 0
 1709 002a 94F85330 	 ldrb r3,[r4,#83]
 1710 002e 23B1     	 cbz r3,.L125
 520:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1711              	 .loc 1 520 0
 1712 0030 2046     	 mov r0,r4
 1713 0032 2822     	 movs r2,#40
 1714 0034 0023     	 movs r3,#0
 1715 0036 FFF7FEFF 	 bl prvTCPReturnPacket
 1716              	.LVL218:
 1717              	.L125:
 530:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
 1718              	 .loc 1 530 0
 1719 003a 2046     	 mov r0,r4
 1720 003c FFF7FEFF 	 bl prvTCPNextTimeout
 1721              	.LVL219:
 1722 0040 0128     	 cmp r0,#1
 1723 0042 94BF     	 ite ls
 1724 0044 0025     	 movls r5,#0
 1725 0046 0125     	 movhi r5,#1
 1726              	.LVL220:
 543:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 1727              	 .loc 1 543 0
 1728 0048 E16F     	 ldr r1,[r4,#124]
 1729 004a 31B1     	 cbz r1,.L126
 1730 004c 00E0     	 b .L124
 1731              	.LVL221:
 1732              	.L146:
 488:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1733              	 .loc 1 488 0
 1734 004e 0025     	 movs r5,#0
 1735              	.LVL222:
 1736              	.L124:
 545:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxSocket->u.xTCP.pxAckMessage = NULL;
 1737              	 .loc 1 545 0
 1738 0050 0846     	 mov r0,r1
 1739 0052 FFF7FEFF 	 bl vReleaseNetworkBufferAndDescriptor
 1740              	.LVL223:
 546:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 1741              	 .loc 1 546 0
 1742 0056 0023     	 movs r3,#0
 1743 0058 E367     	 str r3,[r4,#124]
 1744              	.L126:
 552:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 1745              	 .loc 1 552 0
 1746 005a 002D     	 cmp r5,#0
 1747 005c 40F0FE80 	 bne .L147
 1748              	.LVL224:
 1749              	.L123:
 555:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eCONNECT_SYN ) )
 1750              	 .loc 1 555 0
 1751 0060 94F85330 	 ldrb r3,[r4,#83]
 1752 0064 042B     	 cmp r3,#4
 1753 0066 03D8     	 bhi .L128
 1754              	.L144:
 555:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eCONNECT_SYN ) )
 1755              	 .loc 1 555 0 is_stmt 0 discriminator 1
 1756 0068 022B     	 cmp r3,#2
 1757 006a 40F00081 	 bne .L130
 1758 006e 0FE0     	 b .L129
 1759              	.L128:
 1760              	.LVL225:
 1761              	.LBB198:
 1762              	.LBB199:
 587:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 1763              	 .loc 1 587 0 is_stmt 1
 1764 0070 022B     	 cmp r3,#2
 1765 0072 0DD0     	 beq .L129
 590:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1766              	 .loc 1 590 0
 1767 0074 04A9     	 add r1,sp,#16
 1768 0076 0023     	 movs r3,#0
 1769 0078 41F8083D 	 str r3,[r1,#-8]!
 594:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1770              	 .loc 1 594 0
 1771 007c 2046     	 mov r0,r4
 1772 007e FFF7FEFF 	 bl prvTCPSendRepeated
 1773              	.LVL226:
 596:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 1774              	 .loc 1 596 0
 1775 0082 0298     	 ldr r0,[sp,#8]
 1776 0084 0028     	 cmp r0,#0
 1777 0086 00F0F280 	 beq .L130
 598:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 1778              	 .loc 1 598 0
 1779 008a FFF7FEFF 	 bl vReleaseNetworkBufferAndDescriptor
 1780              	.LVL227:
 1781 008e EEE0     	 b .L130
 1782              	.LVL228:
 1783              	.L129:
 603:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 1784              	 .loc 1 603 0
 1785 0090 94F85230 	 ldrb r3,[r4,#82]
 1786 0094 022B     	 cmp r3,#2
 1787 0096 04D9     	 bls .L132
 611:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 1788              	 .loc 1 611 0
 1789 0098 2046     	 mov r0,r4
 1790 009a 0821     	 movs r1,#8
 1791 009c FFF7FEFF 	 bl vTCPStateChange
 1792              	.LVL229:
 1793 00a0 E5E0     	 b .L130
 1794              	.L132:
 613:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 1795              	 .loc 1 613 0
 1796 00a2 94F84130 	 ldrb r3,[r4,#65]
 1797 00a6 13F0080F 	 tst r3,#8
 1798 00aa 40F08380 	 bne .L133
 1799              	.LVL230:
 1800              	.LBB200:
 1801              	.LBB201:
1001:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1802              	 .loc 1 1001 0
 1803 00ae A16B     	 ldr r1,[r4,#56]
 1804 00b0 0A06     	 lsls r2,r1,#24
 1805 00b2 42EA1162 	 orr r2,r2,r1,lsr#24
 1806 00b6 01F47F43 	 and r3,r1,#65280
 1807 00ba 42EA0322 	 orr r2,r2,r3,lsl#8
 1808 00be 01F47F03 	 and r3,r1,#16711680
 1809 00c2 42EA1323 	 orr r3,r2,r3,lsr#8
 1810 00c6 04A8     	 add r0,sp,#16
 1811 00c8 40F80C3D 	 str r3,[r0,#-12]!
1004:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1812              	 .loc 1 1004 0
 1813 00cc 02A9     	 add r1,sp,#8
 1814 00ce FFF7FEFF 	 bl eARPGetCacheEntry
 1815              	.LVL231:
1006:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 1816              	 .loc 1 1006 0
 1817 00d2 0128     	 cmp r0,#1
 1818 00d4 08D0     	 beq .L135
1014:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1819              	 .loc 1 1014 0
 1820 00d6 94F85230 	 ldrb r3,[r4,#82]
 1821 00da 0133     	 adds r3,r3,#1
 1822 00dc 84F85230 	 strb r3,[r4,#82]
1028:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		xReturn = pdFALSE;
 1823              	 .loc 1 1028 0
 1824 00e0 0198     	 ldr r0,[sp,#4]
 1825              	.LVL232:
 1826 00e2 FFF7FEFF 	 bl FreeRTOS_OutputARPRequest
 1827              	.LVL233:
 1828 00e6 C2E0     	 b .L130
 1829              	.LVL234:
 1830              	.L135:
1036:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 																	  pxSocket->usLocalPort,
 1831              	 .loc 1 1036 0
 1832 00e8 7D4B     	 ldr r3,.L157
 1833 00ea 5869     	 ldr r0,[r3,#20]
 1834              	.LVL235:
 1835 00ec A18C     	 ldrh r1,[r4,#36]
 1836 00ee A26B     	 ldr r2,[r4,#56]
 1837 00f0 A38F     	 ldrh r3,[r4,#60]
 1838 00f2 FFF7FEFF 	 bl ulApplicationGetNextSequenceNumber
 1839              	.LVL236:
1042:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 1840              	 .loc 1 1042 0
 1841 00f6 0646     	 mov r6,r0
 1842 00f8 0028     	 cmp r0,#0
 1843 00fa 00F0B880 	 beq .L130
 1844              	.LVL237:
 1845              	.LBB202:
1059:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1846              	 .loc 1 1059 0
 1847 00fe 0025     	 movs r5,#0
 1848 0100 84F85250 	 strb r5,[r4,#82]
1062:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1849              	 .loc 1 1062 0
 1850 0104 94F84130 	 ldrb r3,[r4,#65]
 1851 0108 43F00803 	 orr r3,r3,#8
 1852 010c 84F84130 	 strb r3,[r4,#65]
1066:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1853              	 .loc 1 1066 0
 1854 0110 04F18200 	 add r0,r4,#130
 1855              	.LVL238:
 1856 0114 2946     	 mov r1,r5
 1857 0116 4622     	 movs r2,#70
 1858 0118 FFF7FEFF 	 bl memset
 1859              	.LVL239:
1070:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1860              	 .loc 1 1070 0
 1861 011c 04AB     	 add r3,sp,#16
 1862 011e 53F8080D 	 ldr r0,[r3,#-8]!
 1863 0122 C4F88800 	 str r0,[r4,#136]
 1864 0126 9B88     	 ldrh r3,[r3,#4]
 1865 0128 A4F88C30 	 strh r3,[r4,#140]
1073:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1866              	 .loc 1 1073 0
 1867 012c 0823     	 movs r3,#8
 1868 012e 84F88E30 	 strb r3,[r4,#142]
 1869 0132 84F88F50 	 strb r5,[r4,#143]
1075:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		usLength = ( uint16_t ) ( sizeof( TCPPacket_t ) - sizeof( pxTCPPacket->xEthernetHeader ) );
 1870              	 .loc 1 1075 0
 1871 0136 4523     	 movs r3,#69
 1872 0138 84F89030 	 strb r3,[r4,#144]
 1873              	.LVL240:
1077:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxIPHeader->ucTimeToLive = ( uint8_t ) ipconfigTCP_TIME_TO_LIVE;
 1874              	 .loc 1 1077 0
 1875 013c 84F89250 	 strb r5,[r4,#146]
 1876 0140 3823     	 movs r3,#56
 1877 0142 84F89330 	 strb r3,[r4,#147]
1078:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1878              	 .loc 1 1078 0
 1879 0146 8023     	 movs r3,#128
 1880 0148 84F89830 	 strb r3,[r4,#152]
1080:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1881              	 .loc 1 1080 0
 1882 014c 0623     	 movs r3,#6
 1883 014e 84F89930 	 strb r3,[r4,#153]
1084:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxIPHeader->ulSourceIPAddress = FreeRTOS_htonl( pxSocket->u.xTCP.ulRemoteIP );
 1884              	 .loc 1 1084 0
 1885 0152 634B     	 ldr r3,.L157
 1886 0154 5B69     	 ldr r3,[r3,#20]
 1887 0156 C4F8A030 	 str r3,[r4,#160]
1085:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1888              	 .loc 1 1085 0
 1889 015a A16B     	 ldr r1,[r4,#56]
 1890 015c 0A06     	 lsls r2,r1,#24
 1891 015e 42EA1162 	 orr r2,r2,r1,lsr#24
 1892 0162 01F47F43 	 and r3,r1,#65280
 1893 0166 42EA0322 	 orr r2,r2,r3,lsl#8
 1894 016a 01F47F03 	 and r3,r1,#16711680
 1895 016e 42EA1323 	 orr r3,r2,r3,lsr#8
 1896 0172 C4F89C30 	 str r3,[r4,#156]
1087:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPPacket->xTCPHeader.usDestinationPort = FreeRTOS_htons( pxSocket->usLocalPort );
 1897              	 .loc 1 1087 0
 1898 0176 A28F     	 ldrh r2,[r4,#60]
 1899 0178 130A     	 lsrs r3,r2,#8
 1900 017a 43EA0223 	 orr r3,r3,r2,lsl#8
 1901 017e A4F8A430 	 strh r3,[r4,#164]
1088:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1902              	 .loc 1 1088 0
 1903 0182 A28C     	 ldrh r2,[r4,#36]
 1904 0184 130A     	 lsrs r3,r2,#8
 1905 0186 43EA0223 	 orr r3,r3,r2,lsl#8
 1906 018a A4F8A630 	 strh r3,[r4,#166]
1092:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1907              	 .loc 1 1092 0
 1908 018e C4F8E850 	 str r5,[r4,#232]
1095:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1909              	 .loc 1 1095 0
 1910 0192 C4F80461 	 str r6,[r4,#260]
1099:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1911              	 .loc 1 1099 0
 1912 0196 5023     	 movs r3,#80
 1913 0198 84F8B030 	 strb r3,[r4,#176]
1102:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1914              	 .loc 1 1102 0
 1915 019c 0223     	 movs r3,#2
 1916 019e 84F8B130 	 strb r3,[r4,#177]
 1917              	.LVL241:
 1918              	.LBB203:
 1919              	.LBB204:
3052:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
3053:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3054:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static void prvSocketSetMSS( FreeRTOS_Socket_t *pxSocket )
3055:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** {
3056:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint32_t ulMSS = ipconfigTCP_MSS;
3057:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3058:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( ( ( FreeRTOS_ntohl( pxSocket->u.xTCP.ulRemoteIP ) ^ *ipLOCAL_IP_ADDRESS_POINTER ) & xNetworkAd
3059:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
3060:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Data for this peer will pass through a router, and maybe through
3061:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		the internet.  Limit the MSS to 1400 bytes or less. */
3062:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		ulMSS = FreeRTOS_min_uint32( ( uint32_t ) tcpREDUCED_MSS_THROUGH_INTERNET, ulMSS );
3063:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
3064:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3065:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	FreeRTOS_debug_printf( ( "prvSocketSetMSS: %lu bytes for %lxip:%u\n", ulMSS, pxSocket->u.xTCP.ulRe
3066:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3067:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	pxSocket->u.xTCP.usInitMSS = ( uint16_t ) ulMSS;
 1920              	 .loc 1 3067 0
 1921 01a2 4FF49163 	 mov r3,#1160
 1922 01a6 A4F84C30 	 strh r3,[r4,#76]
3068:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	pxSocket->u.xTCP.usCurMSS  = ( uint16_t ) ulMSS;
 1923              	 .loc 1 3068 0
 1924 01aa A4F84A30 	 strh r3,[r4,#74]
 1925              	.LBE204:
 1926              	.LBE203:
1110:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 1927              	 .loc 1 1110 0
 1928 01ae 2046     	 mov r0,r4
 1929 01b0 FFF7FEFF 	 bl prvTCPCreateWindow
 1930              	.LVL242:
 1931              	.L133:
 1932              	.LBE202:
 1933              	.LBE201:
 1934              	.LBE200:
 1935              	.LBB205:
 1936              	.LBB206:
 1937              	.LBB207:
1442:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** UBaseType_t uxOptionsLength;
 1938              	 .loc 1 1442 0
 1939 01b4 B4F84C20 	 ldrh r2,[r4,#76]
 1940              	.LVL243:
1447:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	pxTCPHeader->ucOptdata[ 1 ] = ( uint8_t ) tcpTCP_OPT_MSS_LEN;
 1941              	 .loc 1 1447 0
 1942 01b8 0223     	 movs r3,#2
 1943 01ba 84F8B830 	 strb r3,[r4,#184]
1448:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	pxTCPHeader->ucOptdata[ 2 ] = ( uint8_t ) ( usMSS >> 8 );
 1944              	 .loc 1 1448 0
 1945 01be 0423     	 movs r3,#4
 1946 01c0 84F8B930 	 strb r3,[r4,#185]
1449:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	pxTCPHeader->ucOptdata[ 3 ] = ( uint8_t ) ( usMSS & 0xffU );
 1947              	 .loc 1 1449 0
 1948 01c4 130A     	 lsrs r3,r2,#8
 1949 01c6 84F8BA30 	 strb r3,[r4,#186]
1450:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1950              	 .loc 1 1450 0
 1951 01ca 84F8BB20 	 strb r2,[r4,#187]
 1952              	.LVL244:
 1953              	.LBB208:
 1954              	.LBB209:
1415:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		ucFactor = 0U;
 1955              	 .loc 1 1415 0
 1956 01ce D4F8D030 	 ldr r3,[r4,#208]
 1957 01d2 03FB02F2 	 mul r2,r3,r2
 1958              	.LVL245:
1417:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 1959              	 .loc 1 1417 0
 1960 01d6 B2F5803F 	 cmp r2,#65536
 1961 01da 07D3     	 bcc .L148
 1962 01dc 0023     	 movs r3,#0
 1963              	.LVL246:
 1964              	.L138:
1420:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			ucFactor++;
 1965              	 .loc 1 1420 0
 1966 01de 5208     	 lsrs r2,r2,#1
 1967              	.LVL247:
1421:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 1968              	 .loc 1 1421 0
 1969 01e0 0133     	 adds r3,r3,#1
 1970              	.LVL248:
 1971 01e2 DBB2     	 uxtb r3,r3
 1972              	.LVL249:
1417:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 1973              	 .loc 1 1417 0
 1974 01e4 B2F5803F 	 cmp r2,#65536
 1975 01e8 F9D2     	 bcs .L138
 1976 01ea 00E0     	 b .L137
 1977              	.LVL250:
 1978              	.L148:
1416:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		while( uxWinSize > 0xffffUL )
 1979              	 .loc 1 1416 0
 1980 01ec 0023     	 movs r3,#0
 1981              	.LVL251:
 1982              	.L137:
 1983              	.LBE209:
 1984              	.LBE208:
1454:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 1985              	 .loc 1 1454 0
 1986 01ee 84F8C930 	 strb r3,[r4,#201]
1456:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPHeader->ucOptdata[ 5 ] = ( uint8_t ) ( tcpTCP_OPT_WSOPT );
 1987              	 .loc 1 1456 0
 1988 01f2 0122     	 movs r2,#1
 1989              	.LVL252:
 1990 01f4 84F8BC20 	 strb r2,[r4,#188]
1457:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPHeader->ucOptdata[ 6 ] = ( uint8_t ) ( tcpTCP_OPT_WSOPT_LEN );
 1991              	 .loc 1 1457 0
 1992 01f8 0321     	 movs r1,#3
 1993 01fa 84F8BD10 	 strb r1,[r4,#189]
1458:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPHeader->ucOptdata[ 7 ] = ( uint8_t ) pxSocket->u.xTCP.ucMyWinScaleFactor;
 1994              	 .loc 1 1458 0
 1995 01fe 84F8BE10 	 strb r1,[r4,#190]
1459:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		uxOptionsLength = 8U;
 1996              	 .loc 1 1459 0
 1997 0202 84F8BF30 	 strb r3,[r4,#191]
 1998              	.LVL253:
1470:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPHeader->ucOptdata[ uxOptionsLength + 1U ] = tcpTCP_OPT_NOOP;
 1999              	 .loc 1 1470 0
 2000 0206 84F8C020 	 strb r2,[r4,#192]
1471:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPHeader->ucOptdata[ uxOptionsLength + 2U ] = tcpTCP_OPT_SACK_P;	/* 4: Sack-Permitted Option. 
 2001              	 .loc 1 1471 0
 2002 020a 84F8C120 	 strb r2,[r4,#193]
1472:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPHeader->ucOptdata[ uxOptionsLength + 3U ] = 2U;	/* 2: length of this option. */
 2003              	 .loc 1 1472 0
 2004 020e 0423     	 movs r3,#4
 2005 0210 84F8C230 	 strb r3,[r4,#194]
1473:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		uxOptionsLength += 4U;
 2006              	 .loc 1 1473 0
 2007 0214 0223     	 movs r3,#2
 2008 0216 84F8C330 	 strb r3,[r4,#195]
 2009              	.LVL254:
 2010              	.LBE207:
 2011              	.LBE206:
 636:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 2012              	 .loc 1 636 0
 2013 021a 8023     	 movs r3,#128
 2014 021c 84F8B030 	 strb r3,[r4,#176]
 640:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 2015              	 .loc 1 640 0
 2016 0220 94F85230 	 ldrb r3,[r4,#82]
 2017 0224 1344     	 add r3,r3,r2
 2018 0226 84F85230 	 strb r3,[r4,#82]
 645:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 2019              	 .loc 1 645 0
 2020 022a 2046     	 mov r0,r4
 2021 022c 0021     	 movs r1,#0
 2022 022e 3422     	 movs r2,#52
 2023 0230 0B46     	 mov r3,r1
 2024 0232 FFF7FEFF 	 bl prvTCPReturnPacket
 2025              	.LVL255:
 2026 0236 1AE0     	 b .L130
 2027              	.LVL256:
 2028              	.L141:
 2029              	.LBE205:
 2030              	.LBE199:
 2031              	.LBE198:
 2032              	.LBB210:
 2033              	.LBB211:
 2034              	.LBB212:
 445:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 2035              	 .loc 1 445 0
 2036 0238 2046     	 mov r0,r4
 2037              	.LVL257:
 2038 023a 0821     	 movs r1,#8
 2039 023c FFF7FEFF 	 bl vTCPStateChange
 2040              	.LVL258:
 449:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
 2041              	 .loc 1 449 0
 2042 0240 94F84030 	 ldrb r3,[r4,#64]
 2043 0244 13F0040F 	 tst r3,#4
 2044 0248 0AD0     	 beq .L149
 451:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					{
 2045              	 .loc 1 451 0
 2046 024a 13F0080F 	 tst r3,#8
 2047 024e 09D1     	 bne .L150
 457:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					}
 2048              	 .loc 1 457 0
 2049 0250 2046     	 mov r0,r4
 2050 0252 FFF7FEFF 	 bl vSocketClose
 2051              	.LVL259:
 462:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
 2052              	 .loc 1 462 0
 2053 0256 4FF0FF30 	 mov r0,#-1
 2054 025a 3EE0     	 b .L153
 2055              	.LVL260:
 2056              	.L147:
 2057              	.LBE212:
 2058              	.LBE211:
 2059              	.LBE210:
 487:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** BaseType_t xReady = pdFALSE;
 2060              	 .loc 1 487 0
 2061 025c 0020     	 movs r0,#0
 2062 025e 3CE0     	 b .L153
 2063              	.LVL261:
 2064              	.L149:
 2065              	.LBB217:
 2066              	.LBB215:
 422:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			break;
 2067              	 .loc 1 422 0
 2068 0260 0120     	 movs r0,#1
 2069 0262 3AE0     	 b .L153
 2070              	.L150:
 2071              	.LBB213:
 462:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
 2072              	 .loc 1 462 0
 2073 0264 4FF0FF30 	 mov r0,#-1
 2074 0268 37E0     	 b .L153
 2075              	.LVL262:
 2076              	.L151:
 2077              	.LBE213:
 398:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 2078              	 .loc 1 398 0
 2079 026a 0020     	 movs r0,#0
 2080 026c 35E0     	 b .L153
 2081              	.LVL263:
 2082              	.L130:
 2083              	.LBE215:
 2084              	.LBE217:
 562:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 2085              	 .loc 1 562 0
 2086 026e 2046     	 mov r0,r4
 2087 0270 FFF7FEFF 	 bl prvTCPNextTimeout
 2088              	.LVL264:
 2089              	.LBB218:
 2090              	.LBB216:
 398:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 2091              	 .loc 1 398 0
 2092 0274 94F85330 	 ldrb r3,[r4,#83]
 2093 0278 082B     	 cmp r3,#8
 2094 027a 15D8     	 bhi .L139
 2095 027c 01A2     	 adr r2,.L140
 2096 027e 52F823F0 	 ldr pc,[r2,r3,lsl#2]
 2097 0282 00BF     	 .p2align 2
 2098              	.L140:
 2099 0284 6B020000 	 .word .L151+1
 2100 0288 6B020000 	 .word .L151+1
 2101 028c A9020000 	 .word .L139+1
 2102 0290 A9020000 	 .word .L139+1
 2103 0294 A9020000 	 .word .L139+1
 2104 0298 6B020000 	 .word .L151+1
 2105 029c A9020000 	 .word .L139+1
 2106 02a0 A9020000 	 .word .L139+1
 2107 02a4 6B020000 	 .word .L151+1
 2108              	 .p2align 1
 2109              	.L139:
 2110              	.LVL265:
 2111              	.LBB214:
 429:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 2112              	 .loc 1 429 0
 2113 02a8 FFF7FEFF 	 bl xTaskGetTickCount
 2114              	.LVL266:
 2115 02ac 236E     	 ldr r3,[r4,#96]
 2116 02ae C01A     	 subs r0,r0,r3
 2117              	.LVL267:
 432:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 2118              	 .loc 1 432 0
 2119 02b0 0C4B     	 ldr r3,.L157+4
 2120 02b2 9842     	 cmp r0,r3
 2121 02b4 C0D8     	 bhi .L141
 2122              	.LBE214:
 422:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			break;
 2123              	 .loc 1 422 0
 2124 02b6 0120     	 movs r0,#1
 2125              	.LVL268:
 2126 02b8 0FE0     	 b .L153
 2127              	.LVL269:
 2128              	.L154:
 2129              	.LBE216:
 2130              	.LBE218:
 555:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eCONNECT_SYN ) )
 2131              	 .loc 1 555 0
 2132 02ba 94F85330 	 ldrb r3,[r4,#83]
 2133 02be D7E6     	 b .L128
 2134              	.L122:
 499:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 2135              	 .loc 1 499 0
 2136 02c0 C16F     	 ldr r1,[r0,#124]
 2137 02c2 0029     	 cmp r1,#0
 2138 02c4 7FF4ACAE 	 bne .L142
 2139 02c8 F7E7     	 b .L154
 2140              	.L155:
 555:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eCONNECT_SYN ) )
 2141              	 .loc 1 555 0
 2142 02ca 94F85330 	 ldrb r3,[r4,#83]
 2143 02ce CBE6     	 b .L144
 2144              	.L121:
 499:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 2145              	 .loc 1 499 0
 2146 02d0 C16F     	 ldr r1,[r0,#124]
 2147 02d2 0029     	 cmp r1,#0
 2148 02d4 7FF4A4AE 	 bne .L142
 2149 02d8 F7E7     	 b .L155
 2150              	.LVL270:
 2151              	.L153:
 574:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
 2152              	 .loc 1 574 0
 2153 02da 04B0     	 add sp,sp,#16
 2154              	.LCFI18:
 2155              	 .cfi_def_cfa_offset 16
 2156              	 
 2157 02dc 70BD     	 pop {r4,r5,r6,pc}
 2158              	.LVL271:
 2159              	.L158:
 2160 02de 00BF     	 .align 2
 2161              	.L157:
 2162 02e0 00000000 	 .word xDefaultPartUDPPacketHeader
 2163 02e4 C0D40100 	 .word 120000
 2164              	 .cfi_endproc
 2165              	.LFE52:
 2167              	 .section .text.prvTCPHandleFin,"ax",%progbits
 2168              	 .align 2
 2169              	 .thumb
 2170              	 .thumb_func
 2172              	prvTCPHandleFin:
 2173              	.LFB69:
2078:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /* Map the ethernet buffer onto the ProtocolHeader_t struct for easy access to the fields. */
 2174              	 .loc 1 2078 0
 2175              	 .cfi_startproc
 2176              	 
 2177              	 
 2178              	.LVL272:
 2179 0000 38B5     	 push {r3,r4,r5,lr}
 2180              	.LCFI19:
 2181              	 .cfi_def_cfa_offset 16
 2182              	 .cfi_offset 3,-16
 2183              	 .cfi_offset 4,-12
 2184              	 .cfi_offset 5,-8
 2185              	 .cfi_offset 14,-4
 2186 0002 0446     	 mov r4,r0
2080:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	&( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + xIPHeaderSize( pxNetworkBuffer ) ] )
 2187              	 .loc 1 2080 0
 2188 0004 8D69     	 ldr r5,[r1,#24]
 2189              	.LVL273:
2086:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 2190              	 .loc 1 2086 0
 2191 0006 D5F82A10 	 ldr r1,[r5,#42]
 2192              	.LVL274:
2088:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 2193              	 .loc 1 2088 0
 2194 000a 95F82F30 	 ldrb r3,[r5,#47]
 2195 000e 13F0010F 	 tst r3,#1
 2196 0012 04D0     	 beq .L160
2090:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 2197              	 .loc 1 2090 0
 2198 0014 D0F8EC30 	 ldr r3,[r0,#236]
 2199 0018 0133     	 adds r3,r3,#1
 2200 001a C0F8E830 	 str r3,[r0,#232]
 2201              	.LVL275:
 2202              	.L160:
2092:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 2203              	 .loc 1 2092 0
 2204 001e 94F84130 	 ldrb r3,[r4,#65]
 2205 0022 13F0400F 	 tst r3,#64
 2206 0026 0AD1     	 bne .L161
2095:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxSocket->u.xTCP.bits.bFinSent = pdTRUE_UNSIGNED;
 2207              	 .loc 1 2095 0
 2208 0028 D4F8F830 	 ldr r3,[r4,#248]
 2209 002c C4F8FC30 	 str r3,[r4,#252]
2096:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 2210              	 .loc 1 2096 0
 2211 0030 94F84130 	 ldrb r3,[r4,#65]
 2212 0034 43F04003 	 orr r3,r3,#64
 2213 0038 84F84130 	 strb r3,[r4,#65]
 2214 003c 15E0     	 b .L162
 2215              	.L161:
2101:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 2216              	 .loc 1 2101 0
 2217 003e D4F8FC30 	 ldr r3,[r4,#252]
 2218 0042 581C     	 adds r0,r3,#1
 2219              	.LVL276:
2086:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 2220              	 .loc 1 2086 0
 2221 0044 0A0E     	 lsrs r2,r1,#24
 2222 0046 42EA0162 	 orr r2,r2,r1,lsl#24
 2223 004a 01F47F43 	 and r3,r1,#65280
 2224 004e 42EA0322 	 orr r2,r2,r3,lsl#8
 2225 0052 01F47F03 	 and r3,r1,#16711680
 2226 0056 42EA1323 	 orr r3,r2,r3,lsr#8
2101:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 2227              	 .loc 1 2101 0
 2228 005a 9842     	 cmp r0,r3
 2229 005c 05D1     	 bne .L162
2103:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 2230              	 .loc 1 2103 0
 2231 005e 94F84230 	 ldrb r3,[r4,#66]
 2232 0062 43F00103 	 orr r3,r3,#1
 2233 0066 84F84230 	 strb r3,[r4,#66]
 2234              	.L162:
2107:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 2235              	 .loc 1 2107 0
 2236 006a 94F84220 	 ldrb r2,[r4,#66]
 2237 006e 12F0010F 	 tst r2,#1
 2238 0072 0BD1     	 bne .L163
2109:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPHeader->ucTCPFlags = ( uint8_t ) tcpTCP_FLAG_ACK | ( uint8_t ) tcpTCP_FLAG_FIN;
 2239              	 .loc 1 2109 0
 2240 0074 D4F8FC30 	 ldr r3,[r4,#252]
 2241 0078 C4F8F830 	 str r3,[r4,#248]
2110:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 2242              	 .loc 1 2110 0
 2243 007c 1123     	 movs r3,#17
 2244 007e 85F82F30 	 strb r3,[r5,#47]
2113:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 2245              	 .loc 1 2113 0
 2246 0082 2046     	 mov r0,r4
 2247 0084 0A21     	 movs r1,#10
 2248              	.LVL277:
 2249 0086 FFF7FEFF 	 bl vTCPStateChange
 2250              	.LVL278:
 2251 008a 18E0     	 b .L164
 2252              	.LVL279:
 2253              	.L163:
2118:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( pxSocket->u.xTCP.bits.bFinRecv == pdFALSE_UNSIGNED )
 2254              	 .loc 1 2118 0
 2255 008c D4F8FC30 	 ldr r3,[r4,#252]
 2256 0090 0133     	 adds r3,r3,#1
 2257 0092 C4F8F830 	 str r3,[r4,#248]
2119:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 2258              	 .loc 1 2119 0
 2259 0096 94F84130 	 ldrb r3,[r4,#65]
 2260 009a 13F0800F 	 tst r3,#128
 2261 009e 03D1     	 bne .L165
2123:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 2262              	 .loc 1 2123 0
 2263 00a0 0023     	 movs r3,#0
 2264 00a2 85F82F30 	 strb r3,[r5,#47]
 2265 00a6 0AE0     	 b .L164
 2266              	.L165:
2127:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 2267              	 .loc 1 2127 0
 2268 00a8 12F0020F 	 tst r2,#2
2131:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 2269              	 .loc 1 2131 0
 2270 00ac 0CBF     	 ite eq
 2271 00ae 1023     	 moveq r3,#16
2137:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 2272              	 .loc 1 2137 0
 2273 00b0 0023     	 movne r3,#0
 2274 00b2 85F82F30 	 strb r3,[r5,#47]
2141:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 2275              	 .loc 1 2141 0
 2276 00b6 2046     	 mov r0,r4
 2277 00b8 0821     	 movs r1,#8
 2278              	.LVL280:
 2279 00ba FFF7FEFF 	 bl vTCPStateChange
 2280              	.LVL281:
 2281              	.L164:
2145:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 2282              	 .loc 1 2145 0
 2283 00be D4F8F830 	 ldr r3,[r4,#248]
 2284 00c2 C4F80431 	 str r3,[r4,#260]
2147:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 2285              	 .loc 1 2147 0
 2286 00c6 95F82F30 	 ldrb r3,[r5,#47]
 2287 00ca 23B1     	 cbz r3,.L169
 2288              	.LVL282:
2149:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		xSendLength = ( BaseType_t ) ucIntermediateResult;
 2289              	 .loc 1 2149 0
 2290 00cc 94F81401 	 ldrb r0,[r4,#276]
 2291 00d0 2830     	 adds r0,r0,#40
2150:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 2292              	 .loc 1 2150 0
 2293 00d2 C0B2     	 uxtb r0,r0
 2294              	.LVL283:
 2295 00d4 00E0     	 b .L168
 2296              	.LVL284:
 2297              	.L169:
2085:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint32_t ulAckNr = FreeRTOS_ntohl( pxTCPHeader->ulAckNr );
 2298              	 .loc 1 2085 0
 2299 00d6 0020     	 movs r0,#0
 2300              	.LVL285:
 2301              	.L168:
2153:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 2302              	 .loc 1 2153 0
 2303 00d8 94F81431 	 ldrb r3,[r4,#276]
 2304 00dc 1433     	 adds r3,r3,#20
 2305 00de 9B00     	 lsls r3,r3,#2
 2306 00e0 85F82E30 	 strb r3,[r5,#46]
2166:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
 2307              	 .loc 1 2166 0
 2308 00e4 38BD     	 pop {r3,r4,r5,pc}
 2309              	 .cfi_endproc
 2310              	.LFE69:
 2312 00e6 00BF     	 .section .text.xProcessReceivedTCPPacket,"ax",%progbits
 2313              	 .align 2
 2314              	 .global xProcessReceivedTCPPacket
 2315              	 .thumb
 2316              	 .thumb_func
 2318              	xProcessReceivedTCPPacket:
 2319              	.LFB81:
3069:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** }
3070:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
3071:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3072:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
3073:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  *	FreeRTOS_TCP_IP has only 2 public functions, this is the second one:
3074:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  *	xProcessReceivedTCPPacket()
3075:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  *		prvTCPHandleState()
3076:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  *			prvTCPPrepareSend()
3077:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  *				prvTCPReturnPacket()
3078:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  *				xNetworkInterfaceOutput()	// Sends data to the NIC
3079:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  *		prvTCPSendRepeated()
3080:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  *			prvTCPReturnPacket()		// Prepare for returning
3081:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  *			xNetworkInterfaceOutput()	// Sends data to the NIC
3082:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** */
3083:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** BaseType_t xProcessReceivedTCPPacket( NetworkBufferDescriptor_t *pxDescriptor )
3084:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** {
 2320              	 .loc 1 3084 0
 2321              	 .cfi_startproc
 2322              	 
 2323              	 
 2324              	.LVL286:
 2325 0000 2DE9F04F 	 push {r4,r5,r6,r7,r8,r9,r10,fp,lr}
 2326              	.LCFI20:
 2327              	 .cfi_def_cfa_offset 36
 2328              	 .cfi_offset 4,-36
 2329              	 .cfi_offset 5,-32
 2330              	 .cfi_offset 6,-28
 2331              	 .cfi_offset 7,-24
 2332              	 .cfi_offset 8,-20
 2333              	 .cfi_offset 9,-16
 2334              	 .cfi_offset 10,-12
 2335              	 .cfi_offset 11,-8
 2336              	 .cfi_offset 14,-4
 2337 0004 8BB0     	 sub sp,sp,#44
 2338              	.LCFI21:
 2339              	 .cfi_def_cfa_offset 80
3085:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /* Function might modify the parameter. */
3086:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** NetworkBufferDescriptor_t *pxNetworkBuffer = pxDescriptor;
 2340              	 .loc 1 3086 0
 2341 0006 0990     	 str r0,[sp,#36]
3087:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3088:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /* Map the buffer onto a ProtocolHeaders_t struct for easy access to the fields. */
3089:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** const ProtocolHeaders_t *pxProtocolHeaders = ipCAST_CONST_PTR_TO_CONST_TYPE_PTR( ProtocolHeaders_t,
 2342              	 .loc 1 3089 0
 2343 0008 D0F81890 	 ldr r9,[r0,#24]
 2344              	.LVL287:
3090:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	&( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + xIPHeaderSize( pxNetworkBuffer ) ] )
3091:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** FreeRTOS_Socket_t *pxSocket;
3092:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint16_t ucTCPFlags = pxProtocolHeaders->xTCPHeader.ucTCPFlags;
 2345              	 .loc 1 3092 0
 2346 000c 99F82FB0 	 ldrb fp,[r9,#47]
 2347              	.LVL288:
3093:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint32_t ulLocalIP;
3094:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint16_t xLocalPort = FreeRTOS_htons( pxProtocolHeaders->xTCPHeader.usDestinationPort );
 2348              	 .loc 1 3094 0
 2349 0010 B9F82410 	 ldrh r1,[r9,#36]
 2350              	.LVL289:
3095:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint16_t xRemotePort = FreeRTOS_htons( pxProtocolHeaders->xTCPHeader.usSourcePort );
 2351              	 .loc 1 3095 0
 2352 0014 B9F822E0 	 ldrh lr,[r9,#34]
 2353              	.LVL290:
3096:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint32_t ulRemoteIP;
3097:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint32_t ulSequenceNumber = FreeRTOS_ntohl( pxProtocolHeaders->xTCPHeader.ulSequenceNumber );
 2354              	 .loc 1 3097 0
 2355 0018 D9F82650 	 ldr r5,[r9,#38]
 2356              	.LVL291:
3098:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint32_t ulAckNumber = FreeRTOS_ntohl( pxProtocolHeaders->xTCPHeader.ulAckNr );;
 2357              	 .loc 1 3098 0
 2358 001c D9F82A60 	 ldr r6,[r9,#42]
 2359              	.LVL292:
3099:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** BaseType_t xResult = pdPASS;
3100:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** configASSERT( pxNetworkBuffer != NULL );
 2360              	 .loc 1 3100 0
 2361 0020 40B9     	 cbnz r0,.L172
 2362              	.LBB281:
 2363              	.LBB282:
 2364              	 .loc 4 197 0
 2365              	
 2366 0022 4FF01403 	 mov r3,#20
 2367 0026 83F31188 	 msr basepri,r3
 2368 002a BFF36F8F 	 isb 
 2369 002e BFF34F8F 	 dsb 
 2370              	
 2371              	
 2372              	.LVL293:
 2373              	 .thumb
 2374              	.L173:
 2375              	.LBE282:
 2376              	.LBE281:
 2377              	 .loc 1 3100 0 discriminator 1
 2378 0032 FEE7     	 b .L173
 2379              	.L172:
3101:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** configASSERT( pxNetworkBuffer->pucEthernetBuffer != NULL );
 2380              	 .loc 1 3101 0
 2381 0034 B9F1000F 	 cmp r9,#0
 2382 0038 08D1     	 bne .L174
 2383              	.LBB283:
 2384              	.LBB284:
 2385              	 .loc 4 197 0
 2386              	
 2387 003a 4FF01403 	 mov r3,#20
 2388 003e 83F31188 	 msr basepri,r3
 2389 0042 BFF36F8F 	 isb 
 2390 0046 BFF34F8F 	 dsb 
 2391              	
 2392              	
 2393              	.LVL294:
 2394              	 .thumb
 2395              	.L175:
 2396              	.LBE284:
 2397              	.LBE283:
 2398              	 .loc 1 3101 0 discriminator 2
 2399 004a FEE7     	 b .L175
 2400              	.L174:
3102:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** const IPHeader_t *pxIPHeader;
3103:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3104:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	/* Check for a minimum packet size. */
3105:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( pxNetworkBuffer->xDataLength < ( ipSIZE_OF_ETH_HEADER + xIPHeaderSize( pxNetworkBuffer ) + ipS
 2401              	 .loc 1 3105 0
 2402 004c C369     	 ldr r3,[r0,#28]
 2403 004e 352B     	 cmp r3,#53
 2404 0050 40F24785 	 bls .L267
 2405              	.LVL295:
3106:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
3107:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		xResult = pdFAIL;
3108:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
3109:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	else
3110:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
3111:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Map the ethernet buffer onto the IPHeader_t struct for easy access to the fields. */
3112:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxIPHeader = ipCAST_CONST_PTR_TO_CONST_TYPE_PTR( IPHeader_t, &( pxNetworkBuffer->pucEthernetBuffe
3113:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		ulLocalIP = FreeRTOS_htonl( pxIPHeader->ulDestinationIPAddress );
 2406              	 .loc 1 3113 0
 2407 0054 D9F81E30 	 ldr r3,[r9,#30]
 2408              	.LVL296:
3114:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		ulRemoteIP = FreeRTOS_htonl( pxIPHeader->ulSourceIPAddress );
 2409              	 .loc 1 3114 0
 2410 0058 D9F81A20 	 ldr r2,[r9,#26]
 2411              	.LVL297:
3113:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		ulRemoteIP = FreeRTOS_htonl( pxIPHeader->ulSourceIPAddress );
 2412              	 .loc 1 3113 0
 2413 005c 1806     	 lsls r0,r3,#24
 2414              	.LVL298:
 2415 005e 40EA1360 	 orr r0,r0,r3,lsr#24
 2416 0062 03F47F44 	 and r4,r3,#65280
 2417 0066 40EA0420 	 orr r0,r0,r4,lsl#8
 2418 006a 03F47F03 	 and r3,r3,#16711680
 2419              	.LVL299:
3094:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint16_t xRemotePort = FreeRTOS_htons( pxProtocolHeaders->xTCPHeader.usSourcePort );
 2420              	 .loc 1 3094 0
 2421 006e 0C0A     	 lsrs r4,r1,#8
 2422 0070 44EA0121 	 orr r1,r4,r1,lsl#8
 2423              	 .loc 1 3114 0
 2424 0074 1406     	 lsls r4,r2,#24
 2425 0076 44EA1264 	 orr r4,r4,r2,lsr#24
 2426 007a 02F47F47 	 and r7,r2,#65280
 2427 007e 44EA0724 	 orr r4,r4,r7,lsl#8
 2428 0082 02F47F02 	 and r2,r2,#16711680
 2429              	.LVL300:
3095:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint32_t ulRemoteIP;
 2430              	 .loc 1 3095 0
 2431 0086 4FEA1E27 	 lsr r7,lr,#8
 2432 008a 47EA0E27 	 orr r7,r7,lr,lsl#8
3115:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3116:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Find the destination socket, and if not found: return a socket listing to
3117:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		the destination PORT. */
3118:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxSocket = ( FreeRTOS_Socket_t * ) pxTCPSocketLookup( ulLocalIP, xLocalPort, ulRemoteIP, xRemoteP
 2433              	 .loc 1 3118 0
 2434 008e 40EA1320 	 orr r0,r0,r3,lsr#8
 2435              	.LVL301:
 2436 0092 89B2     	 uxth r1,r1
 2437 0094 44EA1222 	 orr r2,r4,r2,lsr#8
 2438              	.LVL302:
 2439 0098 BBB2     	 uxth r3,r7
 2440 009a FFF7FEFF 	 bl pxTCPSocketLookup
 2441              	.LVL303:
3119:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3120:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( ( pxSocket == NULL ) || ( prvTCPSocketIsActive( ipNUMERIC_CAST( eIPTCPState_t, pxSocket->u.xT
 2442              	 .loc 1 3120 0
 2443 009e 0446     	 mov r4,r0
 2444 00a0 58B1     	 cbz r0,.L177
 2445              	 .loc 1 3120 0 is_stmt 0 discriminator 1
 2446 00a2 90F85330 	 ldrb r3,[r0,#83]
 2447              	.LVL304:
 2448              	.LBB285:
 2449              	.LBB286:
 367:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 2450              	 .loc 1 367 0 is_stmt 1 discriminator 1
 2451 00a6 0B2B     	 cmp r3,#11
 2452 00a8 15D8     	 bhi .L178
 2453 00aa DFE803F0 	 tbb [pc,r3]
 2454              	.L179:
 2455 00ae 06       	 .byte (.L177-.L179)/2
 2456 00af 14       	 .byte (.L178-.L179)/2
 2457 00b0 14       	 .byte (.L178-.L179)/2
 2458 00b1 14       	 .byte (.L178-.L179)/2
 2459 00b2 14       	 .byte (.L178-.L179)/2
 2460 00b3 14       	 .byte (.L178-.L179)/2
 2461 00b4 14       	 .byte (.L178-.L179)/2
 2462 00b5 06       	 .byte (.L177-.L179)/2
 2463 00b6 06       	 .byte (.L177-.L179)/2
 2464 00b7 06       	 .byte (.L177-.L179)/2
 2465 00b8 14       	 .byte (.L178-.L179)/2
 2466 00b9 06       	 .byte (.L177-.L179)/2
 2467              	.LVL305:
 2468              	 .p2align 1
 2469              	.L177:
 2470              	.LBE286:
 2471              	.LBE285:
3121:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
3122:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* A TCP messages is received but either there is no socket with the
3123:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			given port number or the there is a socket, but it is in one of these
3124:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			non-active states:  eCLOSED, eCLOSE_WAIT, eFIN_WAIT_2, eCLOSING, or
3125:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			eTIME_WAIT. */
3126:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3127:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			FreeRTOS_debug_printf( ( "TCP: No active socket on port %d (%lxip:%d)\n", xLocalPort, ulRemoteIP
3128:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3129:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* Send a RST to all packets that can not be handled.  As a result
3130:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			the other party will get a ECONN error.  There are two exceptions:
3131:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			1) A packet that already has the RST flag set.
3132:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			2) A packet that only has the ACK flag set.
3133:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			A packet with only the ACK flag set might be the last ACK in
3134:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			a three-way hand-shake that closes a connection. */
3135:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( ( ( ucTCPFlags & tcpTCP_FLAG_CTRL ) != tcpTCP_FLAG_ACK ) &&
 2472              	 .loc 1 3135 0
 2473 00ba 0BF01F03 	 and r3,fp,#31
 2474 00be 102B     	 cmp r3,#16
 2475 00c0 00F01585 	 beq .L180
 2476              	 .loc 1 3135 0 is_stmt 0 discriminator 1
 2477 00c4 1BF0040F 	 tst fp,#4
 2478 00c8 40F01185 	 bne .L180
3136:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				( ( ucTCPFlags & tcpTCP_FLAG_RST ) == 0U ) )
3137:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
3138:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				( void ) prvTCPSendReset( pxNetworkBuffer );
 2479              	 .loc 1 3138 0 is_stmt 1
 2480 00cc 0998     	 ldr r0,[sp,#36]
 2481              	.LVL306:
 2482 00ce FFF7FEFF 	 bl prvTCPSendReset
 2483              	.LVL307:
 2484 00d2 00F00CBD 	 b .L180
 2485              	.LVL308:
 2486              	.L178:
3139:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
3140:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3141:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* The packet can't be handled. */
3142:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			xResult = pdFAIL;
3143:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
3144:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		else
3145:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
3146:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxSocket->u.xTCP.ucRepCount = 0U;
 2487              	 .loc 1 3146 0
 2488 00d6 0022     	 movs r2,#0
 2489 00d8 80F85220 	 strb r2,[r0,#82]
3147:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3148:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eTCP_LISTEN )
 2490              	 .loc 1 3148 0
 2491 00dc 012B     	 cmp r3,#1
 2492 00de 40F0C480 	 bne .L181
3149:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
3150:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				/* The matching socket is in a listening state.  Test if the peer
3151:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				has set the SYN flag. */
3152:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				if( ( ucTCPFlags & tcpTCP_FLAG_CTRL ) != tcpTCP_FLAG_SYN )
 2493              	 .loc 1 3152 0
 2494 00e2 0BF01F03 	 and r3,fp,#31
 2495              	.LVL309:
 2496 00e6 022B     	 cmp r3,#2
 2497 00e8 08D0     	 beq .L182
3153:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
3154:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					/* What happens: maybe after a reboot, a client doesn't know the
3155:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					connection had gone.  Send a RST in order to get a new connect
3156:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					request. */
3157:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					#if( ipconfigHAS_DEBUG_PRINTF == 1 )
3158:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					{
3159:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					FreeRTOS_debug_printf( ( "TCP: Server can't handle flags: %s from %lxip:%u to port %u\n",
3160:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						prvTCPFlagMeaning( ( UBaseType_t ) ucTCPFlags ), ulRemoteIP, xRemotePort, xLocalPort ) );
3161:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					}
3162:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					#endif /* ipconfigHAS_DEBUG_PRINTF */
3163:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3164:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					if( ( ucTCPFlags & tcpTCP_FLAG_RST ) == 0U )
 2498              	 .loc 1 3164 0
 2499 00ea 1BF0040F 	 tst fp,#4
 2500 00ee 40F0FE84 	 bne .L180
3165:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					{
3166:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						( void ) prvTCPSendReset( pxNetworkBuffer );
 2501              	 .loc 1 3166 0
 2502 00f2 0998     	 ldr r0,[sp,#36]
 2503              	.LVL310:
 2504 00f4 FFF7FEFF 	 bl prvTCPSendReset
 2505              	.LVL311:
 2506 00f8 00F0F9BC 	 b .L180
 2507              	.LVL312:
 2508              	.L182:
3167:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					}
3168:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					xResult = pdFAIL;
3169:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
3170:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				else
3171:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
3172:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					/* prvHandleListen() will either return a newly created socket
3173:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					(if bReuseSocket is false), otherwise it returns the current
3174:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					socket which will later get connected. */
3175:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					pxSocket = prvHandleListen( pxSocket, pxNetworkBuffer );
 2509              	 .loc 1 3175 0
 2510 00fc 099E     	 ldr r6,[sp,#36]
 2511              	.LVL313:
 2512              	.LBB287:
 2513              	.LBB288:
3176:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3177:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					if( pxSocket == NULL )
3178:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					{
3179:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						xResult = pdFAIL;
3180:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					}
3181:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
3182:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}	/* if( pxSocket->u.xTCP.ucTCPState == eTCP_LISTEN ). */
3183:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			else
3184:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
3185:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				/* This is not a socket in listening mode. Check for the RST
3186:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				flag. */
3187:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				if( ( ucTCPFlags & tcpTCP_FLAG_RST ) != 0U )
3188:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
3189:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					FreeRTOS_debug_printf( ( "TCP: RST received from %lxip:%u for %u\n", ulRemoteIP, xRemotePort, 
3190:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3191:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					/* Implement https://tools.ietf.org/html/rfc5961#section-3.2. */
3192:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					if( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eCONNECT_SYN )
3193:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					{
3194:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						/* Per the above RFC, "In the SYN-SENT state ... the RST is
3195:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						acceptable if the ACK field acknowledges the SYN." */
3196:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						if( ulAckNumber == ( pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber + 1UL ) )
3197:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						{
3198:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							vTCPStateChange( pxSocket, eCLOSED );
3199:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						}
3200:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					}
3201:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					else
3202:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					{
3203:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						/* Check whether the packet matches the next expected sequence number. */
3204:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						if( ulSequenceNumber == pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber )
3205:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						{
3206:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							vTCPStateChange( pxSocket, eCLOSED );
3207:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						}
3208:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						/* Otherwise, check whether the packet is within the receive window. */
3209:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						else if( ( ulSequenceNumber > pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber ) &&
3210:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 								 ( ulSequenceNumber < ( pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber +
3211:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 													  pxSocket->u.xTCP.xTCPWindow.xSize.ulRxWindowLength ) ) )
3212:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						{
3213:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							/* Send a challenge ACK. */
3214:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							( void ) prvTCPSendChallengeAck( pxNetworkBuffer );
3215:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						}
3216:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						else
3217:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						{
3218:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 							/* Nothing. */
3219:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						}
3220:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					}
3221:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3222:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					/* Otherwise, do nothing. In any case, the packet cannot be handled. */
3223:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					xResult = pdFAIL;
3224:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
3225:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				else if( ( ( ucTCPFlags & tcpTCP_FLAG_CTRL ) == tcpTCP_FLAG_SYN ) && ( pxSocket->u.xTCP.ucTCPSt
3226:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
3227:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					/* SYN flag while this socket is already connected. */
3228:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					FreeRTOS_debug_printf( ( "TCP: SYN unexpected from %lxip:%u\n", ulRemoteIP, xRemotePort ) );
3229:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3230:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					/* The packet cannot be handled. */
3231:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					xResult = pdFAIL;
3232:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
3233:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				else
3234:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
3235:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					/* Update the copy of the TCP header only (skipping eth and IP
3236:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					headers).  It might be used later on, whenever data must be sent
3237:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					to the peer. */
3238:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					const size_t lOffset = ipNUMERIC_CAST( size_t, ipSIZE_OF_ETH_HEADER + uxIPHeaderSizeSocket( px
3239:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					( void ) memcpy( ( void * ) ( &( pxSocket->u.xTCP.xPacket.u.ucLastPacket[ lOffset ] ) ),
3240:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 									 ( const void * ) ( &( pxNetworkBuffer->pucEthernetBuffer[ lOffset ] ) ),
3241:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 									 ipSIZE_OF_TCP_HEADER );
3242:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
3243:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
3244:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
3245:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3246:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( xResult != pdFAIL )
3247:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
3248:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		uint16_t usWindow;
3249:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3250:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* pxSocket is not NULL when xResult != pdFAIL. */
3251:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			configASSERT( pxSocket != NULL );
3252:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* Touch the alive timers because we received a message	for this
3253:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			socket. */
3254:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			prvTCPTouchSocket( pxSocket );
3255:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3256:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* Parse the TCP option(s), if present. */
3257:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* _HT_ : if we're in the SYN phase, and peer does not send a MSS option,
3258:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			then we MUST assume an MSS size of 536 bytes for backward compatibility. */
3259:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3260:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* When there are no TCP options, the TCP offset equals 20 bytes, which is stored as
3261:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			the number 5 (words) in the higher nibble of the TCP-offset byte. */
3262:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( ( pxProtocolHeaders->xTCPHeader.ucTCPOffset & tcpTCP_OFFSET_LENGTH_BITS ) > tcpTCP_OFFSET_ST
3263:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
3264:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				prvCheckOptions( pxSocket, pxNetworkBuffer );
3265:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
3266:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3267:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			usWindow = FreeRTOS_ntohs( pxProtocolHeaders->xTCPHeader.usWindow );
3268:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxSocket->u.xTCP.ulWindowSize = (uint32_t ) usWindow;
3269:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			#if( ipconfigUSE_TCP_WIN == 1 )
3270:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
3271:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				/* rfc1323 : The Window field in a SYN (i.e., a <SYN> or <SYN,ACK>)
3272:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				segment itself is never scaled. */
3273:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				if( ( ucTCPFlags & ( uint8_t ) tcpTCP_FLAG_SYN ) == 0U )
3274:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
3275:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					pxSocket->u.xTCP.ulWindowSize =
3276:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						( pxSocket->u.xTCP.ulWindowSize << pxSocket->u.xTCP.ucPeerWinScaleFactor );
3277:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
3278:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
3279:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			#endif /* ipconfigUSE_TCP_WIN */
3280:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3281:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* In prvTCPHandleState() the incoming messages will be handled
3282:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			depending on the current state of the connection. */
3283:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( prvTCPHandleState( pxSocket, &pxNetworkBuffer ) > 0 )
3284:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
3285:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				/* prvTCPHandleState() has sent a message, see if there are more to
3286:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				be transmitted. */
3287:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				#if( ipconfigUSE_TCP_WIN == 1 )
3288:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
3289:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					( void ) prvTCPSendRepeated( pxSocket, &pxNetworkBuffer );
3290:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
3291:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				#endif /* ipconfigUSE_TCP_WIN */
3292:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
3293:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3294:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( pxNetworkBuffer != NULL )
3295:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
3296:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				/* We must check if the buffer is unequal to NULL, because the
3297:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				socket might keep a reference to it in case a delayed ACK must be
3298:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				sent. */
3299:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
3300:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				#ifndef _lint
3301:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				/* Clear pointers that are freed. */
3302:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxNetworkBuffer = NULL;
3303:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				#endif
3304:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
3305:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3306:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* And finally, calculate when this socket wants to be woken up. */
3307:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( void ) prvTCPNextTimeout ( pxSocket );
3308:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* Return pdPASS to tell that the network buffer is 'consumed'. */
3309:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			xResult = pdPASS;
3310:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
3311:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
3312:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	/* pdPASS being returned means the buffer has been consumed. */
3313:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	return xResult;
3314:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** }
3315:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
3316:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3317:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static FreeRTOS_Socket_t *prvHandleListen( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t *
3318:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** {
3319:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /* Map the ethernet buffer onto a TCPPacket_t struct for easy access to the fields. */
3320:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** const TCPPacket_t * pxTCPPacket = ipCAST_CONST_PTR_TO_CONST_TYPE_PTR( TCPPacket_t, pxNetworkBuffer-
 2514              	 .loc 1 3320 0
 2515 00fe D6F81880 	 ldr r8,[r6,#24]
 2516              	.LVL314:
3321:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** FreeRTOS_Socket_t *pxReturn = NULL;
3322:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint32_t ulInitialSequenceNumber;
3323:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3324:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	/* Assume that a new Initial Sequence Number will be required. Request
3325:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	it now in order to fail out if necessary. */
3326:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	ulInitialSequenceNumber = ulApplicationGetNextSequenceNumber( *ipLOCAL_IP_ADDRESS_POINTER,
 2517              	 .loc 1 3326 0
 2518 0102 D04B     	 ldr r3,.L300
 2519 0104 5869     	 ldr r0,[r3,#20]
 2520              	.LVL315:
 2521 0106 A18C     	 ldrh r1,[r4,#36]
 2522 0108 D8F81A20 	 ldr r2,[r8,#26]
 2523 010c B8F82230 	 ldrh r3,[r8,#34]
 2524 0110 FFF7FEFF 	 bl ulApplicationGetNextSequenceNumber
 2525              	.LVL316:
3327:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 																  pxSocket->usLocalPort,
3328:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 																  pxTCPPacket->xIPHeader.ulSourceIPAddress,
3329:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 																  pxTCPPacket->xTCPHeader.usSourcePort );
3330:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3331:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	/* A pure SYN (without ACK) has come in, create a new socket to answer
3332:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	it. */
3333:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( ulInitialSequenceNumber != 0UL )
 2526              	 .loc 1 3333 0
 2527 0114 0746     	 mov r7,r0
 2528 0116 0028     	 cmp r0,#0
 2529 0118 00F02A85 	 beq .L183
3334:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
3335:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( pxSocket->u.xTCP.bits.bReuseSocket != pdFALSE_UNSIGNED )
 2530              	 .loc 1 3335 0
 2531 011c 94F84030 	 ldrb r3,[r4,#64]
 2532 0120 13F0080F 	 tst r3,#8
 2533 0124 06D0     	 beq .L184
 2534              	.LVL317:
3336:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
3337:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* The flag bReuseSocket indicates that the same instance of the
3338:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			listening socket should be used for the connection. */
3339:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxReturn = pxSocket;
3340:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxSocket->u.xTCP.bits.bPassQueued = pdTRUE_UNSIGNED;
 2535              	 .loc 1 3340 0
 2536 0126 43F00403 	 orr r3,r3,#4
 2537 012a 84F84030 	 strb r3,[r4,#64]
3341:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxSocket->u.xTCP.pxPeerSocket = pxSocket;
 2538              	 .loc 1 3341 0
 2539 012e 6465     	 str r4,[r4,#84]
3339:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxSocket->u.xTCP.bits.bPassQueued = pdTRUE_UNSIGNED;
 2540              	 .loc 1 3339 0
 2541 0130 2546     	 mov r5,r4
 2542              	.LVL318:
 2543 0132 5BE0     	 b .L185
 2544              	.LVL319:
 2545              	.L184:
3342:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
3343:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		else
3344:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
3345:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* The socket does not have the bReuseSocket flag set meaning create a
3346:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			new socket when a connection comes in. */
3347:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxReturn = NULL;
3348:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3349:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( pxSocket->u.xTCP.usChildCount >= pxSocket->u.xTCP.usBacklog )
 2546              	 .loc 1 3349 0
 2547 0134 B4F84E20 	 ldrh r2,[r4,#78]
 2548 0138 B4F85030 	 ldrh r3,[r4,#80]
 2549 013c 9A42     	 cmp r2,r3
 2550 013e 04D3     	 bcc .L186
3350:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
3351:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				FreeRTOS_printf( ( "Check: Socket %u already has %u / %u child%s\n",
3352:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					pxSocket->usLocalPort,
3353:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					pxSocket->u.xTCP.usChildCount,
3354:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					pxSocket->u.xTCP.usBacklog,
3355:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					( pxSocket->u.xTCP.usChildCount == 1U ) ? "" : "ren" ) );
3356:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				( void ) prvTCPSendReset( pxNetworkBuffer );
 2551              	 .loc 1 3356 0
 2552 0140 3046     	 mov r0,r6
 2553              	.LVL320:
 2554 0142 FFF7FEFF 	 bl prvTCPSendReset
 2555              	.LVL321:
 2556 0146 00F013BD 	 b .L183
 2557              	.LVL322:
 2558              	.L186:
 2559              	.LBB289:
3357:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
3358:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			else
3359:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
3360:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				FreeRTOS_Socket_t *pxNewSocket = ( FreeRTOS_Socket_t * )
 2560              	 .loc 1 3360 0
 2561 014a 0220     	 movs r0,#2
 2562              	.LVL323:
 2563 014c 0121     	 movs r1,#1
 2564 014e 0622     	 movs r2,#6
 2565 0150 FFF7FEFF 	 bl FreeRTOS_socket
 2566              	.LVL324:
 2567 0154 0546     	 mov r5,r0
 2568              	.LVL325:
3361:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					FreeRTOS_socket( FREERTOS_AF_INET, FREERTOS_SOCK_STREAM, FREERTOS_IPPROTO_TCP );
3362:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3363:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				if( ( pxNewSocket == NULL ) || ( pxNewSocket == FREERTOS_INVALID_SOCKET ) )
 2569              	 .loc 1 3363 0
 2570 0156 431E     	 subs r3,r0,#1
 2571 0158 13F1030F 	 cmn r3,#3
 2572 015c 04D9     	 bls .L188
3364:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
3365:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					FreeRTOS_debug_printf( ( "TCP: Listen: new socket failed\n" ) );
3366:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					( void ) prvTCPSendReset( pxNetworkBuffer );
 2573              	 .loc 1 3366 0
 2574 015e 3046     	 mov r0,r6
 2575              	.LVL326:
 2576 0160 FFF7FEFF 	 bl prvTCPSendReset
 2577              	.LVL327:
 2578 0164 00F004BD 	 b .L183
 2579              	.LVL328:
 2580              	.L188:
 2581              	.LBB290:
 2582              	.LBB291:
3367:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
3368:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				else if( prvTCPSocketCopy( pxNewSocket, pxSocket ) != pdFALSE )
3369:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
3370:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					/* The socket will be connected immediately, no time for the
3371:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					owner to setsockopt's, therefore copy properties of the server
3372:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					socket to the new socket.  Only the binding might fail (due to
3373:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					lack of resources). */
3374:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					pxReturn = pxNewSocket;
3375:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
3376:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				else
3377:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
3378:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					/* Copying failed somehow. */
3379:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
3380:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
3381:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
3382:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
3383:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3384:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( ( ulInitialSequenceNumber != 0U ) && ( pxReturn != NULL ) )
3385:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
3386:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	/* Map the byte stream onto the ProtocolHeaders_t for easy access to the fields. */
3387:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	const ProtocolHeaders_t *pxProtocolHeaders = ipCAST_CONST_PTR_TO_CONST_TYPE_PTR( ProtocolHeaders_t
3388:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		&( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + xIPHeaderSize( pxNetworkBuffer ) ] 
3389:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3390:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxReturn->u.xTCP.usRemotePort = FreeRTOS_htons( pxTCPPacket->xTCPHeader.usSourcePort );
3391:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxReturn->u.xTCP.ulRemoteIP = FreeRTOS_htonl( pxTCPPacket->xIPHeader.ulSourceIPAddress );
3392:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxReturn->u.xTCP.xTCPWindow.ulOurSequenceNumber = ulInitialSequenceNumber;
3393:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3394:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Here is the SYN action. */
3395:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxReturn->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber = FreeRTOS_ntohl( pxProtocolHeaders->xTCPH
3396:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		prvSocketSetMSS( pxReturn );
3397:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3398:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		prvTCPCreateWindow( pxReturn );
3399:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3400:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		vTCPStateChange( pxReturn, eSYN_FIRST );
3401:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3402:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Make a copy of the header up to the TCP header.  It is needed later
3403:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		on, whenever data must be sent to the peer. */
3404:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		( void ) memcpy( ( void * ) ( pxReturn->u.xTCP.xPacket.u.ucLastPacket ), ( const void * ) ( pxNet
3405:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
3406:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	return pxReturn;
3407:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** }
3408:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
3409:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3410:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
3411:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * Duplicates a socket after a listening socket receives a connection.
3412:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
3413:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** static BaseType_t prvTCPSocketCopy( FreeRTOS_Socket_t *pxNewSocket, FreeRTOS_Socket_t *pxSocket )
3414:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** {
3415:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** struct freertos_sockaddr xAddress;
3416:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** BaseType_t xResult;
3417:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3418:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	pxNewSocket->xReceiveBlockTime = pxSocket->xReceiveBlockTime;
 2583              	 .loc 1 3418 0
 2584 0168 E369     	 ldr r3,[r4,#28]
 2585 016a C361     	 str r3,[r0,#28]
3419:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	pxNewSocket->xSendBlockTime = pxSocket->xSendBlockTime;
 2586              	 .loc 1 3419 0
 2587 016c 236A     	 ldr r3,[r4,#32]
 2588 016e 0362     	 str r3,[r0,#32]
3420:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	pxNewSocket->ucSocketOptions = pxSocket->ucSocketOptions;
 2589              	 .loc 1 3420 0
 2590 0170 94F82630 	 ldrb r3,[r4,#38]
 2591 0174 80F82630 	 strb r3,[r0,#38]
3421:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	pxNewSocket->u.xTCP.uxRxStreamSize = pxSocket->u.xTCP.uxRxStreamSize;
 2592              	 .loc 1 3421 0
 2593 0178 E36E     	 ldr r3,[r4,#108]
 2594 017a C366     	 str r3,[r0,#108]
3422:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	pxNewSocket->u.xTCP.uxTxStreamSize = pxSocket->u.xTCP.uxTxStreamSize;
 2595              	 .loc 1 3422 0
 2596 017c 236F     	 ldr r3,[r4,#112]
 2597 017e 0367     	 str r3,[r0,#112]
3423:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	pxNewSocket->u.xTCP.uxLittleSpace = pxSocket->u.xTCP.uxLittleSpace;
 2598              	 .loc 1 3423 0
 2599 0180 636E     	 ldr r3,[r4,#100]
 2600 0182 4366     	 str r3,[r0,#100]
3424:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	pxNewSocket->u.xTCP.uxEnoughSpace = pxSocket->u.xTCP.uxEnoughSpace;
 2601              	 .loc 1 3424 0
 2602 0184 A36E     	 ldr r3,[r4,#104]
 2603 0186 8366     	 str r3,[r0,#104]
3425:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	pxNewSocket->u.xTCP.uxRxWinSize  = pxSocket->u.xTCP.uxRxWinSize;
 2604              	 .loc 1 3425 0
 2605 0188 D4F8D030 	 ldr r3,[r4,#208]
 2606 018c C0F8D030 	 str r3,[r0,#208]
3426:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	pxNewSocket->u.xTCP.uxTxWinSize  = pxSocket->u.xTCP.uxTxWinSize;
 2607              	 .loc 1 3426 0
 2608 0190 D4F8D430 	 ldr r3,[r4,#212]
 2609 0194 C0F8D430 	 str r3,[r0,#212]
3427:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3428:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#if( ipconfigSOCKET_HAS_USER_SEMAPHORE == 1 )
3429:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
3430:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxNewSocket->pxUserSemaphore = pxSocket->pxUserSemaphore;
3431:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
3432:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#endif /* ipconfigSOCKET_HAS_USER_SEMAPHORE */
3433:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3434:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#if( ipconfigUSE_CALLBACKS == 1 )
3435:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
3436:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* In case call-backs are used, copy them from parent to child. */
3437:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxNewSocket->u.xTCP.pxHandleConnected = pxSocket->u.xTCP.pxHandleConnected;
3438:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxNewSocket->u.xTCP.pxHandleReceive = pxSocket->u.xTCP.pxHandleReceive;
3439:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxNewSocket->u.xTCP.pxHandleSent = pxSocket->u.xTCP.pxHandleSent;
3440:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
3441:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#endif /* ipconfigUSE_CALLBACKS */
3442:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3443:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
3444:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
3445:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Child socket of listening sockets will inherit the Socket Set
3446:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		Otherwise the owner has no chance of including it into the set. */
3447:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( pxSocket->pxSocketSet != NULL )
 2610              	 .loc 1 3447 0
 2611 0198 E36A     	 ldr r3,[r4,#44]
 2612 019a 23B1     	 cbz r3,.L189
3448:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
3449:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxNewSocket->pxSocketSet = pxSocket->pxSocketSet;
 2613              	 .loc 1 3449 0
 2614 019c C362     	 str r3,[r0,#44]
3450:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxNewSocket->xSelectBits = pxSocket->xSelectBits | ( ( EventBits_t ) eSELECT_READ ) | ( ( EventB
 2615              	 .loc 1 3450 0
 2616 019e 236B     	 ldr r3,[r4,#48]
 2617 01a0 43F00503 	 orr r3,r3,#5
 2618 01a4 0363     	 str r3,[r0,#48]
 2619              	.L189:
3451:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
3452:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
3453:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#endif /* ipconfigSUPPORT_SELECT_FUNCTION */
3454:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3455:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	/* And bind it to the same local port as its parent. */
3456:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	xAddress.sin_addr = *ipLOCAL_IP_ADDRESS_POINTER;
 2620              	 .loc 1 3456 0
 2621 01a6 A74B     	 ldr r3,.L300
 2622 01a8 5B69     	 ldr r3,[r3,#20]
 2623 01aa 0893     	 str r3,[sp,#32]
3457:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	xAddress.sin_port = FreeRTOS_htons( pxSocket->usLocalPort );
 2624              	 .loc 1 3457 0
 2625 01ac A28C     	 ldrh r2,[r4,#36]
 2626 01ae 130A     	 lsrs r3,r2,#8
 2627 01b0 43EA0223 	 orr r3,r3,r2,lsl#8
 2628 01b4 ADF81E30 	 strh r3,[sp,#30]
3458:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3459:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#if( ipconfigTCP_HANG_PROTECTION == 1 )
3460:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
3461:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Only when there is anti-hanging protection, a socket may become an
3462:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		orphan temporarily.  Once this socket is really connected, the owner of
3463:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		the server socket will be notified. */
3464:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3465:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* When bPassQueued is true, the socket is an orphan until it gets
3466:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		connected. */
3467:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxNewSocket->u.xTCP.bits.bPassQueued = pdTRUE_UNSIGNED;
 2629              	 .loc 1 3467 0
 2630 01b8 95F84030 	 ldrb r3,[r5,#64]
 2631 01bc 43F00403 	 orr r3,r3,#4
 2632 01c0 85F84030 	 strb r3,[r5,#64]
3468:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxNewSocket->u.xTCP.pxPeerSocket = pxSocket;
 2633              	 .loc 1 3468 0
 2634 01c4 6C65     	 str r4,[r5,#84]
3469:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
3470:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#else
3471:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
3472:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* A reference to the new socket may be stored and the socket is marked
3473:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		as 'passable'. */
3474:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3475:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* When bPassAccept is true, this socket may be returned in a call to
3476:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		accept(). */
3477:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxNewSocket->u.xTCP.bits.bPassAccept = pdTRUE_UNSIGNED;
3478:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if(pxSocket->u.xTCP.pxPeerSocket == NULL )
3479:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
3480:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxSocket->u.xTCP.pxPeerSocket = pxNewSocket;
3481:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
3482:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
3483:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#endif
3484:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3485:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	pxSocket->u.xTCP.usChildCount++;
 2635              	 .loc 1 3485 0
 2636 01c6 B4F84E30 	 ldrh r3,[r4,#78]
 2637 01ca 0133     	 adds r3,r3,#1
 2638 01cc A4F84E30 	 strh r3,[r4,#78]
3486:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3487:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	FreeRTOS_debug_printf( ( "Gain: Socket %u now has %u / %u child%s\n",
3488:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxSocket->usLocalPort,
3489:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxSocket->u.xTCP.usChildCount,
3490:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxSocket->u.xTCP.usBacklog,
3491:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		( pxSocket->u.xTCP.usChildCount == 1U ) ? "" : "ren" ) );
3492:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3493:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	/* Now bind the child socket to the same port as the listening socket. */
3494:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( vSocketBind ( pxNewSocket, &xAddress, sizeof( xAddress ), pdTRUE ) != 0 )
 2639              	 .loc 1 3494 0
 2640 01d0 2846     	 mov r0,r5
 2641              	.LVL329:
 2642 01d2 07A9     	 add r1,sp,#28
 2643 01d4 0822     	 movs r2,#8
 2644 01d6 0123     	 movs r3,#1
 2645 01d8 FFF7FEFF 	 bl vSocketBind
 2646              	.LVL330:
 2647 01dc 0028     	 cmp r0,#0
 2648 01de 00F08284 	 beq .L190
3495:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
3496:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		FreeRTOS_debug_printf( ( "TCP: Listen: new socket bind error\n" ) );
3497:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		( void ) vSocketClose( pxNewSocket );
 2649              	 .loc 1 3497 0
 2650 01e2 2846     	 mov r0,r5
 2651 01e4 FFF7FEFF 	 bl vSocketClose
 2652              	.LVL331:
 2653 01e8 0024     	 movs r4,#0
 2654 01ea 39E0     	 b .L191
 2655              	.LVL332:
 2656              	.L185:
 2657              	.LBE291:
 2658              	.LBE290:
 2659              	.LBE289:
 2660              	.LBB292:
3387:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		&( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + xIPHeaderSize( pxNetworkBuffer ) ] 
 2661              	 .loc 1 3387 0
 2662 01ec B169     	 ldr r1,[r6,#24]
 2663              	.LVL333:
3390:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxReturn->u.xTCP.ulRemoteIP = FreeRTOS_htonl( pxTCPPacket->xIPHeader.ulSourceIPAddress );
 2664              	 .loc 1 3390 0
 2665 01ee B8F82220 	 ldrh r2,[r8,#34]
 2666 01f2 130A     	 lsrs r3,r2,#8
 2667 01f4 43EA0223 	 orr r3,r3,r2,lsl#8
 2668 01f8 AB87     	 strh r3,[r5,#60]
3391:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxReturn->u.xTCP.xTCPWindow.ulOurSequenceNumber = ulInitialSequenceNumber;
 2669              	 .loc 1 3391 0
 2670 01fa D8F81A20 	 ldr r2,[r8,#26]
 2671 01fe 1306     	 lsls r3,r2,#24
 2672 0200 43EA1263 	 orr r3,r3,r2,lsr#24
 2673 0204 02F47F40 	 and r0,r2,#65280
 2674 0208 43EA0023 	 orr r3,r3,r0,lsl#8
 2675 020c 02F47F02 	 and r2,r2,#16711680
 2676 0210 43EA1223 	 orr r3,r3,r2,lsr#8
 2677 0214 AB63     	 str r3,[r5,#56]
3392:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 2678              	 .loc 1 3392 0
 2679 0216 C5F80471 	 str r7,[r5,#260]
3395:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		prvSocketSetMSS( pxReturn );
 2680              	 .loc 1 3395 0
 2681 021a D1F82620 	 ldr r2,[r1,#38]
 2682 021e 1306     	 lsls r3,r2,#24
 2683 0220 43EA1263 	 orr r3,r3,r2,lsr#24
 2684 0224 02F47F41 	 and r1,r2,#65280
 2685              	.LVL334:
 2686 0228 43EA0123 	 orr r3,r3,r1,lsl#8
 2687 022c 02F47F02 	 and r2,r2,#16711680
 2688 0230 43EA1223 	 orr r3,r3,r2,lsr#8
 2689 0234 C5F8E830 	 str r3,[r5,#232]
 2690              	.LVL335:
 2691              	.LBB293:
 2692              	.LBB294:
3067:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	pxSocket->u.xTCP.usCurMSS  = ( uint16_t ) ulMSS;
 2693              	 .loc 1 3067 0
 2694 0238 4FF49163 	 mov r3,#1160
 2695 023c A5F84C30 	 strh r3,[r5,#76]
3068:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** }
 2696              	 .loc 1 3068 0
 2697 0240 A5F84A30 	 strh r3,[r5,#74]
 2698              	.LBE294:
 2699              	.LBE293:
3398:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 2700              	 .loc 1 3398 0
 2701 0244 2846     	 mov r0,r5
 2702 0246 FFF7FEFF 	 bl prvTCPCreateWindow
 2703              	.LVL336:
3400:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 2704              	 .loc 1 3400 0
 2705 024a 2846     	 mov r0,r5
 2706 024c 0321     	 movs r1,#3
 2707 024e FFF7FEFF 	 bl vTCPStateChange
 2708              	.LVL337:
3404:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 2709              	 .loc 1 3404 0
 2710 0252 05F18200 	 add r0,r5,#130
 2711 0256 B169     	 ldr r1,[r6,#24]
 2712 0258 4622     	 movs r2,#70
 2713 025a FFF7FEFF 	 bl memcpy
 2714              	.LVL338:
 2715 025e 2C46     	 mov r4,r5
 2716              	.LVL339:
 2717              	.L191:
 2718              	.LBE292:
 2719              	.LBE288:
 2720              	.LBE287:
3246:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 2721              	 .loc 1 3246 0
 2722 0260 002C     	 cmp r4,#0
 2723 0262 61D1     	 bne .L192
 2724 0264 0020     	 movs r0,#0
 2725 0266 00F092BC 	 b .L286
 2726              	.LVL340:
 2727              	.L181:
3187:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
 2728              	 .loc 1 3187 0
 2729 026a 1BF0040F 	 tst fp,#4
 2730 026e 42D0     	 beq .L193
3192:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					{
 2731              	 .loc 1 3192 0
 2732 0270 022B     	 cmp r3,#2
 2733 0272 15D1     	 bne .L194
3196:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						{
 2734              	 .loc 1 3196 0
 2735 0274 D0F80431 	 ldr r3,[r0,#260]
 2736              	.LVL341:
 2737 0278 5A1C     	 adds r2,r3,#1
3098:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** BaseType_t xResult = pdPASS;
 2738              	 .loc 1 3098 0
 2739 027a 330E     	 lsrs r3,r6,#24
 2740 027c 43EA0663 	 orr r3,r3,r6,lsl#24
 2741 0280 06F47F41 	 and r1,r6,#65280
 2742 0284 43EA0123 	 orr r3,r3,r1,lsl#8
 2743 0288 06F47F06 	 and r6,r6,#16711680
 2744              	.LVL342:
 2745 028c 43EA1623 	 orr r3,r3,r6,lsr#8
3196:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						{
 2746              	 .loc 1 3196 0
 2747 0290 9A42     	 cmp r2,r3
 2748 0292 40F02C84 	 bne .L180
3198:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						}
 2749              	 .loc 1 3198 0
 2750 0296 0021     	 movs r1,#0
 2751 0298 FFF7FEFF 	 bl vTCPStateChange
 2752              	.LVL343:
 2753 029c 00F027BC 	 b .L180
 2754              	.LVL344:
 2755              	.L194:
3097:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint32_t ulAckNumber = FreeRTOS_ntohl( pxProtocolHeaders->xTCPHeader.ulAckNr );;
 2756              	 .loc 1 3097 0
 2757 02a0 2B0E     	 lsrs r3,r5,#24
 2758              	.LVL345:
 2759 02a2 43EA0563 	 orr r3,r3,r5,lsl#24
 2760 02a6 05F47F42 	 and r2,r5,#65280
 2761 02aa 43EA0223 	 orr r3,r3,r2,lsl#8
 2762 02ae 05F47F05 	 and r5,r5,#16711680
 2763              	.LVL346:
 2764 02b2 43EA1523 	 orr r3,r3,r5,lsr#8
3204:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						{
 2765              	 .loc 1 3204 0
 2766 02b6 D0F8E810 	 ldr r1,[r0,#232]
 2767 02ba 9942     	 cmp r1,r3
 2768 02bc 04D1     	 bne .L195
3206:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						}
 2769              	 .loc 1 3206 0
 2770 02be 0021     	 movs r1,#0
 2771 02c0 FFF7FEFF 	 bl vTCPStateChange
 2772              	.LVL347:
 2773 02c4 00F013BC 	 b .L180
 2774              	.LVL348:
 2775              	.L195:
3209:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 								 ( ulSequenceNumber < ( pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber +
 2776              	 .loc 1 3209 0
 2777 02c8 8B42     	 cmp r3,r1
 2778 02ca 40F21084 	 bls .L180
3210:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 													  pxSocket->u.xTCP.xTCPWindow.xSize.ulRxWindowLength ) ) )
 2779              	 .loc 1 3210 0 discriminator 1
 2780 02ce D0F8DC20 	 ldr r2,[r0,#220]
 2781 02d2 0A44     	 add r2,r2,r1
3209:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 								 ( ulSequenceNumber < ( pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber +
 2782              	 .loc 1 3209 0 discriminator 1
 2783 02d4 9342     	 cmp r3,r2
 2784 02d6 80F00A84 	 bcs .L180
3214:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						}
 2785              	 .loc 1 3214 0
 2786 02da 0999     	 ldr r1,[sp,#36]
 2787              	.LVL349:
 2788              	.LBB296:
 2789              	.LBB297:
 2790              	.LBB298:
3025:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		const uint32_t ulSendLength = ( uint32_t )
 2791              	 .loc 1 3025 0
 2792 02dc 8B69     	 ldr r3,[r1,#24]
 2793              	.LVL350:
3029:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPPacket->xTCPHeader.ucTCPOffset = ( ipSIZE_OF_TCP_HEADER ) << 2;
 2794              	 .loc 1 3029 0
 2795 02de 1022     	 movs r2,#16
 2796 02e0 83F82F20 	 strb r2,[r3,#47]
 2797              	.LVL351:
3030:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 2798              	 .loc 1 3030 0
 2799 02e4 5022     	 movs r2,#80
 2800 02e6 83F82E20 	 strb r2,[r3,#46]
3032:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 2801              	 .loc 1 3032 0
 2802 02ea 0020     	 movs r0,#0
 2803              	.LVL352:
 2804 02ec 2822     	 movs r2,#40
 2805 02ee 0346     	 mov r3,r0
 2806              	.LVL353:
 2807 02f0 FFF7FEFF 	 bl prvTCPReturnPacket
 2808              	.LVL354:
 2809 02f4 FBE3     	 b .L180
 2810              	.LVL355:
 2811              	.L193:
 2812              	.LBE298:
 2813              	.LBE297:
 2814              	.LBE296:
3225:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
 2815              	 .loc 1 3225 0
 2816 02f6 0BF01F02 	 and r2,fp,#31
 2817 02fa 022A     	 cmp r2,#2
 2818 02fc 02D1     	 bne .L196
3225:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
 2819              	 .loc 1 3225 0 is_stmt 0 discriminator 1
 2820 02fe 042B     	 cmp r3,#4
 2821 0300 00F2F583 	 bhi .L180
 2822              	.L196:
 2823              	.LVL356:
 2824              	.LBB299:
3239:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 									 ( const void * ) ( &( pxNetworkBuffer->pucEthernetBuffer[ lOffset ] ) ),
 2825              	 .loc 1 3239 0 is_stmt 1
 2826 0304 099A     	 ldr r2,[sp,#36]
 2827 0306 9269     	 ldr r2,[r2,#24]
 2828 0308 52F8221F 	 ldr r1,[r2,#34]!
 2829 030c 5668     	 ldr r6,[r2,#4]
 2830              	.LVL357:
 2831 030e 9568     	 ldr r5,[r2,#8]
 2832              	.LVL358:
 2833 0310 D068     	 ldr r0,[r2,#12]
 2834              	.LVL359:
 2835 0312 C4F8A410 	 str r1,[r4,#164]
 2836 0316 C4F8A860 	 str r6,[r4,#168]
 2837 031a C4F8AC50 	 str r5,[r4,#172]
 2838 031e C4F8B000 	 str r0,[r4,#176]
 2839 0322 1169     	 ldr r1,[r2,#16]
 2840 0324 C4F8B410 	 str r1,[r4,#180]
 2841              	.LVL360:
 2842              	.L192:
 2843              	.LBE299:
 2844              	.LBB300:
 2845              	.LBB301:
 2846              	.LBB302:
1490:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 2847              	 .loc 1 1490 0
 2848 0328 FFF7FEFF 	 bl xTaskGetTickCount
 2849              	.LVL361:
 2850 032c 2066     	 str r0,[r4,#96]
1496:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxSocket->u.xTCP.bits.bSendKeepAlive = pdFALSE_UNSIGNED;
 2851              	 .loc 1 1496 0
 2852 032e 94F84130 	 ldrb r3,[r4,#65]
1497:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxSocket->u.xTCP.ucKeepRepCount = 0U;
 2853              	 .loc 1 1497 0
 2854 0332 03F0FB03 	 and r3,r3,#251
 2855 0336 6FF34103 	 bfc r3,#1,#1
 2856 033a 84F84130 	 strb r3,[r4,#65]
1498:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxSocket->u.xTCP.xLastAliveTime = xTaskGetTickCount();
 2857              	 .loc 1 1498 0
 2858 033e 0023     	 movs r3,#0
 2859 0340 84F85830 	 strb r3,[r4,#88]
1499:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 2860              	 .loc 1 1499 0
 2861 0344 FFF7FEFF 	 bl xTaskGetTickCount
 2862              	.LVL362:
 2863 0348 E065     	 str r0,[r4,#92]
 2864              	.LBE302:
 2865              	.LBE301:
3262:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 2866              	 .loc 1 3262 0
 2867 034a 99F82E30 	 ldrb r3,[r9,#46]
 2868 034e 03F0F003 	 and r3,r3,#240
 2869 0352 502B     	 cmp r3,#80
 2870 0354 40F2D580 	 bls .L197
3264:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 2871              	 .loc 1 3264 0
 2872 0358 0999     	 ldr r1,[sp,#36]
 2873              	.LVL363:
 2874              	.LBB303:
 2875              	.LBB304:
1149:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	&( pxNetworkBuffer->pucEthernetBuffer[ uxTCPHeaderOffset ] ) );
 2876              	 .loc 1 1149 0
 2877 035a 8A69     	 ldr r2,[r1,#24]
 2878              	.LVL364:
1164:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( pxTCPHeader->ucTCPOffset <= ( 5U << 4U ) )
 2879              	 .loc 1 1164 0
 2880 035c 02F13607 	 add r7,r2,#54
 2881              	.LVL365:
1165:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 2882              	 .loc 1 1165 0
 2883 0360 92F82E30 	 ldrb r3,[r2,#46]
 2884 0364 502B     	 cmp r3,#80
 2885 0366 40F2CC80 	 bls .L197
 2886              	.LVL366:
1171:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		uxOptionsLength = ( size_t ) ucLength;
 2887              	 .loc 1 1171 0
 2888 036a 1B09     	 lsrs r3,r3,#4
 2889              	.LVL367:
 2890 036c 053B     	 subs r3,r3,#5
 2891 036e 9B00     	 lsls r3,r3,#2
1172:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( pxNetworkBuffer->xDataLength > uxOptionOffset )
 2892              	 .loc 1 1172 0
 2893 0370 5FFA83FA 	 uxtb r10,r3
 2894              	.LVL368:
1173:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 2895              	 .loc 1 1173 0
 2896 0374 CB69     	 ldr r3,[r1,#28]
1176:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				( uxOptionsLength <= ( pxNetworkBuffer->xDataLength - uxOptionOffset ) ) )
 2897              	 .loc 1 1176 0
 2898 0376 362B     	 cmp r3,#54
 2899 0378 40F2C380 	 bls .L197
1177:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 2900              	 .loc 1 1177 0
 2901 037c 363B     	 subs r3,r3,#54
1176:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				( uxOptionsLength <= ( pxNetworkBuffer->xDataLength - uxOptionOffset ) ) )
 2902              	 .loc 1 1176 0
 2903 037e 9A45     	 cmp r10,r3
 2904 0380 00F2BF80 	 bhi .L197
1179:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
 2905              	 .loc 1 1179 0
 2906 0384 92F82F30 	 ldrb r3,[r2,#47]
 2907 0388 03F00203 	 and r3,r3,#2
 2908 038c DBB2     	 uxtb r3,r3
 2909 038e 0493     	 str r3,[sp,#16]
 2910              	.LVL369:
1191:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					{
 2911              	 .loc 1 1191 0
 2912 0390 BAF1000F 	 cmp r10,#0
 2913 0394 00F0B580 	 beq .L197
 2914              	.LBB305:
 2915              	.LBB306:
 2916              	.LBB307:
 2917              	.LBB308:
1368:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 2918              	 .loc 1 1368 0
 2919 0398 04F1D803 	 add r3,r4,#216
 2920 039c 0593     	 str r3,[sp,#20]
 2921              	.LVL370:
 2922              	.L282:
 2923              	.LBE308:
 2924              	.LBE307:
1224:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 2925              	 .loc 1 1224 0
 2926 039e 3B78     	 ldrb r3,[r7]
 2927 03a0 002B     	 cmp r3,#0
 2928 03a2 00F0AE80 	 beq .L197
1229:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 2929              	 .loc 1 1229 0
 2930 03a6 012B     	 cmp r3,#1
 2931 03a8 00F0A383 	 beq .L268
1234:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 2932              	 .loc 1 1234 0
 2933 03ac BAF1010F 	 cmp r10,#1
 2934 03b0 40F2A780 	 bls .L197
1241:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 2935              	 .loc 1 1241 0
 2936 03b4 032B     	 cmp r3,#3
 2937 03b6 16D1     	 bne .L199
1245:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 2938              	 .loc 1 1245 0
 2939 03b8 BAF1020F 	 cmp r10,#2
 2940 03bc 40F2A180 	 bls .L197
 2941 03c0 7B78     	 ldrb r3,[r7,#1]
 2942 03c2 032B     	 cmp r3,#3
 2943 03c4 40F09D80 	 bne .L197
1252:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 2944              	 .loc 1 1252 0
 2945 03c8 049B     	 ldr r3,[sp,#16]
 2946 03ca 002B     	 cmp r3,#0
 2947 03cc 00F09383 	 beq .L269
1254:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxSocket->u.xTCP.bits.bWinScaling = pdTRUE_UNSIGNED;
 2948              	 .loc 1 1254 0
 2949 03d0 BB78     	 ldrb r3,[r7,#2]
 2950 03d2 84F8CA30 	 strb r3,[r4,#202]
1255:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 2951              	 .loc 1 1255 0
 2952 03d6 94F84230 	 ldrb r3,[r4,#66]
 2953 03da 43F01003 	 orr r3,r3,#16
 2954 03de 84F84230 	 strb r3,[r4,#66]
1257:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 2955              	 .loc 1 1257 0
 2956 03e2 0325     	 movs r5,#3
 2957 03e4 88E0     	 b .L201
 2958              	.L199:
1261:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 2959              	 .loc 1 1261 0
 2960 03e6 022B     	 cmp r3,#2
 2961 03e8 2ED1     	 bne .L200
1264:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 2962              	 .loc 1 1264 0
 2963 03ea BAF1030F 	 cmp r10,#3
 2964 03ee 40F28880 	 bls .L197
 2965 03f2 7B78     	 ldrb r3,[r7,#1]
 2966 03f4 042B     	 cmp r3,#4
 2967 03f6 40F08480 	 bne .L197
 2968              	.LVL371:
 2969              	.LBB314:
 2970              	.LBB315:
 2971              	 .file 5 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include/FreeRTOS_IP_Private.h"
   1:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*
   2:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * FreeRTOS+TCP V2.2.2
   3:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  *
   5:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * this software and associated documentation files (the "Software"), to deal in
   7:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * the Software without restriction, including without limitation the rights to
   8:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * subject to the following conditions:
  11:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  *
  12:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * The above copyright notice and this permission notice shall be included in all
  13:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * copies or substantial portions of the Software.
  14:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  *
  15:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  *
  22:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * http://aws.amazon.com/freertos
  23:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * http://www.FreeRTOS.org
  24:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  */
  25:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
  26:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #ifndef FREERTOS_IP_PRIVATE_H
  27:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define FREERTOS_IP_PRIVATE_H
  28:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
  29:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #ifdef __cplusplus
  30:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** extern "C" {
  31:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #endif
  32:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
  33:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* Application level configuration options. */
  34:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "FreeRTOSIPConfig.h"
  35:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "FreeRTOSIPConfigDefaults.h"
  36:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "FreeRTOS_Sockets.h"
  37:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "IPTraceMacroDefaults.h"
  38:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "FreeRTOS_Stream_Buffer.h"
  39:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #if( ipconfigUSE_TCP == 1 )
  40:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#include "FreeRTOS_TCP_WIN.h"
  41:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#include "FreeRTOS_TCP_IP.h"
  42:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #endif
  43:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
  44:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "semphr.h"
  45:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
  46:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "event_groups.h"
  47:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
  48:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*-----------------------------------------------------------*/
  49:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* Utility macros for marking casts as recognized during     */
  50:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* static analysis.                                          */
  51:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*-----------------------------------------------------------*/
  52:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define ipCAST_PTR_TO_TYPE_PTR( TYPE, pointer ) ( vCastPointerTo_##TYPE( ( void * )( pointer ) ) )
  53:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define ipCAST_CONST_PTR_TO_CONST_TYPE_PTR( TYPE, pointer ) ( vCastConstPointerTo_##TYPE( ( const v
  54:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
  55:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*-----------------------------------------------------------*/
  56:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* Utility macros for declaring cast utility functions in    */
  57:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* order to centralize typecasting for static analysis.      */
  58:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*-----------------------------------------------------------*/
  59:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define ipDECL_CAST_PTR_FUNC_FOR_TYPE( TYPE ) TYPE * vCastPointerTo_##TYPE( void * pvArgument )
  60:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define ipDECL_CAST_CONST_PTR_FUNC_FOR_TYPE( TYPE ) const TYPE * vCastConstPointerTo_##TYPE( const 
  61:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
  62:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef struct xNetworkAddressingParameters
  63:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
  64:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint32_t ulDefaultIPAddress;
  65:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint32_t ulNetMask;
  66:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint32_t ulGatewayAddress;
  67:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint32_t ulDNSServerAddress;
  68:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint32_t ulBroadcastAddress;
  69:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** } NetworkAddressingParameters_t;
  70:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
  71:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** extern BaseType_t xTCPWindowLoggingLevel;
  72:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** extern QueueHandle_t xNetworkEventQueue;
  73:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
  74:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*-----------------------------------------------------------*/
  75:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* Protocol headers.                                         */
  76:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*-----------------------------------------------------------*/
  77:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
  78:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_start.h"
  79:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** struct xETH_HEADER
  80:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
  81:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	MACAddress_t xDestinationAddress; /*  0 + 6 = 6  */
  82:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	MACAddress_t xSourceAddress;      /*  6 + 6 = 12 */
  83:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usFrameType;              /* 12 + 2 = 14 */
  84:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
  85:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_end.h"
  86:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef struct xETH_HEADER EthernetHeader_t;
  87:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
  88:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_PTR_FUNC_FOR_TYPE( EthernetHeader_t )
  89:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
  90:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	return ( EthernetHeader_t *)pvArgument;
  91:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
  92:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
  93:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_CONST_PTR_FUNC_FOR_TYPE( EthernetHeader_t )
  94:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
  95:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	return ( const EthernetHeader_t *) pvArgument;
  96:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
  97:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
  98:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
  99:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_start.h"
 100:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** struct xARP_HEADER
 101:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 102:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usHardwareType;				/*  0 +  2 =  2 */
 103:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usProtocolType;				/*  2 +  2 =  4 */
 104:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint8_t ucHardwareAddressLength;		/*  4 +  1 =  5 */
 105:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint8_t ucProtocolAddressLength;		/*  5 +  1 =  6 */
 106:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usOperation;					/*  6 +  2 =  8 */
 107:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	MACAddress_t xSenderHardwareAddress;	/*  8 +  6 = 14 */
 108:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint8_t ucSenderProtocolAddress[ 4 ];	/* 14 +  4 = 18  */
 109:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	MACAddress_t xTargetHardwareAddress;	/* 18 +  6 = 24  */
 110:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint32_t ulTargetProtocolAddress;		/* 24 +  4 = 28  */
 111:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 112:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_end.h"
 113:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef struct xARP_HEADER ARPHeader_t;
 114:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 115:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_start.h"
 116:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** struct xIP_HEADER
 117:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 118:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint8_t ucVersionHeaderLength;        /*  0 + 1 =  1 */
 119:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint8_t ucDifferentiatedServicesCode; /*  1 + 1 =  2 */
 120:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usLength;                    /*  2 + 2 =  4 */
 121:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usIdentification;            /*  4 + 2 =  6 */
 122:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usFragmentOffset;            /*  6 + 2 =  8 */
 123:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint8_t ucTimeToLive;                 /*  8 + 1 =  9 */
 124:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint8_t ucProtocol;                   /*  9 + 1 = 10 */
 125:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usHeaderChecksum;            /* 10 + 2 = 12 */
 126:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint32_t ulSourceIPAddress;           /* 12 + 4 = 16 */
 127:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint32_t ulDestinationIPAddress;      /* 16 + 4 = 20 */
 128:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 129:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_end.h"
 130:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef struct xIP_HEADER IPHeader_t;
 131:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 132:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_PTR_FUNC_FOR_TYPE( IPHeader_t )
 133:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 134:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	return ( IPHeader_t *)pvArgument;
 135:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 136:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_CONST_PTR_FUNC_FOR_TYPE( IPHeader_t )
 137:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 138:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	return ( const IPHeader_t *) pvArgument;
 139:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 140:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 141:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 142:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_start.h"
 143:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** struct xICMP_HEADER
 144:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 145:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint8_t ucTypeOfMessage;   /* 0 + 1 = 1 */
 146:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint8_t ucTypeOfService;   /* 1 + 1 = 2 */
 147:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usChecksum;       /* 2 + 2 = 4 */
 148:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usIdentifier;     /* 4 + 2 = 6 */
 149:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usSequenceNumber; /* 6 + 2 = 8 */
 150:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 151:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_end.h"
 152:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef struct xICMP_HEADER ICMPHeader_t;
 153:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 154:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_PTR_FUNC_FOR_TYPE( ICMPHeader_t )
 155:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 156:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	return ( ICMPHeader_t *)pvArgument;
 157:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 158:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_CONST_PTR_FUNC_FOR_TYPE( ICMPHeader_t )
 159:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 160:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	return ( const ICMPHeader_t *) pvArgument;
 161:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 162:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 163:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 164:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_start.h"
 165:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** struct xUDP_HEADER
 166:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 167:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usSourcePort;      /* 0 + 2 = 2 */
 168:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usDestinationPort; /* 2 + 2 = 4 */
 169:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usLength;          /* 4 + 2 = 6 */
 170:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usChecksum;        /* 6 + 2 = 8 */
 171:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 172:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_end.h"
 173:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef struct xUDP_HEADER UDPHeader_t;
 174:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 175:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_start.h"
 176:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** struct xTCP_HEADER
 177:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 178:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usSourcePort;		/* +  2 =  2 */
 179:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usDestinationPort;	/* +  2 =  4 */
 180:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint32_t ulSequenceNumber;	/* +  4 =  8 */
 181:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint32_t ulAckNr;   	 	/* +  4 = 12 */
 182:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint8_t  ucTCPOffset;		/* +  1 = 13 */
 183:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint8_t  ucTCPFlags;		/* +  1 = 14 */
 184:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usWindow;			/* +  2 = 15 */
 185:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usChecksum;		/* +  2 = 18 */
 186:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usUrgent;			/* +  2 = 20 */
 187:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #if ipconfigUSE_TCP == 1
 188:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	/* the option data is not a part of the TCP header */
 189:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint8_t  ucOptdata[ipSIZE_TCP_OPTIONS];		/* + 12 = 32 */
 190:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #endif
 191:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 192:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_end.h"
 193:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef struct xTCP_HEADER TCPHeader_t;
 194:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 195:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*-----------------------------------------------------------*/
 196:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* Nested protocol packets.                                  */
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*-----------------------------------------------------------*/
 198:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 199:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_start.h"
 200:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** struct xARP_PACKET
 201:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 202:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	EthernetHeader_t xEthernetHeader;	/*  0 + 14 = 14 */
 203:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	ARPHeader_t xARPHeader;			/* 14 + 28 = 42 */
 204:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 205:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_end.h"
 206:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef struct xARP_PACKET ARPPacket_t;
 207:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 208:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_PTR_FUNC_FOR_TYPE( ARPPacket_t )
 209:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 210:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****     return ( ARPPacket_t *)pvArgument;
 211:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 212:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_CONST_PTR_FUNC_FOR_TYPE( ARPPacket_t )
 213:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 214:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****     return ( const ARPPacket_t *) pvArgument;
 215:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 216:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 217:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 218:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_start.h"
 219:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** struct xIP_PACKET
 220:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 221:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	EthernetHeader_t xEthernetHeader;
 222:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	IPHeader_t xIPHeader;
 223:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 224:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_end.h"
 225:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef struct xIP_PACKET IPPacket_t;
 226:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 227:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_PTR_FUNC_FOR_TYPE( IPPacket_t )
 228:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 229:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****     return ( IPPacket_t *)pvArgument;
 230:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 231:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_CONST_PTR_FUNC_FOR_TYPE( IPPacket_t )
 232:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 233:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****     return ( const IPPacket_t *) pvArgument;
 234:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 235:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 236:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 237:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_start.h"
 238:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** struct xICMP_PACKET
 239:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 240:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	EthernetHeader_t xEthernetHeader;
 241:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	IPHeader_t xIPHeader;
 242:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	ICMPHeader_t xICMPHeader;
 243:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 244:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_end.h"
 245:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef struct xICMP_PACKET ICMPPacket_t;
 246:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 247:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_PTR_FUNC_FOR_TYPE( ICMPPacket_t )
 248:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 249:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****     return ( ICMPPacket_t *)pvArgument;
 250:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 251:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 252:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 253:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_start.h"
 254:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** struct xUDP_PACKET
 255:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 256:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	EthernetHeader_t xEthernetHeader; /*  0 + 14 = 14 */
 257:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	IPHeader_t xIPHeader;             /* 14 + 20 = 34 */
 258:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	UDPHeader_t xUDPHeader;           /* 34 +  8 = 42 */
 259:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 260:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_end.h"
 261:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef struct xUDP_PACKET UDPPacket_t;
 262:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 263:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_PTR_FUNC_FOR_TYPE( UDPPacket_t )
 264:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 265:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****     return ( UDPPacket_t *)pvArgument;
 266:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 267:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_CONST_PTR_FUNC_FOR_TYPE( UDPPacket_t )
 268:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 269:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****     return ( const UDPPacket_t *) pvArgument;
 270:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 271:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 272:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_start.h"
 273:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** struct xTCP_PACKET
 274:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 275:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	EthernetHeader_t xEthernetHeader; /*  0 + 14 = 14 */
 276:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	IPHeader_t xIPHeader;             /* 14 + 20 = 34 */
 277:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	TCPHeader_t xTCPHeader;           /* 34 + 32 = 66 */
 278:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 279:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_end.h"
 280:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef struct xTCP_PACKET TCPPacket_t;
 281:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 282:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_PTR_FUNC_FOR_TYPE( TCPPacket_t )
 283:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 284:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****     return ( TCPPacket_t *)pvArgument;
 285:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 286:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 287:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_CONST_PTR_FUNC_FOR_TYPE( TCPPacket_t )
 288:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 289:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	return ( const TCPPacket_t *) pvArgument;
 290:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 291:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 292:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 293:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef union XPROT_PACKET
 294:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 295:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	ARPPacket_t xARPPacket;
 296:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	TCPPacket_t xTCPPacket;
 297:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	UDPPacket_t xUDPPacket;
 298:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	ICMPPacket_t xICMPPacket;
 299:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** } ProtocolPacket_t;
 300:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 301:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_PTR_FUNC_FOR_TYPE( ProtocolPacket_t )
 302:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 303:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	return ( ProtocolPacket_t *)pvArgument;
 304:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 305:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_CONST_PTR_FUNC_FOR_TYPE( ProtocolPacket_t )
 306:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 307:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	return ( const ProtocolPacket_t *) pvArgument;
 308:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 309:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 310:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef union xPROT_HEADERS
 311:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 312:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	ICMPHeader_t xICMPHeader;
 313:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	UDPHeader_t xUDPHeader;
 314:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	TCPHeader_t xTCPHeader;
 315:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** } ProtocolHeaders_t;
 316:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 317:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_PTR_FUNC_FOR_TYPE( ProtocolHeaders_t )
 318:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 319:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	return ( ProtocolHeaders_t *)pvArgument;
 320:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 321:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 322:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_CONST_PTR_FUNC_FOR_TYPE( ProtocolHeaders_t )
 323:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 324:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	return ( const ProtocolHeaders_t *) pvArgument;
 325:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 326:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 327:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* The maximum UDP payload length. */
 328:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define ipMAX_UDP_PAYLOAD_LENGTH ( ( ipconfigNETWORK_MTU - ipSIZE_OF_IPv4_HEADER ) - ipSIZE_OF_UDP_
 329:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 330:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* The maximum RAW payload length */
 331:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define ipMAX_RAW_PAYLOAD_LENGTH ( ipconfigNETWORK_MTU )
 332:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 333:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 334:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef enum
 335:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 336:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eReleaseBuffer = 0,		/* Processing the frame did not find anything to do - just release the buffer
 337:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eProcessBuffer,			/* An Ethernet frame has a valid address - continue process its contents. */
 338:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eReturnEthernetFrame,	/* The Ethernet frame contains an ARP or ICMP packet that can be returned to
 339:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eFrameConsumed			/* Processing the Ethernet packet contents resulted in the payload being sent to 
 340:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** } eFrameProcessingResult_t;
 341:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 342:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef enum
 343:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 344:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eNoEvent = -1,
 345:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eNetworkDownEvent,		/* 0: The network interface has been lost and/or needs [re]connecting. */
 346:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eNetworkRxEvent,		/* 1: The network interface has queued a received Ethernet frame. */
 347:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eNetworkTxEvent,		/* 2: Let the IP-task send a network packet. */
 348:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eARPTimerEvent,			/* 3: The ARP timer expired. */
 349:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eStackTxEvent,			/* 4: The software stack has queued a packet to transmit. */
 350:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eDHCPEvent,				/* 5: Process the DHCP state machine. */
 351:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eTCPTimerEvent,			/* 6: See if any TCP socket needs attention. */
 352:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eTCPAcceptEvent,		/* 7: Client API FreeRTOS_accept() waiting for client connections. */
 353:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eTCPNetStat,			/* 8: IP-task is asked to produce a netstat listing. */
 354:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eSocketBindEvent,		/* 9: Send a message to the IP-task to bind a socket to a port. */
 355:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eSocketCloseEvent,		/*10: Send a message to the IP-task to close a socket. */
 356:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eSocketSelectEvent,		/*11: Send a message to the IP-task for select(). */
 357:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eSocketSignalEvent,		/*12: A socket must be signalled. */
 358:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eStackRAWTxEvent,
 359:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** } eIPEvent_t;
 360:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 361:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef struct IP_TASK_COMMANDS
 362:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 363:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eIPEvent_t eEventType;
 364:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	void *pvData;
 365:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** } IPStackEvent_t;
 366:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 367:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define ipBROADCAST_IP_ADDRESS 0xffffffffUL
 368:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 369:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* Offset into the Ethernet frame that is used to temporarily store information
 370:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** on the fragmentation status of the packet being sent.  The value is important,
 371:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** as it is past the location into which the destination address will get placed. */
 372:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define ipFRAGMENTATION_PARAMETERS_OFFSET		( 6 )
 373:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define ipSOCKET_OPTIONS_OFFSET					( 6 )
 374:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 375:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* Only used when outgoing fragmentation is being used (FreeRTOSIPConfig.h
 376:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** setting. */
 377:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define ipGET_UDP_PAYLOAD_OFFSET_FOR_FRAGMENT( usFragmentOffset ) ( ( ( usFragmentOffset ) == 0 ) ?
 378:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 379:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* The offset into a UDP packet at which the UDP data (payload) starts. */
 380:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define ipUDP_PAYLOAD_OFFSET_IPv4	( sizeof( UDPPacket_t ) )
 381:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 382:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* The offset into an IP packet into which the IP data (payload) starts. */
 383:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define ipIP_PAYLOAD_OFFSET		( sizeof( IPPacket_t ) )
 384:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 385:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #if( ipconfigBYTE_ORDER == pdFREERTOS_LITTLE_ENDIAN )
 386:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 387:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	/* Ethernet frame types. */
 388:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#define ipARP_FRAME_TYPE	( 0x0608U )
 389:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#define ipIPv4_FRAME_TYPE	( 0x0008U )
 390:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 391:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	/* ARP related definitions. */
 392:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#define ipARP_PROTOCOL_TYPE				( 0x0008U )
 393:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#define ipARP_HARDWARE_TYPE_ETHERNET	( 0x0100U )
 394:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#define ipARP_REQUEST					( 0x0100U )
 395:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#define ipARP_REPLY						( 0x0200U )
 396:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 397:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #else
 398:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 399:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	/* Ethernet frame types. */
 400:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#define ipARP_FRAME_TYPE	( 0x0806U )
 401:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#define ipIPv4_FRAME_TYPE	( 0x0800U )
 402:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 403:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	/* ARP related definitions. */
 404:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#define ipARP_PROTOCOL_TYPE ( 0x0800U )
 405:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#define ipARP_HARDWARE_TYPE_ETHERNET ( 0x0001U )
 406:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#define ipARP_REQUEST ( 0x0001 )
 407:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#define ipARP_REPLY ( 0x0002 )
 408:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 409:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #endif /* ipconfigBYTE_ORDER == pdFREERTOS_LITTLE_ENDIAN */
 410:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 411:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 412:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* For convenience, a MAC address of all zeros and another of all 0xffs are
 413:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** defined const for quick reference. */
 414:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** extern const MACAddress_t xBroadcastMACAddress; /* all 0xff's */
 415:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** extern uint16_t usPacketIdentifier;
 416:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 417:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* Define a default UDP packet header (declared in FreeRTOS_UDP_IP.c) */
 418:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef union xUDPPacketHeader
 419:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 420:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint8_t ucBytes[24];
 421:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint32_t ulWords[6];
 422:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** } UDPPacketHeader_t;
 423:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** extern UDPPacketHeader_t xDefaultPartUDPPacketHeader;
 424:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** extern UDPPacketHeader_t xDefaultPartRAWPacketHeader;
 425:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 426:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* Structure that stores the netmask, gateway address and DNS server addresses. */
 427:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** extern NetworkAddressingParameters_t xNetworkAddressing;
 428:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 429:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* Structure that stores the defaults for netmask, gateway address and DNS.
 430:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** These values will be copied to 'xNetworkAddressing' in case DHCP is not used,
 431:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** and also in case DHCP does not lead to a confirmed request. */
 432:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*lint -e9003*/
 433:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** extern NetworkAddressingParameters_t xDefaultAddressing;	/*lint !e9003 could define variable 'xDefa
 434:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 435:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* True when BufferAllocation_1.c was included, false for BufferAllocation_2.c */
 436:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** extern const BaseType_t xBufferAllocFixedSize;
 437:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 438:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* Defined in FreeRTOS_Sockets.c */
 439:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #if ( ipconfigUSE_TCP == 1 )
 440:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	extern List_t xBoundTCPSocketsList;
 441:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #endif
 442:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 443:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* The local IP address is accessed from within xDefaultPartUDPPacketHeader,
 444:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** rather than duplicated in its own variable. */
 445:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define ipLOCAL_IP_ADDRESS_POINTER ( ( uint32_t * ) &( xDefaultPartUDPPacketHeader.ulWords[ 20U / s
 446:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 447:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* The local MAC address is accessed from within xDefaultPartUDPPacketHeader,
 448:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** rather than duplicated in its own variable. */
 449:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define ipLOCAL_MAC_ADDRESS ( xDefaultPartUDPPacketHeader.ucBytes )
 450:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 451:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* In this library, there is often a cast from a character pointer
 452:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * to a pointer to a struct.
 453:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * In order to suppress MISRA warnings, do the cast within a macro,
 454:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * which can be exempt from warnings:
 455:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  *
 456:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * 3 required by MISRA:
 457:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * -emacro(740,ipPOINTER_CAST)    // 750:  Unusual pointer cast (incompatible indirect types) [MISR
 458:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * -emacro(9005,ipPOINTER_CAST)   // 9005: attempt to cast away const/volatile from a pointer or re
 459:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * -emacro(9087,ipPOINTER_CAST)   // 9087: cast performed between a pointer to object type and a po
 460:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  *
 461:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * 2 advisory by MISRA:
 462:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * -emacro(9079,ipPOINTER_CAST)   // 9079: conversion from pointer to void to pointer to other type
 463:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * --emacro((826),ipPOINTER_CAST) // 826:  Suspicious pointer-to-pointer conversion (area too small
 464:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * 
 465:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * The MISRA warnings can safely be suppressed because all casts are planned with care.
 466:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  */
 467:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 468:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define ipPOINTER_CAST( TYPE, pointer  ) ( ( TYPE ) ( pointer ) )
 469:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 470:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* Sequence and ACK numbers are essentially unsigned (uint32_t). But when
 471:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * a distance is calculated, it is useful to use signed numbers:
 472:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * int32_t lDistance = ( int32_t ) ( ulSeq1 - ulSeq2 );
 473:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  *
 474:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * 1 required by MISRA:
 475:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * -emacro(9033,ipNUMERIC_CAST) // 9033: Impermissible cast of composite expression (different esse
 476:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  *
 477:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * 1 advisory by MISRA:
 478:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * -emacro(9030,ipNUMERIC_CAST) // 9030: Impermissible cast; cannot cast from 'essentially Boolean'
 479:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  */
 480:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 481:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define ipNUMERIC_CAST( TYPE, expression  ) ( ( TYPE ) ( expression ) )
 482:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 483:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* ICMP packets are sent using the same function as UDP packets.  The port
 484:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** number is used to distinguish between the two, as 0 is an invalid UDP port. */
 485:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define ipPACKET_CONTAINS_ICMP_DATA					( 0 )
 486:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 487:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* For now, the lower 8 bits in 'xEventBits' will be reserved for the above
 488:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** socket events. */
 489:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define SOCKET_EVENT_BIT_COUNT   8
 490:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 491:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define vSetField16( pxBase, xType, xField, usValue ) \
 492:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** { \
 493:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	( ( uint8_t* )( pxBase ) ) [ offsetof( xType, xField ) + 0 ] = ( uint8_t ) ( ( usValue ) >> 8 ); \
 494:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	( ( uint8_t* )( pxBase ) ) [ offsetof( xType, xField ) + 1 ] = ( uint8_t ) ( ( usValue ) & 0xffU )
 495:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 496:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 497:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define vSetField32( pxBase, xType, xField, ulValue ) \
 498:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** { \
 499:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	( (uint8_t*)( pxBase ) ) [ offsetof( xType, xField ) + 0 ] = ( uint8_t )   ( ( ulValue ) >> 24 ); 
 500:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	( (uint8_t*)( pxBase ) ) [ offsetof( xType, xField ) + 1 ] = ( uint8_t ) ( ( ( ulValue ) >> 16 ) &
 501:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	( (uint8_t*)( pxBase ) ) [ offsetof( xType, xField ) + 2 ] = ( uint8_t ) ( ( ( ulValue ) >> 8 ) & 
 502:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	( (uint8_t*)( pxBase ) ) [ offsetof( xType, xField ) + 3 ] = ( uint8_t )   ( ( ulValue ) & 0xffU )
 503:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 504:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 505:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define vFlip_16( left, right ) \
 506:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	do { \
 507:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		uint16_t tmp = (left); \
 508:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		(left) = (right); \
 509:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		(right) = tmp; \
 510:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	} while ( ipFALSE_BOOL )
 511:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 512:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define vFlip_32( left, right ) \
 513:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	do { \
 514:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		uint32_t tmp = (left); \
 515:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		(left) = (right); \
 516:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		(right) = tmp; \
 517:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	} while ( ipFALSE_BOOL )
 518:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 519:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* WARNING: Do NOT use this macro when the array was received as a parameter. */
 520:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #ifndef ARRAY_SIZE
 521:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#define ARRAY_SIZE(x)	( ( BaseType_t ) ( sizeof( x ) / sizeof( ( x )[ 0 ] ) ) )
 522:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #endif
 523:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 524:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*
 525:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * Create a message that contains a command to initialise the network interface.
 526:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * This is used during initialisation, and at any time the network interface
 527:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * goes down thereafter.  The network interface hardware driver is responsible
 528:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * for sending the message that contains the network interface down command/
 529:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * event.
 530:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  *
 531:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * Only use the FreeRTOS_NetworkDownFromISR() version if the function is to be
 532:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * called from an interrupt service routine.  If FreeRTOS_NetworkDownFromISR()
 533:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * returns a non-zero value then a context switch should be performed ebfore
 534:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * the interrupt is exited.
 535:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  */
 536:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** void FreeRTOS_NetworkDown( void );
 537:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** BaseType_t FreeRTOS_NetworkDownFromISR( void );
 538:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 539:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*
 540:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * Processes incoming ARP packets.
 541:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  */
 542:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** eFrameProcessingResult_t eARPProcessPacket( ARPPacket_t * const pxARPFrame );
 543:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 544:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*
 545:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * Inspect an Ethernet frame to see if it contains data that the stack needs to
 546:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * process.  eProcessBuffer is returned if the frame should be processed by the
 547:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * stack.  eReleaseBuffer is returned if the frame should be discarded.
 548:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  */
 549:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** eFrameProcessingResult_t eConsiderFrameForProcessing( const uint8_t * const pucEthernetBuffer );
 550:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 551:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*
 552:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * Return the checksum generated over xDataLengthBytes from pucNextData.
 553:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  */
 554:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** uint16_t usGenerateChecksum( uint16_t usSum, const uint8_t * pucNextData, size_t uxByteCount );
 555:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 556:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* Socket related private functions. */
 557:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 558:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*
 559:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * The caller must ensure that pxNetworkBuffer->xDataLength is the UDP packet 
 560:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * payload size (excluding packet headers) and that the packet in pucEthernetBuffer 
 561:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * is at least the size of UDPPacket_t. 
 562:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  */
 563:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** BaseType_t xProcessReceivedUDPPacket( NetworkBufferDescriptor_t *pxNetworkBuffer, uint16_t usPort )
 564:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 565:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*
 566:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * Initialize the socket list data structures for TCP and UDP. 
 567:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  */
 568:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** void vNetworkSocketsInit( void );
 569:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 570:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*
 571:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * Returns pdTRUE if the IP task has been created and is initialised.  Otherwise
 572:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * returns pdFALSE.
 573:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  */
 574:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** BaseType_t xIPIsNetworkTaskReady( void );
 575:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 576:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #if( ipconfigSOCKET_HAS_USER_WAKE_CALLBACK == 1 )
 577:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	struct xSOCKET;
 578:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	typedef void (*SocketWakeupCallback_t)( struct xSOCKET * pxSocket );
 579:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #endif
 580:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 581:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #if( ipconfigUSE_TCP == 1 )
 582:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 583:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	/*
 584:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	 * Actually a user thing, but because xBoundTCPSocketsList, let it do by the
 585:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	 * IP-task
 586:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	 */
 587:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#if( ipconfigHAS_PRINTF != 0 )
 588:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		void vTCPNetStat( void );
 589:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#endif
 590:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 591:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	/*
 592:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	 * At least one socket needs to check for timeouts
 593:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	 */
 594:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	TickType_t xTCPTimerCheck( BaseType_t xWillSleep );
 595:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 596:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	/* Every TCP socket has a buffer space just big enough to store
 597:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	the last TCP header received.
 598:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	As a reference of this field may be passed to DMA, force the
 599:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	alignment to 8 bytes. */
 600:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	typedef union
 601:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	{
 602:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		struct
 603:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		{
 604:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			/* Increase the alignment of this union by adding a 64-bit variable. */
 605:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			uint64_t ullAlignmentWord;
 606:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		} a;
 607:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		struct
 608:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		{
 609:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			/* The next field only serves to give 'ucLastPacket' a correct
 610:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			alignment of 8 + 2.  See comments in FreeRTOS_IP.h */
 611:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			uint8_t ucFillPacket[ ipconfigPACKET_FILLER_SIZE ];
 612:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			uint8_t ucLastPacket[ sizeof( TCPPacket_t ) ];
 613:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		} u;
 614:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	} LastTCPPacket_t;
 615:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 616:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	/*
 617:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	 * Note that the values of all short and long integers in these structs
 618:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	 * are being stored in the native-endian way
 619:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	 * Translation should take place when accessing any structure which defines
 620:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	 * network packets, such as IPHeader_t and TCPHeader_t
 621:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	 */
 622:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	typedef struct TCPSOCKET
 623:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	{
 624:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		uint32_t ulRemoteIP;		/* IP address of remote machine */
 625:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		uint16_t usRemotePort;		/* Port on remote machine */
 626:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		struct {
 627:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			/* Most compilers do like bit-flags */
 628:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			uint32_t
 629:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				bMssChange : 1,		/* This socket has seen a change in MSS */
 630:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				bPassAccept : 1,	/* when true, this socket may be returned in a call to accept() */
 631:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				bPassQueued : 1,	/* when true, this socket is an orphan until it gets connected
 632:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 									 * Why an orphan? Because it may not be returned in a accept() call until it
 633:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 									 * gets the state eESTABLISHED */
 634:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				bReuseSocket : 1,	/* When a listening socket gets a connection, do not create a new instance bu
 635:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				bCloseAfterSend : 1,/* As soon as the last byte has been transmitted, finalise the connection
 636:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 									 * Useful in e.g. FTP connections, where the last data bytes are sent along with the FIN f
 637:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				bUserShutdown : 1,	/* User requesting a graceful shutdown */
 638:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				bCloseRequested : 1,/* Request to finalise the connection */
 639:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				bLowWater : 1,		/* high-water level has been reached. Cleared as soon as 'rx-count < lo-water' 
 640:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				bWinChange : 1,		/* The value of bLowWater has changed, must send a window update */
 641:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				bSendKeepAlive : 1,	/* When this flag is true, a TCP keep-alive message must be send */
 642:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				bWaitKeepAlive : 1,	/* When this flag is true, a TCP keep-alive reply is expected */
 643:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				bConnPrepared : 1,	/* Connecting socket: Message has been prepared */
 644:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
 645:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 					bConnPassed : 1,	/* Connecting socket: Socket has been passed in a successful select()  */
 646:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				#endif /* ipconfigSUPPORT_SELECT_FUNCTION */
 647:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				bFinAccepted : 1,	/* This socket has received (or sent) a FIN and accepted it */
 648:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				bFinSent : 1,		/* We've sent out a FIN */
 649:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				bFinRecv : 1,		/* We've received a FIN from our peer */
 650:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				bFinAcked : 1,		/* Our FIN packet has been acked */
 651:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				bFinLast : 1,		/* The last ACK (after FIN and FIN+ACK) has been sent or will be sent by the pee
 652:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				bRxStopped : 1,		/* Application asked to temporarily stop reception */
 653:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				bMallocError : 1,	/* There was an error allocating a stream */
 654:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				bWinScaling : 1;	/* A TCP-Window Scaling option was offered and accepted in the SYN phase. */
 655:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		} bits;
 656:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		uint32_t ulHighestRxAllowed;
 657:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 								/* The highest sequence number that we can receive at any moment */
 658:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		uint16_t usTimeout;		/* Time (in ticks) after which this socket needs attention */
 659:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		uint16_t usCurMSS;		/* Current Maximum Segment Size */
 660:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		uint16_t usInitMSS;		/* Initial maximum segment Size */
 661:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		uint16_t usChildCount;	/* In case of a listening socket: number of connections on this port numbe
 662:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		uint16_t usBacklog;		/* In case of a listening socket: maximum number of concurrent connections o
 663:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		uint8_t ucRepCount;		/* Send repeat count, for retransmissions
 664:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 								 * This counter is separate from the xmitCount in the
 665:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 								 * TCP win segments */
 666:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		uint8_t ucTCPState;		/* TCP state: see eTCP_STATE */
 667:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		struct xSOCKET *pxPeerSocket;	/* for server socket: child, for child socket: parent */
 668:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		#if( ipconfigTCP_KEEP_ALIVE == 1 )
 669:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			uint8_t ucKeepRepCount;
 670:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			TickType_t xLastAliveTime;
 671:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		#endif /* ipconfigTCP_KEEP_ALIVE */
 672:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		#if( ipconfigTCP_HANG_PROTECTION == 1 )
 673:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			TickType_t xLastActTime;
 674:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		#endif /* ipconfigTCP_HANG_PROTECTION */
 675:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		size_t uxLittleSpace;
 676:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		size_t uxEnoughSpace;
 677:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		size_t uxRxStreamSize;
 678:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		size_t uxTxStreamSize;
 679:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		StreamBuffer_t *rxStream;
 680:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		StreamBuffer_t *txStream;
 681:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		#if( ipconfigUSE_TCP_WIN == 1 )
 682:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			NetworkBufferDescriptor_t *pxAckMessage;
 683:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		#endif /* ipconfigUSE_TCP_WIN */
 684:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		/* Buffer space to store the last TCP header received. */
 685:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		LastTCPPacket_t xPacket;
 686:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		uint8_t tcpflags;		/* TCP flags */
 687:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		#if( ipconfigUSE_TCP_WIN != 0 )
 688:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			uint8_t ucMyWinScaleFactor;
 689:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			uint8_t ucPeerWinScaleFactor;
 690:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		#endif
 691:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		#if( ipconfigUSE_CALLBACKS == 1 )
 692:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			FOnTCPReceive_t pxHandleReceive;	/*
 693:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 										 		 * In case of a TCP socket:
 694:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 										 		 * typedef void (* FOnTCPReceive_t) (Socket_t xSocket, void *pData, size_t xLength );
 695:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 										 		 */
 696:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			FOnTCPSent_t pxHandleSent;
 697:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			FOnConnected_t pxHandleConnected;	/* Actually type: typedef void (* FOnConnected_t) (Socket_t xS
 698:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		#endif /* ipconfigUSE_CALLBACKS */
 699:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		uint32_t ulWindowSize;		/* Current Window size advertised by peer */
 700:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		size_t uxRxWinSize;	/* Fixed value: size of the TCP reception window */
 701:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		size_t uxTxWinSize;	/* Fixed value: size of the TCP transmit window */
 702:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 703:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		TCPWindow_t xTCPWindow;
 704:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	} IPTCPSocket_t;
 705:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 706:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #endif /* ipconfigUSE_TCP */
 707:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 708:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef struct UDPSOCKET
 709:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 710:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	List_t xWaitingPacketsList;	/* Incoming packets */
 711:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#if( ipconfigUDP_MAX_RX_PACKETS > 0 )
 712:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		UBaseType_t uxMaxPackets; /* Protection: limits the number of packets buffered per socket */
 713:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#endif /* ipconfigUDP_MAX_RX_PACKETS */
 714:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#if( ipconfigUSE_CALLBACKS == 1 )
 715:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		FOnUDPReceive_t pxHandleReceive;	/*
 716:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 											 * In case of a UDP socket:
 717:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 											 * typedef void (* FOnUDPReceive_t) (Socket_t xSocket, void *pData, size_t xLength, stru
 718:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 											 */
 719:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		FOnUDPSent_t pxHandleSent;
 720:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#endif /* ipconfigUSE_CALLBACKS */
 721:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** } IPUDPSocket_t;
 722:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 723:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef struct RAWSOCKET
 724:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 725:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	List_t xWaitingPacketsList;	/* Incoming packets */
 726:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#if( ipconfigUSE_CALLBACKS == 1 )
 727:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		FOnRAWReceive_t pxHandleReceive;	/*
 728:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 											 * In case of a RAW socket:
 729:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 											 * typedef void (* FOnRAWReceive_t) (Socket_t xSocket, void *pData, size_t xLength, stru
 730:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 											 */
 731:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		FOnRAWSent_t pxHandleSent;
 732:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#endif /* ipconfigUSE_CALLBACKS */
 733:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** } IPRAWSocket_t;
 734:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 735:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* Formally typedef'd as eSocketEvent_t. */
 736:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** enum eSOCKET_EVENT {
 737:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eSOCKET_RECEIVE = 0x0001,
 738:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eSOCKET_SEND    = 0x0002,
 739:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eSOCKET_ACCEPT  = 0x0004,
 740:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eSOCKET_CONNECT = 0x0008,
 741:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eSOCKET_BOUND   = 0x0010,
 742:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eSOCKET_CLOSED	= 0x0020,
 743:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eSOCKET_INTR	= 0x0040,
 744:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eSOCKET_ALL		= 0x007F,
 745:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** };
 746:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 747:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef struct xSOCKET
 748:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 749:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	EventBits_t xEventBits;
 750:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	EventGroupHandle_t xEventGroup;
 751:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 752:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	ListItem_t xBoundSocketListItem; /* Used to reference the socket from a bound sockets list. */
 753:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	TickType_t xReceiveBlockTime; /* if recv[to] is called while no data is available, wait this amoun
 754:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	TickType_t xSendBlockTime; /* if send[to] is called while there is not enough space to send, wait 
 755:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 756:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usLocalPort;		/* Local port on this machine */
 757:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint8_t ucSocketOptions;
 758:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint8_t ucProtocol; /* choice of FREERTOS_IPPROTO_UDP/TCP/RAW */
 759:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint8_t ucSocketType;/* TODO: Need to check padding */
 760:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint8_t __pad0;
 761:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t __pad1;
 762:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#if( ipconfigSOCKET_HAS_USER_SEMAPHORE == 1 )
 763:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		SemaphoreHandle_t pxUserSemaphore;
 764:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#endif /* ipconfigSOCKET_HAS_USER_SEMAPHORE */
 765:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#if( ipconfigSOCKET_HAS_USER_WAKE_CALLBACK == 1 )
 766:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		SocketWakeupCallback_t pxUserWakeCallback;
 767:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#endif /* ipconfigSOCKET_HAS_USER_WAKE_CALLBACK */
 768:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 769:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
 770:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		struct xSOCKET_SET *pxSocketSet;
 771:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		/* User may indicate which bits are interesting for this socket. */
 772:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		EventBits_t xSelectBits;
 773:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		/* These bits indicate the events which have actually occurred.
 774:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		They are maintained by the IP-task */
 775:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		EventBits_t xSocketBits;
 776:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#endif /* ipconfigSUPPORT_SELECT_FUNCTION */
 777:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	/* TCP/UDP specific fields: */
 778:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	/* Before accessing any member of this structure, it should be confirmed */
 779:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	/* that the protocol corresponds with the type of structure */
 780:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 781:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	union
 782:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	{
 783:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		IPRAWSocket_t xRAW;	/* w/ IPPROTO_UDP */
 784:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		IPUDPSocket_t xUDP;
 785:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		#if( ipconfigUSE_TCP == 1 )
 786:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			IPTCPSocket_t xTCP;
 787:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			/* Make sure that xTCP is 8-bytes aligned by
 788:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			declaring a 64-bit variable in the same union */
 789:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			uint64_t ullTCPAlignment;
 790:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		#endif /* ipconfigUSE_TCP */
 791:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	} u;
 792:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** } FreeRTOS_Socket_t;
 793:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 794:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_PTR_FUNC_FOR_TYPE( FreeRTOS_Socket_t )
 795:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 796:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	return ( FreeRTOS_Socket_t *)pvArgument;
 797:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 798:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_CONST_PTR_FUNC_FOR_TYPE( FreeRTOS_Socket_t )
 799:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 800:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	return ( const FreeRTOS_Socket_t *) pvArgument;
 801:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 802:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 803:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #if( ipconfigUSE_TCP == 1 )
 804:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	/*
 805:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	 * Lookup a TCP socket, using a multiple matching: both port numbers and
 806:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	 * return IP address.
 807:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	 */
 808:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	FreeRTOS_Socket_t *pxTCPSocketLookup( uint32_t ulLocalIP, UBaseType_t uxLocalPort, uint32_t ulRemo
 809:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 810:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #endif /* ipconfigUSE_TCP */
 811:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 812:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*
 813:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * Look up a local socket by finding a match with the local port.
 814:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  */
 815:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** FreeRTOS_Socket_t *pxUDPSocketLookup( UBaseType_t uxLocalPort );
 816:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 817:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*
 818:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * Called when the application has generated a UDP packet to send.
 819:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  */
 820:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** void vProcessGeneratedUDPPacket( NetworkBufferDescriptor_t * const pxNetworkBuffer );
 821:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 822:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*
 823:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * Called when the application has generated a UDP packet to send.
 824:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  */
 825:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** void vProcessGeneratedRAWPacket( NetworkBufferDescriptor_t * const pxNetworkBuffer );
 826:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 827:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*
 828:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * Calculate the upper-layer checksum
 829:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * Works both for UDP, ICMP and TCP packages
 830:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * bOut = true: checksum will be set in outgoing packets
 831:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * bOut = false: checksum will be calculated for incoming packets
 832:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  *     returning 0xffff means: checksum was correct
 833:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  */
 834:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** uint16_t usGenerateProtocolChecksum( const uint8_t * const pucEthernetBuffer, size_t uxBufferLength
 835:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 836:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*
 837:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * An Ethernet frame has been updated (maybe it was an ARP request or a PING
 838:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * request?) and is to be sent back to its source.
 839:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  */
 840:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** void vReturnEthernetFrame( NetworkBufferDescriptor_t * pxNetworkBuffer, BaseType_t xReleaseAfterSen
 841:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 842:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*
 843:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * The internal version of bind()
 844:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * If 'ulInternal' is true, it is called by the driver
 845:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * The TCP driver needs to bind a socket at the moment a listening socket
 846:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * creates a new connected socket
 847:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  */
 848:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** BaseType_t vSocketBind( FreeRTOS_Socket_t *pxSocket, struct freertos_sockaddr * pxBindAddress, size
 849:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 850:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*
 851:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * Internal function to add streaming data to a TCP socket. If ulIn == true,
 852:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * data will be added to the rxStream, otherwise to the tXStream.  Normally data
 853:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * will be written with ulOffset == 0, meaning: at the end of the FIFO.  When
 854:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * packet come in out-of-order, an offset will be used to put it in front and
 855:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * the head will not change yet.
 856:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  */
 857:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** int32_t lTCPAddRxdata(FreeRTOS_Socket_t *pxSocket, size_t uxOffset, const uint8_t *pcData, uint32_t
 858:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 859:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*
 860:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * Currently called for any important event.
 861:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  */
 862:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** void vSocketWakeUpUser( FreeRTOS_Socket_t *pxSocket );
 863:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 864:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*
 865:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * Some helping function, their meaning should be clear.
 866:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * Going by MISRA rules, these utility functions should not be defined
 867:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * if they are not being used anywhwere. But their use depends on the
 868:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * application and hence these functions are defined unconditionally.
 869:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  */
 870:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE uint32_t ulChar2u32 (const uint8_t *apChr);
 871:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE uint32_t ulChar2u32 (const uint8_t *apChr)
 872:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 873:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	return  ( ( ( uint32_t )apChr[0] ) << 24) |
 874:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			( ( ( uint32_t )apChr[1] ) << 16) |
 875:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			( ( ( uint32_t )apChr[2] ) << 8) |
 876:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			( ( ( uint32_t )apChr[3] ) );
 877:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 878:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 879:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE uint16_t usChar2u16 (const uint8_t *apChr);
 880:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE uint16_t usChar2u16 (const uint8_t *apChr)
 881:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 882:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	return ( uint16_t )
 2972              	 .loc 5 882 0
 2973 03fa BA78     	 ldrb r2,[r7,#2]
 2974 03fc FB78     	 ldrb r3,[r7,#3]
 2975 03fe 43EA0223 	 orr r3,r3,r2,lsl#8
 2976              	.LVL372:
 2977              	.LBE315:
 2978              	.LBE314:
1275:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 2979              	 .loc 1 1275 0
 2980 0402 B4F84C20 	 ldrh r2,[r4,#76]
 2981 0406 9342     	 cmp r3,r2
 2982 0408 75D0     	 beq .L270
 2983              	.LVL373:
1292:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 2984              	 .loc 1 1292 0
 2985 040a 002B     	 cmp r3,#0
 2986 040c 79D0     	 beq .L197
1294:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
 2987              	 .loc 1 1294 0
 2988 040e 9342     	 cmp r3,r2
 2989 0410 80F07383 	 bcs .L271
1297:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					if( pxSocket->u.xTCP.usCurMSS > uxNewMSS )
 2990              	 .loc 1 1297 0
 2991 0414 94F84020 	 ldrb r2,[r4,#64]
 2992 0418 42F00102 	 orr r2,r2,#1
 2993 041c 84F84020 	 strb r2,[r4,#64]
1305:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					pxTCPWindow->usMSSInit = ( uint16_t ) uxNewMSS;
 2994              	 .loc 1 1305 0
 2995 0420 D4F8DC20 	 ldr r2,[r4,#220]
 2996 0424 B2FBF3F2 	 udiv r2,r2,r3
 2997 0428 03FB02F2 	 mul r2,r3,r2
 2998 042c C4F8DC20 	 str r2,[r4,#220]
1306:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					pxTCPWindow->usMSS = ( uint16_t ) uxNewMSS;
 2999              	 .loc 1 1306 0
 3000 0430 A4F89631 	 strh r3,[r4,#406]
1307:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					pxSocket->u.xTCP.usInitMSS = ( uint16_t ) uxNewMSS;
 3001              	 .loc 1 1307 0
 3002 0434 A4F89431 	 strh r3,[r4,#404]
1308:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					pxSocket->u.xTCP.usCurMSS = ( uint16_t ) uxNewMSS;
 3003              	 .loc 1 1308 0
 3004 0438 A4F84C30 	 strh r3,[r4,#76]
1309:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
 3005              	 .loc 1 1309 0
 3006 043c A4F84A30 	 strh r3,[r4,#74]
1312:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 3007              	 .loc 1 1312 0
 3008 0440 0425     	 movs r5,#4
 3009 0442 59E0     	 b .L201
 3010              	.L301:
 3011              	 .align 2
 3012              	.L300:
 3013 0444 00000000 	 .word xDefaultPartUDPPacketHeader
 3014              	.LVL374:
 3015              	.L200:
1320:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( ( ucLen < ( uint8_t ) 2U ) || ( uxRemainingOptionsBytes < ( size_t ) ucLen ) )
 3016              	 .loc 1 1320 0
 3017 0448 7D78     	 ldrb r5,[r7,#1]
 3018              	.LVL375:
1321:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 3019              	 .loc 1 1321 0
 3020 044a 012D     	 cmp r5,#1
 3021 044c 59D9     	 bls .L197
 3022 044e 5545     	 cmp r5,r10
 3023 0450 57D8     	 bhi .L197
 3024              	.LVL376:
1338:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
 3025              	 .loc 1 1338 0
 3026 0452 052B     	 cmp r3,#5
 3027 0454 48D1     	 bne .L272
1340:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					uxIndex += 2U;
 3028              	 .loc 1 1340 0
 3029 0456 AB1E     	 subs r3,r5,#2
 3030 0458 DBB2     	 uxtb r3,r3
 3031              	.LVL377:
1343:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					{
 3032              	 .loc 1 1343 0
 3033 045a 072B     	 cmp r3,#7
 3034 045c 46D9     	 bls .L273
 3035 045e 3E46     	 mov r6,r7
 3036 0460 A5F10A08 	 sub r8,r5,#10
 3037 0464 C8F3C408 	 ubfx r8,r8,#3,#5
 3038 0468 08F10103 	 add r3,r8,#1
 3039              	.LVL378:
 3040 046c 07EBC303 	 add r3,r7,r3,lsl#3
 3041 0470 0393     	 str r3,[sp,#12]
 3042              	.LVL379:
 3043              	.L204:
 3044              	.LBB316:
 3045              	.LBB313:
 3046              	.LBB309:
 3047              	.LBB310:
 873:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			( ( ( uint32_t )apChr[1] ) << 16) |
 3048              	 .loc 5 873 0
 3049 0472 B278     	 ldrb r2,[r6,#2]
 874:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			( ( ( uint32_t )apChr[2] ) << 8) |
 3050              	 .loc 5 874 0
 3051 0474 F378     	 ldrb r3,[r6,#3]
 3052 0476 1B04     	 lsls r3,r3,#16
 873:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			( ( ( uint32_t )apChr[1] ) << 16) |
 3053              	 .loc 5 873 0
 3054 0478 43EA0263 	 orr r3,r3,r2,lsl#24
 876:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 3055              	 .loc 5 876 0
 3056 047c 7179     	 ldrb r1,[r6,#5]
 3057 047e 1943     	 orrs r1,r1,r3
 875:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			( ( ( uint32_t )apChr[3] ) );
 3058              	 .loc 5 875 0
 3059 0480 96F804E0 	 ldrb lr,[r6,#4]
 3060              	.LBE310:
 3061              	.LBE309:
 3062              	.LBB311:
 3063              	.LBB312:
 873:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			( ( ( uint32_t )apChr[1] ) << 16) |
 3064              	 .loc 5 873 0
 3065 0484 B279     	 ldrb r2,[r6,#6]
 874:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			( ( ( uint32_t )apChr[2] ) << 8) |
 3066              	 .loc 5 874 0
 3067 0486 F379     	 ldrb r3,[r6,#7]
 3068 0488 1B04     	 lsls r3,r3,#16
 873:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			( ( ( uint32_t )apChr[1] ) << 16) |
 3069              	 .loc 5 873 0
 3070 048a 43EA0263 	 orr r3,r3,r2,lsl#24
 876:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 3071              	 .loc 5 876 0
 3072 048e 727A     	 ldrb r2,[r6,#9]
 3073 0490 1343     	 orrs r3,r3,r2
 875:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			( ( ( uint32_t )apChr[3] ) );
 3074              	 .loc 5 875 0
 3075 0492 327A     	 ldrb r2,[r6,#8]
 3076              	.LBE312:
 3077              	.LBE311:
1368:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 3078              	 .loc 1 1368 0
 3079 0494 0598     	 ldr r0,[sp,#20]
 3080 0496 41EA0E21 	 orr r1,r1,lr,lsl#8
 3081 049a 43EA0222 	 orr r2,r3,r2,lsl#8
 3082 049e FFF7FEFF 	 bl ulTCPWindowTxSack
 3083              	.LVL380:
 3084 04a2 0346     	 mov r3,r0
 3085              	.LVL381:
1373:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 3086              	 .loc 1 1373 0
 3087 04a4 A06F     	 ldr r0,[r4,#120]
 3088              	.LVL382:
 3089 04a6 90B1     	 cbz r0,.L203
 3090 04a8 8BB1     	 cbz r3,.L203
1376:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxSocket->xEventBits |= ( EventBits_t ) eSOCKET_SEND;
 3091              	 .loc 1 1376 0
 3092 04aa 0022     	 movs r2,#0
 3093 04ac 0092     	 str r2,[sp]
 3094 04ae 1146     	 mov r1,r2
 3095 04b0 FFF7FEFF 	 bl uxStreamBufferGet
 3096              	.LVL383:
1377:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 3097              	 .loc 1 1377 0
 3098 04b4 2368     	 ldr r3,[r4]
 3099 04b6 43F00202 	 orr r2,r3,#2
 3100 04ba 2260     	 str r2,[r4]
1381:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
 3101              	 .loc 1 1381 0
 3102 04bc 226B     	 ldr r2,[r4,#48]
 3103 04be 12F0020F 	 tst r2,#2
 3104 04c2 04D0     	 beq .L203
1386:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
 3105              	 .loc 1 1386 0
 3106 04c4 43F40073 	 orr r3,r3,#512
 3107 04c8 43F00203 	 orr r3,r3,#2
 3108 04cc 2360     	 str r3,[r4]
 3109              	.L203:
 3110 04ce 0836     	 adds r6,r6,#8
 3111              	.LVL384:
 3112              	.LBE313:
 3113              	.LBE316:
1343:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					{
 3114              	 .loc 1 1343 0
 3115 04d0 039B     	 ldr r3,[sp,#12]
 3116 04d2 9E42     	 cmp r6,r3
 3117 04d4 CDD1     	 bne .L204
 3118 04d6 4FEAC803 	 lsl r3,r8,#3
 3119 04da 0A33     	 adds r3,r3,#10
 3120 04dc 0A3D     	 subs r5,r5,#10
 3121 04de A5EBC805 	 sub r5,r5,r8,lsl#3
 3122 04e2 05F0FF05 	 and r5,r5,#255
 3123 04e6 03E0     	 b .L202
 3124              	.LVL385:
 3125              	.L272:
1330:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			
 3126              	 .loc 1 1330 0
 3127 04e8 0023     	 movs r3,#0
 3128 04ea 01E0     	 b .L202
 3129              	.LVL386:
 3130              	.L273:
1340:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					uxIndex += 2U;
 3131              	 .loc 1 1340 0
 3132 04ec 1D46     	 mov r5,r3
1341:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 3133              	 .loc 1 1341 0
 3134 04ee 0223     	 movs r3,#2
 3135              	.LVL387:
 3136              	.L202:
 3137              	.LBE306:
 3138              	.LBE305:
1197:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					{
 3139              	 .loc 1 1197 0
 3140 04f0 ED18     	 adds r5,r5,r3
 3141              	.LVL388:
 3142 04f2 01D1     	 bne .L201
 3143 04f4 05E0     	 b .L197
 3144              	.LVL389:
 3145              	.L270:
 3146              	.LBB319:
 3147              	.LBB317:
1312:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 3148              	 .loc 1 1312 0
 3149 04f6 0425     	 movs r5,#4
 3150              	.LVL390:
 3151              	.L201:
 3152              	.LBE317:
 3153              	.LBE319:
1202:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
 3154              	 .loc 1 1202 0
 3155 04f8 2F44     	 add r7,r7,r5
 3156              	.LVL391:
1191:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					{
 3157              	 .loc 1 1191 0
 3158 04fa BAEB050A 	 subs r10,r10,r5
 3159              	.LVL392:
 3160 04fe 7FF44EAF 	 bne .L282
 3161              	.LVL393:
 3162              	.L197:
 3163              	.LBE304:
 3164              	.LBE303:
3267:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxSocket->u.xTCP.ulWindowSize = (uint32_t ) usWindow;
 3165              	 .loc 1 3267 0
 3166 0502 B9F83020 	 ldrh r2,[r9,#48]
 3167              	.LVL394:
 3168 0506 130A     	 lsrs r3,r2,#8
 3169 0508 43EA0223 	 orr r3,r3,r2,lsl#8
3268:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			#if( ipconfigUSE_TCP_WIN == 1 )
 3170              	 .loc 1 3268 0
 3171 050c 9BB2     	 uxth r3,r3
 3172 050e C4F8CC30 	 str r3,[r4,#204]
 3173              	.LVL395:
3273:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
 3174              	 .loc 1 3273 0
 3175 0512 1BF0020F 	 tst fp,#2
 3176 0516 04D1     	 bne .L206
3276:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
 3177              	 .loc 1 3276 0
 3178 0518 94F8CA20 	 ldrb r2,[r4,#202]
 3179 051c 9340     	 lsls r3,r3,r2
3275:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 						( pxSocket->u.xTCP.ulWindowSize << pxSocket->u.xTCP.ucPeerWinScaleFactor );
 3180              	 .loc 1 3275 0
 3181 051e C4F8CC30 	 str r3,[r4,#204]
 3182              	.L206:
 3183              	.LVL396:
 3184              	.LBB322:
 3185              	.LBB323:
2838:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	&( ( *ppxNetworkBuffer )->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + xIPHeaderSize( *ppxNetworkBuff
 3186              	 .loc 1 2838 0
 3187 0522 DDF82480 	 ldr r8,[sp,#36]
 3188 0526 D8F81860 	 ldr r6,[r8,#24]
 3189              	.LVL397:
2844:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 3190              	 .loc 1 2844 0
 3191 052a D6F82630 	 ldr r3,[r6,#38]
 3192 052e 1A06     	 lsls r2,r3,#24
 3193 0530 42EA1362 	 orr r2,r2,r3,lsr#24
 3194 0534 03F47F41 	 and r1,r3,#65280
 3195 0538 42EA0122 	 orr r2,r2,r1,lsl#8
 3196 053c 03F47F03 	 and r3,r3,#16711680
 3197 0540 42EA132B 	 orr fp,r2,r3,lsr#8
 3198              	.LVL398:
2852:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** TCPWindow_t *pxTCPWindow = &( pxSocket->u.xTCP.xTCPWindow );
 3199              	 .loc 1 2852 0
 3200 0544 96F82FA0 	 ldrb r10,[r6,#47]
 3201              	.LVL399:
 3202              	.LBB324:
 3203              	.LBB325:
2195:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	lTCPHeaderLength = ( int32_t ) ucIntermediateResult;
 3204              	 .loc 1 2195 0
 3205 0548 96F82E30 	 ldrb r3,[r6,#46]
 3206 054c 03F0F003 	 and r3,r3,#240
 3207 0550 9D08     	 lsrs r5,r3,#2
 3208              	.LVL400:
2199:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 3209              	 .loc 1 2199 0
 3210 0552 05F12209 	 add r9,r5,#34
 3211              	.LVL401:
 3212 0556 B144     	 add r9,r9,r6
 3213              	.LVL402:
2204:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 3214              	 .loc 1 2204 0
 3215 0558 D8F81C30 	 ldr r3,[r8,#28]
 3216 055c A3F10E02 	 sub r2,r3,#14
 3217              	.LVL403:
2206:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	lLength =  ( int32_t ) usLength;
 3218              	 .loc 1 2206 0
 3219 0560 318A     	 ldrh r1,[r6,#16]
 3220              	.LVL404:
 3221 0562 0B0A     	 lsrs r3,r1,#8
 3222 0564 43EA0123 	 orr r3,r3,r1,lsl#8
2207:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 3223              	 .loc 1 2207 0
 3224 0568 9BB2     	 uxth r3,r3
 3225              	.LVL405:
 3226 056a 9342     	 cmp r3,r2
 3227 056c A8BF     	 it ge
 3228 056e 1346     	 movge r3,r2
 3229              	.LVL406:
2218:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 3230              	 .loc 1 2218 0
 3231 0570 05F11402 	 add r2,r5,#20
 3232 0574 9342     	 cmp r3,r2
2220:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 3233              	 .loc 1 2220 0
 3234 0576 C6BF     	 itte gt
 3235 0578 5B1B     	 subgt r3,r3,r5
 3236              	.LVL407:
 3237 057a A3F11405 	 subgt r5,r3,#20
 3238              	.LVL408:
2224:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 3239              	 .loc 1 2224 0
 3240 057e 0025     	 movle r5,#0
 3241              	.LVL409:
2233:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 3242              	 .loc 1 2233 0
 3243 0580 1AF0200F 	 tst r10,#32
 3244 0584 09D0     	 beq .L208
2236:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		*ppucRecvData += lUrgentLength;
 3245              	 .loc 1 2236 0
 3246 0586 B28E     	 ldrh r2,[r6,#52]
 3247              	.LVL410:
 3248 0588 130A     	 lsrs r3,r2,#8
 3249 058a 43EA0223 	 orr r3,r3,r2,lsl#8
 3250 058e 9BB2     	 uxth r3,r3
 3251              	.LVL411:
2237:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		lReceiveLength -= FreeRTOS_min_int32( lReceiveLength, lUrgentLength );
 3252              	 .loc 1 2237 0
 3253 0590 9944     	 add r9,r9,r3
 3254              	.LVL412:
2238:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 3255              	 .loc 1 2238 0
 3256 0592 9D42     	 cmp r5,r3
 3257 0594 D4BF     	 ite le
 3258 0596 6D1B     	 suble r5,r5,r5
 3259              	.LVL413:
 3260 0598 ED1A     	 subgt r5,r5,r3
 3261              	.LVL414:
 3262              	.L208:
 3263              	.LBE325:
 3264              	.LBE324:
2858:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 3265              	 .loc 1 2858 0
 3266 059a 2F46     	 mov r7,r5
 3267              	.LVL415:
2860:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 3268              	 .loc 1 2860 0
 3269 059c 94F85310 	 ldrb r1,[r4,#83]
 3270              	.LVL416:
 3271 05a0 0429     	 cmp r1,#4
 3272 05a2 0BD9     	 bls .L209
2862:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 3273              	 .loc 1 2862 0
 3274 05a4 0BF10103 	 add r3,fp,#1
 3275 05a8 D4F8E820 	 ldr r2,[r4,#232]
 3276 05ac 9A42     	 cmp r2,r3
 3277 05ae 05D1     	 bne .L209
2867:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 3278              	 .loc 1 2867 0
 3279 05b0 94F84130 	 ldrb r3,[r4,#65]
 3280 05b4 43F00103 	 orr r3,r3,#1
 3281 05b8 84F84130 	 strb r3,[r4,#65]
 3282              	.LVL417:
 3283              	.L209:
2873:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 3284              	 .loc 1 2873 0
 3285 05bc 07EB0B03 	 add r3,r7,fp
 3286 05c0 1A46     	 mov r2,r3
 3287 05c2 0493     	 str r3,[sp,#16]
 3288 05c4 D4F8F030 	 ldr r3,[r4,#240]
 3289 05c8 D31A     	 subs r3,r2,r3
 3290 05ca 002B     	 cmp r3,#0
2875:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 3291              	 .loc 1 2875 0
 3292 05cc C4BF     	 itt gt
 3293 05ce 1346     	 movgt r3,r2
 3294 05d0 C4F8F030 	 strgt r3,[r4,#240]
 3295              	.LVL418:
 3296              	.LBB326:
 3297              	.LBB327:
2258:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint32_t ulSequenceNumber, ulSpace;
 3298              	 .loc 1 2258 0
 3299 05d4 04F1D803 	 add r3,r4,#216
 3300 05d8 0393     	 str r3,[sp,#12]
 3301              	.LVL419:
2263:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 3302              	 .loc 1 2263 0
 3303 05da D8F81830 	 ldr r3,[r8,#24]
 3304              	.LVL420:
 3305 05de D3F82620 	 ldr r2,[r3,#38]
 3306              	.LVL421:
2265:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 3307              	 .loc 1 2265 0
 3308 05e2 AFB3     	 cbz r7,.L211
 3309 05e4 0329     	 cmp r1,#3
 3310 05e6 33D9     	 bls .L211
2274:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 3311              	 .loc 1 2274 0
 3312 05e8 616F     	 ldr r1,[r4,#116]
 3313 05ea 49B1     	 cbz r1,.L212
 3314              	.LVL422:
 3315              	.LBB328:
 3316              	.LBB329:
  99:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** size_t uxTail = pxBuffer->uxTail;
 3317              	 .loc 2 99 0
 3318 05ec 8868     	 ldr r0,[r1,#8]
 3319              	.LVL423:
 100:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 
 3320              	 .loc 2 100 0
 3321 05ee 0B68     	 ldr r3,[r1]
 3322              	.LVL424:
 3323              	.LBB330:
 3324              	.LBB331:
  68:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	if( uxCount >= pxBuffer->LENGTH )
 3325              	 .loc 2 68 0
 3326 05f0 0969     	 ldr r1,[r1,#16]
 3327              	.LVL425:
 3328 05f2 0B44     	 add r3,r3,r1
 3329              	.LVL426:
 3330 05f4 013B     	 subs r3,r3,#1
 3331 05f6 1B1A     	 subs r3,r3,r0
 3332              	.LVL427:
  69:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	{
 3333              	 .loc 2 69 0
 3334 05f8 9942     	 cmp r1,r3
 3335 05fa 02D8     	 bhi .L213
  71:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Stream_Buffer.h **** 	}
 3336              	 .loc 2 71 0
 3337 05fc 5B1A     	 subs r3,r3,r1
 3338              	.LVL428:
 3339 05fe 00E0     	 b .L213
 3340              	.LVL429:
 3341              	.L212:
 3342              	.LBE331:
 3343              	.LBE330:
 3344              	.LBE329:
 3345              	.LBE328:
2280:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 3346              	 .loc 1 2280 0
 3347 0600 E36E     	 ldr r3,[r4,#108]
 3348              	.LVL430:
 3349              	.L213:
2263:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 3350              	 .loc 1 2263 0
 3351 0602 110E     	 lsrs r1,r2,#24
 3352 0604 41EA0261 	 orr r1,r1,r2,lsl#24
 3353 0608 02F47F40 	 and r0,r2,#65280
 3354 060c 41EA0021 	 orr r1,r1,r0,lsl#8
 3355 0610 02F47F02 	 and r2,r2,#16711680
 3356              	.LVL431:
2283:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 3357              	 .loc 1 2283 0
 3358 0614 0398     	 ldr r0,[sp,#12]
 3359 0616 41EA1221 	 orr r1,r1,r2,lsr#8
 3360 061a 3A46     	 mov r2,r7
 3361 061c FFF7FEFF 	 bl lTCPWindowRxCheck
 3362              	.LVL432:
2285:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 3363              	 .loc 1 2285 0
 3364 0620 011E     	 subs r1,r0,#0
 3365 0622 C0F26C82 	 blt .L214
2291:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 3366              	 .loc 1 2291 0
 3367 0626 2046     	 mov r0,r4
 3368              	.LVL433:
 3369 0628 4A46     	 mov r2,r9
 3370 062a 3B46     	 mov r3,r7
 3371 062c FFF7FEFF 	 bl lTCPAddRxdata
 3372              	.LVL434:
2293:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 3373              	 .loc 1 2293 0
 3374 0630 8542     	 cmp r5,r0
 3375 0632 00F06482 	 beq .L214
2300:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				xResult = -1;
 3376              	 .loc 1 2300 0
 3377 0636 4046     	 mov r0,r8
 3378              	.LVL435:
 3379 0638 FFF7FEFF 	 bl prvTCPSendReset
 3380              	.LVL436:
 3381 063c 46E2     	 b .L248
 3382              	.LVL437:
 3383              	.L258:
2314:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxTCPWindow->ulUserDataLength = 0;
 3384              	 .loc 1 2314 0
 3385 063e 2046     	 mov r0,r4
 3386 0640 0021     	 movs r1,#0
 3387 0642 0A46     	 mov r2,r1
 3388 0644 FFF7FEFF 	 bl lTCPAddRxdata
 3389              	.LVL438:
2315:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 3390              	 .loc 1 2315 0
 3391 0648 0023     	 movs r3,#0
 3392 064a C4F80831 	 str r3,[r4,#264]
 3393 064e 5BE2     	 b .L216
 3394              	.LVL439:
 3395              	.L211:
2322:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 3396              	 .loc 1 2322 0
 3397 0650 0023     	 movs r3,#0
 3398              	.LVL440:
 3399 0652 84F81431 	 strb r3,[r4,#276]
 3400              	.LVL441:
 3401              	.LBE327:
 3402              	.LBE326:
 3403              	.LBB333:
 3404              	.LBB334:
2333:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	&( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + xIPHeaderSize( pxNetworkBuffer ) ] )
 3405              	 .loc 1 2333 0
 3406 0656 099B     	 ldr r3,[sp,#36]
 3407 0658 D3F81880 	 ldr r8,[r3,#24]
 3408              	.LVL442:
 3409 065c 0CE0     	 b .L217
 3410              	.LVL443:
 3411              	.L259:
2353:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 3412              	 .loc 1 2353 0
 3413 065e 08F13600 	 add r0,r8,#54
 3414 0662 04F5AC71 	 add r1,r4,#344
 3415 0666 4A46     	 mov r2,r9
 3416 0668 FFF7FEFF 	 bl memcpy
 3417              	.LVL444:
2357:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 3418              	 .loc 1 2357 0
 3419 066c 09F11403 	 add r3,r9,#20
 3420 0670 9B00     	 lsls r3,r3,#2
 3421 0672 88F82E30 	 strb r3,[r8,#46]
 3422 0676 24E0     	 b .L218
 3423              	.LVL445:
 3424              	.L217:
2361:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 3425              	 .loc 1 2361 0
 3426 0678 94F85330 	 ldrb r3,[r4,#83]
 3427 067c 042B     	 cmp r3,#4
 3428 067e 1DD9     	 bls .L275
 3429 0680 94F84030 	 ldrb r3,[r4,#64]
 3430 0684 13F0010F 	 tst r3,#1
 3431 0688 1AD0     	 beq .L276
2364:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( xTCPWindowLoggingLevel >= 0 )
 3432              	 .loc 1 2364 0
 3433 068a 94F84030 	 ldrb r3,[r4,#64]
 3434 068e 6FF30003 	 bfc r3,#0,#1
 3435 0692 84F84030 	 strb r3,[r4,#64]
2370:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPHeader->ucOptdata[ 1 ] = tcpTCP_OPT_MSS_LEN;
 3436              	 .loc 1 2370 0
 3437 0696 0223     	 movs r3,#2
 3438 0698 88F83630 	 strb r3,[r8,#54]
2371:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPHeader->ucOptdata[ 2 ] = ( uint8_t ) ( ( pxSocket->u.xTCP.usCurMSS ) >> 8 );
 3439              	 .loc 1 2371 0
 3440 069c 0425     	 movs r5,#4
 3441 069e 88F83750 	 strb r5,[r8,#55]
2372:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPHeader->ucOptdata[ 3 ] = ( uint8_t ) ( ( pxSocket->u.xTCP.usCurMSS ) & 0xffU );
 3442              	 .loc 1 2372 0
 3443 06a2 B4F84A30 	 ldrh r3,[r4,#74]
 3444 06a6 1B0A     	 lsrs r3,r3,#8
 3445 06a8 88F83830 	 strb r3,[r8,#56]
2373:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		uxOptionsLength = 4U;
 3446              	 .loc 1 2373 0
 3447 06ac B4F84A30 	 ldrh r3,[r4,#74]
 3448 06b0 88F83930 	 strb r3,[r8,#57]
 3449              	.LVL446:
2375:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 3450              	 .loc 1 2375 0
 3451 06b4 6023     	 movs r3,#96
 3452 06b6 88F82E30 	 strb r3,[r8,#46]
 3453 06ba 02E0     	 b .L218
 3454              	.LVL447:
 3455              	.L275:
2337:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 3456              	 .loc 1 2337 0
 3457 06bc 0025     	 movs r5,#0
 3458 06be 00E0     	 b .L218
 3459              	.L276:
 3460 06c0 0025     	 movs r5,#0
 3461              	.LVL448:
 3462              	.L218:
 3463              	.LBE334:
 3464              	.LBE333:
2887:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 3465              	 .loc 1 2887 0
 3466 06c2 94F85330 	 ldrb r3,[r4,#83]
 3467 06c6 042B     	 cmp r3,#4
 3468 06c8 08D1     	 bne .L219
 3469 06ca 0AF01F02 	 and r2,r10,#31
 3470 06ce 022A     	 cmp r2,#2
 3471 06d0 40F03982 	 bne .L220
2895:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 3472              	 .loc 1 2895 0
 3473 06d4 2046     	 mov r0,r4
 3474 06d6 0321     	 movs r1,#3
 3475 06d8 FFF7FEFF 	 bl vTCPStateChange
 3476              	.LVL449:
 3477              	.L219:
2898:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 3478              	 .loc 1 2898 0
 3479 06dc 1AF0010F 	 tst r10,#1
 3480 06e0 16D0     	 beq .L221
 3481 06e2 94F84130 	 ldrb r3,[r4,#65]
 3482 06e6 13F0800F 	 tst r3,#128
 3483 06ea 11D1     	 bne .L221
 3484              	.L264:
2902:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxSocket->u.xTCP.bits.bFinRecv = pdTRUE_UNSIGNED;
 3485              	 .loc 1 2902 0
 3486 06ec 049B     	 ldr r3,[sp,#16]
 3487 06ee C4F8EC30 	 str r3,[r4,#236]
2903:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 3488              	 .loc 1 2903 0
 3489 06f2 94F84130 	 ldrb r3,[r4,#65]
 3490 06f6 43F08003 	 orr r3,r3,#128
 3491 06fa 84F84130 	 strb r3,[r4,#65]
 3492              	.LVL450:
2906:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 3493              	 .loc 1 2906 0
 3494 06fe 13F0400F 	 tst r3,#64
 3495 0702 05D1     	 bne .L221
2909:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 3496              	 .loc 1 2909 0
 3497 0704 94F84230 	 ldrb r3,[r4,#66]
 3498 0708 43F00203 	 orr r3,r3,#2
 3499 070c 84F84230 	 strb r3,[r4,#66]
 3500              	.L221:
2913:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 3501              	 .loc 1 2913 0
 3502 0710 94F85330 	 ldrb r3,[r4,#83]
 3503 0714 9A1E     	 subs r2,r3,#2
 3504 0716 082A     	 cmp r2,#8
 3505 0718 00F29381 	 bhi .L277
 3506 071c DFE812F0 	 tbh [pc,r2,lsl#1]
 3507              	.L224:
 3508 0720 5800     	 .2byte (.L223-.L224)/2
 3509 0722 0900     	 .2byte (.L225-.L224)/2
 3510 0724 5800     	 .2byte (.L223-.L224)/2
 3511 0726 EF00     	 .2byte (.L226-.L224)/2
 3512 0728 8B01     	 .2byte (.L227-.L224)/2
 3513 072a 8B01     	 .2byte (.L227-.L224)/2
 3514 072c 9101     	 .2byte (.L277-.L224)/2
 3515 072e 9101     	 .2byte (.L277-.L224)/2
 3516 0730 8B01     	 .2byte (.L227-.L224)/2
 3517              	 .p2align 1
 3518              	.L225:
 3519              	.LVL451:
 3520              	.LBB336:
 3521              	.LBB337:
1442:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** UBaseType_t uxOptionsLength;
 3522              	 .loc 1 1442 0
 3523 0732 B4F84C30 	 ldrh r3,[r4,#76]
 3524              	.LVL452:
1447:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	pxTCPHeader->ucOptdata[ 1 ] = ( uint8_t ) tcpTCP_OPT_MSS_LEN;
 3525              	 .loc 1 1447 0
 3526 0736 0222     	 movs r2,#2
 3527 0738 86F83620 	 strb r2,[r6,#54]
1448:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	pxTCPHeader->ucOptdata[ 2 ] = ( uint8_t ) ( usMSS >> 8 );
 3528              	 .loc 1 1448 0
 3529 073c 0422     	 movs r2,#4
 3530 073e 86F83720 	 strb r2,[r6,#55]
1449:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	pxTCPHeader->ucOptdata[ 3 ] = ( uint8_t ) ( usMSS & 0xffU );
 3531              	 .loc 1 1449 0
 3532 0742 1A0A     	 lsrs r2,r3,#8
 3533 0744 86F83820 	 strb r2,[r6,#56]
1450:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 3534              	 .loc 1 1450 0
 3535 0748 86F83930 	 strb r3,[r6,#57]
 3536              	.LVL453:
 3537              	.LBB338:
 3538              	.LBB339:
1415:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		ucFactor = 0U;
 3539              	 .loc 1 1415 0
 3540 074c B4F84C20 	 ldrh r2,[r4,#76]
 3541 0750 D4F8D030 	 ldr r3,[r4,#208]
 3542              	.LVL454:
 3543 0754 03FB02F2 	 mul r2,r3,r2
 3544              	.LVL455:
1417:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 3545              	 .loc 1 1417 0
 3546 0758 B2F5803F 	 cmp r2,#65536
 3547 075c 07D3     	 bcc .L278
 3548 075e 0023     	 movs r3,#0
 3549              	.LVL456:
 3550              	.L229:
1420:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			ucFactor++;
 3551              	 .loc 1 1420 0
 3552 0760 5208     	 lsrs r2,r2,#1
 3553              	.LVL457:
1421:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 3554              	 .loc 1 1421 0
 3555 0762 0133     	 adds r3,r3,#1
 3556              	.LVL458:
 3557 0764 DBB2     	 uxtb r3,r3
 3558              	.LVL459:
1417:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 3559              	 .loc 1 1417 0
 3560 0766 B2F5803F 	 cmp r2,#65536
 3561 076a F9D2     	 bcs .L229
 3562 076c 00E0     	 b .L228
 3563              	.LVL460:
 3564              	.L278:
1416:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		while( uxWinSize > 0xffffUL )
 3565              	 .loc 1 1416 0
 3566 076e 0023     	 movs r3,#0
 3567              	.LVL461:
 3568              	.L228:
 3569              	.LBE339:
 3570              	.LBE338:
1454:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 3571              	 .loc 1 1454 0
 3572 0770 84F8C930 	 strb r3,[r4,#201]
1456:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPHeader->ucOptdata[ 5 ] = ( uint8_t ) ( tcpTCP_OPT_WSOPT );
 3573              	 .loc 1 1456 0
 3574 0774 0123     	 movs r3,#1
 3575 0776 86F83A30 	 strb r3,[r6,#58]
1457:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPHeader->ucOptdata[ 6 ] = ( uint8_t ) ( tcpTCP_OPT_WSOPT_LEN );
 3576              	 .loc 1 1457 0
 3577 077a 0322     	 movs r2,#3
 3578              	.LVL462:
 3579 077c 86F83B20 	 strb r2,[r6,#59]
1458:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPHeader->ucOptdata[ 7 ] = ( uint8_t ) pxSocket->u.xTCP.ucMyWinScaleFactor;
 3580              	 .loc 1 1458 0
 3581 0780 86F83C20 	 strb r2,[r6,#60]
1459:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		uxOptionsLength = 8U;
 3582              	 .loc 1 1459 0
 3583 0784 94F8C920 	 ldrb r2,[r4,#201]
 3584 0788 86F83D20 	 strb r2,[r6,#61]
 3585              	.LVL463:
1470:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPHeader->ucOptdata[ uxOptionsLength + 1U ] = tcpTCP_OPT_NOOP;
 3586              	 .loc 1 1470 0
 3587 078c 86F83E30 	 strb r3,[r6,#62]
1471:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPHeader->ucOptdata[ uxOptionsLength + 2U ] = tcpTCP_OPT_SACK_P;	/* 4: Sack-Permitted Option. 
 3588              	 .loc 1 1471 0
 3589 0790 86F83F30 	 strb r3,[r6,#63]
1472:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPHeader->ucOptdata[ uxOptionsLength + 3U ] = 2U;	/* 2: length of this option. */
 3590              	 .loc 1 1472 0
 3591 0794 0421     	 movs r1,#4
 3592 0796 86F84010 	 strb r1,[r6,#64]
1473:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		uxOptionsLength += 4U;
 3593              	 .loc 1 1473 0
 3594 079a 0223     	 movs r3,#2
 3595 079c 86F84130 	 strb r3,[r6,#65]
 3596              	.LVL464:
 3597              	.LBE337:
 3598              	.LBE336:
2933:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 3599              	 .loc 1 2933 0
 3600 07a0 1223     	 movs r3,#18
 3601 07a2 86F82F30 	 strb r3,[r6,#47]
 3602              	.LVL465:
2941:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				vTCPStateChange( pxSocket, eSYN_RECEIVED );
 3603              	 .loc 1 2941 0
 3604 07a6 8023     	 movs r3,#128
 3605 07a8 86F82E30 	 strb r3,[r6,#46]
2942:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 3606              	 .loc 1 2942 0
 3607 07ac 2046     	 mov r0,r4
 3608 07ae FFF7FEFF 	 bl vTCPStateChange
 3609              	.LVL466:
2944:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxTCPWindow->rx.ulCurrentSequenceNumber = ulSequenceNumber + 1UL;
 3610              	 .loc 1 2944 0
 3611 07b2 0BF10103 	 add r3,fp,#1
 3612 07b6 C4F8F030 	 str r3,[r4,#240]
2945:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxTCPWindow->ulNextTxSequenceNumber     = pxTCPWindow->tx.ulFirstSequenceNumber + 1UL;
 3613              	 .loc 1 2945 0
 3614 07ba C4F8E830 	 str r3,[r4,#232]
2946:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxTCPWindow->tx.ulCurrentSequenceNumber = pxTCPWindow->tx.ulFirstSequenceNumber + 1UL; /* becau
 3615              	 .loc 1 2946 0
 3616 07be D4F8F430 	 ldr r3,[r4,#244]
 3617 07c2 0133     	 adds r3,r3,#1
 3618 07c4 C4F80C31 	 str r3,[r4,#268]
2947:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 3619              	 .loc 1 2947 0
 3620 07c8 C4F8F830 	 str r3,[r4,#248]
2936:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 3621              	 .loc 1 2936 0
 3622 07cc 3420     	 movs r0,#52
 3623 07ce C4E1     	 b .L230
 3624              	.LVL467:
 3625              	.L223:
 3626              	.LBB340:
 3627              	.LBB341:
2396:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	&( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + uxIPHeaderSizeSocket( pxSocket ) ] )
 3628              	 .loc 1 2396 0
 3629 07d0 099A     	 ldr r2,[sp,#36]
 3630 07d2 D2F81880 	 ldr r8,[r2,#24]
 3631              	.LVL468:
2400:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint32_t ulSequenceNumber = FreeRTOS_ntohl( pxTCPHeader->ulSequenceNumber );
 3632              	 .loc 1 2400 0
 3633 07d6 98F82F00 	 ldrb r0,[r8,#47]
 3634              	.LVL469:
2401:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** BaseType_t xSendLength = 0;
 3635              	 .loc 1 2401 0
 3636 07da D8F82620 	 ldr r2,[r8,#38]
 3637 07de 1106     	 lsls r1,r2,#24
 3638 07e0 41EA1261 	 orr r1,r1,r2,lsr#24
 3639 07e4 02F47F46 	 and r6,r2,#65280
 3640              	.LVL470:
 3641 07e8 41EA0626 	 orr r6,r1,r6,lsl#8
 3642 07ec 02F47F02 	 and r2,r2,#16711680
 3643 07f0 46EA1226 	 orr r6,r6,r2,lsr#8
 3644              	.LVL471:
2409:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 3645              	 .loc 1 2409 0
 3646 07f4 022B     	 cmp r3,#2
 3647 07f6 14BF     	 ite ne
 3648 07f8 1022     	 movne r2,#16
 3649 07fa 1222     	 moveq r2,#18
 3650              	.LVL472:
 3651              	.L231:
2414:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 3652              	 .loc 1 2414 0
 3653 07fc 00F01700 	 and r0,r0,#23
 3654              	.LVL473:
 3655 0800 9042     	 cmp r0,r2
 3656 0802 22D0     	 beq .L232
2421:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		/* Send RST with the expected sequence and ACK numbers,
 3657              	 .loc 1 2421 0
 3658 0804 2046     	 mov r0,r4
 3659 0806 0821     	 movs r1,#8
 3660 0808 FFF7FEFF 	 bl vTCPStateChange
 3661              	.LVL474:
2424:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPWindow->rx.ulCurrentSequenceNumber = ulSequenceNumber;
 3662              	 .loc 1 2424 0
 3663 080c D8F82A20 	 ldr r2,[r8,#42]
 3664 0810 1306     	 lsls r3,r2,#24
 3665 0812 43EA1263 	 orr r3,r3,r2,lsr#24
 3666 0816 02F47F41 	 and r1,r2,#65280
 3667 081a 43EA0123 	 orr r3,r3,r1,lsl#8
 3668 081e 02F47F02 	 and r2,r2,#16711680
 3669 0822 43EA1223 	 orr r3,r3,r2,lsr#8
 3670 0826 C4F80431 	 str r3,[r4,#260]
2425:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 3671              	 .loc 1 2425 0
 3672 082a C4F8E860 	 str r6,[r4,#232]
2427:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 3673              	 .loc 1 2427 0
 3674 082e 98F82F30 	 ldrb r3,[r8,#47]
 3675 0832 43F00403 	 orr r3,r3,#4
 3676 0836 88F82F30 	 strb r3,[r8,#47]
 3677              	.LVL475:
2429:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		xSendLength = ( BaseType_t ) uxIntermediateResult;
 3678              	 .loc 1 2429 0
 3679 083a 05F12806 	 add r6,r5,#40
 3680              	.LVL476:
2432:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 3681              	 .loc 1 2432 0
 3682 083e 05F11403 	 add r3,r5,#20
 3683 0842 9B00     	 lsls r3,r3,#2
 3684 0844 88F82E30 	 strb r3,[r8,#46]
 3685 0848 FCE0     	 b .L222
 3686              	.LVL477:
 3687              	.L232:
2436:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxTCPWindow->usOurPortNumber = pxSocket->usLocalPort;
 3688              	 .loc 1 2436 0
 3689 084a A28F     	 ldrh r2,[r4,#60]
 3690              	.LVL478:
 3691 084c A4F89221 	 strh r2,[r4,#402]
2437:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 3692              	 .loc 1 2437 0
 3693 0850 A28C     	 ldrh r2,[r4,#36]
 3694 0852 A4F89021 	 strh r2,[r4,#400]
2439:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 3695              	 .loc 1 2439 0
 3696 0856 022B     	 cmp r3,#2
 3697 0858 25D1     	 bne .L233
 3698              	.LVL479:
 3699              	.LBB342:
2446:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxProtocolHeaders->xTCPHeader.ucTCPFlags = tcpTCP_FLAG_ACK;
 3700              	 .loc 1 2446 0
 3701 085a 1023     	 movs r3,#16
 3702 085c 84F8B130 	 strb r3,[r4,#177]
2447:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 3703              	 .loc 1 2447 0
 3704 0860 88F82F30 	 strb r3,[r8,#47]
2451:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				ulSequenceNumber, pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber, ( uint32_t ) pxSocket->u.xTC
 3705              	 .loc 1 2451 0
 3706 0864 0398     	 ldr r0,[sp,#12]
 3707 0866 3146     	 mov r1,r6
 3708 0868 D4F80421 	 ldr r2,[r4,#260]
 3709 086c B4F84A30 	 ldrh r3,[r4,#74]
 3710 0870 FFF7FEFF 	 bl vTCPWindowInit
 3711              	.LVL480:
2453:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxTCPWindow->rx.ulCurrentSequenceNumber = ulSequenceNumber + 1U;
 3712              	 .loc 1 2453 0
 3713 0874 0136     	 adds r6,r6,#1
 3714              	.LVL481:
 3715 0876 C4F8F060 	 str r6,[r4,#240]
2454:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxTCPWindow->tx.ulCurrentSequenceNumber++; /* because we send a TCP_SYN [ | TCP_ACK ]; */
 3716              	 .loc 1 2454 0
 3717 087a C4F8E860 	 str r6,[r4,#232]
2455:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxTCPWindow->ulNextTxSequenceNumber++;
 3718              	 .loc 1 2455 0
 3719 087e D4F8F830 	 ldr r3,[r4,#248]
 3720 0882 0133     	 adds r3,r3,#1
 3721 0884 C4F8F830 	 str r3,[r4,#248]
2456:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 3722              	 .loc 1 2456 0
 3723 0888 D4F80C31 	 ldr r3,[r4,#268]
 3724 088c 0133     	 adds r3,r3,#1
 3725 088e C4F80C31 	 str r3,[r4,#268]
 3726              	.LBE342:
2469:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 3727              	 .loc 1 2469 0
 3728 0892 D4F8F430 	 ldr r3,[r4,#244]
 3729 0896 0133     	 adds r3,r3,#1
 3730 0898 C4F80431 	 str r3,[r4,#260]
2482:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 3731              	 .loc 1 2482 0
 3732 089c 94F85330 	 ldrb r3,[r4,#83]
 3733 08a0 022B     	 cmp r3,#2
 3734 08a2 10D1     	 bne .L287
 3735 08a4 10E0     	 b .L234
 3736              	.LVL482:
 3737              	.L233:
2458:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 3738              	 .loc 1 2458 0
 3739 08a6 002F     	 cmp r7,#0
 3740 08a8 40F05181 	 bne .L236
2460:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 3741              	 .loc 1 2460 0
 3742 08ac C4F8E860 	 str r6,[r4,#232]
2469:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 3743              	 .loc 1 2469 0
 3744 08b0 D4F8F430 	 ldr r3,[r4,#244]
 3745 08b4 0133     	 adds r3,r3,#1
 3746 08b6 C4F80431 	 str r3,[r4,#260]
2482:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 3747              	 .loc 1 2482 0
 3748 08ba 94F85330 	 ldrb r3,[r4,#83]
 3749 08be 022B     	 cmp r3,#2
 3750 08c0 02D0     	 beq .L234
2402:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** UBaseType_t uxIntermediateResult = 0;
 3751              	 .loc 1 2402 0
 3752 08c2 0026     	 movs r6,#0
 3753              	.LVL483:
 3754 08c4 0CE0     	 b .L237
 3755              	.LVL484:
 3756              	.L287:
2482:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 3757              	 .loc 1 2482 0
 3758 08c6 57B1     	 cbz r7,.L280
 3759              	.LVL485:
 3760              	.L234:
2484:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 3761              	 .loc 1 2484 0
 3762 08c8 1023     	 movs r3,#16
 3763 08ca 88F82F30 	 strb r3,[r8,#47]
 3764              	.LVL486:
2486:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			xSendLength = ( BaseType_t ) uxIntermediateResult;
 3765              	 .loc 1 2486 0
 3766 08ce 05F12806 	 add r6,r5,#40
 3767              	.LVL487:
2488:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 3768              	 .loc 1 2488 0
 3769 08d2 05F11403 	 add r3,r5,#20
 3770 08d6 9B00     	 lsls r3,r3,#2
 3771 08d8 88F82E30 	 strb r3,[r8,#46]
 3772 08dc 00E0     	 b .L237
 3773              	.LVL488:
 3774              	.L280:
2402:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** UBaseType_t uxIntermediateResult = 0;
 3775              	 .loc 1 2402 0
 3776 08de 0026     	 movs r6,#0
 3777              	.LVL489:
 3778              	.L237:
2492:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 3779              	 .loc 1 2492 0
 3780 08e0 94F84230 	 ldrb r3,[r4,#66]
 3781 08e4 13F0100F 	 tst r3,#16
 3782 08e8 04D1     	 bne .L238
2496:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxSocket->u.xTCP.ucPeerWinScaleFactor = 0;
 3783              	 .loc 1 2496 0
 3784 08ea 0023     	 movs r3,#0
 3785 08ec 84F8C930 	 strb r3,[r4,#201]
2497:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 3786              	 .loc 1 2497 0
 3787 08f0 84F8CA30 	 strb r3,[r4,#202]
 3788              	.L238:
2503:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 3789              	 .loc 1 2503 0
 3790 08f4 2046     	 mov r0,r4
 3791 08f6 0521     	 movs r1,#5
 3792 08f8 FFF7FEFF 	 bl vTCPStateChange
 3793              	.LVL490:
 3794 08fc A2E0     	 b .L222
 3795              	.LVL491:
 3796              	.L226:
 3797              	.LBE341:
 3798              	.LBE340:
 3799              	.LBB345:
 3800              	.LBB346:
2522:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	&( ( *ppxNetworkBuffer )->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + uxIPHeaderSizeSocket( pxSocket
 3801              	 .loc 1 2522 0
 3802 08fe 099B     	 ldr r3,[sp,#36]
 3803 0900 D3F81880 	 ldr r8,[r3,#24]
 3804              	.LVL492:
2526:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint32_t ulSequenceNumber = FreeRTOS_ntohl( pxTCPHeader->ulSequenceNumber ), ulCount, ulIntermediat
 3805              	 .loc 1 2526 0
 3806 0904 98F82F90 	 ldrb r9,[r8,#47]
 3807              	.LVL493:
2527:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** BaseType_t xSendLength = 0, xMayClose = pdFALSE, bRxComplete, bTxDone;
 3808              	 .loc 1 2527 0
 3809 0908 D8F82630 	 ldr r3,[r8,#38]
 3810 090c 1A06     	 lsls r2,r3,#24
 3811 090e 42EA1362 	 orr r2,r2,r3,lsr#24
 3812 0912 03F47F46 	 and r6,r3,#65280
 3813              	.LVL494:
 3814 0916 42EA0626 	 orr r6,r2,r6,lsl#8
 3815 091a 03F47F03 	 and r3,r3,#16711680
 3816 091e 46EA1326 	 orr r6,r6,r3,lsr#8
 3817              	.LVL495:
2534:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	pxSocket->u.xTCP.ulWindowSize = ( uint32_t ) usWindow;
 3818              	 .loc 1 2534 0
 3819 0922 B8F83020 	 ldrh r2,[r8,#48]
 3820              	.LVL496:
 3821 0926 130A     	 lsrs r3,r2,#8
 3822 0928 43EA0223 	 orr r3,r3,r2,lsl#8
2535:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	#if( ipconfigUSE_TCP_WIN != 0 )
 3823              	 .loc 1 2535 0
 3824 092c 9BB2     	 uxth r3,r3
2539:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 3825              	 .loc 1 2539 0
 3826 092e 94F8CA20 	 ldrb r2,[r4,#202]
 3827 0932 9340     	 lsls r3,r3,r2
2538:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( pxSocket->u.xTCP.ulWindowSize << pxSocket->u.xTCP.ucPeerWinScaleFactor );
 3828              	 .loc 1 2538 0
 3829 0934 C4F8CC30 	 str r3,[r4,#204]
 3830              	.LVL497:
2543:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 3831              	 .loc 1 2543 0
 3832 0938 19F0100F 	 tst r9,#16
 3833 093c 26D0     	 beq .L239
2545:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 3834              	 .loc 1 2545 0
 3835 093e D8F82A30 	 ldr r3,[r8,#42]
 3836 0942 1A06     	 lsls r2,r3,#24
 3837 0944 42EA1362 	 orr r2,r2,r3,lsr#24
 3838 0948 03F47F41 	 and r1,r3,#65280
 3839 094c 42EA0121 	 orr r1,r2,r1,lsl#8
 3840 0950 03F47F03 	 and r3,r3,#16711680
 3841 0954 0398     	 ldr r0,[sp,#12]
 3842 0956 41EA1321 	 orr r1,r1,r3,lsr#8
 3843 095a FFF7FEFF 	 bl ulTCPWindowTxAck
 3844              	.LVL498:
 3845 095e 0346     	 mov r3,r0
 3846              	.LVL499:
2550:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 3847              	 .loc 1 2550 0
 3848 0960 A06F     	 ldr r0,[r4,#120]
 3849              	.LVL500:
 3850 0962 C0B1     	 cbz r0,.L240
 3851 0964 A3B1     	 cbz r3,.L241
2556:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 3852              	 .loc 1 2556 0
 3853 0966 0022     	 movs r2,#0
 3854 0968 0092     	 str r2,[sp]
 3855 096a 1146     	 mov r1,r2
 3856 096c FFF7FEFF 	 bl uxStreamBufferGet
 3857              	.LVL501:
 3858 0970 60B1     	 cbz r0,.L239
2558:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 3859              	 .loc 1 2558 0
 3860 0972 2368     	 ldr r3,[r4]
 3861 0974 43F00202 	 orr r2,r3,#2
 3862 0978 2260     	 str r2,[r4]
2562:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					{
 3863              	 .loc 1 2562 0
 3864 097a 226B     	 ldr r2,[r4,#48]
 3865 097c 12F0020F 	 tst r2,#2
 3866 0980 04D0     	 beq .L239
2564:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 					}
 3867              	 .loc 1 2564 0
 3868 0982 43F40073 	 orr r3,r3,#512
 3869 0986 43F00203 	 orr r3,r3,#2
 3870 098a 2360     	 str r3,[r4]
 3871              	.L239:
2584:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 3872              	 .loc 1 2584 0
 3873 098c A36F     	 ldr r3,[r4,#120]
 3874 098e 13B1     	 cbz r3,.L240
 3875              	.L241:
2586:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 3876              	 .loc 1 2586 0
 3877 0990 2046     	 mov r0,r4
 3878 0992 FFF7FEFF 	 bl prvTCPAddTxData
 3879              	.LVL502:
 3880              	.L240:
2589:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 3881              	 .loc 1 2589 0
 3882 0996 D4F8F830 	 ldr r3,[r4,#248]
 3883 099a C4F80431 	 str r3,[r4,#260]
2591:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 3884              	 .loc 1 2591 0
 3885 099e 94F84130 	 ldrb r3,[r4,#65]
 3886 09a2 13F0200F 	 tst r3,#32
 3887 09a6 02D1     	 bne .L242
 3888 09a8 19F0010F 	 tst r9,#1
 3889 09ac 21D0     	 beq .L245
 3890              	.L242:
 3891              	.LVL503:
2597:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 3892              	 .loc 1 2597 0
 3893 09ae 13F0400F 	 tst r3,#64
 3894 09b2 12D1     	 bne .L244
2600:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			bTxDone		= xTCPWindowTxDone( pxTCPWindow );
 3895              	 .loc 1 2600 0
 3896 09b4 DDF80CA0 	 ldr r10,[sp,#12]
 3897              	.LVL504:
 3898 09b8 5046     	 mov r0,r10
 3899 09ba FFF7FEFF 	 bl xTCPWindowRxEmpty
 3900              	.LVL505:
 3901 09be 8146     	 mov r9,r0
 3902              	.LVL506:
2601:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 3903              	 .loc 1 2601 0
 3904 09c0 5046     	 mov r0,r10
 3905              	.LVL507:
 3906 09c2 FFF7FEFF 	 bl xTCPWindowTxDone
 3907              	.LVL508:
2603:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 3908              	 .loc 1 2603 0
 3909 09c6 B9F1000F 	 cmp r9,#0
 3910 09ca 12D0     	 beq .L245
 3911 09cc 88B1     	 cbz r0,.L245
 3912              	.LVL509:
 3913 09ce D4F8E830 	 ldr r3,[r4,#232]
 3914 09d2 F31A     	 subs r3,r6,r3
2614:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				lDistance = ( int32_t ) ulIntermediateResult;
 3915              	 .loc 1 2614 0
 3916 09d4 3B44     	 add r3,r3,r7
2635:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 3917              	 .loc 1 2635 0
 3918 09d6 012B     	 cmp r3,#1
 3919 09d8 0BDC     	 bgt .L245
 3920              	.LVL510:
 3921              	.L244:
2637:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			xSendLength = prvTCPHandleFin( pxSocket, *ppxNetworkBuffer );
 3922              	 .loc 1 2637 0
 3923 09da 94F84130 	 ldrb r3,[r4,#65]
 3924 09de 43F02003 	 orr r3,r3,#32
 3925 09e2 84F84130 	 strb r3,[r4,#65]
 3926              	.LVL511:
2638:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 3927              	 .loc 1 2638 0
 3928 09e6 2046     	 mov r0,r4
 3929 09e8 0999     	 ldr r1,[sp,#36]
 3930 09ea FFF7FEFF 	 bl prvTCPHandleFin
 3931              	.LVL512:
 3932 09ee 0646     	 mov r6,r0
 3933              	.LVL513:
 3934 09f0 28E0     	 b .L222
 3935              	.LVL514:
 3936              	.L245:
2644:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 3937              	 .loc 1 2644 0
 3938 09f2 1023     	 movs r3,#16
 3939 09f4 88F82F30 	 strb r3,[r8,#47]
2646:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 3940              	 .loc 1 2646 0
 3941 09f8 002F     	 cmp r7,#0
 3942 09fa 00F0C580 	 beq .L246
 3943              	.LVL515:
2648:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			xSendLength = ( BaseType_t ) uxIntermediateResult;
 3944              	 .loc 1 2648 0
 3945 09fe 05F12806 	 add r6,r5,#40
 3946              	.LVL516:
2651:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 3947              	 .loc 1 2651 0
 3948 0a02 05F11403 	 add r3,r5,#20
 3949 0a06 9B00     	 lsls r3,r3,#2
 3950 0a08 88F82E30 	 strb r3,[r8,#46]
2653:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 3951              	 .loc 1 2653 0
 3952 0a0c 94F84130 	 ldrb r3,[r4,#65]
 3953 0a10 13F0400F 	 tst r3,#64
2655:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 3954              	 .loc 1 2655 0
 3955 0a14 1CBF     	 itt ne
 3956 0a16 D4F8FC30 	 ldrne r3,[r4,#252]
 3957 0a1a C4F8F830 	 strne r3,[r4,#248]
2664:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 3958              	 .loc 1 2664 0
 3959 0a1e 8DB9     	 cbnz r5,.L222
 3960 0a20 00E0     	 b .L266
 3961              	.LVL517:
 3962              	.L281:
 3963 0a22 0026     	 movs r6,#0
 3964              	.LVL518:
 3965              	.L266:
2668:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( lSendResult > 0 )
 3966              	 .loc 1 2668 0
 3967 0a24 2046     	 mov r0,r4
 3968 0a26 09A9     	 add r1,sp,#36
 3969              	.LVL519:
 3970 0a28 0022     	 movs r2,#0
 3971 0a2a FFF7FEFF 	 bl prvTCPPrepareSend
 3972              	.LVL520:
2669:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 3973              	 .loc 1 2669 0
 3974 0a2e 0028     	 cmp r0,#0
 3975 0a30 00F39380 	 bgt .L230
 3976 0a34 06E0     	 b .L222
 3977              	.LVL521:
 3978              	.L227:
 3979              	.LBE346:
 3980              	.LBE345:
2977:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			break;
 3981              	 .loc 1 2977 0
 3982 0a36 2046     	 mov r0,r4
 3983 0a38 0999     	 ldr r1,[sp,#36]
 3984 0a3a FFF7FEFF 	 bl prvTCPHandleFin
 3985              	.LVL522:
 3986 0a3e 0646     	 mov r6,r0
 3987              	.LVL523:
 3988 0a40 00E0     	 b .L222
 3989              	.LVL524:
 3990              	.L277:
2841:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint32_t ulReceiveLength;	/* Number of bytes contained in the TCP message. */
 3991              	 .loc 1 2841 0
 3992 0a42 0026     	 movs r6,#0
 3993              	.LVL525:
 3994              	.L222:
3006:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 3995              	 .loc 1 3006 0
 3996 0a44 002E     	 cmp r6,#0
 3997 0a46 41DD     	 ble .L248
 3998              	.LVL526:
 3999              	.L262:
 4000              	.LBB348:
 4001              	.LBB349:
2689:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	&( ( *ppxNetworkBuffer )->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + xIPHeaderSize( *ppxNetworkBuff
 4002              	 .loc 1 2689 0
 4003 0a48 099B     	 ldr r3,[sp,#36]
 4004 0a4a 9A69     	 ldr r2,[r3,#24]
 4005              	.LVL527:
2708:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	lRxSpace = ( int32_t ) ulRxBufferSpace;
 4006              	 .loc 1 2708 0
 4007 0a4c 656C     	 ldr r5,[r4,#68]
 4008              	.LVL528:
 4009 0a4e D4F8E800 	 ldr r0,[r4,#232]
 4010              	.LVL529:
2716:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 4011              	 .loc 1 2716 0
 4012 0a52 B4F84A10 	 ldrh r1,[r4,#74]
 4013              	.LVL530:
2723:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( lRxSpace >= lMinLength ) &&						/* There is Rx space for more data. */
 4014              	 .loc 1 2723 0
 4015 0a56 5FB3     	 cbz r7,.L249
2708:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	lRxSpace = ( int32_t ) ulRxBufferSpace;
 4016              	 .loc 1 2708 0
 4017 0a58 2D1A     	 subs r5,r5,r0
 4018              	.LVL531:
2723:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( lRxSpace >= lMinLength ) &&						/* There is Rx space for more data. */
 4019              	 .loc 1 2723 0
 4020 0a5a B5EB410F 	 cmp r5,r1,lsl#1
 4021 0a5e 27DB     	 blt .L249
2725:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( xSendLength == ipNUMERIC_CAST( BaseType_t, uxIPHeaderSizeSocket( pxSocket ) + ipSIZE_OF_TCP_HE
 4022              	 .loc 1 2725 0
 4023 0a60 94F84110 	 ldrb r1,[r4,#65]
 4024              	.LVL532:
2724:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED ) &&	/* Not in a closure phase. */
 4025              	 .loc 1 2724 0
 4026 0a64 11F0400F 	 tst r1,#64
 4027 0a68 22D1     	 bne .L249
2725:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( xSendLength == ipNUMERIC_CAST( BaseType_t, uxIPHeaderSizeSocket( pxSocket ) + ipSIZE_OF_TCP_HE
 4028              	 .loc 1 2725 0
 4029 0a6a 282E     	 cmp r6,#40
 4030 0a6c 20D1     	 bne .L249
2726:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eESTABLISHED ) &&	/* Connection established. */
 4031              	 .loc 1 2726 0
 4032 0a6e 94F85310 	 ldrb r1,[r4,#83]
 4033 0a72 0529     	 cmp r1,#5
 4034 0a74 1CD1     	 bne .L249
2727:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			( pxTCPHeader->ucTCPFlags == tcpTCP_FLAG_ACK ) )		/* There are no other flags than an ACK. */
 4035              	 .loc 1 2727 0
 4036 0a76 92F82F20 	 ldrb r2,[r2,#47]
 4037              	.LVL533:
 4038 0a7a 102A     	 cmp r2,#16
 4039 0a7c 18D1     	 bne .L249
2730:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 4040              	 .loc 1 2730 0
 4041 0a7e E06F     	 ldr r0,[r4,#124]
 4042 0a80 8342     	 cmp r3,r0
 4043 0a82 04D0     	 beq .L250
2733:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				{
 4044              	 .loc 1 2733 0
 4045 0a84 08B1     	 cbz r0,.L251
2735:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
 4046              	 .loc 1 2735 0
 4047 0a86 FFF7FEFF 	 bl vReleaseNetworkBufferAndDescriptor
 4048              	.LVL534:
 4049              	.L251:
2738:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 4050              	 .loc 1 2738 0
 4051 0a8a 099B     	 ldr r3,[sp,#36]
 4052 0a8c E367     	 str r3,[r4,#124]
 4053              	.L250:
2740:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				( lRxSpace < ipNUMERIC_CAST( int32_t, 2U * pxSocket->u.xTCP.usCurMSS ) ) )	/* There are less th
 4054              	 .loc 1 2740 0
 4055 0a8e B4F84A30 	 ldrh r3,[r4,#74]
 4056 0a92 9F42     	 cmp r7,r3
 4057 0a94 02D3     	 bcc .L252
 4058 0a96 B5EB430F 	 cmp r5,r3,lsl#1
 4059 0a9a 03DA     	 bge .L253
 4060              	.L252:
2743:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 4061              	 .loc 1 2743 0
 4062 0a9c 0223     	 movs r3,#2
 4063 0a9e A4F84830 	 strh r3,[r4,#72]
 4064 0aa2 02E0     	 b .L254
 4065              	.L253:
2750:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 4066              	 .loc 1 2750 0
 4067 0aa4 1423     	 movs r3,#20
 4068 0aa6 A4F84830 	 strh r3,[r4,#72]
 4069              	.L254:
2764:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			xSendLength = 0;
 4070              	 .loc 1 2764 0
 4071 0aaa 0023     	 movs r3,#0
 4072 0aac 0993     	 str r3,[sp,#36]
 4073              	.LVL535:
 4074 0aae 0DE0     	 b .L248
 4075              	.LVL536:
 4076              	.L249:
2767:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 4077              	 .loc 1 2767 0
 4078 0ab0 E06F     	 ldr r0,[r4,#124]
 4079              	.LVL537:
 4080 0ab2 0028     	 cmp r0,#0
 4081 0ab4 53D0     	 beq .L255
2771:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 4082              	 .loc 1 2771 0
 4083 0ab6 8342     	 cmp r3,r0
 4084 0ab8 01D0     	 beq .L256
2773:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 4085              	 .loc 1 2773 0
 4086 0aba FFF7FEFF 	 bl vReleaseNetworkBufferAndDescriptor
 4087              	.LVL538:
 4088              	.L256:
2776:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 4089              	 .loc 1 2776 0
 4090 0abe 0023     	 movs r3,#0
 4091 0ac0 E367     	 str r3,[r4,#124]
 4092 0ac2 4CE0     	 b .L255
 4093              	.L263:
 4094              	.LBE349:
 4095              	.LBE348:
 4096              	.LBE323:
 4097              	.LBE322:
3289:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				}
 4098              	 .loc 1 3289 0
 4099 0ac4 2046     	 mov r0,r4
 4100 0ac6 09A9     	 add r1,sp,#36
 4101              	.LVL539:
 4102 0ac8 FFF7FEFF 	 bl prvTCPSendRepeated
 4103              	.LVL540:
 4104              	.L248:
3294:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 4105              	 .loc 1 3294 0
 4106 0acc 0998     	 ldr r0,[sp,#36]
 4107 0ace 18B1     	 cbz r0,.L257
3299:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				#ifndef _lint
 4108              	 .loc 1 3299 0
 4109 0ad0 FFF7FEFF 	 bl vReleaseNetworkBufferAndDescriptor
 4110              	.LVL541:
3302:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				#endif
 4111              	 .loc 1 3302 0
 4112 0ad4 0023     	 movs r3,#0
 4113 0ad6 0993     	 str r3,[sp,#36]
 4114              	.L257:
3307:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* Return pdPASS to tell that the network buffer is 'consumed'. */
 4115              	 .loc 1 3307 0
 4116 0ad8 2046     	 mov r0,r4
 4117 0ada FFF7FEFF 	 bl prvTCPNextTimeout
 4118              	.LVL542:
3309:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 4119              	 .loc 1 3309 0
 4120 0ade 0120     	 movs r0,#1
 4121 0ae0 55E0     	 b .L286
 4122              	.LVL543:
 4123              	.L267:
 4124              	.LBE300:
3107:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 4125              	 .loc 1 3107 0
 4126 0ae2 0020     	 movs r0,#0
 4127              	.LVL544:
 4128 0ae4 53E0     	 b .L286
 4129              	.LVL545:
 4130              	.L190:
 4131              	.LBB362:
 4132              	.LBB295:
3384:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 4133              	 .loc 1 3384 0
 4134 0ae6 002D     	 cmp r5,#0
 4135 0ae8 7FF480AB 	 bne .L185
 4136 0aec 40E0     	 b .L183
 4137              	.LVL546:
 4138              	.L180:
 4139              	.LBE295:
 4140              	.LBE362:
 4141              	.LBB363:
3309:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 4142              	 .loc 1 3309 0
 4143 0aee 0020     	 movs r0,#0
 4144 0af0 4DE0     	 b .L286
 4145              	.LVL547:
 4146              	.L268:
 4147              	.LBB359:
 4148              	.LBB321:
 4149              	.LBB320:
 4150              	.LBB318:
1232:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
 4151              	 .loc 1 1232 0
 4152 0af2 0125     	 movs r5,#1
 4153 0af4 00E5     	 b .L201
 4154              	.L269:
1257:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 4155              	 .loc 1 1257 0
 4156 0af6 0325     	 movs r5,#3
 4157 0af8 FEE4     	 b .L201
 4158              	.LVL548:
 4159              	.L271:
1312:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
 4160              	 .loc 1 1312 0
 4161 0afa 0425     	 movs r5,#4
 4162              	.LVL549:
 4163 0afc FCE4     	 b .L201
 4164              	.LVL550:
 4165              	.L214:
 4166              	.LBE318:
 4167              	.LBE320:
 4168              	.LBE321:
 4169              	.LBE359:
 4170              	.LBB360:
 4171              	.LBB357:
 4172              	.LBB351:
 4173              	.LBB332:
2312:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 4174              	 .loc 1 2312 0
 4175 0afe D4F80831 	 ldr r3,[r4,#264]
 4176 0b02 002B     	 cmp r3,#0
 4177 0b04 7FF49BAD 	 bne .L258
 4178              	.L216:
 4179              	.LVL551:
 4180              	.LBE332:
 4181              	.LBE351:
 4182              	.LBB352:
 4183              	.LBB335:
2333:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	&( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + xIPHeaderSize( pxNetworkBuffer ) ] )
 4184              	 .loc 1 2333 0
 4185 0b08 099B     	 ldr r3,[sp,#36]
 4186 0b0a D3F81880 	 ldr r8,[r3,#24]
 4187              	.LVL552:
2337:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 4188              	 .loc 1 2337 0
 4189 0b0e 94F81491 	 ldrb r9,[r4,#276]
 4190              	.LVL553:
 4191 0b12 4D46     	 mov r5,r9
 4192              	.LVL554:
2340:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 4193              	 .loc 1 2340 0
 4194 0b14 B9F1000F 	 cmp r9,#0
 4195 0b18 7FF4A1AD 	 bne .L259
 4196 0b1c ACE5     	 b .L217
 4197              	.LVL555:
 4198              	.L288:
 4199              	.LBE335:
 4200              	.LBE352:
 4201              	.LBB353:
 4202              	.LBB343:
2396:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	&( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + uxIPHeaderSizeSocket( pxSocket ) ] )
 4203              	 .loc 1 2396 0
 4204 0b1e 099A     	 ldr r2,[sp,#36]
 4205 0b20 D2F81880 	 ldr r8,[r2,#24]
 4206              	.LVL556:
2400:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint32_t ulSequenceNumber = FreeRTOS_ntohl( pxTCPHeader->ulSequenceNumber );
 4207              	 .loc 1 2400 0
 4208 0b24 98F82F00 	 ldrb r0,[r8,#47]
 4209              	.LVL557:
2401:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** BaseType_t xSendLength = 0;
 4210              	 .loc 1 2401 0
 4211 0b28 D8F82620 	 ldr r2,[r8,#38]
 4212 0b2c 1106     	 lsls r1,r2,#24
 4213 0b2e 41EA1261 	 orr r1,r1,r2,lsr#24
 4214 0b32 02F47F46 	 and r6,r2,#65280
 4215              	.LVL558:
 4216 0b36 41EA0626 	 orr r6,r1,r6,lsl#8
 4217 0b3a 02F47F02 	 and r2,r2,#16711680
 4218 0b3e 46EA1226 	 orr r6,r6,r2,lsr#8
 4219              	.LVL559:
2406:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	if( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eCONNECT_SYN )
 4220              	 .loc 1 2406 0
 4221 0b42 1022     	 movs r2,#16
 4222 0b44 5AE6     	 b .L231
 4223              	.LVL560:
 4224              	.L220:
 4225              	.LBE343:
 4226              	.LBE353:
2898:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 4227              	 .loc 1 2898 0
 4228 0b46 1AF0010F 	 tst r10,#1
 4229 0b4a 16D1     	 bne .L260
 4230 0b4c E7E7     	 b .L288
 4231              	.LVL561:
 4232              	.L236:
 4233              	.LBB354:
 4234              	.LBB344:
2469:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
 4235              	 .loc 1 2469 0
 4236 0b4e D4F8F430 	 ldr r3,[r4,#244]
 4237 0b52 0133     	 adds r3,r3,#1
 4238 0b54 C4F80431 	 str r3,[r4,#260]
 4239 0b58 B6E6     	 b .L234
 4240              	.LVL562:
 4241              	.L230:
 4242              	.LBE344:
 4243              	.LBE354:
2841:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** uint32_t ulReceiveLength;	/* Number of bytes contained in the TCP message. */
 4244              	 .loc 1 2841 0
 4245 0b5a 0646     	 mov r6,r0
 4246 0b5c 74E7     	 b .L262
 4247              	.LVL563:
 4248              	.L255:
 4249              	.LBB355:
 4250              	.LBB350:
2806:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		#if( ipconfigZERO_COPY_TX_DRIVER != 0 )
 4251              	 .loc 1 2806 0
 4252 0b5e 2046     	 mov r0,r4
 4253 0b60 0999     	 ldr r1,[sp,#36]
 4254 0b62 3246     	 mov r2,r6
 4255 0b64 0023     	 movs r3,#0
 4256 0b66 FFF7FEFF 	 bl prvTCPReturnPacket
 4257              	.LVL564:
 4258              	.LBE350:
 4259              	.LBE355:
 4260              	.LBE357:
 4261              	.LBE360:
3283:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
 4262              	 .loc 1 3283 0
 4263 0b6a 002E     	 cmp r6,#0
 4264 0b6c AADC     	 bgt .L263
 4265 0b6e ADE7     	 b .L248
 4266              	.LVL565:
 4267              	.L183:
3309:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
 4268              	 .loc 1 3309 0
 4269 0b70 0020     	 movs r0,#0
 4270              	.LVL566:
 4271 0b72 0CE0     	 b .L286
 4272              	.LVL567:
 4273              	.L289:
 4274              	.LBB361:
 4275              	.LBB358:
2913:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 4276              	 .loc 1 2913 0
 4277 0b74 94F85330 	 ldrb r3,[r4,#83]
 4278 0b78 2AE6     	 b .L223
 4279              	.L260:
2898:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 4280              	 .loc 1 2898 0
 4281 0b7a 94F84130 	 ldrb r3,[r4,#65]
 4282 0b7e 13F0800F 	 tst r3,#128
 4283 0b82 3FF4B3AD 	 beq .L264
 4284 0b86 F5E7     	 b .L289
 4285              	.LVL568:
 4286              	.L246:
 4287              	.LBB356:
 4288              	.LBB347:
2664:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
 4289              	 .loc 1 2664 0
 4290 0b88 002D     	 cmp r5,#0
 4291 0b8a 9FD1     	 bne .L248
 4292 0b8c 49E7     	 b .L281
 4293              	.LVL569:
 4294              	.L286:
 4295              	.LBE347:
 4296              	.LBE356:
 4297              	.LBE358:
 4298              	.LBE361:
 4299              	.LBE363:
3314:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
 4300              	 .loc 1 3314 0
 4301 0b8e 0BB0     	 add sp,sp,#44
 4302              	.LCFI22:
 4303              	 .cfi_def_cfa_offset 36
 4304              	 
 4305 0b90 BDE8F08F 	 pop {r4,r5,r6,r7,r8,r9,r10,fp,pc}
 4306              	 .cfi_endproc
 4307              	.LFE81:
 4309              	 .section .text.xTCPCheckNewClient,"ax",%progbits
 4310              	 .align 2
 4311              	 .global xTCPCheckNewClient
 4312              	 .thumb
 4313              	 .thumb_func
 4315              	xTCPCheckNewClient:
 4316              	.LFB84:
3498:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		xResult = pdFALSE;
3499:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
3500:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	else
3501:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
3502:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		xResult = pdTRUE;
3503:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
3504:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3505:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	return xResult;
3506:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** }
3507:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
3508:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3509:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #if( ( ipconfigHAS_DEBUG_PRINTF != 0 ) || ( ipconfigHAS_PRINTF != 0 ) )
3510:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3511:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	const char *FreeRTOS_GetTCPStateName( UBaseType_t ulState )
3512:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
3513:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	static const char * const pcStateNames[] =
3514:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
3515:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		"eCLOSED",
3516:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		"eTCP_LISTEN",
3517:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		"eCONNECT_SYN",
3518:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		"eSYN_FIRST",
3519:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		"eSYN_RECEIVED",
3520:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		"eESTABLISHED",
3521:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		"eFIN_WAIT_1",
3522:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		"eFIN_WAIT_2",
3523:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		"eCLOSE_WAIT",
3524:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		"eCLOSING",
3525:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		"eLAST_ACK",
3526:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		"eTIME_WAIT",
3527:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		"eUNKNOWN",
3528:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	};
3529:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	BaseType_t xIndex = ( BaseType_t ) ulState;
3530:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3531:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( ( xIndex < 0 ) || ( xIndex >= ARRAY_SIZE( pcStateNames ) ) )
3532:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
3533:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			/* The last item is called 'eUNKNOWN' */
3534:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			xIndex = ARRAY_SIZE( pcStateNames );
3535:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			xIndex--;
3536:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
3537:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		return pcStateNames[ xIndex ];
3538:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
3539:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3540:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** #endif /* ( ( ipconfigHAS_DEBUG_PRINTF != 0 ) || ( ipconfigHAS_PRINTF != 0 ) ) */
3541:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*-----------------------------------------------------------*/
3542:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3543:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** /*
3544:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * In the API accept(), the user asks is there is a new client?  As API's can
3545:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  * not walk through the xBoundTCPSocketsList the IP-task will do this.
3546:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c ****  */
3547:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** BaseType_t xTCPCheckNewClient( FreeRTOS_Socket_t *pxSocket )
3548:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** {
 4317              	 .loc 1 3548 0
 4318              	 .cfi_startproc
 4319              	 
 4320              	 
 4321              	 
 4322              	.LVL570:
3549:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** TickType_t uxLocalPort = ( TickType_t ) FreeRTOS_htons( pxSocket->usLocalPort );
 4323              	 .loc 1 3549 0
 4324 0000 818C     	 ldrh r1,[r0,#36]
 4325 0002 0B0A     	 lsrs r3,r1,#8
 4326 0004 43EA0121 	 orr r1,r3,r1,lsl#8
 4327 0008 89B2     	 uxth r1,r1
 4328              	.LVL571:
3550:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** const ListItem_t *pxIterator;
3551:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** FreeRTOS_Socket_t *pxFound;
3552:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** BaseType_t xResult = pdFALSE;
3553:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** const ListItem_t *pxEndTCP = listGET_END_MARKER( &xBoundTCPSocketsList );
3554:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 
3555:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	/* Here xBoundTCPSocketsList can be accessed safely IP-task is the only one
3556:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	who has access. */
3557:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	for( pxIterator = ( const ListItem_t * ) listGET_HEAD_ENTRY( &xBoundTCPSocketsList );
 4329              	 .loc 1 3557 0
 4330 000a 104A     	 ldr r2,.L311
 4331 000c D368     	 ldr r3,[r2,#12]
 4332              	.LVL572:
 4333 000e 0832     	 adds r2,r2,#8
 4334 0010 9342     	 cmp r3,r2
 4335 0012 16D0     	 beq .L306
3548:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** TickType_t uxLocalPort = ( TickType_t ) FreeRTOS_htons( pxSocket->usLocalPort );
 4336              	 .loc 1 3548 0
 4337 0014 30B4     	 push {r4,r5}
 4338              	.LCFI23:
 4339              	 .cfi_def_cfa_offset 8
 4340              	 .cfi_offset 4,-8
 4341              	 .cfi_offset 5,-4
 4342              	 .loc 1 3557 0
 4343 0016 1446     	 mov r4,r2
 4344              	.L307:
3558:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxIterator != pxEndTCP;
3559:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxIterator = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
3560:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
3561:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		if( listGET_LIST_ITEM_VALUE( pxIterator ) == ( configLIST_VOLATILE TickType_t ) uxLocalPort )
 4345              	 .loc 1 3561 0
 4346 0018 1A68     	 ldr r2,[r3]
 4347 001a 8A42     	 cmp r2,r1
 4348 001c 0CD1     	 bne .L304
3562:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		{
3563:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			pxFound = ipCAST_PTR_TO_TYPE_PTR( FreeRTOS_Socket_t, listGET_LIST_ITEM_OWNER( pxIterator ) );
 4349              	 .loc 1 3563 0
 4350 001e DA68     	 ldr r2,[r3,#12]
 4351              	.LVL573:
3564:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			if( ( pxFound->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_TCP ) && ( pxFound->u.xTCP.bits.bPassA
 4352              	 .loc 1 3564 0
 4353 0020 92F82750 	 ldrb r5,[r2,#39]
 4354 0024 062D     	 cmp r5,#6
 4355 0026 07D1     	 bne .L304
 4356              	 .loc 1 3564 0 is_stmt 0 discriminator 1
 4357 0028 92F84050 	 ldrb r5,[r2,#64]
 4358 002c 15F0020F 	 tst r5,#2
 4359 0030 02D0     	 beq .L304
3565:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			{
3566:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				pxSocket->u.xTCP.pxPeerSocket = pxFound;
 4360              	 .loc 1 3566 0 is_stmt 1
 4361 0032 4265     	 str r2,[r0,#84]
 4362              	.LVL574:
3567:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				FreeRTOS_debug_printf( ( "xTCPCheckNewClient[0]: client on port %u\n", pxSocket->usLocalPort ) 
3568:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				xResult = pdTRUE;
 4363              	 .loc 1 3568 0
 4364 0034 0120     	 movs r0,#1
 4365              	.LVL575:
3569:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 				break;
 4366              	 .loc 1 3569 0
 4367 0036 06E0     	 b .L303
 4368              	.LVL576:
 4369              	.L304:
3559:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	{
 4370              	 .loc 1 3559 0
 4371 0038 5B68     	 ldr r3,[r3,#4]
 4372              	.LVL577:
3557:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		pxIterator != pxEndTCP;
 4373              	 .loc 1 3557 0
 4374 003a A342     	 cmp r3,r4
 4375 003c ECD1     	 bne .L307
3552:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** const ListItem_t *pxEndTCP = listGET_END_MARKER( &xBoundTCPSocketsList );
 4376              	 .loc 1 3552 0
 4377 003e 0020     	 movs r0,#0
 4378              	.LVL578:
 4379 0040 01E0     	 b .L303
 4380              	.LVL579:
 4381              	.L306:
 4382              	.LCFI24:
 4383              	 .cfi_def_cfa_offset 0
 4384              	 .cfi_restore 4
 4385              	 .cfi_restore 5
 4386 0042 0020     	 movs r0,#0
 4387              	.LVL580:
 4388 0044 7047     	 bx lr
 4389              	.LVL581:
 4390              	.L303:
 4391              	.LCFI25:
 4392              	 .cfi_def_cfa_offset 8
 4393              	 .cfi_offset 4,-8
 4394              	 .cfi_offset 5,-4
3570:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 			}
3571:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 		}
3572:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	}
3573:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** 	return xResult;
3574:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_IP.c **** }
 4395              	 .loc 1 3574 0
 4396 0046 30BC     	 pop {r4,r5}
 4397              	.LCFI26:
 4398              	 .cfi_restore 5
 4399              	 .cfi_restore 4
 4400              	 .cfi_def_cfa_offset 0
 4401 0048 7047     	 bx lr
 4402              	.L312:
 4403 004a 00BF     	 .align 2
 4404              	.L311:
 4405 004c 00000000 	 .word xBoundTCPSocketsList
 4406              	 .cfi_endproc
 4407              	.LFE84:
 4409              	 .text
 4410              	.Letext0:
 4411              	 .file 6 "e:\\embedded\\dave_4-4-2_64bit_2018-02-23\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 4412              	 .file 7 "e:\\embedded\\dave_4-4-2_64bit_2018-02-23\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 4413              	 .file 8 "e:\\embedded\\dave_4-4-2_64bit_2018-02-23\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\lib\\gcc\\arm-none-eabi\\4.9.3\\include\\stddef.h"
 4414              	 .file 9 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/include/list.h"
 4415              	 .file 10 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/include/event_groups.h"
 4416              	 .file 11 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include/FreeRTOS_Sockets.h"
 4417              	 .file 12 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include/FreeRTOS_TCP_WIN.h"
 4418              	 .file 13 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include/FreeRTOS_TCP_IP.h"
 4419              	 .file 14 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include/FreeRTOS_ARP.h"
 4420              	 .file 15 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include/NetworkInterface.h"
 4421              	 .file 16 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include/NetworkBufferManagement.h"
 4422              	 .file 17 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/include/task.h"
DEFINED SYMBOLS
                            *ABS*:00000000 FreeRTOS_TCP_IP.c
    {standard input}:19     .text.prvTCPAddTxData:00000000 $t
    {standard input}:23     .text.prvTCPAddTxData:00000000 prvTCPAddTxData
    {standard input}:139    .text.prvTCPReturnPacket:00000000 $t
    {standard input}:143    .text.prvTCPReturnPacket:00000000 prvTCPReturnPacket
    {standard input}:502    .text.prvTCPReturnPacket:00000208 $d
    {standard input}:509    .text.prvTCPSendReset:00000000 $t
    {standard input}:513    .text.prvTCPSendReset:00000000 prvTCPSendReset
    {standard input}:555    .text.prvTCPCreateWindow:00000000 $t
    {standard input}:559    .text.prvTCPCreateWindow:00000000 prvTCPCreateWindow
    {standard input}:602    .text.prvTCPNextTimeout:00000000 $t
    {standard input}:606    .text.prvTCPNextTimeout:00000000 prvTCPNextTimeout
    {standard input}:742    .text.prvTCPNextTimeout:000000c8 $d
    {standard input}:747    .text.vTCPStateChange:00000000 $t
    {standard input}:752    .text.vTCPStateChange:00000000 vTCPStateChange
    {standard input}:859    .text.vTCPStateChange:0000007e $d
    {standard input}:872    .text.vTCPStateChange:0000008a $t
    {standard input}:1064   .text.vTCPStateChange:00000194 $d
    {standard input}:1077   .text.vTCPStateChange:000001c4 $t
    {standard input}:1086   .text.prvTCPPrepareSend:00000000 $t
    {standard input}:1090   .text.prvTCPPrepareSend:00000000 prvTCPPrepareSend
    {standard input}:1594   .text.prvTCPPrepareSend:000002c8 $d
    {standard input}:1600   .text.prvTCPSendRepeated:00000000 $t
    {standard input}:1604   .text.prvTCPSendRepeated:00000000 prvTCPSendRepeated
    {standard input}:1665   .text.xTCPSocketCheck:00000000 $t
    {standard input}:1670   .text.xTCPSocketCheck:00000000 xTCPSocketCheck
    {standard input}:2099   .text.xTCPSocketCheck:00000284 $d
    {standard input}:2108   .text.xTCPSocketCheck:000002a8 $t
    {standard input}:2162   .text.xTCPSocketCheck:000002e0 $d
    {standard input}:2168   .text.prvTCPHandleFin:00000000 $t
    {standard input}:2172   .text.prvTCPHandleFin:00000000 prvTCPHandleFin
    {standard input}:2313   .text.xProcessReceivedTCPPacket:00000000 $t
    {standard input}:2318   .text.xProcessReceivedTCPPacket:00000000 xProcessReceivedTCPPacket
    {standard input}:2455   .text.xProcessReceivedTCPPacket:000000ae $d
    {standard input}:2468   .text.xProcessReceivedTCPPacket:000000ba $t
    {standard input}:3013   .text.xProcessReceivedTCPPacket:00000444 $d
    {standard input}:3017   .text.xProcessReceivedTCPPacket:00000448 $t
    {standard input}:3508   .text.xProcessReceivedTCPPacket:00000720 $d
    {standard input}:3517   .text.xProcessReceivedTCPPacket:00000732 $t
    {standard input}:4310   .text.xTCPCheckNewClient:00000000 $t
    {standard input}:4315   .text.xTCPCheckNewClient:00000000 xTCPCheckNewClient
    {standard input}:4405   .text.xTCPCheckNewClient:0000004c $d
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.0.3466fc6a3db32493c997d085de4c7a28
                           .group:00000000 wm4.features.h.22.bee0aee4a3878f51861c775df98fa3ea
                           .group:00000000 wm4._default_types.h.15.933e8edd27a65e0b69af4a865eb623d2
                           .group:00000000 wm4._intsup.h.10.ca9f32a61b410c270a48d1161ca2c217
                           .group:00000000 wm4.stdint.h.22.f4a337c398d8b6d821a97202448bc0d0
                           .group:00000000 wm4.newlib.h.8.fe7d912fc917043c98742c35eddd8cff
                           .group:00000000 wm4.config.h.216.aad1ef7bee4fb69981cb38ce62f84d9c
                           .group:00000000 wm4._ansi.h.23.9f8fcfa20193763fcf364fb91705c94b
                           .group:00000000 wm4.stdio.h.31.7c0e28c411445f3f9c5b11accf882760
                           .group:00000000 wm4.stddef.h.184.159df79b4ca79c76561572a55985524c
                           .group:00000000 wm4.cdefs.h.47.4002528de975c0fcce6c551c15d87b8c
                           .group:00000000 wm4.stddef.h.39.fb88e218f22ad7a0ab38f3d93c6eb3e4
                           .group:00000000 wm4.stdarg.h.34.3a23a216c0c293b3d2ea2e89281481e6
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4._types.h.54.d3d34a3b7f3cc230cd159baf022b4b08
                           .group:00000000 wm4.stddef.h.158.61317cdbfb4026324507d123a50b0fd6
                           .group:00000000 wm4.reent.h.17.8bd9e4098e0428508c282cad794fae43
                           .group:00000000 wm4.types.h.23.0d949686bbcadd1621462d4fa1f884f9
                           .group:00000000 wm4.types.h.2.e9cec8c90ab35f77d9f499e06ae02400
                           .group:00000000 wm4.types.h.80.56707660962b21991903f1fee7c13bb3
                           .group:00000000 wm4.stdio.h.2.4aa87247282eca6c8f36f9de33d8df1a
                           .group:00000000 wm4.stdio.h.65.7c7009d79fb33c27bcf8e2214c76b343
                           .group:00000000 wm4.FreeRTOSConfig.h.30.aa43eb1cb33228d5c7e359a94d48589b
                           .group:00000000 wm4.projdefs.h.28.d6a7c9061b707820f2fcf4c2ff5d9f24
                           .group:00000000 wm4.portmacro.h.30.2ddc2eaf2e032c76c597fb78c4365041
                           .group:00000000 wm4.portable.h.63.e9cc508c3850f44ce542149380c67812
                           .group:00000000 wm4.mpu_wrappers.h.28.163fb40577cf8d1578015ea3f2ff4cdb
                           .group:00000000 wm4.FreeRTOS.h.67.9945f39eea4ddeb224c0782392206292
                           .group:00000000 wm4.list.h.57.02ec67e07eacffe5ca7cfb7326896236
                           .group:00000000 wm4.task.h.47.2d3fe49a094b8ec1e3e6aac441e8db21
                           .group:00000000 wm4.queue.h.66.45d4a3cf5de24cde7e732f8dad25383c
                           .group:00000000 wm4.semphr.h.38.96f44691bfa19eb833944d3a35b81e54
                           .group:00000000 wm4.FreeRTOSIPConfig.h.37.3f9c1db988571ff1f3dec4c7e54978d6
                           .group:00000000 wm4.FreeRTOS_errno_TCP.h.27.708877b341d0e6bcb4ba112b2ad8082a
                           .group:00000000 wm4.FreeRTOSIPConfigDefaults.h.41.f972b11d9b1eba5383080cfaef1fd740
                           .group:00000000 wm4.IPTraceMacroDefaults.h.31.69642530b5a79c93e762c9b09ac0d1d5
                           .group:00000000 wm4.FreeRTOS_IP.h.59.3f5e36f6612bd0c66747c6093da47335
                           .group:00000000 wm4.FreeRTOS_IP.h.179.e5077063e624bc5d3f02542470d6ea94
                           .group:00000000 wm4.string.h.8.c4b8571ce60dff2817f43fec8b86aecd
                           .group:00000000 wm4.stddef.h.158.a7efb00f6cbc6f43213b50e183c9830c
                           .group:00000000 wm4.timers.h.29.025d268d6baf57298309e7b498ee1cc7
                           .group:00000000 wm4.FreeRTOS_Sockets.h.58.61d472da32c0e0f5bc49c368f15d0ac5
                           .group:00000000 wm4.FreeRTOS_TCP_WIN.h.32.f3cfab69924f28284deb16cc1a30fb93
                           .group:00000000 wm4.FreeRTOS_IP_Private.h.52.551f932b14473cea139893dda31b3fa0
                           .group:00000000 wm4.FreeRTOS_IP_Private.h.328.b5788f8d626a4cf16b8282f9399f3f55

UNDEFINED SYMBOLS
lTCPWindowTxAdd
usGenerateChecksum
usGenerateProtocolChecksum
xNetworkInterfaceOutput
xDefaultPartUDPPacketHeader
usPacketIdentifier
vTCPWindowCreate
xTCPWindowTxHasData
FreeRTOS_closesocket
xTaskGetTickCount
vSocketWakeUpUser
ulTCPWindowTxGet
xTCPWindowTxDone
uxStreamBufferGet
memcpy
vReleaseNetworkBufferAndDescriptor
pxGetNetworkBufferWithDescriptor
xBufferAllocFixedSize
eARPGetCacheEntry
FreeRTOS_OutputARPRequest
ulApplicationGetNextSequenceNumber
memset
vSocketClose
pxTCPSocketLookup
FreeRTOS_socket
vSocketBind
ulTCPWindowTxSack
lTCPWindowRxCheck
lTCPAddRxdata
vTCPWindowInit
ulTCPWindowTxAck
xTCPWindowRxEmpty
xBoundTCPSocketsList
