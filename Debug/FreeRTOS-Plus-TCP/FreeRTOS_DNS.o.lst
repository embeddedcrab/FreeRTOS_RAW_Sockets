   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .eabi_attribute 28,1
   5              	 .fpu fpv4-sp-d16
   6              	 .eabi_attribute 23,1
   7              	 .eabi_attribute 24,1
   8              	 .eabi_attribute 25,1
   9              	 .eabi_attribute 26,1
  10              	 .eabi_attribute 30,1
  11              	 .eabi_attribute 34,1
  12              	 .eabi_attribute 18,4
  13              	 .thumb
  14              	 .file "FreeRTOS_DNS.c"
  15              	 .text
  16              	.Ltext0:
  17              	 .cfi_sections .debug_frame
  18              	 .section .text.prvSkipNameField,"ax",%progbits
  19              	 .align 2
  20              	 .thumb
  21              	 .thumb_func
  23              	prvSkipNameField:
  24              	.LFB68:
  25              	 .file 1 "../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c"
   1:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /*
   2:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  * FreeRTOS+TCP V2.2.2
   3:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  *
   5:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  * this software and associated documentation files (the "Software"), to deal in
   7:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  * the Software without restriction, including without limitation the rights to
   8:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  * subject to the following conditions:
  11:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  *
  12:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  * The above copyright notice and this permission notice shall be included in all
  13:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  * copies or substantial portions of the Software.
  14:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  *
  15:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  *
  22:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  * http://aws.amazon.com/freertos
  23:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  * http://www.FreeRTOS.org
  24:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  */
  25:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
  26:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /* Standard includes. */
  27:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #include <stdint.h>
  28:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #include <stdio.h>
  29:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
  30:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /* FreeRTOS includes. */
  31:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #include "FreeRTOS.h"
  32:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #include "task.h"
  33:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #include "semphr.h"
  34:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
  35:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /* FreeRTOS+TCP includes. */
  36:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #include "FreeRTOS_IP.h"
  37:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #include "FreeRTOS_Sockets.h"
  38:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #include "FreeRTOS_IP_Private.h"
  39:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #include "FreeRTOS_UDP_IP.h"
  40:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #include "FreeRTOS_DNS.h"
  41:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #include "FreeRTOS_DHCP.h"
  42:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #include "NetworkBufferManagement.h"
  43:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #include "NetworkInterface.h"
  44:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
  45:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #include "FreeRTOSIPConfigDefaults.h"
  46:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
  47:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /* Exclude the entire file if DNS is not enabled. */
  48:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #if( ipconfigUSE_DNS != 0 )
  49:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
  50:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #if( ipconfigBYTE_ORDER == pdFREERTOS_LITTLE_ENDIAN )
  51:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#define dnsDNS_PORT						0x3500U
  52:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#define dnsONE_QUESTION					0x0100U
  53:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#define dnsOUTGOING_FLAGS				0x0001U /* Standard query. */
  54:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#define dnsRX_FLAGS_MASK				0x0f80U /* The bits of interest in the flags field of incoming DNS mes
  55:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#define dnsEXPECTED_RX_FLAGS			0x0080U /* Should be a response, without any errors. */
  56:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #else
  57:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#define dnsDNS_PORT						0x0035U
  58:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#define dnsONE_QUESTION					0x0001U
  59:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#define dnsOUTGOING_FLAGS				0x0100U /* Standard query. */
  60:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#define dnsRX_FLAGS_MASK				0x800fU /* The bits of interest in the flags field of incoming DNS mes
  61:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#define dnsEXPECTED_RX_FLAGS			0x8000U /* Should be a response, without any errors. */
  62:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
  63:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #endif /* ipconfigBYTE_ORDER */
  64:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
  65:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /* The maximum number of times a DNS request should be sent out if a response
  66:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** is not received, before giving up. */
  67:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #ifndef ipconfigDNS_REQUEST_ATTEMPTS
  68:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#define ipconfigDNS_REQUEST_ATTEMPTS		5
  69:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #endif
  70:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
  71:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /* If the top two bits in the first character of a name field are set then the
  72:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** name field is an offset to the string, rather than the string itself. */
  73:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #define dnsNAME_IS_OFFSET					( ( uint8_t ) 0xc0 )
  74:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
  75:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /* NBNS flags. */
  76:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #if( ipconfigUSE_NBNS == 1 )
  77:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#define dnsNBNS_FLAGS_RESPONSE				0x8000U
  78:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#define dnsNBNS_FLAGS_OPCODE_MASK			0x7800U
  79:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#define dnsNBNS_FLAGS_OPCODE_QUERY			0x0000U
  80:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #endif	/* ( ipconfigUSE_NBNS == 1 ) */
  81:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
  82:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /* Host types. */
  83:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #define dnsTYPE_A_HOST							0x01U
  84:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #define dnsCLASS_IN								0x01U
  85:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
  86:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #ifndef _lint
  87:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	/* LLMNR constants. */
  88:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#define dnsLLMNR_TTL_VALUE					300000UL
  89:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#define dnsLLMNR_FLAGS_IS_REPONSE			0x8000U
  90:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #endif	/* _lint */
  91:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
  92:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /* NBNS constants. */
  93:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #if( ipconfigUSE_NBNS != 0 )
  94:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#define dnsNBNS_TTL_VALUE					3600UL /* 1 hour valid */
  95:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#define dnsNBNS_TYPE_NET_BIOS				0x0020U
  96:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#define dnsNBNS_CLASS_IN					0x01U
  97:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#define dnsNBNS_NAME_FLAGS					0x6000U
  98:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#define dnsNBNS_ENCODED_NAME_LENGTH			32
  99:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 100:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	/* If the queried NBNS name matches with the device's name,
 101:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	the query will be responded to with these flags: */
 102:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#define dnsNBNS_QUERY_RESPONSE_FLAGS		( 0x8500U )
 103:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #endif	/* ( ipconfigUSE_NBNS != 0 ) */
 104:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 105:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /* Flag DNS parsing errors in situations where an IPv4 address is the return
 106:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** type. */
 107:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #define dnsPARSE_ERROR							0UL
 108:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 109:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #ifndef _lint
 110:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#if( ipconfigUSE_DNS_CACHE == 0 )
 111:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		#if( ipconfigDNS_CACHE_ADDRESSES_PER_ENTRY != 1 )
 112:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			#error When DNS caching is disabled, please make ipconfigDNS_CACHE_ADDRESSES_PER_ENTRY equal to 
 113:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		#endif
 114:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#endif
 115:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #endif
 116:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 117:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /* Define the ASCII value of '.' (Period/Full-stop). */
 118:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #define ASCII_BASELINE_DOT						46U
 119:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 120:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /*
 121:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  * Create a socket and bind it to the standard DNS port number.  Return the
 122:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  * the created socket - or NULL if the socket could not be created or bound.
 123:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  */
 124:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** static Socket_t prvCreateDNSSocket( void );
 125:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 126:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /*
 127:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  * Create the DNS message in the zero copy buffer passed in the first parameter.
 128:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  */
 129:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** _static size_t prvCreateDNSMessage( uint8_t *pucUDPPayloadBuffer,
 130:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								   const char *pcHostName,
 131:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								   TickType_t uxIdentifier );
 132:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 133:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /*
 134:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  * Simple routine that jumps over the NAME field of a resource record.
 135:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  * It returns the number of bytes read.
 136:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  */
 137:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** _static size_t prvSkipNameField( const uint8_t *pucByte,
 138:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								size_t uxLength );
 139:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 140:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /*
 141:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  * Process a response packet from a DNS server.
 142:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  * The parameter 'xExpected' indicates whether the identifier in the reply
 143:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  * was expected, and thus if the DNS cache may be updated with the reply.
 144:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  */
 145:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** _static uint32_t prvParseDNSReply( uint8_t *pucUDPPayloadBuffer,
 146:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								  size_t uxBufferLength,
 147:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								  BaseType_t xExpected );
 148:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 149:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /*
 150:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  * Check if hostname is already known. If not, call prvGetHostByName() to send a DNS request.
 151:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  */
 152:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #if( ipconfigDNS_USE_CALLBACKS == 1 )
 153:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	static uint32_t prvPrepareLookup( const char *pcHostName,
 154:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 									  FOnDNSEvent pCallback,
 155:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 									  void *pvSearchID,
 156:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 									  TickType_t uxTimeout );
 157:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #else
 158:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	static uint32_t prvPrepareLookup( const char *pcHostName );
 159:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #endif
 160:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 161:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /*
 162:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  * Prepare and send a message to a DNS server.  'uxReadTimeOut_ticks' will be passed as
 163:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  * zero, in case the user has supplied a call-back function.
 164:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  */
 165:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** static uint32_t prvGetHostByName( const char *pcHostName,
 166:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								  TickType_t uxIdentifier,
 167:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								  TickType_t uxReadTimeOut_ticks );
 168:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 169:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #if( ipconfigDNS_USE_CALLBACKS != 0 )
 170:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	static void vDNSSetCallBack( const char *pcHostName,
 171:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								 void *pvSearchID,
 172:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								 FOnDNSEvent pCallbackFunction,
 173:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								 TickType_t uxTimeout,
 174:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								 TickType_t uxIdentifier );
 175:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #endif	/* ipconfigDNS_USE_CALLBACKS */
 176:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 177:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #if( ipconfigDNS_USE_CALLBACKS != 0 )
 178:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	static BaseType_t xDNSDoCallback( TickType_t uxIdentifier,
 179:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 									  const char *pcName,
 180:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 									  uint32_t ulIPAddress );
 181:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #endif	/* ipconfigDNS_USE_CALLBACKS */
 182:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 183:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /*
 184:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  * The NBNS and the LLMNR protocol share this reply function.
 185:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  */
 186:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #if( ( ipconfigUSE_NBNS == 1 ) || ( ipconfigUSE_LLMNR == 1 ) )
 187:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	static void prvReplyDNSMessage( NetworkBufferDescriptor_t *pxNetworkBuffer,
 188:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 									BaseType_t lNetLength );
 189:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #endif
 190:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 191:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #if( ipconfigUSE_NBNS == 1 )
 192:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	static portINLINE void prvTreatNBNS( uint8_t *pucPayload,
 193:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 										 size_t uxBufferLength,
 194:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 										 uint32_t ulIPAddress );
 195:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #endif /* ipconfigUSE_NBNS */
 196:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 197:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 198:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #if( ipconfigUSE_DNS_CACHE == 1 ) || ( ipconfigDNS_USE_CALLBACKS == 1 )
 199:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	_static size_t prvReadNameField( const uint8_t *pucByte,
 200:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 									size_t uxRemainingBytes,
 201:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 									char *pcName,
 202:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 									size_t uxDestLen );
 203:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #endif	/* ipconfigUSE_DNS_CACHE || ipconfigDNS_USE_CALLBACKS */
 204:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 205:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #if( ipconfigUSE_DNS_CACHE == 1 )
 206:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	static BaseType_t prvProcessDNSCache( const char *pcName,
 207:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 										  uint32_t *pulIP,
 208:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 										  uint32_t ulTTL,
 209:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 										  BaseType_t xLookUp );
 210:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 211:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	typedef struct xDNS_CACHE_TABLE_ROW
 212:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
 213:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		uint32_t ulIPAddresses[ ipconfigDNS_CACHE_ADDRESSES_PER_ENTRY ]; /* The IP address(es) of an ARP 
 214:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		char pcName[ ipconfigDNS_CACHE_NAME_LENGTH ]; /* The name of the host */
 215:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		uint32_t ulTTL;                               /* Time-to-Live (in seconds) from the DNS server. *
 216:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		uint32_t ulTimeWhenAddedInSeconds;
 217:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #if( ipconfigDNS_CACHE_ADDRESSES_PER_ENTRY > 1 )
 218:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		uint8_t  ucNumIPAddresses;
 219:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		uint8_t  ucCurrentIPAddress;
 220:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #endif
 221:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	} DNSCacheRow_t;
 222:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 223:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	static DNSCacheRow_t xDNSCache[ ipconfigDNS_CACHE_ENTRIES ];
 224:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 225:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	/* Utility function: Clear DNS cache by calling this function. */
 226:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	void FreeRTOS_dnsclear( void )
 227:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
 228:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		( void ) memset( xDNSCache, 0x0, sizeof( xDNSCache ) );
 229:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
 230:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #endif /* ipconfigUSE_DNS_CACHE == 1 */
 231:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 232:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #if( ipconfigUSE_LLMNR == 1 )
 233:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	const MACAddress_t xLLMNR_MacAdress = { { 0x01, 0x00, 0x5e, 0x00, 0x00, 0xfc } };
 234:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #endif /* ipconfigUSE_LLMNR == 1 */
 235:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 236:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /*-----------------------------------------------------------*/
 237:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 238:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /* Below #include just tells the compiler to pack the structure. 
 239:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  * It is included in to make the code more readable */
 240:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #include "pack_struct_start.h"
 241:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** struct xDNSMessage
 242:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** {
 243:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	uint16_t usIdentifier;
 244:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	uint16_t usFlags;
 245:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	uint16_t usQuestions;
 246:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	uint16_t usAnswers;
 247:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	uint16_t usAuthorityRRs;
 248:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	uint16_t usAdditionalRRs;
 249:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** }
 250:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #include "pack_struct_end.h"
 251:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** typedef struct xDNSMessage DNSMessage_t;
 252:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 253:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** static portINLINE ipDECL_CAST_PTR_FUNC_FOR_TYPE( DNSMessage_t )
 254:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** {
 255:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	return ( DNSMessage_t *)pvArgument;
 256:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** }
 257:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** static portINLINE ipDECL_CAST_CONST_PTR_FUNC_FOR_TYPE( DNSMessage_t )
 258:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** {
 259:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	return ( const DNSMessage_t *) pvArgument;
 260:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** }
 261:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 262:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /* A DNS query consists of a header, as described in 'struct xDNSMessage'
 263:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** It is followed by 1 or more queries, each one consisting of a name and a tail,
 264:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** with two fields: type and class
 265:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** */
 266:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #include "pack_struct_start.h"
 267:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** struct xDNSTail
 268:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** {
 269:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	uint16_t usType;
 270:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	uint16_t usClass;
 271:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** }
 272:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #include "pack_struct_end.h"
 273:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** typedef struct xDNSTail DNSTail_t;
 274:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 275:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** static portINLINE ipDECL_CAST_PTR_FUNC_FOR_TYPE( DNSTail_t )
 276:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** {
 277:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	return ( DNSTail_t * ) pvArgument;
 278:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** }
 279:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 280:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /* DNS answer record header. */
 281:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #include "pack_struct_start.h"
 282:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** struct xDNSAnswerRecord
 283:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** {
 284:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	uint16_t usType;
 285:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	uint16_t usClass;
 286:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	uint32_t ulTTL;
 287:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	uint16_t usDataLength;
 288:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** }
 289:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #include "pack_struct_end.h"
 290:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** typedef struct xDNSAnswerRecord DNSAnswerRecord_t;
 291:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 292:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** static portINLINE ipDECL_CAST_PTR_FUNC_FOR_TYPE( DNSAnswerRecord_t )
 293:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** {
 294:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	return ( DNSAnswerRecord_t * ) pvArgument;
 295:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** }
 296:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 297:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #if( ipconfigUSE_LLMNR == 1 )
 298:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 299:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#include "pack_struct_start.h"
 300:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	struct xLLMNRAnswer
 301:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
 302:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		uint8_t ucNameCode;
 303:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		uint8_t ucNameOffset;   /* The name is not repeated in the answer, only the offset is given with 
 304:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		uint16_t usType;
 305:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		uint16_t usClass;
 306:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		uint32_t ulTTL;
 307:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		uint16_t usDataLength;
 308:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		uint32_t ulIPAddress;
 309:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
 310:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#include "pack_struct_end.h"
 311:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	typedef struct xLLMNRAnswer LLMNRAnswer_t;
 312:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 313:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	static portINLINE ipDECL_CAST_PTR_FUNC_FOR_TYPE( LLMNRAnswer_t )
 314:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
 315:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		return ( LLMNRAnswer_t *)pvArgument;
 316:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
 317:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 318:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 319:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #endif /* ipconfigUSE_LLMNR == 1 */
 320:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 321:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #if( ipconfigUSE_NBNS == 1 )
 322:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 323:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#include "pack_struct_start.h"
 324:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	struct xNBNSRequest
 325:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
 326:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		uint16_t usRequestId;
 327:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		uint16_t usFlags;
 328:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		uint16_t ulRequestCount;
 329:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		uint16_t usAnswerRSS;
 330:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		uint16_t usAuthRSS;
 331:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		uint16_t usAdditionalRSS;
 332:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		uint8_t ucNameSpace;
 333:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		uint8_t ucName[ dnsNBNS_ENCODED_NAME_LENGTH ];
 334:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		uint8_t ucNameZero;
 335:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		uint16_t usType;
 336:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		uint16_t usClass;
 337:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
 338:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#include "pack_struct_end.h"
 339:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	typedef struct xNBNSRequest NBNSRequest_t;
 340:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 341:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#include "pack_struct_start.h"
 342:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	struct xNBNSAnswer
 343:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
 344:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		uint16_t usType;
 345:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		uint16_t usClass;
 346:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		uint32_t ulTTL;
 347:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		uint16_t usDataLength;
 348:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		uint16_t usNbFlags;     /* NetBIOS flags 0x6000 : IP-address, big-endian */
 349:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		uint32_t ulIPAddress;
 350:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
 351:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#include "pack_struct_end.h"
 352:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	typedef struct xNBNSAnswer NBNSAnswer_t;
 353:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 354:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	static portINLINE ipDECL_CAST_PTR_FUNC_FOR_TYPE( NBNSAnswer_t )
 355:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
 356:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		return ( NBNSAnswer_t *)pvArgument;
 357:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
 358:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 359:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#endif /* ipconfigUSE_NBNS == 1 */
 360:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 361:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /*-----------------------------------------------------------*/
 362:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 363:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #if( ipconfigUSE_DNS_CACHE == 1 )
 364:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	uint32_t FreeRTOS_dnslookup( const char *pcHostName )
 365:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
 366:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	uint32_t ulIPAddress = 0UL;
 367:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 368:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		( void ) prvProcessDNSCache( pcHostName, &ulIPAddress, 0, pdTRUE );
 369:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		return ulIPAddress;
 370:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
 371:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #endif /* ipconfigUSE_DNS_CACHE == 1 */
 372:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /*-----------------------------------------------------------*/
 373:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 374:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #if( ipconfigDNS_USE_CALLBACKS == 1 )
 375:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 376:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	typedef struct xDNS_Callback
 377:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
 378:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		TickType_t uxRemaningTime;		/* Timeout in ms */
 379:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		FOnDNSEvent pCallbackFunction;	/* Function to be called when the address has been found or when a
 380:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		TimeOut_t uxTimeoutState;
 381:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		void *pvSearchID;
 382:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		struct xLIST_ITEM xListItem;
 383:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		char pcName[ 1 ];
 384:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	} DNSCallback_t;
 385:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 386:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	static portINLINE ipDECL_CAST_PTR_FUNC_FOR_TYPE( DNSCallback_t )
 387:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
 388:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		return ( DNSCallback_t *)pvArgument;
 389:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
 390:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 391:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	static List_t xCallbackList;
 392:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 393:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	/* Define FreeRTOS_gethostbyname() as a normal blocking call. */
 394:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	uint32_t FreeRTOS_gethostbyname( const char *pcHostName )
 395:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
 396:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		return FreeRTOS_gethostbyname_a( pcHostName, NULL, ( void * ) NULL, 0 );
 397:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
 398:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	/*-----------------------------------------------------------*/
 399:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 400:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	/* Initialise the list of call-back structures. */
 401:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	void vDNSInitialise( void )
 402:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
 403:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		vListInitialise( &xCallbackList );
 404:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
 405:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	/*-----------------------------------------------------------*/
 406:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 407:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	/* Iterate through the list of call-back structures and remove
 408:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	old entries which have reached a timeout.
 409:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	As soon as the list hase become empty, the DNS timer will be stopped
 410:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	In case pvSearchID is supplied, the user wants to cancel a DNS request
 411:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	*/
 412:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	void vDNSCheckCallBack( void *pvSearchID )
 413:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
 414:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	const ListItem_t * pxIterator;
 415:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	const ListItem_t * xEnd = listGET_END_MARKER( &xCallbackList );
 416:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 417:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		vTaskSuspendAll();
 418:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
 419:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( xEnd );
 420:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				 pxIterator != xEnd;
 421:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				 )
 422:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
 423:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				DNSCallback_t *pxCallback = ipCAST_PTR_TO_TYPE_PTR( DNSCallback_t, listGET_LIST_ITEM_OWNER( pxI
 424:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				/* Move to the next item because we might remove this item */
 425:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				pxIterator = ( const ListItem_t * ) listGET_NEXT( pxIterator );
 426:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				if( ( pvSearchID != NULL ) && ( pvSearchID == pxCallback->pvSearchID ) )
 427:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
 428:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					( void ) uxListRemove( &( pxCallback->xListItem ) );
 429:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					vPortFree( pxCallback );
 430:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
 431:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				else if( xTaskCheckForTimeOut( &pxCallback->uxTimeoutState, &pxCallback->uxRemaningTime ) != pd
 432:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
 433:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					pxCallback->pCallbackFunction( pxCallback->pcName, pxCallback->pvSearchID, 0 );
 434:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					( void ) uxListRemove( &( pxCallback->xListItem ) );
 435:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					vPortFree( pxCallback );
 436:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
 437:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				else
 438:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
 439:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					/* This call-back is still waiting for a reply or a time-out. */
 440:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
 441:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			}
 442:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		}
 443:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		( void ) xTaskResumeAll();
 444:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 445:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		if( listLIST_IS_EMPTY( &xCallbackList ) != pdFALSE )
 446:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
 447:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			vIPSetDnsTimerEnableState( pdFALSE );
 448:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		}
 449:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
 450:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	/*-----------------------------------------------------------*/
 451:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 452:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	void FreeRTOS_gethostbyname_cancel( void *pvSearchID )
 453:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
 454:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		/* _HT_ Should better become a new API call to have the IP-task remove the callback */
 455:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		vDNSCheckCallBack( pvSearchID );
 456:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
 457:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	/*-----------------------------------------------------------*/
 458:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 459:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	/* FreeRTOS_gethostbyname_a() was called along with callback parameters.
 460:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	Store them in a list for later reference. */
 461:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	static void vDNSSetCallBack( const char *pcHostName,
 462:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								 void *pvSearchID,
 463:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								 FOnDNSEvent pCallbackFunction,
 464:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								 TickType_t uxTimeout,
 465:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								 TickType_t uxIdentifier )
 466:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
 467:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	size_t lLength = strlen( pcHostName );
 468:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	DNSCallback_t *pxCallback = ipCAST_PTR_TO_TYPE_PTR( DNSCallback_t, pvPortMalloc( sizeof( *pxCallba
 469:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 470:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		/* Translate from ms to number of clock ticks. */
 471:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		uxTimeout /= portTICK_PERIOD_MS;
 472:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 473:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		if( pxCallback != NULL )
 474:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
 475:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			if( listLIST_IS_EMPTY( &xCallbackList ) != pdFALSE )
 476:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
 477:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				/* This is the first one, start the DNS timer to check for timeouts */
 478:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				vIPReloadDNSTimer( FreeRTOS_min_uint32( 1000U, uxTimeout ) );
 479:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			}
 480:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 481:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			( void ) strcpy( pxCallback->pcName, pcHostName );
 482:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			pxCallback->pCallbackFunction = pCallbackFunction;
 483:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			pxCallback->pvSearchID = pvSearchID;
 484:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			pxCallback->uxRemaningTime = uxTimeout;
 485:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			vTaskSetTimeOutState( &pxCallback->uxTimeoutState );
 486:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			listSET_LIST_ITEM_OWNER( &( pxCallback->xListItem ), ( void *) pxCallback );
 487:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			listSET_LIST_ITEM_VALUE( &( pxCallback->xListItem ), uxIdentifier );
 488:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			vTaskSuspendAll();
 489:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
 490:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				vListInsertEnd( &xCallbackList, &pxCallback->xListItem );
 491:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			}
 492:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			( void ) xTaskResumeAll();
 493:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		}
 494:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
 495:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	/*-----------------------------------------------------------*/
 496:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 497:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	/* A DNS reply was received, see if there is any matching entry and
 498:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	call the handler.  Returns pdTRUE if uxIdentifier was recognised. */
 499:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	static BaseType_t xDNSDoCallback( TickType_t uxIdentifier,
 500:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 									  const char *pcName,
 501:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 									  uint32_t ulIPAddress )
 502:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
 503:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	BaseType_t xResult = pdFALSE;
 504:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	const ListItem_t * pxIterator;
 505:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	const ListItem_t * xEnd = listGET_END_MARKER( &xCallbackList );
 506:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 507:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		vTaskSuspendAll();
 508:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
 509:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( xEnd );
 510:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				 pxIterator != ( const ListItem_t * ) xEnd;
 511:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				 pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
 512:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
 513:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				if( listGET_LIST_ITEM_VALUE( pxIterator ) == uxIdentifier )
 514:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
 515:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				DNSCallback_t *pxCallback = ipCAST_PTR_TO_TYPE_PTR( DNSCallback_t, listGET_LIST_ITEM_OWNER( pxI
 516:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 517:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					pxCallback->pCallbackFunction( pcName, pxCallback->pvSearchID, ulIPAddress );
 518:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					( void ) uxListRemove( &pxCallback->xListItem );
 519:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					vPortFree( pxCallback );
 520:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 521:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					if( listLIST_IS_EMPTY( &xCallbackList ) != pdFALSE )
 522:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					{
 523:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						/* The list of outstanding requests is empty. No need for periodic polling. */
 524:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						vIPSetDnsTimerEnableState( pdFALSE );
 525:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					}
 526:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 527:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					xResult = pdTRUE;
 528:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					break;
 529:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
 530:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			}
 531:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		}
 532:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		( void ) xTaskResumeAll();
 533:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		return xResult;
 534:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
 535:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 536:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #endif /* ipconfigDNS_USE_CALLBACKS == 1 */
 537:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /*-----------------------------------------------------------*/
 538:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 539:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #if( ipconfigDNS_USE_CALLBACKS == 0 )
 540:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	uint32_t FreeRTOS_gethostbyname( const char *pcHostName )
 541:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
 542:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		return prvPrepareLookup( pcHostName );
 543:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
 544:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #else
 545:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	uint32_t FreeRTOS_gethostbyname_a( const char *pcHostName,
 546:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 									   FOnDNSEvent pCallback,
 547:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 									   void *pvSearchID,
 548:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 									   TickType_t uxTimeout )
 549:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
 550:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		return prvPrepareLookup( pcHostName, pCallback, pvSearchID, uxTimeout );
 551:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
 552:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #endif
 553:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 554:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #if( ipconfigDNS_USE_CALLBACKS == 1 )
 555:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	static uint32_t prvPrepareLookup( const char *pcHostName,
 556:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 									  FOnDNSEvent pCallback,
 557:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 									  void *pvSearchID,
 558:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 									  TickType_t uxTimeout )
 559:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #else
 560:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	static uint32_t prvPrepareLookup( const char *pcHostName )
 561:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #endif
 562:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** {
 563:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** uint32_t ulIPAddress = 0UL;
 564:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** TickType_t uxReadTimeOut_ticks = ipconfigDNS_RECEIVE_BLOCK_TIME_TICKS;
 565:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /* Generate a unique identifier for this query. Keep it in a local variable
 566:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c ****  as gethostbyname() may be called from different threads */
 567:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** BaseType_t xHasRandom = pdFALSE;
 568:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** TickType_t uxIdentifier = 0U;
 569:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #if( ipconfigUSE_DNS_CACHE != 0 )
 570:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	BaseType_t xLengthOk = pdFALSE;
 571:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #endif
 572:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 573:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#if( ipconfigUSE_DNS_CACHE != 0 )
 574:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
 575:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		if( pcHostName != NULL )
 576:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
 577:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		size_t xLength = strlen( pcHostName ) + 1U;
 578:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 579:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			if( xLength <= ipconfigDNS_CACHE_NAME_LENGTH )
 580:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
 581:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				/* The name is not too long. */
 582:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				xLengthOk = pdTRUE;
 583:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			}
 584:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			else
 585:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
 586:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				FreeRTOS_printf( ( "prvPrepareLookup: name is too long ( %lu > %lu )\n",
 587:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								   ( uint32_t ) xLength,
 588:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								   ( uint32_t ) ipconfigDNS_CACHE_NAME_LENGTH ) );
 589:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			}
 590:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		}
 591:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
 592:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	if( ( pcHostName != NULL ) && ( xLengthOk != pdFALSE ) )
 593:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#else
 594:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	if( pcHostName != NULL )
 595:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#endif	/* ( ipconfigUSE_DNS_CACHE != 0 ) */
 596:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
 597:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		/* If the supplied hostname is IP address, convert it to uint32_t
 598:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		and return. */
 599:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		#if( ipconfigINCLUDE_FULL_INET_ADDR == 1 )
 600:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
 601:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			ulIPAddress = FreeRTOS_inet_addr( pcHostName );
 602:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		}
 603:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		#endif /* ipconfigINCLUDE_FULL_INET_ADDR == 1 */
 604:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 605:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		/* If a DNS cache is used then check the cache before issuing another DNS
 606:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		request. */
 607:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		#if( ipconfigUSE_DNS_CACHE == 1 )
 608:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
 609:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			if( ulIPAddress == 0UL )
 610:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
 611:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				ulIPAddress = FreeRTOS_dnslookup( pcHostName );
 612:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 613:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				if( ulIPAddress != 0UL )
 614:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
 615:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					FreeRTOS_debug_printf( ( "FreeRTOS_gethostbyname: found '%s' in cache: %lxip\n", pcHostName, u
 616:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
 617:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				else
 618:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
 619:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					/* prvGetHostByName will be called to start a DNS lookup. */
 620:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
 621:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			}
 622:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		}
 623:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		#endif /* ipconfigUSE_DNS_CACHE == 1 */
 624:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 625:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		/* Generate a unique identifier. */
 626:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		if( ulIPAddress == 0UL )
 627:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
 628:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		uint32_t ulNumber;
 629:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 630:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			xHasRandom = xApplicationGetRandomNumber( &( ulNumber ) );
 631:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			/* DNS identifiers are 16-bit. */
 632:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			uxIdentifier = ( TickType_t ) ( ulNumber & 0xffffU );
 633:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		}
 634:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 635:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		#if( ipconfigDNS_USE_CALLBACKS == 1 )
 636:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
 637:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			if( pCallback != NULL )
 638:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
 639:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				if( ulIPAddress == 0UL )
 640:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
 641:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					/* The user has provided a callback function, so do not block on recvfrom() */
 642:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					if( xHasRandom != pdFALSE )
 643:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					{
 644:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						uxReadTimeOut_ticks = 0U;
 645:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						vDNSSetCallBack( pcHostName, pvSearchID, pCallback, uxTimeout, uxIdentifier );
 646:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					}
 647:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
 648:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				else
 649:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
 650:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					/* The IP address is known, do the call-back now. */
 651:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					pCallback( pcHostName, pvSearchID, ulIPAddress );
 652:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
 653:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			}
 654:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		}
 655:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		#endif /* if ( ipconfigDNS_USE_CALLBACKS == 1 ) */
 656:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 657:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		if( ( ulIPAddress == 0UL ) && ( xHasRandom != pdFALSE ) )
 658:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
 659:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			ulIPAddress = prvGetHostByName( pcHostName, uxIdentifier, uxReadTimeOut_ticks );
 660:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		}
 661:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
 662:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	return ulIPAddress;
 663:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** }
 664:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /*-----------------------------------------------------------*/
 665:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 666:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** static uint32_t prvGetHostByName( const char *pcHostName,
 667:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								  TickType_t uxIdentifier,
 668:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								  TickType_t uxReadTimeOut_ticks )
 669:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** {
 670:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** struct freertos_sockaddr xAddress;
 671:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** Socket_t xDNSSocket;
 672:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** uint32_t ulIPAddress = 0UL;
 673:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** uint32_t ulAddressLength = sizeof( struct freertos_sockaddr );
 674:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** BaseType_t xAttempt;
 675:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** int32_t lBytes;
 676:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** size_t uxPayloadLength, uxExpectedPayloadLength;
 677:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** TickType_t uxWriteTimeOut_ticks = ipconfigDNS_SEND_BLOCK_TIME_TICKS;
 678:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 679:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #if( ipconfigUSE_LLMNR == 1 )
 680:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	BaseType_t bHasDot = pdFALSE;
 681:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #endif /* ipconfigUSE_LLMNR == 1 */
 682:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 683:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	/* If LLMNR is being used then determine if the host name includes a '.' -
 684:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	if not then LLMNR can be used as the lookup method. */
 685:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#if( ipconfigUSE_LLMNR == 1 )
 686:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
 687:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	const char *pucPtr;
 688:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 689:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		for( pucPtr = pcHostName; *pucPtr != ( char ) 0; pucPtr++ )
 690:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
 691:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			if( *pucPtr == '.' )
 692:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
 693:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				bHasDot = pdTRUE;
 694:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				break;
 695:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			}
 696:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		}
 697:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
 698:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#endif /* ipconfigUSE_LLMNR == 1 */
 699:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 700:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	/* Two is added at the end for the count of characters in the first
 701:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	subdomain part and the string end byte. */
 702:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	uxExpectedPayloadLength = sizeof( DNSMessage_t ) + strlen( pcHostName ) + sizeof( uint16_t ) + siz
 703:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 704:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	xDNSSocket = prvCreateDNSSocket();
 705:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 706:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	if( xDNSSocket != NULL )
 707:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
 708:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		/* Ideally we should check for the return value. But since we are passing
 709:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		correct parameters, and xDNSSocket is != NULL, the return value is 
 710:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		going to be '0' i.e. success. Thus, return value is discarded */
 711:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		( void ) FreeRTOS_setsockopt( xDNSSocket, 0, FREERTOS_SO_SNDTIMEO, &( uxWriteTimeOut_ticks ), siz
 712:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		( void ) FreeRTOS_setsockopt( xDNSSocket, 0, FREERTOS_SO_RCVTIMEO, &( uxReadTimeOut_ticks ),  siz
 713:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 714:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		for( xAttempt = 0; xAttempt < ipconfigDNS_REQUEST_ATTEMPTS; xAttempt++ )
 715:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
 716:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		size_t uxHeaderBytes;
 717:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		NetworkBufferDescriptor_t *pxNetworkBuffer;
 718:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		uint8_t *pucUDPPayloadBuffer = NULL, *pucReceiveBuffer;
 719:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 720:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			/* Get a buffer.  This uses a maximum delay, but the delay will be
 721:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			capped to ipconfigUDP_MAX_SEND_BLOCK_TIME_TICKS so the return value
 722:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			still needs to be tested. */
 723:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 724:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			uxHeaderBytes = ipSIZE_OF_ETH_HEADER + ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_UDP_HEADER;
 725:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 726:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			pxNetworkBuffer = pxGetNetworkBufferWithDescriptor( uxHeaderBytes + uxExpectedPayloadLength, 0UL
 727:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			if( pxNetworkBuffer != NULL )
 728:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
 729:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				pucUDPPayloadBuffer = &( pxNetworkBuffer->pucEthernetBuffer[ uxHeaderBytes ] );
 730:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			}
 731:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 732:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			if( pucUDPPayloadBuffer != NULL )
 733:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
 734:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				/* Create the message in the obtained buffer. */
 735:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				uxPayloadLength = prvCreateDNSMessage( pucUDPPayloadBuffer, pcHostName, uxIdentifier );
 736:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 737:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				iptraceSENDING_DNS_REQUEST();
 738:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 739:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				/* Obtain the DNS server address. */
 740:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				FreeRTOS_GetAddressConfiguration( NULL, NULL, NULL, &ulIPAddress );
 741:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 742:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				/* Send the DNS message. */
 743:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #if( ipconfigUSE_LLMNR == 1 )
 744:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				if( bHasDot == pdFALSE )
 745:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
 746:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					/* Use LLMNR addressing. */
 747:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					( ipCAST_PTR_TO_TYPE_PTR( DNSMessage_t, pucUDPPayloadBuffer ) )->usFlags = 0;
 748:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					xAddress.sin_addr = ipLLMNR_IP_ADDR; /* Is in network byte order. */
 749:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					xAddress.sin_port = ipLLMNR_PORT;
 750:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					xAddress.sin_port = FreeRTOS_ntohs( xAddress.sin_port );
 751:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
 752:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				else
 753:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #endif
 754:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
 755:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					/* Use DNS server. */
 756:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					xAddress.sin_addr = ulIPAddress;
 757:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					xAddress.sin_port = dnsDNS_PORT;
 758:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
 759:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 760:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				ulIPAddress = 0UL;
 761:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 762:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				if( FreeRTOS_sendto( xDNSSocket, pucUDPPayloadBuffer, uxPayloadLength, FREERTOS_ZERO_COPY, &xAd
 763:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
 764:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					/* Wait for the reply. */
 765:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					lBytes = FreeRTOS_recvfrom( xDNSSocket, &pucReceiveBuffer, 0, FREERTOS_ZERO_COPY, &xAddress, &
 766:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 767:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					if( lBytes > 0 )
 768:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					{
 769:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					BaseType_t xExpected;
 770:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					const DNSMessage_t *pxDNSMessageHeader = ipCAST_CONST_PTR_TO_CONST_TYPE_PTR( DNSMessage_t, puc
 771:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 772:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						/* See if the identifiers match. */
 773:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						if( uxIdentifier == ( TickType_t ) pxDNSMessageHeader->usIdentifier )
 774:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						{
 775:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							xExpected = pdTRUE;
 776:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						}
 777:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						else
 778:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						{
 779:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							/* The reply was not expected. */
 780:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							xExpected = pdFALSE;
 781:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						}
 782:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 783:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						/* The reply was received.  Process it. */
 784:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					#if( ipconfigDNS_USE_CALLBACKS == 0 )
 785:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						/* It is useless to analyse the unexpected reply
 786:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						unless asynchronous look-ups are enabled. */
 787:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						if( xExpected != pdFALSE )
 788:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					#endif /* ipconfigDNS_USE_CALLBACKS == 0 */
 789:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						{
 790:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							ulIPAddress = prvParseDNSReply( pucReceiveBuffer, ( size_t ) lBytes, xExpected );
 791:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						}
 792:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 793:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						/* Finished with the buffer.  The zero copy interface
 794:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						is being used, so the buffer must be freed by the
 795:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						task. */
 796:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						FreeRTOS_ReleaseUDPPayloadBuffer( pucReceiveBuffer );
 797:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 798:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						if( ulIPAddress != 0UL )
 799:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						{
 800:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							/* All done. */
 801:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							/* coverity[break_stmt] : Break statement terminating the loop */
 802:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							break;
 803:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						}
 804:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					}
 805:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
 806:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				else
 807:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
 808:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					/* The message was not sent so the stack will not be
 809:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					releasing the zero copy - it must be released here. */
 810:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 811:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
 812:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			}
 813:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 814:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			if( uxReadTimeOut_ticks == 0U )
 815:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
 816:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				/* This DNS lookup is asynchronous, using a call-back:
 817:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				send the request only once. */
 818:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				break;
 819:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			}
 820:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		}
 821:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 822:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		/* Finished with the socket. */
 823:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		( void ) FreeRTOS_closesocket( xDNSSocket );
 824:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
 825:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 826:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	return ulIPAddress;
 827:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** }
 828:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /*-----------------------------------------------------------*/
 829:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 830:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** _static size_t prvCreateDNSMessage( uint8_t *pucUDPPayloadBuffer,
 831:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								   const char *pcHostName,
 832:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								   TickType_t uxIdentifier )
 833:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** {
 834:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** DNSMessage_t *pxDNSMessageHeader;
 835:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** uint8_t *pucStart, *pucByte;
 836:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** DNSTail_t const * pxTail;
 837:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** static const DNSMessage_t xDefaultPartDNSHeader =
 838:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** {
 839:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	0,                 /* The identifier will be overwritten. */
 840:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	dnsOUTGOING_FLAGS, /* Flags set for standard query. */
 841:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	dnsONE_QUESTION,   /* One question is being asked. */
 842:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	0,                 /* No replies are included. */
 843:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	0,                 /* No authorities. */
 844:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	0                  /* No additional authorities. */
 845:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** };
 846:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 847:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	/* Copy in the const part of the header. Intentionally using different
 848:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	 * pointers with memcpy() to put the information in to correct place. */
 849:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	( void ) memcpy( ( void * ) pucUDPPayloadBuffer, ( const void * ) ( &( xDefaultPartDNSHeader ) ), 
 850:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 851:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	/* Write in a unique identifier. Cast the Payload Buffer to DNSMessage_t
 852:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	 * to easily access fields of the DNS Message. */
 853:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	pxDNSMessageHeader = ipCAST_PTR_TO_TYPE_PTR( DNSMessage_t, pucUDPPayloadBuffer );
 854:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	pxDNSMessageHeader->usIdentifier = ( uint16_t ) uxIdentifier;
 855:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 856:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	/* Create the resource record at the end of the header.  First
 857:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	find the end of the header. */
 858:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	pucStart = &( pucUDPPayloadBuffer[ sizeof( xDefaultPartDNSHeader ) ] );
 859:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 860:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	/* Leave a gap for the first length bytes. */
 861:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	pucByte = &( pucStart[ 1 ] );
 862:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 863:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	/* Copy in the host name. */
 864:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	( void ) strcpy( ( char * ) pucByte, pcHostName );
 865:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 866:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	/* Mark the end of the string. */
 867:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	pucByte = &( pucByte[ strlen( pcHostName ) ] );
 868:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	*pucByte = 0x00U;
 869:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 870:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	/* Walk the string to replace the '.' characters with byte counts.
 871:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	pucStart holds the address of the byte count.  Walking the string
 872:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	starts after the byte count position. */
 873:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	pucByte = pucStart;
 874:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 875:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	do
 876:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
 877:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		pucByte++;
 878:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 879:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		while( ( *pucByte != ( uint8_t ) 0U ) && ( *pucByte != ( uint8_t ) ASCII_BASELINE_DOT ) )
 880:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
 881:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			pucByte++;
 882:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		}
 883:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 884:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		/* Fill in the byte count, then move the pucStart pointer up to
 885:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		the found byte position. */
 886:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		*pucStart = ( uint8_t ) ( ( uint32_t ) pucByte - ( uint32_t ) pucStart );
 887:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		( *pucStart )--;
 888:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 889:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		pucStart = pucByte;
 890:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	} while( *pucByte != ( uint8_t ) 0U );
 891:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 892:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	/* Finish off the record. Cast the record onto DNSTail_t stucture to easily
 893:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	 * access the fields of the DNS Message. */
 894:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	pxTail = ipCAST_PTR_TO_TYPE_PTR( DNSTail_t, &( pucByte[ 1 ] ) );
 895:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 896:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#if defined( _lint ) || defined( __COVERITY__ )
 897:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	( void ) pxTail;
 898:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#else
 899:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	vSetField16( pxTail, DNSTail_t, usType, dnsTYPE_A_HOST );
 900:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	vSetField16( pxTail, DNSTail_t, usClass, dnsCLASS_IN );
 901:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#endif
 902:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 903:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	/* Return the total size of the generated message, which is the space from
 904:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	the last written byte to the beginning of the buffer. */
 905:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	return ( ( uint32_t ) pucByte - ( uint32_t ) pucUDPPayloadBuffer + 1U ) + sizeof( DNSTail_t );
 906:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** }
 907:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /*-----------------------------------------------------------*/
 908:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 909:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #if( ipconfigUSE_DNS_CACHE == 1 ) || ( ipconfigDNS_USE_CALLBACKS == 1 )
 910:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 911:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	_static size_t prvReadNameField( const uint8_t *pucByte,
 912:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 									size_t uxRemainingBytes,
 913:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 									char *pcName,
 914:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 									size_t uxDestLen )
 915:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
 916:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	size_t uxNameLen = 0U;
 917:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	size_t uxIndex = 0U;
 918:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	size_t uxSourceLen = uxRemainingBytes;
 919:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 920:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	/* uxCount gets the valus from pucByte and counts down to 0.
 921:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	No need to have a different type than that of pucByte */
 922:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	size_t uxCount;  
 923:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 924:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		if( uxSourceLen == ( size_t ) 0U )
 925:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
 926:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			/* Return 0 value in case of error. */
 927:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			uxIndex = 0U;
 928:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		}
 929:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		/* Determine if the name is the fully coded name, or an offset to the name
 930:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		elsewhere in the message. */
 931:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		else if( ( pucByte[ uxIndex ] & dnsNAME_IS_OFFSET ) == dnsNAME_IS_OFFSET )
 932:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
 933:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			/* Jump over the two byte offset. */
 934:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			if( uxSourceLen > sizeof( uint16_t ) )
 935:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
 936:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				uxIndex += sizeof( uint16_t );
 937:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			}
 938:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			else
 939:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
 940:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				uxIndex = 0U;
 941:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			}
 942:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		}
 943:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		else
 944:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
 945:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			/* 'uxIndex' points to the full name. Walk over the string. */
 946:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			while( ( uxIndex < uxSourceLen ) && ( pucByte[ uxIndex ] != ( uint8_t )0x00U ) )
 947:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
 948:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				/* If this is not the first time through the loop, then add a
 949:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				separator in the output. */
 950:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				if( ( uxNameLen > 0U ) )
 951:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
 952:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					if( uxNameLen >= uxDestLen )
 953:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					{
 954:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						uxIndex = 0U;
 955:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						/* coverity[break_stmt] : Break statement terminating the loop */
 956:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						break;
 957:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					}
 958:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					pcName[ uxNameLen ] = '.';
 959:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					uxNameLen++;
 960:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
 961:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 962:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				/* Process the first/next sub-string. */
 963:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				uxCount = ( size_t ) pucByte[ uxIndex ];
 964:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				uxIndex++;
 965:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				if( ( uxIndex + uxCount ) > uxSourceLen )
 966:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
 967:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					uxIndex = 0U;
 968:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					break;
 969:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
 970:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 971:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				while( ( uxCount-- != 0U ) && ( uxIndex < uxSourceLen ) )
 972:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
 973:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					if( uxNameLen >= uxDestLen )
 974:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					{
 975:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						uxIndex = 0U;
 976:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						break;
 977:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						/* break out of inner loop here
 978:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						break out of outer loop at the test uxNameLen >= uxDestLen. */
 979:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					}
 980:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					pcName[ uxNameLen ] = ( char ) pucByte[ uxIndex ];
 981:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					uxNameLen++;
 982:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					uxIndex++;
 983:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
 984:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			}
 985:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 986:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			/* Confirm that a fully formed name was found. */
 987:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			if( uxIndex > 0U )
 988:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
 989:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				if( ( uxNameLen < uxDestLen ) && ( uxIndex < uxSourceLen ) && ( pucByte[ uxIndex ] == 0U ) )
 990:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
 991:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					pcName[ uxNameLen ] = '\0';
 992:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					uxIndex++;
 993:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
 994:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				else
 995:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
 996:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					uxIndex = 0U;
 997:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
 998:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			}
 999:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		}
1000:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1001:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		return uxIndex;
1002:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
1003:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #endif	/* ipconfigUSE_DNS_CACHE || ipconfigDNS_USE_CALLBACKS */
1004:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /*-----------------------------------------------------------*/
1005:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1006:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** _static size_t prvSkipNameField( const uint8_t *pucByte,
1007:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								size_t uxLength )
1008:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** {
  26              	 .loc 1 1008 0
  27              	 .cfi_startproc
  28              	 
  29              	 
  30              	 
  31              	.LVL0:
1009:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** size_t uxChunkLength;
1010:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** size_t uxSourceLenCpy = uxLength;
1011:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** size_t uxIndex = 0U;
1012:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1013:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	if( uxSourceLenCpy == 0U )
  32              	 .loc 1 1013 0
  33 0000 0A46     	 mov r2,r1
  34 0002 F9B1     	 cbz r1,.L8
1014:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
1015:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		uxIndex = 0U;
1016:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
1017:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	/* Determine if the name is the fully coded name, or an offset to the name
1018:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	elsewhere in the message. */
1019:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	else if( ( pucByte[ uxIndex ] & dnsNAME_IS_OFFSET ) == dnsNAME_IS_OFFSET )
  35              	 .loc 1 1019 0
  36 0004 0378     	 ldrb r3,[r0]
  37 0006 03F0C001 	 and r1,r3,#192
  38              	.LVL1:
  39 000a C029     	 cmp r1,#192
  40 000c 08D0     	 beq .L3
1020:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
1021:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		/* Jump over the two byte offset. */
1022:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		if( uxSourceLenCpy > sizeof( uint16_t ) )
1023:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
1024:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			uxIndex += sizeof( uint16_t );
1025:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		}
1026:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		else
1027:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
1028:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			uxIndex = 0U;
1029:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		}
1030:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
1031:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	else
1032:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
1033:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		/* pucByte points to the full name. Walk over the string. */
1034:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		while( ( pucByte[ uxIndex ] != 0U ) && ( uxSourceLenCpy > 1U ) )
  41              	 .loc 1 1034 0
  42 000e DBB1     	 cbz r3,.L9
  43 0010 012A     	 cmp r2,#1
  44 0012 1BD9     	 bls .L10
1035:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
1036:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			/* Conversion to size_t causes addition to be done
1037:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			in size_t */
1038:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			uxChunkLength = ( ( size_t ) pucByte[ uxIndex ] ) + 1U;
  45              	 .loc 1 1038 0
  46 0014 0133     	 adds r3,r3,#1
  47              	.LVL2:
1039:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1040:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			if( uxSourceLenCpy > uxChunkLength )
  48              	 .loc 1 1040 0
  49 0016 9A42     	 cmp r2,r3
  50 0018 98BF     	 it ls
  51 001a 0021     	 movls r1,#0
  52 001c 1ED9     	 bls .L14
  53 001e 08E0     	 b .L11
  54              	.LVL3:
  55              	.L3:
1028:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		}
  56              	 .loc 1 1028 0
  57 0020 022A     	 cmp r2,#2
  58 0022 8CBF     	 ite hi
  59 0024 0221     	 movhi r1,#2
  60 0026 0021     	 movls r1,#0
  61 0028 18E0     	 b .L14
  62              	.LVL4:
  63              	.L6:
1038:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
  64              	 .loc 1 1038 0
  65 002a 0133     	 adds r3,r3,#1
  66              	.LVL5:
  67              	 .loc 1 1040 0
  68 002c 9342     	 cmp r3,r2
  69 002e 01D3     	 bcc .L4
  70 0030 0EE0     	 b .L13
  71              	.LVL6:
  72              	.L11:
  73 0032 0021     	 movs r1,#0
  74              	.LVL7:
  75              	.L4:
1041:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
1042:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				uxSourceLenCpy -= uxChunkLength;
  76              	 .loc 1 1042 0
  77 0034 D21A     	 subs r2,r2,r3
  78              	.LVL8:
1043:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				uxIndex += uxChunkLength;
  79              	 .loc 1 1043 0
  80 0036 1944     	 add r1,r1,r3
  81              	.LVL9:
1034:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
  82              	 .loc 1 1034 0
  83 0038 435C     	 ldrb r3,[r0,r1]
  84              	.LVL10:
  85 003a 6BB1     	 cbz r3,.L5
1034:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
  86              	 .loc 1 1034 0 is_stmt 0 discriminator 1
  87 003c 012A     	 cmp r2,#1
  88 003e F4D8     	 bhi .L6
  89 0040 0021     	 movs r1,#0
  90              	.LVL11:
  91 0042 0BE0     	 b .L14
  92              	.LVL12:
  93              	.L8:
1015:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
  94              	 .loc 1 1015 0 is_stmt 1
  95 0044 0021     	 movs r1,#0
  96              	.LVL13:
  97 0046 09E0     	 b .L14
  98              	.L9:
1034:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
  99              	 .loc 1 1034 0
 100 0048 0021     	 movs r1,#0
 101 004a 07E0     	 b .L14
 102              	.L10:
 103 004c 0021     	 movs r1,#0
 104 004e 05E0     	 b .L14
 105              	.LVL14:
 106              	.L13:
 107 0050 0021     	 movs r1,#0
 108              	.LVL15:
 109 0052 03E0     	 b .L14
 110              	.LVL16:
 111              	.L7:
1044:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			}
1045:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			else
1046:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
1047:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				uxIndex = 0U;
1048:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				break;
1049:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			}
1050:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		}
1051:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1052:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		/* Confirm that a fully formed name was found. */
1053:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		if( uxIndex > 0U )
1054:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
1055:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			if( pucByte[ uxIndex ] == 0U )
1056:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
1057:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				uxIndex++;
 112              	 .loc 1 1057 0
 113 0054 0131     	 adds r1,r1,#1
 114              	.LVL17:
 115 0056 01E0     	 b .L14
 116              	.L5:
1053:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
 117              	 .loc 1 1053 0
 118 0058 0029     	 cmp r1,#0
 119 005a FBD1     	 bne .L7
 120              	.LVL18:
 121              	.L14:
1058:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			}
1059:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			else
1060:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
1061:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				uxIndex = 0U;
1062:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			}
1063:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		}
1064:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
1065:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1066:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	return uxIndex;
1067:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** }
 122              	 .loc 1 1067 0
 123 005c 0846     	 mov r0,r1
 124              	.LVL19:
 125 005e 7047     	 bx lr
 126              	 .cfi_endproc
 127              	.LFE68:
 129              	 .section .text.prvProcessDNSCache,"ax",%progbits
 130              	 .align 2
 131              	 .thumb
 132              	 .thumb_func
 134              	prvProcessDNSCache:
 135              	.LFB72:
1068:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /*-----------------------------------------------------------*/
1069:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1070:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /* The function below will only be called :
1071:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** when ipconfigDNS_USE_CALLBACKS == 1
1072:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** when ipconfigUSE_LLMNR == 1
1073:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** for testing purposes, by the module iot_test_freertos_tcp.c
1074:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** */
1075:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** uint32_t ulDNSHandlePacket( const NetworkBufferDescriptor_t *pxNetworkBuffer )
1076:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** {
1077:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** DNSMessage_t *pxDNSMessageHeader;
1078:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** size_t uxPayloadSize;
1079:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1080:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	/* Only proceed if the payload length indicated in the header
1081:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	appears to be valid. */
1082:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	if( pxNetworkBuffer->xDataLength >= sizeof( UDPPacket_t ) )
1083:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
1084:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		uxPayloadSize = pxNetworkBuffer->xDataLength - sizeof( UDPPacket_t );
1085:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1086:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		if( uxPayloadSize >= sizeof( DNSMessage_t ) )
1087:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
1088:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			pxDNSMessageHeader =
1089:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				ipCAST_PTR_TO_TYPE_PTR( DNSMessage_t, pxNetworkBuffer->pucEthernetBuffer );
1090:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1091:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			/* The parameter pdFALSE indicates that the reply was not expected. */
1092:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			( void ) prvParseDNSReply( ( uint8_t * ) pxDNSMessageHeader,
1093:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				uxPayloadSize,
1094:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				pdFALSE );
1095:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		}
1096:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
1097:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1098:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	/* The packet was not consumed. */
1099:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	return pdFAIL;
1100:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** }
1101:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /*-----------------------------------------------------------*/
1102:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1103:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #if( ipconfigUSE_NBNS == 1 )
1104:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1105:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	uint32_t ulNBNSHandlePacket( NetworkBufferDescriptor_t * pxNetworkBuffer )
1106:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
1107:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	UDPPacket_t *pxUDPPacket = ipCAST_PTR_TO_TYPE_PTR( UDPPacket_t, pxNetworkBuffer->pucEthernetBuffer
1108:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	uint8_t *pucUDPPayloadBuffer = &( pxNetworkBuffer->pucEthernetBuffer[ sizeof( *pxUDPPacket ) ] );
1109:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1110:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		prvTreatNBNS( pucUDPPayloadBuffer,
1111:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					  pxNetworkBuffer->xDataLength,
1112:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					  pxUDPPacket->xIPHeader.ulSourceIPAddress );
1113:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1114:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		/* The packet was not consumed. */
1115:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		return pdFAIL;
1116:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
1117:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1118:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #endif /* ipconfigUSE_NBNS */
1119:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /*-----------------------------------------------------------*/
1120:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1121:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** _static uint32_t prvParseDNSReply( uint8_t *pucUDPPayloadBuffer,
1122:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								  size_t uxBufferLength,
1123:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								  BaseType_t xExpected )
1124:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** {
1125:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** DNSMessage_t *pxDNSMessageHeader;
1126:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /* This pointer is not used to modify anything */
1127:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** const DNSAnswerRecord_t *pxDNSAnswerRecord; 
1128:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** uint32_t ulIPAddress = 0UL;
1129:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #if( ipconfigUSE_LLMNR == 1 )
1130:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	char *pcRequestedName = NULL;
1131:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #endif
1132:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** uint8_t *pucByte;
1133:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** size_t uxSourceBytesRemaining;
1134:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** uint16_t x, usDataLength, usQuestions;
1135:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** uint16_t usType = 0U;
1136:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** BaseType_t xReturn = pdTRUE;
1137:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1138:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #if( ipconfigUSE_LLMNR == 1 )
1139:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	uint16_t usClass = 0U;
1140:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #endif
1141:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #if( ipconfigUSE_DNS_CACHE == 1 ) || ( ipconfigDNS_USE_CALLBACKS == 1 )
1142:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	BaseType_t xDoStore = xExpected;
1143:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	char pcName[ ipconfigDNS_CACHE_NAME_LENGTH ] = "";
1144:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #endif
1145:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1146:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	/* Ensure that the buffer is of at least minimal DNS message length. */
1147:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	if( uxBufferLength < sizeof( DNSMessage_t ) )
1148:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
1149:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		xReturn = pdFALSE;
1150:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
1151:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	else
1152:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
1153:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		uxSourceBytesRemaining = uxBufferLength;
1154:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1155:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		/* Parse the DNS message header. Map the byte stream onto a structure 
1156:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		 * for easier access. */
1157:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		pxDNSMessageHeader = ipCAST_PTR_TO_TYPE_PTR( DNSMessage_t, pucUDPPayloadBuffer );
1158:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1159:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		/* Introduce a do {} while (0) to allow the use of breaks. */
1160:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		do
1161:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
1162:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		size_t uxBytesRead = 0U;
1163:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		size_t uxResult;
1164:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1165:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			/* Start at the first byte after the header. */
1166:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			pucByte = &( pucUDPPayloadBuffer [ sizeof( DNSMessage_t ) ] );
1167:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			uxSourceBytesRemaining -= sizeof( DNSMessage_t );
1168:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1169:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			/* Skip any question records. */
1170:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			usQuestions = FreeRTOS_ntohs( pxDNSMessageHeader->usQuestions );
1171:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1172:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			for( x = 0U; x < usQuestions; x++ )
1173:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
1174:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				#if( ipconfigUSE_LLMNR == 1 )
1175:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
1176:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					if( x == 0U )
1177:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					{
1178:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						pcRequestedName = ( char * ) pucByte;
1179:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					}
1180:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
1181:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				#endif
1182:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1183:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #if( ipconfigUSE_DNS_CACHE == 1 ) || ( ipconfigDNS_USE_CALLBACKS == 1 )
1184:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				if( x == 0U )
1185:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
1186:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					uxResult = prvReadNameField( pucByte,
1187:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 												 uxSourceBytesRemaining,
1188:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 												 pcName,
1189:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 												 sizeof( pcName ) );
1190:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1191:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					/* Check for a malformed response. */
1192:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					if( uxResult == 0U )
1193:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					{
1194:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						xReturn = pdFALSE;
1195:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						break;
1196:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					}
1197:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					uxBytesRead += uxResult;
1198:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					pucByte = &( pucByte[ uxResult ] );
1199:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					uxSourceBytesRemaining -= uxResult;
1200:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
1201:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				else
1202:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #endif /* ipconfigUSE_DNS_CACHE || ipconfigDNS_USE_CALLBACKS */
1203:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
1204:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					/* Skip the variable length pcName field. */
1205:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					uxResult = prvSkipNameField( pucByte,
1206:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 												 uxSourceBytesRemaining );
1207:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1208:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					/* Check for a malformed response. */
1209:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					if( uxResult == 0U )
1210:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					{
1211:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						xReturn = pdFALSE;
1212:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						break;
1213:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					}
1214:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					uxBytesRead += uxResult;
1215:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					pucByte = &( pucByte[ uxResult ] );
1216:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					uxSourceBytesRemaining -= uxResult;
1217:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
1218:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1219:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				/* Check the remaining buffer size. */
1220:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				if( uxSourceBytesRemaining >= sizeof( uint32_t ) )
1221:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
1222:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					#if( ipconfigUSE_LLMNR == 1 )
1223:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					{
1224:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						/* usChar2u16 returns value in host endianness. */
1225:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						usType = usChar2u16( pucByte );
1226:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						usClass = usChar2u16( &( pucByte[ 2 ] ) );
1227:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					}
1228:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					#endif /* ipconfigUSE_LLMNR */
1229:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1230:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					/* Skip the type and class fields. */
1231:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					pucByte = &( pucByte[ sizeof( uint32_t ) ] );
1232:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					uxSourceBytesRemaining -= sizeof( uint32_t );
1233:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
1234:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				else
1235:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
1236:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					xReturn = pdFALSE;
1237:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					break;
1238:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
1239:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			}
1240:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1241:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			if( xReturn == pdFALSE )
1242:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
1243:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				/* No need to proceed. Break out of the do-while loop. */
1244:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				break;
1245:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			}
1246:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1247:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			/* Search through the answer records. */
1248:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			pxDNSMessageHeader->usAnswers = FreeRTOS_ntohs( pxDNSMessageHeader->usAnswers );
1249:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1250:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			if( ( pxDNSMessageHeader->usFlags & dnsRX_FLAGS_MASK ) == dnsEXPECTED_RX_FLAGS )
1251:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
1252:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			const uint16_t usCount = ( uint16_t ) ipconfigDNS_CACHE_ADDRESSES_PER_ENTRY;
1253:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			uint16_t usNumARecordsStored = 0;
1254:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	
1255:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				for( x = 0U; x < pxDNSMessageHeader->usAnswers; x++ )
1256:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
1257:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				BaseType_t xDoAccept;
1258:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	
1259:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					if( usNumARecordsStored >= usCount )
1260:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					{
1261:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						/* Only count ipconfigDNS_CACHE_ADDRESSES_PER_ENTRY number of records. */
1262:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						break;
1263:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					}
1264:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1265:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					uxResult = prvSkipNameField( pucByte,
1266:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 												 uxSourceBytesRemaining );
1267:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	
1268:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					/* Check for a malformed response. */
1269:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					if( uxResult == 0U )
1270:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					{
1271:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						xReturn = pdFALSE;
1272:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						break;
1273:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					}
1274:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1275:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					uxBytesRead += uxResult;
1276:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					pucByte = &( pucByte[ uxResult ] );
1277:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					uxSourceBytesRemaining -= uxResult;
1278:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1279:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					/* Is there enough data for an IPv4 A record answer and, if so,
1280:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					is this an A record? */
1281:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					if( uxSourceBytesRemaining < sizeof( uint16_t ) )
1282:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					{
1283:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						xReturn = pdFALSE;
1284:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						break;
1285:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					}
1286:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					usType = usChar2u16( pucByte );
1287:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1288:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					if( usType == ( uint16_t ) dnsTYPE_A_HOST )
1289:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					{
1290:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						if( uxSourceBytesRemaining >= ( sizeof( DNSAnswerRecord_t ) + ipSIZE_OF_IPv4_ADDRESS ) )
1291:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						{
1292:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							xDoAccept = pdTRUE;
1293:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						}
1294:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						else
1295:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						{
1296:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							xDoAccept = pdFALSE;
1297:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						}
1298:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					}
1299:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					else
1300:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					{
1301:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						/* Unknown host type. */
1302:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						xDoAccept = pdFALSE;
1303:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					}
1304:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1305:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					if( xDoAccept != pdFALSE )
1306:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					{
1307:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						/* This is the required record type and is of sufficient size. */
1308:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						/* Mapping pucByte to a DNSAnswerRecord allows easy access of the
1309:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						 * fields of the structure. */
1310:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						pxDNSAnswerRecord = ipCAST_PTR_TO_TYPE_PTR( DNSAnswerRecord_t, pucByte );
1311:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1312:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						/* Sanity check the data length of an IPv4 answer. */
1313:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						if( FreeRTOS_ntohs( pxDNSAnswerRecord->usDataLength ) == ( uint16_t ) sizeof( uint32_t ) )
1314:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						{
1315:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							/* Copy the IP address out of the record. Using different pointers
1316:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							 * to copy only the portion we want is intentional here. */
1317:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							( void ) memcpy( ( void * ) ( &( ulIPAddress ) ),
1318:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 											 ( const void * ) ( &( pucByte[ sizeof( DNSAnswerRecord_t ) ] ) ),
1319:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 											 sizeof( uint32_t ) );
1320:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1321:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							#if( ipconfigDNS_USE_CALLBACKS == 1 )
1322:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							{
1323:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								/* See if any asynchronous call was made to FreeRTOS_gethostbyname_a() */
1324:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								if( xDNSDoCallback( ( TickType_t ) pxDNSMessageHeader->usIdentifier, pcName, ulIPAddress ) 
1325:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								{
1326:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 									/* This device has requested this DNS look-up.
1327:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 									The result may be stored in the DNS cache. */
1328:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 									xDoStore = pdTRUE;
1329:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								}
1330:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							}
1331:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							#endif	/* ipconfigDNS_USE_CALLBACKS == 1 */
1332:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							#if( ipconfigUSE_DNS_CACHE == 1 )
1333:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							{
1334:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							char cBuffer[ 16 ];
1335:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1336:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								/* The reply will only be stored in the DNS cache when the
1337:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								request was issued by this device. */
1338:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								if( xDoStore != pdFALSE )
1339:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								{
1340:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 									( void ) prvProcessDNSCache( pcName, &ulIPAddress, pxDNSAnswerRecord->ulTTL, pdFALSE );
1341:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 									usNumARecordsStored++;    /* Track # of A records stored */
1342:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								}
1343:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1344:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								( void ) FreeRTOS_inet_ntop( FREERTOS_AF_INET, ( const void * ) &( ulIPAddress ), cBuffer, 
1345:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								/* Show what has happened. */
1346:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								FreeRTOS_printf( ( "DNS[0x%04lX]: The answer to '%s' (%s) will%s be stored\n",
1347:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 												   ( UBaseType_t ) pxDNSMessageHeader->usIdentifier,
1348:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 												   pcName,
1349:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 												   cBuffer,
1350:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 												   ( xDoStore != 0 ) ? "" : " NOT" ) );
1351:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							}
1352:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							#endif /* ipconfigUSE_DNS_CACHE */
1353:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						}
1354:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1355:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						pucByte = &( pucByte[ sizeof( DNSAnswerRecord_t ) + sizeof( uint32_t ) ] );
1356:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						uxSourceBytesRemaining -= ( sizeof( DNSAnswerRecord_t ) + sizeof( uint32_t ) );
1357:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					}
1358:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					else if( uxSourceBytesRemaining >= sizeof( DNSAnswerRecord_t ) )
1359:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					{
1360:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						/* It's not an A record, so skip it. Get the header location
1361:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						and then jump over the header. */
1362:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						/* Cast the response to DNSAnswerRecord for easy access to fields of the DNS response. */
1363:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						pxDNSAnswerRecord = ipCAST_PTR_TO_TYPE_PTR( DNSAnswerRecord_t, pucByte );
1364:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1365:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						pucByte = &( pucByte[ sizeof( DNSAnswerRecord_t ) ] );
1366:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						uxSourceBytesRemaining -= sizeof( DNSAnswerRecord_t );
1367:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1368:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						/* Determine the length of the answer data from the header. */
1369:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						usDataLength = FreeRTOS_ntohs( pxDNSAnswerRecord->usDataLength );
1370:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1371:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						/* Jump over the answer. */
1372:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						if( uxSourceBytesRemaining >= usDataLength )
1373:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						{
1374:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							pucByte = &( pucByte[ usDataLength ] );
1375:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							uxSourceBytesRemaining -= usDataLength;
1376:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						}
1377:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						else
1378:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						{
1379:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							/* Malformed response. */
1380:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							xReturn = pdFALSE;
1381:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							break;
1382:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						}
1383:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					}
1384:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					else
1385:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					{
1386:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						/* Do nothing */
1387:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					}
1388:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
1389:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			}
1390:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1391:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #if( ipconfigUSE_LLMNR == 1 )
1392:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			else if( ( usQuestions != ( uint16_t ) 0U ) && ( usType == dnsTYPE_A_HOST ) && ( usClass == dnsC
1393:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
1394:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				/* If this is not a reply to our DNS request, it might an LLMNR
1395:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				request. */
1396:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				if( xApplicationDNSQueryHook( &( pcRequestedName[ 1 ] ) )  != pdFALSE )
1397:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
1398:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				int16_t usLength;
1399:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				NetworkBufferDescriptor_t *pxNewBuffer = NULL;
1400:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				NetworkBufferDescriptor_t *pxNetworkBuffer = pxUDPPayloadBuffer_to_NetworkBuffer( pucUDPPayload
1401:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				LLMNRAnswer_t *pxAnswer;
1402:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				uint8_t *pucNewBuffer = NULL;
1403:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1404:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					if( ( xBufferAllocFixedSize == pdFALSE ) && ( pxNetworkBuffer != NULL ) )
1405:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					{
1406:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					size_t uxDataLength = uxBufferLength + sizeof( UDPHeader_t ) + sizeof( EthernetHeader_t ) + si
1407:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1408:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						/* Set the size of the outgoing packet. */
1409:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						pxNetworkBuffer->xDataLength = uxDataLength;
1410:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						pxNewBuffer = pxDuplicateNetworkBufferWithDescriptor( pxNetworkBuffer, uxDataLength + sizeof(
1411:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1412:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						if( pxNewBuffer != NULL )
1413:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						{
1414:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						BaseType_t xOffset1, xOffset2;
1415:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1416:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							xOffset1 = ( BaseType_t ) ( pucByte - pucUDPPayloadBuffer );
1417:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							xOffset2 = ( BaseType_t ) ( ( ( uint8_t * ) pcRequestedName ) - pucUDPPayloadBuffer );
1418:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1419:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							pxNetworkBuffer = pxNewBuffer;
1420:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							pucNewBuffer = &( pxNetworkBuffer->pucEthernetBuffer[ ipUDP_PAYLOAD_OFFSET_IPv4 ] );
1421:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1422:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							pucByte = &( pucNewBuffer[ xOffset1 ] );
1423:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							pcRequestedName = ( char * ) &( pucNewBuffer[ xOffset2 ] );
1424:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							pxDNSMessageHeader = ipCAST_PTR_TO_TYPE_PTR( DNSMessage_t, pucNewBuffer );
1425:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						}
1426:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						else
1427:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						{
1428:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							/* Just to indicate that the message may not be answered. */
1429:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							pxNetworkBuffer = NULL;
1430:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						}
1431:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					}
1432:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1433:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					/* The test on 'pucNewBuffer' is only to satisfy lint. */
1434:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					if( ( pxNetworkBuffer != NULL ) && ( pucNewBuffer != NULL ) )
1435:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					{
1436:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						pxAnswer = ipCAST_PTR_TO_TYPE_PTR( LLMNRAnswer_t, pucByte );
1437:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1438:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						/* We leave 'usIdentifier' and 'usQuestions' untouched */
1439:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						#ifndef _lint
1440:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						vSetField16( pxDNSMessageHeader, DNSMessage_t, usFlags, dnsLLMNR_FLAGS_IS_REPONSE ); /* Set t
1441:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						vSetField16( pxDNSMessageHeader, DNSMessage_t, usAnswers, 1 );                       /* Provi
1442:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						vSetField16( pxDNSMessageHeader, DNSMessage_t, usAuthorityRRs, 0 );                  /* No au
1443:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						vSetField16( pxDNSMessageHeader, DNSMessage_t, usAdditionalRRs, 0 );                 /* No ad
1444:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						#endif /* lint */
1445:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1446:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						pxAnswer->ucNameCode = dnsNAME_IS_OFFSET;
1447:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						pxAnswer->ucNameOffset = ( uint8_t ) ( pcRequestedName - ( char * ) pucNewBuffer );
1448:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1449:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						#ifndef _lint
1450:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						vSetField16( pxAnswer, LLMNRAnswer_t, usType, dnsTYPE_A_HOST ); /* Type A: host */
1451:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						vSetField16( pxAnswer, LLMNRAnswer_t, usClass, dnsCLASS_IN );   /* 1: Class IN */
1452:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						vSetField32( pxAnswer, LLMNRAnswer_t, ulTTL, dnsLLMNR_TTL_VALUE );
1453:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						vSetField16( pxAnswer, LLMNRAnswer_t, usDataLength, 4 );
1454:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						vSetField32( pxAnswer, LLMNRAnswer_t, ulIPAddress, FreeRTOS_ntohl( *ipLOCAL_IP_ADDRESS_POINTE
1455:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						#endif /* lint */
1456:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						usLength = ( int16_t ) ( sizeof( *pxAnswer ) + ( size_t ) ( pucByte - pucNewBuffer ) );
1457:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1458:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						prvReplyDNSMessage( pxNetworkBuffer, usLength );
1459:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1460:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						if( pxNewBuffer != NULL )
1461:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						{
1462:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							vReleaseNetworkBufferAndDescriptor( pxNewBuffer );
1463:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						}
1464:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					}
1465:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
1466:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			}
1467:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			else
1468:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
1469:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				/* Not an expected reply. */
1470:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			}
1471:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #endif /* ipconfigUSE_LLMNR == 1 */
1472:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			( void ) uxBytesRead;
1473:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		} while( ipFALSE_BOOL );
1474:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
1475:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1476:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	if( xReturn == pdFALSE )
1477:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
1478:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		/* There was an error while parsing the DNS response. Return error code. */
1479:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		ulIPAddress = dnsPARSE_ERROR;
1480:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
1481:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	else if( xExpected == pdFALSE )
1482:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
1483:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		/* Do not return a valid IP-address in case the reply was not expected. */
1484:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		ulIPAddress = 0UL;
1485:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
1486:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	else
1487:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
1488:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		/* The IP-address found will be returned. */
1489:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
1490:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1491:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#if( ipconfigUSE_DNS_CACHE == 1 ) || ( ipconfigDNS_USE_CALLBACKS == 1 )
1492:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	( void ) xDoStore;
1493:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#endif
1494:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1495:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	return ulIPAddress;
1496:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** }
1497:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /*-----------------------------------------------------------*/
1498:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1499:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #if( ipconfigUSE_NBNS == 1 )
1500:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1501:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	static void prvTreatNBNS( uint8_t *pucPayload,
1502:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							  size_t uxBufferLength,
1503:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							  uint32_t ulIPAddress )
1504:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
1505:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	uint16_t usFlags, usType, usClass;
1506:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	uint8_t *pucSource, *pucTarget;
1507:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	uint8_t ucByte;
1508:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	uint8_t ucNBNSName[ 17 ];
1509:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	uint8_t *pucUDPPayloadBuffer = pucPayload;
1510:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	NetworkBufferDescriptor_t *pxNetworkBuffer;
1511:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	size_t uxBytesNeeded = sizeof( UDPPacket_t ) + sizeof( NBNSRequest_t );
1512:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1513:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		/* Check for minimum buffer size. */
1514:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		if( uxBufferLength < uxBytesNeeded )
1515:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
1516:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			return;
1517:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		}
1518:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1519:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		/* Read the request flags in host endianness. */
1520:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		usFlags = usChar2u16( &( pucUDPPayloadBuffer[ offsetof( NBNSRequest_t, usFlags ) ] ) );
1521:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1522:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		if( ( usFlags & dnsNBNS_FLAGS_OPCODE_MASK ) == dnsNBNS_FLAGS_OPCODE_QUERY )
1523:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
1524:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			usType  = usChar2u16( &( pucUDPPayloadBuffer[ offsetof( NBNSRequest_t, usType ) ] ) );
1525:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			usClass = usChar2u16( &( pucUDPPayloadBuffer[ offsetof( NBNSRequest_t, usClass ) ] ) );
1526:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1527:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			/* Not used for now */
1528:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			( void ) usClass;
1529:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1530:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			/* For NBNS a name is 16 bytes long, written with capitals only.
1531:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			Make sure that the copy is terminated with a zero. */
1532:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			pucTarget = &( ucNBNSName[ sizeof( ucNBNSName ) - 2U ] );
1533:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			pucTarget[ 1 ] = ( uint8_t ) 0U;
1534:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1535:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			/* Start with decoding the last 2 bytes. */
1536:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			pucSource = &( pucUDPPayloadBuffer[ ( dnsNBNS_ENCODED_NAME_LENGTH - 2 ) + offsetof( NBNSRequest_
1537:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1538:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			for( ;; )
1539:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
1540:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			const uint8_t ucCharA = ( uint8_t ) 0x41U;
1541:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1542:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				ucByte = ( ( uint8_t ) ( ( pucSource[ 0 ] - ucCharA ) << 4 ) ) | ( pucSource[ 1 ] - ucCharA );
1543:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1544:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				/* Make sure there are no trailing spaces in the name. */
1545:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				if( ( ucByte == ( uint8_t ) ' ' ) && ( pucTarget[ 1 ] == 0U ) )
1546:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
1547:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					ucByte = 0U;
1548:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
1549:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1550:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				*pucTarget = ucByte;
1551:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1552:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				if( pucTarget == ucNBNSName )
1553:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
1554:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					break;
1555:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
1556:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1557:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				pucTarget -= 1;
1558:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				pucSource -= 2;
1559:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			}
1560:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1561:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			#if( ipconfigUSE_DNS_CACHE == 1 )
1562:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
1563:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				if( ( usFlags & dnsNBNS_FLAGS_RESPONSE ) != 0U )
1564:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
1565:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					/* If this is a response from another device,
1566:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					add the name to the DNS cache */
1567:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					( void ) prvProcessDNSCache( ( char * ) ucNBNSName, &( ulIPAddress ), 0, pdFALSE );
1568:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
1569:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			}
1570:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			#else
1571:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
1572:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				/* Avoid compiler warnings. */
1573:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				( void ) ulIPAddress;
1574:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			}
1575:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			#endif /* ipconfigUSE_DNS_CACHE */
1576:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1577:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			if( ( ( usFlags & dnsNBNS_FLAGS_RESPONSE ) == 0U ) &&
1578:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				( usType == dnsNBNS_TYPE_NET_BIOS ) &&
1579:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				( xApplicationDNSQueryHook( ( const char * ) ucNBNSName ) != pdFALSE ) )
1580:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
1581:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			uint16_t usLength;
1582:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			DNSMessage_t *pxMessage;
1583:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			NBNSAnswer_t *pxAnswer;
1584:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1585:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				/* Someone is looking for a device with ucNBNSName,
1586:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				prepare a positive reply. */
1587:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				pxNetworkBuffer = pxUDPPayloadBuffer_to_NetworkBuffer( pucUDPPayloadBuffer );
1588:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1589:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				if( ( xBufferAllocFixedSize == pdFALSE ) && ( pxNetworkBuffer != NULL ) )
1590:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
1591:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				NetworkBufferDescriptor_t *pxNewBuffer;
1592:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1593:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					/* The field xDataLength was set to the total length of the UDP packet,
1594:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					i.e. the payload size plus sizeof( UDPPacket_t ). */
1595:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					pxNewBuffer = pxDuplicateNetworkBufferWithDescriptor( pxNetworkBuffer, pxNetworkBuffer->xDataL
1596:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1597:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					if( pxNewBuffer != NULL )
1598:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					{
1599:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						pucUDPPayloadBuffer = &( pxNewBuffer->pucEthernetBuffer[ sizeof( UDPPacket_t ) ] );
1600:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						pxNetworkBuffer = pxNewBuffer;
1601:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					}
1602:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					else
1603:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					{
1604:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						/* Just prevent that a reply will be sent */
1605:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						pxNetworkBuffer = NULL;
1606:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					}
1607:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
1608:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1609:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				/* Should not occur: pucUDPPayloadBuffer is part of a xNetworkBufferDescriptor */
1610:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				if( pxNetworkBuffer != NULL )
1611:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
1612:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					pxMessage = ipCAST_PTR_TO_TYPE_PTR( DNSMessage_t, pucUDPPayloadBuffer );
1613:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1614:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					/* As the fields in the structures are not word-aligned, we have to
1615:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					copy the values byte-by-byte using macro's vSetField16() and vSetField32() */
1616:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					#ifndef _lint
1617:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					vSetField16( pxMessage, DNSMessage_t, usFlags, dnsNBNS_QUERY_RESPONSE_FLAGS ); /* 0x8500 */
1618:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					vSetField16( pxMessage, DNSMessage_t, usQuestions, 0 );
1619:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					vSetField16( pxMessage, DNSMessage_t, usAnswers, 1 );
1620:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					vSetField16( pxMessage, DNSMessage_t, usAuthorityRRs, 0 );
1621:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					vSetField16( pxMessage, DNSMessage_t, usAdditionalRRs, 0 );
1622:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					#else
1623:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					( void ) pxMessage;
1624:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					#endif
1625:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					
1626:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					pxAnswer = ipCAST_PTR_TO_TYPE_PTR( NBNSAnswer_t, &( pucUDPPayloadBuffer[ offsetof( NBNSRequest
1627:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1628:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					#ifndef _lint
1629:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					vSetField16( pxAnswer, NBNSAnswer_t, usType, usType );            /* Type */
1630:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					vSetField16( pxAnswer, NBNSAnswer_t, usClass, dnsNBNS_CLASS_IN ); /* Class */
1631:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					vSetField32( pxAnswer, NBNSAnswer_t, ulTTL, dnsNBNS_TTL_VALUE );
1632:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					vSetField16( pxAnswer, NBNSAnswer_t, usDataLength, 6 );           /* 6 bytes including the len
1633:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					vSetField16( pxAnswer, NBNSAnswer_t, usNbFlags, dnsNBNS_NAME_FLAGS );
1634:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					vSetField32( pxAnswer, NBNSAnswer_t, ulIPAddress, FreeRTOS_ntohl( *ipLOCAL_IP_ADDRESS_POINTER 
1635:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					#else
1636:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					( void ) pxAnswer;
1637:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					#endif
1638:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1639:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					usLength = ( uint16_t ) ( sizeof( NBNSAnswer_t ) + ( size_t ) offsetof( NBNSRequest_t, usType 
1640:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1641:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					prvReplyDNSMessage( pxNetworkBuffer, ( BaseType_t ) usLength );
1642:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
1643:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			}
1644:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		}
1645:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
1646:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1647:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #endif /* ipconfigUSE_NBNS */
1648:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /*-----------------------------------------------------------*/
1649:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1650:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** static Socket_t prvCreateDNSSocket( void )
1651:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** {
1652:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** Socket_t xSocket;
1653:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** struct freertos_sockaddr xAddress;
1654:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** BaseType_t xReturn;
1655:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1656:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	/* This must be the first time this function has been called.  Create
1657:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	the socket. */
1658:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	xSocket = FreeRTOS_socket( FREERTOS_AF_INET, FREERTOS_SOCK_DGRAM, FREERTOS_IPPROTO_UDP );
1659:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	if( prvSocketValid( xSocket ) != pdTRUE )
1660:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
1661:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		/* There was an error, return NULL. */
1662:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		xSocket = NULL;
1663:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
1664:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	else
1665:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
1666:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		/* Auto bind the port. */
1667:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		xAddress.sin_port = 0U;
1668:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		xReturn = FreeRTOS_bind( xSocket, &xAddress, sizeof( xAddress ) );
1669:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1670:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		/* Check the bind was successful, and clean up if not. */
1671:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		if( xReturn != 0 )
1672:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
1673:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			( void ) FreeRTOS_closesocket( xSocket );
1674:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			xSocket = NULL;
1675:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		}
1676:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		else
1677:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
1678:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			/* The send and receive timeouts will be set later on. */
1679:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		}
1680:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
1681:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1682:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	return xSocket;
1683:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** }
1684:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /*-----------------------------------------------------------*/
1685:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1686:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #if( ( ipconfigUSE_NBNS == 1 ) || ( ipconfigUSE_LLMNR == 1 ) )
1687:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1688:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	static void prvReplyDNSMessage( NetworkBufferDescriptor_t *pxNetworkBuffer,
1689:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 									BaseType_t lNetLength )
1690:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
1691:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	UDPPacket_t *pxUDPPacket;
1692:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	IPHeader_t *pxIPHeader;
1693:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	UDPHeader_t *pxUDPHeader;
1694:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	size_t uxDataLength;
1695:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1696:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		pxUDPPacket = ipCAST_PTR_TO_TYPE_PTR( UDPPacket_t, pxNetworkBuffer->pucEthernetBuffer );
1697:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		pxIPHeader = &pxUDPPacket->xIPHeader;
1698:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		pxUDPHeader = &pxUDPPacket->xUDPHeader;
1699:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		/* HT: started using defines like 'ipSIZE_OF_xxx' */
1700:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			pxIPHeader->usLength				= FreeRTOS_htons( ( uint16_t ) lNetLength + ipSIZE_OF_IPv4_HEADER + ipSI
1701:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		/* HT:endian: should not be translated, copying from packet to packet */
1702:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		pxIPHeader->ulDestinationIPAddress = pxIPHeader->ulSourceIPAddress;
1703:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		pxIPHeader->ulSourceIPAddress	   = *ipLOCAL_IP_ADDRESS_POINTER;
1704:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		pxIPHeader->ucTimeToLive		   = ipconfigUDP_TIME_TO_LIVE;
1705:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		pxIPHeader->usIdentification	   = FreeRTOS_htons( usPacketIdentifier );
1706:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		usPacketIdentifier++;
1707:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		pxUDPHeader->usLength			   = FreeRTOS_htons( ( uint32_t ) lNetLength + ipSIZE_OF_UDP_HEADER );
1708:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		vFlip_16( pxUDPHeader->usSourcePort, pxUDPHeader->usDestinationPort );
1709:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1710:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		/* Important: tell NIC driver how many bytes must be sent */
1711:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		uxDataLength = ( ( size_t ) lNetLength ) + ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_UDP_HEADER + ipSIZE_
1712:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1713:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		#if( ipconfigDRIVER_INCLUDED_TX_IP_CHECKSUM == 0 )
1714:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
1715:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			/* calculate the IP header checksum */
1716:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			pxIPHeader->usHeaderChecksum = 0U;
1717:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			pxIPHeader->usHeaderChecksum = usGenerateChecksum( 0U, ( uint8_t * ) &( pxIPHeader->ucVersionHea
1718:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			pxIPHeader->usHeaderChecksum = ~FreeRTOS_htons( pxIPHeader->usHeaderChecksum );
1719:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1720:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			/* calculate the UDP checksum for outgoing package */
1721:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			( void ) usGenerateProtocolChecksum( ( uint8_t * ) pxUDPPacket, uxDataLength, pdTRUE );
1722:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		}
1723:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		#endif
1724:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1725:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		/* Important: tell NIC driver how many bytes must be sent */
1726:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		pxNetworkBuffer->xDataLength = uxDataLength;
1727:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1728:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		/* This function will fill in the eth addresses and send the packet */
1729:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		vReturnEthernetFrame( pxNetworkBuffer, pdFALSE );
1730:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
1731:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1732:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #endif /* ipconfigUSE_NBNS == 1 || ipconfigUSE_LLMNR == 1 */
1733:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /*-----------------------------------------------------------*/
1734:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1735:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #if( ipconfigUSE_DNS_CACHE == 1 )
1736:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1737:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	static BaseType_t prvProcessDNSCache( const char *pcName,
1738:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 									uint32_t *pulIP,
1739:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 									uint32_t ulTTL,
1740:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 									BaseType_t xLookUp )
1741:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
 136              	 .loc 1 1741 0
 137              	 .cfi_startproc
 138              	 
 139              	 
 140              	.LVL20:
 141 0000 2DE9F04F 	 push {r4,r5,r6,r7,r8,r9,r10,fp,lr}
 142              	.LCFI0:
 143              	 .cfi_def_cfa_offset 36
 144              	 .cfi_offset 4,-36
 145              	 .cfi_offset 5,-32
 146              	 .cfi_offset 6,-28
 147              	 .cfi_offset 7,-24
 148              	 .cfi_offset 8,-20
 149              	 .cfi_offset 9,-16
 150              	 .cfi_offset 10,-12
 151              	 .cfi_offset 11,-8
 152              	 .cfi_offset 14,-4
 153 0004 83B0     	 sub sp,sp,#12
 154              	.LCFI1:
 155              	 .cfi_def_cfa_offset 48
 156 0006 0546     	 mov r5,r0
 157 0008 0190     	 str r0,[sp,#4]
 158 000a 0E46     	 mov r6,r1
 159 000c 9146     	 mov r9,r2
 160 000e 9846     	 mov r8,r3
 161              	.LVL21:
1742:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	BaseType_t x;
1743:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	BaseType_t xFound = pdFALSE;
1744:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	uint32_t ulCurrentTimeSeconds = ( xTaskGetTickCount() / portTICK_PERIOD_MS ) / 1000UL;
 162              	 .loc 1 1744 0
 163 0010 FFF7FEFF 	 bl xTaskGetTickCount
 164              	.LVL22:
 165 0014 424C     	 ldr r4,.L34
 166 0016 A4FB0034 	 umull r3,r4,r4,r0
 167 001a A409     	 lsrs r4,r4,#6
 168              	.LVL23:
1745:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	uint32_t ulIPAddressIndex = 0;
1746:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	static BaseType_t xFreeEntry = 0;
1747:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1748:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		configASSERT( ( pcName != NULL ) );
 169              	 .loc 1 1748 0
 170 001c 45B9     	 cbnz r5,.L16
 171              	.LBB38:
 172              	.LBB39:
 173              	 .file 2 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h"
   1:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*
   2:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * FreeRTOS Kernel V10.4.1
   3:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
   5:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * this software and associated documentation files (the "Software"), to deal in
   7:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * the Software without restriction, including without limitation the rights to
   8:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * subject to the following conditions:
  11:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  12:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * The above copyright notice and this permission notice shall be included in all
  13:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * copies or substantial portions of the Software.
  14:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  15:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  22:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * https://www.FreeRTOS.org
  23:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * https://github.com/FreeRTOS
  24:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  25:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * 1 tab == 4 spaces!
  26:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  */
  27:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  28:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  29:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** #ifndef PORTMACRO_H
  30:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define PORTMACRO_H
  31:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  32:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifdef __cplusplus
  33:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         extern "C" {
  34:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
  35:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  36:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------
  37:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * Port specific definitions.
  38:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  39:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * The settings in this file configure FreeRTOS correctly for the
  40:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * given hardware and compiler.
  41:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  42:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * These settings should not be altered.
  43:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *-----------------------------------------------------------
  44:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  */
  45:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  46:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Type definitions. */
  47:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portCHAR          char
  48:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portFLOAT         float
  49:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portDOUBLE        double
  50:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portLONG          long
  51:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portSHORT         short
  52:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portSTACK_TYPE    uint32_t
  53:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portBASE_TYPE     long
  54:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  55:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     typedef portSTACK_TYPE   StackType_t;
  56:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     typedef long             BaseType_t;
  57:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     typedef unsigned long    UBaseType_t;
  58:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  59:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #if ( configUSE_16_BIT_TICKS == 1 )
  60:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         typedef uint16_t     TickType_t;
  61:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portMAX_DELAY              ( TickType_t ) 0xffff
  62:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #else
  63:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         typedef uint32_t     TickType_t;
  64:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portMAX_DELAY              ( TickType_t ) 0xffffffffUL
  65:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  66:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
  67:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * not need to be guarded with a critical section. */
  68:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portTICK_TYPE_IS_ATOMIC    1
  69:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
  70:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
  71:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  72:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Architecture specifics. */
  73:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portSTACK_GROWTH      ( -1 )
  74:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portTICK_PERIOD_MS    ( ( TickType_t ) 1000 / configTICK_RATE_HZ )
  75:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portBYTE_ALIGNMENT    8
  76:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portDONT_DISCARD      __attribute__( ( used ) )
  77:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
  78:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  79:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Scheduler utilities. */
  80:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portYIELD()                                 \
  81:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     {                                                   \
  82:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         /* Set a PendSV to request a context switch. */ \
  83:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT; \
  84:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****                                                         \
  85:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         /* Barriers are normally not required but do ensure the code is completely \
  86:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****          * within the specified behaviour for the architecture. */ \
  87:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile ( "dsb" ::: "memory" );                     \
  88:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile ( "isb" );                                  \
  89:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     }
  90:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  91:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portNVIC_INT_CTRL_REG     ( *( ( volatile uint32_t * ) 0xe000ed04 ) )
  92:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portNVIC_PENDSVSET_BIT    ( 1UL << 28UL )
  93:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portEND_SWITCHING_ISR( xSwitchRequired )    if( xSwitchRequired != pdFALSE ) portYIELD(
  94:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portYIELD_FROM_ISR( x )                     portEND_SWITCHING_ISR( x )
  95:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
  96:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  97:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Critical section management. */
  98:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     extern void vPortEnterCritical( void );
  99:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     extern void vPortExitCritical( void );
 100:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portSET_INTERRUPT_MASK_FROM_ISR()         ulPortRaiseBASEPRI()
 101:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portCLEAR_INTERRUPT_MASK_FROM_ISR( x )    vPortSetBASEPRI( x )
 102:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portDISABLE_INTERRUPTS()                  vPortRaiseBASEPRI()
 103:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portENABLE_INTERRUPTS()                   vPortSetBASEPRI( 0 )
 104:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portENTER_CRITICAL()                      vPortEnterCritical()
 105:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portEXIT_CRITICAL()                       vPortExitCritical()
 106:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 107:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 108:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 109:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Task function macros as described on the FreeRTOS.org WEB site.  These are
 110:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * not necessary for to use this port.  They are defined so the common demo files
 111:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * (which build with all the ports) will build. */
 112:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portTASK_FUNCTION_PROTO( vFunction, pvParameters )    void vFunction( void * pvParamete
 113:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portTASK_FUNCTION( vFunction, pvParameters )          void vFunction( void * pvParamete
 114:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 115:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 116:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Tickless idle/low power functionality. */
 117:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifndef portSUPPRESS_TICKS_AND_SLEEP
 118:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
 119:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime )    vPortSuppressTicksAndSleep( xE
 120:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
 121:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 122:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 123:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Architecture specific optimisations. */
 124:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
 125:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define configUSE_PORT_OPTIMISED_TASK_SELECTION    1
 126:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
 127:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 128:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
 129:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 130:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Generic helper function. */
 131:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t 
 132:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         {
 133:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             uint8_t ucReturn;
 134:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 135:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             __asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 136:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 137:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             return ucReturn;
 138:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         }
 139:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 140:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Check the configuration. */
 141:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #if ( configMAX_PRIORITIES > 32 )
 142:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             #error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIO
 143:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #endif
 144:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 145:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Store/clear the ready priorities in a bit map. */
 146:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities )    ( uxReadyPriorities )
 147:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities )     ( uxReadyPriorities )
 148:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 149:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 150:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 151:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities )    uxTopPriority = ( 3
 152:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 153:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 154:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 155:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 156:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 157:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifdef configASSERT
 158:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         void vPortValidateInterruptPriority( void );
 159:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portASSERT_IF_INTERRUPT_PRIORITY_INVALID()    vPortValidateInterruptPriority()
 160:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
 161:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 162:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* portNOP() is not required by this port. */
 163:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portNOP()
 164:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 165:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portINLINE              __inline
 166:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 167:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifndef portFORCE_INLINE
 168:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portFORCE_INLINE    inline __attribute__( ( always_inline ) )
 169:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
 170:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 171:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     portFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )
 172:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     {
 173:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         uint32_t ulCurrentInterrupt;
 174:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         BaseType_t xReturn;
 175:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 176:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         /* Obtain the number of the currently executing interrupt. */
 177:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile ( "mrs %0, ipsr" : "=r" ( ulCurrentInterrupt )::"memory" );
 178:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 179:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         if( ulCurrentInterrupt == 0 )
 180:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         {
 181:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             xReturn = pdFALSE;
 182:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         }
 183:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         else
 184:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         {
 185:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             xReturn = pdTRUE;
 186:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         }
 187:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 188:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         return xReturn;
 189:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     }
 190:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 191:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 192:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 193:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     portFORCE_INLINE static void vPortRaiseBASEPRI( void )
 194:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     {
 195:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         uint32_t ulNewBASEPRI;
 196:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile
 174              	 .loc 2 197 0
 175              	
 176 001e 4FF01403 	 mov r3,#20
 177 0022 83F31188 	 msr basepri,r3
 178 0026 BFF36F8F 	 isb 
 179 002a BFF34F8F 	 dsb 
 180              	
 181              	
 182              	.LVL24:
 183              	 .thumb
 184              	.L17:
 185              	.LBE39:
 186              	.LBE38:
 187              	 .loc 1 1748 0 discriminator 1
 188 002e FEE7     	 b .L17
 189              	.L16:
 190 0030 3C4F     	 ldr r7,.L34+4
 191              	 .loc 1 1748 0 is_stmt 0
 192 0032 0025     	 movs r5,#0
 193              	.LVL25:
 194              	.L22:
1749:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1750:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		/* For each entry in the DNS cache table. */
1751:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		for( x = 0; x < ipconfigDNS_CACHE_ENTRIES; x++ )
1752:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
1753:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			if( xDNSCache[ x ].pcName[ 0 ] == ( char ) 0 )
 195              	 .loc 1 1753 0 is_stmt 1
 196 0034 3B79     	 ldrb r3,[r7,#4]
 197 0036 002B     	 cmp r3,#0
 198 0038 39D0     	 beq .L18
1754:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
1755:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				continue;
1756:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			}
1757:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1758:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			if( strcmp( xDNSCache[ x ].pcName, pcName ) == 0 )
 199              	 .loc 1 1758 0
 200 003a 381D     	 adds r0,r7,#4
 201 003c 0199     	 ldr r1,[sp,#4]
 202 003e FFF7FEFF 	 bl strcmp
 203              	.LVL26:
 204 0042 A0BB     	 cbnz r0,.L18
1759:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
1760:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				/* Is this function called for a lookup or to add/update an IP address? */
1761:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				if( xLookUp != pdFALSE )
 205              	 .loc 1 1761 0
 206 0044 B8F1000F 	 cmp r8,#0
 207 0048 23D0     	 beq .L19
1762:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
1763:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					/* Confirm that the record is still fresh. */
1764:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					if( ulCurrentTimeSeconds < ( xDNSCache[ x ].ulTimeWhenAddedInSeconds + FreeRTOS_ntohl( xDNSCac
 208              	 .loc 1 1764 0
 209 004a C5EBC501 	 rsb r1,r5,r5,lsl#3
 210 004e 354B     	 ldr r3,.L34+4
 211 0050 03EB8101 	 add r1,r3,r1,lsl#2
 212 0054 4A69     	 ldr r2,[r1,#20]
 213 0056 1306     	 lsls r3,r2,#24
 214 0058 43EA1263 	 orr r3,r3,r2,lsr#24
 215 005c 02F47F40 	 and r0,r2,#65280
 216 0060 43EA0023 	 orr r3,r3,r0,lsl#8
 217 0064 02F47F02 	 and r2,r2,#16711680
 218 0068 43EA1223 	 orr r3,r3,r2,lsr#8
 219 006c 8A69     	 ldr r2,[r1,#24]
 220 006e 1344     	 add r3,r3,r2
 221 0070 9C42     	 cmp r4,r3
 222 0072 06D2     	 bcs .L20
1765:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					{
1766:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #if( ipconfigDNS_CACHE_ADDRESSES_PER_ENTRY > 1 )
1767:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					uint8_t ucIndex;
1768:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						/* The ucCurrentIPAddress value increments without bound and will rollover, */
1769:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						/*  modulo it by the number of IP addresses to keep it in range.     */
1770:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						/*  Also perform a final modulo by the max number of IP addresses    */
1771:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						/*  per DNS cache entry to prevent out-of-bounds access in the event */
1772:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						/*  that ucNumIPAddresses has been corrupted.                        */
1773:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						ucIndex = xDNSCache[ x ].ucCurrentIPAddress % xDNSCache[ x ].ucNumIPAddresses;
1774:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						ucIndex = ucIndex % ( uint8_t ) ipconfigDNS_CACHE_ADDRESSES_PER_ENTRY;
1775:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						ulIPAddressIndex = ucIndex;
1776:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1777:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						xDNSCache[ x ].ucCurrentIPAddress++;
1778:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #endif
1779:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						*pulIP = xDNSCache[ x ].ulIPAddresses[ ulIPAddressIndex ];
 223              	 .loc 1 1779 0
 224 0074 C5EBC505 	 rsb r5,r5,r5,lsl#3
 225              	.LVL27:
 226 0078 2A4B     	 ldr r3,.L34+4
 227 007a 53F82530 	 ldr r3,[r3,r5,lsl#2]
 228 007e 3360     	 str r3,[r6]
 229 0080 4AE0     	 b .L21
 230              	.LVL28:
 231              	.L20:
1780:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					}
1781:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					else
1782:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					{
1783:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						/* Age out the old cached record. */
1784:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						xDNSCache[ x ].pcName[ 0 ] = ( char ) 0;
 232              	 .loc 1 1784 0
 233 0082 C5EBC505 	 rsb r5,r5,r5,lsl#3
 234              	.LVL29:
 235 0086 274B     	 ldr r3,.L34+4
 236 0088 03EB8503 	 add r3,r3,r5,lsl#2
 237 008c 0022     	 movs r2,#0
 238 008e 1A71     	 strb r2,[r3,#4]
 239 0090 42E0     	 b .L21
 240              	.LVL30:
 241              	.L19:
1785:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					}
1786:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
1787:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				else
1788:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
1789:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #if( ipconfigDNS_CACHE_ADDRESSES_PER_ENTRY > 1 )
1790:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					if ( xDNSCache[ x ].ucNumIPAddresses < ( uint8_t ) ipconfigDNS_CACHE_ADDRESSES_PER_ENTRY )
1791:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					{
1792:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						/* If more answers exist than there are IP address storage slots */
1793:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						/* they will overwrite entry 0 */
1794:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1795:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						ulIPAddressIndex = xDNSCache[ x ].ucNumIPAddresses;
1796:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						xDNSCache[ x ].ucNumIPAddresses++;
1797:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					}
1798:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #endif
1799:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					xDNSCache[ x ].ulIPAddresses[ ulIPAddressIndex ] = *pulIP;
 242              	 .loc 1 1799 0
 243 0092 3668     	 ldr r6,[r6]
 244              	.LVL31:
 245 0094 234B     	 ldr r3,.L34+4
 246 0096 EA00     	 lsls r2,r5,#3
 247 0098 511B     	 subs r1,r2,r5
 248 009a 8900     	 lsls r1,r1,#2
 249 009c 5818     	 adds r0,r3,r1
 250 009e 5E50     	 str r6,[r3,r1]
1800:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					xDNSCache[ x ].ulTTL = ulTTL;
 251              	 .loc 1 1800 0
 252 00a0 C0F81490 	 str r9,[r0,#20]
1801:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					xDNSCache[ x ].ulTimeWhenAddedInSeconds = ulCurrentTimeSeconds;
 253              	 .loc 1 1801 0
 254 00a4 521B     	 subs r2,r2,r5
 255 00a6 03EB8203 	 add r3,r3,r2,lsl#2
 256 00aa 9C61     	 str r4,[r3,#24]
 257 00ac 34E0     	 b .L21
 258              	.LVL32:
 259              	.L18:
1751:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
 260              	 .loc 1 1751 0 discriminator 2
 261 00ae 0135     	 adds r5,r5,#1
 262              	.LVL33:
 263 00b0 1C37     	 adds r7,r7,#28
 264 00b2 042D     	 cmp r5,#4
 265 00b4 BED1     	 bne .L22
 266 00b6 2BE0     	 b .L30
 267              	.L25:
1802:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
1803:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1804:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				xFound = pdTRUE;
1805:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				break;
1806:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			}
1807:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		}
1808:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1809:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		if( xFound == pdFALSE )
1810:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
1811:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			if( xLookUp != pdFALSE )
1812:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
1813:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				*pulIP = 0UL;
 268              	 .loc 1 1813 0
 269 00b8 0020     	 movs r0,#0
 270 00ba 3060     	 str r0,[r6]
 271 00bc 2DE0     	 b .L31
 272              	.L32:
1814:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			}
1815:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			else
1816:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
1817:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				/* Add or update the item. */
1818:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				if( strlen( pcName ) < ( size_t ) ipconfigDNS_CACHE_NAME_LENGTH )
 273              	 .loc 1 1818 0
 274 00be 0198     	 ldr r0,[sp,#4]
 275 00c0 FFF7FEFF 	 bl strlen
 276              	.LVL34:
 277 00c4 0F28     	 cmp r0,#15
 278 00c6 1FD8     	 bhi .L27
1819:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
1820:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					( void ) strcpy( xDNSCache[ xFreeEntry ].pcName, pcName );
 279              	 .loc 1 1820 0
 280 00c8 DFF85CA0 	 ldr r10,.L34+8
 281 00cc DAF80050 	 ldr r5,[r10]
 282              	.LVL35:
 283 00d0 DFF850B0 	 ldr fp,.L34+4
 284 00d4 C5EBC507 	 rsb r7,r5,r5,lsl#3
 285 00d8 BF00     	 lsls r7,r7,#2
 286 00da 0BEB0708 	 add r8,fp,r7
 287              	.LVL36:
 288 00de 08F10400 	 add r0,r8,#4
 289 00e2 0199     	 ldr r1,[sp,#4]
 290 00e4 FFF7FEFF 	 bl strcpy
 291              	.LVL37:
1821:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1822:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					xDNSCache[ xFreeEntry ].ulIPAddresses[ 0 ] = *pulIP;
 292              	 .loc 1 1822 0
 293 00e8 3368     	 ldr r3,[r6]
 294 00ea 4BF80730 	 str r3,[fp,r7]
1823:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					xDNSCache[ xFreeEntry ].ulTTL = ulTTL;
 295              	 .loc 1 1823 0
 296 00ee C8F81490 	 str r9,[r8,#20]
1824:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					xDNSCache[ xFreeEntry ].ulTimeWhenAddedInSeconds = ulCurrentTimeSeconds;
 297              	 .loc 1 1824 0
 298 00f2 C8F81840 	 str r4,[r8,#24]
1825:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #if( ipconfigDNS_CACHE_ADDRESSES_PER_ENTRY > 1 )
1826:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					xDNSCache[ xFreeEntry ].ucNumIPAddresses = 1;
1827:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					xDNSCache[ xFreeEntry ].ucCurrentIPAddress = 0;
1828:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1829:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					/* Initialize all remaining IP addresses in this entry to 0 */
1830:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					( void ) memset( &xDNSCache[ xFreeEntry ].ulIPAddresses[ 1 ],
1831:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							0,
1832:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							sizeof( xDNSCache[ xFreeEntry ].ulIPAddresses[ 1 ] ) *
1833:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								( ( uint32_t ) ipconfigDNS_CACHE_ADDRESSES_PER_ENTRY - 1U ) );
1834:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #endif
1835:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1836:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					xFreeEntry++;
 299              	 .loc 1 1836 0
 300 00f6 0135     	 adds r5,r5,#1
 301 00f8 CAF80050 	 str r5,[r10]
1837:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1838:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					if( xFreeEntry == ipconfigDNS_CACHE_ENTRIES )
 302              	 .loc 1 1838 0
 303 00fc 042D     	 cmp r5,#4
 304 00fe 05D1     	 bne .L28
1839:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					{
1840:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						xFreeEntry = 0;
 305              	 .loc 1 1840 0
 306 0100 0020     	 movs r0,#0
 307 0102 CAF80000 	 str r0,[r10]
 308 0106 08E0     	 b .L31
 309              	.LVL38:
 310              	.L27:
1743:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	uint32_t ulCurrentTimeSeconds = ( xTaskGetTickCount() / portTICK_PERIOD_MS ) / 1000UL;
 311              	 .loc 1 1743 0
 312 0108 0020     	 movs r0,#0
 313 010a 06E0     	 b .L31
 314              	.LVL39:
 315              	.L28:
 316 010c 0020     	 movs r0,#0
 317 010e 04E0     	 b .L31
 318              	.LVL40:
 319              	.L30:
1811:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
 320              	 .loc 1 1811 0
 321 0110 B8F1000F 	 cmp r8,#0
 322 0114 D3D0     	 beq .L32
 323 0116 CFE7     	 b .L25
 324              	.LVL41:
 325              	.L21:
1748:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 326              	 .loc 1 1748 0
 327 0118 0120     	 movs r0,#1
 328              	.LVL42:
 329              	.L31:
1841:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					}
1842:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
1843:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			}
1844:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		}
1845:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
1846:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		if( ( xLookUp == 0 ) || ( *pulIP != 0UL ) )
1847:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
1848:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			FreeRTOS_debug_printf( ( "prvProcessDNSCache: %s: '%s' @ %lxip\n", ( xLookUp != 0 ) ? "look-up" 
1849:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		}
1850:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		return xFound;
1851:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
 330              	 .loc 1 1851 0
 331 011a 03B0     	 add sp,sp,#12
 332              	.LCFI2:
 333              	 .cfi_def_cfa_offset 36
 334              	 
 335 011c BDE8F08F 	 pop {r4,r5,r6,r7,r8,r9,r10,fp,pc}
 336              	.LVL43:
 337              	.L35:
 338              	 .align 2
 339              	.L34:
 340 0120 D34D6210 	 .word 274877907
 341 0124 00000000 	 .word .LANCHOR0
 342 0128 00000000 	 .word .LANCHOR1
 343              	 .cfi_endproc
 344              	.LFE72:
 346              	 .section .text.prvParseDNSReply,"ax",%progbits
 347              	 .align 2
 348              	 .thumb
 349              	 .thumb_func
 351              	prvParseDNSReply:
 352              	.LFB70:
1124:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** DNSMessage_t *pxDNSMessageHeader;
 353              	 .loc 1 1124 0
 354              	 .cfi_startproc
 355              	 
 356              	 
 357              	.LVL44:
 358 0000 2DE9F04F 	 push {r4,r5,r6,r7,r8,r9,r10,fp,lr}
 359              	.LCFI3:
 360              	 .cfi_def_cfa_offset 36
 361              	 .cfi_offset 4,-36
 362              	 .cfi_offset 5,-32
 363              	 .cfi_offset 6,-28
 364              	 .cfi_offset 7,-24
 365              	 .cfi_offset 8,-20
 366              	 .cfi_offset 9,-16
 367              	 .cfi_offset 10,-12
 368              	 .cfi_offset 11,-8
 369              	 .cfi_offset 14,-4
 370 0004 8DB0     	 sub sp,sp,#52
 371              	.LCFI4:
 372              	 .cfi_def_cfa_offset 88
1128:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #if( ipconfigUSE_LLMNR == 1 )
 373              	 .loc 1 1128 0
 374 0006 0023     	 movs r3,#0
 375 0008 0B93     	 str r3,[sp,#44]
 376              	.LVL45:
1143:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #endif
 377              	 .loc 1 1143 0
 378 000a 0793     	 str r3,[sp,#28]
 379 000c 0893     	 str r3,[sp,#32]
 380 000e 0993     	 str r3,[sp,#36]
 381 0010 0A93     	 str r3,[sp,#40]
1147:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
 382              	 .loc 1 1147 0
 383 0012 0B29     	 cmp r1,#11
 384 0014 40F20D81 	 bls .L68
 385 0018 0092     	 str r2,[sp]
 386 001a 0646     	 mov r6,r0
 387              	.LVL46:
 388              	.LBB51:
1166:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			uxSourceBytesRemaining -= sizeof( DNSMessage_t );
 389              	 .loc 1 1166 0
 390 001c 00F10C05 	 add r5,r0,#12
 391              	.LVL47:
1167:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 392              	 .loc 1 1167 0
 393 0020 A1F10C04 	 sub r4,r1,#12
 394              	.LVL48:
1170:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 395              	 .loc 1 1170 0
 396 0024 B0F80480 	 ldrh r8,[r0,#4]
 397 0028 4FEA1823 	 lsr r3,r8,#8
 398 002c 43EA0828 	 orr r8,r3,r8,lsl#8
 399 0030 1FFA88F8 	 uxth r8,r8
 400              	.LVL49:
1172:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
 401              	 .loc 1 1172 0
 402 0034 B8F1000F 	 cmp r8,#0
 403 0038 00F00181 	 beq .L38
 404 003c 0027     	 movs r7,#0
 405              	.LBB52:
 406              	.LBB53:
 936:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			}
 407              	 .loc 1 936 0
 408 003e 4FF0020B 	 mov fp,#2
 946:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
 409              	 .loc 1 946 0
 410 0042 B946     	 mov r9,r7
 411 0044 0197     	 str r7,[sp,#4]
 412              	.LVL50:
 413              	.L54:
 414              	.LBE53:
 415              	.LBE52:
1184:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
 416              	 .loc 1 1184 0
 417 0046 002F     	 cmp r7,#0
 418 0048 62D1     	 bne .L39
 419              	.LVL51:
 420              	.LBB56:
 421              	.LBB54:
 924:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
 422              	 .loc 1 924 0
 423 004a 002C     	 cmp r4,#0
 424 004c 00F0F180 	 beq .L68
 931:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
 425              	 .loc 1 931 0
 426 0050 2978     	 ldrb r1,[r5]
 427 0052 01F0C003 	 and r3,r1,#192
 428 0056 C02B     	 cmp r3,#192
 429 0058 01D0     	 beq .L41
 946:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
 430              	 .loc 1 946 0
 431 005a 69B9     	 cbnz r1,.L72
 432 005c E9E0     	 b .L68
 433              	.L41:
 934:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
 434              	 .loc 1 934 0
 435 005e 022C     	 cmp r4,#2
 436 0060 52D8     	 bhi .L73
 437 0062 E6E0     	 b .L68
 438              	.LVL52:
 439              	.L51:
 950:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
 440              	 .loc 1 950 0
 441 0064 62B1     	 cbz r2,.L42
 952:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					{
 442              	 .loc 1 952 0
 443 0066 0F2A     	 cmp r2,#15
 444 0068 00F2E380 	 bhi .L68
 958:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					uxNameLen++;
 445              	 .loc 1 958 0
 446 006c 0CAB     	 add r3,sp,#48
 447 006e 1344     	 add r3,r3,r2
 448 0070 03F814AC 	 strb r10,[r3,#-20]
 959:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
 449              	 .loc 1 959 0
 450 0074 0132     	 adds r2,r2,#1
 451              	.LVL53:
 452 0076 03E0     	 b .L42
 453              	.LVL54:
 454              	.L72:
 946:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
 455              	 .loc 1 946 0
 456 0078 4846     	 mov r0,r9
 457 007a 019A     	 ldr r2,[sp,#4]
 958:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					uxNameLen++;
 458              	 .loc 1 958 0
 459 007c 4FF02E0A 	 mov r10,#46
 460              	.LVL55:
 461              	.L42:
 963:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				uxIndex++;
 462              	 .loc 1 963 0
 463 0080 8C46     	 mov ip,r1
 464              	.LVL56:
 964:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				if( ( uxIndex + uxCount ) > uxSourceLen )
 465              	 .loc 1 964 0
 466 0082 431C     	 adds r3,r0,#1
 467              	.LVL57:
 965:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
 468              	 .loc 1 965 0
 469 0084 03EB010E 	 add lr,r3,r1
 470 0088 A645     	 cmp lr,r4
 471 008a 00F2D280 	 bhi .L68
 472              	.LVL58:
 971:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
 473              	 .loc 1 971 0
 474 008e C1B1     	 cbz r1,.L74
 475 0090 A342     	 cmp r3,r4
 476 0092 25D2     	 bcs .L50
 973:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					{
 477              	 .loc 1 973 0
 478 0094 0F2A     	 cmp r2,#15
 479 0096 16D8     	 bhi .L75
 480 0098 2844     	 add r0,r0,r5
 481 009a 07A9     	 add r1,sp,#28
 482              	.LVL59:
 483 009c 01EB020E 	 add lr,r1,r2
 484 00a0 9444     	 add ip,ip,r2
 485              	.LVL60:
 486 00a2 0132     	 adds r2,r2,#1
 487              	.LVL61:
 488 00a4 03E0     	 b .L48
 489              	.LVL62:
 490              	.L49:
 491 00a6 511C     	 adds r1,r2,#1
 492 00a8 1129     	 cmp r1,#17
 493 00aa 0ED0     	 beq .L76
 494 00ac 0A46     	 mov r2,r1
 495              	.LVL63:
 496              	.L48:
 980:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					uxNameLen++;
 497              	 .loc 1 980 0
 498 00ae 10F8011F 	 ldrb r1,[r0,#1]!
 499 00b2 0EF8011B 	 strb r1,[lr],#1
 500              	.LVL64:
 982:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
 501              	 .loc 1 982 0
 502 00b6 0133     	 adds r3,r3,#1
 503              	.LVL65:
 971:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
 504              	 .loc 1 971 0
 505 00b8 6245     	 cmp r2,ip
 506 00ba 08D0     	 beq .L77
 507 00bc A342     	 cmp r3,r4
 508 00be F2D3     	 bcc .L49
 509 00c0 0EE0     	 b .L50
 510              	.LVL66:
 511              	.L74:
 964:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				if( ( uxIndex + uxCount ) > uxSourceLen )
 512              	 .loc 1 964 0
 513 00c2 1846     	 mov r0,r3
 514 00c4 04E0     	 b .L46
 515              	.L75:
 975:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						break;
 516              	 .loc 1 975 0
 517 00c6 0198     	 ldr r0,[sp,#4]
 518 00c8 02E0     	 b .L46
 519              	.LVL67:
 520              	.L76:
 521 00ca 0198     	 ldr r0,[sp,#4]
 522 00cc 00E0     	 b .L46
 523              	.L77:
 982:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
 524              	 .loc 1 982 0
 525 00ce 1846     	 mov r0,r3
 526              	.L46:
 527              	.LVL68:
 946:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
 528              	 .loc 1 946 0
 529 00d0 A042     	 cmp r0,r4
 530 00d2 04D2     	 bcs .L78
 531 00d4 295C     	 ldrb r1,[r5,r0]
 532 00d6 0029     	 cmp r1,#0
 533 00d8 C4D1     	 bne .L51
 534 00da 0346     	 mov r3,r0
 535 00dc 00E0     	 b .L50
 536              	.L78:
 537 00de 0346     	 mov r3,r0
 538              	.LVL69:
 539              	.L50:
 987:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
 540              	 .loc 1 987 0
 541 00e0 002B     	 cmp r3,#0
 542 00e2 00F0A680 	 beq .L68
 989:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
 543              	 .loc 1 989 0
 544 00e6 0F2A     	 cmp r2,#15
 545 00e8 00F2A380 	 bhi .L68
 546 00ec A342     	 cmp r3,r4
 547 00ee 80F0A080 	 bcs .L68
 548 00f2 E95C     	 ldrb r1,[r5,r3]
 549 00f4 0029     	 cmp r1,#0
 550 00f6 40F09C80 	 bne .L68
 991:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					uxIndex++;
 551              	 .loc 1 991 0
 552 00fa 0CA9     	 add r1,sp,#48
 553 00fc 0A44     	 add r2,r2,r1
 554              	.LVL70:
 555 00fe 02F8149C 	 strb r9,[r2,#-20]
 556              	.LVL71:
 557              	.LBE54:
 558              	.LBE56:
1192:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					{
 559              	 .loc 1 1192 0
 560 0102 591C     	 adds r1,r3,#1
 561              	.LVL72:
 562 0104 01D1     	 bne .L44
 563 0106 94E0     	 b .L68
 564              	.LVL73:
 565              	.L73:
 566              	.LBB57:
 567              	.LBB55:
 936:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			}
 568              	 .loc 1 936 0
 569 0108 5946     	 mov r1,fp
 570              	.LVL74:
 571              	.L44:
 572              	.LBE55:
 573              	.LBE57:
1198:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					uxSourceBytesRemaining -= uxResult;
 574              	 .loc 1 1198 0
 575 010a 0D44     	 add r5,r5,r1
 576              	.LVL75:
1199:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
 577              	 .loc 1 1199 0
 578 010c 611A     	 subs r1,r4,r1
 579              	.LVL76:
 580 010e 08E0     	 b .L53
 581              	.LVL77:
 582              	.L39:
1205:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 												 uxSourceBytesRemaining );
 583              	 .loc 1 1205 0
 584 0110 2846     	 mov r0,r5
 585 0112 2146     	 mov r1,r4
 586 0114 FFF7FEFF 	 bl prvSkipNameField
 587              	.LVL78:
1209:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					{
 588              	 .loc 1 1209 0
 589 0118 0028     	 cmp r0,#0
 590 011a 00F08A80 	 beq .L68
1215:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					uxSourceBytesRemaining -= uxResult;
 591              	 .loc 1 1215 0
 592 011e 0544     	 add r5,r5,r0
 593              	.LVL79:
1216:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
 594              	 .loc 1 1216 0
 595 0120 211A     	 subs r1,r4,r0
 596              	.LVL80:
 597              	.L53:
1220:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
 598              	 .loc 1 1220 0
 599 0122 0329     	 cmp r1,#3
 600 0124 40F28580 	 bls .L68
1231:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					uxSourceBytesRemaining -= sizeof( uint32_t );
 601              	 .loc 1 1231 0
 602 0128 0435     	 adds r5,r5,#4
 603              	.LVL81:
1232:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
 604              	 .loc 1 1232 0
 605 012a 0C1F     	 subs r4,r1,#4
 606              	.LVL82:
1172:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
 607              	 .loc 1 1172 0
 608 012c 0137     	 adds r7,r7,#1
 609 012e BFB2     	 uxth r7,r7
 610              	.LVL83:
 611 0130 B845     	 cmp r8,r7
 612 0132 88D1     	 bne .L54
 613 0134 83E0     	 b .L38
 614              	.LVL84:
 615              	.L67:
 616              	.LBB58:
1255:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
 617              	 .loc 1 1255 0 discriminator 1
 618 0136 23B9     	 cbnz r3,.L79
 619 0138 9AE0     	 b .L56
 620              	.LVL85:
 621              	.L64:
 622              	.LBB59:
1259:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					{
 623              	 .loc 1 1259 0
 624 013a B9F1000F 	 cmp r9,#0
 625 013e 07D0     	 beq .L84
 626              	.LBE59:
 627 0140 96E0     	 b .L56
 628              	.LVL86:
 629              	.L79:
1255:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
 630              	 .loc 1 1255 0
 631 0142 009B     	 ldr r3,[sp]
 632 0144 0193     	 str r3,[sp,#4]
 633 0146 0027     	 movs r7,#0
 634              	.LBB73:
 635              	.LBB60:
 636              	.LBB61:
 509:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				 pxIterator != ( const ListItem_t * ) xEnd;
 637              	 .loc 1 509 0
 638 0148 DFF844A1 	 ldr r10,.L88
 639 014c 0AF10808 	 add r8,r10,#8
 640              	.LVL87:
 641              	.L84:
 642              	.LBE61:
 643              	.LBE60:
1265:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 												 uxSourceBytesRemaining );
 644              	 .loc 1 1265 0
 645 0150 2846     	 mov r0,r5
 646 0152 2146     	 mov r1,r4
 647 0154 FFF7FEFF 	 bl prvSkipNameField
 648              	.LVL88:
1269:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					{
 649              	 .loc 1 1269 0
 650 0158 0028     	 cmp r0,#0
 651 015a 6AD0     	 beq .L68
1276:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					uxSourceBytesRemaining -= uxResult;
 652              	 .loc 1 1276 0
 653 015c 0544     	 add r5,r5,r0
 654              	.LVL89:
1277:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 655              	 .loc 1 1277 0
 656 015e 241A     	 subs r4,r4,r0
 657              	.LVL90:
1281:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					{
 658              	 .loc 1 1281 0
 659 0160 012C     	 cmp r4,#1
 660 0162 66D9     	 bls .L68
 661              	.LVL91:
 662              	.LBB66:
 663              	.LBB67:
 664              	 .file 3 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include/FreeRTOS_IP_Private.h"
   1:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*
   2:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * FreeRTOS+TCP V2.2.2
   3:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  *
   5:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * this software and associated documentation files (the "Software"), to deal in
   7:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * the Software without restriction, including without limitation the rights to
   8:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * subject to the following conditions:
  11:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  *
  12:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * The above copyright notice and this permission notice shall be included in all
  13:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * copies or substantial portions of the Software.
  14:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  *
  15:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  *
  22:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * http://aws.amazon.com/freertos
  23:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * http://www.FreeRTOS.org
  24:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  */
  25:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
  26:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #ifndef FREERTOS_IP_PRIVATE_H
  27:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define FREERTOS_IP_PRIVATE_H
  28:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
  29:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #ifdef __cplusplus
  30:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** extern "C" {
  31:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #endif
  32:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
  33:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* Application level configuration options. */
  34:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "FreeRTOSIPConfig.h"
  35:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "FreeRTOSIPConfigDefaults.h"
  36:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "FreeRTOS_Sockets.h"
  37:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "IPTraceMacroDefaults.h"
  38:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "FreeRTOS_Stream_Buffer.h"
  39:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #if( ipconfigUSE_TCP == 1 )
  40:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#include "FreeRTOS_TCP_WIN.h"
  41:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#include "FreeRTOS_TCP_IP.h"
  42:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #endif
  43:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
  44:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "semphr.h"
  45:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
  46:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "event_groups.h"
  47:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
  48:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*-----------------------------------------------------------*/
  49:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* Utility macros for marking casts as recognized during     */
  50:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* static analysis.                                          */
  51:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*-----------------------------------------------------------*/
  52:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define ipCAST_PTR_TO_TYPE_PTR( TYPE, pointer ) ( vCastPointerTo_##TYPE( ( void * )( pointer ) ) )
  53:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define ipCAST_CONST_PTR_TO_CONST_TYPE_PTR( TYPE, pointer ) ( vCastConstPointerTo_##TYPE( ( const v
  54:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
  55:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*-----------------------------------------------------------*/
  56:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* Utility macros for declaring cast utility functions in    */
  57:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* order to centralize typecasting for static analysis.      */
  58:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*-----------------------------------------------------------*/
  59:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define ipDECL_CAST_PTR_FUNC_FOR_TYPE( TYPE ) TYPE * vCastPointerTo_##TYPE( void * pvArgument )
  60:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define ipDECL_CAST_CONST_PTR_FUNC_FOR_TYPE( TYPE ) const TYPE * vCastConstPointerTo_##TYPE( const 
  61:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
  62:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef struct xNetworkAddressingParameters
  63:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
  64:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint32_t ulDefaultIPAddress;
  65:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint32_t ulNetMask;
  66:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint32_t ulGatewayAddress;
  67:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint32_t ulDNSServerAddress;
  68:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint32_t ulBroadcastAddress;
  69:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** } NetworkAddressingParameters_t;
  70:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
  71:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** extern BaseType_t xTCPWindowLoggingLevel;
  72:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** extern QueueHandle_t xNetworkEventQueue;
  73:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
  74:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*-----------------------------------------------------------*/
  75:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* Protocol headers.                                         */
  76:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*-----------------------------------------------------------*/
  77:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
  78:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_start.h"
  79:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** struct xETH_HEADER
  80:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
  81:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	MACAddress_t xDestinationAddress; /*  0 + 6 = 6  */
  82:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	MACAddress_t xSourceAddress;      /*  6 + 6 = 12 */
  83:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usFrameType;              /* 12 + 2 = 14 */
  84:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
  85:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_end.h"
  86:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef struct xETH_HEADER EthernetHeader_t;
  87:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
  88:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_PTR_FUNC_FOR_TYPE( EthernetHeader_t )
  89:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
  90:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	return ( EthernetHeader_t *)pvArgument;
  91:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
  92:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
  93:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_CONST_PTR_FUNC_FOR_TYPE( EthernetHeader_t )
  94:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
  95:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	return ( const EthernetHeader_t *) pvArgument;
  96:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
  97:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
  98:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
  99:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_start.h"
 100:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** struct xARP_HEADER
 101:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 102:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usHardwareType;				/*  0 +  2 =  2 */
 103:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usProtocolType;				/*  2 +  2 =  4 */
 104:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint8_t ucHardwareAddressLength;		/*  4 +  1 =  5 */
 105:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint8_t ucProtocolAddressLength;		/*  5 +  1 =  6 */
 106:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usOperation;					/*  6 +  2 =  8 */
 107:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	MACAddress_t xSenderHardwareAddress;	/*  8 +  6 = 14 */
 108:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint8_t ucSenderProtocolAddress[ 4 ];	/* 14 +  4 = 18  */
 109:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	MACAddress_t xTargetHardwareAddress;	/* 18 +  6 = 24  */
 110:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint32_t ulTargetProtocolAddress;		/* 24 +  4 = 28  */
 111:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 112:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_end.h"
 113:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef struct xARP_HEADER ARPHeader_t;
 114:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 115:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_start.h"
 116:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** struct xIP_HEADER
 117:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 118:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint8_t ucVersionHeaderLength;        /*  0 + 1 =  1 */
 119:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint8_t ucDifferentiatedServicesCode; /*  1 + 1 =  2 */
 120:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usLength;                    /*  2 + 2 =  4 */
 121:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usIdentification;            /*  4 + 2 =  6 */
 122:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usFragmentOffset;            /*  6 + 2 =  8 */
 123:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint8_t ucTimeToLive;                 /*  8 + 1 =  9 */
 124:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint8_t ucProtocol;                   /*  9 + 1 = 10 */
 125:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usHeaderChecksum;            /* 10 + 2 = 12 */
 126:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint32_t ulSourceIPAddress;           /* 12 + 4 = 16 */
 127:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint32_t ulDestinationIPAddress;      /* 16 + 4 = 20 */
 128:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 129:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_end.h"
 130:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef struct xIP_HEADER IPHeader_t;
 131:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 132:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_PTR_FUNC_FOR_TYPE( IPHeader_t )
 133:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 134:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	return ( IPHeader_t *)pvArgument;
 135:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 136:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_CONST_PTR_FUNC_FOR_TYPE( IPHeader_t )
 137:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 138:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	return ( const IPHeader_t *) pvArgument;
 139:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 140:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 141:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 142:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_start.h"
 143:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** struct xICMP_HEADER
 144:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 145:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint8_t ucTypeOfMessage;   /* 0 + 1 = 1 */
 146:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint8_t ucTypeOfService;   /* 1 + 1 = 2 */
 147:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usChecksum;       /* 2 + 2 = 4 */
 148:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usIdentifier;     /* 4 + 2 = 6 */
 149:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usSequenceNumber; /* 6 + 2 = 8 */
 150:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 151:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_end.h"
 152:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef struct xICMP_HEADER ICMPHeader_t;
 153:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 154:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_PTR_FUNC_FOR_TYPE( ICMPHeader_t )
 155:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 156:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	return ( ICMPHeader_t *)pvArgument;
 157:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 158:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_CONST_PTR_FUNC_FOR_TYPE( ICMPHeader_t )
 159:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 160:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	return ( const ICMPHeader_t *) pvArgument;
 161:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 162:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 163:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 164:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_start.h"
 165:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** struct xUDP_HEADER
 166:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 167:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usSourcePort;      /* 0 + 2 = 2 */
 168:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usDestinationPort; /* 2 + 2 = 4 */
 169:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usLength;          /* 4 + 2 = 6 */
 170:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usChecksum;        /* 6 + 2 = 8 */
 171:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 172:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_end.h"
 173:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef struct xUDP_HEADER UDPHeader_t;
 174:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 175:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_start.h"
 176:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** struct xTCP_HEADER
 177:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 178:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usSourcePort;		/* +  2 =  2 */
 179:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usDestinationPort;	/* +  2 =  4 */
 180:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint32_t ulSequenceNumber;	/* +  4 =  8 */
 181:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint32_t ulAckNr;   	 	/* +  4 = 12 */
 182:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint8_t  ucTCPOffset;		/* +  1 = 13 */
 183:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint8_t  ucTCPFlags;		/* +  1 = 14 */
 184:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usWindow;			/* +  2 = 15 */
 185:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usChecksum;		/* +  2 = 18 */
 186:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usUrgent;			/* +  2 = 20 */
 187:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #if ipconfigUSE_TCP == 1
 188:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	/* the option data is not a part of the TCP header */
 189:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint8_t  ucOptdata[ipSIZE_TCP_OPTIONS];		/* + 12 = 32 */
 190:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #endif
 191:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 192:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_end.h"
 193:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef struct xTCP_HEADER TCPHeader_t;
 194:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 195:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*-----------------------------------------------------------*/
 196:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* Nested protocol packets.                                  */
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*-----------------------------------------------------------*/
 198:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 199:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_start.h"
 200:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** struct xARP_PACKET
 201:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 202:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	EthernetHeader_t xEthernetHeader;	/*  0 + 14 = 14 */
 203:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	ARPHeader_t xARPHeader;			/* 14 + 28 = 42 */
 204:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 205:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_end.h"
 206:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef struct xARP_PACKET ARPPacket_t;
 207:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 208:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_PTR_FUNC_FOR_TYPE( ARPPacket_t )
 209:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 210:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****     return ( ARPPacket_t *)pvArgument;
 211:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 212:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_CONST_PTR_FUNC_FOR_TYPE( ARPPacket_t )
 213:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 214:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****     return ( const ARPPacket_t *) pvArgument;
 215:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 216:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 217:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 218:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_start.h"
 219:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** struct xIP_PACKET
 220:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 221:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	EthernetHeader_t xEthernetHeader;
 222:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	IPHeader_t xIPHeader;
 223:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 224:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_end.h"
 225:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef struct xIP_PACKET IPPacket_t;
 226:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 227:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_PTR_FUNC_FOR_TYPE( IPPacket_t )
 228:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 229:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****     return ( IPPacket_t *)pvArgument;
 230:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 231:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_CONST_PTR_FUNC_FOR_TYPE( IPPacket_t )
 232:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 233:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****     return ( const IPPacket_t *) pvArgument;
 234:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 235:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 236:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 237:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_start.h"
 238:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** struct xICMP_PACKET
 239:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 240:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	EthernetHeader_t xEthernetHeader;
 241:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	IPHeader_t xIPHeader;
 242:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	ICMPHeader_t xICMPHeader;
 243:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 244:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_end.h"
 245:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef struct xICMP_PACKET ICMPPacket_t;
 246:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 247:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_PTR_FUNC_FOR_TYPE( ICMPPacket_t )
 248:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 249:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****     return ( ICMPPacket_t *)pvArgument;
 250:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 251:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 252:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 253:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_start.h"
 254:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** struct xUDP_PACKET
 255:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 256:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	EthernetHeader_t xEthernetHeader; /*  0 + 14 = 14 */
 257:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	IPHeader_t xIPHeader;             /* 14 + 20 = 34 */
 258:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	UDPHeader_t xUDPHeader;           /* 34 +  8 = 42 */
 259:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 260:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_end.h"
 261:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef struct xUDP_PACKET UDPPacket_t;
 262:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 263:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_PTR_FUNC_FOR_TYPE( UDPPacket_t )
 264:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 265:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****     return ( UDPPacket_t *)pvArgument;
 266:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 267:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_CONST_PTR_FUNC_FOR_TYPE( UDPPacket_t )
 268:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 269:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****     return ( const UDPPacket_t *) pvArgument;
 270:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 271:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 272:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_start.h"
 273:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** struct xTCP_PACKET
 274:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 275:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	EthernetHeader_t xEthernetHeader; /*  0 + 14 = 14 */
 276:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	IPHeader_t xIPHeader;             /* 14 + 20 = 34 */
 277:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	TCPHeader_t xTCPHeader;           /* 34 + 32 = 66 */
 278:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 279:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #include "pack_struct_end.h"
 280:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef struct xTCP_PACKET TCPPacket_t;
 281:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 282:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_PTR_FUNC_FOR_TYPE( TCPPacket_t )
 283:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 284:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****     return ( TCPPacket_t *)pvArgument;
 285:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 286:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 287:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_CONST_PTR_FUNC_FOR_TYPE( TCPPacket_t )
 288:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 289:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	return ( const TCPPacket_t *) pvArgument;
 290:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 291:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 292:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 293:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef union XPROT_PACKET
 294:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 295:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	ARPPacket_t xARPPacket;
 296:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	TCPPacket_t xTCPPacket;
 297:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	UDPPacket_t xUDPPacket;
 298:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	ICMPPacket_t xICMPPacket;
 299:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** } ProtocolPacket_t;
 300:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 301:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_PTR_FUNC_FOR_TYPE( ProtocolPacket_t )
 302:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 303:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	return ( ProtocolPacket_t *)pvArgument;
 304:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 305:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_CONST_PTR_FUNC_FOR_TYPE( ProtocolPacket_t )
 306:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 307:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	return ( const ProtocolPacket_t *) pvArgument;
 308:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 309:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 310:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef union xPROT_HEADERS
 311:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 312:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	ICMPHeader_t xICMPHeader;
 313:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	UDPHeader_t xUDPHeader;
 314:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	TCPHeader_t xTCPHeader;
 315:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** } ProtocolHeaders_t;
 316:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 317:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_PTR_FUNC_FOR_TYPE( ProtocolHeaders_t )
 318:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 319:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	return ( ProtocolHeaders_t *)pvArgument;
 320:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 321:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 322:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_CONST_PTR_FUNC_FOR_TYPE( ProtocolHeaders_t )
 323:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 324:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	return ( const ProtocolHeaders_t *) pvArgument;
 325:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 326:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 327:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* The maximum UDP payload length. */
 328:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define ipMAX_UDP_PAYLOAD_LENGTH ( ( ipconfigNETWORK_MTU - ipSIZE_OF_IPv4_HEADER ) - ipSIZE_OF_UDP_
 329:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 330:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* The maximum RAW payload length */
 331:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define ipMAX_RAW_PAYLOAD_LENGTH ( ipconfigNETWORK_MTU )
 332:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 333:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 334:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef enum
 335:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 336:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eReleaseBuffer = 0,		/* Processing the frame did not find anything to do - just release the buffer
 337:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eProcessBuffer,			/* An Ethernet frame has a valid address - continue process its contents. */
 338:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eReturnEthernetFrame,	/* The Ethernet frame contains an ARP or ICMP packet that can be returned to
 339:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eFrameConsumed			/* Processing the Ethernet packet contents resulted in the payload being sent to 
 340:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** } eFrameProcessingResult_t;
 341:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 342:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef enum
 343:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 344:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eNoEvent = -1,
 345:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eNetworkDownEvent,		/* 0: The network interface has been lost and/or needs [re]connecting. */
 346:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eNetworkRxEvent,		/* 1: The network interface has queued a received Ethernet frame. */
 347:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eNetworkTxEvent,		/* 2: Let the IP-task send a network packet. */
 348:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eARPTimerEvent,			/* 3: The ARP timer expired. */
 349:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eStackTxEvent,			/* 4: The software stack has queued a packet to transmit. */
 350:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eDHCPEvent,				/* 5: Process the DHCP state machine. */
 351:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eTCPTimerEvent,			/* 6: See if any TCP socket needs attention. */
 352:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eTCPAcceptEvent,		/* 7: Client API FreeRTOS_accept() waiting for client connections. */
 353:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eTCPNetStat,			/* 8: IP-task is asked to produce a netstat listing. */
 354:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eSocketBindEvent,		/* 9: Send a message to the IP-task to bind a socket to a port. */
 355:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eSocketCloseEvent,		/*10: Send a message to the IP-task to close a socket. */
 356:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eSocketSelectEvent,		/*11: Send a message to the IP-task for select(). */
 357:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eSocketSignalEvent,		/*12: A socket must be signalled. */
 358:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eStackRAWTxEvent,
 359:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** } eIPEvent_t;
 360:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 361:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef struct IP_TASK_COMMANDS
 362:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 363:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eIPEvent_t eEventType;
 364:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	void *pvData;
 365:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** } IPStackEvent_t;
 366:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 367:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define ipBROADCAST_IP_ADDRESS 0xffffffffUL
 368:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 369:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* Offset into the Ethernet frame that is used to temporarily store information
 370:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** on the fragmentation status of the packet being sent.  The value is important,
 371:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** as it is past the location into which the destination address will get placed. */
 372:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define ipFRAGMENTATION_PARAMETERS_OFFSET		( 6 )
 373:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define ipSOCKET_OPTIONS_OFFSET					( 6 )
 374:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 375:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* Only used when outgoing fragmentation is being used (FreeRTOSIPConfig.h
 376:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** setting. */
 377:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define ipGET_UDP_PAYLOAD_OFFSET_FOR_FRAGMENT( usFragmentOffset ) ( ( ( usFragmentOffset ) == 0 ) ?
 378:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 379:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* The offset into a UDP packet at which the UDP data (payload) starts. */
 380:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define ipUDP_PAYLOAD_OFFSET_IPv4	( sizeof( UDPPacket_t ) )
 381:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 382:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* The offset into an IP packet into which the IP data (payload) starts. */
 383:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define ipIP_PAYLOAD_OFFSET		( sizeof( IPPacket_t ) )
 384:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 385:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #if( ipconfigBYTE_ORDER == pdFREERTOS_LITTLE_ENDIAN )
 386:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 387:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	/* Ethernet frame types. */
 388:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#define ipARP_FRAME_TYPE	( 0x0608U )
 389:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#define ipIPv4_FRAME_TYPE	( 0x0008U )
 390:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 391:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	/* ARP related definitions. */
 392:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#define ipARP_PROTOCOL_TYPE				( 0x0008U )
 393:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#define ipARP_HARDWARE_TYPE_ETHERNET	( 0x0100U )
 394:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#define ipARP_REQUEST					( 0x0100U )
 395:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#define ipARP_REPLY						( 0x0200U )
 396:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 397:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #else
 398:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 399:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	/* Ethernet frame types. */
 400:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#define ipARP_FRAME_TYPE	( 0x0806U )
 401:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#define ipIPv4_FRAME_TYPE	( 0x0800U )
 402:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 403:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	/* ARP related definitions. */
 404:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#define ipARP_PROTOCOL_TYPE ( 0x0800U )
 405:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#define ipARP_HARDWARE_TYPE_ETHERNET ( 0x0001U )
 406:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#define ipARP_REQUEST ( 0x0001 )
 407:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#define ipARP_REPLY ( 0x0002 )
 408:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 409:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #endif /* ipconfigBYTE_ORDER == pdFREERTOS_LITTLE_ENDIAN */
 410:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 411:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 412:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* For convenience, a MAC address of all zeros and another of all 0xffs are
 413:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** defined const for quick reference. */
 414:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** extern const MACAddress_t xBroadcastMACAddress; /* all 0xff's */
 415:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** extern uint16_t usPacketIdentifier;
 416:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 417:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* Define a default UDP packet header (declared in FreeRTOS_UDP_IP.c) */
 418:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef union xUDPPacketHeader
 419:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 420:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint8_t ucBytes[24];
 421:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint32_t ulWords[6];
 422:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** } UDPPacketHeader_t;
 423:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** extern UDPPacketHeader_t xDefaultPartUDPPacketHeader;
 424:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** extern UDPPacketHeader_t xDefaultPartRAWPacketHeader;
 425:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 426:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* Structure that stores the netmask, gateway address and DNS server addresses. */
 427:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** extern NetworkAddressingParameters_t xNetworkAddressing;
 428:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 429:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* Structure that stores the defaults for netmask, gateway address and DNS.
 430:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** These values will be copied to 'xNetworkAddressing' in case DHCP is not used,
 431:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** and also in case DHCP does not lead to a confirmed request. */
 432:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*lint -e9003*/
 433:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** extern NetworkAddressingParameters_t xDefaultAddressing;	/*lint !e9003 could define variable 'xDefa
 434:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 435:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* True when BufferAllocation_1.c was included, false for BufferAllocation_2.c */
 436:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** extern const BaseType_t xBufferAllocFixedSize;
 437:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 438:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* Defined in FreeRTOS_Sockets.c */
 439:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #if ( ipconfigUSE_TCP == 1 )
 440:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	extern List_t xBoundTCPSocketsList;
 441:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #endif
 442:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 443:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* The local IP address is accessed from within xDefaultPartUDPPacketHeader,
 444:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** rather than duplicated in its own variable. */
 445:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define ipLOCAL_IP_ADDRESS_POINTER ( ( uint32_t * ) &( xDefaultPartUDPPacketHeader.ulWords[ 20U / s
 446:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 447:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* The local MAC address is accessed from within xDefaultPartUDPPacketHeader,
 448:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** rather than duplicated in its own variable. */
 449:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define ipLOCAL_MAC_ADDRESS ( xDefaultPartUDPPacketHeader.ucBytes )
 450:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 451:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* In this library, there is often a cast from a character pointer
 452:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * to a pointer to a struct.
 453:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * In order to suppress MISRA warnings, do the cast within a macro,
 454:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * which can be exempt from warnings:
 455:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  *
 456:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * 3 required by MISRA:
 457:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * -emacro(740,ipPOINTER_CAST)    // 750:  Unusual pointer cast (incompatible indirect types) [MISR
 458:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * -emacro(9005,ipPOINTER_CAST)   // 9005: attempt to cast away const/volatile from a pointer or re
 459:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * -emacro(9087,ipPOINTER_CAST)   // 9087: cast performed between a pointer to object type and a po
 460:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  *
 461:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * 2 advisory by MISRA:
 462:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * -emacro(9079,ipPOINTER_CAST)   // 9079: conversion from pointer to void to pointer to other type
 463:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * --emacro((826),ipPOINTER_CAST) // 826:  Suspicious pointer-to-pointer conversion (area too small
 464:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * 
 465:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * The MISRA warnings can safely be suppressed because all casts are planned with care.
 466:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  */
 467:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 468:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define ipPOINTER_CAST( TYPE, pointer  ) ( ( TYPE ) ( pointer ) )
 469:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 470:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* Sequence and ACK numbers are essentially unsigned (uint32_t). But when
 471:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * a distance is calculated, it is useful to use signed numbers:
 472:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * int32_t lDistance = ( int32_t ) ( ulSeq1 - ulSeq2 );
 473:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  *
 474:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * 1 required by MISRA:
 475:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * -emacro(9033,ipNUMERIC_CAST) // 9033: Impermissible cast of composite expression (different esse
 476:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  *
 477:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * 1 advisory by MISRA:
 478:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * -emacro(9030,ipNUMERIC_CAST) // 9030: Impermissible cast; cannot cast from 'essentially Boolean'
 479:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  */
 480:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 481:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define ipNUMERIC_CAST( TYPE, expression  ) ( ( TYPE ) ( expression ) )
 482:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 483:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* ICMP packets are sent using the same function as UDP packets.  The port
 484:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** number is used to distinguish between the two, as 0 is an invalid UDP port. */
 485:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define ipPACKET_CONTAINS_ICMP_DATA					( 0 )
 486:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 487:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* For now, the lower 8 bits in 'xEventBits' will be reserved for the above
 488:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** socket events. */
 489:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define SOCKET_EVENT_BIT_COUNT   8
 490:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 491:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define vSetField16( pxBase, xType, xField, usValue ) \
 492:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** { \
 493:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	( ( uint8_t* )( pxBase ) ) [ offsetof( xType, xField ) + 0 ] = ( uint8_t ) ( ( usValue ) >> 8 ); \
 494:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	( ( uint8_t* )( pxBase ) ) [ offsetof( xType, xField ) + 1 ] = ( uint8_t ) ( ( usValue ) & 0xffU )
 495:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 496:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 497:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define vSetField32( pxBase, xType, xField, ulValue ) \
 498:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** { \
 499:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	( (uint8_t*)( pxBase ) ) [ offsetof( xType, xField ) + 0 ] = ( uint8_t )   ( ( ulValue ) >> 24 ); 
 500:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	( (uint8_t*)( pxBase ) ) [ offsetof( xType, xField ) + 1 ] = ( uint8_t ) ( ( ( ulValue ) >> 16 ) &
 501:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	( (uint8_t*)( pxBase ) ) [ offsetof( xType, xField ) + 2 ] = ( uint8_t ) ( ( ( ulValue ) >> 8 ) & 
 502:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	( (uint8_t*)( pxBase ) ) [ offsetof( xType, xField ) + 3 ] = ( uint8_t )   ( ( ulValue ) & 0xffU )
 503:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 504:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 505:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define vFlip_16( left, right ) \
 506:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	do { \
 507:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		uint16_t tmp = (left); \
 508:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		(left) = (right); \
 509:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		(right) = tmp; \
 510:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	} while ( ipFALSE_BOOL )
 511:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 512:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #define vFlip_32( left, right ) \
 513:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	do { \
 514:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		uint32_t tmp = (left); \
 515:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		(left) = (right); \
 516:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		(right) = tmp; \
 517:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	} while ( ipFALSE_BOOL )
 518:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 519:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* WARNING: Do NOT use this macro when the array was received as a parameter. */
 520:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #ifndef ARRAY_SIZE
 521:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#define ARRAY_SIZE(x)	( ( BaseType_t ) ( sizeof( x ) / sizeof( ( x )[ 0 ] ) ) )
 522:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #endif
 523:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 524:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*
 525:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * Create a message that contains a command to initialise the network interface.
 526:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * This is used during initialisation, and at any time the network interface
 527:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * goes down thereafter.  The network interface hardware driver is responsible
 528:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * for sending the message that contains the network interface down command/
 529:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * event.
 530:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  *
 531:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * Only use the FreeRTOS_NetworkDownFromISR() version if the function is to be
 532:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * called from an interrupt service routine.  If FreeRTOS_NetworkDownFromISR()
 533:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * returns a non-zero value then a context switch should be performed ebfore
 534:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * the interrupt is exited.
 535:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  */
 536:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** void FreeRTOS_NetworkDown( void );
 537:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** BaseType_t FreeRTOS_NetworkDownFromISR( void );
 538:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 539:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*
 540:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * Processes incoming ARP packets.
 541:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  */
 542:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** eFrameProcessingResult_t eARPProcessPacket( ARPPacket_t * const pxARPFrame );
 543:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 544:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*
 545:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * Inspect an Ethernet frame to see if it contains data that the stack needs to
 546:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * process.  eProcessBuffer is returned if the frame should be processed by the
 547:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * stack.  eReleaseBuffer is returned if the frame should be discarded.
 548:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  */
 549:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** eFrameProcessingResult_t eConsiderFrameForProcessing( const uint8_t * const pucEthernetBuffer );
 550:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 551:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*
 552:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * Return the checksum generated over xDataLengthBytes from pucNextData.
 553:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  */
 554:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** uint16_t usGenerateChecksum( uint16_t usSum, const uint8_t * pucNextData, size_t uxByteCount );
 555:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 556:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* Socket related private functions. */
 557:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 558:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*
 559:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * The caller must ensure that pxNetworkBuffer->xDataLength is the UDP packet 
 560:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * payload size (excluding packet headers) and that the packet in pucEthernetBuffer 
 561:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * is at least the size of UDPPacket_t. 
 562:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  */
 563:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** BaseType_t xProcessReceivedUDPPacket( NetworkBufferDescriptor_t *pxNetworkBuffer, uint16_t usPort )
 564:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 565:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*
 566:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * Initialize the socket list data structures for TCP and UDP. 
 567:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  */
 568:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** void vNetworkSocketsInit( void );
 569:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 570:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*
 571:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * Returns pdTRUE if the IP task has been created and is initialised.  Otherwise
 572:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * returns pdFALSE.
 573:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  */
 574:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** BaseType_t xIPIsNetworkTaskReady( void );
 575:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 576:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #if( ipconfigSOCKET_HAS_USER_WAKE_CALLBACK == 1 )
 577:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	struct xSOCKET;
 578:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	typedef void (*SocketWakeupCallback_t)( struct xSOCKET * pxSocket );
 579:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #endif
 580:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 581:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #if( ipconfigUSE_TCP == 1 )
 582:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 583:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	/*
 584:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	 * Actually a user thing, but because xBoundTCPSocketsList, let it do by the
 585:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	 * IP-task
 586:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	 */
 587:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#if( ipconfigHAS_PRINTF != 0 )
 588:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		void vTCPNetStat( void );
 589:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#endif
 590:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 591:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	/*
 592:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	 * At least one socket needs to check for timeouts
 593:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	 */
 594:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	TickType_t xTCPTimerCheck( BaseType_t xWillSleep );
 595:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 596:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	/* Every TCP socket has a buffer space just big enough to store
 597:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	the last TCP header received.
 598:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	As a reference of this field may be passed to DMA, force the
 599:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	alignment to 8 bytes. */
 600:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	typedef union
 601:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	{
 602:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		struct
 603:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		{
 604:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			/* Increase the alignment of this union by adding a 64-bit variable. */
 605:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			uint64_t ullAlignmentWord;
 606:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		} a;
 607:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		struct
 608:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		{
 609:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			/* The next field only serves to give 'ucLastPacket' a correct
 610:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			alignment of 8 + 2.  See comments in FreeRTOS_IP.h */
 611:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			uint8_t ucFillPacket[ ipconfigPACKET_FILLER_SIZE ];
 612:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			uint8_t ucLastPacket[ sizeof( TCPPacket_t ) ];
 613:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		} u;
 614:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	} LastTCPPacket_t;
 615:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 616:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	/*
 617:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	 * Note that the values of all short and long integers in these structs
 618:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	 * are being stored in the native-endian way
 619:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	 * Translation should take place when accessing any structure which defines
 620:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	 * network packets, such as IPHeader_t and TCPHeader_t
 621:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	 */
 622:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	typedef struct TCPSOCKET
 623:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	{
 624:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		uint32_t ulRemoteIP;		/* IP address of remote machine */
 625:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		uint16_t usRemotePort;		/* Port on remote machine */
 626:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		struct {
 627:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			/* Most compilers do like bit-flags */
 628:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			uint32_t
 629:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				bMssChange : 1,		/* This socket has seen a change in MSS */
 630:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				bPassAccept : 1,	/* when true, this socket may be returned in a call to accept() */
 631:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				bPassQueued : 1,	/* when true, this socket is an orphan until it gets connected
 632:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 									 * Why an orphan? Because it may not be returned in a accept() call until it
 633:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 									 * gets the state eESTABLISHED */
 634:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				bReuseSocket : 1,	/* When a listening socket gets a connection, do not create a new instance bu
 635:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				bCloseAfterSend : 1,/* As soon as the last byte has been transmitted, finalise the connection
 636:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 									 * Useful in e.g. FTP connections, where the last data bytes are sent along with the FIN f
 637:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				bUserShutdown : 1,	/* User requesting a graceful shutdown */
 638:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				bCloseRequested : 1,/* Request to finalise the connection */
 639:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				bLowWater : 1,		/* high-water level has been reached. Cleared as soon as 'rx-count < lo-water' 
 640:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				bWinChange : 1,		/* The value of bLowWater has changed, must send a window update */
 641:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				bSendKeepAlive : 1,	/* When this flag is true, a TCP keep-alive message must be send */
 642:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				bWaitKeepAlive : 1,	/* When this flag is true, a TCP keep-alive reply is expected */
 643:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				bConnPrepared : 1,	/* Connecting socket: Message has been prepared */
 644:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
 645:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 					bConnPassed : 1,	/* Connecting socket: Socket has been passed in a successful select()  */
 646:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				#endif /* ipconfigSUPPORT_SELECT_FUNCTION */
 647:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				bFinAccepted : 1,	/* This socket has received (or sent) a FIN and accepted it */
 648:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				bFinSent : 1,		/* We've sent out a FIN */
 649:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				bFinRecv : 1,		/* We've received a FIN from our peer */
 650:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				bFinAcked : 1,		/* Our FIN packet has been acked */
 651:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				bFinLast : 1,		/* The last ACK (after FIN and FIN+ACK) has been sent or will be sent by the pee
 652:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				bRxStopped : 1,		/* Application asked to temporarily stop reception */
 653:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				bMallocError : 1,	/* There was an error allocating a stream */
 654:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 				bWinScaling : 1;	/* A TCP-Window Scaling option was offered and accepted in the SYN phase. */
 655:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		} bits;
 656:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		uint32_t ulHighestRxAllowed;
 657:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 								/* The highest sequence number that we can receive at any moment */
 658:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		uint16_t usTimeout;		/* Time (in ticks) after which this socket needs attention */
 659:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		uint16_t usCurMSS;		/* Current Maximum Segment Size */
 660:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		uint16_t usInitMSS;		/* Initial maximum segment Size */
 661:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		uint16_t usChildCount;	/* In case of a listening socket: number of connections on this port numbe
 662:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		uint16_t usBacklog;		/* In case of a listening socket: maximum number of concurrent connections o
 663:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		uint8_t ucRepCount;		/* Send repeat count, for retransmissions
 664:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 								 * This counter is separate from the xmitCount in the
 665:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 								 * TCP win segments */
 666:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		uint8_t ucTCPState;		/* TCP state: see eTCP_STATE */
 667:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		struct xSOCKET *pxPeerSocket;	/* for server socket: child, for child socket: parent */
 668:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		#if( ipconfigTCP_KEEP_ALIVE == 1 )
 669:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			uint8_t ucKeepRepCount;
 670:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			TickType_t xLastAliveTime;
 671:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		#endif /* ipconfigTCP_KEEP_ALIVE */
 672:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		#if( ipconfigTCP_HANG_PROTECTION == 1 )
 673:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			TickType_t xLastActTime;
 674:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		#endif /* ipconfigTCP_HANG_PROTECTION */
 675:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		size_t uxLittleSpace;
 676:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		size_t uxEnoughSpace;
 677:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		size_t uxRxStreamSize;
 678:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		size_t uxTxStreamSize;
 679:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		StreamBuffer_t *rxStream;
 680:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		StreamBuffer_t *txStream;
 681:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		#if( ipconfigUSE_TCP_WIN == 1 )
 682:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			NetworkBufferDescriptor_t *pxAckMessage;
 683:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		#endif /* ipconfigUSE_TCP_WIN */
 684:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		/* Buffer space to store the last TCP header received. */
 685:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		LastTCPPacket_t xPacket;
 686:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		uint8_t tcpflags;		/* TCP flags */
 687:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		#if( ipconfigUSE_TCP_WIN != 0 )
 688:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			uint8_t ucMyWinScaleFactor;
 689:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			uint8_t ucPeerWinScaleFactor;
 690:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		#endif
 691:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		#if( ipconfigUSE_CALLBACKS == 1 )
 692:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			FOnTCPReceive_t pxHandleReceive;	/*
 693:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 										 		 * In case of a TCP socket:
 694:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 										 		 * typedef void (* FOnTCPReceive_t) (Socket_t xSocket, void *pData, size_t xLength );
 695:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 										 		 */
 696:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			FOnTCPSent_t pxHandleSent;
 697:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			FOnConnected_t pxHandleConnected;	/* Actually type: typedef void (* FOnConnected_t) (Socket_t xS
 698:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		#endif /* ipconfigUSE_CALLBACKS */
 699:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		uint32_t ulWindowSize;		/* Current Window size advertised by peer */
 700:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		size_t uxRxWinSize;	/* Fixed value: size of the TCP reception window */
 701:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		size_t uxTxWinSize;	/* Fixed value: size of the TCP transmit window */
 702:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 703:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		TCPWindow_t xTCPWindow;
 704:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	} IPTCPSocket_t;
 705:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 706:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #endif /* ipconfigUSE_TCP */
 707:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 708:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef struct UDPSOCKET
 709:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 710:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	List_t xWaitingPacketsList;	/* Incoming packets */
 711:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#if( ipconfigUDP_MAX_RX_PACKETS > 0 )
 712:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		UBaseType_t uxMaxPackets; /* Protection: limits the number of packets buffered per socket */
 713:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#endif /* ipconfigUDP_MAX_RX_PACKETS */
 714:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#if( ipconfigUSE_CALLBACKS == 1 )
 715:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		FOnUDPReceive_t pxHandleReceive;	/*
 716:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 											 * In case of a UDP socket:
 717:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 											 * typedef void (* FOnUDPReceive_t) (Socket_t xSocket, void *pData, size_t xLength, stru
 718:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 											 */
 719:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		FOnUDPSent_t pxHandleSent;
 720:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#endif /* ipconfigUSE_CALLBACKS */
 721:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** } IPUDPSocket_t;
 722:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 723:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef struct RAWSOCKET
 724:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 725:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	List_t xWaitingPacketsList;	/* Incoming packets */
 726:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#if( ipconfigUSE_CALLBACKS == 1 )
 727:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		FOnRAWReceive_t pxHandleReceive;	/*
 728:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 											 * In case of a RAW socket:
 729:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 											 * typedef void (* FOnRAWReceive_t) (Socket_t xSocket, void *pData, size_t xLength, stru
 730:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 											 */
 731:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		FOnRAWSent_t pxHandleSent;
 732:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#endif /* ipconfigUSE_CALLBACKS */
 733:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** } IPRAWSocket_t;
 734:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 735:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /* Formally typedef'd as eSocketEvent_t. */
 736:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** enum eSOCKET_EVENT {
 737:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eSOCKET_RECEIVE = 0x0001,
 738:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eSOCKET_SEND    = 0x0002,
 739:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eSOCKET_ACCEPT  = 0x0004,
 740:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eSOCKET_CONNECT = 0x0008,
 741:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eSOCKET_BOUND   = 0x0010,
 742:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eSOCKET_CLOSED	= 0x0020,
 743:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eSOCKET_INTR	= 0x0040,
 744:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	eSOCKET_ALL		= 0x007F,
 745:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** };
 746:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 747:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** typedef struct xSOCKET
 748:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 749:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	EventBits_t xEventBits;
 750:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	EventGroupHandle_t xEventGroup;
 751:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 752:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	ListItem_t xBoundSocketListItem; /* Used to reference the socket from a bound sockets list. */
 753:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	TickType_t xReceiveBlockTime; /* if recv[to] is called while no data is available, wait this amoun
 754:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	TickType_t xSendBlockTime; /* if send[to] is called while there is not enough space to send, wait 
 755:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 756:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t usLocalPort;		/* Local port on this machine */
 757:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint8_t ucSocketOptions;
 758:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint8_t ucProtocol; /* choice of FREERTOS_IPPROTO_UDP/TCP/RAW */
 759:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint8_t ucSocketType;/* TODO: Need to check padding */
 760:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint8_t __pad0;
 761:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	uint16_t __pad1;
 762:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#if( ipconfigSOCKET_HAS_USER_SEMAPHORE == 1 )
 763:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		SemaphoreHandle_t pxUserSemaphore;
 764:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#endif /* ipconfigSOCKET_HAS_USER_SEMAPHORE */
 765:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#if( ipconfigSOCKET_HAS_USER_WAKE_CALLBACK == 1 )
 766:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		SocketWakeupCallback_t pxUserWakeCallback;
 767:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#endif /* ipconfigSOCKET_HAS_USER_WAKE_CALLBACK */
 768:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 769:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
 770:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		struct xSOCKET_SET *pxSocketSet;
 771:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		/* User may indicate which bits are interesting for this socket. */
 772:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		EventBits_t xSelectBits;
 773:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		/* These bits indicate the events which have actually occurred.
 774:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		They are maintained by the IP-task */
 775:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		EventBits_t xSocketBits;
 776:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	#endif /* ipconfigSUPPORT_SELECT_FUNCTION */
 777:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	/* TCP/UDP specific fields: */
 778:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	/* Before accessing any member of this structure, it should be confirmed */
 779:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	/* that the protocol corresponds with the type of structure */
 780:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 781:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	union
 782:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	{
 783:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		IPRAWSocket_t xRAW;	/* w/ IPPROTO_UDP */
 784:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		IPUDPSocket_t xUDP;
 785:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		#if( ipconfigUSE_TCP == 1 )
 786:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			IPTCPSocket_t xTCP;
 787:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			/* Make sure that xTCP is 8-bytes aligned by
 788:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			declaring a 64-bit variable in the same union */
 789:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			uint64_t ullTCPAlignment;
 790:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 		#endif /* ipconfigUSE_TCP */
 791:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	} u;
 792:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** } FreeRTOS_Socket_t;
 793:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 794:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_PTR_FUNC_FOR_TYPE( FreeRTOS_Socket_t )
 795:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 796:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	return ( FreeRTOS_Socket_t *)pvArgument;
 797:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 798:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE ipDECL_CAST_CONST_PTR_FUNC_FOR_TYPE( FreeRTOS_Socket_t )
 799:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 800:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	return ( const FreeRTOS_Socket_t *) pvArgument;
 801:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 802:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 803:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #if( ipconfigUSE_TCP == 1 )
 804:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	/*
 805:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	 * Lookup a TCP socket, using a multiple matching: both port numbers and
 806:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	 * return IP address.
 807:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	 */
 808:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	FreeRTOS_Socket_t *pxTCPSocketLookup( uint32_t ulLocalIP, UBaseType_t uxLocalPort, uint32_t ulRemo
 809:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 810:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** #endif /* ipconfigUSE_TCP */
 811:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 812:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*
 813:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * Look up a local socket by finding a match with the local port.
 814:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  */
 815:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** FreeRTOS_Socket_t *pxUDPSocketLookup( UBaseType_t uxLocalPort );
 816:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 817:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*
 818:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * Called when the application has generated a UDP packet to send.
 819:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  */
 820:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** void vProcessGeneratedUDPPacket( NetworkBufferDescriptor_t * const pxNetworkBuffer );
 821:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 822:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*
 823:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * Called when the application has generated a UDP packet to send.
 824:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  */
 825:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** void vProcessGeneratedRAWPacket( NetworkBufferDescriptor_t * const pxNetworkBuffer );
 826:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 827:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*
 828:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * Calculate the upper-layer checksum
 829:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * Works both for UDP, ICMP and TCP packages
 830:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * bOut = true: checksum will be set in outgoing packets
 831:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * bOut = false: checksum will be calculated for incoming packets
 832:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  *     returning 0xffff means: checksum was correct
 833:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  */
 834:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** uint16_t usGenerateProtocolChecksum( const uint8_t * const pucEthernetBuffer, size_t uxBufferLength
 835:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 836:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*
 837:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * An Ethernet frame has been updated (maybe it was an ARP request or a PING
 838:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * request?) and is to be sent back to its source.
 839:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  */
 840:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** void vReturnEthernetFrame( NetworkBufferDescriptor_t * pxNetworkBuffer, BaseType_t xReleaseAfterSen
 841:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 842:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*
 843:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * The internal version of bind()
 844:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * If 'ulInternal' is true, it is called by the driver
 845:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * The TCP driver needs to bind a socket at the moment a listening socket
 846:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * creates a new connected socket
 847:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  */
 848:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** BaseType_t vSocketBind( FreeRTOS_Socket_t *pxSocket, struct freertos_sockaddr * pxBindAddress, size
 849:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 850:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*
 851:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * Internal function to add streaming data to a TCP socket. If ulIn == true,
 852:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * data will be added to the rxStream, otherwise to the tXStream.  Normally data
 853:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * will be written with ulOffset == 0, meaning: at the end of the FIFO.  When
 854:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * packet come in out-of-order, an offset will be used to put it in front and
 855:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * the head will not change yet.
 856:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  */
 857:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** int32_t lTCPAddRxdata(FreeRTOS_Socket_t *pxSocket, size_t uxOffset, const uint8_t *pcData, uint32_t
 858:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 859:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*
 860:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * Currently called for any important event.
 861:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  */
 862:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** void vSocketWakeUpUser( FreeRTOS_Socket_t *pxSocket );
 863:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 864:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** /*
 865:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * Some helping function, their meaning should be clear.
 866:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * Going by MISRA rules, these utility functions should not be defined
 867:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * if they are not being used anywhwere. But their use depends on the
 868:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  * application and hence these functions are defined unconditionally.
 869:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h ****  */
 870:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE uint32_t ulChar2u32 (const uint8_t *apChr);
 871:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE uint32_t ulChar2u32 (const uint8_t *apChr)
 872:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 873:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	return  ( ( ( uint32_t )apChr[0] ) << 24) |
 874:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			( ( ( uint32_t )apChr[1] ) << 16) |
 875:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			( ( ( uint32_t )apChr[2] ) << 8) |
 876:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 			( ( ( uint32_t )apChr[3] ) );
 877:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** }
 878:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 
 879:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE uint16_t usChar2u16 (const uint8_t *apChr);
 880:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** static portINLINE uint16_t usChar2u16 (const uint8_t *apChr)
 881:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** {
 882:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP_Private.h **** 	return ( uint16_t )
 665              	 .loc 3 882 0
 666 0164 2A78     	 ldrb r2,[r5]
 667 0166 6B78     	 ldrb r3,[r5,#1]
 668              	.LBE67:
 669              	.LBE66:
1288:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					{
 670              	 .loc 1 1288 0
 671 0168 43EA0223 	 orr r3,r3,r2,lsl#8
 672 016c 012B     	 cmp r3,#1
 673 016e 51D1     	 bne .L57
 674              	.LVL92:
1305:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					{
 675              	 .loc 1 1305 0
 676 0170 0D2C     	 cmp r4,#13
 677 0172 4FD9     	 bls .L57
 678              	.LVL93:
1313:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						{
 679              	 .loc 1 1313 0
 680 0174 2A89     	 ldrh r2,[r5,#8]
 681 0176 130A     	 lsrs r3,r2,#8
 682 0178 43EA0223 	 orr r3,r3,r2,lsl#8
 683 017c 1BB2     	 sxth r3,r3
 684 017e 042B     	 cmp r3,#4
 685 0180 3ED1     	 bne .L80
1317:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 											 ( const void * ) ( &( pucByte[ sizeof( DNSAnswerRecord_t ) ] ) ),
 686              	 .loc 1 1317 0
 687 0182 D5F80A00 	 ldr r0,[r5,#10]
 688              	.LVL94:
 689 0186 0B90     	 str r0,[sp,#44]
1324:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								{
 690              	 .loc 1 1324 0
 691 0188 B6F80090 	 ldrh r9,[r6]
 692 018c DDF82CB0 	 ldr fp,[sp,#44]
 693              	.LVL95:
 694              	.LBB68:
 695              	.LBB63:
 507:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
 696              	 .loc 1 507 0
 697 0190 FFF7FEFF 	 bl vTaskSuspendAll
 698              	.LVL96:
 509:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				 pxIterator != ( const ListItem_t * ) xEnd;
 699              	 .loc 1 509 0
 700 0194 DAF80C30 	 ldr r3,[r10,#12]
 701              	.LVL97:
 702 0198 4345     	 cmp r3,r8
 703 019a 5CD0     	 beq .L59
 513:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
 704              	 .loc 1 513 0
 705 019c 1A68     	 ldr r2,[r3]
 706 019e 9145     	 cmp r9,r2
 707 01a0 03D0     	 beq .L60
 708 01a2 1AE0     	 b .L61
 709              	.L63:
 710 01a4 1A68     	 ldr r2,[r3]
 711 01a6 9145     	 cmp r9,r2
 712 01a8 17D1     	 bne .L61
 713              	.L60:
 714              	.LBB62:
 515:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 715              	 .loc 1 515 0
 716 01aa D3F80C90 	 ldr r9,[r3,#12]
 717              	.LVL98:
 517:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					( void ) uxListRemove( &pxCallback->xListItem );
 718              	 .loc 1 517 0
 719 01ae D9F80430 	 ldr r3,[r9,#4]
 720              	.LVL99:
 721 01b2 07A8     	 add r0,sp,#28
 722              	.LVL100:
 723 01b4 D9F81010 	 ldr r1,[r9,#16]
 724 01b8 5A46     	 mov r2,fp
 725 01ba 9847     	 blx r3
 726              	.LVL101:
 518:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					vPortFree( pxCallback );
 727              	 .loc 1 518 0
 728 01bc 09F11400 	 add r0,r9,#20
 729 01c0 FFF7FEFF 	 bl uxListRemove
 730              	.LVL102:
 519:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 731              	 .loc 1 519 0
 732 01c4 4846     	 mov r0,r9
 733 01c6 FFF7FEFF 	 bl vPortFree
 734              	.LVL103:
 521:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					{
 735              	 .loc 1 521 0
 736 01ca DAF80030 	 ldr r3,[r10]
 737 01ce 002B     	 cmp r3,#0
 738 01d0 49D1     	 bne .L62
 524:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					}
 739              	 .loc 1 524 0
 740 01d2 0020     	 movs r0,#0
 741 01d4 FFF7FEFF 	 bl vIPSetDnsTimerEnableState
 742              	.LVL104:
 743 01d8 45E0     	 b .L62
 744              	.LVL105:
 745              	.L61:
 746              	.LBE62:
 511:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
 747              	 .loc 1 511 0
 748 01da 5B68     	 ldr r3,[r3,#4]
 749              	.LVL106:
 509:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				 pxIterator != ( const ListItem_t * ) xEnd;
 750              	 .loc 1 509 0
 751 01dc 4345     	 cmp r3,r8
 752 01de E1D1     	 bne .L63
 753 01e0 39E0     	 b .L59
 754              	.LVL107:
 755              	.L69:
 756              	.LBE63:
 757              	.LBE68:
 758              	.LBB69:
1340:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 									usNumARecordsStored++;    /* Track # of A records stored */
 759              	 .loc 1 1340 0
 760 01e2 07A8     	 add r0,sp,#28
 761              	.LVL108:
 762 01e4 0BA9     	 add r1,sp,#44
 763 01e6 6A68     	 ldr r2,[r5,#4]
 764 01e8 0023     	 movs r3,#0
 765 01ea FFF7FEFF 	 bl prvProcessDNSCache
 766              	.LVL109:
1341:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								}
 767              	 .loc 1 1341 0
 768 01ee 4FF00109 	 mov r9,#1
 769              	.LVL110:
 770              	.L70:
1344:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								/* Show what has happened. */
 771              	 .loc 1 1344 0
 772 01f2 0220     	 movs r0,#2
 773 01f4 0BA9     	 add r1,sp,#44
 774 01f6 03AA     	 add r2,sp,#12
 775 01f8 1023     	 movs r3,#16
 776 01fa FFF7FEFF 	 bl FreeRTOS_inet_ntop
 777              	.LVL111:
 778 01fe 01E0     	 b .L58
 779              	.LVL112:
 780              	.L80:
 781              	.LBE69:
 782 0200 4FF00009 	 mov r9,#0
 783              	.LVL113:
 784              	.L58:
1355:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						uxSourceBytesRemaining -= ( sizeof( DNSAnswerRecord_t ) + sizeof( uint32_t ) );
 785              	 .loc 1 1355 0
 786 0204 0E35     	 adds r5,r5,#14
 787              	.LVL114:
1356:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					}
 788              	 .loc 1 1356 0
 789 0206 0E3C     	 subs r4,r4,#14
 790              	.LVL115:
 791              	.LBE73:
1255:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
 792              	 .loc 1 1255 0
 793 0208 0137     	 adds r7,r7,#1
 794              	.LVL116:
 795 020a BFB2     	 uxth r7,r7
 796              	.LVL117:
 797 020c F388     	 ldrh r3,[r6,#6]
 798 020e BB42     	 cmp r3,r7
 799 0210 93D8     	 bhi .L64
 800 0212 2DE0     	 b .L56
 801              	.LVL118:
 802              	.L57:
 803              	.LBB74:
1358:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					{
 804              	 .loc 1 1358 0
 805 0214 092C     	 cmp r4,#9
 806 0216 2FD9     	 bls .L65
 807              	.LVL119:
1366:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 808              	 .loc 1 1366 0
 809 0218 0A3C     	 subs r4,r4,#10
 810              	.LVL120:
1369:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 811              	 .loc 1 1369 0
 812 021a 2A89     	 ldrh r2,[r5,#8]
 813              	.LVL121:
 814 021c 130A     	 lsrs r3,r2,#8
 815 021e 43EA0223 	 orr r3,r3,r2,lsl#8
1372:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						{
 816              	 .loc 1 1372 0
 817 0222 9BB2     	 uxth r3,r3
 818 0224 9C42     	 cmp r4,r3
 819 0226 04D3     	 bcc .L68
 820 0228 03F10A02 	 add r2,r3,#10
1374:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 							uxSourceBytesRemaining -= usDataLength;
 821              	 .loc 1 1374 0
 822 022c 1544     	 add r5,r5,r2
 823              	.LVL122:
1375:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						}
 824              	 .loc 1 1375 0
 825 022e E41A     	 subs r4,r4,r3
 826              	.LVL123:
 827 0230 22E0     	 b .L65
 828              	.LVL124:
 829              	.L68:
 830              	.LBE74:
 831              	.LBE58:
 832              	.LBE51:
1479:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
 833              	 .loc 1 1479 0
 834 0232 0023     	 movs r3,#0
 835 0234 0B93     	 str r3,[sp,#44]
 836 0236 26E0     	 b .L66
 837              	.LVL125:
 838              	.L71:
1484:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
 839              	 .loc 1 1484 0
 840 0238 0023     	 movs r3,#0
 841 023a 0B93     	 str r3,[sp,#44]
 842 023c 23E0     	 b .L66
 843              	.LVL126:
 844              	.L38:
 845              	.LBB78:
1248:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 846              	 .loc 1 1248 0
 847 023e F288     	 ldrh r2,[r6,#6]
 848 0240 130A     	 lsrs r3,r2,#8
 849 0242 43EA0223 	 orr r3,r3,r2,lsl#8
 850 0246 9BB2     	 uxth r3,r3
 851 0248 F380     	 strh r3,[r6,#6]
1250:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
 852              	 .loc 1 1250 0
 853 024a 7288     	 ldrh r2,[r6,#2]
 854 024c 02F47862 	 and r2,r2,#3968
 855 0250 802A     	 cmp r2,#128
 856 0252 0DD1     	 bne .L56
 857 0254 6FE7     	 b .L67
 858              	.LVL127:
 859              	.L59:
 860              	.LBB76:
 861              	.LBB75:
 862              	.LBB70:
 863              	.LBB64:
 532:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		return xResult;
 864              	 .loc 1 532 0
 865 0256 FFF7FEFF 	 bl xTaskResumeAll
 866              	.LVL128:
 867              	.LBE64:
 868              	.LBE70:
 869              	.LBB71:
1338:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								{
 870              	 .loc 1 1338 0
 871 025a 019B     	 ldr r3,[sp,#4]
 872 025c 002B     	 cmp r3,#0
 873 025e C0D1     	 bne .L69
 874 0260 4FF00009 	 mov r9,#0
 875              	.LVL129:
 876 0264 C5E7     	 b .L70
 877              	.LVL130:
 878              	.L62:
 879              	.LBE71:
 880              	.LBB72:
 881              	.LBB65:
 532:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		return xResult;
 882              	 .loc 1 532 0
 883 0266 FFF7FEFF 	 bl xTaskResumeAll
 884              	.LVL131:
 885              	.LBE65:
 886              	.LBE72:
1328:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 								}
 887              	 .loc 1 1328 0
 888 026a 0123     	 movs r3,#1
 889 026c 0193     	 str r3,[sp,#4]
 890 026e B8E7     	 b .L69
 891              	.LVL132:
 892              	.L56:
 893              	.LBE75:
 894              	.LBE76:
 895              	.LBE78:
1481:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
 896              	 .loc 1 1481 0
 897 0270 009B     	 ldr r3,[sp]
 898 0272 002B     	 cmp r3,#0
 899 0274 E0D0     	 beq .L71
 900 0276 06E0     	 b .L66
 901              	.LVL133:
 902              	.L65:
 903              	.LBB79:
 904              	.LBB77:
1255:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
 905              	 .loc 1 1255 0
 906 0278 0137     	 adds r7,r7,#1
 907              	.LVL134:
 908 027a BFB2     	 uxth r7,r7
 909              	.LVL135:
 910 027c F388     	 ldrh r3,[r6,#6]
 911 027e BB42     	 cmp r3,r7
 912 0280 3FF666AF 	 bhi .L84
 913 0284 F4E7     	 b .L56
 914              	.LVL136:
 915              	.L66:
 916              	.LBE77:
 917              	.LBE79:
1495:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** }
 918              	 .loc 1 1495 0
 919 0286 0B98     	 ldr r0,[sp,#44]
1496:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /*-----------------------------------------------------------*/
 920              	 .loc 1 1496 0
 921 0288 0DB0     	 add sp,sp,#52
 922              	.LCFI5:
 923              	 .cfi_def_cfa_offset 36
 924              	 
 925 028a BDE8F08F 	 pop {r4,r5,r6,r7,r8,r9,r10,fp,pc}
 926              	.L89:
 927 028e 00BF     	 .align 2
 928              	.L88:
 929 0290 00000000 	 .word .LANCHOR2
 930              	 .cfi_endproc
 931              	.LFE70:
 933              	 .section .text.FreeRTOS_dnsclear,"ax",%progbits
 934              	 .align 2
 935              	 .global FreeRTOS_dnsclear
 936              	 .thumb
 937              	 .thumb_func
 939              	FreeRTOS_dnsclear:
 940              	.LFB50:
 227:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		( void ) memset( xDNSCache, 0x0, sizeof( xDNSCache ) );
 941              	 .loc 1 227 0
 942              	 .cfi_startproc
 943              	 
 944              	 
 945 0000 08B5     	 push {r3,lr}
 946              	.LCFI6:
 947              	 .cfi_def_cfa_offset 8
 948              	 .cfi_offset 3,-8
 949              	 .cfi_offset 14,-4
 228:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
 950              	 .loc 1 228 0
 951 0002 0348     	 ldr r0,.L92
 952 0004 0021     	 movs r1,#0
 953 0006 7022     	 movs r2,#112
 954 0008 FFF7FEFF 	 bl memset
 955              	.LVL137:
 956 000c 08BD     	 pop {r3,pc}
 957              	.L93:
 958 000e 00BF     	 .align 2
 959              	.L92:
 960 0010 00000000 	 .word .LANCHOR0
 961              	 .cfi_endproc
 962              	.LFE50:
 964              	 .section .text.FreeRTOS_dnslookup,"ax",%progbits
 965              	 .align 2
 966              	 .global FreeRTOS_dnslookup
 967              	 .thumb
 968              	 .thumb_func
 970              	FreeRTOS_dnslookup:
 971              	.LFB55:
 365:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	uint32_t ulIPAddress = 0UL;
 972              	 .loc 1 365 0
 973              	 .cfi_startproc
 974              	 
 975              	 
 976              	.LVL138:
 977 0000 00B5     	 push {lr}
 978              	.LCFI7:
 979              	 .cfi_def_cfa_offset 4
 980              	 .cfi_offset 14,-4
 981 0002 83B0     	 sub sp,sp,#12
 982              	.LCFI8:
 983              	 .cfi_def_cfa_offset 16
 366:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 984              	 .loc 1 366 0
 985 0004 0022     	 movs r2,#0
 986 0006 02A9     	 add r1,sp,#8
 987 0008 41F8042D 	 str r2,[r1,#-4]!
 368:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		return ulIPAddress;
 988              	 .loc 1 368 0
 989 000c 0123     	 movs r3,#1
 990 000e FFF7FEFF 	 bl prvProcessDNSCache
 991              	.LVL139:
 370:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #endif /* ipconfigUSE_DNS_CACHE == 1 */
 992              	 .loc 1 370 0
 993 0012 0198     	 ldr r0,[sp,#4]
 994 0014 03B0     	 add sp,sp,#12
 995              	.LCFI9:
 996              	 .cfi_def_cfa_offset 4
 997              	 
 998 0016 5DF804FB 	 ldr pc,[sp],#4
 999              	 .cfi_endproc
 1000              	.LFE55:
 1002 001a 00BF     	 .section .text.vDNSInitialise,"ax",%progbits
 1003              	 .align 2
 1004              	 .global vDNSInitialise
 1005              	 .thumb
 1006              	 .thumb_func
 1008              	vDNSInitialise:
 1009              	.LFB58:
 402:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		vListInitialise( &xCallbackList );
 1010              	 .loc 1 402 0
 1011              	 .cfi_startproc
 1012              	 
 1013              	 
 1014 0000 08B5     	 push {r3,lr}
 1015              	.LCFI10:
 1016              	 .cfi_def_cfa_offset 8
 1017              	 .cfi_offset 3,-8
 1018              	 .cfi_offset 14,-4
 403:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
 1019              	 .loc 1 403 0
 1020 0002 0248     	 ldr r0,.L98
 1021 0004 FFF7FEFF 	 bl vListInitialise
 1022              	.LVL140:
 1023 0008 08BD     	 pop {r3,pc}
 1024              	.L99:
 1025 000a 00BF     	 .align 2
 1026              	.L98:
 1027 000c 00000000 	 .word .LANCHOR2
 1028              	 .cfi_endproc
 1029              	.LFE58:
 1031              	 .section .text.vDNSCheckCallBack,"ax",%progbits
 1032              	 .align 2
 1033              	 .global vDNSCheckCallBack
 1034              	 .thumb
 1035              	 .thumb_func
 1037              	vDNSCheckCallBack:
 1038              	.LFB59:
 413:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	const ListItem_t * pxIterator;
 1039              	 .loc 1 413 0
 1040              	 .cfi_startproc
 1041              	 
 1042              	 
 1043              	.LVL141:
 1044 0000 2DE9F041 	 push {r4,r5,r6,r7,r8,lr}
 1045              	.LCFI11:
 1046              	 .cfi_def_cfa_offset 24
 1047              	 .cfi_offset 4,-24
 1048              	 .cfi_offset 5,-20
 1049              	 .cfi_offset 6,-16
 1050              	 .cfi_offset 7,-12
 1051              	 .cfi_offset 8,-8
 1052              	 .cfi_offset 14,-4
 1053 0004 0646     	 mov r6,r0
 1054              	.LVL142:
 417:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
 1055              	 .loc 1 417 0
 1056 0006 FFF7FEFF 	 bl vTaskSuspendAll
 1057              	.LVL143:
 419:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				 pxIterator != xEnd;
 1058              	 .loc 1 419 0
 1059 000a 1A4B     	 ldr r3,.L109
 1060 000c DD68     	 ldr r5,[r3,#12]
 1061              	.LVL144:
 1062 000e 0833     	 adds r3,r3,#8
 1063 0010 9D42     	 cmp r5,r3
 1064 0012 25D0     	 beq .L101
 1065              	.LBB80:
 433:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					( void ) uxListRemove( &( pxCallback->xListItem ) );
 1066              	 .loc 1 433 0
 1067 0014 4FF00008 	 mov r8,#0
 1068              	.LBE80:
 419:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				 pxIterator != xEnd;
 1069              	 .loc 1 419 0
 1070 0018 1F46     	 mov r7,r3
 1071              	.L106:
 1072              	.LBB81:
 423:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				/* Move to the next item because we might remove this item */
 1073              	 .loc 1 423 0
 1074 001a EC68     	 ldr r4,[r5,#12]
 1075              	.LVL145:
 425:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				if( ( pvSearchID != NULL ) && ( pvSearchID == pxCallback->pvSearchID ) )
 1076              	 .loc 1 425 0
 1077 001c 6D68     	 ldr r5,[r5,#4]
 1078              	.LVL146:
 426:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
 1079              	 .loc 1 426 0
 1080 001e 56B1     	 cbz r6,.L102
 426:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
 1081              	 .loc 1 426 0 is_stmt 0 discriminator 1
 1082 0020 2369     	 ldr r3,[r4,#16]
 1083 0022 B342     	 cmp r3,r6
 1084 0024 07D1     	 bne .L102
 428:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					vPortFree( pxCallback );
 1085              	 .loc 1 428 0 is_stmt 1
 1086 0026 04F11400 	 add r0,r4,#20
 1087 002a FFF7FEFF 	 bl uxListRemove
 1088              	.LVL147:
 429:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
 1089              	 .loc 1 429 0
 1090 002e 2046     	 mov r0,r4
 1091 0030 FFF7FEFF 	 bl vPortFree
 1092              	.LVL148:
 1093 0034 12E0     	 b .L103
 1094              	.L102:
 431:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
 1095              	 .loc 1 431 0
 1096 0036 04F10800 	 add r0,r4,#8
 1097 003a 2146     	 mov r1,r4
 1098 003c FFF7FEFF 	 bl xTaskCheckForTimeOut
 1099              	.LVL149:
 1100 0040 60B1     	 cbz r0,.L103
 433:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					( void ) uxListRemove( &( pxCallback->xListItem ) );
 1101              	 .loc 1 433 0
 1102 0042 6368     	 ldr r3,[r4,#4]
 1103 0044 04F12800 	 add r0,r4,#40
 1104 0048 2169     	 ldr r1,[r4,#16]
 1105 004a 4246     	 mov r2,r8
 1106 004c 9847     	 blx r3
 1107              	.LVL150:
 434:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					vPortFree( pxCallback );
 1108              	 .loc 1 434 0
 1109 004e 04F11400 	 add r0,r4,#20
 1110 0052 FFF7FEFF 	 bl uxListRemove
 1111              	.LVL151:
 435:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
 1112              	 .loc 1 435 0
 1113 0056 2046     	 mov r0,r4
 1114 0058 FFF7FEFF 	 bl vPortFree
 1115              	.LVL152:
 1116              	.L103:
 1117              	.LBE81:
 419:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				 pxIterator != xEnd;
 1118              	 .loc 1 419 0 discriminator 1
 1119 005c BD42     	 cmp r5,r7
 1120 005e DCD1     	 bne .L106
 1121              	.LVL153:
 1122              	.L101:
 443:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 1123              	 .loc 1 443 0
 1124 0060 FFF7FEFF 	 bl xTaskResumeAll
 1125              	.LVL154:
 445:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
 1126              	 .loc 1 445 0
 1127 0064 034B     	 ldr r3,.L109
 1128 0066 1B68     	 ldr r3,[r3]
 1129 0068 13B9     	 cbnz r3,.L100
 447:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		}
 1130              	 .loc 1 447 0
 1131 006a 0020     	 movs r0,#0
 1132 006c FFF7FEFF 	 bl vIPSetDnsTimerEnableState
 1133              	.LVL155:
 1134              	.L100:
 1135 0070 BDE8F081 	 pop {r4,r5,r6,r7,r8,pc}
 1136              	.LVL156:
 1137              	.L110:
 1138              	 .align 2
 1139              	.L109:
 1140 0074 00000000 	 .word .LANCHOR2
 1141              	 .cfi_endproc
 1142              	.LFE59:
 1144              	 .section .text.FreeRTOS_gethostbyname_cancel,"ax",%progbits
 1145              	 .align 2
 1146              	 .global FreeRTOS_gethostbyname_cancel
 1147              	 .thumb
 1148              	 .thumb_func
 1150              	FreeRTOS_gethostbyname_cancel:
 1151              	.LFB60:
 453:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		/* _HT_ Should better become a new API call to have the IP-task remove the callback */
 1152              	 .loc 1 453 0
 1153              	 .cfi_startproc
 1154              	 
 1155              	 
 1156              	.LVL157:
 1157 0000 08B5     	 push {r3,lr}
 1158              	.LCFI12:
 1159              	 .cfi_def_cfa_offset 8
 1160              	 .cfi_offset 3,-8
 1161              	 .cfi_offset 14,-4
 455:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
 1162              	 .loc 1 455 0
 1163 0002 FFF7FEFF 	 bl vDNSCheckCallBack
 1164              	.LVL158:
 1165 0006 08BD     	 pop {r3,pc}
 1166              	 .cfi_endproc
 1167              	.LFE60:
 1169              	 .section .text.FreeRTOS_gethostbyname_a,"ax",%progbits
 1170              	 .align 2
 1171              	 .global FreeRTOS_gethostbyname_a
 1172              	 .thumb
 1173              	 .thumb_func
 1175              	FreeRTOS_gethostbyname_a:
 1176              	.LFB63:
 549:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		return prvPrepareLookup( pcHostName, pCallback, pvSearchID, uxTimeout );
 1177              	 .loc 1 549 0
 1178              	 .cfi_startproc
 1179              	 
 1180              	 
 1181              	.LVL159:
 1182 0000 2DE9F04F 	 push {r4,r5,r6,r7,r8,r9,r10,fp,lr}
 1183              	.LCFI13:
 1184              	 .cfi_def_cfa_offset 36
 1185              	 .cfi_offset 4,-36
 1186              	 .cfi_offset 5,-32
 1187              	 .cfi_offset 6,-28
 1188              	 .cfi_offset 7,-24
 1189              	 .cfi_offset 8,-20
 1190              	 .cfi_offset 9,-16
 1191              	 .cfi_offset 10,-12
 1192              	 .cfi_offset 11,-8
 1193              	 .cfi_offset 14,-4
 1194 0004 8DB0     	 sub sp,sp,#52
 1195              	.LCFI14:
 1196              	 .cfi_def_cfa_offset 88
 1197              	.LVL160:
 1198              	.LBB100:
 1199              	.LBB101:
 575:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
 1200              	 .loc 1 575 0
 1201 0006 0028     	 cmp r0,#0
 1202 0008 00F00E81 	 beq .L135
 1203 000c 0446     	 mov r4,r0
 1204 000e 9846     	 mov r8,r3
 1205 0010 1746     	 mov r7,r2
 1206 0012 0E46     	 mov r6,r1
 1207              	.LBB102:
 577:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 1208              	 .loc 1 577 0
 1209 0014 FFF7FEFF 	 bl strlen
 1210              	.LVL161:
 1211 0018 0130     	 adds r0,r0,#1
 1212              	.LVL162:
 1213              	.LBE102:
 592:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#else
 1214              	 .loc 1 592 0
 1215 001a 1028     	 cmp r0,#16
 1216 001c 00F20681 	 bhi .L136
 601:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		}
 1217              	 .loc 1 601 0
 1218 0020 2046     	 mov r0,r4
 1219              	.LVL163:
 1220 0022 FFF7FEFF 	 bl FreeRTOS_inet_addr
 1221              	.LVL164:
 609:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
 1222              	 .loc 1 609 0
 1223 0026 0546     	 mov r5,r0
 1224 0028 68B9     	 cbnz r0,.L115
 611:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 1225              	 .loc 1 611 0
 1226 002a 2046     	 mov r0,r4
 1227              	.LVL165:
 1228 002c FFF7FEFF 	 bl FreeRTOS_dnslookup
 1229              	.LVL166:
 626:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
 1230              	 .loc 1 626 0
 1231 0030 0546     	 mov r5,r0
 1232 0032 0028     	 cmp r0,#0
 1233 0034 40F0FC80 	 bne .L116
 1234              	.LBB103:
 630:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			/* DNS identifiers are 16-bit. */
 1235              	 .loc 1 630 0
 1236 0038 0AA8     	 add r0,sp,#40
 1237              	.LVL167:
 1238 003a FFF7FEFF 	 bl xApplicationGetRandomNumber
 1239              	.LVL168:
 632:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		}
 1240              	 .loc 1 632 0
 1241 003e BDF828A0 	 ldrh r10,[sp,#40]
 1242              	.LVL169:
 1243              	.LBE103:
 637:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
 1244              	 .loc 1 637 0
 1245 0042 16B9     	 cbnz r6,.L117
 1246 0044 FAE0     	 b .L143
 1247              	.LVL170:
 1248              	.L115:
 1249 0046 86BB     	 cbnz r6,.L119
 1250 0048 FBE0     	 b .L139
 1251              	.LVL171:
 1252              	.L117:
 642:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					{
 1253              	 .loc 1 642 0
 1254 004a 0028     	 cmp r0,#0
 1255 004c 00F0F980 	 beq .L139
 1256              	.LVL172:
 1257              	.LBB104:
 1258              	.LBB105:
 467:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	DNSCallback_t *pxCallback = ipCAST_PTR_TO_TYPE_PTR( DNSCallback_t, pvPortMalloc( sizeof( *pxCallba
 1259              	 .loc 1 467 0
 1260 0050 2046     	 mov r0,r4
 1261              	.LVL173:
 1262 0052 FFF7FEFF 	 bl strlen
 1263              	.LVL174:
 468:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 1264              	 .loc 1 468 0
 1265 0056 2C30     	 adds r0,r0,#44
 1266              	.LVL175:
 1267 0058 FFF7FEFF 	 bl pvPortMalloc
 1268              	.LVL176:
 473:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
 1269              	 .loc 1 473 0
 1270 005c 0546     	 mov r5,r0
 1271              	.LVL177:
 1272 005e 0028     	 cmp r0,#0
 1273 0060 00F0EA80 	 beq .L121
 475:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
 1274              	 .loc 1 475 0
 1275 0064 794B     	 ldr r3,.L146
 1276 0066 1B68     	 ldr r3,[r3]
 1277 0068 3BB9     	 cbnz r3,.L122
 1278              	.LVL178:
 478:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			}
 1279              	 .loc 1 478 0
 1280 006a 4046     	 mov r0,r8
 1281              	.LVL179:
 1282 006c B8F57A7F 	 cmp r8,#1000
 1283 0070 28BF     	 it cs
 1284 0072 4FF47A70 	 movcs r0,#1000
 1285 0076 FFF7FEFF 	 bl vIPReloadDNSTimer
 1286              	.LVL180:
 1287              	.L122:
 481:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			pxCallback->pCallbackFunction = pCallbackFunction;
 1288              	 .loc 1 481 0
 1289 007a 05F12800 	 add r0,r5,#40
 1290 007e 2146     	 mov r1,r4
 1291 0080 FFF7FEFF 	 bl strcpy
 1292              	.LVL181:
 482:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			pxCallback->pvSearchID = pvSearchID;
 1293              	 .loc 1 482 0
 1294 0084 6E60     	 str r6,[r5,#4]
 483:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			pxCallback->uxRemaningTime = uxTimeout;
 1295              	 .loc 1 483 0
 1296 0086 2F61     	 str r7,[r5,#16]
 484:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			vTaskSetTimeOutState( &pxCallback->uxTimeoutState );
 1297              	 .loc 1 484 0
 1298 0088 2846     	 mov r0,r5
 1299 008a 40F8088B 	 str r8,[r0],#8
 485:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			listSET_LIST_ITEM_OWNER( &( pxCallback->xListItem ), ( void *) pxCallback );
 1300              	 .loc 1 485 0
 1301 008e FFF7FEFF 	 bl vTaskSetTimeOutState
 1302              	.LVL182:
 486:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			listSET_LIST_ITEM_VALUE( &( pxCallback->xListItem ), uxIdentifier );
 1303              	 .loc 1 486 0
 1304 0092 2D62     	 str r5,[r5,#32]
 487:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			vTaskSuspendAll();
 1305              	 .loc 1 487 0
 1306 0094 45F814AF 	 str r10,[r5,#20]!
 1307              	.LVL183:
 488:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
 1308              	 .loc 1 488 0
 1309 0098 FFF7FEFF 	 bl vTaskSuspendAll
 1310              	.LVL184:
 490:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			}
 1311              	 .loc 1 490 0
 1312 009c 6B48     	 ldr r0,.L146
 1313 009e 2946     	 mov r1,r5
 1314 00a0 FFF7FEFF 	 bl vListInsertEnd
 1315              	.LVL185:
 492:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		}
 1316              	 .loc 1 492 0
 1317 00a4 FFF7FEFF 	 bl xTaskResumeAll
 1318              	.LVL186:
 1319 00a8 C6E0     	 b .L121
 1320              	.LVL187:
 1321              	.L119:
 1322              	.LBE105:
 1323              	.LBE104:
 651:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
 1324              	 .loc 1 651 0
 1325 00aa 2046     	 mov r0,r4
 1326              	.LVL188:
 1327 00ac 3946     	 mov r1,r7
 1328 00ae 2A46     	 mov r2,r5
 1329 00b0 B047     	 blx r6
 1330              	.LVL189:
 1331 00b2 C6E0     	 b .L139
 1332              	.LVL190:
 1333              	.L138:
 657:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
 1334              	 .loc 1 657 0
 1335 00b4 41F28833 	 movw r3,#5000
 1336              	.LVL191:
 1337              	.L134:
 1338 00b8 0593     	 str r3,[sp,#20]
 1339              	.LVL192:
 1340              	.LBB106:
 1341              	.LBB107:
 672:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** uint32_t ulAddressLength = sizeof( struct freertos_sockaddr );
 1342              	 .loc 1 672 0
 1343 00ba 0023     	 movs r3,#0
 1344              	.LVL193:
 1345 00bc 0693     	 str r3,[sp,#24]
 673:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** BaseType_t xAttempt;
 1346              	 .loc 1 673 0
 1347 00be 0823     	 movs r3,#8
 1348 00c0 0793     	 str r3,[sp,#28]
 677:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 1349              	 .loc 1 677 0
 1350 00c2 4FF4FA73 	 mov r3,#500
 1351 00c6 0893     	 str r3,[sp,#32]
 702:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 1352              	 .loc 1 702 0
 1353 00c8 2046     	 mov r0,r4
 1354 00ca FFF7FEFF 	 bl strlen
 1355              	.LVL194:
 1356 00ce 0746     	 mov r7,r0
 1357              	.LVL195:
 1358              	.LBB108:
 1359              	.LBB109:
1658:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	if( prvSocketValid( xSocket ) != pdTRUE )
 1360              	 .loc 1 1658 0
 1361 00d0 0220     	 movs r0,#2
 1362              	.LVL196:
 1363 00d2 0146     	 mov r1,r0
 1364 00d4 1122     	 movs r2,#17
 1365 00d6 FFF7FEFF 	 bl FreeRTOS_socket
 1366              	.LVL197:
 1367 00da 0646     	 mov r6,r0
 1368              	.LVL198:
 1369              	.LBB110:
 1370              	.LBB111:
 1371              	 .file 4 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include/FreeRTOS_Sockets.h"
   1:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** /*
   2:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h ****  * FreeRTOS+TCP V2.2.2
   3:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h ****  * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h ****  *
   5:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h ****  * this software and associated documentation files (the "Software"), to deal in
   7:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h ****  * the Software without restriction, including without limitation the rights to
   8:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h ****  * subject to the following conditions:
  11:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h ****  *
  12:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h ****  * The above copyright notice and this permission notice shall be included in all
  13:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h ****  * copies or substantial portions of the Software.
  14:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h ****  *
  15:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h ****  *
  22:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h ****  * http://aws.amazon.com/freertos
  23:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h ****  * http://www.FreeRTOS.org
  24:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h ****  */
  25:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
  26:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #ifndef FREERTOS_SOCKETS_H
  27:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_SOCKETS_H
  28:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
  29:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #ifdef __cplusplus
  30:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** extern "C" {
  31:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #endif
  32:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
  33:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** /* Standard includes. */
  34:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #include <string.h>
  35:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
  36:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** /* Application level configuration options. */
  37:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #include "FreeRTOSIPConfig.h"
  38:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
  39:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #ifndef FREERTOS_IP_CONFIG_H
  40:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 	#error FreeRTOSIPConfig.h has not been included yet
  41:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #endif
  42:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
  43:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** /* Event bit definitions are required by the select functions. */
  44:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #include "event_groups.h"
  45:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
  46:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #ifndef INC_FREERTOS_H
  47:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 	#error FreeRTOS.h must be included before FreeRTOS_Sockets.h.
  48:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #endif
  49:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
  50:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #ifndef INC_TASK_H
  51:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 	#ifndef TASK_H /* For compatibility with older FreeRTOS versions. */
  52:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 		#error The FreeRTOS header file task.h must be included before FreeRTOS_Sockets.h.
  53:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 	#endif
  54:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #endif
  55:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
  56:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** /* Assigned to an Socket_t variable when the socket is not valid, probably
  57:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** because it could not be created. */
  58:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_INVALID_SOCKET	( ( Socket_t ) ~0U )
  59:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
  60:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** /* API function error values.  As errno is supported, the FreeRTOS sockets
  61:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** functions return error codes rather than just a pass or fail indication. */
  62:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** /* HT: Extended the number of error codes, gave them positive values and if possible
  63:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** the corresponding found in errno.h
  64:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** In case of an error, API's will still return negative numbers, e.g.
  65:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h ****   return -pdFREERTOS_ERRNO_EWOULDBLOCK;
  66:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** in case an operation would block */
  67:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
  68:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** /* The following defines are obsolete, please use -pdFREERTOS_ERRNO_Exxx */
  69:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
  70:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_SOCKET_ERROR	( -1 )
  71:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_EWOULDBLOCK	( - pdFREERTOS_ERRNO_EWOULDBLOCK )
  72:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_EINVAL			( - pdFREERTOS_ERRNO_EINVAL )
  73:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_EADDRNOTAVAIL	( - pdFREERTOS_ERRNO_EADDRNOTAVAIL )
  74:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_EADDRINUSE		( - pdFREERTOS_ERRNO_EADDRINUSE )
  75:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_ENOBUFS		( - pdFREERTOS_ERRNO_ENOBUFS )
  76:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_ENOPROTOOPT	( - pdFREERTOS_ERRNO_ENOPROTOOPT )
  77:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_ECLOSED		( - pdFREERTOS_ERRNO_ENOTCONN )
  78:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
  79:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** /* Values for the parameters to FreeRTOS_socket(), inline with the Berkeley
  80:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** standard.  See the documentation of FreeRTOS_socket() for more information. */
  81:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_AF_INET		( 2 )
  82:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_AF_INET6		( 10 )
  83:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
  84:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_SOCK_DGRAM		( 2 )
  85:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_IPPROTO_UDP	( 17 )
  86:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
  87:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_SOCK_STREAM	( 1 )
  88:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_IPPROTO_TCP	( 6 )
  89:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
  90:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_SOCK_RAW		( 3 )
  91:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_IPPROTO_RAW	( 255 )
  92:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
  93:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** /* Values for the parameters to FreeRTOS_socket(), inline with the Berkeley
  94:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** standard. */
  95:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_AF_CAN			( 29 )
  96:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FreeRTOS_PF_CAN			( FreeRTOS_AF_CAN )
  97:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
  98:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** /* Particular protocols of the protocol family PF_CAN */
  99:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_CAN_RAW		( 4 )/* TODO: CAN RAW sockets, Check the number */
 100:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FreeRTOS_SOL_CAN_RAW	( 103 )
 101:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FreeRTOS_CAN_ISOTP		( 6 )/* ISO 15765-2 Transport Protocol */
 102:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
 103:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** /* IP packet of type "Any local network"
 104:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h ****  * can be used instead of TCP for testing with sockets in raw mode
 105:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h ****  */
 106:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_IPPROTO_USR_LAN  ( 63 )
 107:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
 108:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** /* A bit value that can be passed into the FreeRTOS_sendto() function as part of
 109:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** the flags parameter.  Setting the FREERTOS_ZERO_COPY in the flags parameter
 110:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** indicates that the zero copy interface is being used.  See the documentation for
 111:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** FreeRTOS_sockets() for more information. */
 112:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_ZERO_COPY		( 1 )
 113:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
 114:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** /* Values that can be passed in the option name parameter of calls to
 115:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** FreeRTOS_setsockopt(). */
 116:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_SO_RCVTIMEO			( 0 )		/* Used to set the receive time out. */
 117:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_SO_SNDTIMEO			( 1 )		/* Used to set the send time out. */
 118:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_SO_UDPCKSUM_OUT		( 2 )	 	/* Used to turn the use of the UDP checksum by a socket o
 119:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #if( ipconfigSOCKET_HAS_USER_SEMAPHORE == 1 )
 120:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 	#define FREERTOS_SO_SET_SEMAPHORE	( 3 )		/* Used to set a user's semaphore */
 121:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #endif
 122:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_SO_SNDBUF				( 4 )		/* Set the size of the send buffer (TCP only) */
 123:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_SO_RCVBUF				( 5 )		/* Set the size of the receive buffer (TCP only) */
 124:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
 125:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #if ipconfigUSE_CALLBACKS == 1
 126:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 	#define FREERTOS_SO_TCP_CONN_HANDLER	( 6 )		/* Install a callback for (dis) connection events. Sup
 127:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 	#define FREERTOS_SO_TCP_RECV_HANDLER	( 7 )		/* Install a callback for receiving TCP data. Supply p
 128:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 	#define FREERTOS_SO_TCP_SENT_HANDLER	( 8 )		/* Install a callback for sending TCP data. Supply poi
 129:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 	#define FREERTOS_SO_UDP_RECV_HANDLER	( 9 )		/* Install a callback for receiving UDP data. Supply p
 130:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 	#define FREERTOS_SO_UDP_SENT_HANDLER	( 10 )		/* Install a callback for sending UDP data. Supply po
 131:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #endif /* ipconfigUSE_CALLBACKS */
 132:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
 133:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_SO_REUSE_LISTEN_SOCKET	( 11 )		/* When a listening socket gets connected, do not c
 134:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_SO_CLOSE_AFTER_SEND	( 12 )		/* As soon as the last byte has been transmitted, fina
 135:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_SO_WIN_PROPERTIES		( 13 )		/* Set all buffer and window properties in one call, pa
 136:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_SO_SET_FULL_SIZE		( 14 )		/* Refuse to send packets smaller than MSS  */
 137:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
 138:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_SO_STOP_RX				( 15 )		/* Temporarily hold up reception, used by streaming client *
 139:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
 140:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #if( ipconfigUDP_MAX_RX_PACKETS > 0 )
 141:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 	#define FREERTOS_SO_UDP_MAX_RX_PACKETS	( 16 )		/* This option helps to limit the maximum number of
 142:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #endif
 143:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
 144:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #if( ipconfigSOCKET_HAS_USER_WAKE_CALLBACK == 1 )
 145:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 	#define FREERTOS_SO_WAKEUP_CALLBACK	( 17 )
 146:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #endif
 147:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
 148:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_SO_SET_LOW_HIGH_WATER	( 18 )
 149:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_SO_TYPE				( 19 )
 150:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
 151:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
 152:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_NOT_LAST_IN_FRAGMENTED_PACKET 	( 0x80 )  /* For internal use only, but also part o
 153:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_FRAGMENTED_PACKET				( 0x40 )  /* For internal use only, but also part of an 8-bit
 154:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
 155:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** /* Values for flag for FreeRTOS_shutdown(). */
 156:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_SHUT_RD				( 0 )		/* Not really at this moment, just for compatibility of the inte
 157:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_SHUT_WR				( 1 )
 158:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_SHUT_RDWR				( 2 )
 159:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
 160:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** /* Values for flag for FreeRTOS_recv(). */
 161:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_MSG_OOB				( 2 )		/* process out-of-band data */
 162:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_MSG_PEEK				( 4 )		/* peek at incoming message */
 163:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_MSG_DONTROUTE			( 8 )		/* send without using routing tables */
 164:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define FREERTOS_MSG_DONTWAIT			( 16 )		/* Can be used with recvfrom(), sendto(), recv(), and send(
 165:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
 166:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
 167:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** typedef struct xWIN_PROPS {
 168:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 	/* Properties of the Tx buffer and Tx window */
 169:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 	int32_t lTxBufSize;	/* Unit: bytes */
 170:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 	int32_t lTxWinSize;	/* Unit: MSS */
 171:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
 172:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 	/* Properties of the Rx buffer and Rx window */
 173:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 	int32_t lRxBufSize;	/* Unit: bytes */
 174:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 	int32_t lRxWinSize;	/* Unit: MSS */
 175:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** } WinProperties_t;
 176:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
 177:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** typedef struct xLOW_HIGH_WATER {
 178:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 	/* Structure to pass for the 'FREERTOS_SO_SET_LOW_HIGH_WATER' option */
 179:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 	size_t uxLittleSpace;	/* Send a STOP when buffer space drops below X bytes */
 180:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 	size_t uxEnoughSpace;	/* Send a GO when buffer space grows above X bytes */
 181:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** } LowHighWater_t;
 182:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
 183:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** /* For compatibility with the expected Berkeley sockets naming. */
 184:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #define socklen_t uint32_t
 185:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
 186:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** /* For this limited implementation, only two members are required in the
 187:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** Berkeley style sockaddr structure. */
 188:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** struct freertos_sockaddr
 189:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** {
 190:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 	/* _HT_ On 32- and 64-bit architectures, the addition of the two uint8_t
 191:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 	fields doesn't make the structure bigger, due to alignment.
 192:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 	The fields are inserted as a preparation for IPv6. */
 193:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
 194:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 	/* sin_len and sin_family not used in the IPv4-only release. */
 195:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 	uint8_t sin_len;		/* length of this structure. */
 196:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 	uint8_t sin_family;		/* FREERTOS_AF_INET. */
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 	uint16_t sin_port;
 198:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 	uint32_t sin_addr;
 199:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** };
 200:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
 201:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** extern const char *FreeRTOS_inet_ntoa( uint32_t ulIPAddress, char *pcBuffer );
 202:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
 203:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #if ipconfigBYTE_ORDER == pdFREERTOS_LITTLE_ENDIAN
 204:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
 205:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 	#define FreeRTOS_inet_addr_quick( ucOctet0, ucOctet1, ucOctet2, ucOctet3 )				\
 206:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 										( ( ( ( uint32_t ) ( ucOctet3 ) ) << 24UL ) |		\
 207:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 										( ( ( uint32_t ) ( ucOctet2 ) ) << 16UL ) |			\
 208:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 										( ( ( uint32_t ) ( ucOctet1 ) ) <<  8UL ) |			\
 209:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 										( ( uint32_t ) ( ucOctet0 ) ) )
 210:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
 211:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #else /* ipconfigBYTE_ORDER */
 212:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
 213:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 	#define FreeRTOS_inet_addr_quick( ucOctet0, ucOctet1, ucOctet2, ucOctet3 )				\
 214:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 										( ( ( ( uint32_t ) ( ucOctet0 ) ) << 24UL ) |		\
 215:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 										( ( ( uint32_t ) ( ucOctet1 ) ) << 16UL ) |			\
 216:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 										( ( ( uint32_t ) ( ucOctet2 ) ) <<  8UL ) |			\
 217:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 										( ( uint32_t ) ( ucOctet3 ) ) )
 218:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
 219:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** #endif /* ipconfigBYTE_ORDER */
 220:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
 221:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** /* The socket type itself. */
 222:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** struct xSOCKET;
 223:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** typedef struct xSOCKET *Socket_t;
 224:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** typedef struct xSOCKET const * ConstSocket_t;
 225:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** 
 226:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** static portINLINE unsigned int prvSocketValid( Socket_t xSocket )
 227:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h **** {
 228:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h ****     /* coverity[misra_c_2012_rule_11_4_violation] */
 229:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_Sockets.h ****     return ( ( xSocket != FREERTOS_INVALID_SOCKET ) && ( xSocket != NULL ) );
 1372              	 .loc 4 229 0
 1373 00dc 431E     	 subs r3,r0,#1
 1374              	.LBE111:
 1375              	.LBE110:
1659:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
 1376              	 .loc 1 1659 0
 1377 00de 13F1030F 	 cmn r3,#3
 1378 00e2 00F29F80 	 bhi .L125
1667:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		xReturn = FreeRTOS_bind( xSocket, &xAddress, sizeof( xAddress ) );
 1379              	 .loc 1 1667 0
 1380 00e6 0023     	 movs r3,#0
 1381 00e8 ADF82A30 	 strh r3,[sp,#42]
1668:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 1382              	 .loc 1 1668 0
 1383 00ec 0AA9     	 add r1,sp,#40
 1384 00ee 0822     	 movs r2,#8
 1385 00f0 FFF7FEFF 	 bl FreeRTOS_bind
 1386              	.LVL199:
1671:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
 1387              	 .loc 1 1671 0
 1388 00f4 18B1     	 cbz r0,.L124
1673:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			xSocket = NULL;
 1389              	 .loc 1 1673 0
 1390 00f6 3046     	 mov r0,r6
 1391              	.LVL200:
 1392 00f8 FFF7FEFF 	 bl FreeRTOS_closesocket
 1393              	.LVL201:
 1394 00fc 92E0     	 b .L125
 1395              	.LVL202:
 1396              	.L124:
 1397              	.LBE109:
 1398              	.LBE108:
 706:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
 1399              	 .loc 1 706 0
 1400 00fe 002E     	 cmp r6,#0
 1401 0100 00F09080 	 beq .L125
 711:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		( void ) FreeRTOS_setsockopt( xDNSSocket, 0, FREERTOS_SO_RCVTIMEO, &( uxReadTimeOut_ticks ),  siz
 1402              	 .loc 1 711 0
 1403 0104 0425     	 movs r5,#4
 1404 0106 0095     	 str r5,[sp]
 1405 0108 3046     	 mov r0,r6
 1406              	.LVL203:
 1407 010a 0021     	 movs r1,#0
 1408 010c 0122     	 movs r2,#1
 1409 010e 08AB     	 add r3,sp,#32
 1410 0110 FFF7FEFF 	 bl FreeRTOS_setsockopt
 1411              	.LVL204:
 712:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 1412              	 .loc 1 712 0
 1413 0114 0095     	 str r5,[sp]
 1414 0116 3046     	 mov r0,r6
 1415 0118 0021     	 movs r1,#0
 1416 011a 0A46     	 mov r2,r1
 1417 011c 05AB     	 add r3,sp,#20
 1418              	.LVL205:
 1419 011e FFF7FEFF 	 bl FreeRTOS_setsockopt
 1420              	.LVL206:
 1421 0122 4FF00208 	 mov r8,#2
 1422              	.LVL207:
 1423              	.LBB112:
 726:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			if( pxNetworkBuffer != NULL )
 1424              	 .loc 1 726 0
 1425 0126 07F13C03 	 add r3,r7,#60
 1426 012a 0293     	 str r3,[sp,#8]
 1427              	.LVL208:
 1428              	.L132:
 1429 012c 0298     	 ldr r0,[sp,#8]
 1430 012e 0021     	 movs r1,#0
 1431 0130 FFF7FEFF 	 bl pxGetNetworkBufferWithDescriptor
 1432              	.LVL209:
 727:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
 1433              	 .loc 1 727 0
 1434 0134 8146     	 mov r9,r0
 1435 0136 0028     	 cmp r0,#0
 1436 0138 6CD0     	 beq .L126
 729:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			}
 1437              	 .loc 1 729 0
 1438 013a 8369     	 ldr r3,[r0,#24]
 1439              	.LVL210:
 732:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
 1440              	 .loc 1 732 0
 1441 013c 13F12A0B 	 adds fp,r3,#42
 1442              	.LVL211:
 1443 0140 68D0     	 beq .L126
 1444              	.LVL212:
 1445              	.LBB113:
 1446              	.LBB114:
 849:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 1447              	 .loc 1 849 0
 1448 0142 434D     	 ldr r5,.L146+4
 1449 0144 07CD     	 ldmia r5!,{r0,r1,r2}
 1450              	.LVL213:
 1451 0146 C3F82A00 	 str r0,[r3,#42]
 1452 014a CBF80410 	 str r1,[fp,#4]
 1453 014e CBF80820 	 str r2,[fp,#8]
 1454              	.LVL214:
 854:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 1455              	 .loc 1 854 0
 1456 0152 A3F82AA0 	 strh r10,[r3,#42]
 858:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 1457              	 .loc 1 858 0
 1458 0156 03F13605 	 add r5,r3,#54
 1459              	.LVL215:
 861:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 1460              	 .loc 1 861 0
 1461 015a 03F13707 	 add r7,r3,#55
 1462              	.LVL216:
 864:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 1463              	 .loc 1 864 0
 1464 015e 3846     	 mov r0,r7
 1465 0160 2146     	 mov r1,r4
 1466 0162 FFF7FEFF 	 bl strcpy
 1467              	.LVL217:
 867:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	*pucByte = 0x00U;
 1468              	 .loc 1 867 0
 1469 0166 2046     	 mov r0,r4
 1470 0168 FFF7FEFF 	 bl strlen
 1471              	.LVL218:
 868:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 1472              	 .loc 1 868 0
 1473 016c 0023     	 movs r3,#0
 1474 016e 3B54     	 strb r3,[r7,r0]
 1475              	.LVL219:
 1476 0170 00E0     	 b .L129
 1477              	.LVL220:
 1478              	.L137:
 890:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 1479              	 .loc 1 890 0
 1480 0172 1546     	 mov r5,r2
 1481              	.LVL221:
 1482              	.L129:
 877:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 1483              	 .loc 1 877 0
 1484 0174 6A1C     	 adds r2,r5,#1
 1485              	.LVL222:
 879:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
 1486              	 .loc 1 879 0
 1487 0176 6B78     	 ldrb r3,[r5,#1]
 1488 0178 33B1     	 cbz r3,.L127
 1489 017a 2E2B     	 cmp r3,#46
 1490 017c 04D0     	 beq .L127
 1491              	.LVL223:
 1492              	.L140:
 1493 017e 12F8013F 	 ldrb r3,[r2,#1]!
 1494              	.LVL224:
 1495 0182 0BB1     	 cbz r3,.L127
 1496 0184 2E2B     	 cmp r3,#46
 1497 0186 FAD1     	 bne .L140
 1498              	.LVL225:
 1499              	.L127:
 886:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		( *pucStart )--;
 1500              	 .loc 1 886 0
 1501 0188 531B     	 subs r3,r2,r5
 887:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 1502              	 .loc 1 887 0
 1503 018a 013B     	 subs r3,r3,#1
 1504 018c 2B70     	 strb r3,[r5]
 1505              	.LVL226:
 890:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 1506              	 .loc 1 890 0
 1507 018e 1378     	 ldrb r3,[r2]
 1508 0190 002B     	 cmp r3,#0
 1509 0192 EED1     	 bne .L137
 1510              	.LVL227:
 899:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	vSetField16( pxTail, DNSTail_t, usClass, dnsCLASS_IN );
 1511              	 .loc 1 899 0
 1512 0194 0025     	 movs r5,#0
 1513 0196 5570     	 strb r5,[r2,#1]
 1514 0198 0127     	 movs r7,#1
 1515 019a 9770     	 strb r7,[r2,#2]
 900:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	#endif
 1516              	 .loc 1 900 0
 1517 019c D570     	 strb r5,[r2,#3]
 1518 019e 1771     	 strb r7,[r2,#4]
 1519 01a0 CBF10503 	 rsb r3,fp,#5
 905:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** }
 1520              	 .loc 1 905 0
 1521 01a4 1344     	 add r3,r3,r2
 1522 01a6 0393     	 str r3,[sp,#12]
 1523              	.LBE114:
 1524              	.LBE113:
 740:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 1525              	 .loc 1 740 0
 1526 01a8 2846     	 mov r0,r5
 1527 01aa 2946     	 mov r1,r5
 1528 01ac 2A46     	 mov r2,r5
 1529              	.LVL228:
 1530 01ae 06AB     	 add r3,sp,#24
 1531 01b0 FFF7FEFF 	 bl FreeRTOS_GetAddressConfiguration
 1532              	.LVL229:
 756:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					xAddress.sin_port = dnsDNS_PORT;
 1533              	 .loc 1 756 0
 1534 01b4 069B     	 ldr r3,[sp,#24]
 1535 01b6 0B93     	 str r3,[sp,#44]
 757:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
 1536              	 .loc 1 757 0
 1537 01b8 4FF45453 	 mov r3,#13568
 1538 01bc ADF82A30 	 strh r3,[sp,#42]
 760:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 1539              	 .loc 1 760 0
 1540 01c0 0695     	 str r5,[sp,#24]
 762:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				{
 1541              	 .loc 1 762 0
 1542 01c2 0AAB     	 add r3,sp,#40
 1543 01c4 0093     	 str r3,[sp]
 1544 01c6 0823     	 movs r3,#8
 1545 01c8 0193     	 str r3,[sp,#4]
 1546 01ca 3046     	 mov r0,r6
 1547 01cc 5946     	 mov r1,fp
 1548 01ce 039A     	 ldr r2,[sp,#12]
 1549 01d0 3B46     	 mov r3,r7
 1550 01d2 FFF7FEFF 	 bl FreeRTOS_sendto
 1551              	.LVL230:
 1552 01d6 D0B1     	 cbz r0,.L130
 765:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 1553              	 .loc 1 765 0
 1554 01d8 0AAB     	 add r3,sp,#40
 1555 01da 0093     	 str r3,[sp]
 1556 01dc 07AB     	 add r3,sp,#28
 1557 01de 0193     	 str r3,[sp,#4]
 1558 01e0 3046     	 mov r0,r6
 1559 01e2 09A9     	 add r1,sp,#36
 1560 01e4 2A46     	 mov r2,r5
 1561 01e6 3B46     	 mov r3,r7
 1562 01e8 FFF7FEFF 	 bl FreeRTOS_recvfrom
 1563              	.LVL231:
 767:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 					{
 1564              	 .loc 1 767 0
 1565 01ec 011E     	 subs r1,r0,#0
 1566 01ee 11DD     	 ble .L126
 1567              	.LBB115:
 770:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 1568              	 .loc 1 770 0
 1569 01f0 0998     	 ldr r0,[sp,#36]
 1570              	.LVL232:
 773:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						{
 1571              	 .loc 1 773 0
 1572 01f2 0288     	 ldrh r2,[r0]
 790:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						}
 1573              	 .loc 1 790 0
 1574 01f4 9245     	 cmp r10,r2
 1575 01f6 14BF     	 ite ne
 1576 01f8 0022     	 movne r2,#0
 1577 01fa 0122     	 moveq r2,#1
 1578 01fc FFF7FEFF 	 bl prvParseDNSReply
 1579              	.LVL233:
 1580 0200 0690     	 str r0,[sp,#24]
 796:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 1581              	 .loc 1 796 0
 1582 0202 0998     	 ldr r0,[sp,#36]
 1583 0204 FFF7FEFF 	 bl FreeRTOS_ReleaseUDPPayloadBuffer
 1584              	.LVL234:
 798:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 						{
 1585              	 .loc 1 798 0
 1586 0208 069B     	 ldr r3,[sp,#24]
 1587 020a 1BB1     	 cbz r3,.L126
 1588 020c 07E0     	 b .L133
 1589              	.L130:
 1590              	.LBE115:
 810:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				}
 1591              	 .loc 1 810 0
 1592 020e 4846     	 mov r0,r9
 1593 0210 FFF7FEFF 	 bl vReleaseNetworkBufferAndDescriptor
 1594              	.LVL235:
 1595              	.L126:
 814:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
 1596              	 .loc 1 814 0
 1597 0214 059B     	 ldr r3,[sp,#20]
 1598 0216 13B1     	 cbz r3,.L133
 1599              	.LVL236:
 1600              	.LBE112:
 714:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
 1601              	 .loc 1 714 0
 1602 0218 B8F10108 	 subs r8,r8,#1
 1603              	.LVL237:
 1604 021c 86D1     	 bne .L132
 1605              	.LVL238:
 1606              	.L133:
 823:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
 1607              	 .loc 1 823 0
 1608 021e 3046     	 mov r0,r6
 1609 0220 FFF7FEFF 	 bl FreeRTOS_closesocket
 1610              	.LVL239:
 1611              	.L125:
 826:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** }
 1612              	 .loc 1 826 0
 1613 0224 069D     	 ldr r5,[sp,#24]
 1614 0226 0CE0     	 b .L139
 1615              	.LVL240:
 1616              	.L135:
 1617              	.LBE107:
 1618              	.LBE106:
 563:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** TickType_t uxReadTimeOut_ticks = ipconfigDNS_RECEIVE_BLOCK_TIME_TICKS;
 1619              	 .loc 1 563 0
 1620 0228 0025     	 movs r5,#0
 1621 022a 0AE0     	 b .L139
 1622              	.LVL241:
 1623              	.L136:
 1624 022c 0025     	 movs r5,#0
 1625 022e 08E0     	 b .L139
 1626              	.LVL242:
 1627              	.L116:
 637:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 			{
 1628              	 .loc 1 637 0
 1629 0230 002E     	 cmp r6,#0
 1630 0232 7FF43AAF 	 bne .L119
 1631 0236 04E0     	 b .L139
 1632              	.LVL243:
 1633              	.L121:
 657:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
 1634              	 .loc 1 657 0
 1635 0238 0023     	 movs r3,#0
 1636 023a 3DE7     	 b .L134
 1637              	.LVL244:
 1638              	.L143:
 1639 023c 0028     	 cmp r0,#0
 1640 023e 7FF439AF 	 bne .L138
 1641              	.LVL245:
 1642              	.L139:
 1643              	.LBE101:
 1644              	.LBE100:
 551:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** #endif
 1645              	 .loc 1 551 0
 1646 0242 2846     	 mov r0,r5
 1647 0244 0DB0     	 add sp,sp,#52
 1648              	.LCFI15:
 1649              	 .cfi_def_cfa_offset 36
 1650              	 
 1651 0246 BDE8F08F 	 pop {r4,r5,r6,r7,r8,r9,r10,fp,pc}
 1652              	.L147:
 1653 024a 00BF     	 .align 2
 1654              	.L146:
 1655 024c 00000000 	 .word .LANCHOR2
 1656 0250 00000000 	 .word .LANCHOR3
 1657              	 .cfi_endproc
 1658              	.LFE63:
 1660              	 .section .text.FreeRTOS_gethostbyname,"ax",%progbits
 1661              	 .align 2
 1662              	 .global FreeRTOS_gethostbyname
 1663              	 .thumb
 1664              	 .thumb_func
 1666              	FreeRTOS_gethostbyname:
 1667              	.LFB57:
 395:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		return FreeRTOS_gethostbyname_a( pcHostName, NULL, ( void * ) NULL, 0 );
 1668              	 .loc 1 395 0
 1669              	 .cfi_startproc
 1670              	 
 1671              	 
 1672              	.LVL246:
 1673 0000 08B5     	 push {r3,lr}
 1674              	.LCFI16:
 1675              	 .cfi_def_cfa_offset 8
 1676              	 .cfi_offset 3,-8
 1677              	 .cfi_offset 14,-4
 396:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	}
 1678              	 .loc 1 396 0
 1679 0002 0021     	 movs r1,#0
 1680 0004 0A46     	 mov r2,r1
 1681 0006 0B46     	 mov r3,r1
 1682 0008 FFF7FEFF 	 bl FreeRTOS_gethostbyname_a
 1683              	.LVL247:
 397:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	/*-----------------------------------------------------------*/
 1684              	 .loc 1 397 0
 1685 000c 08BD     	 pop {r3,pc}
 1686              	 .cfi_endproc
 1687              	.LFE57:
 1689 000e 00BF     	 .section .text.ulDNSHandlePacket,"ax",%progbits
 1690              	 .align 2
 1691              	 .global ulDNSHandlePacket
 1692              	 .thumb
 1693              	 .thumb_func
 1695              	ulDNSHandlePacket:
 1696              	.LFB69:
1076:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** DNSMessage_t *pxDNSMessageHeader;
 1697              	 .loc 1 1076 0
 1698              	 .cfi_startproc
 1699              	 
 1700              	 
 1701              	.LVL248:
1082:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 	{
 1702              	 .loc 1 1082 0
 1703 0000 C169     	 ldr r1,[r0,#28]
 1704 0002 2929     	 cmp r1,#41
 1705 0004 09D9     	 bls .L153
1084:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 
 1706              	 .loc 1 1084 0
 1707 0006 2A39     	 subs r1,r1,#42
 1708              	.LVL249:
1086:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 		{
 1709              	 .loc 1 1086 0
 1710 0008 0B29     	 cmp r1,#11
 1711 000a 06D9     	 bls .L153
1076:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** DNSMessage_t *pxDNSMessageHeader;
 1712              	 .loc 1 1076 0
 1713 000c 08B5     	 push {r3,lr}
 1714              	.LCFI17:
 1715              	 .cfi_def_cfa_offset 8
 1716              	 .cfi_offset 3,-8
 1717              	 .cfi_offset 14,-4
 1718              	.LVL250:
1092:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** 				uxPayloadSize,
 1719              	 .loc 1 1092 0
 1720 000e 8069     	 ldr r0,[r0,#24]
 1721              	.LVL251:
 1722 0010 0022     	 movs r2,#0
 1723 0012 FFF7FEFF 	 bl prvParseDNSReply
 1724              	.LVL252:
1100:../FreeRTOS-Plus-TCP/FreeRTOS_DNS.c **** /*-----------------------------------------------------------*/
 1725              	 .loc 1 1100 0
 1726 0016 0020     	 movs r0,#0
 1727 0018 08BD     	 pop {r3,pc}
 1728              	.LVL253:
 1729              	.L153:
 1730              	.LCFI18:
 1731              	 .cfi_def_cfa_offset 0
 1732              	 .cfi_restore 3
 1733              	 .cfi_restore 14
 1734 001a 0020     	 movs r0,#0
 1735              	.LVL254:
 1736 001c 7047     	 bx lr
 1737              	 .cfi_endproc
 1738              	.LFE69:
 1740 001e 00BF     	 .section .bss.xCallbackList,"aw",%nobits
 1741              	 .align 2
 1742              	 .set .LANCHOR2,.+0
 1745              	xCallbackList:
 1746 0000 00000000 	 .space 20
 1746      00000000 
 1746      00000000 
 1746      00000000 
 1746      00000000 
 1747              	 .section .bss.xFreeEntry.7065,"aw",%nobits
 1748              	 .align 2
 1749              	 .set .LANCHOR1,.+0
 1752              	xFreeEntry.7065:
 1753 0000 00000000 	 .space 4
 1754              	 .section .bss.xDNSCache,"aw",%nobits
 1755              	 .align 2
 1756              	 .set .LANCHOR0,.+0
 1759              	xDNSCache:
 1760 0000 00000000 	 .space 112
 1760      00000000 
 1760      00000000 
 1760      00000000 
 1760      00000000 
 1761              	 .section .rodata.xDefaultPartDNSHeader.6982,"a",%progbits
 1762              	 .align 2
 1763              	 .set .LANCHOR3,.+0
 1766              	xDefaultPartDNSHeader.6982:
 1767 0000 0000     	 .short 0
 1768 0002 0100     	 .short 1
 1769 0004 0001     	 .short 256
 1770 0006 0000     	 .short 0
 1771 0008 0000     	 .short 0
 1772 000a 0000     	 .short 0
 1773              	 .text
 1774              	.Letext0:
 1775              	 .file 5 "e:\\embedded\\dave_4-4-2_64bit_2018-02-23\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 1776              	 .file 6 "e:\\embedded\\dave_4-4-2_64bit_2018-02-23\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 1777              	 .file 7 "e:\\embedded\\dave_4-4-2_64bit_2018-02-23\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\lib\\gcc\\arm-none-eabi\\4.9.3\\include\\stddef.h"
 1778              	 .file 8 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/include/list.h"
 1779              	 .file 9 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/include/task.h"
 1780              	 .file 10 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include/FreeRTOS_IP.h"
 1781              	 .file 11 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/include/event_groups.h"
 1782              	 .file 12 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include/FreeRTOS_Stream_Buffer.h"
 1783              	 .file 13 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include/FreeRTOS_TCP_WIN.h"
 1784              	 .file 14 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include/FreeRTOS_DNS.h"
 1785              	 .file 15 "e:\\embedded\\dave_4-4-2_64bit_2018-02-23\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\string.h"
 1786              	 .file 16 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/include/portable.h"
 1787              	 .file 17 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include/NetworkBufferManagement.h"
DEFINED SYMBOLS
                            *ABS*:00000000 FreeRTOS_DNS.c
    {standard input}:19     .text.prvSkipNameField:00000000 $t
    {standard input}:23     .text.prvSkipNameField:00000000 prvSkipNameField
    {standard input}:130    .text.prvProcessDNSCache:00000000 $t
    {standard input}:134    .text.prvProcessDNSCache:00000000 prvProcessDNSCache
    {standard input}:340    .text.prvProcessDNSCache:00000120 $d
    {standard input}:347    .text.prvParseDNSReply:00000000 $t
    {standard input}:351    .text.prvParseDNSReply:00000000 prvParseDNSReply
    {standard input}:929    .text.prvParseDNSReply:00000290 $d
    {standard input}:934    .text.FreeRTOS_dnsclear:00000000 $t
    {standard input}:939    .text.FreeRTOS_dnsclear:00000000 FreeRTOS_dnsclear
    {standard input}:960    .text.FreeRTOS_dnsclear:00000010 $d
    {standard input}:965    .text.FreeRTOS_dnslookup:00000000 $t
    {standard input}:970    .text.FreeRTOS_dnslookup:00000000 FreeRTOS_dnslookup
    {standard input}:1003   .text.vDNSInitialise:00000000 $t
    {standard input}:1008   .text.vDNSInitialise:00000000 vDNSInitialise
    {standard input}:1027   .text.vDNSInitialise:0000000c $d
    {standard input}:1032   .text.vDNSCheckCallBack:00000000 $t
    {standard input}:1037   .text.vDNSCheckCallBack:00000000 vDNSCheckCallBack
    {standard input}:1140   .text.vDNSCheckCallBack:00000074 $d
    {standard input}:1145   .text.FreeRTOS_gethostbyname_cancel:00000000 $t
    {standard input}:1150   .text.FreeRTOS_gethostbyname_cancel:00000000 FreeRTOS_gethostbyname_cancel
    {standard input}:1170   .text.FreeRTOS_gethostbyname_a:00000000 $t
    {standard input}:1175   .text.FreeRTOS_gethostbyname_a:00000000 FreeRTOS_gethostbyname_a
    {standard input}:1655   .text.FreeRTOS_gethostbyname_a:0000024c $d
    {standard input}:1661   .text.FreeRTOS_gethostbyname:00000000 $t
    {standard input}:1666   .text.FreeRTOS_gethostbyname:00000000 FreeRTOS_gethostbyname
    {standard input}:1690   .text.ulDNSHandlePacket:00000000 $t
    {standard input}:1695   .text.ulDNSHandlePacket:00000000 ulDNSHandlePacket
    {standard input}:1741   .bss.xCallbackList:00000000 $d
    {standard input}:1745   .bss.xCallbackList:00000000 xCallbackList
    {standard input}:1748   .bss.xFreeEntry.7065:00000000 $d
    {standard input}:1752   .bss.xFreeEntry.7065:00000000 xFreeEntry.7065
    {standard input}:1755   .bss.xDNSCache:00000000 $d
    {standard input}:1759   .bss.xDNSCache:00000000 xDNSCache
    {standard input}:1762   .rodata.xDefaultPartDNSHeader.6982:00000000 $d
    {standard input}:1766   .rodata.xDefaultPartDNSHeader.6982:00000000 xDefaultPartDNSHeader.6982
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.0.3466fc6a3db32493c997d085de4c7a28
                           .group:00000000 wm4.features.h.22.bee0aee4a3878f51861c775df98fa3ea
                           .group:00000000 wm4._default_types.h.15.933e8edd27a65e0b69af4a865eb623d2
                           .group:00000000 wm4._intsup.h.10.ca9f32a61b410c270a48d1161ca2c217
                           .group:00000000 wm4.stdint.h.22.f4a337c398d8b6d821a97202448bc0d0
                           .group:00000000 wm4.newlib.h.8.fe7d912fc917043c98742c35eddd8cff
                           .group:00000000 wm4.config.h.216.aad1ef7bee4fb69981cb38ce62f84d9c
                           .group:00000000 wm4._ansi.h.23.9f8fcfa20193763fcf364fb91705c94b
                           .group:00000000 wm4.stdio.h.31.7c0e28c411445f3f9c5b11accf882760
                           .group:00000000 wm4.stddef.h.184.159df79b4ca79c76561572a55985524c
                           .group:00000000 wm4.cdefs.h.47.4002528de975c0fcce6c551c15d87b8c
                           .group:00000000 wm4.stddef.h.39.fb88e218f22ad7a0ab38f3d93c6eb3e4
                           .group:00000000 wm4.stdarg.h.34.3a23a216c0c293b3d2ea2e89281481e6
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4._types.h.54.d3d34a3b7f3cc230cd159baf022b4b08
                           .group:00000000 wm4.stddef.h.158.61317cdbfb4026324507d123a50b0fd6
                           .group:00000000 wm4.reent.h.17.8bd9e4098e0428508c282cad794fae43
                           .group:00000000 wm4.types.h.23.0d949686bbcadd1621462d4fa1f884f9
                           .group:00000000 wm4.types.h.2.e9cec8c90ab35f77d9f499e06ae02400
                           .group:00000000 wm4.types.h.80.56707660962b21991903f1fee7c13bb3
                           .group:00000000 wm4.stdio.h.2.4aa87247282eca6c8f36f9de33d8df1a
                           .group:00000000 wm4.stdio.h.65.7c7009d79fb33c27bcf8e2214c76b343
                           .group:00000000 wm4.FreeRTOSConfig.h.30.aa43eb1cb33228d5c7e359a94d48589b
                           .group:00000000 wm4.projdefs.h.28.d6a7c9061b707820f2fcf4c2ff5d9f24
                           .group:00000000 wm4.portmacro.h.30.2ddc2eaf2e032c76c597fb78c4365041
                           .group:00000000 wm4.portable.h.63.e9cc508c3850f44ce542149380c67812
                           .group:00000000 wm4.mpu_wrappers.h.28.163fb40577cf8d1578015ea3f2ff4cdb
                           .group:00000000 wm4.FreeRTOS.h.67.9945f39eea4ddeb224c0782392206292
                           .group:00000000 wm4.list.h.57.02ec67e07eacffe5ca7cfb7326896236
                           .group:00000000 wm4.task.h.47.2d3fe49a094b8ec1e3e6aac441e8db21
                           .group:00000000 wm4.queue.h.66.45d4a3cf5de24cde7e732f8dad25383c
                           .group:00000000 wm4.semphr.h.38.96f44691bfa19eb833944d3a35b81e54
                           .group:00000000 wm4.FreeRTOSIPConfig.h.37.3f9c1db988571ff1f3dec4c7e54978d6
                           .group:00000000 wm4.FreeRTOS_errno_TCP.h.27.708877b341d0e6bcb4ba112b2ad8082a
                           .group:00000000 wm4.FreeRTOSIPConfigDefaults.h.41.f972b11d9b1eba5383080cfaef1fd740
                           .group:00000000 wm4.IPTraceMacroDefaults.h.31.69642530b5a79c93e762c9b09ac0d1d5
                           .group:00000000 wm4.FreeRTOS_IP.h.59.3f5e36f6612bd0c66747c6093da47335
                           .group:00000000 wm4.FreeRTOS_IP.h.179.e5077063e624bc5d3f02542470d6ea94
                           .group:00000000 wm4.string.h.8.c4b8571ce60dff2817f43fec8b86aecd
                           .group:00000000 wm4.stddef.h.158.a7efb00f6cbc6f43213b50e183c9830c
                           .group:00000000 wm4.timers.h.29.025d268d6baf57298309e7b498ee1cc7
                           .group:00000000 wm4.FreeRTOS_Sockets.h.58.61d472da32c0e0f5bc49c368f15d0ac5
                           .group:00000000 wm4.FreeRTOS_TCP_WIN.h.32.f3cfab69924f28284deb16cc1a30fb93
                           .group:00000000 wm4.FreeRTOS_IP_Private.h.52.551f932b14473cea139893dda31b3fa0
                           .group:00000000 wm4.FreeRTOS_IP_Private.h.328.b5788f8d626a4cf16b8282f9399f3f55
                           .group:00000000 wm4.FreeRTOS_DNS.h.27.8432bc3440a9cfc56281e07613f9ce59

UNDEFINED SYMBOLS
xTaskGetTickCount
strcmp
strlen
strcpy
vTaskSuspendAll
uxListRemove
vPortFree
vIPSetDnsTimerEnableState
FreeRTOS_inet_ntop
xTaskResumeAll
memset
vListInitialise
xTaskCheckForTimeOut
FreeRTOS_inet_addr
xApplicationGetRandomNumber
pvPortMalloc
vIPReloadDNSTimer
vTaskSetTimeOutState
vListInsertEnd
FreeRTOS_socket
FreeRTOS_bind
FreeRTOS_closesocket
FreeRTOS_setsockopt
pxGetNetworkBufferWithDescriptor
FreeRTOS_GetAddressConfiguration
FreeRTOS_sendto
FreeRTOS_recvfrom
FreeRTOS_ReleaseUDPPayloadBuffer
vReleaseNetworkBufferAndDescriptor
