   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .eabi_attribute 28,1
   5              	 .fpu fpv4-sp-d16
   6              	 .eabi_attribute 23,1
   7              	 .eabi_attribute 24,1
   8              	 .eabi_attribute 25,1
   9              	 .eabi_attribute 26,1
  10              	 .eabi_attribute 30,1
  11              	 .eabi_attribute 34,1
  12              	 .eabi_attribute 18,4
  13              	 .thumb
  14              	 .file "FreeRTOS_TCP_WIN.c"
  15              	 .text
  16              	.Ltext0:
  17              	 .cfi_sections .debug_frame
  18              	 .section .text.vListInsertGeneric,"ax",%progbits
  19              	 .align 2
  20              	 .thumb
  21              	 .thumb_func
  23              	vListInsertGeneric:
  24              	.LFB58:
  25              	 .file 1 "../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c"
   1:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*
   2:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * FreeRTOS+TCP V2.2.2
   3:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  *
   5:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * this software and associated documentation files (the "Software"), to deal in
   7:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * the Software without restriction, including without limitation the rights to
   8:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * subject to the following conditions:
  11:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  *
  12:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * The above copyright notice and this permission notice shall be included in all
  13:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * copies or substantial portions of the Software.
  14:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  *
  15:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  *
  22:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * http://aws.amazon.com/freertos
  23:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * http://www.FreeRTOS.org
  24:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  */
  25:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
  26:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*
  27:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * FreeRTOS_TCP_WIN.c
  28:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * Module which handles the TCP windowing schemes for FreeRTOS+TCP.  Many
  29:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * functions have two versions - one for FreeRTOS+TCP (full) and one for
  30:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * FreeRTOS+TCP (lite).
  31:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  *
  32:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * In this module all ports and IP addresses and sequence numbers are
  33:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * being stored in host byte-order.
  34:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  */
  35:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
  36:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /* Standard includes. */
  37:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #include <stdint.h>
  38:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
  39:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /* FreeRTOS includes. */
  40:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #include "FreeRTOS.h"
  41:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #include "task.h"
  42:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
  43:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /* FreeRTOS+TCP includes. */
  44:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #include "FreeRTOS_UDP_IP.h"
  45:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #include "FreeRTOS_IP.h"
  46:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #include "FreeRTOS_Sockets.h"
  47:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #include "FreeRTOS_IP_Private.h"
  48:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
  49:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #include "FreeRTOSIPConfigDefaults.h"
  50:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
  51:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /* Constants used for Smoothed Round Trip Time (SRTT). */
  52:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #define	winSRTT_INCREMENT_NEW 		2
  53:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #define winSRTT_INCREMENT_CURRENT 	6
  54:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #define	winSRTT_DECREMENT_NEW 		1
  55:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #define winSRTT_DECREMENT_CURRENT 	7
  56:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #define winSRTT_CAP_mS				50
  57:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
  58:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** static portINLINE ipDECL_CAST_PTR_FUNC_FOR_TYPE( TCPSegment_t )
  59:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** {
  60:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	return ( TCPSegment_t *)pvArgument;
  61:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** }
  62:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
  63:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
  64:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #if( ipconfigUSE_TCP_WIN == 1 )
  65:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
  66:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	#define xTCPWindowRxNew( pxWindow, ulSequenceNumber, lCount ) xTCPWindowNew( pxWindow, ulSequenceN
  67:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
  68:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	#define xTCPWindowTxNew( pxWindow, ulSequenceNumber, lCount ) xTCPWindowNew( pxWindow, ulSequenceN
  69:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
  70:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	/* The code to send a single Selective ACK (SACK):
  71:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	 * NOP (0x01), NOP (0x01), SACK (0x05), LEN (0x0a),
  72:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	 * followed by a lower and a higher sequence number,
  73:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	 * where LEN is 2 + 2*4 = 10 bytes. */
  74:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	#if( ipconfigBYTE_ORDER == pdFREERTOS_BIG_ENDIAN )
  75:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		#define OPTION_CODE_SINGLE_SACK		( 0x0101050aUL )
  76:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	#else
  77:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		#define OPTION_CODE_SINGLE_SACK		( 0x0a050101UL )
  78:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	#endif
  79:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
  80:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	/* Normal retransmission:
  81:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	 * A packet will be retransmitted after a Retransmit Time-Out (RTO).
  82:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	 * Fast retransmission:
  83:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	 * When 3 packets with a higher sequence number have been acknowledged
  84:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	 * by the peer, it is very unlikely a current packet will ever arrive.
  85:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	 * It will be retransmitted far before the RTO.
  86:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	 */
  87:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	#define	DUPLICATE_ACKS_BEFORE_FAST_RETRANSMIT		( 3U )
  88:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
  89:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	/* If there have been several retransmissions (4), decrease the
  90:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	 * size of the transmission window to at most 2 times MSS.
  91:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	 */
  92:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	#define MAX_TRANSMIT_COUNT_USING_LARGE_WINDOW		( 4U )
  93:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
  94:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #endif /* configUSE_TCP_WIN */
  95:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*-----------------------------------------------------------*/
  96:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
  97:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** static void vListInsertGeneric( List_t * const pxList, ListItem_t * const pxNewListItem, MiniListIt
  98:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
  99:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*
 100:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * All TCP sockets share a pool of segment descriptors (TCPSegment_t)
 101:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * Available descriptors are stored in the 'xSegmentList'
 102:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * When a socket owns a descriptor, it will either be stored in
 103:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * 'xTxSegments' or 'xRxSegments'
 104:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * As soon as a package has been confirmed, the descriptor will be returned
 105:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * to the segment pool
 106:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  */
 107:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #if( ipconfigUSE_TCP_WIN == 1 )
 108:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	static BaseType_t prvCreateSectors( void );
 109:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #endif /* ipconfigUSE_TCP_WIN == 1 */
 110:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 111:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*
 112:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * Find a segment with a given sequence number in the list of received
 113:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * segments: 'pxWindow->xRxSegments'.
 114:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  */
 115:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #if( ipconfigUSE_TCP_WIN == 1 )
 116:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	static TCPSegment_t *xTCPWindowRxFind( const TCPWindow_t *pxWindow, uint32_t ulSequenceNumber );
 117:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #endif /* ipconfigUSE_TCP_WIN == 1 */
 118:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 119:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*
 120:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * Allocate a new segment
 121:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * The socket will borrow all segments from a common pool: 'xSegmentList',
 122:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * which is a list of 'TCPSegment_t'
 123:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  */
 124:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #if( ipconfigUSE_TCP_WIN == 1 )
 125:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	static TCPSegment_t *xTCPWindowNew( TCPWindow_t *pxWindow, uint32_t ulSequenceNumber, int32_t lCou
 126:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #endif /* ipconfigUSE_TCP_WIN == 1 */
 127:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 128:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*
 129:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * Detaches and returns the head of a queue
 130:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  */
 131:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #if( ipconfigUSE_TCP_WIN == 1 )
 132:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	static TCPSegment_t *xTCPWindowGetHead( const List_t *pxList );
 133:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #endif /* ipconfigUSE_TCP_WIN == 1 */
 134:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 135:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*
 136:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * Returns the head of a queue but it won't be detached
 137:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  */
 138:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #if( ipconfigUSE_TCP_WIN == 1 )
 139:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	static TCPSegment_t *xTCPWindowPeekHead( const List_t *pxList );
 140:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #endif /* ipconfigUSE_TCP_WIN == 1 */
 141:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 142:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*
 143:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  *  Free entry pxSegment because it's not used anymore
 144:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  *	The ownership will be passed back to the segment pool
 145:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  */
 146:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #if( ipconfigUSE_TCP_WIN == 1 )
 147:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	static void vTCPWindowFree( TCPSegment_t *pxSegment );
 148:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #endif /* ipconfigUSE_TCP_WIN == 1 */
 149:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 150:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*
 151:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * A segment has been received with sequence number 'ulSequenceNumber', where
 152:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * 'ulCurrentSequenceNumber == ulSequenceNumber', which means that exactly this
 153:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * segment was expected.  xTCPWindowRxConfirm() will check if there is already
 154:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * another segment with a sequence number between (ulSequenceNumber) and
 155:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * (ulSequenceNumber+xLength).  Normally none will be found, because the next Rx
 156:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * segment should have a sequence number equal to '(ulSequenceNumber+xLength)'.
 157:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  */
 158:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #if( ipconfigUSE_TCP_WIN == 1 )
 159:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	static TCPSegment_t *xTCPWindowRxConfirm( const TCPWindow_t *pxWindow, uint32_t ulSequenceNumber, 
 160:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #endif /* ipconfigUSE_TCP_WIN == 1 */
 161:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 162:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*
 163:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * FreeRTOS+TCP stores data in circular buffers.  Calculate the next position to
 164:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * store.
 165:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  */
 166:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #if( ipconfigUSE_TCP_WIN == 1 )
 167:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	static int32_t lTCPIncrementTxPosition( int32_t lPosition, int32_t lMax, int32_t lCount );
 168:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #endif /* ipconfigUSE_TCP_WIN == 1 */
 169:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 170:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*
 171:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * This function will look if there is new transmission data.  It will return
 172:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * true if there is data to be sent.
 173:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  */
 174:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #if( ipconfigUSE_TCP_WIN == 1 )
 175:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	static BaseType_t prvTCPWindowTxHasSpace( TCPWindow_t const * pxWindow, uint32_t ulWindowSize );
 176:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #endif /* ipconfigUSE_TCP_WIN == 1 */
 177:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 178:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*
 179:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * An acknowledge was received.  See if some outstanding data may be removed
 180:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * from the transmission queue(s).
 181:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  */
 182:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #if( ipconfigUSE_TCP_WIN == 1 )
 183:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	static uint32_t prvTCPWindowTxCheckAck( TCPWindow_t *pxWindow, uint32_t ulFirst, uint32_t ulLast )
 184:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #endif /* ipconfigUSE_TCP_WIN == 1 */
 185:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 186:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*
 187:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * A higher Tx block has been acknowledged.  Now iterate through the xWaitQueue
 188:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * to find a possible condition for a FAST retransmission.
 189:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  */
 190:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #if( ipconfigUSE_TCP_WIN == 1 )
 191:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	static uint32_t prvTCPWindowFastRetransmit( TCPWindow_t *pxWindow, uint32_t ulFirst );
 192:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #endif /* ipconfigUSE_TCP_WIN == 1 */
 193:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 194:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*-----------------------------------------------------------*/
 195:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 196:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /* TCP segment pool. */
 197:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #if( ipconfigUSE_TCP_WIN == 1 )
 198:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	static TCPSegment_t *xTCPSegments = NULL;
 199:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #endif /* ipconfigUSE_TCP_WIN == 1 */
 200:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 201:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /* List of free TCP segments. */
 202:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #if( ipconfigUSE_TCP_WIN == 1 )
 203:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	_static List_t xSegmentList;
 204:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #endif
 205:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 206:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /* Logging verbosity level. */
 207:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** BaseType_t xTCPWindowLoggingLevel = 0;
 208:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 209:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #if( ipconfigUSE_TCP_WIN == 1 )
 210:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	/* Some 32-bit arithmetic: comparing sequence numbers */
 211:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	static portINLINE BaseType_t xSequenceLessThanOrEqual( uint32_t a, uint32_t b );
 212:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	static portINLINE BaseType_t xSequenceLessThanOrEqual( uint32_t a, uint32_t b )
 213:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	{
 214:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	BaseType_t xResult;
 215:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 216:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		/* Test if a <= b
 217:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		Return true if the unsigned subtraction of (b-a) doesn't generate an
 218:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		arithmetic overflow. */
 219:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		if( ( ( b - a ) & 0x80000000UL ) == 0UL )
 220:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 221:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			xResult = pdTRUE;
 222:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 223:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		else
 224:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 225:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			xResult = pdFALSE;
 226:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 227:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		return xResult;
 228:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
 229:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #endif /* ipconfigUSE_TCP_WIN */
 230:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*-----------------------------------------------------------*/
 231:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 232:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #if( ipconfigUSE_TCP_WIN == 1 )
 233:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	static portINLINE BaseType_t xSequenceLessThan( uint32_t a, uint32_t b );
 234:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	static portINLINE BaseType_t xSequenceLessThan( uint32_t a, uint32_t b )
 235:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	{
 236:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	BaseType_t xResult;
 237:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 238:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		/* Test if a < b */
 239:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		if( ( ( b - ( a + 1UL ) ) & 0x80000000UL ) == 0UL )
 240:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 241:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			xResult = pdTRUE;
 242:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 243:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		else
 244:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 245:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			xResult = pdFALSE;
 246:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 247:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		return xResult;
 248:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
 249:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #endif /* ipconfigUSE_TCP_WIN */
 250:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*-----------------------------------------------------------*/
 251:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 252:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #if( ipconfigUSE_TCP_WIN == 1 )
 253:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	static portINLINE BaseType_t xSequenceGreaterThan( uint32_t a, uint32_t b );
 254:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	static portINLINE BaseType_t xSequenceGreaterThan( uint32_t a, uint32_t b )
 255:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	{
 256:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	BaseType_t xResult;
 257:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 258:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		/* Test if a > b */
 259:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		if( ( ( a - ( b + 1UL ) ) & 0x80000000UL ) == 0UL )
 260:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 261:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			xResult = pdTRUE;
 262:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 263:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		else
 264:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 265:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			xResult = pdFALSE;
 266:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 267:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		return xResult;
 268:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
 269:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #endif /* ipconfigUSE_TCP_WIN */
 270:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 271:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*-----------------------------------------------------------*/
 272:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** static portINLINE BaseType_t xSequenceGreaterThanOrEqual( uint32_t a, uint32_t b );
 273:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** static portINLINE BaseType_t xSequenceGreaterThanOrEqual( uint32_t a, uint32_t b )
 274:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** {
 275:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** BaseType_t xResult;
 276:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 277:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	/* Test if a >= b */
 278:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	if( ( ( a - b ) & 0x80000000UL ) == 0UL )
 279:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	{
 280:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		xResult = pdTRUE;
 281:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
 282:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	else
 283:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	{
 284:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		xResult = pdFALSE;
 285:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
 286:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	return xResult;
 287:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** }
 288:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*-----------------------------------------------------------*/
 289:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 290:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #if( ipconfigUSE_TCP_WIN == 1 )
 291:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	static portINLINE void vListInsertFifo( List_t * const pxList, ListItem_t * const pxNewListItem );
 292:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	static portINLINE void vListInsertFifo( List_t * const pxList, ListItem_t * const pxNewListItem )
 293:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	{
 294:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		vListInsertGeneric( pxList, pxNewListItem, &pxList->xListEnd );
 295:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
 296:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #endif
 297:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*-----------------------------------------------------------*/
 298:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 299:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** static portINLINE void vTCPTimerSet( TCPTimer_t *pxTimer );
 300:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** static portINLINE void vTCPTimerSet( TCPTimer_t *pxTimer )
 301:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** {
 302:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	pxTimer->ulBorn = xTaskGetTickCount ( );
 303:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** }
 304:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*-----------------------------------------------------------*/
 305:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 306:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** static portINLINE uint32_t ulTimerGetAge( const TCPTimer_t *pxTimer );
 307:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** static portINLINE uint32_t ulTimerGetAge( const TCPTimer_t *pxTimer )
 308:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** {
 309:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	return ( ( xTaskGetTickCount() - ( ( TickType_t ) pxTimer->ulBorn ) ) * portTICK_PERIOD_MS );
 310:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** }
 311:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*-----------------------------------------------------------*/
 312:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 313:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** static void vListInsertGeneric( List_t * const pxList, ListItem_t * const pxNewListItem, MiniListIt
 314:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** {
  26              	 .loc 1 314 0
  27              	 .cfi_startproc
  28              	 
  29              	 
  30              	 
  31              	.LVL0:
 315:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	/* Insert a new list item into pxList, it does not sort the list,
 316:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	but it puts the item just before xListEnd, so it will be the last item
 317:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	returned by listGET_HEAD_ENTRY() */
 318:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	pxNewListItem->pxNext = ( struct xLIST_ITEM * configLIST_VOLATILE )pxWhere;
  32              	 .loc 1 318 0
  33 0000 4A60     	 str r2,[r1,#4]
 319:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	pxNewListItem->pxPrevious = pxWhere->pxPrevious;
  34              	 .loc 1 319 0
  35 0002 9368     	 ldr r3,[r2,#8]
  36 0004 8B60     	 str r3,[r1,#8]
 320:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	pxWhere->pxPrevious->pxNext = pxNewListItem;
  37              	 .loc 1 320 0
  38 0006 9368     	 ldr r3,[r2,#8]
  39 0008 5960     	 str r1,[r3,#4]
 321:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	pxWhere->pxPrevious = pxNewListItem;
  40              	 .loc 1 321 0
  41 000a 9160     	 str r1,[r2,#8]
 322:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 323:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	/* Remember which list the item is in. */
 324:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	listLIST_ITEM_CONTAINER( pxNewListItem ) = ( struct xLIST * configLIST_VOLATILE )pxList;
  42              	 .loc 1 324 0
  43 000c 0861     	 str r0,[r1,#16]
 325:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 326:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	( pxList->uxNumberOfItems )++;
  44              	 .loc 1 326 0
  45 000e 0368     	 ldr r3,[r0]
  46 0010 0133     	 adds r3,r3,#1
  47 0012 0360     	 str r3,[r0]
  48 0014 7047     	 bx lr
  49              	 .cfi_endproc
  50              	.LFE58:
  52 0016 00BF     	 .section .text.xTCPWindowRxFind,"ax",%progbits
  53              	 .align 2
  54              	 .thumb
  55              	 .thumb_func
  57              	xTCPWindowRxFind:
  58              	.LFB60:
 327:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** }
 328:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*-----------------------------------------------------------*/
 329:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 330:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #if( ipconfigUSE_TCP_WIN == 1 )
 331:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 332:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	static BaseType_t prvCreateSectors( void )
 333:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	{
 334:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	BaseType_t xIndex, xReturn;
 335:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 336:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		/* Allocate space for 'xTCPSegments' and store them in 'xSegmentList'. */
 337:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 338:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		vListInitialise( &xSegmentList );
 339:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		xTCPSegments = ipCAST_PTR_TO_TYPE_PTR( TCPSegment_t, pvPortMallocLarge( ( size_t ) ipconfigTCP_WI
 340:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 341:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		if( xTCPSegments == NULL )
 342:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 343:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			FreeRTOS_debug_printf( ( "prvCreateSectors: malloc %u failed\n",
 344:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				( unsigned ) ipconfigTCP_WIN_SEG_COUNT * sizeof( xTCPSegments[ 0 ] ) ) );
 345:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 346:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			xReturn = pdFAIL;
 347:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 348:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		else
 349:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 350:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			/* Clear the allocated space. */
 351:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			( void ) memset( xTCPSegments, 0, ( size_t ) ipconfigTCP_WIN_SEG_COUNT * sizeof( xTCPSegments[ 0
 352:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 353:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			for( xIndex = 0; xIndex < ipconfigTCP_WIN_SEG_COUNT; xIndex++ )
 354:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
 355:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				/* Could call vListInitialiseItem here but all data has been
 356:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				nulled already.  Set the owner to a segment descriptor. */
 357:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				listSET_LIST_ITEM_OWNER( &( xTCPSegments[ xIndex ].xSegmentItem  ),( void * ) &( xTCPSegments[ 
 358:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				listSET_LIST_ITEM_OWNER( &( xTCPSegments[ xIndex ].xQueueItem ), ( void * ) &( xTCPSegments[ xI
 359:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 360:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				/* And add it to the pool of available segments */
 361:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				vListInsertFifo( &xSegmentList, &( xTCPSegments[xIndex].xSegmentItem ) );
 362:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
 363:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 364:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			xReturn = pdPASS;
 365:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 366:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 367:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		return xReturn;
 368:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
 369:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 370:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #endif /* ipconfigUSE_TCP_WIN == 1 */
 371:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*-----------------------------------------------------------*/
 372:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 373:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #if( ipconfigUSE_TCP_WIN == 1 )
 374:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 375:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	static TCPSegment_t *xTCPWindowRxFind( const TCPWindow_t *pxWindow, uint32_t ulSequenceNumber )
 376:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	{
  59              	 .loc 1 376 0
  60              	 .cfi_startproc
  61              	 
  62              	 
  63              	 
  64              	.LVL1:
  65 0000 10B4     	 push {r4}
  66              	.LCFI0:
  67              	 .cfi_def_cfa_offset 4
  68              	 .cfi_offset 4,-4
  69              	.LVL2:
 377:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	const ListItem_t *pxIterator;
 378:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	const ListItem_t* pxEnd;
 379:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	TCPSegment_t *pxSegment, *pxReturn = NULL;
 380:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 381:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		/* Find a segment with a given sequence number in the list of received
 382:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		segments. */
 383:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		pxEnd = listGET_END_MARKER( &pxWindow->xRxSegments );
  70              	 .loc 1 383 0
  71 0002 00F1AC04 	 add r4,r0,#172
  72              	.LVL3:
 384:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 385:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		for( pxIterator  = listGET_NEXT( pxEnd );
  73              	 .loc 1 385 0
  74 0006 D0F8B030 	 ldr r3,[r0,#176]
  75              	.LVL4:
  76 000a 9C42     	 cmp r4,r3
  77 000c 0DD0     	 beq .L7
 386:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			 pxIterator != pxEnd;
 387:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			 pxIterator  = listGET_NEXT( pxIterator ) )
 388:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 389:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			pxSegment = ipCAST_PTR_TO_TYPE_PTR( TCPSegment_t, listGET_LIST_ITEM_OWNER( pxIterator ) );
  78              	 .loc 1 389 0
  79 000e D868     	 ldr r0,[r3,#12]
  80              	.LVL5:
 390:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 391:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			if( pxSegment->ulSequenceNumber == ulSequenceNumber )
  81              	 .loc 1 391 0
  82 0010 0268     	 ldr r2,[r0]
  83 0012 8A42     	 cmp r2,r1
  84 0014 04D1     	 bne .L5
  85 0016 09E0     	 b .L3
  86              	.L6:
  87              	.LVL6:
 389:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
  88              	 .loc 1 389 0
  89 0018 D868     	 ldr r0,[r3,#12]
  90              	 .loc 1 391 0
  91 001a 0268     	 ldr r2,[r0]
  92 001c 8A42     	 cmp r2,r1
  93 001e 05D0     	 beq .L3
  94              	.LVL7:
  95              	.L5:
 387:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
  96              	 .loc 1 387 0
  97 0020 5B68     	 ldr r3,[r3,#4]
  98              	.LVL8:
 385:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			 pxIterator != pxEnd;
  99              	 .loc 1 385 0
 100 0022 9C42     	 cmp r4,r3
 101 0024 F8D1     	 bne .L6
 102              	.LVL9:
 379:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 103              	 .loc 1 379 0
 104 0026 0020     	 movs r0,#0
 105 0028 00E0     	 b .L3
 106              	.LVL10:
 107              	.L7:
 108 002a 0020     	 movs r0,#0
 109              	.LVL11:
 110              	.L3:
 392:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
 393:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				pxReturn = pxSegment;
 394:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				break;
 395:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
 396:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 397:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 398:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		return pxReturn;
 399:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
 111              	 .loc 1 399 0
 112 002c 5DF8044B 	 ldr r4,[sp],#4
 113              	.LCFI1:
 114              	 .cfi_restore 4
 115              	 .cfi_def_cfa_offset 0
 116              	.LVL12:
 117 0030 7047     	 bx lr
 118              	 .cfi_endproc
 119              	.LFE60:
 121              	 .section .text.prvTCPWindowTxHasSpace,"ax",%progbits
 122              	 .align 2
 123              	 .thumb
 124              	 .thumb_func
 126              	prvTCPWindowTxHasSpace:
 127              	.LFB75:
 400:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 401:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #endif /* ipconfigUSE_TCP_WIN == 1 */
 402:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*-----------------------------------------------------------*/
 403:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 404:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #if( ipconfigUSE_TCP_WIN == 1 )
 405:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 406:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	static TCPSegment_t *xTCPWindowNew( TCPWindow_t *pxWindow, uint32_t ulSequenceNumber, int32_t lCou
 407:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	{
 408:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	TCPSegment_t *pxSegment;
 409:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	ListItem_t * pxItem;
 410:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 411:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		/* Allocate a new segment.  The socket will borrow all segments from a
 412:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		common pool: 'xSegmentList', which is a list of 'TCPSegment_t' */
 413:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		if( listLIST_IS_EMPTY( &xSegmentList ) != pdFALSE )
 414:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 415:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			/* If the TCP-stack runs out of segments, you might consider
 416:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			increasing 'ipconfigTCP_WIN_SEG_COUNT'. */
 417:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			FreeRTOS_debug_printf( ( "xTCPWindow%cxNew: Error: all segments occupied\n", ( xIsForRx != 0 ) ?
 418:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			pxSegment = NULL;
 419:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 420:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		else
 421:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 422:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			/* Pop the item at the head of the list.  Semaphore protection is
 423:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			not required as only the IP task will call these functions.  */
 424:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			pxItem = ( ListItem_t * ) listGET_HEAD_ENTRY( &xSegmentList );
 425:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			pxSegment = ipCAST_PTR_TO_TYPE_PTR( TCPSegment_t, listGET_LIST_ITEM_OWNER( pxItem ) );
 426:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 427:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			configASSERT( pxItem != NULL );
 428:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			configASSERT( pxSegment != NULL );
 429:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 430:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			/* Remove the item from xSegmentList. */
 431:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			( void ) uxListRemove( pxItem );
 432:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 433:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			/* Add it to either the connections' Rx or Tx queue. */
 434:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			if( xIsForRx != 0 )
 435:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
 436:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				vListInsertFifo( &pxWindow->xRxSegments, pxItem );
 437:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
 438:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			else
 439:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
 440:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				vListInsertFifo( &pxWindow->xTxSegments, pxItem );
 441:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
 442:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 443:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			/* And set the segment's timer to zero */
 444:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			vTCPTimerSet( &pxSegment->xTransmitTimer );
 445:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 446:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			pxSegment->u.ulFlags = 0;
 447:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			pxSegment->u.bits.bIsForRx = ( xIsForRx != 0 ) ? 1U : 0U;
 448:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			pxSegment->lMaxLength = lCount;
 449:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			pxSegment->lDataLength = lCount;
 450:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			pxSegment->ulSequenceNumber = ulSequenceNumber;
 451:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			#if( ipconfigHAS_DEBUG_PRINTF != 0 )
 452:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
 453:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			static UBaseType_t xLowestLength = ipconfigTCP_WIN_SEG_COUNT;
 454:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			UBaseType_t xLength = listCURRENT_LIST_LENGTH( &xSegmentList );
 455:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 456:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				if( xLowestLength > xLength )
 457:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
 458:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					xLowestLength = xLength;
 459:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				}
 460:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
 461:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			#endif /* ipconfigHAS_DEBUG_PRINTF */
 462:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 463:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 464:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		return pxSegment;
 465:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
 466:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 467:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #endif /* ipconfigUSE_TCP_WIN == 1 */
 468:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*-----------------------------------------------------------*/
 469:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 470:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #if( ipconfigUSE_TCP_WIN == 1 )
 471:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 472:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	BaseType_t xTCPWindowRxEmpty( const TCPWindow_t *pxWindow )
 473:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	{
 474:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	BaseType_t xReturn;
 475:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 476:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		/* When the peer has a close request (FIN flag), the driver will check
 477:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		if there are missing packets in the Rx-queue.  It will accept the
 478:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		closure of the connection if both conditions are true:
 479:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		  - the Rx-queue is empty
 480:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		  - the highest Rx sequence number has been ACK'ed */
 481:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		if( listLIST_IS_EMPTY( ( &pxWindow->xRxSegments ) ) == pdFALSE )
 482:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 483:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			/* Rx data has been stored while earlier packets were missing. */
 484:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			xReturn = pdFALSE;
 485:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 486:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		else if( xSequenceGreaterThanOrEqual( pxWindow->rx.ulCurrentSequenceNumber, pxWindow->rx.ulHighes
 487:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 488:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			/* No Rx packets are being stored and the highest sequence number
 489:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			that has been received has been ACKed. */
 490:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			xReturn = pdTRUE;
 491:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 492:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		else
 493:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 494:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			FreeRTOS_debug_printf( ( "xTCPWindowRxEmpty: cur %lu highest %lu (empty)\n",
 495:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				( pxWindow->rx.ulCurrentSequenceNumber - pxWindow->rx.ulFirstSequenceNumber ),
 496:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				( pxWindow->rx.ulHighestSequenceNumber - pxWindow->rx.ulFirstSequenceNumber ) ) );
 497:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			xReturn = pdFALSE;
 498:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 499:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 500:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		return xReturn;
 501:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
 502:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 503:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #endif /* ipconfigUSE_TCP_WIN == 1 */
 504:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*-----------------------------------------------------------*/
 505:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 506:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #if( ipconfigUSE_TCP_WIN == 1 )
 507:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 508:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	static TCPSegment_t *xTCPWindowGetHead( const List_t *pxList )
 509:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	{
 510:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	TCPSegment_t *pxSegment;
 511:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	ListItem_t * pxItem;
 512:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 513:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		/* Detaches and returns the head of a queue. */
 514:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		if( listLIST_IS_EMPTY( pxList ) != pdFALSE )
 515:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 516:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			pxSegment = NULL;
 517:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 518:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		else
 519:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 520:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			pxItem = ( ListItem_t * ) listGET_HEAD_ENTRY( pxList );
 521:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			pxSegment = ipCAST_PTR_TO_TYPE_PTR( TCPSegment_t, listGET_LIST_ITEM_OWNER( pxItem ) );
 522:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 523:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			( void ) uxListRemove( pxItem );
 524:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 525:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 526:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		return pxSegment;
 527:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
 528:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 529:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #endif /* ipconfigUSE_TCP_WIN == 1 */
 530:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*-----------------------------------------------------------*/
 531:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 532:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #if( ipconfigUSE_TCP_WIN == 1 )
 533:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 534:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	static TCPSegment_t *xTCPWindowPeekHead( const List_t *pxList )
 535:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	{
 536:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	const ListItem_t *pxItem;
 537:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	TCPSegment_t *pxReturn;
 538:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 539:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		/* Returns the head of a queue but it won't be detached. */
 540:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		if( listLIST_IS_EMPTY( pxList ) != pdFALSE )
 541:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 542:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			pxReturn = NULL;
 543:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 544:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		else
 545:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 546:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			pxItem = ( ListItem_t * ) listGET_HEAD_ENTRY( pxList );
 547:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			pxReturn = ipCAST_PTR_TO_TYPE_PTR( TCPSegment_t, listGET_LIST_ITEM_OWNER( pxItem ) );
 548:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 549:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 550:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		return pxReturn;
 551:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
 552:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 553:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #endif /* ipconfigUSE_TCP_WIN == 1 */
 554:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*-----------------------------------------------------------*/
 555:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 556:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #if( ipconfigUSE_TCP_WIN == 1 )
 557:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 558:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	static void vTCPWindowFree( TCPSegment_t *pxSegment )
 559:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	{
 560:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		/*  Free entry pxSegment because it's not used any more.  The ownership
 561:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		will be passed back to the segment pool.
 562:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 563:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		Unlink it from one of the queues, if any. */
 564:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		if( listLIST_ITEM_CONTAINER( &( pxSegment->xQueueItem ) ) != NULL )
 565:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 566:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			( void ) uxListRemove( &( pxSegment->xQueueItem ) );
 567:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 568:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 569:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		pxSegment->ulSequenceNumber = 0UL;
 570:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		pxSegment->lDataLength = 0L;
 571:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		pxSegment->u.ulFlags = 0UL;
 572:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 573:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		/* Take it out of xRxSegments/xTxSegments */
 574:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		if( listLIST_ITEM_CONTAINER( &( pxSegment->xSegmentItem ) ) != NULL )
 575:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 576:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			( void ) uxListRemove( &( pxSegment->xSegmentItem ) );
 577:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 578:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 579:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		/* Return it to xSegmentList */
 580:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		vListInsertFifo( &xSegmentList, &( pxSegment->xSegmentItem ) );
 581:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
 582:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 583:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #endif /* ipconfigUSE_TCP_WIN == 1 */
 584:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*-----------------------------------------------------------*/
 585:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 586:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #if( ipconfigUSE_TCP_WIN == 1 )
 587:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 588:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	void vTCPWindowDestroy( TCPWindow_t const * pxWindow )
 589:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	{
 590:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	const List_t * pxSegments;
 591:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	BaseType_t xRound;
 592:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	TCPSegment_t *pxSegment;
 593:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 594:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		/*  Destroy a window.  A TCP window doesn't serve any more.  Return all
 595:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		owned segments to the pool.  In order to save code, it will make 2 rounds,
 596:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		one to remove the segments from xRxSegments, and a second round to clear
 597:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		xTxSegments*/
 598:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		for( xRound = 0; xRound < 2; xRound++ )
 599:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 600:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			if( xRound != 0 )
 601:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
 602:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				pxSegments = &( pxWindow->xRxSegments );
 603:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
 604:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			else
 605:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
 606:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				pxSegments = &( pxWindow->xTxSegments );
 607:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
 608:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 609:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			if( listLIST_IS_INITIALISED( pxSegments ) )
 610:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
 611:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				while( listCURRENT_LIST_LENGTH( pxSegments ) > 0U )
 612:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
 613:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					pxSegment = ipCAST_PTR_TO_TYPE_PTR( TCPSegment_t, listGET_OWNER_OF_HEAD_ENTRY( pxSegments ) );
 614:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					vTCPWindowFree( pxSegment );
 615:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				}
 616:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
 617:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 618:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
 619:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 620:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #endif /* ipconfigUSE_TCP_WIN == 1 */
 621:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*-----------------------------------------------------------*/
 622:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 623:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** void vTCPWindowCreate( TCPWindow_t *pxWindow, uint32_t ulRxWindowLength,
 624:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	uint32_t ulTxWindowLength, uint32_t ulAckNumber, uint32_t ulSequenceNumber, uint32_t ulMSS )
 625:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** {
 626:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	/* Create and initialize a window. */
 627:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 628:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	#if( ipconfigUSE_TCP_WIN == 1 )
 629:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	{
 630:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		if( xTCPSegments == NULL )
 631:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 632:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			( void ) prvCreateSectors();
 633:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 634:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 635:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		vListInitialise( &( pxWindow->xTxSegments ) );
 636:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		vListInitialise( &( pxWindow->xRxSegments ) );
 637:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 638:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		vListInitialise( &( pxWindow->xPriorityQueue ) );	/* Priority queue: segments which must be sent 
 639:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		vListInitialise( &( pxWindow->xTxQueue ) );			/* Transmit queue: segments queued for transmission
 640:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		vListInitialise( &( pxWindow->xWaitQueue ) );		/* Waiting queue:  outstanding segments */
 641:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
 642:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	#endif /* ipconfigUSE_TCP_WIN == 1 */
 643:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 644:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	if( xTCPWindowLoggingLevel != 0 )
 645:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	{
 646:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		FreeRTOS_debug_printf( ( "vTCPWindowCreate: for WinLen = Rx/Tx: %lu/%lu\n",
 647:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			ulRxWindowLength, ulTxWindowLength ) );
 648:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
 649:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 650:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	pxWindow->xSize.ulRxWindowLength = ulRxWindowLength;
 651:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	pxWindow->xSize.ulTxWindowLength = ulTxWindowLength;
 652:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 653:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	vTCPWindowInit( pxWindow, ulAckNumber, ulSequenceNumber, ulMSS );
 654:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** }
 655:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*-----------------------------------------------------------*/
 656:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 657:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** void vTCPWindowInit( TCPWindow_t *pxWindow, uint32_t ulAckNumber, uint32_t ulSequenceNumber, uint32
 658:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** {
 659:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** const int32_t l500ms = 500;
 660:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 661:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	pxWindow->u.ulFlags = 0UL;
 662:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	pxWindow->u.bits.bHasInit = pdTRUE_UNSIGNED;
 663:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 664:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	if( ulMSS != 0UL )
 665:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	{
 666:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		if( pxWindow->usMSSInit != 0U )
 667:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 668:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			pxWindow->usMSSInit = ( uint16_t ) ulMSS;
 669:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 670:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 671:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		if( ( ulMSS < ( uint32_t ) pxWindow->usMSS ) || ( pxWindow->usMSS == 0U ) )
 672:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 673:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			pxWindow->xSize.ulRxWindowLength = ( pxWindow->xSize.ulRxWindowLength / ulMSS ) * ulMSS;
 674:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			pxWindow->usMSS = ( uint16_t ) ulMSS;
 675:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 676:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
 677:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 678:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	#if( ipconfigUSE_TCP_WIN == 0 )
 679:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	{
 680:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		pxWindow->xTxSegment.lMaxLength = ( int32_t ) pxWindow->usMSS;
 681:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
 682:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	#endif /* ipconfigUSE_TCP_WIN == 1 */
 683:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 684:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	/*Start with a timeout of 2 * 500 ms (1 sec). */
 685:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	pxWindow->lSRTT = l500ms;
 686:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 687:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	/* Just for logging, to print relative sequence numbers. */
 688:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	pxWindow->rx.ulFirstSequenceNumber = ulAckNumber;
 689:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 690:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	/* The segment asked for in the next transmission. */
 691:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	pxWindow->rx.ulCurrentSequenceNumber = ulAckNumber;
 692:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 693:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	/* The right-hand side of the receive window. */
 694:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	pxWindow->rx.ulHighestSequenceNumber = ulAckNumber;
 695:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 696:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	pxWindow->tx.ulFirstSequenceNumber = ulSequenceNumber;
 697:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 698:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	/* The segment asked for in next transmission. */
 699:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	pxWindow->tx.ulCurrentSequenceNumber = ulSequenceNumber;
 700:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 701:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	/* The sequence number given to the next outgoing byte to be added is
 702:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	maintained by lTCPWindowTxAdd(). */
 703:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	pxWindow->ulNextTxSequenceNumber = ulSequenceNumber;
 704:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 705:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	/* The right-hand side of the transmit window. */
 706:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	pxWindow->tx.ulHighestSequenceNumber = ulSequenceNumber;
 707:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	pxWindow->ulOurSequenceNumber = ulSequenceNumber;
 708:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** }
 709:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*-----------------------------------------------------------*/
 710:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 711:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #if( ipconfigUSE_TCP_WIN == 1 )
 712:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 713:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****     void vTCPSegmentCleanup( void )
 714:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****     {
 715:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****         /* Free and clear the TCP segments pointer. This function should only be called
 716:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****          * once FreeRTOS+TCP will no longer be used. No thread-safety is provided for this
 717:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****          * function. */
 718:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****         if( xTCPSegments != NULL )
 719:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****         {
 720:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****             vPortFreeLarge( xTCPSegments );
 721:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****             xTCPSegments = NULL;
 722:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****         }
 723:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****     }
 724:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 725:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #endif /* ipconfgiUSE_TCP_WIN == 1 */
 726:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*-----------------------------------------------------------*/
 727:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 728:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*=============================================================================
 729:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  *
 730:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  *                ######        #    #
 731:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  *                 #    #       #    #
 732:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  *                 #    #       #    #
 733:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  *                 #    #        ####
 734:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  *                 ######         ##
 735:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  *                 #  ##         ####
 736:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  *                 #   #        #    #
 737:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  *                 #    #       #    #
 738:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  *                ###  ##       #    #
 739:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * Rx functions
 740:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  *
 741:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  *=============================================================================*/
 742:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 743:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #if( ipconfigUSE_TCP_WIN == 1 )
 744:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 745:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	static TCPSegment_t *xTCPWindowRxConfirm( const TCPWindow_t *pxWindow, uint32_t ulSequenceNumber, 
 746:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	{
 747:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	TCPSegment_t *pxBest = NULL;
 748:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	const ListItem_t *pxIterator;
 749:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	uint32_t ulNextSequenceNumber = ulSequenceNumber + ulLength;
 750:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	const ListItem_t * pxEnd = listGET_END_MARKER( &pxWindow->xRxSegments );
 751:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	TCPSegment_t *pxSegment;
 752:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 753:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		/* A segment has been received with sequence number 'ulSequenceNumber',
 754:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		where 'ulCurrentSequenceNumber == ulSequenceNumber', which means that
 755:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		exactly this segment was expected.  xTCPWindowRxConfirm() will check if
 756:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		there is already another segment with a sequence number between (ulSequenceNumber)
 757:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		and (ulSequenceNumber+ulLength).  Normally none will be found, because
 758:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		the next RX segment should have a sequence number equal to
 759:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		'(ulSequenceNumber+ulLength)'. */
 760:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 761:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		/* Iterate through all RX segments that are stored: */
 762:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		for( pxIterator  = listGET_NEXT( pxEnd );
 763:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			 pxIterator != pxEnd;
 764:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			 pxIterator  = listGET_NEXT( pxIterator ) )
 765:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 766:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			pxSegment = ipCAST_PTR_TO_TYPE_PTR( TCPSegment_t, listGET_LIST_ITEM_OWNER( pxIterator ) );
 767:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			/* And see if there is a segment for which:
 768:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			'ulSequenceNumber' <= 'pxSegment->ulSequenceNumber' < 'ulNextSequenceNumber'
 769:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			If there are more matching segments, the one with the lowest sequence number
 770:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			shall be taken */
 771:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			if( ( xSequenceGreaterThanOrEqual( pxSegment->ulSequenceNumber, ulSequenceNumber ) != 0 ) &&
 772:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				( xSequenceLessThan( pxSegment->ulSequenceNumber, ulNextSequenceNumber ) != 0 ) )
 773:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
 774:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				if( ( pxBest == NULL ) || ( xSequenceLessThan( pxSegment->ulSequenceNumber, pxBest->ulSequenceN
 775:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
 776:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					pxBest = pxSegment;
 777:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				}
 778:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
 779:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 780:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 781:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		if( ( pxBest != NULL ) &&
 782:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			( ( pxBest->ulSequenceNumber != ulSequenceNumber ) || ( pxBest->lDataLength != ( int32_t ) ulLen
 783:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 784:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			FreeRTOS_debug_printf( ( "xTCPWindowRxConfirm[%u]: search %lu (+%ld=%lu) found %lu (+%ld=%lu)\n"
 785:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				pxWindow->usPeerPortNumber,
 786:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				ulSequenceNumber - pxWindow->rx.ulFirstSequenceNumber,
 787:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				ulLength,
 788:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				ulSequenceNumber + ulLength - pxWindow->rx.ulFirstSequenceNumber,
 789:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				pxBest->ulSequenceNumber - pxWindow->rx.ulFirstSequenceNumber,
 790:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				pxBest->lDataLength,
 791:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				pxBest->ulSequenceNumber + ( ( uint32_t ) pxBest->lDataLength ) - pxWindow->rx.ulFirstSequenceN
 792:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 793:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 794:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		return pxBest;
 795:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
 796:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 797:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #endif /* ipconfgiUSE_TCP_WIN == 1 */
 798:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*-----------------------------------------------------------*/
 799:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 800:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #if( ipconfigUSE_TCP_WIN == 1 )
 801:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 802:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	int32_t lTCPWindowRxCheck( TCPWindow_t *pxWindow, uint32_t ulSequenceNumber, uint32_t ulLength, ui
 803:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	{
 804:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	uint32_t ulCurrentSequenceNumber, ulLast, ulSavedSequenceNumber, ulIntermediateResult = 0;
 805:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	int32_t lReturn, lDistance;
 806:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	TCPSegment_t *pxFound;
 807:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 808:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		/* If lTCPWindowRxCheck( ) returns == 0, the packet will be passed
 809:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		directly to user (segment is expected).  If it returns a positive
 810:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		number, an earlier packet is missing, but this packet may be stored.
 811:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		If negative, the packet has already been stored, or it is out-of-order,
 812:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		or there is not enough space.
 813:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 814:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		As a side-effect, pxWindow->ulUserDataLength will get set to non-zero,
 815:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		if more Rx data may be passed to the user after this packet. */
 816:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 817:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		ulCurrentSequenceNumber = pxWindow->rx.ulCurrentSequenceNumber;
 818:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 819:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		/* For Selective Ack (SACK), used when out-of-sequence data come in. */
 820:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		pxWindow->ucOptionLength = 0U;
 821:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 822:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		/* Non-zero if TCP-windows contains data which must be popped. */
 823:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		pxWindow->ulUserDataLength = 0UL;
 824:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 825:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		if( ulCurrentSequenceNumber == ulSequenceNumber )
 826:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 827:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			/* This is the packet with the lowest sequence number we're waiting
 828:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			for.  It can be passed directly to the rx stream. */
 829:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			if( ulLength > ulSpace )
 830:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
 831:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				FreeRTOS_debug_printf( ( "lTCPWindowRxCheck: Refuse %lu bytes, due to lack of space (%lu)\n", u
 832:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				lReturn = -1;
 833:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
 834:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			else
 835:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
 836:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				ulCurrentSequenceNumber += ulLength;
 837:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 838:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				if( listCURRENT_LIST_LENGTH( &( pxWindow->xRxSegments ) ) != 0U )
 839:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
 840:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					ulSavedSequenceNumber = ulCurrentSequenceNumber;
 841:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 842:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****                     /* Clean up all sequence received between ulSequenceNumber and ulSequenceNumber
 843:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****                     If the server is forced to retransmit packets several time in a row it might se
 844:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****                     So we cannot rely on the packets between ulSequenceNumber and ulSequenceNumber 
 845:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****                     clean them out. */
 846:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****                     do
 847:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****                     {
 848:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****                         pxFound = xTCPWindowRxConfirm( pxWindow, ulSequenceNumber, ulLength );
 849:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 850:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****                         if ( pxFound != NULL )
 851:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****                         {
 852:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****                             /* Remove it because it will be passed to user directly. */
 853:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****                             vTCPWindowFree( pxFound );
 854:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****                         }
 855:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****                     } while ( pxFound != NULL );
 856:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 857:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					/*  Check for following segments that are already in the
 858:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					queue and increment ulCurrentSequenceNumber. */
 859:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					for( ;; )
 860:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					{
 861:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						pxFound = xTCPWindowRxFind( pxWindow, ulCurrentSequenceNumber );
 862:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						if( pxFound == NULL )
 863:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						{
 864:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 							break;
 865:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						}
 866:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						ulCurrentSequenceNumber += ( uint32_t ) pxFound->lDataLength;
 867:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 868:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						/* As all packet below this one have been passed to the
 869:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						user it can be discarded. */
 870:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						vTCPWindowFree( pxFound );
 871:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					}
 872:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 873:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					if( ulSavedSequenceNumber != ulCurrentSequenceNumber )
 874:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					{
 875:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						/*  After the current data-package, there is more data
 876:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						to be popped. */
 877:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						pxWindow->ulUserDataLength = ulCurrentSequenceNumber - ulSavedSequenceNumber;
 878:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 879:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						if( xTCPWindowLoggingLevel >= 1 )
 880:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						{
 881:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 							FreeRTOS_debug_printf( ( "lTCPWindowRxCheck[%d,%d]: retran %lu (Found %lu bytes at %lu cnt %
 882:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 								pxWindow->usPeerPortNumber, pxWindow->usOurPortNumber,
 883:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 								ulSequenceNumber - pxWindow->rx.ulFirstSequenceNumber,
 884:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 								pxWindow->ulUserDataLength,
 885:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 								ulSavedSequenceNumber - pxWindow->rx.ulFirstSequenceNumber,
 886:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 								listCURRENT_LIST_LENGTH( &pxWindow->xRxSegments ) ) );
 887:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						}
 888:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					}
 889:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				}
 890:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 891:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				pxWindow->rx.ulCurrentSequenceNumber = ulCurrentSequenceNumber;
 892:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 893:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				/* Packet was expected, may be passed directly to the socket
 894:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				buffer or application.  Store the packet at offset 0. */
 895:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				lReturn = 0;
 896:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
 897:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 898:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		else if( ulCurrentSequenceNumber == ( ulSequenceNumber + 1UL ) )
 899:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 900:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			/* Looks like a TCP keep-alive message.  Do not accept/store Rx data
 901:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			ulUserDataLength = 0. Not packet out-of-sync.  Just reply to it. */
 902:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			lReturn = -1;
 903:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 904:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		else
 905:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 906:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			/* The packet is not the one expected.  See if it falls within the Rx
 907:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			window so it can be stored. */
 908:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 909:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			/*  An "out-of-sequence" segment was received, must have missed one.
 910:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			Prepare a SACK (Selective ACK). */
 911:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			ulLast = ulSequenceNumber + ulLength;
 912:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 913:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			ulIntermediateResult = ulLast - ulCurrentSequenceNumber;
 914:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			/* The cast from unsigned long to signed long is on purpose. */
 915:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			lDistance = ( int32_t ) ulIntermediateResult;
 916:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 917:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			if( lDistance <= 0 )
 918:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
 919:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				/* An earlier has been received, must be a retransmission of a
 920:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				packet that has been accepted already.  No need to send out a
 921:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				Selective ACK (SACK). */
 922:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				lReturn = -1;
 923:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
 924:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			else if( lDistance > ( int32_t ) ulSpace )
 925:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
 926:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				/* The new segment is ahead of rx.ulCurrentSequenceNumber.  The
 927:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				sequence number of this packet is too far ahead, ignore it. */
 928:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				FreeRTOS_debug_printf( ( "lTCPWindowRxCheck: Refuse %lu+%lu bytes, due to lack of space (%lu)\n
 929:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				lReturn = -1;
 930:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
 931:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			else
 932:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
 933:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				/* See if there is more data in a contiguous block to make the
 934:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				SACK describe a longer range of data. */
 935:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 936:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				/* TODO: SACK's may also be delayed for a short period
 937:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				 * This is useful because subsequent packets will be SACK'd with
 938:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				 * single one message
 939:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				 */
 940:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				for( ;; )
 941:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
 942:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					pxFound = xTCPWindowRxFind( pxWindow, ulLast );
 943:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					if( pxFound == NULL )
 944:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					{
 945:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						break;
 946:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					}
 947:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					ulLast += ( uint32_t ) pxFound->lDataLength;
 948:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				}
 949:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 950:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				if( xTCPWindowLoggingLevel >= 1 )
 951:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
 952:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					FreeRTOS_debug_printf( ( "lTCPWindowRxCheck[%d,%d]: seqnr %u exp %u (dist %d) SACK to %u\n",
 953:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						( int ) pxWindow->usPeerPortNumber,
 954:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						( int ) pxWindow->usOurPortNumber,
 955:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						( unsigned ) ulSequenceNumber - pxWindow->rx.ulFirstSequenceNumber,
 956:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						( unsigned ) ulCurrentSequenceNumber - pxWindow->rx.ulFirstSequenceNumber,
 957:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						( unsigned ) ( ulSequenceNumber - ulCurrentSequenceNumber ),	/* want this signed */
 958:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						( unsigned ) ( ulLast - pxWindow->rx.ulFirstSequenceNumber ) ) );
 959:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				}
 960:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 961:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				/* Now prepare the SACK message.
 962:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				Code OPTION_CODE_SINGLE_SACK already in network byte order. */
 963:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				pxWindow->ulOptionsData[0] = OPTION_CODE_SINGLE_SACK;
 964:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 965:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				/* First sequence number that we received. */
 966:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				pxWindow->ulOptionsData[1] = FreeRTOS_htonl( ulSequenceNumber );
 967:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 968:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				/* Last + 1 */
 969:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				pxWindow->ulOptionsData[2] = FreeRTOS_htonl( ulLast );
 970:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 971:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				/* Which make 12 (3*4) option bytes. */
 972:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				pxWindow->ucOptionLength = ( uint8_t ) ( 3U * sizeof( pxWindow->ulOptionsData[ 0 ] ) );
 973:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 974:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				pxFound = xTCPWindowRxFind( pxWindow, ulSequenceNumber );
 975:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 976:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				if( pxFound != NULL )
 977:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
 978:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					/* This out-of-sequence packet has been received for a
 979:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					second time.  It is already stored but do send a SACK
 980:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					again. */
 981:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					lReturn = -1;
 982:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				}
 983:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				else
 984:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
 985:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					pxFound = xTCPWindowRxNew( pxWindow, ulSequenceNumber, ( int32_t ) ulLength );
 986:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 987:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					if( pxFound == NULL )
 988:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					{
 989:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						/* Can not send a SACK, because the segment cannot be
 990:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						stored. */
 991:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						pxWindow->ucOptionLength = 0U;
 992:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 993:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						/* Needs to be stored but there is no segment
 994:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						available. */
 995:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						lReturn = -1;
 996:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					}
 997:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					else
 998:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					{
 999:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						if( xTCPWindowLoggingLevel != 0 )
1000:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						{
1001:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 							FreeRTOS_debug_printf( ( "lTCPWindowRxCheck[%u,%u]: seqnr %lu (cnt %lu)\n",
1002:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 								pxWindow->usPeerPortNumber, pxWindow->usOurPortNumber, ulSequenceNumber - pxWindow->rx.ulFi
1003:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 								listCURRENT_LIST_LENGTH( &pxWindow->xRxSegments ) ) );
1004:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 							FreeRTOS_flush_logging( );
1005:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						}
1006:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1007:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						/* Return a positive value.  The packet may be accepted
1008:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						and stored but an earlier packet is still missing. */
1009:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						ulIntermediateResult = ulSequenceNumber - ulCurrentSequenceNumber;
1010:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						lReturn = ( int32_t ) ulIntermediateResult;
1011:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					}
1012:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				}
1013:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
1014:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
1015:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1016:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		return lReturn;
1017:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
1018:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1019:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #endif /* ipconfgiUSE_TCP_WIN == 1 */
1020:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*-----------------------------------------------------------*/
1021:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1022:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*=============================================================================
1023:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  *
1024:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  *                    #########   #    #
1025:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  *                    #   #   #   #    #
1026:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  *                        #       #    #
1027:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  *                        #        ####
1028:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  *                        #         ##
1029:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  *                        #        ####
1030:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  *                        #       #    #
1031:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  *                        #       #    #
1032:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  *                      #####     #    #
1033:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  *
1034:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  * Tx functions
1035:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  *
1036:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****  *=============================================================================*/
1037:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1038:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #if( ipconfigUSE_TCP_WIN == 1 )
1039:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1040:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	static int32_t lTCPIncrementTxPosition( int32_t lPosition, int32_t lMax, int32_t lCount )
1041:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	{
1042:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	int32_t lReturn;
1043:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1044:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		/* +TCP stores data in circular buffers.  Calculate the next position to
1045:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		store. */
1046:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		lReturn = lPosition + lCount;
1047:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		if( lReturn >= lMax )
1048:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
1049:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			lReturn -= lMax;
1050:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
1051:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1052:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		return lReturn;
1053:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
1054:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1055:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #endif /* ipconfigUSE_TCP_WIN == 1 */
1056:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*-----------------------------------------------------------*/
1057:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1058:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #if( ipconfigUSE_TCP_WIN == 1 )
1059:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1060:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	int32_t lTCPWindowTxAdd( TCPWindow_t *pxWindow, uint32_t ulLength, int32_t lPosition, int32_t lMax
1061:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	{
1062:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	int32_t lBytesLeft = ( int32_t ) ulLength, lToWrite;
1063:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	int32_t lDone = 0;
1064:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	int32_t lBufferIndex = lPosition;
1065:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	TCPSegment_t *pxSegment = pxWindow->pxHeadSegment;
1066:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1067:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		/* Puts a message in the Tx-window (after buffer size has been
1068:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		verified). */
1069:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		if( pxSegment != NULL )
1070:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
1071:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			if( pxSegment->lDataLength < pxSegment->lMaxLength )
1072:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
1073:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				if( ( pxSegment->u.bits.bOutstanding == pdFALSE_UNSIGNED ) && ( pxSegment->lDataLength != 0 ) )
1074:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
1075:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					/* Adding data to a segment that was already in the TX queue.  It
1076:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					will be filled-up to a maximum of MSS (maximum segment size). */
1077:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					lToWrite = FreeRTOS_min_int32( lBytesLeft, pxSegment->lMaxLength - pxSegment->lDataLength );
1078:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1079:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					pxSegment->lDataLength += lToWrite;
1080:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1081:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					if( pxSegment->lDataLength >= pxSegment->lMaxLength )
1082:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					{
1083:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						/* This segment is full, don't add more bytes. */
1084:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						pxWindow->pxHeadSegment = NULL;
1085:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					}
1086:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1087:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					lBytesLeft -= lToWrite;
1088:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1089:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					/* ulNextTxSequenceNumber is the sequence number of the next byte to
1090:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					be stored for transmission. */
1091:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					pxWindow->ulNextTxSequenceNumber += ( uint32_t ) lToWrite;
1092:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1093:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					/* Increased the return value. */
1094:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					lDone += lToWrite;
1095:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1096:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					/* Some detailed logging, for those who're interested. */
1097:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					if( ( xTCPWindowLoggingLevel >= 2 ) && ipconfigTCP_MAY_LOG_PORT( pxWindow->usOurPortNumber ) )
1098:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					{
1099:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						FreeRTOS_debug_printf( ( "lTCPWindowTxAdd: Add %4lu bytes for seqNr %lu len %4lu (nxt %lu) po
1100:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 							ulLength,
1101:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 							pxSegment->ulSequenceNumber - pxWindow->tx.ulFirstSequenceNumber,
1102:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 							pxSegment->lDataLength,
1103:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 							pxWindow->ulNextTxSequenceNumber - pxWindow->tx.ulFirstSequenceNumber,
1104:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 							pxSegment->lStreamPos ) );
1105:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						FreeRTOS_flush_logging( );
1106:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					}
1107:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1108:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					/* Calculate the next position in the circular data buffer, knowing
1109:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					its maximum length 'lMax'. */
1110:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					lBufferIndex = lTCPIncrementTxPosition( lBufferIndex, lMax, lToWrite );
1111:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				}
1112:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
1113:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
1114:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1115:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		while( lBytesLeft > 0 )
1116:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
1117:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			/* The current transmission segment is full, create new segments as
1118:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			needed. */
1119:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			pxSegment = xTCPWindowTxNew( pxWindow, pxWindow->ulNextTxSequenceNumber, ( int32_t ) pxWindow->u
1120:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1121:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			if( pxSegment != NULL )
1122:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
1123:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				/* Store as many as needed, but no more than the maximum
1124:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				(MSS). */
1125:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				lToWrite = FreeRTOS_min_int32( lBytesLeft, pxSegment->lMaxLength );
1126:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1127:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				pxSegment->lDataLength = lToWrite;
1128:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				pxSegment->lStreamPos = lBufferIndex;
1129:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				lBytesLeft -= lToWrite;
1130:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				lBufferIndex = lTCPIncrementTxPosition( lBufferIndex, lMax, lToWrite );
1131:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				pxWindow->ulNextTxSequenceNumber += ( uint32_t ) lToWrite;
1132:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				lDone += lToWrite;
1133:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1134:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				/* Link this segment in the Tx-Queue. */
1135:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				vListInsertFifo( &( pxWindow->xTxQueue ), &( pxSegment->xQueueItem ) );
1136:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1137:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				/* Let 'pxHeadSegment' point to this segment if there is still
1138:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				space. */
1139:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				if( pxSegment->lDataLength < pxSegment->lMaxLength )
1140:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
1141:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					pxWindow->pxHeadSegment = pxSegment;
1142:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				}
1143:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				else
1144:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
1145:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					pxWindow->pxHeadSegment = NULL;
1146:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				}
1147:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1148:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				if( ipconfigTCP_MAY_LOG_PORT( pxWindow->usOurPortNumber ) )
1149:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
1150:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					if( ( xTCPWindowLoggingLevel >= 3 ) ||
1151:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						( ( xTCPWindowLoggingLevel >= 2 ) && ( pxWindow->pxHeadSegment != NULL ) ) )
1152:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					{
1153:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						FreeRTOS_debug_printf( ( "lTCPWindowTxAdd: New %4ld bytes for seqNr %lu len %4lu (nxt %lu) po
1154:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 							ulLength,
1155:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 							pxSegment->ulSequenceNumber - pxWindow->tx.ulFirstSequenceNumber,
1156:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 							pxSegment->lDataLength,
1157:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 							pxWindow->ulNextTxSequenceNumber - pxWindow->tx.ulFirstSequenceNumber,
1158:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 							pxSegment->lStreamPos ) );
1159:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						FreeRTOS_flush_logging( );
1160:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					}
1161:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				}
1162:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
1163:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			else
1164:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
1165:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				/* A sever situation: running out of segments for transmission.
1166:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				No more data can be sent at the moment. */
1167:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				if( lDone != 0 )
1168:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
1169:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					FreeRTOS_debug_printf( ( "lTCPWindowTxAdd: Sorry all buffers full (cancel %ld bytes)\n", lByte
1170:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				}
1171:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				break;
1172:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
1173:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
1174:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1175:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		return lDone;
1176:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
1177:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1178:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #endif /* ipconfigUSE_TCP_WIN == 1 */
1179:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*-----------------------------------------------------------*/
1180:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1181:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #if( ipconfigUSE_TCP_WIN == 1 )
1182:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1183:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	BaseType_t xTCPWindowTxDone( const TCPWindow_t *pxWindow )
1184:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	{
1185:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		return listLIST_IS_EMPTY( ( &pxWindow->xTxSegments) );
1186:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
1187:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1188:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #endif /* ipconfigUSE_TCP_WIN == 1 */
1189:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*-----------------------------------------------------------*/
1190:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1191:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #if( ipconfigUSE_TCP_WIN == 1 )
1192:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1193:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	static BaseType_t prvTCPWindowTxHasSpace( TCPWindow_t const * pxWindow, uint32_t ulWindowSize )
1194:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	{
 128              	 .loc 1 1194 0
 129              	 .cfi_startproc
 130              	 
 131              	 
 132              	 
 133              	.LVL13:
 134              	.LBB83:
 135              	.LBB84:
 540:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 136              	 .loc 1 540 0
 137 0000 436D     	 ldr r3,[r0,#84]
 138 0002 C3B1     	 cbz r3,.L13
 139              	.LVL14:
 547:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 140              	 .loc 1 547 0
 141 0004 036E     	 ldr r3,[r0,#96]
 142 0006 DA68     	 ldr r2,[r3,#12]
 143              	.LVL15:
 144              	.LBE84:
 145              	.LBE83:
1195:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	uint32_t ulTxOutstanding;
1196:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	BaseType_t xHasSpace;
1197:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	const TCPSegment_t *pxSegment;
1198:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	uint32_t ulNettSize;
1199:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1200:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		/* This function will look if there is new transmission data.  It will
1201:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		return true if there is data to be sent. */
1202:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1203:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		pxSegment = xTCPWindowPeekHead( &( pxWindow->xTxQueue ) );
1204:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1205:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		if( pxSegment == NULL )
 146              	 .loc 1 1205 0
 147 0008 C2B1     	 cbz r2,.L14
1194:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	uint32_t ulTxOutstanding;
 148              	 .loc 1 1194 0
 149 000a 10B4     	 push {r4}
 150              	.LCFI2:
 151              	 .cfi_def_cfa_offset 4
 152              	 .cfi_offset 4,-4
1206:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
1207:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			xHasSpace = pdFALSE;
1208:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
1209:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		else
1210:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
1211:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			/* How much data is outstanding, i.e. how much data has been sent
1212:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			but not yet acknowledged ? */
1213:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			if( pxWindow->tx.ulHighestSequenceNumber >= pxWindow->tx.ulCurrentSequenceNumber )
 153              	 .loc 1 1213 0
 154 000c 836A     	 ldr r3,[r0,#40]
 155 000e 046A     	 ldr r4,[r0,#32]
 156 0010 A342     	 cmp r3,r4
 157 0012 15D3     	 bcc .L12
1214:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
1215:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				ulTxOutstanding = pxWindow->tx.ulHighestSequenceNumber - pxWindow->tx.ulCurrentSequenceNumber;
 158              	 .loc 1 1215 0
 159 0014 1B1B     	 subs r3,r3,r4
 160              	.LVL16:
1216:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
1217:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			else
1218:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
1219:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				ulTxOutstanding = 0UL;
1220:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
1221:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1222:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			/* Subtract this from the peer's space. */
1223:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			ulNettSize = ulWindowSize - FreeRTOS_min_uint32( ulWindowSize, ulTxOutstanding );
1224:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1225:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			/* See if the next segment may be sent. */
1226:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			if( ulNettSize >= ( uint32_t ) pxSegment->lDataLength )
 161              	 .loc 1 1226 0
 162 0016 9268     	 ldr r2,[r2,#8]
 163              	.LVL17:
1223:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 164              	 .loc 1 1223 0
 165 0018 9942     	 cmp r1,r3
 166 001a 94BF     	 ite ls
 167 001c 491A     	 subls r1,r1,r1
 168              	.LVL18:
 169 001e C91A     	 subhi r1,r1,r3
 170              	 .loc 1 1226 0
 171 0020 9142     	 cmp r1,r2
 172 0022 34BF     	 ite cc
 173 0024 0021     	 movcc r1,#0
 174 0026 0121     	 movcs r1,#1
 175              	.LVL19:
1227:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
1228:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				xHasSpace = pdTRUE;
1229:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
1230:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			else
1231:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
1232:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				xHasSpace = pdFALSE;
1233:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
1234:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1235:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			/* If 'xHasSpace', it looks like the peer has at least space for 1
1236:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			more new segment of size MSS.  xSize.ulTxWindowLength is the self-imposed
1237:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			limitation of the transmission window (in case of many resends it
1238:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			may be decreased). */
1239:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			if( ( ulTxOutstanding != 0UL ) && ( pxWindow->xSize.ulTxWindowLength < ( ulTxOutstanding + ( ( u
 176              	 .loc 1 1239 0
 177 0028 7BB1     	 cbz r3,.L15
 178              	 .loc 1 1239 0 is_stmt 0 discriminator 1
 179 002a 1344     	 add r3,r3,r2
 180              	.LVL20:
 181 002c 8268     	 ldr r2,[r0,#8]
1240:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
1241:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				xHasSpace = pdFALSE;
 182              	 .loc 1 1241 0 is_stmt 1 discriminator 1
 183 002e 9A42     	 cmp r2,r3
 184 0030 38BF     	 it cc
 185 0032 0021     	 movcc r1,#0
 186              	.LVL21:
 187 0034 09E0     	 b .L15
 188              	.LVL22:
 189              	.L13:
 190              	.LCFI3:
 191              	 .cfi_def_cfa_offset 0
 192              	 .cfi_restore 4
1207:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 193              	 .loc 1 1207 0
 194 0036 0021     	 movs r1,#0
 195              	.LVL23:
 196              	.L17:
1242:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
1243:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
1244:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1245:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		return xHasSpace;
1246:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
 197              	 .loc 1 1246 0
 198 0038 0846     	 mov r0,r1
 199              	.LVL24:
 200 003a 7047     	 bx lr
 201              	.LVL25:
 202              	.L14:
1207:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 203              	 .loc 1 1207 0
 204 003c 0021     	 movs r1,#0
 205              	.LVL26:
 206 003e FBE7     	 b .L17
 207              	.LVL27:
 208              	.L12:
 209              	.LCFI4:
 210              	 .cfi_def_cfa_offset 4
 211              	 .cfi_offset 4,-4
1226:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
 212              	 .loc 1 1226 0
 213 0040 9068     	 ldr r0,[r2,#8]
 214              	.LVL28:
 215 0042 8142     	 cmp r1,r0
 216 0044 34BF     	 ite cc
 217 0046 0021     	 movcc r1,#0
 218              	.LVL29:
 219 0048 0121     	 movcs r1,#1
 220              	.LVL30:
 221              	.L15:
 222              	 .loc 1 1246 0
 223 004a 0846     	 mov r0,r1
 224 004c 5DF8044B 	 ldr r4,[sp],#4
 225              	.LCFI5:
 226              	 .cfi_restore 4
 227              	 .cfi_def_cfa_offset 0
 228 0050 7047     	 bx lr
 229              	 .cfi_endproc
 230              	.LFE75:
 232 0052 00BF     	 .section .text.vTCPWindowFree,"ax",%progbits
 233              	 .align 2
 234              	 .thumb
 235              	 .thumb_func
 237              	vTCPWindowFree:
 238              	.LFB65:
 559:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		/*  Free entry pxSegment because it's not used any more.  The ownership
 239              	 .loc 1 559 0
 240              	 .cfi_startproc
 241              	 
 242              	 
 243              	.LVL31:
 244 0000 10B5     	 push {r4,lr}
 245              	.LCFI6:
 246              	 .cfi_def_cfa_offset 8
 247              	 .cfi_offset 4,-8
 248              	 .cfi_offset 14,-4
 249 0002 0446     	 mov r4,r0
 564:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 250              	 .loc 1 564 0
 251 0004 836A     	 ldr r3,[r0,#40]
 252 0006 13B1     	 cbz r3,.L19
 566:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 253              	 .loc 1 566 0
 254 0008 1830     	 adds r0,r0,#24
 255              	.LVL32:
 256 000a FFF7FEFF 	 bl uxListRemove
 257              	.LVL33:
 258              	.L19:
 569:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		pxSegment->lDataLength = 0L;
 259              	 .loc 1 569 0
 260 000e 0023     	 movs r3,#0
 261 0010 2360     	 str r3,[r4]
 570:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		pxSegment->u.ulFlags = 0UL;
 262              	 .loc 1 570 0
 263 0012 A360     	 str r3,[r4,#8]
 571:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 264              	 .loc 1 571 0
 265 0014 6361     	 str r3,[r4,#20]
 574:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 266              	 .loc 1 574 0
 267 0016 E36B     	 ldr r3,[r4,#60]
 268 0018 1BB1     	 cbz r3,.L20
 576:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 269              	 .loc 1 576 0
 270 001a 04F12C00 	 add r0,r4,#44
 271 001e FFF7FEFF 	 bl uxListRemove
 272              	.LVL34:
 273              	.L20:
 274              	.LBB85:
 275              	.LBB86:
 294:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
 276              	 .loc 1 294 0
 277 0022 044A     	 ldr r2,.L22
 278 0024 1046     	 mov r0,r2
 279 0026 04F12C01 	 add r1,r4,#44
 280              	.LVL35:
 281 002a 0832     	 adds r2,r2,#8
 282 002c FFF7FEFF 	 bl vListInsertGeneric
 283              	.LVL36:
 284 0030 10BD     	 pop {r4,pc}
 285              	.LVL37:
 286              	.L23:
 287 0032 00BF     	 .align 2
 288              	.L22:
 289 0034 00000000 	 .word .LANCHOR0
 290              	.LBE86:
 291              	.LBE85:
 292              	 .cfi_endproc
 293              	.LFE65:
 295              	 .section .text.xTCPWindowNew,"ax",%progbits
 296              	 .align 2
 297              	 .thumb
 298              	 .thumb_func
 300              	xTCPWindowNew:
 301              	.LFB61:
 407:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	TCPSegment_t *pxSegment;
 302              	 .loc 1 407 0
 303              	 .cfi_startproc
 304              	 
 305              	 
 306              	.LVL38:
 307 0000 2DE9F843 	 push {r3,r4,r5,r6,r7,r8,r9,lr}
 308              	.LCFI7:
 309              	 .cfi_def_cfa_offset 32
 310              	 .cfi_offset 3,-32
 311              	 .cfi_offset 4,-28
 312              	 .cfi_offset 5,-24
 313              	 .cfi_offset 6,-20
 314              	 .cfi_offset 7,-16
 315              	 .cfi_offset 8,-12
 316              	 .cfi_offset 9,-8
 317              	 .cfi_offset 14,-4
 413:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 318              	 .loc 1 413 0
 319 0004 234C     	 ldr r4,.L34
 320 0006 2468     	 ldr r4,[r4]
 321 0008 002C     	 cmp r4,#0
 322 000a 3FD0     	 beq .L32
 424:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			pxSegment = ipCAST_PTR_TO_TYPE_PTR( TCPSegment_t, listGET_LIST_ITEM_OWNER( pxItem ) );
 323              	 .loc 1 424 0
 324 000c 214C     	 ldr r4,.L34
 325 000e E768     	 ldr r7,[r4,#12]
 326              	.LVL39:
 425:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 327              	 .loc 1 425 0
 328 0010 FC68     	 ldr r4,[r7,#12]
 329              	.LVL40:
 427:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			configASSERT( pxSegment != NULL );
 330              	 .loc 1 427 0
 331 0012 47B9     	 cbnz r7,.L26
 332              	.LBB87:
 333              	.LBB88:
 334              	 .file 2 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h"
   1:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*
   2:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * FreeRTOS Kernel V10.4.1
   3:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
   5:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * this software and associated documentation files (the "Software"), to deal in
   7:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * the Software without restriction, including without limitation the rights to
   8:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * subject to the following conditions:
  11:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  12:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * The above copyright notice and this permission notice shall be included in all
  13:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * copies or substantial portions of the Software.
  14:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  15:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  22:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * https://www.FreeRTOS.org
  23:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * https://github.com/FreeRTOS
  24:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  25:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * 1 tab == 4 spaces!
  26:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  */
  27:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  28:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  29:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** #ifndef PORTMACRO_H
  30:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define PORTMACRO_H
  31:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  32:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifdef __cplusplus
  33:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         extern "C" {
  34:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
  35:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  36:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------
  37:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * Port specific definitions.
  38:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  39:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * The settings in this file configure FreeRTOS correctly for the
  40:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * given hardware and compiler.
  41:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  42:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * These settings should not be altered.
  43:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *-----------------------------------------------------------
  44:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  */
  45:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  46:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Type definitions. */
  47:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portCHAR          char
  48:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portFLOAT         float
  49:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portDOUBLE        double
  50:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portLONG          long
  51:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portSHORT         short
  52:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portSTACK_TYPE    uint32_t
  53:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portBASE_TYPE     long
  54:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  55:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     typedef portSTACK_TYPE   StackType_t;
  56:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     typedef long             BaseType_t;
  57:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     typedef unsigned long    UBaseType_t;
  58:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  59:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #if ( configUSE_16_BIT_TICKS == 1 )
  60:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         typedef uint16_t     TickType_t;
  61:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portMAX_DELAY              ( TickType_t ) 0xffff
  62:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #else
  63:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         typedef uint32_t     TickType_t;
  64:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portMAX_DELAY              ( TickType_t ) 0xffffffffUL
  65:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  66:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
  67:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * not need to be guarded with a critical section. */
  68:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portTICK_TYPE_IS_ATOMIC    1
  69:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
  70:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
  71:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  72:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Architecture specifics. */
  73:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portSTACK_GROWTH      ( -1 )
  74:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portTICK_PERIOD_MS    ( ( TickType_t ) 1000 / configTICK_RATE_HZ )
  75:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portBYTE_ALIGNMENT    8
  76:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portDONT_DISCARD      __attribute__( ( used ) )
  77:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
  78:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  79:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Scheduler utilities. */
  80:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portYIELD()                                 \
  81:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     {                                                   \
  82:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         /* Set a PendSV to request a context switch. */ \
  83:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT; \
  84:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****                                                         \
  85:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         /* Barriers are normally not required but do ensure the code is completely \
  86:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****          * within the specified behaviour for the architecture. */ \
  87:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile ( "dsb" ::: "memory" );                     \
  88:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile ( "isb" );                                  \
  89:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     }
  90:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  91:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portNVIC_INT_CTRL_REG     ( *( ( volatile uint32_t * ) 0xe000ed04 ) )
  92:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portNVIC_PENDSVSET_BIT    ( 1UL << 28UL )
  93:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portEND_SWITCHING_ISR( xSwitchRequired )    if( xSwitchRequired != pdFALSE ) portYIELD(
  94:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portYIELD_FROM_ISR( x )                     portEND_SWITCHING_ISR( x )
  95:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
  96:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  97:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Critical section management. */
  98:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     extern void vPortEnterCritical( void );
  99:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     extern void vPortExitCritical( void );
 100:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portSET_INTERRUPT_MASK_FROM_ISR()         ulPortRaiseBASEPRI()
 101:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portCLEAR_INTERRUPT_MASK_FROM_ISR( x )    vPortSetBASEPRI( x )
 102:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portDISABLE_INTERRUPTS()                  vPortRaiseBASEPRI()
 103:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portENABLE_INTERRUPTS()                   vPortSetBASEPRI( 0 )
 104:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portENTER_CRITICAL()                      vPortEnterCritical()
 105:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portEXIT_CRITICAL()                       vPortExitCritical()
 106:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 107:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 108:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 109:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Task function macros as described on the FreeRTOS.org WEB site.  These are
 110:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * not necessary for to use this port.  They are defined so the common demo files
 111:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * (which build with all the ports) will build. */
 112:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portTASK_FUNCTION_PROTO( vFunction, pvParameters )    void vFunction( void * pvParamete
 113:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portTASK_FUNCTION( vFunction, pvParameters )          void vFunction( void * pvParamete
 114:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 115:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 116:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Tickless idle/low power functionality. */
 117:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifndef portSUPPRESS_TICKS_AND_SLEEP
 118:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
 119:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime )    vPortSuppressTicksAndSleep( xE
 120:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
 121:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 122:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 123:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Architecture specific optimisations. */
 124:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
 125:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define configUSE_PORT_OPTIMISED_TASK_SELECTION    1
 126:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
 127:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 128:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
 129:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 130:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Generic helper function. */
 131:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t 
 132:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         {
 133:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             uint8_t ucReturn;
 134:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 135:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             __asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 136:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 137:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             return ucReturn;
 138:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         }
 139:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 140:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Check the configuration. */
 141:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #if ( configMAX_PRIORITIES > 32 )
 142:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             #error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIO
 143:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #endif
 144:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 145:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Store/clear the ready priorities in a bit map. */
 146:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities )    ( uxReadyPriorities )
 147:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities )     ( uxReadyPriorities )
 148:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 149:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 150:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 151:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities )    uxTopPriority = ( 3
 152:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 153:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 154:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 155:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 156:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 157:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifdef configASSERT
 158:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         void vPortValidateInterruptPriority( void );
 159:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portASSERT_IF_INTERRUPT_PRIORITY_INVALID()    vPortValidateInterruptPriority()
 160:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
 161:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 162:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* portNOP() is not required by this port. */
 163:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portNOP()
 164:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 165:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portINLINE              __inline
 166:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 167:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifndef portFORCE_INLINE
 168:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portFORCE_INLINE    inline __attribute__( ( always_inline ) )
 169:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
 170:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 171:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     portFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )
 172:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     {
 173:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         uint32_t ulCurrentInterrupt;
 174:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         BaseType_t xReturn;
 175:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 176:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         /* Obtain the number of the currently executing interrupt. */
 177:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile ( "mrs %0, ipsr" : "=r" ( ulCurrentInterrupt )::"memory" );
 178:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 179:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         if( ulCurrentInterrupt == 0 )
 180:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         {
 181:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             xReturn = pdFALSE;
 182:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         }
 183:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         else
 184:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         {
 185:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             xReturn = pdTRUE;
 186:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         }
 187:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 188:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         return xReturn;
 189:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     }
 190:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 191:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 192:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 193:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     portFORCE_INLINE static void vPortRaiseBASEPRI( void )
 194:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     {
 195:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         uint32_t ulNewBASEPRI;
 196:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile
 335              	 .loc 2 197 0
 336              	
 337 0014 4FF01403 	 mov r3,#20
 338 0018 83F31188 	 msr basepri,r3
 339 001c BFF36F8F 	 isb 
 340 0020 BFF34F8F 	 dsb 
 341              	
 342              	
 343              	.LVL41:
 344              	 .thumb
 345              	.L27:
 346              	.LBE88:
 347              	.LBE87:
 427:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			configASSERT( pxSegment != NULL );
 348              	 .loc 1 427 0 discriminator 1
 349 0024 FEE7     	 b .L27
 350              	.LVL42:
 351              	.L26:
 428:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 352              	 .loc 1 428 0
 353 0026 44B9     	 cbnz r4,.L28
 354              	.LBB89:
 355              	.LBB90:
 356              	 .loc 2 197 0
 357              	
 358 0028 4FF01403 	 mov r3,#20
 359 002c 83F31188 	 msr basepri,r3
 360 0030 BFF36F8F 	 isb 
 361 0034 BFF34F8F 	 dsb 
 362              	
 363              	
 364              	.LVL43:
 365              	 .thumb
 366              	.L29:
 367              	.LBE90:
 368              	.LBE89:
 428:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 369              	 .loc 1 428 0 discriminator 2
 370 0038 FEE7     	 b .L29
 371              	.LVL44:
 372              	.L28:
 373 003a 1D46     	 mov r5,r3
 374 003c 9046     	 mov r8,r2
 375 003e 8946     	 mov r9,r1
 376 0040 0646     	 mov r6,r0
 431:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 377              	 .loc 1 431 0
 378 0042 3846     	 mov r0,r7
 379              	.LVL45:
 380 0044 FFF7FEFF 	 bl uxListRemove
 381              	.LVL46:
 434:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
 382              	 .loc 1 434 0
 383 0048 3DB1     	 cbz r5,.L30
 384              	.LVL47:
 385              	.LBB91:
 386              	.LBB92:
 294:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
 387              	 .loc 1 294 0
 388 004a 06F1A400 	 add r0,r6,#164
 389              	.LVL48:
 390 004e 3946     	 mov r1,r7
 391 0050 06F1AC02 	 add r2,r6,#172
 392 0054 FFF7FEFF 	 bl vListInsertGeneric
 393              	.LVL49:
 394 0058 06E0     	 b .L31
 395              	.LVL50:
 396              	.L30:
 397              	.LBE92:
 398              	.LBE91:
 399              	.LBB93:
 400              	.LBB94:
 401 005a 06F19000 	 add r0,r6,#144
 402              	.LVL51:
 403 005e 3946     	 mov r1,r7
 404 0060 06F19802 	 add r2,r6,#152
 405 0064 FFF7FEFF 	 bl vListInsertGeneric
 406              	.LVL52:
 407              	.L31:
 408              	.LBE94:
 409              	.LBE93:
 410              	.LBB95:
 411              	.LBB96:
 302:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** }
 412              	 .loc 1 302 0
 413 0068 FFF7FEFF 	 bl xTaskGetTickCount
 414              	.LVL53:
 415 006c 2061     	 str r0,[r4,#16]
 416              	.LBE96:
 417              	.LBE95:
 446:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			pxSegment->u.bits.bIsForRx = ( xIsForRx != 0 ) ? 1U : 0U;
 418              	 .loc 1 446 0
 419 006e 0023     	 movs r3,#0
 420 0070 6361     	 str r3,[r4,#20]
 447:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			pxSegment->lMaxLength = lCount;
 421              	 .loc 1 447 0
 422 0072 ED1A     	 subs r5,r5,r3
 423              	.LVL54:
 424 0074 18BF     	 it ne
 425 0076 0125     	 movne r5,#1
 426 0078 65F38203 	 bfi r3,r5,#2,#1
 427 007c A375     	 strb r3,[r4,#22]
 448:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			pxSegment->lDataLength = lCount;
 428              	 .loc 1 448 0
 429 007e C4F80480 	 str r8,[r4,#4]
 449:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			pxSegment->ulSequenceNumber = ulSequenceNumber;
 430              	 .loc 1 449 0
 431 0082 C4F80880 	 str r8,[r4,#8]
 450:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			#if( ipconfigHAS_DEBUG_PRINTF != 0 )
 432              	 .loc 1 450 0
 433 0086 C4F80090 	 str r9,[r4]
 434 008a 00E0     	 b .L25
 435              	.LVL55:
 436              	.L32:
 418:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 437              	 .loc 1 418 0
 438 008c 0024     	 movs r4,#0
 439              	.LVL56:
 440              	.L25:
 465:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 441              	 .loc 1 465 0
 442 008e 2046     	 mov r0,r4
 443 0090 BDE8F883 	 pop {r3,r4,r5,r6,r7,r8,r9,pc}
 444              	.LVL57:
 445              	.L35:
 446              	 .align 2
 447              	.L34:
 448 0094 00000000 	 .word .LANCHOR0
 449              	 .cfi_endproc
 450              	.LFE61:
 452              	 .section .text.prvTCPWindowTxCheckAck,"ax",%progbits
 453              	 .align 2
 454              	 .thumb
 455              	 .thumb_func
 457              	prvTCPWindowTxCheckAck:
 458              	.LFB78:
1247:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1248:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #endif /* ipconfigUSE_TCP_WIN == 1 */
1249:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*-----------------------------------------------------------*/
1250:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1251:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #if( ipconfigUSE_TCP_WIN == 1 )
1252:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1253:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	BaseType_t xTCPWindowTxHasData( TCPWindow_t const * pxWindow, uint32_t ulWindowSize, TickType_t *p
1254:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	{
1255:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	TCPSegment_t const * pxSegment;
1256:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	BaseType_t xReturn;
1257:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	TickType_t ulAge, ulMaxAge;
1258:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1259:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		*pulDelay = 0U;
1260:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1261:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		if( listLIST_IS_EMPTY( &pxWindow->xPriorityQueue ) == pdFALSE )
1262:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
1263:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			/* No need to look at retransmissions or new transmission as long as
1264:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			there are priority segments.  *pulDelay equals zero, meaning it must
1265:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			be sent out immediately. */
1266:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			xReturn = pdTRUE;
1267:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
1268:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		else
1269:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
1270:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			pxSegment = xTCPWindowPeekHead( &( pxWindow->xWaitQueue ) );
1271:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1272:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			if( pxSegment != NULL )
1273:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
1274:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				/* There is an outstanding segment, see if it is time to resend
1275:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				it. */
1276:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				ulAge = ulTimerGetAge( &pxSegment->xTransmitTimer );
1277:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1278:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				/* After a packet has been sent for the first time, it will wait
1279:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				'1 * lSRTT' ms for an ACK. A second time it will wait '2 * lSRTT' ms,
1280:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				each time doubling the time-out */
1281:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				ulMaxAge = ( 1UL << pxSegment->u.bits.ucTransmitCount ) * ( ( uint32_t ) pxWindow->lSRTT );
1282:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1283:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				if( ulMaxAge > ulAge )
1284:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
1285:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					/* A segment must be sent after this amount of msecs */
1286:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					*pulDelay = ulMaxAge - ulAge;
1287:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				}
1288:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1289:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				xReturn = pdTRUE;
1290:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
1291:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			else
1292:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
1293:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				/* No priority segment, no outstanding data, see if there is new
1294:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				transmission data. */
1295:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				pxSegment = xTCPWindowPeekHead( &pxWindow->xTxQueue );
1296:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1297:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				/* See if it fits in the peer's reception window. */
1298:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				if( pxSegment == NULL )
1299:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
1300:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					xReturn = pdFALSE;
1301:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				}
1302:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				else if( prvTCPWindowTxHasSpace( pxWindow, ulWindowSize ) == pdFALSE )
1303:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
1304:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					/* Too many outstanding messages. */
1305:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					xReturn = pdFALSE;
1306:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				}
1307:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				else if( ( pxWindow->u.bits.bSendFullSize != pdFALSE_UNSIGNED ) && ( pxSegment->lDataLength < p
1308:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
1309:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					/* 'bSendFullSize' is a special optimisation.  If true, the
1310:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					driver will only sent completely filled packets (of MSS
1311:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					bytes). */
1312:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					xReturn = pdFALSE;
1313:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				}
1314:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				else
1315:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
1316:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					xReturn = pdTRUE;
1317:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				}
1318:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
1319:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
1320:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1321:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		return xReturn;
1322:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
1323:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1324:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #endif /* ipconfigUSE_TCP_WIN == 1 */
1325:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*-----------------------------------------------------------*/
1326:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1327:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #if( ipconfigUSE_TCP_WIN == 1 )
1328:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1329:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	uint32_t ulTCPWindowTxGet( TCPWindow_t *pxWindow, uint32_t ulWindowSize, int32_t *plPosition )
1330:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	{
1331:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	TCPSegment_t *pxSegment;
1332:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	uint32_t ulMaxTime;
1333:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	uint32_t ulReturn  = ~0UL;
1334:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1335:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1336:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		/* Fetches data to be sent-out now.
1337:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1338:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		Priority messages: segments with a resend need no check current sliding
1339:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		window size. */
1340:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		pxSegment = xTCPWindowGetHead( &( pxWindow->xPriorityQueue ) );
1341:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		pxWindow->ulOurSequenceNumber = pxWindow->tx.ulHighestSequenceNumber;
1342:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1343:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		if( pxSegment == NULL )
1344:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
1345:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			/* Waiting messages: outstanding messages with a running timer
1346:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			neither check peer's reception window size because these packets
1347:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			have been sent earlier. */
1348:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			pxSegment = xTCPWindowPeekHead( &( pxWindow->xWaitQueue ) );
1349:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1350:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			if( pxSegment != NULL )
1351:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
1352:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				/* Do check the timing. */
1353:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				ulMaxTime = ( 1UL << pxSegment->u.bits.ucTransmitCount ) * ( ( uint32_t ) pxWindow->lSRTT );
1354:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1355:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				if( ulTimerGetAge( &pxSegment->xTransmitTimer ) > ulMaxTime )
1356:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
1357:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					/* A normal (non-fast) retransmission.  Move it from the
1358:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					head of the waiting queue. */
1359:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					pxSegment = xTCPWindowGetHead( &( pxWindow->xWaitQueue ) );
1360:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					pxSegment->u.bits.ucDupAckCount = ( uint8_t ) pdFALSE_UNSIGNED;
1361:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1362:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					/* Some detailed logging. */
1363:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					if( ( xTCPWindowLoggingLevel != 0 ) && ( ipconfigTCP_MAY_LOG_PORT( pxWindow->usOurPortNumber )
1364:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					{
1365:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						FreeRTOS_debug_printf( ( "ulTCPWindowTxGet[%u,%u]: WaitQueue %ld bytes for sequence number %l
1366:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 							pxWindow->usPeerPortNumber,
1367:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 							pxWindow->usOurPortNumber,
1368:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 							pxSegment->lDataLength,
1369:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 							pxSegment->ulSequenceNumber - pxWindow->tx.ulFirstSequenceNumber,
1370:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 							pxSegment->ulSequenceNumber ) );
1371:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						FreeRTOS_flush_logging( );
1372:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					}
1373:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				}
1374:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				else
1375:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
1376:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					pxSegment = NULL;
1377:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				}
1378:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
1379:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1380:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			if( pxSegment == NULL )
1381:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
1382:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				/* New messages: sent-out for the first time.  Check current
1383:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				sliding window size of peer. */
1384:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				pxSegment = xTCPWindowPeekHead( &( pxWindow->xTxQueue ) );
1385:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1386:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				if( pxSegment == NULL )
1387:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
1388:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					/* No segments queued. */
1389:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					ulReturn = 0UL;
1390:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				}
1391:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				else if( ( pxWindow->u.bits.bSendFullSize != pdFALSE_UNSIGNED ) && ( pxSegment->lDataLength < p
1392:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
1393:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					/* A segment has been queued but the driver waits until it
1394:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					has a full size of MSS. */
1395:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					ulReturn = 0;
1396:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				}
1397:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				else if( prvTCPWindowTxHasSpace( pxWindow, ulWindowSize ) == pdFALSE )
1398:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
1399:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					/* Peer has no more space at this moment. */
1400:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					ulReturn = 0;
1401:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				}
1402:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				else
1403:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
1404:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					/* Move it out of the Tx queue. */
1405:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					pxSegment = xTCPWindowGetHead( &( pxWindow->xTxQueue ) );
1406:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1407:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					/* Don't let pxHeadSegment point to this segment any more,
1408:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					so no more data will be added. */
1409:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					if( pxWindow->pxHeadSegment == pxSegment )
1410:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					{
1411:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						pxWindow->pxHeadSegment = NULL;
1412:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					}
1413:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1414:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					/* pxWindow->tx.highest registers the highest sequence
1415:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					number in our transmission window. */
1416:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					pxWindow->tx.ulHighestSequenceNumber = pxSegment->ulSequenceNumber + ( ( uint32_t ) pxSegment-
1417:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1418:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					/* ...and more detailed logging */
1419:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					if( ( xTCPWindowLoggingLevel >= 2 ) && ( ipconfigTCP_MAY_LOG_PORT( pxWindow->usOurPortNumber )
1420:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					{
1421:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						FreeRTOS_debug_printf( ( "ulTCPWindowTxGet[%u,%u]: XmitQueue %ld bytes for sequence number %l
1422:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 							pxWindow->usPeerPortNumber,
1423:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 							pxWindow->usOurPortNumber,
1424:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 							pxSegment->lDataLength,
1425:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 							pxSegment->ulSequenceNumber - pxWindow->tx.ulFirstSequenceNumber,
1426:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 							ulWindowSize ) );
1427:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						FreeRTOS_flush_logging( );
1428:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					}
1429:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				}
1430:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
1431:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
1432:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		else
1433:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
1434:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			/* There is a priority segment. It doesn't need any checking for
1435:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			space or timeouts. */
1436:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			if( xTCPWindowLoggingLevel != 0 )
1437:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
1438:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				FreeRTOS_debug_printf( ( "ulTCPWindowTxGet[%u,%u]: PrioQueue %ld bytes for sequence number %lu 
1439:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					pxWindow->usPeerPortNumber,
1440:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					pxWindow->usOurPortNumber,
1441:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					pxSegment->lDataLength,
1442:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					pxSegment->ulSequenceNumber - pxWindow->tx.ulFirstSequenceNumber,
1443:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					ulWindowSize ) );
1444:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				FreeRTOS_flush_logging( );
1445:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
1446:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
1447:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1448:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		/* See if it has already been determined to return 0. */
1449:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		if( ulReturn != 0UL )
1450:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
1451:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			/* pxSegment is not NULL when ulReturn != 0UL. */
1452:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			configASSERT( pxSegment != NULL );
1453:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			configASSERT( listLIST_ITEM_CONTAINER( &(pxSegment->xQueueItem ) ) == NULL );
1454:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1455:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			/* Now that the segment will be transmitted, add it to the tail of
1456:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			the waiting queue. */
1457:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			vListInsertFifo( &pxWindow->xWaitQueue, &pxSegment->xQueueItem );
1458:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1459:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			/* And mark it as outstanding. */
1460:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			pxSegment->u.bits.bOutstanding = pdTRUE_UNSIGNED;
1461:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1462:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			/* Administer the transmit count, needed for fast
1463:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			retransmissions. */
1464:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			( pxSegment->u.bits.ucTransmitCount )++;
1465:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1466:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			/* If there have been several retransmissions (4), decrease the
1467:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			size of the transmission window to at most 2 times MSS. */
1468:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			if( pxSegment->u.bits.ucTransmitCount == MAX_TRANSMIT_COUNT_USING_LARGE_WINDOW )
1469:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
1470:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				if( pxWindow->xSize.ulTxWindowLength > ( 2U * ( ( uint32_t ) pxWindow->usMSS ) ) )
1471:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
1472:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					FreeRTOS_debug_printf( ( "ulTCPWindowTxGet[%u - %d]: Change Tx window: %lu -> %u\n",
1473:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						pxWindow->usPeerPortNumber,
1474:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						pxWindow->usOurPortNumber,
1475:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						pxWindow->xSize.ulTxWindowLength,
1476:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						2U * pxWindow->usMSS ) );
1477:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					pxWindow->xSize.ulTxWindowLength = ( 2UL * pxWindow->usMSS );
1478:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				}
1479:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
1480:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1481:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			/* Clear the transmit timer. */
1482:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			vTCPTimerSet( &( pxSegment->xTransmitTimer ) );
1483:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1484:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			pxWindow->ulOurSequenceNumber = pxSegment->ulSequenceNumber;
1485:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1486:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			/* Inform the caller where to find the data within the queue. */
1487:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			*plPosition = pxSegment->lStreamPos;
1488:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1489:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			/* And return the length of the data segment */
1490:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			ulReturn = ( uint32_t ) pxSegment->lDataLength;
1491:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
1492:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1493:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		return ulReturn;
1494:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
1495:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1496:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #endif /* ipconfigUSE_TCP_WIN == 1 */
1497:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*-----------------------------------------------------------*/
1498:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1499:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #if( ipconfigUSE_TCP_WIN == 1 )
1500:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1501:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	static uint32_t prvTCPWindowTxCheckAck( TCPWindow_t *pxWindow, uint32_t ulFirst, uint32_t ulLast )
1502:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	{
 459              	 .loc 1 1502 0
 460              	 .cfi_startproc
 461              	 
 462              	 
 463              	.LVL58:
 464 0000 2DE9F04F 	 push {r4,r5,r6,r7,r8,r9,r10,fp,lr}
 465              	.LCFI8:
 466              	 .cfi_def_cfa_offset 36
 467              	 .cfi_offset 4,-36
 468              	 .cfi_offset 5,-32
 469              	 .cfi_offset 6,-28
 470              	 .cfi_offset 7,-24
 471              	 .cfi_offset 8,-20
 472              	 .cfi_offset 9,-16
 473              	 .cfi_offset 10,-12
 474              	 .cfi_offset 11,-8
 475              	 .cfi_offset 14,-4
 476 0004 83B0     	 sub sp,sp,#12
 477              	.LCFI9:
 478              	 .cfi_def_cfa_offset 48
 479 0006 8246     	 mov r10,r0
 480 0008 0192     	 str r2,[sp,#4]
 481              	.LVL59:
1503:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	uint32_t ulBytesConfirmed = 0U;
1504:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	uint32_t ulSequenceNumber = ulFirst, ulDataLength;
1505:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	const ListItem_t *pxIterator;
1506:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	const ListItem_t *pxEnd = listGET_END_MARKER( &pxWindow->xTxSegments );
 482              	 .loc 1 1506 0
 483 000a 00F19808 	 add r8,r0,#152
 484              	.LVL60:
1507:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	BaseType_t xDoUnlink;
1508:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	TCPSegment_t *pxSegment;
1509:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		/* An acknowledgement or a selective ACK (SACK) was received.  See if some outstanding data
1510:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		may be removed from the transmission queue(s).
1511:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		All TX segments for which
1512:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		( ( ulSequenceNumber >= ulFirst ) && ( ulSequenceNumber < ulLast ) in a
1513:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		contiguous block.  Note that the segments are stored in xTxSegments in a
1514:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		strict sequential order. */
1515:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1516:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		/* SRTT[i] = (1-a) * SRTT[i-1] + a * RTT
1517:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1518:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		0 < a < 1; usually a = 1/8
1519:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1520:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		RTO = 2 * SRTT
1521:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1522:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		where:
1523:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		  RTT is Round Trip Time
1524:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		  SRTT is Smoothed RTT
1525:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		  RTO is Retransmit timeout
1526:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1527:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		 A Smoothed RTT will increase quickly, but it is conservative when
1528:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		 becoming smaller. */
1529:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1530:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		pxIterator  = listGET_NEXT( pxEnd );
 485              	 .loc 1 1530 0
 486 000e D0F89C50 	 ldr r5,[r0,#156]
 487              	.LVL61:
1531:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		while( ( pxIterator != pxEnd ) && ( xSequenceLessThan( ulSequenceNumber, ulLast ) != 0 ) )
 488              	 .loc 1 1531 0
 489 0012 A845     	 cmp r8,r5
 490 0014 5CD0     	 beq .L50
 491 0016 0C46     	 mov r4,r1
 492              	.LVL62:
 493 0018 02F1FF39 	 add r9,r2,#-1
 494              	.LVL63:
 495              	.LBB97:
 496              	.LBB98:
 239:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 497              	 .loc 1 239 0
 498 001c C1EB0903 	 rsb r3,r1,r9
 499              	.LBE98:
 500              	.LBE97:
 501              	 .loc 1 1531 0
 502 0020 002B     	 cmp r3,#0
 503 0022 58DB     	 blt .L51
 504 0024 0023     	 movs r3,#0
 505 0026 0093     	 str r3,[sp]
 506 0028 6FEA020B 	 mvn fp,r2
 507              	.LVL64:
 508              	.L46:
1532:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
1533:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			xDoUnlink = pdFALSE;
1534:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			pxSegment = ipCAST_PTR_TO_TYPE_PTR( TCPSegment_t, listGET_LIST_ITEM_OWNER( pxIterator ) );
 509              	 .loc 1 1534 0
 510 002c EE68     	 ldr r6,[r5,#12]
 511              	.LVL65:
1535:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1536:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			/* Move to the next item because the current item might get
1537:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			removed. */
1538:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			pxIterator = ( const ListItem_t * ) listGET_NEXT( pxIterator );
 512              	 .loc 1 1538 0
 513 002e 6D68     	 ldr r5,[r5,#4]
 514              	.LVL66:
1539:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1540:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			/* Continue if this segment does not fall within the ACK'd range. */
1541:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			if( xSequenceGreaterThan( ulSequenceNumber, pxSegment->ulSequenceNumber ) != pdFALSE )
 515              	 .loc 1 1541 0
 516 0030 3368     	 ldr r3,[r6]
 517              	.LVL67:
 518 0032 DA43     	 mvns r2,r3
 519 0034 E242     	 cmn r2,r4
 520 0036 44D5     	 bpl .L38
1542:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
1543:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				continue;
1544:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
1545:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1546:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			/* Is it ready? */
1547:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			if( ulSequenceNumber != pxSegment->ulSequenceNumber )
 521              	 .loc 1 1547 0
 522 0038 9C42     	 cmp r4,r3
 523 003a 5DD1     	 bne .L52
1548:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
1549:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				/* coverity[break_stmt] : Break statement terminating the loop */
1550:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				break;
1551:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
1552:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1553:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			ulDataLength = ( uint32_t ) pxSegment->lDataLength;
 524              	 .loc 1 1553 0
 525 003c B768     	 ldr r7,[r6,#8]
 526              	.LVL68:
1554:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1555:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			if( pxSegment->u.bits.bAcked == pdFALSE_UNSIGNED )
 527              	 .loc 1 1555 0
 528 003e B37D     	 ldrb r3,[r6,#22]
 529              	.LVL69:
 530 0040 13F0020F 	 tst r3,#2
 531 0044 53D1     	 bne .L39
1556:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
1557:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				if( xSequenceGreaterThan( pxSegment->ulSequenceNumber + ( uint32_t )ulDataLength, ulLast ) != p
 532              	 .loc 1 1557 0
 533 0046 E219     	 adds r2,r4,r7
 534              	.LVL70:
 535 0048 1BEB020F 	 cmn fp,r2
 536 004c 54D5     	 bpl .L52
1558:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
1559:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					/* What happens?  Only part of this segment was accepted,
1560:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					probably due to WND limits
1561:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1562:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					  AAAAAAA BBBBBBB << acked
1563:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					  aaaaaaa aaaa    << sent */
1564:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					#if( ipconfigHAS_DEBUG_PRINTF != 0 )
1565:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					{
1566:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						uint32_t ulFirstSeq = pxSegment->ulSequenceNumber - pxWindow->tx.ulFirstSequenceNumber;
1567:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						FreeRTOS_debug_printf( ( "prvTCPWindowTxCheckAck[%u.%u]: %lu - %lu Partial sequence number %l
1568:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 							pxWindow->usPeerPortNumber,
1569:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 							pxWindow->usOurPortNumber,
1570:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 							ulFirstSeq - pxWindow->tx.ulFirstSequenceNumber,
1571:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 							ulLast - pxWindow->tx.ulFirstSequenceNumber,
1572:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 							ulFirstSeq, ulFirstSeq + ulDataLength ) );
1573:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					}
1574:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					#endif	/* ipconfigHAS_DEBUG_PRINTF */
1575:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					break;
1576:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				}
1577:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1578:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				/* This segment is fully ACK'd, set the flag. */
1579:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				pxSegment->u.bits.bAcked = pdTRUE;
 537              	 .loc 1 1579 0
 538 004e 43F00203 	 orr r3,r3,#2
 539 0052 B375     	 strb r3,[r6,#22]
 540              	.LVL71:
1580:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1581:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				/* Calculate the RTT only if the segment was sent-out for the
1582:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				first time and if this is the last ACK'd segment in a range. */
1583:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				if( ( pxSegment->u.bits.ucTransmitCount == 1U ) && ( ( pxSegment->ulSequenceNumber + ulDataLeng
 541              	 .loc 1 1583 0
 542 0054 337D     	 ldrb r3,[r6,#20]
 543 0056 012B     	 cmp r3,#1
 544 0058 44D1     	 bne .L40
 545              	 .loc 1 1583 0 is_stmt 0 discriminator 1
 546 005a 019B     	 ldr r3,[sp,#4]
 547 005c 9342     	 cmp r3,r2
 548 005e 41D1     	 bne .L40
 549              	.LVL72:
 550              	.LBB100:
 551              	.LBB101:
 552              	.LBB102:
 309:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** }
 553              	 .loc 1 309 0 is_stmt 1
 554 0060 FFF7FEFF 	 bl xTaskGetTickCount
 555              	.LVL73:
 556 0064 3369     	 ldr r3,[r6,#16]
 557 0066 C01A     	 subs r0,r0,r3
 558              	.LVL74:
 559              	.LBE102:
 560              	.LBE101:
1584:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
1585:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					int32_t mS = ( int32_t ) ulTimerGetAge( &( pxSegment->xTransmitTimer ) );
1586:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1587:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					if( pxWindow->lSRTT >= mS )
 561              	 .loc 1 1587 0
 562 0068 DAF83830 	 ldr r3,[r10,#56]
 563 006c 9842     	 cmp r0,r3
 564 006e 08DC     	 bgt .L41
1588:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					{
1589:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						/* RTT becomes smaller: adapt slowly. */
1590:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						pxWindow->lSRTT = ( ( winSRTT_DECREMENT_NEW * mS ) + ( winSRTT_DECREMENT_CURRENT * pxWindow->
 565              	 .loc 1 1590 0
 566 0070 C3EBC303 	 rsb r3,r3,r3,lsl#3
 567 0074 1B18     	 adds r3,r3,r0
 568 0076 48BF     	 it mi
 569 0078 0733     	 addmi r3,r3,#7
 570 007a DB10     	 asrs r3,r3,#3
 571 007c CAF83830 	 str r3,[r10,#56]
 572 0080 08E0     	 b .L43
 573              	.L41:
1591:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					}
1592:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					else
1593:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					{
1594:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						/* RTT becomes larger: adapt quicker */
1595:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						pxWindow->lSRTT = ( ( winSRTT_INCREMENT_NEW * mS ) + ( winSRTT_INCREMENT_CURRENT * pxWindow->
 574              	 .loc 1 1595 0
 575 0082 03EB4303 	 add r3,r3,r3,lsl#1
 576 0086 1844     	 add r0,r0,r3
 577              	.LVL75:
 578 0088 4000     	 lsls r0,r0,#1
 579 008a 48BF     	 it mi
 580 008c 0730     	 addmi r0,r0,#7
 581 008e C010     	 asrs r0,r0,#3
 582 0090 CAF83800 	 str r0,[r10,#56]
 583              	.L43:
1596:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					}
1597:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1598:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					/* Cap to the minimum of 50ms. */
1599:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					if( pxWindow->lSRTT < winSRTT_CAP_mS )
 584              	 .loc 1 1599 0
 585 0094 DAF83830 	 ldr r3,[r10,#56]
 586 0098 312B     	 cmp r3,#49
 587 009a 23DC     	 bgt .L40
1600:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					{
1601:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						pxWindow->lSRTT = winSRTT_CAP_mS;
 588              	 .loc 1 1601 0
 589 009c 3223     	 movs r3,#50
 590 009e CAF83830 	 str r3,[r10,#56]
 591 00a2 1FE0     	 b .L40
 592              	.LVL76:
 593              	.L48:
 594              	.LBE100:
1602:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					}
1603:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				}
1604:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1605:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				/* Unlink it from the 3 queues, but do not destroy it (yet). */
1606:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				xDoUnlink = pdTRUE;
1607:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
1608:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1609:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			/* pxSegment->u.bits.bAcked is now true.  Is it located at the left
1610:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			side of the transmission queue?  If so, it may be freed. */
1611:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			if( ulSequenceNumber == pxWindow->tx.ulCurrentSequenceNumber )
1612:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
1613:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				if( ( xTCPWindowLoggingLevel >= 2 ) && ( ipconfigTCP_MAY_LOG_PORT( pxWindow->usOurPortNumber ) 
1614:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
1615:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					FreeRTOS_debug_printf( ( "prvTCPWindowTxCheckAck: %lu - %lu Ready sequence number %lu\n",
1616:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						ulFirst - pxWindow->tx.ulFirstSequenceNumber,
1617:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						ulLast - pxWindow->tx.ulFirstSequenceNumber,
1618:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						pxSegment->ulSequenceNumber - pxWindow->tx.ulFirstSequenceNumber ) );
1619:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				}
1620:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1621:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				/* Increase the left-hand value of the transmission window. */
1622:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				pxWindow->tx.ulCurrentSequenceNumber += ulDataLength;
 595              	 .loc 1 1622 0
 596 00a4 3B19     	 adds r3,r7,r4
 597 00a6 CAF82030 	 str r3,[r10,#32]
1623:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1624:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				/* This function will return the number of bytes that the tail
1625:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				of txStream may be advanced. */
1626:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				ulBytesConfirmed += ulDataLength;
 598              	 .loc 1 1626 0
 599 00aa 009B     	 ldr r3,[sp]
 600 00ac 3B44     	 add r3,r3,r7
 601 00ae 0093     	 str r3,[sp]
 602              	.LVL77:
1627:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1628:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				/* All segments below tx.ulCurrentSequenceNumber may be freed. */
1629:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				vTCPWindowFree( pxSegment );
 603              	 .loc 1 1629 0
 604 00b0 3046     	 mov r0,r6
 605 00b2 FFF7FEFF 	 bl vTCPWindowFree
 606              	.LVL78:
 607 00b6 03E0     	 b .L45
 608              	.LVL79:
 609              	.L47:
1630:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1631:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				/* No need to unlink it any more. */
1632:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				xDoUnlink = pdFALSE;
1633:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
1634:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1635:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			if( ( xDoUnlink != pdFALSE ) && ( listLIST_ITEM_CONTAINER( &( pxSegment->xQueueItem ) ) != NULL 
1636:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
1637:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				/* Remove item from its queues. */
1638:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				( void ) uxListRemove( &pxSegment->xQueueItem );
 610              	 .loc 1 1638 0
 611 00b8 06F11800 	 add r0,r6,#24
 612 00bc FFF7FEFF 	 bl uxListRemove
 613              	.LVL80:
 614              	.L45:
1639:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
1640:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1641:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			ulSequenceNumber += ulDataLength;
 615              	 .loc 1 1641 0
 616 00c0 3C44     	 add r4,r4,r7
 617              	.LVL81:
 618              	.L38:
1531:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 619              	 .loc 1 1531 0
 620 00c2 A845     	 cmp r8,r5
 621 00c4 18D0     	 beq .L52
 622              	.LVL82:
 623              	.LBB103:
 624              	.LBB99:
 239:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 625              	 .loc 1 239 0
 626 00c6 C4EB0903 	 rsb r3,r4,r9
 627              	.LBE99:
 628              	.LBE103:
1531:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 629              	 .loc 1 1531 0
 630 00ca 002B     	 cmp r3,#0
 631 00cc AEDA     	 bge .L46
 632 00ce 13E0     	 b .L52
 633              	.LVL83:
 634              	.L50:
1503:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	uint32_t ulSequenceNumber = ulFirst, ulDataLength;
 635              	 .loc 1 1503 0
 636 00d0 0023     	 movs r3,#0
 637 00d2 0093     	 str r3,[sp]
 638 00d4 10E0     	 b .L52
 639              	.LVL84:
 640              	.L51:
 641 00d6 0023     	 movs r3,#0
 642 00d8 0093     	 str r3,[sp]
 643 00da 0DE0     	 b .L52
 644              	.LVL85:
 645              	.L54:
1635:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
 646              	 .loc 1 1635 0
 647 00dc B36A     	 ldr r3,[r6,#40]
 648 00de 002B     	 cmp r3,#0
 649 00e0 EAD1     	 bne .L47
 650 00e2 EDE7     	 b .L45
 651              	.LVL86:
 652              	.L40:
1611:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
 653              	 .loc 1 1611 0
 654 00e4 DAF82030 	 ldr r3,[r10,#32]
 655 00e8 A342     	 cmp r3,r4
 656 00ea F7D1     	 bne .L54
 657 00ec DAE7     	 b .L48
 658              	.LVL87:
 659              	.L39:
 660 00ee DAF82030 	 ldr r3,[r10,#32]
 661 00f2 A342     	 cmp r3,r4
 662 00f4 E4D1     	 bne .L45
 663 00f6 D5E7     	 b .L48
 664              	.LVL88:
 665              	.L52:
1642:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
1643:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1644:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		return ulBytesConfirmed;
1645:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
 666              	 .loc 1 1645 0
 667 00f8 0098     	 ldr r0,[sp]
 668 00fa 03B0     	 add sp,sp,#12
 669              	.LCFI10:
 670              	 .cfi_def_cfa_offset 36
 671              	 
 672 00fc BDE8F08F 	 pop {r4,r5,r6,r7,r8,r9,r10,fp,pc}
 673              	 .cfi_endproc
 674              	.LFE78:
 676              	 .section .text.xTCPWindowRxEmpty,"ax",%progbits
 677              	 .align 2
 678              	 .global xTCPWindowRxEmpty
 679              	 .thumb
 680              	 .thumb_func
 682              	xTCPWindowRxEmpty:
 683              	.LFB62:
 473:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	BaseType_t xReturn;
 684              	 .loc 1 473 0
 685              	 .cfi_startproc
 686              	 
 687              	 
 688              	 
 689              	.LVL89:
 481:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 690              	 .loc 1 481 0
 691 0000 D0F8A430 	 ldr r3,[r0,#164]
 692 0004 2BB9     	 cbnz r3,.L58
 693              	.LVL90:
 694              	.LBB104:
 695              	.LBB105:
 278:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	{
 696              	 .loc 1 278 0
 697 0006 0369     	 ldr r3,[r0,#16]
 698 0008 8069     	 ldr r0,[r0,#24]
 699              	.LVL91:
 700 000a 181A     	 subs r0,r3,r0
 701              	.LVL92:
 702 000c C043     	 mvns r0,r0
 703 000e C00F     	 lsrs r0,r0,#31
 704              	.LBE105:
 705              	.LBE104:
 706 0010 7047     	 bx lr
 707              	.LVL93:
 708              	.L58:
 484:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 709              	 .loc 1 484 0
 710 0012 0020     	 movs r0,#0
 711              	.LVL94:
 501:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 712              	 .loc 1 501 0
 713 0014 7047     	 bx lr
 714              	 .cfi_endproc
 715              	.LFE62:
 717 0016 00BF     	 .section .text.vTCPWindowDestroy,"ax",%progbits
 718              	 .align 2
 719              	 .global vTCPWindowDestroy
 720              	 .thumb
 721              	 .thumb_func
 723              	vTCPWindowDestroy:
 724              	.LFB66:
 589:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	const List_t * pxSegments;
 725              	 .loc 1 589 0
 726              	 .cfi_startproc
 727              	 
 728              	 
 729              	.LVL95:
 730 0000 70B5     	 push {r4,r5,r6,lr}
 731              	.LCFI11:
 732              	 .cfi_def_cfa_offset 16
 733              	 .cfi_offset 4,-16
 734              	 .cfi_offset 5,-12
 735              	 .cfi_offset 6,-8
 736              	 .cfi_offset 14,-4
 737 0002 0646     	 mov r6,r0
 738              	.LVL96:
 589:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	const List_t * pxSegments;
 739              	 .loc 1 589 0
 740 0004 0125     	 movs r5,#1
 741 0006 00E0     	 b .L60
 742              	.LVL97:
 743              	.L64:
 744 0008 0135     	 adds r5,r5,#1
 745              	.L60:
 746              	.LVL98:
 600:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
 747              	 .loc 1 600 0
 748 000a 012D     	 cmp r5,#1
 749 000c 07D0     	 beq .L61
 750              	.LVL99:
 609:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
 751              	 .loc 1 609 0
 752 000e D6F8AC30 	 ldr r3,[r6,#172]
 753 0012 B3F1FF3F 	 cmp r3,#-1
 754 0016 12D1     	 bne .L62
 602:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
 755              	 .loc 1 602 0
 756 0018 06F1A404 	 add r4,r6,#164
 757              	.LVL100:
 758 001c 06E0     	 b .L63
 759              	.LVL101:
 760              	.L61:
 609:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
 761              	 .loc 1 609 0
 762 001e D6F89830 	 ldr r3,[r6,#152]
 763 0022 B3F1FF3F 	 cmp r3,#-1
 764 0026 EFD1     	 bne .L64
 606:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
 765              	 .loc 1 606 0
 766 0028 06F19004 	 add r4,r6,#144
 767              	.LVL102:
 768              	.L63:
 611:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
 769              	 .loc 1 611 0
 770 002c 2368     	 ldr r3,[r4]
 771 002e 33B1     	 cbz r3,.L62
 772              	.L66:
 773              	.LVL103:
 613:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					vTCPWindowFree( pxSegment );
 774              	 .loc 1 613 0
 775 0030 E368     	 ldr r3,[r4,#12]
 614:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				}
 776              	 .loc 1 614 0
 777 0032 D868     	 ldr r0,[r3,#12]
 778 0034 FFF7FEFF 	 bl vTCPWindowFree
 779              	.LVL104:
 611:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
 780              	 .loc 1 611 0
 781 0038 2368     	 ldr r3,[r4]
 782 003a 002B     	 cmp r3,#0
 783 003c F8D1     	 bne .L66
 784              	.L62:
 785              	.LVL105:
 598:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 786              	 .loc 1 598 0 discriminator 2
 787 003e 012D     	 cmp r5,#1
 788 0040 E2DD     	 ble .L64
 618:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 789              	 .loc 1 618 0
 790 0042 70BD     	 pop {r4,r5,r6,pc}
 791              	 .cfi_endproc
 792              	.LFE66:
 794              	 .section .text.vTCPWindowInit,"ax",%progbits
 795              	 .align 2
 796              	 .global vTCPWindowInit
 797              	 .thumb
 798              	 .thumb_func
 800              	vTCPWindowInit:
 801              	.LFB68:
 658:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** const int32_t l500ms = 500;
 802              	 .loc 1 658 0
 803              	 .cfi_startproc
 804              	 
 805              	 
 806              	 
 807              	.LVL106:
 808 0000 10B4     	 push {r4}
 809              	.LCFI12:
 810              	 .cfi_def_cfa_offset 4
 811              	 .cfi_offset 4,-4
 812              	.LVL107:
 661:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	pxWindow->u.bits.bHasInit = pdTRUE_UNSIGNED;
 813              	 .loc 1 661 0
 814 0002 0024     	 movs r4,#0
 815 0004 0460     	 str r4,[r0]
 662:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 816              	 .loc 1 662 0
 817 0006 0124     	 movs r4,#1
 818 0008 0470     	 strb r4,[r0]
 664:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	{
 819              	 .loc 1 664 0
 820 000a 93B1     	 cbz r3,.L70
 821 000c 1C46     	 mov r4,r3
 666:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 822              	 .loc 1 666 0
 823 000e B0F8BE30 	 ldrh r3,[r0,#190]
 824              	.LVL108:
 825 0012 0BB1     	 cbz r3,.L71
 668:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 826              	 .loc 1 668 0
 827 0014 A0F8BE40 	 strh r4,[r0,#190]
 828              	.L71:
 671:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 829              	 .loc 1 671 0
 830 0018 B0F8BC30 	 ldrh r3,[r0,#188]
 831 001c 9C42     	 cmp r4,r3
 832 001e 00D3     	 bcc .L72
 671:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 833              	 .loc 1 671 0 is_stmt 0 discriminator 1
 834 0020 3BB9     	 cbnz r3,.L70
 835              	.L72:
 673:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			pxWindow->usMSS = ( uint16_t ) ulMSS;
 836              	 .loc 1 673 0 is_stmt 1
 837 0022 4368     	 ldr r3,[r0,#4]
 838 0024 B3FBF4F3 	 udiv r3,r3,r4
 839 0028 04FB03F3 	 mul r3,r4,r3
 840 002c 4360     	 str r3,[r0,#4]
 674:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 841              	 .loc 1 674 0
 842 002e A0F8BC40 	 strh r4,[r0,#188]
 843              	.LVL109:
 844              	.L70:
 685:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 845              	 .loc 1 685 0
 846 0032 4FF4FA73 	 mov r3,#500
 847 0036 8363     	 str r3,[r0,#56]
 688:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 848              	 .loc 1 688 0
 849 0038 C160     	 str r1,[r0,#12]
 691:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 850              	 .loc 1 691 0
 851 003a 0161     	 str r1,[r0,#16]
 694:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 852              	 .loc 1 694 0
 853 003c 8161     	 str r1,[r0,#24]
 696:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 854              	 .loc 1 696 0
 855 003e C261     	 str r2,[r0,#28]
 699:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 856              	 .loc 1 699 0
 857 0040 0262     	 str r2,[r0,#32]
 703:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 858              	 .loc 1 703 0
 859 0042 4263     	 str r2,[r0,#52]
 706:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	pxWindow->ulOurSequenceNumber = ulSequenceNumber;
 860              	 .loc 1 706 0
 861 0044 8262     	 str r2,[r0,#40]
 707:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** }
 862              	 .loc 1 707 0
 863 0046 C262     	 str r2,[r0,#44]
 708:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*-----------------------------------------------------------*/
 864              	 .loc 1 708 0
 865 0048 5DF8044B 	 ldr r4,[sp],#4
 866              	.LCFI13:
 867              	 .cfi_restore 4
 868              	 .cfi_def_cfa_offset 0
 869 004c 7047     	 bx lr
 870              	 .cfi_endproc
 871              	.LFE68:
 873 004e 00BF     	 .section .text.vTCPWindowCreate,"ax",%progbits
 874              	 .align 2
 875              	 .global vTCPWindowCreate
 876              	 .thumb
 877              	 .thumb_func
 879              	vTCPWindowCreate:
 880              	.LFB67:
 625:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	/* Create and initialize a window. */
 881              	 .loc 1 625 0
 882              	 .cfi_startproc
 883              	 
 884              	 
 885              	.LVL110:
 886 0000 2DE9F84F 	 push {r3,r4,r5,r6,r7,r8,r9,r10,fp,lr}
 887              	.LCFI14:
 888              	 .cfi_def_cfa_offset 40
 889              	 .cfi_offset 3,-40
 890              	 .cfi_offset 4,-36
 891              	 .cfi_offset 5,-32
 892              	 .cfi_offset 6,-28
 893              	 .cfi_offset 7,-24
 894              	 .cfi_offset 8,-20
 895              	 .cfi_offset 9,-16
 896              	 .cfi_offset 10,-12
 897              	 .cfi_offset 11,-8
 898              	 .cfi_offset 14,-4
 899 0004 0546     	 mov r5,r0
 900 0006 8A46     	 mov r10,r1
 901 0008 9146     	 mov r9,r2
 902 000a 9846     	 mov r8,r3
 630:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 903              	 .loc 1 630 0
 904 000c 214B     	 ldr r3,.L79
 905              	.LVL111:
 906 000e 1B68     	 ldr r3,[r3]
 907 0010 03BB     	 cbnz r3,.L75
 908              	.LBB110:
 909              	.LBB111:
 338:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		xTCPSegments = ipCAST_PTR_TO_TYPE_PTR( TCPSegment_t, pvPortMallocLarge( ( size_t ) ipconfigTCP_WI
 910              	 .loc 1 338 0
 911 0012 2148     	 ldr r0,.L79+4
 912              	.LVL112:
 913 0014 FFF7FEFF 	 bl vListInitialise
 914              	.LVL113:
 339:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 915              	 .loc 1 339 0
 916 0018 4FF47050 	 mov r0,#15360
 917 001c FFF7FEFF 	 bl pvPortMalloc
 918              	.LVL114:
 919 0020 0646     	 mov r6,r0
 920              	.LVL115:
 921 0022 1C4B     	 ldr r3,.L79
 922 0024 1860     	 str r0,[r3]
 341:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 923              	 .loc 1 341 0
 924 0026 A8B1     	 cbz r0,.L75
 351:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 925              	 .loc 1 351 0
 926 0028 0021     	 movs r1,#0
 927 002a 4FF47052 	 mov r2,#15360
 928 002e FFF7FEFF 	 bl memset
 929              	.LVL116:
 930 0032 3446     	 mov r4,r6
 931 0034 06F57056 	 add r6,r6,#15360
 932              	.LVL117:
 933              	.LBB112:
 934              	.LBB113:
 294:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
 935              	 .loc 1 294 0
 936 0038 174F     	 ldr r7,.L79+4
 937 003a 07F1080B 	 add fp,r7,#8
 938              	.LVL118:
 939              	.L76:
 940              	.LBE113:
 941              	.LBE112:
 357:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				listSET_LIST_ITEM_OWNER( &( xTCPSegments[ xIndex ].xQueueItem ), ( void * ) &( xTCPSegments[ xI
 942              	 .loc 1 357 0
 943 003e A463     	 str r4,[r4,#56]
 358:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 944              	 .loc 1 358 0
 945 0040 6462     	 str r4,[r4,#36]
 946              	.LVL119:
 947              	.LBB115:
 948              	.LBB114:
 294:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
 949              	 .loc 1 294 0
 950 0042 3846     	 mov r0,r7
 951 0044 04F12C01 	 add r1,r4,#44
 952              	.LVL120:
 953 0048 5A46     	 mov r2,fp
 954 004a FFF7FEFF 	 bl vListInsertGeneric
 955              	.LVL121:
 956 004e 4034     	 adds r4,r4,#64
 957              	.LVL122:
 958              	.LBE114:
 959              	.LBE115:
 353:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
 960              	 .loc 1 353 0
 961 0050 B442     	 cmp r4,r6
 962 0052 F4D1     	 bne .L76
 963              	.LVL123:
 964              	.L75:
 965              	.LBE111:
 966              	.LBE110:
 635:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		vListInitialise( &( pxWindow->xRxSegments ) );
 967              	 .loc 1 635 0
 968 0054 05F19000 	 add r0,r5,#144
 969 0058 FFF7FEFF 	 bl vListInitialise
 970              	.LVL124:
 636:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 971              	 .loc 1 636 0
 972 005c 05F1A400 	 add r0,r5,#164
 973 0060 FFF7FEFF 	 bl vListInitialise
 974              	.LVL125:
 638:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		vListInitialise( &( pxWindow->xTxQueue ) );			/* Transmit queue: segments queued for transmission
 975              	 .loc 1 638 0
 976 0064 05F14000 	 add r0,r5,#64
 977 0068 FFF7FEFF 	 bl vListInitialise
 978              	.LVL126:
 639:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		vListInitialise( &( pxWindow->xWaitQueue ) );		/* Waiting queue:  outstanding segments */
 979              	 .loc 1 639 0
 980 006c 05F15400 	 add r0,r5,#84
 981 0070 FFF7FEFF 	 bl vListInitialise
 982              	.LVL127:
 640:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
 983              	 .loc 1 640 0
 984 0074 05F16800 	 add r0,r5,#104
 985 0078 FFF7FEFF 	 bl vListInitialise
 986              	.LVL128:
 650:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	pxWindow->xSize.ulTxWindowLength = ulTxWindowLength;
 987              	 .loc 1 650 0
 988 007c C5F804A0 	 str r10,[r5,#4]
 651:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 989              	 .loc 1 651 0
 990 0080 C5F80890 	 str r9,[r5,#8]
 653:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** }
 991              	 .loc 1 653 0
 992 0084 2846     	 mov r0,r5
 993 0086 4146     	 mov r1,r8
 994 0088 0A9A     	 ldr r2,[sp,#40]
 995 008a 0B9B     	 ldr r3,[sp,#44]
 996 008c FFF7FEFF 	 bl vTCPWindowInit
 997              	.LVL129:
 998 0090 BDE8F88F 	 pop {r3,r4,r5,r6,r7,r8,r9,r10,fp,pc}
 999              	.LVL130:
 1000              	.L80:
 1001              	 .align 2
 1002              	.L79:
 1003 0094 00000000 	 .word .LANCHOR1
 1004 0098 00000000 	 .word .LANCHOR0
 1005              	 .cfi_endproc
 1006              	.LFE67:
 1008              	 .section .text.vTCPSegmentCleanup,"ax",%progbits
 1009              	 .align 2
 1010              	 .global vTCPSegmentCleanup
 1011              	 .thumb
 1012              	 .thumb_func
 1014              	vTCPSegmentCleanup:
 1015              	.LFB69:
 714:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****         /* Free and clear the TCP segments pointer. This function should only be called
 1016              	 .loc 1 714 0
 1017              	 .cfi_startproc
 1018              	 
 1019              	 
 1020 0000 08B5     	 push {r3,lr}
 1021              	.LCFI15:
 1022              	 .cfi_def_cfa_offset 8
 1023              	 .cfi_offset 3,-8
 1024              	 .cfi_offset 14,-4
 718:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****         {
 1025              	 .loc 1 718 0
 1026 0002 044B     	 ldr r3,.L84
 1027 0004 1868     	 ldr r0,[r3]
 1028 0006 20B1     	 cbz r0,.L81
 720:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****             xTCPSegments = NULL;
 1029              	 .loc 1 720 0
 1030 0008 FFF7FEFF 	 bl vPortFree
 1031              	.LVL131:
 721:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****         }
 1032              	 .loc 1 721 0
 1033 000c 0022     	 movs r2,#0
 1034 000e 014B     	 ldr r3,.L84
 1035 0010 1A60     	 str r2,[r3]
 1036              	.L81:
 1037 0012 08BD     	 pop {r3,pc}
 1038              	.L85:
 1039              	 .align 2
 1040              	.L84:
 1041 0014 00000000 	 .word .LANCHOR1
 1042              	 .cfi_endproc
 1043              	.LFE69:
 1045              	 .section .text.lTCPWindowRxCheck,"ax",%progbits
 1046              	 .align 2
 1047              	 .global lTCPWindowRxCheck
 1048              	 .thumb
 1049              	 .thumb_func
 1051              	lTCPWindowRxCheck:
 1052              	.LFB71:
 803:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	uint32_t ulCurrentSequenceNumber, ulLast, ulSavedSequenceNumber, ulIntermediateResult = 0;
 1053              	 .loc 1 803 0
 1054              	 .cfi_startproc
 1055              	 
 1056              	 
 1057              	.LVL132:
 1058 0000 2DE9F041 	 push {r4,r5,r6,r7,r8,lr}
 1059              	.LCFI16:
 1060              	 .cfi_def_cfa_offset 24
 1061              	 .cfi_offset 4,-24
 1062              	 .cfi_offset 5,-20
 1063              	 .cfi_offset 6,-16
 1064              	 .cfi_offset 7,-12
 1065              	 .cfi_offset 8,-8
 1066              	 .cfi_offset 14,-4
 1067 0004 0646     	 mov r6,r0
 1068 0006 8846     	 mov r8,r1
 1069 0008 1746     	 mov r7,r2
 1070              	.LVL133:
 817:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1071              	 .loc 1 817 0
 1072 000a 0469     	 ldr r4,[r0,#16]
 1073              	.LVL134:
 820:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1074              	 .loc 1 820 0
 1075 000c 0022     	 movs r2,#0
 1076              	.LVL135:
 1077 000e 80F83C20 	 strb r2,[r0,#60]
 823:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1078              	 .loc 1 823 0
 1079 0012 0263     	 str r2,[r0,#48]
 825:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 1080              	 .loc 1 825 0
 1081 0014 8C42     	 cmp r4,r1
 1082 0016 44D1     	 bne .L87
 829:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
 1083              	 .loc 1 829 0
 1084 0018 9F42     	 cmp r7,r3
 1085 001a 00F28B80 	 bhi .L98
 836:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1086              	 .loc 1 836 0
 1087 001e 2744     	 add r7,r7,r4
 1088              	.LVL136:
 838:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
 1089              	 .loc 1 838 0
 1090 0020 D0F8A430 	 ldr r3,[r0,#164]
 1091              	.LVL137:
 1092 0024 002B     	 cmp r3,#0
 1093 0026 38D0     	 beq .L89
 1094              	.LBB124:
 1095              	.LBB125:
 750:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	TCPSegment_t *pxSegment;
 1096              	 .loc 1 750 0
 1097 0028 00F1AC05 	 add r5,r0,#172
 762:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			 pxIterator != pxEnd;
 1098              	 .loc 1 762 0
 1099 002c 9046     	 mov r8,r2
 1100              	.LVL138:
 1101              	.L107:
 1102 002e D6F8B030 	 ldr r3,[r6,#176]
 1103              	.LVL139:
 1104 0032 9D42     	 cmp r5,r3
 1105 0034 1FD0     	 beq .L99
 1106 0036 C646     	 mov lr,r8
 1107              	.LVL140:
 1108              	.L92:
 766:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			/* And see if there is a segment for which:
 1109              	 .loc 1 766 0
 1110 0038 D868     	 ldr r0,[r3,#12]
 1111              	.LVL141:
 771:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				( xSequenceLessThan( pxSegment->ulSequenceNumber, ulNextSequenceNumber ) != 0 ) )
 1112              	 .loc 1 771 0
 1113 003a 0268     	 ldr r2,[r0]
 1114              	.LVL142:
 1115              	.LBB126:
 1116              	.LBB127:
 278:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	{
 1117              	 .loc 1 278 0
 1118 003c 111B     	 subs r1,r2,r4
 1119              	.LBE127:
 1120              	.LBE126:
 771:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				( xSequenceLessThan( pxSegment->ulSequenceNumber, ulNextSequenceNumber ) != 0 ) )
 1121              	 .loc 1 771 0
 1122 003e 0029     	 cmp r1,#0
 1123 0040 0FDB     	 blt .L91
 1124              	.LVL143:
 1125 0042 D143     	 mvns r1,r2
 1126 0044 F942     	 cmn r1,r7
 1127 0046 0CD4     	 bmi .L91
 774:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
 1128              	 .loc 1 774 0
 1129 0048 BEF1000F 	 cmp lr,#0
 1130 004c 08D0     	 beq .L100
 1131              	.LVL144:
 1132 004e DEF80010 	 ldr r1,[lr]
 1133              	.LBB128:
 1134              	.LBB129:
 239:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 1135              	 .loc 1 239 0
 1136 0052 D243     	 mvns r2,r2
 1137              	.LVL145:
 1138              	.LBE129:
 1139              	.LBE128:
 774:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
 1140              	 .loc 1 774 0
 1141 0054 0A44     	 add r2,r2,r1
 776:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				}
 1142              	 .loc 1 776 0
 1143 0056 1EEA220E 	 ands lr,lr,r2,asr#32
 1144 005a 38BF     	 it cc
 1145 005c 8646     	 movcc lr,r0
 1146              	.LVL146:
 1147 005e 00E0     	 b .L91
 1148              	.LVL147:
 1149              	.L100:
 1150 0060 8646     	 mov lr,r0
 1151              	.LVL148:
 1152              	.L91:
 764:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 1153              	 .loc 1 764 0
 1154 0062 5B68     	 ldr r3,[r3,#4]
 1155              	.LVL149:
 762:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			 pxIterator != pxEnd;
 1156              	 .loc 1 762 0
 1157 0064 9D42     	 cmp r5,r3
 1158 0066 E7D1     	 bne .L92
 1159              	.LBE125:
 1160              	.LBE124:
 850:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****                         {
 1161              	 .loc 1 850 0
 1162 0068 BEF1000F 	 cmp lr,#0
 1163 006c 05D0     	 beq .L101
 853:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c ****                         }
 1164              	 .loc 1 853 0
 1165 006e 7046     	 mov r0,lr
 1166              	.LVL150:
 1167 0070 FFF7FEFF 	 bl vTCPWindowFree
 1168              	.LVL151:
 1169 0074 DBE7     	 b .L107
 1170              	.LVL152:
 1171              	.L99:
 1172              	.LBB131:
 1173              	.LBB130:
 762:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			 pxIterator != pxEnd;
 1174              	 .loc 1 762 0
 1175 0076 3C46     	 mov r4,r7
 1176              	.LVL153:
 1177 0078 00E0     	 b .L108
 1178              	.LVL154:
 1179              	.L101:
 1180              	.LBE130:
 1181              	.LBE131:
 1182 007a 3C46     	 mov r4,r7
 1183              	.LVL155:
 1184              	.L108:
 861:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						if( pxFound == NULL )
 1185              	 .loc 1 861 0
 1186 007c 3046     	 mov r0,r6
 1187 007e 2146     	 mov r1,r4
 1188 0080 FFF7FEFF 	 bl xTCPWindowRxFind
 1189              	.LVL156:
 862:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						{
 1190              	 .loc 1 862 0
 1191 0084 20B1     	 cbz r0,.L94
 866:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1192              	 .loc 1 866 0
 1193 0086 8268     	 ldr r2,[r0,#8]
 1194 0088 1444     	 add r4,r4,r2
 1195              	.LVL157:
 870:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					}
 1196              	 .loc 1 870 0
 1197 008a FFF7FEFF 	 bl vTCPWindowFree
 1198              	.LVL158:
 871:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1199              	 .loc 1 871 0
 1200 008e F5E7     	 b .L108
 1201              	.LVL159:
 1202              	.L94:
 873:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					{
 1203              	 .loc 1 873 0
 1204 0090 BC42     	 cmp r4,r7
 1205 0092 02D0     	 beq .L89
 877:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1206              	 .loc 1 877 0
 1207 0094 E71B     	 subs r7,r4,r7
 1208              	.LVL160:
 1209 0096 3763     	 str r7,[r6,#48]
 1210 0098 2746     	 mov r7,r4
 1211              	.LVL161:
 1212              	.L89:
 891:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1213              	 .loc 1 891 0
 1214 009a 3761     	 str r7,[r6,#16]
 1215              	.LVL162:
 895:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
 1216              	 .loc 1 895 0
 1217 009c 0020     	 movs r0,#0
 1218 009e BDE8F081 	 pop {r4,r5,r6,r7,r8,pc}
 1219              	.LVL163:
 1220              	.L87:
 898:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 1221              	 .loc 1 898 0
 1222 00a2 4A1C     	 adds r2,r1,#1
 1223 00a4 A242     	 cmp r2,r4
 1224 00a6 49D0     	 beq .L102
 911:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1225              	 .loc 1 911 0
 1226 00a8 CD19     	 adds r5,r1,r7
 1227              	.LVL164:
 913:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			/* The cast from unsigned long to signed long is on purpose. */
 1228              	 .loc 1 913 0
 1229 00aa 2A1B     	 subs r2,r5,r4
 1230              	.LVL165:
 917:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
 1231              	 .loc 1 917 0
 1232 00ac 002A     	 cmp r2,#0
 1233 00ae 49DD     	 ble .L103
 924:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
 1234              	 .loc 1 924 0
 1235 00b0 9A42     	 cmp r2,r3
 1236 00b2 4BDC     	 bgt .L104
 1237              	.LVL166:
 1238              	.L109:
 942:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					if( pxFound == NULL )
 1239              	 .loc 1 942 0
 1240 00b4 3046     	 mov r0,r6
 1241 00b6 2946     	 mov r1,r5
 1242 00b8 FFF7FEFF 	 bl xTCPWindowRxFind
 1243              	.LVL167:
 943:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					{
 1244              	 .loc 1 943 0
 1245 00bc 10B1     	 cbz r0,.L95
 947:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				}
 1246              	 .loc 1 947 0
 1247 00be 8368     	 ldr r3,[r0,#8]
 1248 00c0 1D44     	 add r5,r5,r3
 1249              	.LVL168:
 948:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1250              	 .loc 1 948 0
 1251 00c2 F7E7     	 b .L109
 1252              	.L95:
 963:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1253              	 .loc 1 963 0
 1254 00c4 254B     	 ldr r3,.L111
 1255 00c6 C6F88030 	 str r3,[r6,#128]
 966:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1256              	 .loc 1 966 0
 1257 00ca 4FEA0863 	 lsl r3,r8,#24
 1258 00ce 43EA1863 	 orr r3,r3,r8,lsr#24
 1259 00d2 08F47F42 	 and r2,r8,#65280
 1260 00d6 43EA0223 	 orr r3,r3,r2,lsl#8
 1261 00da 08F47F02 	 and r2,r8,#16711680
 1262 00de 43EA1223 	 orr r3,r3,r2,lsr#8
 1263 00e2 C6F88430 	 str r3,[r6,#132]
 969:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1264              	 .loc 1 969 0
 1265 00e6 2B06     	 lsls r3,r5,#24
 1266 00e8 43EA1563 	 orr r3,r3,r5,lsr#24
 1267 00ec 05F47F42 	 and r2,r5,#65280
 1268 00f0 43EA0223 	 orr r3,r3,r2,lsl#8
 1269 00f4 05F47F05 	 and r5,r5,#16711680
 1270              	.LVL169:
 1271 00f8 43EA1525 	 orr r5,r3,r5,lsr#8
 1272 00fc C6F88850 	 str r5,[r6,#136]
 972:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1273              	 .loc 1 972 0
 1274 0100 0C23     	 movs r3,#12
 1275 0102 86F83C30 	 strb r3,[r6,#60]
 974:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1276              	 .loc 1 974 0
 1277 0106 3046     	 mov r0,r6
 1278              	.LVL170:
 1279 0108 4146     	 mov r1,r8
 1280 010a FFF7FEFF 	 bl xTCPWindowRxFind
 1281              	.LVL171:
 976:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
 1282              	 .loc 1 976 0
 1283 010e 08BB     	 cbnz r0,.L105
 985:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1284              	 .loc 1 985 0
 1285 0110 3046     	 mov r0,r6
 1286              	.LVL172:
 1287 0112 4146     	 mov r1,r8
 1288 0114 3A46     	 mov r2,r7
 1289 0116 0123     	 movs r3,#1
 1290 0118 FFF7FEFF 	 bl xTCPWindowNew
 1291              	.LVL173:
 987:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					{
 1292              	 .loc 1 987 0
 1293 011c 30B9     	 cbnz r0,.L97
 991:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1294              	 .loc 1 991 0
 1295 011e 0023     	 movs r3,#0
 1296 0120 86F83C30 	 strb r3,[r6,#60]
 1297              	.LVL174:
 995:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					}
 1298              	 .loc 1 995 0
 1299 0124 4FF0FF30 	 mov r0,#-1
 1300              	.LVL175:
 1301 0128 BDE8F081 	 pop {r4,r5,r6,r7,r8,pc}
 1302              	.LVL176:
 1303              	.L97:
1009:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						lReturn = ( int32_t ) ulIntermediateResult;
 1304              	 .loc 1 1009 0
 1305 012c C4EB0800 	 rsb r0,r4,r8
 1306              	.LVL177:
 1307 0130 BDE8F081 	 pop {r4,r5,r6,r7,r8,pc}
 1308              	.LVL178:
 1309              	.L98:
 832:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
 1310              	 .loc 1 832 0
 1311 0134 4FF0FF30 	 mov r0,#-1
 1312              	.LVL179:
 1313 0138 BDE8F081 	 pop {r4,r5,r6,r7,r8,pc}
 1314              	.LVL180:
 1315              	.L102:
 902:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 1316              	 .loc 1 902 0
 1317 013c 4FF0FF30 	 mov r0,#-1
 1318              	.LVL181:
 1319 0140 BDE8F081 	 pop {r4,r5,r6,r7,r8,pc}
 1320              	.LVL182:
 1321              	.L103:
 922:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
 1322              	 .loc 1 922 0
 1323 0144 4FF0FF30 	 mov r0,#-1
 1324              	.LVL183:
 1325 0148 BDE8F081 	 pop {r4,r5,r6,r7,r8,pc}
 1326              	.LVL184:
 1327              	.L104:
 929:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
 1328              	 .loc 1 929 0
 1329 014c 4FF0FF30 	 mov r0,#-1
 1330              	.LVL185:
 1331 0150 BDE8F081 	 pop {r4,r5,r6,r7,r8,pc}
 1332              	.LVL186:
 1333              	.L105:
 981:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				}
 1334              	 .loc 1 981 0
 1335 0154 4FF0FF30 	 mov r0,#-1
 1336              	.LVL187:
1017:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1337              	 .loc 1 1017 0
 1338 0158 BDE8F081 	 pop {r4,r5,r6,r7,r8,pc}
 1339              	.LVL188:
 1340              	.L112:
 1341              	 .align 2
 1342              	.L111:
 1343 015c 0101050A 	 .word 168100097
 1344              	 .cfi_endproc
 1345              	.LFE71:
 1347              	 .section .text.lTCPWindowTxAdd,"ax",%progbits
 1348              	 .align 2
 1349              	 .global lTCPWindowTxAdd
 1350              	 .thumb
 1351              	 .thumb_func
 1353              	lTCPWindowTxAdd:
 1354              	.LFB73:
1061:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	int32_t lBytesLeft = ( int32_t ) ulLength, lToWrite;
 1355              	 .loc 1 1061 0
 1356              	 .cfi_startproc
 1357              	 
 1358              	 
 1359              	.LVL189:
 1360 0000 2DE9F04F 	 push {r4,r5,r6,r7,r8,r9,r10,fp,lr}
 1361              	.LCFI17:
 1362              	 .cfi_def_cfa_offset 36
 1363              	 .cfi_offset 4,-36
 1364              	 .cfi_offset 5,-32
 1365              	 .cfi_offset 6,-28
 1366              	 .cfi_offset 7,-24
 1367              	 .cfi_offset 8,-20
 1368              	 .cfi_offset 9,-16
 1369              	 .cfi_offset 10,-12
 1370              	 .cfi_offset 11,-8
 1371              	 .cfi_offset 14,-4
 1372 0004 83B0     	 sub sp,sp,#12
 1373              	.LCFI18:
 1374              	 .cfi_def_cfa_offset 48
 1375 0006 0546     	 mov r5,r0
 1376 0008 1646     	 mov r6,r2
 1377 000a 9A46     	 mov r10,r3
1062:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	int32_t lDone = 0;
 1378              	 .loc 1 1062 0
 1379 000c 0F46     	 mov r7,r1
 1380              	.LVL190:
1065:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1381              	 .loc 1 1065 0
 1382 000e C36F     	 ldr r3,[r0,#124]
 1383              	.LVL191:
1069:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 1384              	 .loc 1 1069 0
 1385 0010 F3B1     	 cbz r3,.L121
1071:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
 1386              	 .loc 1 1071 0
 1387 0012 9A68     	 ldr r2,[r3,#8]
 1388              	.LVL192:
 1389 0014 5868     	 ldr r0,[r3,#4]
 1390              	.LVL193:
 1391 0016 8242     	 cmp r2,r0
 1392 0018 1DDA     	 bge .L122
1073:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
 1393              	 .loc 1 1073 0
 1394 001a 9C7D     	 ldrb r4,[r3,#22]
 1395 001c 14F0010F 	 tst r4,#1
 1396 0020 1CD1     	 bne .L123
1073:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
 1397              	 .loc 1 1073 0 is_stmt 0 discriminator 1
 1398 0022 F2B1     	 cbz r2,.L124
 1399              	.LVL194:
1077:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1400              	 .loc 1 1077 0 is_stmt 1
 1401 0024 C2EB0008 	 rsb r8,r2,r0
 1402              	.LVL195:
 1403              	.LBB142:
 1404              	.LBB143:
 1405              	 .file 3 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include/FreeRTOS_IP.h"
   1:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /*
   2:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * FreeRTOS+TCP V2.2.2
   3:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  *
   5:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * this software and associated documentation files (the "Software"), to deal in
   7:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * the Software without restriction, including without limitation the rights to
   8:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * subject to the following conditions:
  11:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  *
  12:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * The above copyright notice and this permission notice shall be included in all
  13:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * copies or substantial portions of the Software.
  14:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  *
  15:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  *
  22:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * http://aws.amazon.com/freertos
  23:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * http://www.FreeRTOS.org
  24:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  */
  25:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  26:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #ifndef FREERTOS_IP_H
  27:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define FREERTOS_IP_H
  28:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  29:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #ifdef __cplusplus
  30:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** extern "C" {
  31:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #endif
  32:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  33:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #include "FreeRTOS.h"
  34:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #include "task.h"
  35:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  36:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /* Application level configuration options. */
  37:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #include "FreeRTOSIPConfig.h"
  38:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #include "FreeRTOSIPConfigDefaults.h"
  39:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #include "IPTraceMacroDefaults.h"
  40:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  41:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #ifdef __COVERITY__
  42:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	/* Coverity static checks don't like inlined functions.
  43:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	As it is up to the users to allow inlining, don't let
  44:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	let Coverity know about it. */
  45:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  46:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	#ifdef portINLINE
  47:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 		/* The usage of #undef violates the rule. */
  48:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 		#undef portINLINE
  49:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  50:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	#endif
  51:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  52:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	#define	portINLINE
  53:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #endif
  54:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  55:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /* Some constants defining the sizes of several parts of a packet.
  56:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** These defines come before inlucding the configuration header files. */
  57:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /* The size of the Ethernet header is 14, meaning that 802.1Q VLAN tags
  58:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** are not ( yet ) supported. */
  59:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipSIZE_OF_ETH_HEADER			14U
  60:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipSIZE_OF_IPv4_HEADER			20U
  61:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipSIZE_OF_IGMP_HEADER			8U
  62:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipSIZE_OF_ICMP_HEADER			8U
  63:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipSIZE_OF_UDP_HEADER			8U
  64:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipSIZE_OF_TCP_HEADER			20U
  65:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  66:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipSIZE_OF_IPv4_ADDRESS			4U
  67:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  68:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /*
  69:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * Generate a randomized TCP Initial Sequence Number per RFC.
  70:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  * This function must be provided by the application builder.
  71:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  */
  72:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /* This function is defined generally by the application. */
  73:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** extern uint32_t ulApplicationGetNextSequenceNumber( uint32_t ulSourceAddress,
  74:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 													uint16_t usSourcePort,
  75:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 													uint32_t ulDestinationAddress,
  76:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 													uint16_t usDestinationPort );
  77:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  78:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /* The number of octets in the MAC and IP addresses respectively. */
  79:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipMAC_ADDRESS_LENGTH_BYTES ( 6 )
  80:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipIP_ADDRESS_LENGTH_BYTES ( 4 )
  81:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  82:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /* IP protocol definitions. */
  83:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipPROTOCOL_ICMP			( 1U )
  84:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipPROTOCOL_IGMP         ( 2U )
  85:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipPROTOCOL_TCP			( 6U )
  86:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipPROTOCOL_UDP			( 17U )
  87:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipPROTOCOL_RAW			( 255 )
  88:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  89:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /* The character used to fill ICMP echo requests, and therefore also the
  90:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** character expected to fill ICMP echo replies. */
  91:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipECHO_DATA_FILL_BYTE						'x'
  92:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  93:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /* Dimensions the buffers that are filled by received Ethernet frames. */
  94:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipSIZE_OF_ETH_CRC_BYTES					( 4UL )
  95:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipSIZE_OF_ETH_OPTIONAL_802_1Q_TAG_BYTES	( 4UL )
  96:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define ipTOTAL_ETHERNET_FRAME_SIZE				( ( ( uint32_t ) ipconfigNETWORK_MTU ) + ( ( uint32_t ) ipSI
  97:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  98:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
  99:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /* Space left at the beginning of a network buffer storage area to store a
 100:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** pointer back to the network buffer.  Should be a multiple of 8 to ensure 8 byte
 101:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** alignment is maintained on architectures that require it.
 102:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 103:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** In order to get a 32-bit alignment of network packets, an offset of 2 bytes
 104:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** would be desirable, as defined by ipconfigPACKET_FILLER_SIZE.  So the malloc'd
 105:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** buffer will have the following contents:
 106:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	uint32_t pointer;	// word-aligned
 107:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	uchar_8 filler[6];
 108:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	<< ETH-header >>	// half-word-aligned
 109:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	uchar_8 dest[6];    // start of pucEthernetBuffer
 110:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	uchar_8 dest[6];
 111:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	uchar16_t type;
 112:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	<< IP-header >>		// word-aligned
 113:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	uint8_t ucVersionHeaderLength;
 114:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	etc
 115:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****  */
 116:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 117:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #if( ipconfigBUFFER_PADDING != 0 )
 118:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****     #define ipBUFFER_PADDING    ipconfigBUFFER_PADDING
 119:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #else
 120:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h ****     #define ipBUFFER_PADDING    ( 8U + ipconfigPACKET_FILLER_SIZE )
 121:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #endif
 122:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 123:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /* The structure used to store buffers and pass them around the network stack.
 124:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** Buffers can be in use by the stack, in use by the network interface hardware
 125:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** driver, or free (not in use). */
 126:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** typedef struct xNETWORK_BUFFER
 127:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** {
 128:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	ListItem_t xBufferListItem; 	/* Used to reference the buffer form the free buffer list or a socket
 129:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	uint32_t ulIPAddress;			/* Source or destination IP address, depending on usage scenario. */
 130:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	uint8_t *pucEthernetBuffer; 	/* Pointer to the start of the Ethernet frame. */
 131:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	size_t xDataLength; 			/* Starts by holding the total Ethernet frame length, then the UDP/TCP payl
 132:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	uint16_t usPort;				/* Source or destination port, depending on usage scenario. */
 133:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	uint16_t usBoundPort;			/* The port to which a transmitting socket is bound. */
 134:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	#if( ipconfigUSE_LINKED_RX_MESSAGES != 0 )
 135:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 		struct xNETWORK_BUFFER *pxNextBuffer; /* Possible optimisation for expert users - requires networ
 136:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	#endif
 137:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** } NetworkBufferDescriptor_t;
 138:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 139:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #include "pack_struct_start.h"
 140:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** struct xMAC_ADDRESS
 141:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** {
 142:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	uint8_t ucBytes[ ipMAC_ADDRESS_LENGTH_BYTES ];
 143:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** }
 144:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #include "pack_struct_end.h"
 145:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 146:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** typedef struct xMAC_ADDRESS MACAddress_t;
 147:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 148:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** typedef enum eNETWORK_EVENTS
 149:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** {
 150:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	eNetworkUp,		/* The network is configured. */
 151:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	eNetworkDown	/* The network connection has been lost. */
 152:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** } eIPCallbackEvent_t;
 153:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 154:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /* MISRA check: some modules refer to this typedef even though
 155:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** ipconfigSUPPORT_OUTGOING_PINGS is not enabled. */
 156:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** typedef enum ePING_REPLY_STATUS
 157:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** {
 158:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	eSuccess = 0,		/* A correct reply has been received for an outgoing ping. */
 159:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	eInvalidChecksum,	/* A reply was received for an outgoing ping but the checksum of the reply was i
 160:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	eInvalidData		/* A reply was received to an outgoing ping but the payload of the reply was not cor
 161:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** } ePingReplyStatus_t;
 162:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 163:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** typedef struct xIP_TIMER
 164:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** {
 165:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	uint32_t
 166:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 		bActive : 1,	/* This timer is running and must be processed. */
 167:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 		bExpired : 1;	/* Timer has expired and a task must be processed. */
 168:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	TimeOut_t xTimeOut;
 169:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	TickType_t ulRemainingTime;
 170:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	TickType_t ulReloadTime;
 171:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** } IPTimer_t;
 172:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 173:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** /* Endian related definitions. */
 174:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #if( ipconfigBYTE_ORDER == pdFREERTOS_LITTLE_ENDIAN )
 175:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 176:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	/* FreeRTOS_htons / FreeRTOS_htonl: some platforms might have built-in versions
 177:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	using a single instruction so allow these versions to be overridden. */
 178:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	#ifndef FreeRTOS_htons
 179:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 		#define FreeRTOS_htons( usIn ) ( (uint16_t) ( ( ( usIn ) << 8U ) | ( ( usIn ) >> 8U ) ) )
 180:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	#endif
 181:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 182:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	#ifndef	FreeRTOS_htonl
 183:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 		#define FreeRTOS_htonl( ulIn ) 											\
 184:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 			(																	\
 185:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 				( uint32_t ) 													\
 186:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 				( 																\
 187:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 					( ( ( ( uint32_t ) ( ulIn ) )                ) << 24  ) | 	\
 188:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 					( ( ( ( uint32_t ) ( ulIn ) ) & 0x0000ff00UL ) <<  8  ) | 	\
 189:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 					( ( ( ( uint32_t ) ( ulIn ) ) & 0x00ff0000UL ) >>  8  ) | 	\
 190:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 					( ( ( ( uint32_t ) ( ulIn ) )                ) >> 24  )  	\
 191:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 				) 																\
 192:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 			)
 193:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	#endif
 194:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 195:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #else /* ipconfigBYTE_ORDER */
 196:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	#define FreeRTOS_htons( x ) ( ( uint16_t ) ( x ) )
 198:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	#define FreeRTOS_htonl( x ) ( ( uint32_t ) ( x ) )
 199:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 200:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #endif /* ipconfigBYTE_ORDER == pdFREERTOS_LITTLE_ENDIAN */
 201:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 202:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define FreeRTOS_ntohs( x ) FreeRTOS_htons( x )
 203:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #define FreeRTOS_ntohl( x ) FreeRTOS_htonl( x )
 204:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 205:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** #if( ipconfigHAS_INLINE_FUNCTIONS == 1 )
 206:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 207:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	static portINLINE int32_t  FreeRTOS_max_int32  (int32_t  a, int32_t  b);
 208:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	static portINLINE uint32_t FreeRTOS_max_uint32 (uint32_t a, uint32_t b);
 209:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	static portINLINE int32_t  FreeRTOS_min_int32  (int32_t  a, int32_t  b);
 210:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	static portINLINE uint32_t FreeRTOS_min_uint32 (uint32_t a, uint32_t b);
 211:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	static portINLINE uint32_t FreeRTOS_round_up   (uint32_t a, uint32_t d);
 212:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	static portINLINE uint32_t FreeRTOS_round_down (uint32_t a, uint32_t d);
 213:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	static portINLINE BaseType_t  FreeRTOS_min_BaseType  (BaseType_t  a, BaseType_t  b);
 214:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 
 215:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	static portINLINE int32_t  FreeRTOS_max_int32  (int32_t  a, int32_t  b) { return ( a >= b ) ? a : 
 216:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	static portINLINE uint32_t FreeRTOS_max_uint32 (uint32_t a, uint32_t b) { return ( a >= b ) ? a : 
 217:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include\FreeRTOS_IP.h **** 	static portINLINE int32_t  FreeRTOS_min_int32  (int32_t  a, int32_t  b) { return ( a <= b ) ? a : 
 1406              	 .loc 3 217 0
 1407 0028 8845     	 cmp r8,r1
 1408 002a A8BF     	 it ge
 1409 002c 8846     	 movge r8,r1
 1410              	.LVL196:
 1411              	.LBE143:
 1412              	.LBE142:
1079:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1413              	 .loc 1 1079 0
 1414 002e 4244     	 add r2,r2,r8
 1415              	.LVL197:
 1416 0030 9A60     	 str r2,[r3,#8]
 1417              	.LVL198:
1081:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					{
 1418              	 .loc 1 1081 0
 1419 0032 9042     	 cmp r0,r2
1084:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					}
 1420              	 .loc 1 1084 0
 1421 0034 DCBF     	 itt le
 1422 0036 0023     	 movle r3,#0
 1423              	.LVL199:
 1424 0038 EB67     	 strle r3,[r5,#124]
1087:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1425              	 .loc 1 1087 0
 1426 003a C8EB0107 	 rsb r7,r8,r1
 1427              	.LVL200:
1091:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1428              	 .loc 1 1091 0
 1429 003e 6B6B     	 ldr r3,[r5,#52]
 1430 0040 4344     	 add r3,r3,r8
 1431 0042 6B63     	 str r3,[r5,#52]
 1432              	.LVL201:
 1433              	.LBB144:
 1434              	.LBB145:
1046:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		if( lReturn >= lMax )
 1435              	 .loc 1 1046 0
 1436 0044 4644     	 add r6,r6,r8
 1437              	.LVL202:
1047:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 1438              	 .loc 1 1047 0
 1439 0046 B245     	 cmp r10,r6
 1440 0048 0DDC     	 bgt .L114
1049:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 1441              	 .loc 1 1049 0
 1442 004a CAEB0606 	 rsb r6,r10,r6
 1443              	.LVL203:
 1444 004e 0AE0     	 b .L114
 1445              	.LVL204:
 1446              	.L121:
 1447              	.LBE145:
 1448              	.LBE144:
1063:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	int32_t lBufferIndex = lPosition;
 1449              	 .loc 1 1063 0
 1450 0050 4FF00008 	 mov r8,#0
 1451 0054 07E0     	 b .L114
 1452              	.LVL205:
 1453              	.L122:
 1454 0056 4FF00008 	 mov r8,#0
 1455 005a 04E0     	 b .L114
 1456              	.L123:
 1457 005c 4FF00008 	 mov r8,#0
 1458 0060 01E0     	 b .L114
 1459              	.L124:
 1460 0062 4FF00008 	 mov r8,#0
 1461              	.LVL206:
 1462              	.L114:
1115:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 1463              	 .loc 1 1115 0
 1464 0066 002F     	 cmp r7,#0
 1465 0068 2DDD     	 ble .L116
1119:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1466              	 .loc 1 1119 0
 1467 006a 4FF00009 	 mov r9,#0
1135:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1468              	 .loc 1 1135 0
 1469 006e 05F1540B 	 add fp,r5,#84
 1470              	.LBB146:
 1471              	.LBB147:
 294:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
 1472              	 .loc 1 294 0
 1473 0072 05F15C03 	 add r3,r5,#92
 1474 0076 0193     	 str r3,[sp,#4]
 1475              	.LVL207:
 1476              	.L125:
 1477              	.LBE147:
 1478              	.LBE146:
1119:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1479              	 .loc 1 1119 0
 1480 0078 2846     	 mov r0,r5
 1481 007a 696B     	 ldr r1,[r5,#52]
 1482 007c B5F8BC20 	 ldrh r2,[r5,#188]
 1483 0080 4B46     	 mov r3,r9
 1484 0082 FFF7FEFF 	 bl xTCPWindowNew
 1485              	.LVL208:
1121:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
 1486              	 .loc 1 1121 0
 1487 0086 0446     	 mov r4,r0
 1488 0088 E8B1     	 cbz r0,.L116
 1489              	.LVL209:
 1490              	.LBB149:
 1491              	.LBB150:
 1492              	 .loc 3 217 0
 1493 008a 4368     	 ldr r3,[r0,#4]
 1494 008c BB42     	 cmp r3,r7
 1495 008e A8BF     	 it ge
 1496 0090 3B46     	 movge r3,r7
 1497              	.LBE150:
 1498              	.LBE149:
1127:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				pxSegment->lStreamPos = lBufferIndex;
 1499              	 .loc 1 1127 0
 1500 0092 8360     	 str r3,[r0,#8]
1128:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				lBytesLeft -= lToWrite;
 1501              	 .loc 1 1128 0
 1502 0094 C660     	 str r6,[r0,#12]
1129:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				lBufferIndex = lTCPIncrementTxPosition( lBufferIndex, lMax, lToWrite );
 1503              	 .loc 1 1129 0
 1504 0096 FF1A     	 subs r7,r7,r3
 1505              	.LVL210:
 1506              	.LBB151:
 1507              	.LBB152:
1046:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		if( lReturn >= lMax )
 1508              	 .loc 1 1046 0
 1509 0098 1E44     	 add r6,r6,r3
 1510              	.LVL211:
1047:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 1511              	 .loc 1 1047 0
 1512 009a B245     	 cmp r10,r6
1049:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 1513              	 .loc 1 1049 0
 1514 009c D8BF     	 it le
 1515 009e CAEB0606 	 rsble r6,r10,r6
 1516              	.LVL212:
 1517              	.LBE152:
 1518              	.LBE151:
1131:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				lDone += lToWrite;
 1519              	 .loc 1 1131 0
 1520 00a2 6A6B     	 ldr r2,[r5,#52]
 1521 00a4 1A44     	 add r2,r2,r3
 1522 00a6 6A63     	 str r2,[r5,#52]
 1523              	.LVL213:
1132:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1524              	 .loc 1 1132 0
 1525 00a8 9844     	 add r8,r8,r3
 1526              	.LVL214:
 1527              	.LBB153:
 1528              	.LBB148:
 294:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
 1529              	 .loc 1 294 0
 1530 00aa 5846     	 mov r0,fp
 1531              	.LVL215:
 1532 00ac 04F11801 	 add r1,r4,#24
 1533              	.LVL216:
 1534 00b0 019A     	 ldr r2,[sp,#4]
 1535 00b2 FFF7FEFF 	 bl vListInsertGeneric
 1536              	.LVL217:
 1537              	.LBE148:
 1538              	.LBE153:
1139:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
 1539              	 .loc 1 1139 0
 1540 00b6 A268     	 ldr r2,[r4,#8]
 1541 00b8 6368     	 ldr r3,[r4,#4]
 1542 00ba 9A42     	 cmp r2,r3
1141:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				}
 1543              	 .loc 1 1141 0
 1544 00bc A8BF     	 it ge
 1545 00be 4C46     	 movge r4,r9
 1546              	.LVL218:
 1547 00c0 EC67     	 str r4,[r5,#124]
 1548              	.LVL219:
1115:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 1549              	 .loc 1 1115 0
 1550 00c2 002F     	 cmp r7,#0
 1551 00c4 D8DC     	 bgt .L125
 1552              	.LVL220:
 1553              	.L116:
1176:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1554              	 .loc 1 1176 0
 1555 00c6 4046     	 mov r0,r8
 1556 00c8 03B0     	 add sp,sp,#12
 1557              	.LCFI19:
 1558              	 .cfi_def_cfa_offset 36
 1559              	 
 1560 00ca BDE8F08F 	 pop {r4,r5,r6,r7,r8,r9,r10,fp,pc}
 1561              	 .cfi_endproc
 1562              	.LFE73:
 1564 00ce 00BF     	 .section .text.xTCPWindowTxDone,"ax",%progbits
 1565              	 .align 2
 1566              	 .global xTCPWindowTxDone
 1567              	 .thumb
 1568              	 .thumb_func
 1570              	xTCPWindowTxDone:
 1571              	.LFB74:
1184:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		return listLIST_IS_EMPTY( ( &pxWindow->xTxSegments) );
 1572              	 .loc 1 1184 0
 1573              	 .cfi_startproc
 1574              	 
 1575              	 
 1576              	 
 1577              	.LVL221:
1185:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
 1578              	 .loc 1 1185 0
 1579 0000 D0F89000 	 ldr r0,[r0,#144]
 1580              	.LVL222:
1186:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1581              	 .loc 1 1186 0
 1582 0004 B0FA80F0 	 clz r0,r0
 1583 0008 4009     	 lsrs r0,r0,#5
 1584 000a 7047     	 bx lr
 1585              	 .cfi_endproc
 1586              	.LFE74:
 1588              	 .section .text.xTCPWindowTxHasData,"ax",%progbits
 1589              	 .align 2
 1590              	 .global xTCPWindowTxHasData
 1591              	 .thumb
 1592              	 .thumb_func
 1594              	xTCPWindowTxHasData:
 1595              	.LFB76:
1254:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	TCPSegment_t const * pxSegment;
 1596              	 .loc 1 1254 0
 1597              	 .cfi_startproc
 1598              	 
 1599              	 
 1600              	.LVL223:
1259:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1601              	 .loc 1 1259 0
 1602 0000 0023     	 movs r3,#0
 1603 0002 1360     	 str r3,[r2]
1261:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 1604              	 .loc 1 1261 0
 1605 0004 036C     	 ldr r3,[r0,#64]
 1606 0006 43BB     	 cbnz r3,.L132
1254:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	TCPSegment_t const * pxSegment;
 1607              	 .loc 1 1254 0
 1608 0008 70B5     	 push {r4,r5,r6,lr}
 1609              	.LCFI20:
 1610              	 .cfi_def_cfa_offset 16
 1611              	 .cfi_offset 4,-16
 1612              	 .cfi_offset 5,-12
 1613              	 .cfi_offset 6,-8
 1614              	 .cfi_offset 14,-4
 1615 000a 1546     	 mov r5,r2
 1616 000c 0446     	 mov r4,r0
 1617              	.LVL224:
 1618              	.LBB160:
 1619              	.LBB161:
 540:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 1620              	 .loc 1 540 0
 1621 000e 836E     	 ldr r3,[r0,#104]
 1622 0010 7BB1     	 cbz r3,.L131
 1623              	.LVL225:
 547:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 1624              	 .loc 1 547 0
 1625 0012 436F     	 ldr r3,[r0,#116]
 1626 0014 DE68     	 ldr r6,[r3,#12]
 1627              	.LVL226:
 1628              	.LBE161:
 1629              	.LBE160:
1272:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
 1630              	 .loc 1 1272 0
 1631 0016 66B1     	 cbz r6,.L131
 1632              	.LVL227:
 1633              	.LBB162:
 1634              	.LBB163:
 309:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** }
 1635              	 .loc 1 309 0
 1636 0018 FFF7FEFF 	 bl xTaskGetTickCount
 1637              	.LVL228:
 1638 001c 3369     	 ldr r3,[r6,#16]
 1639 001e C01A     	 subs r0,r0,r3
 1640              	.LBE163:
 1641              	.LBE162:
1281:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1642              	 .loc 1 1281 0
 1643 0020 327D     	 ldrb r2,[r6,#20]
 1644 0022 A36B     	 ldr r3,[r4,#56]
 1645 0024 9340     	 lsls r3,r3,r2
 1646              	.LVL229:
1283:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
 1647              	 .loc 1 1283 0
 1648 0026 8342     	 cmp r3,r0
 1649 0028 19D9     	 bls .L133
1286:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				}
 1650              	 .loc 1 1286 0
 1651 002a 1B1A     	 subs r3,r3,r0
 1652              	.LVL230:
 1653 002c 2B60     	 str r3,[r5]
 1654              	.LVL231:
1289:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
 1655              	 .loc 1 1289 0
 1656 002e 0120     	 movs r0,#1
 1657 0030 70BD     	 pop {r4,r5,r6,pc}
 1658              	.LVL232:
 1659              	.L131:
 1660              	.LBB164:
 1661              	.LBB165:
 540:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 1662              	 .loc 1 540 0
 1663 0032 636D     	 ldr r3,[r4,#84]
 1664 0034 ABB1     	 cbz r3,.L134
 1665              	.LVL233:
 547:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 1666              	 .loc 1 547 0
 1667 0036 236E     	 ldr r3,[r4,#96]
 1668 0038 DD68     	 ldr r5,[r3,#12]
 1669              	.LVL234:
 1670              	.LBE165:
 1671              	.LBE164:
1298:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
 1672              	 .loc 1 1298 0
 1673 003a A5B1     	 cbz r5,.L135
1302:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
 1674              	 .loc 1 1302 0
 1675 003c 2046     	 mov r0,r4
 1676              	.LVL235:
 1677 003e FFF7FEFF 	 bl prvTCPWindowTxHasSpace
 1678              	.LVL236:
 1679 0042 90B1     	 cbz r0,.L136
1307:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
 1680              	 .loc 1 1307 0
 1681 0044 2378     	 ldrb r3,[r4]
 1682 0046 13F0020F 	 tst r3,#2
 1683 004a 10D0     	 beq .L137
1307:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
 1684              	 .loc 1 1307 0 is_stmt 0 discriminator 1
 1685 004c AB68     	 ldr r3,[r5,#8]
 1686 004e 6868     	 ldr r0,[r5,#4]
 1687 0050 8342     	 cmp r3,r0
 1688 0052 B4BF     	 ite lt
 1689 0054 0020     	 movlt r0,#0
 1690 0056 0120     	 movge r0,#1
 1691 0058 70BD     	 pop {r4,r5,r6,pc}
 1692              	.LVL237:
 1693              	.L132:
 1694              	.LCFI21:
 1695              	 .cfi_def_cfa_offset 0
 1696              	 .cfi_restore 4
 1697              	 .cfi_restore 5
 1698              	 .cfi_restore 6
 1699              	 .cfi_restore 14
1266:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 1700              	 .loc 1 1266 0 is_stmt 1
 1701 005a 0120     	 movs r0,#1
 1702              	.LVL238:
1322:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1703              	 .loc 1 1322 0
 1704 005c 7047     	 bx lr
 1705              	.LVL239:
 1706              	.L133:
 1707              	.LCFI22:
 1708              	 .cfi_def_cfa_offset 16
 1709              	 .cfi_offset 4,-16
 1710              	 .cfi_offset 5,-12
 1711              	 .cfi_offset 6,-8
 1712              	 .cfi_offset 14,-4
1289:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
 1713              	 .loc 1 1289 0
 1714 005e 0120     	 movs r0,#1
 1715 0060 70BD     	 pop {r4,r5,r6,pc}
 1716              	.LVL240:
 1717              	.L134:
1300:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				}
 1718              	 .loc 1 1300 0
 1719 0062 0020     	 movs r0,#0
 1720              	.LVL241:
 1721 0064 70BD     	 pop {r4,r5,r6,pc}
 1722              	.LVL242:
 1723              	.L135:
 1724 0066 0020     	 movs r0,#0
 1725              	.LVL243:
 1726 0068 70BD     	 pop {r4,r5,r6,pc}
 1727              	.LVL244:
 1728              	.L136:
1305:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				}
 1729              	 .loc 1 1305 0
 1730 006a 0020     	 movs r0,#0
 1731 006c 70BD     	 pop {r4,r5,r6,pc}
 1732              	.LVL245:
 1733              	.L137:
1316:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				}
 1734              	 .loc 1 1316 0
 1735 006e 0120     	 movs r0,#1
 1736              	.LVL246:
1322:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1737              	 .loc 1 1322 0
 1738 0070 70BD     	 pop {r4,r5,r6,pc}
 1739              	 .cfi_endproc
 1740              	.LFE76:
 1742 0072 00BF     	 .section .text.ulTCPWindowTxGet,"ax",%progbits
 1743              	 .align 2
 1744              	 .global ulTCPWindowTxGet
 1745              	 .thumb
 1746              	 .thumb_func
 1748              	ulTCPWindowTxGet:
 1749              	.LFB77:
1330:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	TCPSegment_t *pxSegment;
 1750              	 .loc 1 1330 0
 1751              	 .cfi_startproc
 1752              	 
 1753              	 
 1754              	.LVL247:
 1755 0000 2DE9F041 	 push {r4,r5,r6,r7,r8,lr}
 1756              	.LCFI23:
 1757              	 .cfi_def_cfa_offset 24
 1758              	 .cfi_offset 4,-24
 1759              	 .cfi_offset 5,-20
 1760              	 .cfi_offset 6,-16
 1761              	 .cfi_offset 7,-12
 1762              	 .cfi_offset 8,-8
 1763              	 .cfi_offset 14,-4
 1764 0004 0446     	 mov r4,r0
 1765 0006 8846     	 mov r8,r1
 1766 0008 1646     	 mov r6,r2
 1767              	.LVL248:
 1768              	.LBB186:
 1769              	.LBB187:
 514:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 1770              	 .loc 1 514 0
 1771 000a 036C     	 ldr r3,[r0,#64]
 1772 000c 002B     	 cmp r3,#0
 1773 000e 00F08480 	 beq .L140
 520:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			pxSegment = ipCAST_PTR_TO_TYPE_PTR( TCPSegment_t, listGET_LIST_ITEM_OWNER( pxItem ) );
 1774              	 .loc 1 520 0
 1775 0012 C06C     	 ldr r0,[r0,#76]
 1776              	.LVL249:
 521:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1777              	 .loc 1 521 0
 1778 0014 C568     	 ldr r5,[r0,#12]
 1779              	.LVL250:
 523:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 1780              	 .loc 1 523 0
 1781 0016 FFF7FEFF 	 bl uxListRemove
 1782              	.LVL251:
 1783              	.LBE187:
 1784              	.LBE186:
1341:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1785              	 .loc 1 1341 0
 1786 001a A36A     	 ldr r3,[r4,#40]
 1787 001c E362     	 str r3,[r4,#44]
1343:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 1788              	 .loc 1 1343 0
 1789 001e 002D     	 cmp r5,#0
 1790 0020 4AD1     	 bne .L150
 1791              	.LVL252:
 1792              	.L155:
 1793              	.LBB188:
 1794              	.LBB189:
 540:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 1795              	 .loc 1 540 0
 1796 0022 A36E     	 ldr r3,[r4,#104]
 1797 0024 BBB1     	 cbz r3,.L142
 1798              	.LVL253:
 547:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 1799              	 .loc 1 547 0
 1800 0026 636F     	 ldr r3,[r4,#116]
 1801 0028 DF68     	 ldr r7,[r3,#12]
 1802              	.LVL254:
 1803              	.LBE189:
 1804              	.LBE188:
1350:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
 1805              	 .loc 1 1350 0
 1806 002a A7B1     	 cbz r7,.L142
1353:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1807              	 .loc 1 1353 0
 1808 002c 3B7D     	 ldrb r3,[r7,#20]
 1809 002e A56B     	 ldr r5,[r4,#56]
 1810 0030 9D40     	 lsls r5,r5,r3
 1811              	.LVL255:
 1812              	.LBB190:
 1813              	.LBB191:
 309:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** }
 1814              	 .loc 1 309 0
 1815 0032 FFF7FEFF 	 bl xTaskGetTickCount
 1816              	.LVL256:
 1817 0036 3B69     	 ldr r3,[r7,#16]
 1818 0038 C01A     	 subs r0,r0,r3
 1819              	.LBE191:
 1820              	.LBE190:
1355:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
 1821              	 .loc 1 1355 0
 1822 003a 8542     	 cmp r5,r0
 1823 003c 0BD2     	 bcs .L142
 1824              	.LVL257:
 1825              	.LBB192:
 1826              	.LBB193:
 514:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 1827              	 .loc 1 514 0
 1828 003e A36E     	 ldr r3,[r4,#104]
 1829 0040 23B1     	 cbz r3,.L159
 520:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			pxSegment = ipCAST_PTR_TO_TYPE_PTR( TCPSegment_t, listGET_LIST_ITEM_OWNER( pxItem ) );
 1830              	 .loc 1 520 0
 1831 0042 606F     	 ldr r0,[r4,#116]
 1832              	.LVL258:
 521:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1833              	 .loc 1 521 0
 1834 0044 C568     	 ldr r5,[r0,#12]
 1835              	.LVL259:
 523:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 1836              	 .loc 1 523 0
 1837 0046 FFF7FEFF 	 bl uxListRemove
 1838              	.LVL260:
 1839 004a 00E0     	 b .L144
 1840              	.LVL261:
 1841              	.L159:
 516:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 1842              	 .loc 1 516 0
 1843 004c 0025     	 movs r5,#0
 1844              	.LVL262:
 1845              	.L144:
 1846              	.LBE193:
 1847              	.LBE192:
1360:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1848              	 .loc 1 1360 0
 1849 004e 0023     	 movs r3,#0
 1850 0050 6B75     	 strb r3,[r5,#21]
 1851              	.LVL263:
1380:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
 1852              	 .loc 1 1380 0
 1853 0052 002D     	 cmp r5,#0
 1854 0054 30D1     	 bne .L150
 1855              	.LVL264:
 1856              	.L142:
 1857              	.LBB194:
 1858              	.LBB195:
 540:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 1859              	 .loc 1 540 0
 1860 0056 636D     	 ldr r3,[r4,#84]
 1861 0058 002B     	 cmp r3,#0
 1862 005a 5BD0     	 beq .L160
 1863              	.LVL265:
 547:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 1864              	 .loc 1 547 0
 1865 005c 236E     	 ldr r3,[r4,#96]
 1866 005e DB68     	 ldr r3,[r3,#12]
 1867              	.LVL266:
 1868              	.LBE195:
 1869              	.LBE194:
1386:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
 1870              	 .loc 1 1386 0
 1871 0060 002B     	 cmp r3,#0
 1872 0062 5DD0     	 beq .L146
1391:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
 1873              	 .loc 1 1391 0
 1874 0064 2278     	 ldrb r2,[r4]
 1875 0066 12F0020F 	 tst r2,#2
 1876 006a 03D0     	 beq .L147
1391:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
 1877              	 .loc 1 1391 0 is_stmt 0 discriminator 1
 1878 006c 9A68     	 ldr r2,[r3,#8]
 1879 006e 5B68     	 ldr r3,[r3,#4]
 1880              	.LVL267:
 1881 0070 9A42     	 cmp r2,r3
 1882 0072 55DB     	 blt .L146
 1883              	.L147:
1397:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
 1884              	 .loc 1 1397 0 is_stmt 1
 1885 0074 2046     	 mov r0,r4
 1886 0076 4146     	 mov r1,r8
 1887 0078 FFF7FEFF 	 bl prvTCPWindowTxHasSpace
 1888              	.LVL268:
 1889 007c 0028     	 cmp r0,#0
 1890 007e 4FD0     	 beq .L146
 1891              	.LVL269:
 1892              	.LBB198:
 1893              	.LBB199:
 514:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 1894              	 .loc 1 514 0
 1895 0080 636D     	 ldr r3,[r4,#84]
 1896 0082 002B     	 cmp r3,#0
 1897 0084 55D0     	 beq .L148
 520:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			pxSegment = ipCAST_PTR_TO_TYPE_PTR( TCPSegment_t, listGET_LIST_ITEM_OWNER( pxItem ) );
 1898              	 .loc 1 520 0
 1899 0086 206E     	 ldr r0,[r4,#96]
 1900              	.LVL270:
 521:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1901              	 .loc 1 521 0
 1902 0088 C568     	 ldr r5,[r0,#12]
 1903              	.LVL271:
 523:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 1904              	 .loc 1 523 0
 1905 008a FFF7FEFF 	 bl uxListRemove
 1906              	.LVL272:
 1907              	.LBE199:
 1908              	.LBE198:
1409:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					{
 1909              	 .loc 1 1409 0
 1910 008e E36F     	 ldr r3,[r4,#124]
 1911 0090 AB42     	 cmp r3,r5
 1912 0092 03D1     	 bne .L149
 1913 0094 00E0     	 b .L157
 1914              	.LVL273:
 1915              	.L161:
 1916              	.LBB201:
 1917              	.LBB200:
 516:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 1918              	 .loc 1 516 0
 1919 0096 0025     	 movs r5,#0
 1920              	.LVL274:
 1921              	.L157:
 1922              	.LBE200:
 1923              	.LBE201:
1411:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					}
 1924              	 .loc 1 1411 0
 1925 0098 0023     	 movs r3,#0
 1926 009a E367     	 str r3,[r4,#124]
 1927              	.L149:
1416:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1928              	 .loc 1 1416 0
 1929 009c AA68     	 ldr r2,[r5,#8]
 1930 009e 2B68     	 ldr r3,[r5]
 1931 00a0 1344     	 add r3,r3,r2
 1932 00a2 A362     	 str r3,[r4,#40]
 1933              	.LVL275:
1452:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			configASSERT( listLIST_ITEM_CONTAINER( &(pxSegment->xQueueItem ) ) == NULL );
 1934              	 .loc 1 1452 0
 1935 00a4 45B9     	 cbnz r5,.L150
 1936              	.LVL276:
 1937              	.L156:
 1938              	.LBB202:
 1939              	.LBB203:
 1940              	 .loc 2 197 0
 1941              	
 1942 00a6 4FF01403 	 mov r3,#20
 1943 00aa 83F31188 	 msr basepri,r3
 1944 00ae BFF36F8F 	 isb 
 1945 00b2 BFF34F8F 	 dsb 
 1946              	
 1947              	
 1948              	.LVL277:
 1949              	 .thumb
 1950              	.L151:
 1951              	.LBE203:
 1952              	.LBE202:
1452:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			configASSERT( listLIST_ITEM_CONTAINER( &(pxSegment->xQueueItem ) ) == NULL );
 1953              	 .loc 1 1452 0 discriminator 1
 1954 00b6 FEE7     	 b .L151
 1955              	.LVL278:
 1956              	.L150:
1453:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1957              	 .loc 1 1453 0
 1958 00b8 AB6A     	 ldr r3,[r5,#40]
 1959 00ba 43B1     	 cbz r3,.L152
 1960              	.LBB204:
 1961              	.LBB205:
 1962              	 .loc 2 197 0
 1963              	
 1964 00bc 4FF01403 	 mov r3,#20
 1965 00c0 83F31188 	 msr basepri,r3
 1966 00c4 BFF36F8F 	 isb 
 1967 00c8 BFF34F8F 	 dsb 
 1968              	
 1969              	
 1970              	.LVL279:
 1971              	 .thumb
 1972              	.L153:
 1973              	.LBE205:
 1974              	.LBE204:
1453:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1975              	 .loc 1 1453 0 discriminator 2
 1976 00cc FEE7     	 b .L153
 1977              	.L152:
 1978              	.LVL280:
 1979              	.LBB206:
 1980              	.LBB207:
 294:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
 1981              	 .loc 1 294 0
 1982 00ce 04F16800 	 add r0,r4,#104
 1983              	.LVL281:
 1984 00d2 05F11801 	 add r1,r5,#24
 1985              	.LVL282:
 1986 00d6 04F17002 	 add r2,r4,#112
 1987 00da FFF7FEFF 	 bl vListInsertGeneric
 1988              	.LVL283:
 1989              	.LBE207:
 1990              	.LBE206:
1460:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1991              	 .loc 1 1460 0
 1992 00de AB7D     	 ldrb r3,[r5,#22]
 1993 00e0 43F00103 	 orr r3,r3,#1
 1994 00e4 AB75     	 strb r3,[r5,#22]
1464:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 1995              	 .loc 1 1464 0
 1996 00e6 2B7D     	 ldrb r3,[r5,#20]
 1997 00e8 0133     	 adds r3,r3,#1
 1998 00ea DBB2     	 uxtb r3,r3
 1999 00ec 2B75     	 strb r3,[r5,#20]
1468:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
 2000              	 .loc 1 1468 0
 2001 00ee 042B     	 cmp r3,#4
 2002 00f0 06D1     	 bne .L154
1470:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
 2003              	 .loc 1 1470 0
 2004 00f2 B4F8BC30 	 ldrh r3,[r4,#188]
 2005 00f6 5B00     	 lsls r3,r3,#1
 2006 00f8 A268     	 ldr r2,[r4,#8]
 2007 00fa 9A42     	 cmp r2,r3
1477:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				}
 2008              	 .loc 1 1477 0
 2009 00fc 88BF     	 it hi
 2010 00fe A360     	 strhi r3,[r4,#8]
 2011              	.L154:
 2012              	.LVL284:
 2013              	.LBB208:
 2014              	.LBB209:
 302:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** }
 2015              	 .loc 1 302 0
 2016 0100 FFF7FEFF 	 bl xTaskGetTickCount
 2017              	.LVL285:
 2018 0104 2861     	 str r0,[r5,#16]
 2019              	.LBE209:
 2020              	.LBE208:
1484:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 2021              	 .loc 1 1484 0
 2022 0106 2B68     	 ldr r3,[r5]
 2023 0108 E362     	 str r3,[r4,#44]
1487:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 2024              	 .loc 1 1487 0
 2025 010a EB68     	 ldr r3,[r5,#12]
 2026 010c 3360     	 str r3,[r6]
1490:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 2027              	 .loc 1 1490 0
 2028 010e A868     	 ldr r0,[r5,#8]
 2029              	.LVL286:
 2030 0110 BDE8F081 	 pop {r4,r5,r6,r7,r8,pc}
 2031              	.LVL287:
 2032              	.L160:
 2033              	.LBB210:
 2034              	.LBB196:
 540:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 2035              	 .loc 1 540 0
 2036 0114 0020     	 movs r0,#0
 2037 0116 BDE8F081 	 pop {r4,r5,r6,r7,r8,pc}
 2038              	.LVL288:
 2039              	.L140:
 2040              	.LBE196:
 2041              	.LBE210:
1341:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 2042              	 .loc 1 1341 0
 2043 011a 836A     	 ldr r3,[r0,#40]
 2044 011c C362     	 str r3,[r0,#44]
 2045 011e 80E7     	 b .L155
 2046              	.LVL289:
 2047              	.L146:
 2048              	.LBB211:
 2049              	.LBB197:
 540:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 2050              	 .loc 1 540 0
 2051 0120 0020     	 movs r0,#0
 2052              	.LVL290:
 2053 0122 BDE8F081 	 pop {r4,r5,r6,r7,r8,pc}
 2054              	.LVL291:
 2055              	.L163:
 2056              	.LBE197:
 2057              	.LBE211:
1416:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 2058              	 .loc 1 1416 0
 2059 0126 0022     	 movs r2,#0
 2060 0128 9168     	 ldr r1,[r2,#8]
 2061 012a 1368     	 ldr r3,[r2]
 2062 012c 0B44     	 add r3,r3,r1
 2063 012e A362     	 str r3,[r4,#40]
 2064              	.LVL292:
 2065 0130 B9E7     	 b .L156
 2066              	.LVL293:
 2067              	.L148:
1409:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					{
 2068              	 .loc 1 1409 0
 2069 0132 E36F     	 ldr r3,[r4,#124]
 2070 0134 002B     	 cmp r3,#0
 2071 0136 F6D1     	 bne .L163
 2072 0138 ADE7     	 b .L161
 2073              	 .cfi_endproc
 2074              	.LFE77:
 2076 013a 00BF     	 .section .text.ulTCPWindowTxAck,"ax",%progbits
 2077              	 .align 2
 2078              	 .global ulTCPWindowTxAck
 2079              	 .thumb
 2080              	 .thumb_func
 2082              	ulTCPWindowTxAck:
 2083              	.LFB80:
1646:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #endif /* ipconfigUSE_TCP_WIN == 1 */
1647:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*-----------------------------------------------------------*/
1648:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1649:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #if( ipconfigUSE_TCP_WIN == 1 )
1650:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1651:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	static uint32_t prvTCPWindowFastRetransmit( TCPWindow_t *pxWindow, uint32_t ulFirst )
1652:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	{
1653:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	const ListItem_t * pxIterator;
1654:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	const ListItem_t * pxEnd;
1655:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	TCPSegment_t *pxSegment;
1656:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	uint32_t ulCount = 0UL;
1657:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1658:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		/* A higher Tx block has been acknowledged.  Now iterate through the
1659:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		 xWaitQueue to find a possible condition for a FAST retransmission. */
1660:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1661:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		pxEnd = listGET_END_MARKER( &( pxWindow->xWaitQueue ) );
1662:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1663:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		pxIterator  = listGET_NEXT( pxEnd );
1664:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1665:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		while( pxIterator != pxEnd )
1666:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
1667:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			/* Get the owner, which is a TCP segment. */
1668:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			pxSegment = ipCAST_PTR_TO_TYPE_PTR( TCPSegment_t, listGET_LIST_ITEM_OWNER( pxIterator ) );
1669:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1670:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			/* Hop to the next item before the current gets unlinked. */
1671:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			pxIterator  = listGET_NEXT( pxIterator );
1672:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1673:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			/* Fast retransmission:
1674:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			When 3 packets with a higher sequence number have been acknowledged
1675:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			by the peer, it is very unlikely a current packet will ever arrive.
1676:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			It will be retransmitted far before the RTO. */
1677:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			if( pxSegment->u.bits.bAcked == pdFALSE_UNSIGNED )
1678:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
1679:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				if( xSequenceLessThan( pxSegment->ulSequenceNumber, ulFirst ) != pdFALSE )
1680:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
1681:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					pxSegment->u.bits.ucDupAckCount++;
1682:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					if( pxSegment->u.bits.ucDupAckCount == DUPLICATE_ACKS_BEFORE_FAST_RETRANSMIT )
1683:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					{
1684:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						pxSegment->u.bits.ucTransmitCount = ( uint8_t ) pdFALSE;
1685:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1686:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						/* Not clearing 'ucDupAckCount' yet as more SACK's might come in
1687:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						which might lead to a second fast rexmit. */
1688:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						if( ( xTCPWindowLoggingLevel >= 0 ) && ( ipconfigTCP_MAY_LOG_PORT( pxWindow->usOurPortNumber 
1689:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						{
1690:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 							FreeRTOS_debug_printf( ( "prvTCPWindowFastRetransmit: Requeue sequence number %lu < %lu\n",
1691:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 								pxSegment->ulSequenceNumber - pxWindow->tx.ulFirstSequenceNumber,
1692:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 								ulFirst - pxWindow->tx.ulFirstSequenceNumber ) );
1693:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 							FreeRTOS_flush_logging( );
1694:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						}
1695:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1696:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						/* Remove it from xWaitQueue. */
1697:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						( void ) uxListRemove( &pxSegment->xQueueItem );
1698:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						/* Add this segment to the priority queue so it gets
1699:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						retransmitted immediately. */
1700:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						vListInsertFifo( &( pxWindow->xPriorityQueue ), &( pxSegment->xQueueItem ) );
1701:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						ulCount++;
1702:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					}
1703:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				}
1704:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			}
1705:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
1706:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1707:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		return ulCount;
1708:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
1709:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #endif /* ipconfigUSE_TCP_WIN == 1 */
1710:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*-----------------------------------------------------------*/
1711:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1712:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #if( ipconfigUSE_TCP_WIN == 1 )
1713:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1714:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	uint32_t ulTCPWindowTxAck( TCPWindow_t *pxWindow, uint32_t ulSequenceNumber )
1715:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	{
 2084              	 .loc 1 1715 0
 2085              	 .cfi_startproc
 2086              	 
 2087              	 
 2088              	.LVL294:
 2089 0000 08B5     	 push {r3,lr}
 2090              	.LCFI24:
 2091              	 .cfi_def_cfa_offset 8
 2092              	 .cfi_offset 3,-8
 2093              	 .cfi_offset 14,-4
1716:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	uint32_t ulFirstSequence, ulReturn;
1717:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1718:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		/* Receive a normal ACK. */
1719:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1720:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		ulFirstSequence = pxWindow->tx.ulCurrentSequenceNumber;
 2094              	 .loc 1 1720 0
 2095 0002 036A     	 ldr r3,[r0,#32]
 2096              	.LVL295:
 2097              	.LBB212:
 2098              	.LBB213:
 219:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 2099              	 .loc 1 219 0
 2100 0004 5A1A     	 subs r2,r3,r1
 2101              	.LBE213:
 2102              	.LBE212:
1721:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1722:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		if( xSequenceLessThanOrEqual( ulSequenceNumber, ulFirstSequence ) != pdFALSE )
 2103              	 .loc 1 1722 0
 2104 0006 002A     	 cmp r2,#0
 2105 0008 04DA     	 bge .L167
 2106 000a 0A46     	 mov r2,r1
1723:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
1724:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			ulReturn = 0UL;
1725:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
1726:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		else
1727:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
1728:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			ulReturn = prvTCPWindowTxCheckAck( pxWindow, ulFirstSequence, ulSequenceNumber );
 2107              	 .loc 1 1728 0
 2108 000c 1946     	 mov r1,r3
 2109              	.LVL296:
 2110 000e FFF7FEFF 	 bl prvTCPWindowTxCheckAck
 2111              	.LVL297:
 2112 0012 08BD     	 pop {r3,pc}
 2113              	.LVL298:
 2114              	.L167:
1724:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
 2115              	 .loc 1 1724 0
 2116 0014 0020     	 movs r0,#0
 2117              	.LVL299:
1729:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
1730:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1731:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		return ulReturn;
1732:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
 2118              	 .loc 1 1732 0
 2119 0016 08BD     	 pop {r3,pc}
 2120              	 .cfi_endproc
 2121              	.LFE80:
 2123              	 .section .text.ulTCPWindowTxSack,"ax",%progbits
 2124              	 .align 2
 2125              	 .global ulTCPWindowTxSack
 2126              	 .thumb
 2127              	 .thumb_func
 2129              	ulTCPWindowTxSack:
 2130              	.LFB81:
1733:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1734:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #endif /* ipconfigUSE_TCP_WIN == 1 */
1735:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** /*-----------------------------------------------------------*/
1736:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1737:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** #if( ipconfigUSE_TCP_WIN == 1 )
1738:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1739:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	uint32_t ulTCPWindowTxSack( TCPWindow_t *pxWindow, uint32_t ulFirst, uint32_t ulLast )
1740:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	{
 2131              	 .loc 1 1740 0
 2132              	 .cfi_startproc
 2133              	 
 2134              	 
 2135              	.LVL300:
 2136 0000 2DE9F84F 	 push {r3,r4,r5,r6,r7,r8,r9,r10,fp,lr}
 2137              	.LCFI25:
 2138              	 .cfi_def_cfa_offset 40
 2139              	 .cfi_offset 3,-40
 2140              	 .cfi_offset 4,-36
 2141              	 .cfi_offset 5,-32
 2142              	 .cfi_offset 6,-28
 2143              	 .cfi_offset 7,-24
 2144              	 .cfi_offset 8,-20
 2145              	 .cfi_offset 9,-16
 2146              	 .cfi_offset 10,-12
 2147              	 .cfi_offset 11,-8
 2148              	 .cfi_offset 14,-4
 2149 0004 0746     	 mov r7,r0
 2150 0006 0E46     	 mov r6,r1
 2151              	.LVL301:
1741:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	uint32_t ulAckCount;
1742:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	uint32_t ulCurrentSequenceNumber = pxWindow->tx.ulCurrentSequenceNumber;
1743:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1744:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		/* Receive a SACK option. */
1745:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		ulAckCount = prvTCPWindowTxCheckAck( pxWindow, ulFirst, ulLast );
 2152              	 .loc 1 1745 0
 2153 0008 FFF7FEFF 	 bl prvTCPWindowTxCheckAck
 2154              	.LVL302:
 2155 000c 8046     	 mov r8,r0
 2156              	.LVL303:
 2157              	.LBB222:
 2158              	.LBB223:
1661:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 2159              	 .loc 1 1661 0
 2160 000e 07F17005 	 add r5,r7,#112
 2161              	.LVL304:
1663:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 2162              	 .loc 1 1663 0
 2163 0012 7C6F     	 ldr r4,[r7,#116]
 2164              	.LVL305:
1665:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 2165              	 .loc 1 1665 0
 2166 0014 A542     	 cmp r5,r4
 2167 0016 22D0     	 beq .L170
1684:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 2168              	 .loc 1 1684 0
 2169 0018 4FF0000A 	 mov r10,#0
1700:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						ulCount++;
 2170              	 .loc 1 1700 0
 2171 001c 07F14009 	 add r9,r7,#64
 2172              	.LBB224:
 2173              	.LBB225:
 294:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
 2174              	 .loc 1 294 0
 2175 0020 4837     	 adds r7,r7,#72
 2176              	.LVL306:
 2177              	.L173:
 2178              	.LBE225:
 2179              	.LBE224:
1668:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 2180              	 .loc 1 1668 0
 2181 0022 E168     	 ldr r1,[r4,#12]
 2182              	.LVL307:
1671:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 2183              	 .loc 1 1671 0
 2184 0024 6468     	 ldr r4,[r4,#4]
 2185              	.LVL308:
1677:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			{
 2186              	 .loc 1 1677 0
 2187 0026 8B7D     	 ldrb r3,[r1,#22]
 2188 0028 13F0020F 	 tst r3,#2
 2189 002c 15D1     	 bne .L171
 2190              	.LVL309:
 2191 002e 0B68     	 ldr r3,[r1]
 2192 0030 DB43     	 mvns r3,r3
1679:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				{
 2193              	 .loc 1 1679 0
 2194 0032 F342     	 cmn r3,r6
 2195 0034 11D4     	 bmi .L171
1681:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					if( pxSegment->u.bits.ucDupAckCount == DUPLICATE_ACKS_BEFORE_FAST_RETRANSMIT )
 2196              	 .loc 1 1681 0
 2197 0036 4B7D     	 ldrb r3,[r1,#21]
 2198 0038 0133     	 adds r3,r3,#1
 2199 003a DBB2     	 uxtb r3,r3
 2200 003c 4B75     	 strb r3,[r1,#21]
1682:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 					{
 2201              	 .loc 1 1682 0
 2202 003e 032B     	 cmp r3,#3
 2203 0040 0BD1     	 bne .L171
1684:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
 2204              	 .loc 1 1684 0
 2205 0042 81F814A0 	 strb r10,[r1,#20]
1697:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 						/* Add this segment to the priority queue so it gets
 2206              	 .loc 1 1697 0
 2207 0046 01F1180B 	 add fp,r1,#24
 2208 004a 5846     	 mov r0,fp
 2209 004c FFF7FEFF 	 bl uxListRemove
 2210              	.LVL310:
 2211              	.LBB227:
 2212              	.LBB226:
 294:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
 2213              	 .loc 1 294 0
 2214 0050 4846     	 mov r0,r9
 2215 0052 5946     	 mov r1,fp
 2216 0054 3A46     	 mov r2,r7
 2217 0056 FFF7FEFF 	 bl vListInsertGeneric
 2218              	.LVL311:
 2219              	.L171:
 2220              	.LBE226:
 2221              	.LBE227:
1665:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
 2222              	 .loc 1 1665 0
 2223 005a A542     	 cmp r5,r4
 2224 005c E1D1     	 bne .L173
 2225              	.LVL312:
 2226              	.L170:
 2227              	.LBE223:
 2228              	.LBE222:
1746:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		( void ) prvTCPWindowFastRetransmit( pxWindow, ulFirst );
1747:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1748:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		if( ( xTCPWindowLoggingLevel >= 1 ) && ( xSequenceGreaterThan( ulFirst, ulCurrentSequenceNumber )
1749:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		{
1750:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			FreeRTOS_debug_printf( ( "ulTCPWindowTxSack[%u,%u]: from %lu to %lu (ack = %lu)\n",
1751:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				pxWindow->usPeerPortNumber,
1752:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				pxWindow->usOurPortNumber,
1753:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				ulFirst - pxWindow->tx.ulFirstSequenceNumber,
1754:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				ulLast - pxWindow->tx.ulFirstSequenceNumber,
1755:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 				pxWindow->tx.ulCurrentSequenceNumber - pxWindow->tx.ulFirstSequenceNumber ) );
1756:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 			FreeRTOS_flush_logging( );
1757:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		}
1758:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 
1759:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 		return ulAckCount;
1760:../FreeRTOS-Plus-TCP/FreeRTOS_TCP_WIN.c **** 	}
 2229              	 .loc 1 1760 0
 2230 005e 4046     	 mov r0,r8
 2231 0060 BDE8F88F 	 pop {r3,r4,r5,r6,r7,r8,r9,r10,fp,pc}
 2232              	 .cfi_endproc
 2233              	.LFE81:
 2235              	 .global xTCPWindowLoggingLevel
 2236              	 .section .bss.xTCPSegments,"aw",%nobits
 2237              	 .align 2
 2238              	 .set .LANCHOR1,.+0
 2241              	xTCPSegments:
 2242 0000 00000000 	 .space 4
 2243              	 .section .bss.xSegmentList,"aw",%nobits
 2244              	 .align 2
 2245              	 .set .LANCHOR0,.+0
 2248              	xSegmentList:
 2249 0000 00000000 	 .space 20
 2249      00000000 
 2249      00000000 
 2249      00000000 
 2249      00000000 
 2250              	 .section .bss.xTCPWindowLoggingLevel,"aw",%nobits
 2251              	 .align 2
 2254              	xTCPWindowLoggingLevel:
 2255 0000 00000000 	 .space 4
 2256              	 .text
 2257              	.Letext0:
 2258              	 .file 4 "e:\\embedded\\dave_4-4-2_64bit_2018-02-23\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 2259              	 .file 5 "e:\\embedded\\dave_4-4-2_64bit_2018-02-23\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 2260              	 .file 6 "e:\\embedded\\dave_4-4-2_64bit_2018-02-23\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\lib\\gcc\\arm-none-eabi\\4.9.3\\include\\stddef.h"
 2261              	 .file 7 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/include/list.h"
 2262              	 .file 8 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS-Plus-TCP/include/FreeRTOS_TCP_WIN.h"
 2263              	 .file 9 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/include/portable.h"
 2264              	 .file 10 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/include/task.h"
DEFINED SYMBOLS
                            *ABS*:00000000 FreeRTOS_TCP_WIN.c
    {standard input}:19     .text.vListInsertGeneric:00000000 $t
    {standard input}:23     .text.vListInsertGeneric:00000000 vListInsertGeneric
    {standard input}:53     .text.xTCPWindowRxFind:00000000 $t
    {standard input}:57     .text.xTCPWindowRxFind:00000000 xTCPWindowRxFind
    {standard input}:122    .text.prvTCPWindowTxHasSpace:00000000 $t
    {standard input}:126    .text.prvTCPWindowTxHasSpace:00000000 prvTCPWindowTxHasSpace
    {standard input}:233    .text.vTCPWindowFree:00000000 $t
    {standard input}:237    .text.vTCPWindowFree:00000000 vTCPWindowFree
    {standard input}:289    .text.vTCPWindowFree:00000034 $d
    {standard input}:296    .text.xTCPWindowNew:00000000 $t
    {standard input}:300    .text.xTCPWindowNew:00000000 xTCPWindowNew
    {standard input}:448    .text.xTCPWindowNew:00000094 $d
    {standard input}:453    .text.prvTCPWindowTxCheckAck:00000000 $t
    {standard input}:457    .text.prvTCPWindowTxCheckAck:00000000 prvTCPWindowTxCheckAck
    {standard input}:677    .text.xTCPWindowRxEmpty:00000000 $t
    {standard input}:682    .text.xTCPWindowRxEmpty:00000000 xTCPWindowRxEmpty
    {standard input}:718    .text.vTCPWindowDestroy:00000000 $t
    {standard input}:723    .text.vTCPWindowDestroy:00000000 vTCPWindowDestroy
    {standard input}:795    .text.vTCPWindowInit:00000000 $t
    {standard input}:800    .text.vTCPWindowInit:00000000 vTCPWindowInit
    {standard input}:874    .text.vTCPWindowCreate:00000000 $t
    {standard input}:879    .text.vTCPWindowCreate:00000000 vTCPWindowCreate
    {standard input}:1003   .text.vTCPWindowCreate:00000094 $d
    {standard input}:1009   .text.vTCPSegmentCleanup:00000000 $t
    {standard input}:1014   .text.vTCPSegmentCleanup:00000000 vTCPSegmentCleanup
    {standard input}:1041   .text.vTCPSegmentCleanup:00000014 $d
    {standard input}:1046   .text.lTCPWindowRxCheck:00000000 $t
    {standard input}:1051   .text.lTCPWindowRxCheck:00000000 lTCPWindowRxCheck
    {standard input}:1343   .text.lTCPWindowRxCheck:0000015c $d
    {standard input}:1348   .text.lTCPWindowTxAdd:00000000 $t
    {standard input}:1353   .text.lTCPWindowTxAdd:00000000 lTCPWindowTxAdd
    {standard input}:1565   .text.xTCPWindowTxDone:00000000 $t
    {standard input}:1570   .text.xTCPWindowTxDone:00000000 xTCPWindowTxDone
    {standard input}:1589   .text.xTCPWindowTxHasData:00000000 $t
    {standard input}:1594   .text.xTCPWindowTxHasData:00000000 xTCPWindowTxHasData
    {standard input}:1743   .text.ulTCPWindowTxGet:00000000 $t
    {standard input}:1748   .text.ulTCPWindowTxGet:00000000 ulTCPWindowTxGet
    {standard input}:2077   .text.ulTCPWindowTxAck:00000000 $t
    {standard input}:2082   .text.ulTCPWindowTxAck:00000000 ulTCPWindowTxAck
    {standard input}:2124   .text.ulTCPWindowTxSack:00000000 $t
    {standard input}:2129   .text.ulTCPWindowTxSack:00000000 ulTCPWindowTxSack
    {standard input}:2254   .bss.xTCPWindowLoggingLevel:00000000 xTCPWindowLoggingLevel
    {standard input}:2237   .bss.xTCPSegments:00000000 $d
    {standard input}:2241   .bss.xTCPSegments:00000000 xTCPSegments
    {standard input}:2244   .bss.xSegmentList:00000000 $d
    {standard input}:2248   .bss.xSegmentList:00000000 xSegmentList
    {standard input}:2251   .bss.xTCPWindowLoggingLevel:00000000 $d
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.0.3466fc6a3db32493c997d085de4c7a28
                           .group:00000000 wm4.features.h.22.bee0aee4a3878f51861c775df98fa3ea
                           .group:00000000 wm4._default_types.h.15.933e8edd27a65e0b69af4a865eb623d2
                           .group:00000000 wm4._intsup.h.10.ca9f32a61b410c270a48d1161ca2c217
                           .group:00000000 wm4.stdint.h.22.f4a337c398d8b6d821a97202448bc0d0
                           .group:00000000 wm4.stddef.h.39.c744ceb84abf2f8351653f0e2622da1c
                           .group:00000000 wm4.FreeRTOSConfig.h.30.aa43eb1cb33228d5c7e359a94d48589b
                           .group:00000000 wm4.projdefs.h.28.d6a7c9061b707820f2fcf4c2ff5d9f24
                           .group:00000000 wm4.portmacro.h.30.2ddc2eaf2e032c76c597fb78c4365041
                           .group:00000000 wm4.portable.h.63.e9cc508c3850f44ce542149380c67812
                           .group:00000000 wm4.mpu_wrappers.h.28.163fb40577cf8d1578015ea3f2ff4cdb
                           .group:00000000 wm4.FreeRTOS.h.67.9945f39eea4ddeb224c0782392206292
                           .group:00000000 wm4.list.h.57.02ec67e07eacffe5ca7cfb7326896236
                           .group:00000000 wm4.task.h.47.2d3fe49a094b8ec1e3e6aac441e8db21
                           .group:00000000 wm4.FreeRTOSIPConfig.h.37.3f9c1db988571ff1f3dec4c7e54978d6
                           .group:00000000 wm4.FreeRTOS_errno_TCP.h.27.708877b341d0e6bcb4ba112b2ad8082a
                           .group:00000000 wm4.FreeRTOSIPConfigDefaults.h.41.f972b11d9b1eba5383080cfaef1fd740
                           .group:00000000 wm4.IPTraceMacroDefaults.h.31.69642530b5a79c93e762c9b09ac0d1d5
                           .group:00000000 wm4.FreeRTOS_IP.h.27.bae156c5eba2da2689f75aad27aa76da
                           .group:00000000 wm4.FreeRTOS_IP.h.179.e5077063e624bc5d3f02542470d6ea94
                           .group:00000000 wm4.newlib.h.8.fe7d912fc917043c98742c35eddd8cff
                           .group:00000000 wm4.config.h.216.aad1ef7bee4fb69981cb38ce62f84d9c
                           .group:00000000 wm4._ansi.h.23.9f8fcfa20193763fcf364fb91705c94b
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4._types.h.54.d3d34a3b7f3cc230cd159baf022b4b08
                           .group:00000000 wm4.stddef.h.158.61317cdbfb4026324507d123a50b0fd6
                           .group:00000000 wm4.reent.h.17.8bd9e4098e0428508c282cad794fae43
                           .group:00000000 wm4.cdefs.h.47.4002528de975c0fcce6c551c15d87b8c
                           .group:00000000 wm4.string.h.15.dab3980bf35408a4c507182805e2de3a
                           .group:00000000 wm4.stddef.h.158.a7efb00f6cbc6f43213b50e183c9830c
                           .group:00000000 wm4.timers.h.55.5dc360ab39e4b575b2753deeda01a480
                           .group:00000000 wm4.FreeRTOS_Sockets.h.58.61d472da32c0e0f5bc49c368f15d0ac5
                           .group:00000000 wm4.FreeRTOS_TCP_WIN.h.32.f3cfab69924f28284deb16cc1a30fb93
                           .group:00000000 wm4.queue.h.29.00d24a7c91ec95dd2ba2931e7e83fbc4
                           .group:00000000 wm4.semphr.h.38.96f44691bfa19eb833944d3a35b81e54
                           .group:00000000 wm4.FreeRTOS_IP_Private.h.52.551f932b14473cea139893dda31b3fa0
                           .group:00000000 wm4.FreeRTOS_IP_Private.h.328.b5788f8d626a4cf16b8282f9399f3f55

UNDEFINED SYMBOLS
uxListRemove
xTaskGetTickCount
vListInitialise
pvPortMalloc
memset
vPortFree
