
Ethernet_CAN_XMC4500.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000ab38  08000000  0c000000  00008000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000010  0800ab38  0c00ab38  00012b38  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .rodata       000002d8  0800ab48  0c00ab48  00012b48  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 Stack         00000800  20000000  20000000  00018000  2**0
                  ALLOC
  4 Communication_Buffers 000030a0  30000000  30000000  00018000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          0000cd64  20000800  20000800  00018000  2**2
                  ALLOC
  6 .data         0000029c  2000d570  0c00ae20  00015570  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  7 .debug_aranges 000017e0  00000000  00000000  0001b0a0  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   0003986a  00000000  00000000  0001c880  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00008ac3  00000000  00000000  000560ea  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   00018a75  00000000  00000000  0005ebad  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  0000448c  00000000  00000000  00077624  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    0009276c  00000000  00000000  0007bab0  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    0001cb6f  00000000  00000000  0010e21c  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00001fa0  00000000  00000000  0012ad90  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .build_attributes 00000a4a  00000000  00000000  0012cd30  2**0
                  CONTENTS, READONLY
 16 .debug_macro  000208cc  00000000  00000000  0012d77a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000000 <__Xmc4500_interrupt_vector_cortex_m>:
 8000000:	00 08 00 20 01 02 00 08 cf 03 00 08 db 03 00 08     ... ............
 8000010:	e7 03 00 08 f3 03 00 08 ff 03 00 08 00 00 00 00     ................
	...
 800002c:	0b 04 00 08 17 04 00 08 00 00 00 00 23 04 00 08     ............#...
 800003c:	2f 04 00 08 3b 04 00 08 47 04 00 08 53 04 00 08     /...;...G...S...
 800004c:	5f 04 00 08 6b 04 00 08 77 04 00 08 81 04 00 08     _...k...w.......
 800005c:	8b 04 00 08 95 04 00 08 00 00 00 00 00 00 00 00     ................
 800006c:	00 00 00 00 9f 04 00 08 00 00 00 00 a9 04 00 08     ................
 800007c:	b3 04 00 08 bd 04 00 08 c7 04 00 08 d1 04 00 08     ................
 800008c:	db 04 00 08 e5 04 00 08 ef 04 00 08 f9 04 00 08     ................
 800009c:	03 05 00 08 0d 05 00 08 17 05 00 08 21 05 00 08     ............!...
 80000ac:	2b 05 00 08 35 05 00 08 3f 05 00 08 49 05 00 08     +...5...?...I...
 80000bc:	53 05 00 08 5d 05 00 08 67 05 00 08 71 05 00 08     S...]...g...q...
 80000cc:	7b 05 00 08 85 05 00 08 8f 05 00 08 99 05 00 08     {...............
 80000dc:	a3 05 00 08 ad 05 00 08 b7 05 00 08 c1 05 00 08     ................
 80000ec:	cb 05 00 08 d5 05 00 08 df 05 00 08 e9 05 00 08     ................
 80000fc:	f3 05 00 08 fd 05 00 08 07 06 00 08 11 06 00 08     ................
 800010c:	1b 06 00 08 25 06 00 08 2f 06 00 08 39 06 00 08     ....%.../...9...
 800011c:	43 06 00 08 4d 06 00 08 57 06 00 08 61 06 00 08     C...M...W...a...
 800012c:	6b 06 00 08 75 06 00 08 7f 06 00 08 89 06 00 08     k...u...........
 800013c:	93 06 00 08 9d 06 00 08 a7 06 00 08 b1 06 00 08     ................
 800014c:	bb 06 00 08 c5 06 00 08 cf 06 00 08 d9 06 00 08     ................
 800015c:	e3 06 00 08 00 00 00 00 00 00 00 00 00 00 00 00     ................
 800016c:	00 00 00 00 ed 06 00 08 f7 06 00 08 01 07 00 08     ................
 800017c:	0b 07 00 08 15 07 00 08 1f 07 00 08 29 07 00 08     ............)...
 800018c:	33 07 00 08 3d 07 00 08 47 07 00 08 51 07 00 08     3...=...G...Q...
 800019c:	5b 07 00 08 65 07 00 08 6f 07 00 08 79 07 00 08     [...e...o...y...
 80001ac:	83 07 00 08 8d 07 00 08 97 07 00 08 a1 07 00 08     ................
 80001bc:	ab 07 00 08 b5 07 00 08 bf 07 00 08 c9 07 00 08     ................
 80001cc:	d3 07 00 08 dd 07 00 08 e7 07 00 08 f1 07 00 08     ................
 80001dc:	00 00 00 00 fb 07 00 08 05 08 00 08 0f 08 00 08     ................
 80001ec:	19 08 00 08 23 08 00 08 00 00 00 00 2d 08 00 08     ....#.......-...
 80001fc:	00 00 00 00                                         ....

08000200 <__Xmc4500_reset_cortex_m>:
__Xmc4500_reset_cortex_m:
    .fnstart

    /* C routines are likely to be called. Setup the stack now */
    /* This is already setup by BootROM,hence this step is optional */
    LDR SP,=__Xmc4500_stack
 8000200:	f8df d00c 	ldr.w	sp, [pc, #12]	; 8000210 <__Xmc4500_reset_cortex_m+0x10>

    /* Clock tree, External memory setup etc may be done here */
    LDR     R0, =SystemInit
 8000204:	4803      	ldr	r0, [pc, #12]	; (8000214 <__Xmc4500_reset_cortex_m+0x14>)
    BLX     R0
 8000206:	4780      	blx	r0

/*
   SystemInit_DAVE4() is provided by DAVE3 code generation engine. It is
   weakly defined here though for a potential override.
*/
    LDR     R0, =SystemInit_DAVE4
 8000208:	4803      	ldr	r0, [pc, #12]	; (8000218 <__Xmc4500_reset_cortex_m+0x18>)
    BLX     R0
 800020a:	4780      	blx	r0

    B       __Xmc4500_Program_Loader
 800020c:	f000 b806 	b.w	800021c <__Xmc4500_Program_Loader>
__Xmc4500_reset_cortex_m:
    .fnstart

    /* C routines are likely to be called. Setup the stack now */
    /* This is already setup by BootROM,hence this step is optional */
    LDR SP,=__Xmc4500_stack
 8000210:	20000800 	.word	0x20000800

    /* Clock tree, External memory setup etc may be done here */
    LDR     R0, =SystemInit
 8000214:	08000a71 	.word	0x08000a71

/*
   SystemInit_DAVE4() is provided by DAVE3 code generation engine. It is
   weakly defined here though for a potential override.
*/
    LDR     R0, =SystemInit_DAVE4
 8000218:	080002f1 	.word	0x080002f1

0800021c <__Xmc4500_Program_Loader>:
   .fnstart
   /* Memories are accessible now*/

   /* DATA COPY */
   /* R0 = Start address, R1 = Destination address, R2 = Size */
   LDR R0, =eROData
 800021c:	4825      	ldr	r0, [pc, #148]	; (80002b4 <SKIPCLEAR+0x24>)
   LDR R1, =__Xmc4500_sData
 800021e:	4926      	ldr	r1, [pc, #152]	; (80002b8 <SKIPCLEAR+0x28>)
   LDR R2, =__Xmc4500_Data_Size
 8000220:	4a26      	ldr	r2, [pc, #152]	; (80002bc <SKIPCLEAR+0x2c>)

   /* Is there anything to be copied? */
   CMP R2,#0
 8000222:	2a00      	cmp	r2, #0
   BEQ RAMCODE_COPY
 8000224:	d00e      	beq.n	8000244 <RAMCODE_COPY>

   /* For bytecount less than 4, at least 1 word must be copied */
   CMP R2,#4
 8000226:	2a04      	cmp	r2, #4
   BCS STARTCOPY
 8000228:	d201      	bcs.n	800022e <STARTCOPY>

   /* Byte count < 4 ; so bump it up */
   MOV R2,#4
 800022a:	f04f 0204 	mov.w	r2, #4

0800022e <STARTCOPY>:
STARTCOPY:
   /*
      R2 contains byte count. Change it to word count. It is ensured in the
      linker script that the length is always word aligned.
   */
   LSR R2,R2,#2 /* Divide by 4 to obtain word count */
 800022e:	ea4f 0292 	mov.w	r2, r2, lsr #2

08000232 <COPYLOOP>:

   /* The proverbial loop from the schooldays */
COPYLOOP:
   LDR R3,[R0]
 8000232:	6803      	ldr	r3, [r0, #0]
   STR R3,[R1]
 8000234:	600b      	str	r3, [r1, #0]
   SUBS R2,#1
 8000236:	3a01      	subs	r2, #1
   BEQ RAMCODE_COPY
 8000238:	d004      	beq.n	8000244 <RAMCODE_COPY>
   ADD R0,#4
 800023a:	f100 0004 	add.w	r0, r0, #4
   ADD R1,#4
 800023e:	f101 0104 	add.w	r1, r1, #4
   B COPYLOOP
 8000242:	e7f6      	b.n	8000232 <COPYLOOP>

08000244 <RAMCODE_COPY>:

/* TODO: Check authenticity by Static Code Analyzer for Code Placements */
RAMCODE_COPY:
   /* RAM CODE COPY */
   /* R0 = Start address, R1 = Destination address, R2 = Size */
   LDR R0, =__Xmc4500_Ram_Code_Load
 8000244:	481e      	ldr	r0, [pc, #120]	; (80002c0 <SKIPCLEAR+0x30>)
   LDR R1, =__Xmc4500_sRamCode
 8000246:	491f      	ldr	r1, [pc, #124]	; (80002c4 <SKIPCLEAR+0x34>)
   LDR R2, =__Xmc4500_Ram_Code_Size
 8000248:	4a1f      	ldr	r2, [pc, #124]	; (80002c8 <SKIPCLEAR+0x38>)

   /* Is there anything to be copied? */
   CMP R2,#0
 800024a:	2a00      	cmp	r2, #0
   BEQ SKIPCOPY
 800024c:	d00e      	beq.n	800026c <SKIPCOPY>

   /* For bytecount less than 4, at least 1 word must be copied */
   CMP R2,#4
 800024e:	2a04      	cmp	r2, #4
   BCS RAMCODE_STARTCOPY
 8000250:	d201      	bcs.n	8000256 <RAMCODE_STARTCOPY>

   /* Byte count < 4 ; so bump it up */
   MOV R2,#4
 8000252:	f04f 0204 	mov.w	r2, #4

08000256 <RAMCODE_STARTCOPY>:
RAMCODE_STARTCOPY:
   /*
      R2 contains byte count. Change it to word count. It is ensured in the
      linker script that the length is always word aligned.
   */
   LSR R2,R2,#2 /* Divide by 4 to obtain word count */
 8000256:	ea4f 0292 	mov.w	r2, r2, lsr #2

0800025a <RAMCODE_COPYLOOP>:

   /* The proverbial loop from the schooldays */
RAMCODE_COPYLOOP:
   LDR R3,[R0]
 800025a:	6803      	ldr	r3, [r0, #0]
   STR R3,[R1]
 800025c:	600b      	str	r3, [r1, #0]
   SUBS R2,#1
 800025e:	3a01      	subs	r2, #1
   BEQ SKIPCOPY
 8000260:	d004      	beq.n	800026c <SKIPCOPY>
   ADD R0,#4
 8000262:	f100 0004 	add.w	r0, r0, #4
   ADD R1,#4
 8000266:	f101 0104 	add.w	r1, r1, #4
   B RAMCODE_COPYLOOP
 800026a:	e7f6      	b.n	800025a <RAMCODE_COPYLOOP>

0800026c <SKIPCOPY>:


SKIPCOPY:
   /* BSS CLEAR */
   LDR R0, =__Xmc4500_sBSS     /* Start of BSS */
 800026c:	4817      	ldr	r0, [pc, #92]	; (80002cc <SKIPCLEAR+0x3c>)
   LDR R1, =__Xmc4500_BSS_Size /* BSS size in bytes */
 800026e:	4918      	ldr	r1, [pc, #96]	; (80002d0 <SKIPCLEAR+0x40>)

   /* Find out if there are items assigned to BSS */
   CMP R1,#0
 8000270:	2900      	cmp	r1, #0
   BEQ SKIPCLEAR
 8000272:	d00d      	beq.n	8000290 <SKIPCLEAR>

   /* At least 1 word must be copied */
   CMP R1,#4
 8000274:	2904      	cmp	r1, #4
   BCS STARTCLEAR
 8000276:	d201      	bcs.n	800027c <STARTCLEAR>

   /* Byte count < 4 ; so bump it up to a word*/
   MOV R1,#4
 8000278:	f04f 0104 	mov.w	r1, #4

0800027c <STARTCLEAR>:

STARTCLEAR:
   LSR R1,R1,#2            /* BSS size in words */
 800027c:	ea4f 0191 	mov.w	r1, r1, lsr #2

   MOV R2,#0
 8000280:	f04f 0200 	mov.w	r2, #0

08000284 <CLEARLOOP>:
CLEARLOOP:
   STR R2,[R0]
 8000284:	6002      	str	r2, [r0, #0]
   SUBS R1,#1
 8000286:	3901      	subs	r1, #1
   BEQ SKIPCLEAR
 8000288:	d002      	beq.n	8000290 <SKIPCLEAR>
   ADD R0,#4
 800028a:	f100 0004 	add.w	r0, r0, #4
   B CLEARLOOP
 800028e:	e7f9      	b.n	8000284 <CLEARLOOP>

08000290 <SKIPCLEAR>:

SKIPCLEAR:
   /* Remap vector table */
   /* This is already setup by BootROM,hence this step is optional */
   LDR R0, =__Xmc4500_interrupt_vector_cortex_m
 8000290:	4810      	ldr	r0, [pc, #64]	; (80002d4 <SKIPCLEAR+0x44>)
   LDR R1, =SCB_VTOR
 8000292:	4911      	ldr	r1, [pc, #68]	; (80002d8 <SKIPCLEAR+0x48>)
   STR R0,[R1]
 8000294:	6008      	str	r0, [r1, #0]

   /* Update System Clock */
   LDR R0,=SystemCoreClockUpdate
 8000296:	4811      	ldr	r0, [pc, #68]	; (80002dc <SKIPCLEAR+0x4c>)
   BLX R0
 8000298:	4780      	blx	r0

   /* C++ : Call global constructors */
   #ifndef __SKIP_LIBC_INIT_ARRAY
   LDR R0,=__libc_init_array
 800029a:	4811      	ldr	r0, [pc, #68]	; (80002e0 <SKIPCLEAR+0x50>)
   BLX R0
 800029c:	4780      	blx	r0
   #endif   /* __SKIP_LIBC_INIT_ARRAY */

   /* Reset stack pointer before zipping off to user application, Optional */
   LDR SP,=__Xmc4500_stack
 800029e:	f8df d044 	ldr.w	sp, [pc, #68]	; 80002e4 <SKIPCLEAR+0x54>
   MOV R0,#0
 80002a2:	f04f 0000 	mov.w	r0, #0
   MOV R1,#0
 80002a6:	f04f 0100 	mov.w	r1, #0
   /* Call user defined initialization functions */
   LDR R0,=init_user_before_main
 80002aa:	480f      	ldr	r0, [pc, #60]	; (80002e8 <SKIPCLEAR+0x58>)
   BLX R0
 80002ac:	4780      	blx	r0
   /* Start off to main entry */
   LDR PC, =main
 80002ae:	f8df f03c 	ldr.w	pc, [pc, #60]	; 80002ec <SKIPCLEAR+0x5c>
 80002b2:	0000      	.short	0x0000
   .fnstart
   /* Memories are accessible now*/

   /* DATA COPY */
   /* R0 = Start address, R1 = Destination address, R2 = Size */
   LDR R0, =eROData
 80002b4:	0c00ae20 	.word	0x0c00ae20
   LDR R1, =__Xmc4500_sData
 80002b8:	2000d570 	.word	0x2000d570
   LDR R2, =__Xmc4500_Data_Size
 80002bc:	0000029c 	.word	0x0000029c

/* TODO: Check authenticity by Static Code Analyzer for Code Placements */
RAMCODE_COPY:
   /* RAM CODE COPY */
   /* R0 = Start address, R1 = Destination address, R2 = Size */
   LDR R0, =__Xmc4500_Ram_Code_Load
 80002c0:	0c00b0bc 	.word	0x0c00b0bc
   LDR R1, =__Xmc4500_sRamCode
 80002c4:	2000d80c 	.word	0x2000d80c
   LDR R2, =__Xmc4500_Ram_Code_Size
 80002c8:	00000000 	.word	0x00000000
   B RAMCODE_COPYLOOP


SKIPCOPY:
   /* BSS CLEAR */
   LDR R0, =__Xmc4500_sBSS     /* Start of BSS */
 80002cc:	20000800 	.word	0x20000800
   LDR R1, =__Xmc4500_BSS_Size /* BSS size in bytes */
 80002d0:	0000cd64 	.word	0x0000cd64
   B CLEARLOOP

SKIPCLEAR:
   /* Remap vector table */
   /* This is already setup by BootROM,hence this step is optional */
   LDR R0, =__Xmc4500_interrupt_vector_cortex_m
 80002d4:	08000000 	.word	0x08000000
   LDR R1, =SCB_VTOR
 80002d8:	e000ed08 	.word	0xe000ed08
   STR R0,[R1]

   /* Update System Clock */
   LDR R0,=SystemCoreClockUpdate
 80002dc:	080009f5 	.word	0x080009f5
   BLX R0

   /* C++ : Call global constructors */
   #ifndef __SKIP_LIBC_INIT_ARRAY
   LDR R0,=__libc_init_array
 80002e0:	08000381 	.word	0x08000381
   BLX R0
   #endif   /* __SKIP_LIBC_INIT_ARRAY */

   /* Reset stack pointer before zipping off to user application, Optional */
   LDR SP,=__Xmc4500_stack
 80002e4:	20000800 	.word	0x20000800
   MOV R0,#0
   MOV R1,#0
   /* Call user defined initialization functions */
   LDR R0,=init_user_before_main
 80002e8:	0800aa09 	.word	0x0800aa09
   BLX R0
   /* Start off to main entry */
   LDR PC, =main
 80002ec:	0800a96d 	.word	0x0800a96d

080002f0 <SystemInit_DAVE4>:
*/
     .section ".XmcStartup"
     .weak SystemInit_DAVE4
     .type SystemInit_DAVE4, %function
SystemInit_DAVE4:
     NOP
 80002f0:	bf00      	nop
     BX LR
 80002f2:	4770      	bx	lr

080002f4 <init_system_before_main>:
 * <i>Imp Note:</i>
 *
 */
void init_system_before_main( void );
void init_system_before_main( void )
{
 80002f4:	b508      	push	{r3, lr}
	/* Get Boot mode of device */
	gBootMode = XMC_SCU_GetBootMode();
 80002f6:	f000 fe11 	bl	8000f1c <XMC_SCU_GetBootMode>
 80002fa:	4b1d      	ldr	r3, [pc, #116]	; (8000370 <init_system_before_main+0x7c>)
 80002fc:	6018      	str	r0, [r3, #0]
	/* Check specific mdoe */
	switch( gBootMode )
 80002fe:	681b      	ldr	r3, [r3, #0]
 * \par<b>Related APIs:</b><BR>
 * XMC_SCU_RESET_ClearDeviceResetReason() \n\n\n
 */
__STATIC_INLINE uint32_t XMC_SCU_RESET_GetDeviceResetReason(void)
{
  return ((SCU_RESET->RSTSTAT) & SCU_RESET_RSTSTAT_RSTSTAT_Msk);
 8000300:	4b1c      	ldr	r3, [pc, #112]	; (8000374 <init_system_before_main+0x80>)
 8000302:	681b      	ldr	r3, [r3, #0]
 8000304:	b2db      	uxtb	r3, r3
		case XMC_SCU_BOOTMODE_FABM:
		break;
	}

	/* Get the Reason for Reset */
	gResetReason = XMC_SCU_RESET_GetDeviceResetReason();
 8000306:	4a1c      	ldr	r2, [pc, #112]	; (8000378 <init_system_before_main+0x84>)
 8000308:	6013      	str	r3, [r2, #0]
	/* Check specific reason */
	switch( gResetReason )
 800030a:	6813      	ldr	r3, [r2, #0]
 800030c:	2b08      	cmp	r3, #8
 800030e:	d017      	beq.n	8000340 <init_system_before_main+0x4c>
 8000310:	d804      	bhi.n	800031c <init_system_before_main+0x28>
 8000312:	2b02      	cmp	r3, #2
 8000314:	d00c      	beq.n	8000330 <init_system_before_main+0x3c>
 8000316:	2b04      	cmp	r3, #4
 8000318:	d00e      	beq.n	8000338 <init_system_before_main+0x44>
 800031a:	e005      	b.n	8000328 <init_system_before_main+0x34>
 800031c:	2b20      	cmp	r3, #32
 800031e:	d017      	beq.n	8000350 <init_system_before_main+0x5c>
 8000320:	2b80      	cmp	r3, #128	; 0x80
 8000322:	d019      	beq.n	8000358 <init_system_before_main+0x64>
 8000324:	2b10      	cmp	r3, #16
 8000326:	d00f      	beq.n	8000348 <init_system_before_main+0x54>
 * XMC_SCU_RESET_GetDeviceResetReason() \n\n\n
 */
__STATIC_INLINE void XMC_SCU_RESET_ClearDeviceResetReason(void)
{
  /* Clear RSTSTAT.RSTSTAT bitfield */
  SCU_RESET->RSTCLR = (uint32_t)SCU_RESET_RSTCLR_RSCLR_Msk;
 8000328:	2201      	movs	r2, #1
 800032a:	4b12      	ldr	r3, [pc, #72]	; (8000374 <init_system_before_main+0x80>)
 800032c:	609a      	str	r2, [r3, #8]
 800032e:	e016      	b.n	800035e <init_system_before_main+0x6a>
 8000330:	2201      	movs	r2, #1
 8000332:	4b10      	ldr	r3, [pc, #64]	; (8000374 <init_system_before_main+0x80>)
 8000334:	609a      	str	r2, [r3, #8]
 8000336:	e012      	b.n	800035e <init_system_before_main+0x6a>
 8000338:	2201      	movs	r2, #1
 800033a:	4b0e      	ldr	r3, [pc, #56]	; (8000374 <init_system_before_main+0x80>)
 800033c:	609a      	str	r2, [r3, #8]
 800033e:	e00e      	b.n	800035e <init_system_before_main+0x6a>
 8000340:	2201      	movs	r2, #1
 8000342:	4b0c      	ldr	r3, [pc, #48]	; (8000374 <init_system_before_main+0x80>)
 8000344:	609a      	str	r2, [r3, #8]
 8000346:	e00a      	b.n	800035e <init_system_before_main+0x6a>
 8000348:	2201      	movs	r2, #1
 800034a:	4b0a      	ldr	r3, [pc, #40]	; (8000374 <init_system_before_main+0x80>)
 800034c:	609a      	str	r2, [r3, #8]
 800034e:	e006      	b.n	800035e <init_system_before_main+0x6a>
 8000350:	2201      	movs	r2, #1
 8000352:	4b08      	ldr	r3, [pc, #32]	; (8000374 <init_system_before_main+0x80>)
 8000354:	609a      	str	r2, [r3, #8]
 8000356:	e002      	b.n	800035e <init_system_before_main+0x6a>
 8000358:	2201      	movs	r2, #1
 800035a:	4b06      	ldr	r3, [pc, #24]	; (8000374 <init_system_before_main+0x80>)
 800035c:	609a      	str	r2, [r3, #8]
 * XMC_SCU_CLOCK_Init() \n\n\n
 *
 */
__STATIC_INLINE void XMC_SCU_CLOCK_SetSleepConfig(int32_t config)
{
  SCU_CLK->SLEEPCR = config;
 800035e:	4b07      	ldr	r3, [pc, #28]	; (800037c <init_system_before_main+0x88>)
 8000360:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
 8000364:	631a      	str	r2, [r3, #48]	; 0x30
 * XMC_SCU_CLOCK_Init() \n\n\n
 *
 */
__STATIC_INLINE void XMC_SCU_CLOCK_SetDeepSleepConfig(int32_t config)
{
  SCU_CLK->DSLEEPCR = config;
 8000366:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800036a:	635a      	str	r2, [r3, #52]	; 0x34
 800036c:	bd08      	pop	{r3, pc}
 800036e:	bf00      	nop
 8000370:	2000d430 	.word	0x2000d430
 8000374:	50004400 	.word	0x50004400
 8000378:	2000d42c 	.word	0x2000d42c
 800037c:	50004600 	.word	0x50004600

08000380 <__libc_init_array>:
// Iterate over all the preinit/init routines (mainly static constructors).
void __libc_init_array( void );
inline void
__attribute__((always_inline))
__libc_init_array (void)
{
 8000380:	b570      	push	{r4, r5, r6, lr}
  int count;
  int i;

  count = __preinit_array_end - __preinit_array_start;
 8000382:	4e0e      	ldr	r6, [pc, #56]	; (80003bc <__libc_init_array+0x3c>)
 8000384:	4b0e      	ldr	r3, [pc, #56]	; (80003c0 <__libc_init_array+0x40>)
 8000386:	1b9e      	subs	r6, r3, r6
 8000388:	10b6      	asrs	r6, r6, #2
  for (i = 0; i < count; i++)
 800038a:	2e00      	cmp	r6, #0
 800038c:	dd07      	ble.n	800039e <__libc_init_array+0x1e>
 800038e:	4d0b      	ldr	r5, [pc, #44]	; (80003bc <__libc_init_array+0x3c>)
 8000390:	2400      	movs	r4, #0
    __preinit_array_start[i] ();
 8000392:	f855 3b04 	ldr.w	r3, [r5], #4
 8000396:	4798      	blx	r3
{
  int count;
  int i;

  count = __preinit_array_end - __preinit_array_start;
  for (i = 0; i < count; i++)
 8000398:	3401      	adds	r4, #1
 800039a:	42b4      	cmp	r4, r6
 800039c:	d1f9      	bne.n	8000392 <__libc_init_array+0x12>
  /* If you need to run the code in the .init section, please use
   * the startup files, since this requires the code in crti.o and crtn.o
   * to add the function prologue/epilogue.
   * _init(); // DO NOT ENABE THIS!
   */
  count = __init_array_end - __init_array_start;
 800039e:	4e09      	ldr	r6, [pc, #36]	; (80003c4 <__libc_init_array+0x44>)
 80003a0:	4b09      	ldr	r3, [pc, #36]	; (80003c8 <__libc_init_array+0x48>)
 80003a2:	1b9e      	subs	r6, r3, r6
 80003a4:	10b6      	asrs	r6, r6, #2
  for (i = 0; i < count; i++)
 80003a6:	2e00      	cmp	r6, #0
 80003a8:	dd07      	ble.n	80003ba <__libc_init_array+0x3a>
 80003aa:	4d06      	ldr	r5, [pc, #24]	; (80003c4 <__libc_init_array+0x44>)
 80003ac:	2400      	movs	r4, #0
    __init_array_start[i] ();
 80003ae:	f855 3b04 	ldr.w	r3, [r5], #4
 80003b2:	4798      	blx	r3
   * the startup files, since this requires the code in crti.o and crtn.o
   * to add the function prologue/epilogue.
   * _init(); // DO NOT ENABE THIS!
   */
  count = __init_array_end - __init_array_start;
  for (i = 0; i < count; i++)
 80003b4:	3401      	adds	r4, #1
 80003b6:	42b4      	cmp	r4, r6
 80003b8:	d1f9      	bne.n	80003ae <__libc_init_array+0x2e>
 80003ba:	bd70      	pop	{r4, r5, r6, pc}
 80003bc:	0800ab38 	.word	0x0800ab38
 80003c0:	0800ab38 	.word	0x0800ab38
 80003c4:	0800ab38 	.word	0x0800ab38
 80003c8:	0800ab38 	.word	0x0800ab38
/* Default exception Handlers - Users may override this default functionality by
   defining handlers of the same name in their C code */
    .thumb
    .text

     Insert_ExceptionHandler NMI_Handler
 80003cc:	e7fe      	b.n	80003cc <__libc_init_array+0x4c>

080003ce <NMI_Handler_Veneer>:
 80003ce:	f8df 046c 	ldr.w	r0, [pc, #1132]	; 800083c <AllowPLLInitByStartup+0x8>
 80003d2:	b500      	push	{lr}
 80003d4:	4780      	blx	r0
 80003d6:	bd00      	pop	{pc}
/* ======================================================================== */
     Insert_ExceptionHandler HardFault_Handler
 80003d8:	e7fe      	b.n	80003d8 <NMI_Handler_Veneer+0xa>

080003da <HardFault_Handler_Veneer>:
 80003da:	f8df 0464 	ldr.w	r0, [pc, #1124]	; 8000840 <AllowPLLInitByStartup+0xc>
 80003de:	b500      	push	{lr}
 80003e0:	4780      	blx	r0
 80003e2:	bd00      	pop	{pc}
/* ======================================================================== */
     Insert_ExceptionHandler MemManage_Handler
 80003e4:	e7fe      	b.n	80003e4 <HardFault_Handler_Veneer+0xa>

080003e6 <MemManage_Handler_Veneer>:
 80003e6:	f8df 045c 	ldr.w	r0, [pc, #1116]	; 8000844 <AllowPLLInitByStartup+0x10>
 80003ea:	b500      	push	{lr}
 80003ec:	4780      	blx	r0
 80003ee:	bd00      	pop	{pc}
/* ======================================================================== */
     Insert_ExceptionHandler BusFault_Handler
 80003f0:	e7fe      	b.n	80003f0 <MemManage_Handler_Veneer+0xa>

080003f2 <BusFault_Handler_Veneer>:
 80003f2:	f8df 0454 	ldr.w	r0, [pc, #1108]	; 8000848 <AllowPLLInitByStartup+0x14>
 80003f6:	b500      	push	{lr}
 80003f8:	4780      	blx	r0
 80003fa:	bd00      	pop	{pc}
/* ======================================================================== */
     Insert_ExceptionHandler UsageFault_Handler
 80003fc:	e7fe      	b.n	80003fc <BusFault_Handler_Veneer+0xa>

080003fe <UsageFault_Handler_Veneer>:
 80003fe:	f8df 044c 	ldr.w	r0, [pc, #1100]	; 800084c <AllowPLLInitByStartup+0x18>
 8000402:	b500      	push	{lr}
 8000404:	4780      	blx	r0
 8000406:	bd00      	pop	{pc}
/* ======================================================================== */
     Insert_ExceptionHandler SVC_Handler
 8000408:	e7fe      	b.n	8000408 <UsageFault_Handler_Veneer+0xa>

0800040a <SVC_Handler_Veneer>:
 800040a:	f8df 0444 	ldr.w	r0, [pc, #1092]	; 8000850 <AllowPLLInitByStartup+0x1c>
 800040e:	b500      	push	{lr}
 8000410:	4780      	blx	r0
 8000412:	bd00      	pop	{pc}

08000414 <DebugMon_Handler>:
/* ======================================================================== */
     Insert_ExceptionHandler DebugMon_Handler
 8000414:	e7fe      	b.n	8000414 <DebugMon_Handler>

08000416 <DebugMon_Handler_Veneer>:
 8000416:	f8df 043c 	ldr.w	r0, [pc, #1084]	; 8000854 <AllowPLLInitByStartup+0x20>
 800041a:	b500      	push	{lr}
 800041c:	4780      	blx	r0
 800041e:	bd00      	pop	{pc}
/* ======================================================================== */
     Insert_ExceptionHandler PendSV_Handler
 8000420:	e7fe      	b.n	8000420 <DebugMon_Handler_Veneer+0xa>

08000422 <PendSV_Handler_Veneer>:
 8000422:	f8df 0434 	ldr.w	r0, [pc, #1076]	; 8000858 <AllowPLLInitByStartup+0x24>
 8000426:	b500      	push	{lr}
 8000428:	4780      	blx	r0
 800042a:	bd00      	pop	{pc}
/* ======================================================================== */
     Insert_ExceptionHandler SysTick_Handler
 800042c:	e7fe      	b.n	800042c <PendSV_Handler_Veneer+0xa>

0800042e <SysTick_Handler_Veneer>:
 800042e:	f8df 042c 	ldr.w	r0, [pc, #1068]	; 800085c <AllowPLLInitByStartup+0x28>
 8000432:	b500      	push	{lr}
 8000434:	4780      	blx	r0
 8000436:	bd00      	pop	{pc}
/* ============= END OF EXCEPTION HANDLER DEFINITION ======================== */

/* ============= START OF INTERRUPT HANDLER DEFINITION ====================== */

/* IRQ Handlers */
     Insert_ExceptionHandler SCU_0_IRQHandler
 8000438:	e7fe      	b.n	8000438 <SysTick_Handler_Veneer+0xa>

0800043a <SCU_0_IRQHandler_Veneer>:
 800043a:	f8df 0424 	ldr.w	r0, [pc, #1060]	; 8000860 <AllowPLLInitByStartup+0x2c>
 800043e:	b500      	push	{lr}
 8000440:	4780      	blx	r0
 8000442:	bd00      	pop	{pc}

08000444 <ERU0_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler ERU0_0_IRQHandler
 8000444:	e7fe      	b.n	8000444 <ERU0_0_IRQHandler>

08000446 <ERU0_0_IRQHandler_Veneer>:
 8000446:	f8df 041c 	ldr.w	r0, [pc, #1052]	; 8000864 <AllowPLLInitByStartup+0x30>
 800044a:	b500      	push	{lr}
 800044c:	4780      	blx	r0
 800044e:	bd00      	pop	{pc}

08000450 <ERU0_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler ERU0_1_IRQHandler
 8000450:	e7fe      	b.n	8000450 <ERU0_1_IRQHandler>

08000452 <ERU0_1_IRQHandler_Veneer>:
 8000452:	f8df 0414 	ldr.w	r0, [pc, #1044]	; 8000868 <AllowPLLInitByStartup+0x34>
 8000456:	b500      	push	{lr}
 8000458:	4780      	blx	r0
 800045a:	bd00      	pop	{pc}

0800045c <ERU0_2_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler ERU0_2_IRQHandler
 800045c:	e7fe      	b.n	800045c <ERU0_2_IRQHandler>

0800045e <ERU0_2_IRQHandler_Veneer>:
 800045e:	f8df 040c 	ldr.w	r0, [pc, #1036]	; 800086c <AllowPLLInitByStartup+0x38>
 8000462:	b500      	push	{lr}
 8000464:	4780      	blx	r0
 8000466:	bd00      	pop	{pc}

08000468 <ERU0_3_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler ERU0_3_IRQHandler
 8000468:	e7fe      	b.n	8000468 <ERU0_3_IRQHandler>

0800046a <ERU0_3_IRQHandler_Veneer>:
 800046a:	f8df 0404 	ldr.w	r0, [pc, #1028]	; 8000870 <AllowPLLInitByStartup+0x3c>
 800046e:	b500      	push	{lr}
 8000470:	4780      	blx	r0
 8000472:	bd00      	pop	{pc}

08000474 <ERU1_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler ERU1_0_IRQHandler
 8000474:	e7fe      	b.n	8000474 <ERU1_0_IRQHandler>

08000476 <ERU1_0_IRQHandler_Veneer>:
 8000476:	48ff      	ldr	r0, [pc, #1020]	; (8000874 <AllowPLLInitByStartup+0x40>)
 8000478:	b500      	push	{lr}
 800047a:	4780      	blx	r0
 800047c:	bd00      	pop	{pc}

0800047e <ERU1_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler ERU1_1_IRQHandler
 800047e:	e7fe      	b.n	800047e <ERU1_1_IRQHandler>

08000480 <ERU1_1_IRQHandler_Veneer>:
 8000480:	48fd      	ldr	r0, [pc, #1012]	; (8000878 <AllowPLLInitByStartup+0x44>)
 8000482:	b500      	push	{lr}
 8000484:	4780      	blx	r0
 8000486:	bd00      	pop	{pc}

08000488 <ERU1_2_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler ERU1_2_IRQHandler
 8000488:	e7fe      	b.n	8000488 <ERU1_2_IRQHandler>

0800048a <ERU1_2_IRQHandler_Veneer>:
 800048a:	48fc      	ldr	r0, [pc, #1008]	; (800087c <AllowPLLInitByStartup+0x48>)
 800048c:	b500      	push	{lr}
 800048e:	4780      	blx	r0
 8000490:	bd00      	pop	{pc}

08000492 <ERU1_3_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler ERU1_3_IRQHandler
 8000492:	e7fe      	b.n	8000492 <ERU1_3_IRQHandler>

08000494 <ERU1_3_IRQHandler_Veneer>:
 8000494:	48fa      	ldr	r0, [pc, #1000]	; (8000880 <AllowPLLInitByStartup+0x4c>)
 8000496:	b500      	push	{lr}
 8000498:	4780      	blx	r0
 800049a:	bd00      	pop	{pc}

0800049c <PMU0_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler PMU0_0_IRQHandler
 800049c:	e7fe      	b.n	800049c <PMU0_0_IRQHandler>

0800049e <PMU0_0_IRQHandler_Veneer>:
 800049e:	48f9      	ldr	r0, [pc, #996]	; (8000884 <AllowPLLInitByStartup+0x50>)
 80004a0:	b500      	push	{lr}
 80004a2:	4780      	blx	r0
 80004a4:	bd00      	pop	{pc}

080004a6 <VADC0_C0_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_C0_0_IRQHandler
 80004a6:	e7fe      	b.n	80004a6 <VADC0_C0_0_IRQHandler>

080004a8 <VADC0_C0_0_IRQHandler_Veneer>:
 80004a8:	48f7      	ldr	r0, [pc, #988]	; (8000888 <AllowPLLInitByStartup+0x54>)
 80004aa:	b500      	push	{lr}
 80004ac:	4780      	blx	r0
 80004ae:	bd00      	pop	{pc}

080004b0 <VADC0_C0_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_C0_1_IRQHandler
 80004b0:	e7fe      	b.n	80004b0 <VADC0_C0_1_IRQHandler>

080004b2 <VADC0_C0_1_IRQHandler_Veneer>:
 80004b2:	48f6      	ldr	r0, [pc, #984]	; (800088c <AllowPLLInitByStartup+0x58>)
 80004b4:	b500      	push	{lr}
 80004b6:	4780      	blx	r0
 80004b8:	bd00      	pop	{pc}

080004ba <VADC0_C0_2_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_C0_2_IRQHandler
 80004ba:	e7fe      	b.n	80004ba <VADC0_C0_2_IRQHandler>

080004bc <VADC0_C0_2_IRQHandler_Veneer>:
 80004bc:	48f4      	ldr	r0, [pc, #976]	; (8000890 <AllowPLLInitByStartup+0x5c>)
 80004be:	b500      	push	{lr}
 80004c0:	4780      	blx	r0
 80004c2:	bd00      	pop	{pc}

080004c4 <VADC0_C0_3_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_C0_3_IRQHandler
 80004c4:	e7fe      	b.n	80004c4 <VADC0_C0_3_IRQHandler>

080004c6 <VADC0_C0_3_IRQHandler_Veneer>:
 80004c6:	48f3      	ldr	r0, [pc, #972]	; (8000894 <AllowPLLInitByStartup+0x60>)
 80004c8:	b500      	push	{lr}
 80004ca:	4780      	blx	r0
 80004cc:	bd00      	pop	{pc}

080004ce <VADC0_G0_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G0_0_IRQHandler
 80004ce:	e7fe      	b.n	80004ce <VADC0_G0_0_IRQHandler>

080004d0 <VADC0_G0_0_IRQHandler_Veneer>:
 80004d0:	48f1      	ldr	r0, [pc, #964]	; (8000898 <AllowPLLInitByStartup+0x64>)
 80004d2:	b500      	push	{lr}
 80004d4:	4780      	blx	r0
 80004d6:	bd00      	pop	{pc}

080004d8 <VADC0_G0_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G0_1_IRQHandler
 80004d8:	e7fe      	b.n	80004d8 <VADC0_G0_1_IRQHandler>

080004da <VADC0_G0_1_IRQHandler_Veneer>:
 80004da:	48f0      	ldr	r0, [pc, #960]	; (800089c <AllowPLLInitByStartup+0x68>)
 80004dc:	b500      	push	{lr}
 80004de:	4780      	blx	r0
 80004e0:	bd00      	pop	{pc}

080004e2 <VADC0_G0_2_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G0_2_IRQHandler
 80004e2:	e7fe      	b.n	80004e2 <VADC0_G0_2_IRQHandler>

080004e4 <VADC0_G0_2_IRQHandler_Veneer>:
 80004e4:	48ee      	ldr	r0, [pc, #952]	; (80008a0 <AllowPLLInitByStartup+0x6c>)
 80004e6:	b500      	push	{lr}
 80004e8:	4780      	blx	r0
 80004ea:	bd00      	pop	{pc}

080004ec <VADC0_G0_3_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G0_3_IRQHandler
 80004ec:	e7fe      	b.n	80004ec <VADC0_G0_3_IRQHandler>

080004ee <VADC0_G0_3_IRQHandler_Veneer>:
 80004ee:	48ed      	ldr	r0, [pc, #948]	; (80008a4 <AllowPLLInitByStartup+0x70>)
 80004f0:	b500      	push	{lr}
 80004f2:	4780      	blx	r0
 80004f4:	bd00      	pop	{pc}

080004f6 <VADC0_G1_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G1_0_IRQHandler
 80004f6:	e7fe      	b.n	80004f6 <VADC0_G1_0_IRQHandler>

080004f8 <VADC0_G1_0_IRQHandler_Veneer>:
 80004f8:	48eb      	ldr	r0, [pc, #940]	; (80008a8 <AllowPLLInitByStartup+0x74>)
 80004fa:	b500      	push	{lr}
 80004fc:	4780      	blx	r0
 80004fe:	bd00      	pop	{pc}

08000500 <VADC0_G1_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G1_1_IRQHandler
 8000500:	e7fe      	b.n	8000500 <VADC0_G1_1_IRQHandler>

08000502 <VADC0_G1_1_IRQHandler_Veneer>:
 8000502:	48ea      	ldr	r0, [pc, #936]	; (80008ac <AllowPLLInitByStartup+0x78>)
 8000504:	b500      	push	{lr}
 8000506:	4780      	blx	r0
 8000508:	bd00      	pop	{pc}

0800050a <VADC0_G1_2_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G1_2_IRQHandler
 800050a:	e7fe      	b.n	800050a <VADC0_G1_2_IRQHandler>

0800050c <VADC0_G1_2_IRQHandler_Veneer>:
 800050c:	48e8      	ldr	r0, [pc, #928]	; (80008b0 <AllowPLLInitByStartup+0x7c>)
 800050e:	b500      	push	{lr}
 8000510:	4780      	blx	r0
 8000512:	bd00      	pop	{pc}

08000514 <VADC0_G1_3_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G1_3_IRQHandler
 8000514:	e7fe      	b.n	8000514 <VADC0_G1_3_IRQHandler>

08000516 <VADC0_G1_3_IRQHandler_Veneer>:
 8000516:	48e7      	ldr	r0, [pc, #924]	; (80008b4 <AllowPLLInitByStartup+0x80>)
 8000518:	b500      	push	{lr}
 800051a:	4780      	blx	r0
 800051c:	bd00      	pop	{pc}

0800051e <VADC0_G2_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G2_0_IRQHandler
 800051e:	e7fe      	b.n	800051e <VADC0_G2_0_IRQHandler>

08000520 <VADC0_G2_0_IRQHandler_Veneer>:
 8000520:	48e5      	ldr	r0, [pc, #916]	; (80008b8 <AllowPLLInitByStartup+0x84>)
 8000522:	b500      	push	{lr}
 8000524:	4780      	blx	r0
 8000526:	bd00      	pop	{pc}

08000528 <VADC0_G2_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G2_1_IRQHandler
 8000528:	e7fe      	b.n	8000528 <VADC0_G2_1_IRQHandler>

0800052a <VADC0_G2_1_IRQHandler_Veneer>:
 800052a:	48e4      	ldr	r0, [pc, #912]	; (80008bc <AllowPLLInitByStartup+0x88>)
 800052c:	b500      	push	{lr}
 800052e:	4780      	blx	r0
 8000530:	bd00      	pop	{pc}

08000532 <VADC0_G2_2_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G2_2_IRQHandler
 8000532:	e7fe      	b.n	8000532 <VADC0_G2_2_IRQHandler>

08000534 <VADC0_G2_2_IRQHandler_Veneer>:
 8000534:	48e2      	ldr	r0, [pc, #904]	; (80008c0 <AllowPLLInitByStartup+0x8c>)
 8000536:	b500      	push	{lr}
 8000538:	4780      	blx	r0
 800053a:	bd00      	pop	{pc}

0800053c <VADC0_G2_3_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G2_3_IRQHandler
 800053c:	e7fe      	b.n	800053c <VADC0_G2_3_IRQHandler>

0800053e <VADC0_G2_3_IRQHandler_Veneer>:
 800053e:	48e1      	ldr	r0, [pc, #900]	; (80008c4 <AllowPLLInitByStartup+0x90>)
 8000540:	b500      	push	{lr}
 8000542:	4780      	blx	r0
 8000544:	bd00      	pop	{pc}

08000546 <VADC0_G3_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G3_0_IRQHandler
 8000546:	e7fe      	b.n	8000546 <VADC0_G3_0_IRQHandler>

08000548 <VADC0_G3_0_IRQHandler_Veneer>:
 8000548:	48df      	ldr	r0, [pc, #892]	; (80008c8 <AllowPLLInitByStartup+0x94>)
 800054a:	b500      	push	{lr}
 800054c:	4780      	blx	r0
 800054e:	bd00      	pop	{pc}

08000550 <VADC0_G3_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G3_1_IRQHandler
 8000550:	e7fe      	b.n	8000550 <VADC0_G3_1_IRQHandler>

08000552 <VADC0_G3_1_IRQHandler_Veneer>:
 8000552:	48de      	ldr	r0, [pc, #888]	; (80008cc <AllowPLLInitByStartup+0x98>)
 8000554:	b500      	push	{lr}
 8000556:	4780      	blx	r0
 8000558:	bd00      	pop	{pc}

0800055a <VADC0_G3_2_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G3_2_IRQHandler
 800055a:	e7fe      	b.n	800055a <VADC0_G3_2_IRQHandler>

0800055c <VADC0_G3_2_IRQHandler_Veneer>:
 800055c:	48dc      	ldr	r0, [pc, #880]	; (80008d0 <AllowPLLInitByStartup+0x9c>)
 800055e:	b500      	push	{lr}
 8000560:	4780      	blx	r0
 8000562:	bd00      	pop	{pc}

08000564 <VADC0_G3_3_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G3_3_IRQHandler
 8000564:	e7fe      	b.n	8000564 <VADC0_G3_3_IRQHandler>

08000566 <VADC0_G3_3_IRQHandler_Veneer>:
 8000566:	48db      	ldr	r0, [pc, #876]	; (80008d4 <AllowPLLInitByStartup+0xa0>)
 8000568:	b500      	push	{lr}
 800056a:	4780      	blx	r0
 800056c:	bd00      	pop	{pc}

0800056e <DSD0_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler DSD0_0_IRQHandler
 800056e:	e7fe      	b.n	800056e <DSD0_0_IRQHandler>

08000570 <DSD0_0_IRQHandler_Veneer>:
 8000570:	48d9      	ldr	r0, [pc, #868]	; (80008d8 <AllowPLLInitByStartup+0xa4>)
 8000572:	b500      	push	{lr}
 8000574:	4780      	blx	r0
 8000576:	bd00      	pop	{pc}

08000578 <DSD0_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler DSD0_1_IRQHandler
 8000578:	e7fe      	b.n	8000578 <DSD0_1_IRQHandler>

0800057a <DSD0_1_IRQHandler_Veneer>:
 800057a:	48d8      	ldr	r0, [pc, #864]	; (80008dc <AllowPLLInitByStartup+0xa8>)
 800057c:	b500      	push	{lr}
 800057e:	4780      	blx	r0
 8000580:	bd00      	pop	{pc}

08000582 <DSD0_2_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler DSD0_2_IRQHandler
 8000582:	e7fe      	b.n	8000582 <DSD0_2_IRQHandler>

08000584 <DSD0_2_IRQHandler_Veneer>:
 8000584:	48d6      	ldr	r0, [pc, #856]	; (80008e0 <AllowPLLInitByStartup+0xac>)
 8000586:	b500      	push	{lr}
 8000588:	4780      	blx	r0
 800058a:	bd00      	pop	{pc}

0800058c <DSD0_3_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler DSD0_3_IRQHandler
 800058c:	e7fe      	b.n	800058c <DSD0_3_IRQHandler>

0800058e <DSD0_3_IRQHandler_Veneer>:
 800058e:	48d5      	ldr	r0, [pc, #852]	; (80008e4 <AllowPLLInitByStartup+0xb0>)
 8000590:	b500      	push	{lr}
 8000592:	4780      	blx	r0
 8000594:	bd00      	pop	{pc}

08000596 <DSD0_4_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler DSD0_4_IRQHandler
 8000596:	e7fe      	b.n	8000596 <DSD0_4_IRQHandler>

08000598 <DSD0_4_IRQHandler_Veneer>:
 8000598:	48d3      	ldr	r0, [pc, #844]	; (80008e8 <AllowPLLInitByStartup+0xb4>)
 800059a:	b500      	push	{lr}
 800059c:	4780      	blx	r0
 800059e:	bd00      	pop	{pc}

080005a0 <DSD0_5_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler DSD0_5_IRQHandler
 80005a0:	e7fe      	b.n	80005a0 <DSD0_5_IRQHandler>

080005a2 <DSD0_5_IRQHandler_Veneer>:
 80005a2:	48d2      	ldr	r0, [pc, #840]	; (80008ec <AllowPLLInitByStartup+0xb8>)
 80005a4:	b500      	push	{lr}
 80005a6:	4780      	blx	r0
 80005a8:	bd00      	pop	{pc}

080005aa <DSD0_6_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler DSD0_6_IRQHandler
 80005aa:	e7fe      	b.n	80005aa <DSD0_6_IRQHandler>

080005ac <DSD0_6_IRQHandler_Veneer>:
 80005ac:	48d0      	ldr	r0, [pc, #832]	; (80008f0 <AllowPLLInitByStartup+0xbc>)
 80005ae:	b500      	push	{lr}
 80005b0:	4780      	blx	r0
 80005b2:	bd00      	pop	{pc}

080005b4 <DSD0_7_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler DSD0_7_IRQHandler
 80005b4:	e7fe      	b.n	80005b4 <DSD0_7_IRQHandler>

080005b6 <DSD0_7_IRQHandler_Veneer>:
 80005b6:	48cf      	ldr	r0, [pc, #828]	; (80008f4 <AllowPLLInitByStartup+0xc0>)
 80005b8:	b500      	push	{lr}
 80005ba:	4780      	blx	r0
 80005bc:	bd00      	pop	{pc}

080005be <DAC0_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler DAC0_0_IRQHandler
 80005be:	e7fe      	b.n	80005be <DAC0_0_IRQHandler>

080005c0 <DAC0_0_IRQHandler_Veneer>:
 80005c0:	48cd      	ldr	r0, [pc, #820]	; (80008f8 <AllowPLLInitByStartup+0xc4>)
 80005c2:	b500      	push	{lr}
 80005c4:	4780      	blx	r0
 80005c6:	bd00      	pop	{pc}

080005c8 <DAC0_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler DAC0_1_IRQHandler
 80005c8:	e7fe      	b.n	80005c8 <DAC0_1_IRQHandler>

080005ca <DAC0_1_IRQHandler_Veneer>:
 80005ca:	48cc      	ldr	r0, [pc, #816]	; (80008fc <AllowPLLInitByStartup+0xc8>)
 80005cc:	b500      	push	{lr}
 80005ce:	4780      	blx	r0
 80005d0:	bd00      	pop	{pc}

080005d2 <CCU40_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU40_0_IRQHandler
 80005d2:	e7fe      	b.n	80005d2 <CCU40_0_IRQHandler>

080005d4 <CCU40_0_IRQHandler_Veneer>:
 80005d4:	48ca      	ldr	r0, [pc, #808]	; (8000900 <AllowPLLInitByStartup+0xcc>)
 80005d6:	b500      	push	{lr}
 80005d8:	4780      	blx	r0
 80005da:	bd00      	pop	{pc}

080005dc <CCU40_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU40_1_IRQHandler
 80005dc:	e7fe      	b.n	80005dc <CCU40_1_IRQHandler>

080005de <CCU40_1_IRQHandler_Veneer>:
 80005de:	48c9      	ldr	r0, [pc, #804]	; (8000904 <AllowPLLInitByStartup+0xd0>)
 80005e0:	b500      	push	{lr}
 80005e2:	4780      	blx	r0
 80005e4:	bd00      	pop	{pc}

080005e6 <CCU40_2_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU40_2_IRQHandler
 80005e6:	e7fe      	b.n	80005e6 <CCU40_2_IRQHandler>

080005e8 <CCU40_2_IRQHandler_Veneer>:
 80005e8:	48c7      	ldr	r0, [pc, #796]	; (8000908 <AllowPLLInitByStartup+0xd4>)
 80005ea:	b500      	push	{lr}
 80005ec:	4780      	blx	r0
 80005ee:	bd00      	pop	{pc}

080005f0 <CCU40_3_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU40_3_IRQHandler
 80005f0:	e7fe      	b.n	80005f0 <CCU40_3_IRQHandler>

080005f2 <CCU40_3_IRQHandler_Veneer>:
 80005f2:	48c6      	ldr	r0, [pc, #792]	; (800090c <AllowPLLInitByStartup+0xd8>)
 80005f4:	b500      	push	{lr}
 80005f6:	4780      	blx	r0
 80005f8:	bd00      	pop	{pc}

080005fa <CCU41_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU41_0_IRQHandler
 80005fa:	e7fe      	b.n	80005fa <CCU41_0_IRQHandler>

080005fc <CCU41_0_IRQHandler_Veneer>:
 80005fc:	48c4      	ldr	r0, [pc, #784]	; (8000910 <AllowPLLInitByStartup+0xdc>)
 80005fe:	b500      	push	{lr}
 8000600:	4780      	blx	r0
 8000602:	bd00      	pop	{pc}

08000604 <CCU41_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU41_1_IRQHandler
 8000604:	e7fe      	b.n	8000604 <CCU41_1_IRQHandler>

08000606 <CCU41_1_IRQHandler_Veneer>:
 8000606:	48c3      	ldr	r0, [pc, #780]	; (8000914 <AllowPLLInitByStartup+0xe0>)
 8000608:	b500      	push	{lr}
 800060a:	4780      	blx	r0
 800060c:	bd00      	pop	{pc}

0800060e <CCU41_2_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU41_2_IRQHandler
 800060e:	e7fe      	b.n	800060e <CCU41_2_IRQHandler>

08000610 <CCU41_2_IRQHandler_Veneer>:
 8000610:	48c1      	ldr	r0, [pc, #772]	; (8000918 <AllowPLLInitByStartup+0xe4>)
 8000612:	b500      	push	{lr}
 8000614:	4780      	blx	r0
 8000616:	bd00      	pop	{pc}

08000618 <CCU41_3_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU41_3_IRQHandler
 8000618:	e7fe      	b.n	8000618 <CCU41_3_IRQHandler>

0800061a <CCU41_3_IRQHandler_Veneer>:
 800061a:	48c0      	ldr	r0, [pc, #768]	; (800091c <AllowPLLInitByStartup+0xe8>)
 800061c:	b500      	push	{lr}
 800061e:	4780      	blx	r0
 8000620:	bd00      	pop	{pc}

08000622 <CCU42_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU42_0_IRQHandler
 8000622:	e7fe      	b.n	8000622 <CCU42_0_IRQHandler>

08000624 <CCU42_0_IRQHandler_Veneer>:
 8000624:	48be      	ldr	r0, [pc, #760]	; (8000920 <AllowPLLInitByStartup+0xec>)
 8000626:	b500      	push	{lr}
 8000628:	4780      	blx	r0
 800062a:	bd00      	pop	{pc}

0800062c <CCU42_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU42_1_IRQHandler
 800062c:	e7fe      	b.n	800062c <CCU42_1_IRQHandler>

0800062e <CCU42_1_IRQHandler_Veneer>:
 800062e:	48bd      	ldr	r0, [pc, #756]	; (8000924 <AllowPLLInitByStartup+0xf0>)
 8000630:	b500      	push	{lr}
 8000632:	4780      	blx	r0
 8000634:	bd00      	pop	{pc}

08000636 <CCU42_2_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU42_2_IRQHandler
 8000636:	e7fe      	b.n	8000636 <CCU42_2_IRQHandler>

08000638 <CCU42_2_IRQHandler_Veneer>:
 8000638:	48bb      	ldr	r0, [pc, #748]	; (8000928 <AllowPLLInitByStartup+0xf4>)
 800063a:	b500      	push	{lr}
 800063c:	4780      	blx	r0
 800063e:	bd00      	pop	{pc}

08000640 <CCU42_3_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU42_3_IRQHandler
 8000640:	e7fe      	b.n	8000640 <CCU42_3_IRQHandler>

08000642 <CCU42_3_IRQHandler_Veneer>:
 8000642:	48ba      	ldr	r0, [pc, #744]	; (800092c <AllowPLLInitByStartup+0xf8>)
 8000644:	b500      	push	{lr}
 8000646:	4780      	blx	r0
 8000648:	bd00      	pop	{pc}

0800064a <CCU43_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU43_0_IRQHandler
 800064a:	e7fe      	b.n	800064a <CCU43_0_IRQHandler>

0800064c <CCU43_0_IRQHandler_Veneer>:
 800064c:	48b8      	ldr	r0, [pc, #736]	; (8000930 <AllowPLLInitByStartup+0xfc>)
 800064e:	b500      	push	{lr}
 8000650:	4780      	blx	r0
 8000652:	bd00      	pop	{pc}

08000654 <CCU43_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU43_1_IRQHandler
 8000654:	e7fe      	b.n	8000654 <CCU43_1_IRQHandler>

08000656 <CCU43_1_IRQHandler_Veneer>:
 8000656:	48b7      	ldr	r0, [pc, #732]	; (8000934 <AllowPLLInitByStartup+0x100>)
 8000658:	b500      	push	{lr}
 800065a:	4780      	blx	r0
 800065c:	bd00      	pop	{pc}

0800065e <CCU43_2_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU43_2_IRQHandler
 800065e:	e7fe      	b.n	800065e <CCU43_2_IRQHandler>

08000660 <CCU43_2_IRQHandler_Veneer>:
 8000660:	48b5      	ldr	r0, [pc, #724]	; (8000938 <AllowPLLInitByStartup+0x104>)
 8000662:	b500      	push	{lr}
 8000664:	4780      	blx	r0
 8000666:	bd00      	pop	{pc}

08000668 <CCU43_3_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU43_3_IRQHandler
 8000668:	e7fe      	b.n	8000668 <CCU43_3_IRQHandler>

0800066a <CCU43_3_IRQHandler_Veneer>:
 800066a:	48b4      	ldr	r0, [pc, #720]	; (800093c <AllowPLLInitByStartup+0x108>)
 800066c:	b500      	push	{lr}
 800066e:	4780      	blx	r0
 8000670:	bd00      	pop	{pc}

08000672 <CCU80_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU80_0_IRQHandler
 8000672:	e7fe      	b.n	8000672 <CCU80_0_IRQHandler>

08000674 <CCU80_0_IRQHandler_Veneer>:
 8000674:	48b2      	ldr	r0, [pc, #712]	; (8000940 <AllowPLLInitByStartup+0x10c>)
 8000676:	b500      	push	{lr}
 8000678:	4780      	blx	r0
 800067a:	bd00      	pop	{pc}

0800067c <CCU80_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU80_1_IRQHandler
 800067c:	e7fe      	b.n	800067c <CCU80_1_IRQHandler>

0800067e <CCU80_1_IRQHandler_Veneer>:
 800067e:	48b1      	ldr	r0, [pc, #708]	; (8000944 <AllowPLLInitByStartup+0x110>)
 8000680:	b500      	push	{lr}
 8000682:	4780      	blx	r0
 8000684:	bd00      	pop	{pc}

08000686 <CCU80_2_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU80_2_IRQHandler
 8000686:	e7fe      	b.n	8000686 <CCU80_2_IRQHandler>

08000688 <CCU80_2_IRQHandler_Veneer>:
 8000688:	48af      	ldr	r0, [pc, #700]	; (8000948 <AllowPLLInitByStartup+0x114>)
 800068a:	b500      	push	{lr}
 800068c:	4780      	blx	r0
 800068e:	bd00      	pop	{pc}

08000690 <CCU80_3_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU80_3_IRQHandler
 8000690:	e7fe      	b.n	8000690 <CCU80_3_IRQHandler>

08000692 <CCU80_3_IRQHandler_Veneer>:
 8000692:	48ae      	ldr	r0, [pc, #696]	; (800094c <AllowPLLInitByStartup+0x118>)
 8000694:	b500      	push	{lr}
 8000696:	4780      	blx	r0
 8000698:	bd00      	pop	{pc}

0800069a <CCU81_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU81_0_IRQHandler
 800069a:	e7fe      	b.n	800069a <CCU81_0_IRQHandler>

0800069c <CCU81_0_IRQHandler_Veneer>:
 800069c:	48ac      	ldr	r0, [pc, #688]	; (8000950 <AllowPLLInitByStartup+0x11c>)
 800069e:	b500      	push	{lr}
 80006a0:	4780      	blx	r0
 80006a2:	bd00      	pop	{pc}

080006a4 <CCU81_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU81_1_IRQHandler
 80006a4:	e7fe      	b.n	80006a4 <CCU81_1_IRQHandler>

080006a6 <CCU81_1_IRQHandler_Veneer>:
 80006a6:	48ab      	ldr	r0, [pc, #684]	; (8000954 <AllowPLLInitByStartup+0x120>)
 80006a8:	b500      	push	{lr}
 80006aa:	4780      	blx	r0
 80006ac:	bd00      	pop	{pc}

080006ae <CCU81_2_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU81_2_IRQHandler
 80006ae:	e7fe      	b.n	80006ae <CCU81_2_IRQHandler>

080006b0 <CCU81_2_IRQHandler_Veneer>:
 80006b0:	48a9      	ldr	r0, [pc, #676]	; (8000958 <AllowPLLInitByStartup+0x124>)
 80006b2:	b500      	push	{lr}
 80006b4:	4780      	blx	r0
 80006b6:	bd00      	pop	{pc}

080006b8 <CCU81_3_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU81_3_IRQHandler
 80006b8:	e7fe      	b.n	80006b8 <CCU81_3_IRQHandler>

080006ba <CCU81_3_IRQHandler_Veneer>:
 80006ba:	48a8      	ldr	r0, [pc, #672]	; (800095c <AllowPLLInitByStartup+0x128>)
 80006bc:	b500      	push	{lr}
 80006be:	4780      	blx	r0
 80006c0:	bd00      	pop	{pc}

080006c2 <POSIF0_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler POSIF0_0_IRQHandler
 80006c2:	e7fe      	b.n	80006c2 <POSIF0_0_IRQHandler>

080006c4 <POSIF0_0_IRQHandler_Veneer>:
 80006c4:	48a6      	ldr	r0, [pc, #664]	; (8000960 <AllowPLLInitByStartup+0x12c>)
 80006c6:	b500      	push	{lr}
 80006c8:	4780      	blx	r0
 80006ca:	bd00      	pop	{pc}

080006cc <POSIF0_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler POSIF0_1_IRQHandler
 80006cc:	e7fe      	b.n	80006cc <POSIF0_1_IRQHandler>

080006ce <POSIF0_1_IRQHandler_Veneer>:
 80006ce:	48a5      	ldr	r0, [pc, #660]	; (8000964 <AllowPLLInitByStartup+0x130>)
 80006d0:	b500      	push	{lr}
 80006d2:	4780      	blx	r0
 80006d4:	bd00      	pop	{pc}

080006d6 <POSIF1_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler POSIF1_0_IRQHandler
 80006d6:	e7fe      	b.n	80006d6 <POSIF1_0_IRQHandler>

080006d8 <POSIF1_0_IRQHandler_Veneer>:
 80006d8:	48a3      	ldr	r0, [pc, #652]	; (8000968 <AllowPLLInitByStartup+0x134>)
 80006da:	b500      	push	{lr}
 80006dc:	4780      	blx	r0
 80006de:	bd00      	pop	{pc}

080006e0 <POSIF1_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler POSIF1_1_IRQHandler
 80006e0:	e7fe      	b.n	80006e0 <POSIF1_1_IRQHandler>

080006e2 <POSIF1_1_IRQHandler_Veneer>:
 80006e2:	48a2      	ldr	r0, [pc, #648]	; (800096c <AllowPLLInitByStartup+0x138>)
 80006e4:	b500      	push	{lr}
 80006e6:	4780      	blx	r0
 80006e8:	bd00      	pop	{pc}

080006ea <CAN0_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CAN0_0_IRQHandler
 80006ea:	e7fe      	b.n	80006ea <CAN0_0_IRQHandler>

080006ec <CAN0_0_IRQHandler_Veneer>:
 80006ec:	48a0      	ldr	r0, [pc, #640]	; (8000970 <AllowPLLInitByStartup+0x13c>)
 80006ee:	b500      	push	{lr}
 80006f0:	4780      	blx	r0
 80006f2:	bd00      	pop	{pc}

080006f4 <CAN0_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CAN0_1_IRQHandler
 80006f4:	e7fe      	b.n	80006f4 <CAN0_1_IRQHandler>

080006f6 <CAN0_1_IRQHandler_Veneer>:
 80006f6:	489f      	ldr	r0, [pc, #636]	; (8000974 <AllowPLLInitByStartup+0x140>)
 80006f8:	b500      	push	{lr}
 80006fa:	4780      	blx	r0
 80006fc:	bd00      	pop	{pc}
/* ======================================================================== */
     Insert_ExceptionHandler CAN0_2_IRQHandler
 80006fe:	e7fe      	b.n	80006fe <CAN0_1_IRQHandler_Veneer+0x8>

08000700 <CAN0_2_IRQHandler_Veneer>:
 8000700:	489d      	ldr	r0, [pc, #628]	; (8000978 <AllowPLLInitByStartup+0x144>)
 8000702:	b500      	push	{lr}
 8000704:	4780      	blx	r0
 8000706:	bd00      	pop	{pc}
/* ======================================================================== */
     Insert_ExceptionHandler CAN0_3_IRQHandler
 8000708:	e7fe      	b.n	8000708 <CAN0_2_IRQHandler_Veneer+0x8>

0800070a <CAN0_3_IRQHandler_Veneer>:
 800070a:	489c      	ldr	r0, [pc, #624]	; (800097c <AllowPLLInitByStartup+0x148>)
 800070c:	b500      	push	{lr}
 800070e:	4780      	blx	r0
 8000710:	bd00      	pop	{pc}
/* ======================================================================== */
     Insert_ExceptionHandler CAN0_4_IRQHandler
 8000712:	e7fe      	b.n	8000712 <CAN0_3_IRQHandler_Veneer+0x8>

08000714 <CAN0_4_IRQHandler_Veneer>:
 8000714:	489a      	ldr	r0, [pc, #616]	; (8000980 <AllowPLLInitByStartup+0x14c>)
 8000716:	b500      	push	{lr}
 8000718:	4780      	blx	r0
 800071a:	bd00      	pop	{pc}
/* ======================================================================== */
     Insert_ExceptionHandler CAN0_5_IRQHandler
 800071c:	e7fe      	b.n	800071c <CAN0_4_IRQHandler_Veneer+0x8>

0800071e <CAN0_5_IRQHandler_Veneer>:
 800071e:	4899      	ldr	r0, [pc, #612]	; (8000984 <AllowPLLInitByStartup+0x150>)
 8000720:	b500      	push	{lr}
 8000722:	4780      	blx	r0
 8000724:	bd00      	pop	{pc}
/* ======================================================================== */
     Insert_ExceptionHandler CAN0_6_IRQHandler
 8000726:	e7fe      	b.n	8000726 <CAN0_5_IRQHandler_Veneer+0x8>

08000728 <CAN0_6_IRQHandler_Veneer>:
 8000728:	4897      	ldr	r0, [pc, #604]	; (8000988 <AllowPLLInitByStartup+0x154>)
 800072a:	b500      	push	{lr}
 800072c:	4780      	blx	r0
 800072e:	bd00      	pop	{pc}
/* ======================================================================== */
     Insert_ExceptionHandler CAN0_7_IRQHandler
 8000730:	e7fe      	b.n	8000730 <CAN0_6_IRQHandler_Veneer+0x8>

08000732 <CAN0_7_IRQHandler_Veneer>:
 8000732:	4896      	ldr	r0, [pc, #600]	; (800098c <AllowPLLInitByStartup+0x158>)
 8000734:	b500      	push	{lr}
 8000736:	4780      	blx	r0
 8000738:	bd00      	pop	{pc}

0800073a <USIC0_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler USIC0_0_IRQHandler
 800073a:	e7fe      	b.n	800073a <USIC0_0_IRQHandler>

0800073c <USIC0_0_IRQHandler_Veneer>:
 800073c:	4894      	ldr	r0, [pc, #592]	; (8000990 <AllowPLLInitByStartup+0x15c>)
 800073e:	b500      	push	{lr}
 8000740:	4780      	blx	r0
 8000742:	bd00      	pop	{pc}
/* ======================================================================== */
     Insert_ExceptionHandler USIC0_1_IRQHandler
 8000744:	e7fe      	b.n	8000744 <USIC0_0_IRQHandler_Veneer+0x8>

08000746 <USIC0_1_IRQHandler_Veneer>:
 8000746:	4893      	ldr	r0, [pc, #588]	; (8000994 <AllowPLLInitByStartup+0x160>)
 8000748:	b500      	push	{lr}
 800074a:	4780      	blx	r0
 800074c:	bd00      	pop	{pc}
/* ======================================================================== */
     Insert_ExceptionHandler USIC0_2_IRQHandler
 800074e:	e7fe      	b.n	800074e <USIC0_1_IRQHandler_Veneer+0x8>

08000750 <USIC0_2_IRQHandler_Veneer>:
 8000750:	4891      	ldr	r0, [pc, #580]	; (8000998 <AllowPLLInitByStartup+0x164>)
 8000752:	b500      	push	{lr}
 8000754:	4780      	blx	r0
 8000756:	bd00      	pop	{pc}

08000758 <USIC0_3_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler USIC0_3_IRQHandler
 8000758:	e7fe      	b.n	8000758 <USIC0_3_IRQHandler>

0800075a <USIC0_3_IRQHandler_Veneer>:
 800075a:	4890      	ldr	r0, [pc, #576]	; (800099c <AllowPLLInitByStartup+0x168>)
 800075c:	b500      	push	{lr}
 800075e:	4780      	blx	r0
 8000760:	bd00      	pop	{pc}

08000762 <USIC0_4_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler USIC0_4_IRQHandler
 8000762:	e7fe      	b.n	8000762 <USIC0_4_IRQHandler>

08000764 <USIC0_4_IRQHandler_Veneer>:
 8000764:	488e      	ldr	r0, [pc, #568]	; (80009a0 <AllowPLLInitByStartup+0x16c>)
 8000766:	b500      	push	{lr}
 8000768:	4780      	blx	r0
 800076a:	bd00      	pop	{pc}

0800076c <USIC0_5_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler USIC0_5_IRQHandler
 800076c:	e7fe      	b.n	800076c <USIC0_5_IRQHandler>

0800076e <USIC0_5_IRQHandler_Veneer>:
 800076e:	488d      	ldr	r0, [pc, #564]	; (80009a4 <AllowPLLInitByStartup+0x170>)
 8000770:	b500      	push	{lr}
 8000772:	4780      	blx	r0
 8000774:	bd00      	pop	{pc}

08000776 <USIC1_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler USIC1_0_IRQHandler
 8000776:	e7fe      	b.n	8000776 <USIC1_0_IRQHandler>

08000778 <USIC1_0_IRQHandler_Veneer>:
 8000778:	488b      	ldr	r0, [pc, #556]	; (80009a8 <AllowPLLInitByStartup+0x174>)
 800077a:	b500      	push	{lr}
 800077c:	4780      	blx	r0
 800077e:	bd00      	pop	{pc}

08000780 <USIC1_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler USIC1_1_IRQHandler
 8000780:	e7fe      	b.n	8000780 <USIC1_1_IRQHandler>

08000782 <USIC1_1_IRQHandler_Veneer>:
 8000782:	488a      	ldr	r0, [pc, #552]	; (80009ac <AllowPLLInitByStartup+0x178>)
 8000784:	b500      	push	{lr}
 8000786:	4780      	blx	r0
 8000788:	bd00      	pop	{pc}

0800078a <USIC1_2_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler USIC1_2_IRQHandler
 800078a:	e7fe      	b.n	800078a <USIC1_2_IRQHandler>

0800078c <USIC1_2_IRQHandler_Veneer>:
 800078c:	4888      	ldr	r0, [pc, #544]	; (80009b0 <AllowPLLInitByStartup+0x17c>)
 800078e:	b500      	push	{lr}
 8000790:	4780      	blx	r0
 8000792:	bd00      	pop	{pc}

08000794 <USIC1_3_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler USIC1_3_IRQHandler
 8000794:	e7fe      	b.n	8000794 <USIC1_3_IRQHandler>

08000796 <USIC1_3_IRQHandler_Veneer>:
 8000796:	4887      	ldr	r0, [pc, #540]	; (80009b4 <AllowPLLInitByStartup+0x180>)
 8000798:	b500      	push	{lr}
 800079a:	4780      	blx	r0
 800079c:	bd00      	pop	{pc}

0800079e <USIC1_4_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler USIC1_4_IRQHandler
 800079e:	e7fe      	b.n	800079e <USIC1_4_IRQHandler>

080007a0 <USIC1_4_IRQHandler_Veneer>:
 80007a0:	4885      	ldr	r0, [pc, #532]	; (80009b8 <AllowPLLInitByStartup+0x184>)
 80007a2:	b500      	push	{lr}
 80007a4:	4780      	blx	r0
 80007a6:	bd00      	pop	{pc}

080007a8 <USIC1_5_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler USIC1_5_IRQHandler
 80007a8:	e7fe      	b.n	80007a8 <USIC1_5_IRQHandler>

080007aa <USIC1_5_IRQHandler_Veneer>:
 80007aa:	4884      	ldr	r0, [pc, #528]	; (80009bc <AllowPLLInitByStartup+0x188>)
 80007ac:	b500      	push	{lr}
 80007ae:	4780      	blx	r0
 80007b0:	bd00      	pop	{pc}

080007b2 <USIC2_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler USIC2_0_IRQHandler
 80007b2:	e7fe      	b.n	80007b2 <USIC2_0_IRQHandler>

080007b4 <USIC2_0_IRQHandler_Veneer>:
 80007b4:	4882      	ldr	r0, [pc, #520]	; (80009c0 <AllowPLLInitByStartup+0x18c>)
 80007b6:	b500      	push	{lr}
 80007b8:	4780      	blx	r0
 80007ba:	bd00      	pop	{pc}

080007bc <USIC2_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler USIC2_1_IRQHandler
 80007bc:	e7fe      	b.n	80007bc <USIC2_1_IRQHandler>

080007be <USIC2_1_IRQHandler_Veneer>:
 80007be:	4881      	ldr	r0, [pc, #516]	; (80009c4 <AllowPLLInitByStartup+0x190>)
 80007c0:	b500      	push	{lr}
 80007c2:	4780      	blx	r0
 80007c4:	bd00      	pop	{pc}

080007c6 <USIC2_2_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler USIC2_2_IRQHandler
 80007c6:	e7fe      	b.n	80007c6 <USIC2_2_IRQHandler>

080007c8 <USIC2_2_IRQHandler_Veneer>:
 80007c8:	487f      	ldr	r0, [pc, #508]	; (80009c8 <AllowPLLInitByStartup+0x194>)
 80007ca:	b500      	push	{lr}
 80007cc:	4780      	blx	r0
 80007ce:	bd00      	pop	{pc}

080007d0 <USIC2_3_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler USIC2_3_IRQHandler
 80007d0:	e7fe      	b.n	80007d0 <USIC2_3_IRQHandler>

080007d2 <USIC2_3_IRQHandler_Veneer>:
 80007d2:	487e      	ldr	r0, [pc, #504]	; (80009cc <AllowPLLInitByStartup+0x198>)
 80007d4:	b500      	push	{lr}
 80007d6:	4780      	blx	r0
 80007d8:	bd00      	pop	{pc}

080007da <USIC2_4_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler USIC2_4_IRQHandler
 80007da:	e7fe      	b.n	80007da <USIC2_4_IRQHandler>

080007dc <USIC2_4_IRQHandler_Veneer>:
 80007dc:	487c      	ldr	r0, [pc, #496]	; (80009d0 <AllowPLLInitByStartup+0x19c>)
 80007de:	b500      	push	{lr}
 80007e0:	4780      	blx	r0
 80007e2:	bd00      	pop	{pc}

080007e4 <USIC2_5_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler USIC2_5_IRQHandler
 80007e4:	e7fe      	b.n	80007e4 <USIC2_5_IRQHandler>

080007e6 <USIC2_5_IRQHandler_Veneer>:
 80007e6:	487b      	ldr	r0, [pc, #492]	; (80009d4 <AllowPLLInitByStartup+0x1a0>)
 80007e8:	b500      	push	{lr}
 80007ea:	4780      	blx	r0
 80007ec:	bd00      	pop	{pc}

080007ee <LEDTS0_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler LEDTS0_0_IRQHandler
 80007ee:	e7fe      	b.n	80007ee <LEDTS0_0_IRQHandler>

080007f0 <LEDTS0_0_IRQHandler_Veneer>:
 80007f0:	4879      	ldr	r0, [pc, #484]	; (80009d8 <AllowPLLInitByStartup+0x1a4>)
 80007f2:	b500      	push	{lr}
 80007f4:	4780      	blx	r0
 80007f6:	bd00      	pop	{pc}

080007f8 <FCE0_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler FCE0_0_IRQHandler
 80007f8:	e7fe      	b.n	80007f8 <FCE0_0_IRQHandler>

080007fa <FCE0_0_IRQHandler_Veneer>:
 80007fa:	4878      	ldr	r0, [pc, #480]	; (80009dc <AllowPLLInitByStartup+0x1a8>)
 80007fc:	b500      	push	{lr}
 80007fe:	4780      	blx	r0
 8000800:	bd00      	pop	{pc}

08000802 <GPDMA0_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler GPDMA0_0_IRQHandler
 8000802:	e7fe      	b.n	8000802 <GPDMA0_0_IRQHandler>

08000804 <GPDMA0_0_IRQHandler_Veneer>:
 8000804:	4876      	ldr	r0, [pc, #472]	; (80009e0 <AllowPLLInitByStartup+0x1ac>)
 8000806:	b500      	push	{lr}
 8000808:	4780      	blx	r0
 800080a:	bd00      	pop	{pc}

0800080c <SDMMC0_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler SDMMC0_0_IRQHandler
 800080c:	e7fe      	b.n	800080c <SDMMC0_0_IRQHandler>

0800080e <SDMMC0_0_IRQHandler_Veneer>:
 800080e:	4875      	ldr	r0, [pc, #468]	; (80009e4 <AllowPLLInitByStartup+0x1b0>)
 8000810:	b500      	push	{lr}
 8000812:	4780      	blx	r0
 8000814:	bd00      	pop	{pc}

08000816 <USB0_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler USB0_0_IRQHandler
 8000816:	e7fe      	b.n	8000816 <USB0_0_IRQHandler>

08000818 <USB0_0_IRQHandler_Veneer>:
 8000818:	4873      	ldr	r0, [pc, #460]	; (80009e8 <AllowPLLInitByStartup+0x1b4>)
 800081a:	b500      	push	{lr}
 800081c:	4780      	blx	r0
 800081e:	bd00      	pop	{pc}
/* ======================================================================== */
     Insert_ExceptionHandler ETH0_0_IRQHandler
 8000820:	e7fe      	b.n	8000820 <USB0_0_IRQHandler_Veneer+0x8>

08000822 <ETH0_0_IRQHandler_Veneer>:
 8000822:	4872      	ldr	r0, [pc, #456]	; (80009ec <AllowPLLInitByStartup+0x1b8>)
 8000824:	b500      	push	{lr}
 8000826:	4780      	blx	r0
 8000828:	bd00      	pop	{pc}

0800082a <GPDMA1_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler GPDMA1_0_IRQHandler
 800082a:	e7fe      	b.n	800082a <GPDMA1_0_IRQHandler>

0800082c <GPDMA1_0_IRQHandler_Veneer>:
 800082c:	4870      	ldr	r0, [pc, #448]	; (80009f0 <AllowPLLInitByStartup+0x1bc>)
 800082e:	b500      	push	{lr}
 8000830:	4780      	blx	r0
 8000832:	bd00      	pop	{pc}

08000834 <AllowPLLInitByStartup>:
   returns FALSE indicating that the code engine has performed the clock setup
*/
    .weak   AllowPLLInitByStartup
    .type   AllowPLLInitByStartup, %function
AllowPLLInitByStartup:
    MOV R0,#1
 8000834:	f04f 0001 	mov.w	r0, #1
    BX LR
 8000838:	4770      	bx	lr
 800083a:	0000      	.short	0x0000
/* Default exception Handlers - Users may override this default functionality by
   defining handlers of the same name in their C code */
    .thumb
    .text

     Insert_ExceptionHandler NMI_Handler
 800083c:	0800a8e5 	.word	0x0800a8e5
/* ======================================================================== */
     Insert_ExceptionHandler HardFault_Handler
 8000840:	0800a8d9 	.word	0x0800a8d9
/* ======================================================================== */
     Insert_ExceptionHandler MemManage_Handler
 8000844:	0800a8dd 	.word	0x0800a8dd
/* ======================================================================== */
     Insert_ExceptionHandler BusFault_Handler
 8000848:	0800a8d5 	.word	0x0800a8d5
/* ======================================================================== */
     Insert_ExceptionHandler UsageFault_Handler
 800084c:	0800a8e1 	.word	0x0800a8e1
/* ======================================================================== */
     Insert_ExceptionHandler SVC_Handler
 8000850:	08001d91 	.word	0x08001d91
/* ======================================================================== */
     Insert_ExceptionHandler DebugMon_Handler
 8000854:	08000415 	.word	0x08000415
/* ======================================================================== */
     Insert_ExceptionHandler PendSV_Handler
 8000858:	08001e31 	.word	0x08001e31
/* ======================================================================== */
     Insert_ExceptionHandler SysTick_Handler
 800085c:	08001ea1 	.word	0x08001ea1
/* ============= END OF EXCEPTION HANDLER DEFINITION ======================== */

/* ============= START OF INTERRUPT HANDLER DEFINITION ====================== */

/* IRQ Handlers */
     Insert_ExceptionHandler SCU_0_IRQHandler
 8000860:	08009dfd 	.word	0x08009dfd
/* ======================================================================== */
     Insert_ExceptionHandler ERU0_0_IRQHandler
 8000864:	08000445 	.word	0x08000445
/* ======================================================================== */
     Insert_ExceptionHandler ERU0_1_IRQHandler
 8000868:	08000451 	.word	0x08000451
/* ======================================================================== */
     Insert_ExceptionHandler ERU0_2_IRQHandler
 800086c:	0800045d 	.word	0x0800045d
/* ======================================================================== */
     Insert_ExceptionHandler ERU0_3_IRQHandler
 8000870:	08000469 	.word	0x08000469
/* ======================================================================== */
     Insert_ExceptionHandler ERU1_0_IRQHandler
 8000874:	08000475 	.word	0x08000475
/* ======================================================================== */
     Insert_ExceptionHandler ERU1_1_IRQHandler
 8000878:	0800047f 	.word	0x0800047f
/* ======================================================================== */
     Insert_ExceptionHandler ERU1_2_IRQHandler
 800087c:	08000489 	.word	0x08000489
/* ======================================================================== */
     Insert_ExceptionHandler ERU1_3_IRQHandler
 8000880:	08000493 	.word	0x08000493
/* ======================================================================== */
     Insert_ExceptionHandler PMU0_0_IRQHandler
 8000884:	0800049d 	.word	0x0800049d
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_C0_0_IRQHandler
 8000888:	080004a7 	.word	0x080004a7
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_C0_1_IRQHandler
 800088c:	080004b1 	.word	0x080004b1
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_C0_2_IRQHandler
 8000890:	080004bb 	.word	0x080004bb
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_C0_3_IRQHandler
 8000894:	080004c5 	.word	0x080004c5
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G0_0_IRQHandler
 8000898:	080004cf 	.word	0x080004cf
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G0_1_IRQHandler
 800089c:	080004d9 	.word	0x080004d9
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G0_2_IRQHandler
 80008a0:	080004e3 	.word	0x080004e3
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G0_3_IRQHandler
 80008a4:	080004ed 	.word	0x080004ed
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G1_0_IRQHandler
 80008a8:	080004f7 	.word	0x080004f7
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G1_1_IRQHandler
 80008ac:	08000501 	.word	0x08000501
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G1_2_IRQHandler
 80008b0:	0800050b 	.word	0x0800050b
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G1_3_IRQHandler
 80008b4:	08000515 	.word	0x08000515
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G2_0_IRQHandler
 80008b8:	0800051f 	.word	0x0800051f
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G2_1_IRQHandler
 80008bc:	08000529 	.word	0x08000529
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G2_2_IRQHandler
 80008c0:	08000533 	.word	0x08000533
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G2_3_IRQHandler
 80008c4:	0800053d 	.word	0x0800053d
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G3_0_IRQHandler
 80008c8:	08000547 	.word	0x08000547
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G3_1_IRQHandler
 80008cc:	08000551 	.word	0x08000551
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G3_2_IRQHandler
 80008d0:	0800055b 	.word	0x0800055b
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G3_3_IRQHandler
 80008d4:	08000565 	.word	0x08000565
/* ======================================================================== */
     Insert_ExceptionHandler DSD0_0_IRQHandler
 80008d8:	0800056f 	.word	0x0800056f
/* ======================================================================== */
     Insert_ExceptionHandler DSD0_1_IRQHandler
 80008dc:	08000579 	.word	0x08000579
/* ======================================================================== */
     Insert_ExceptionHandler DSD0_2_IRQHandler
 80008e0:	08000583 	.word	0x08000583
/* ======================================================================== */
     Insert_ExceptionHandler DSD0_3_IRQHandler
 80008e4:	0800058d 	.word	0x0800058d
/* ======================================================================== */
     Insert_ExceptionHandler DSD0_4_IRQHandler
 80008e8:	08000597 	.word	0x08000597
/* ======================================================================== */
     Insert_ExceptionHandler DSD0_5_IRQHandler
 80008ec:	080005a1 	.word	0x080005a1
/* ======================================================================== */
     Insert_ExceptionHandler DSD0_6_IRQHandler
 80008f0:	080005ab 	.word	0x080005ab
/* ======================================================================== */
     Insert_ExceptionHandler DSD0_7_IRQHandler
 80008f4:	080005b5 	.word	0x080005b5
/* ======================================================================== */
     Insert_ExceptionHandler DAC0_0_IRQHandler
 80008f8:	080005bf 	.word	0x080005bf
/* ======================================================================== */
     Insert_ExceptionHandler DAC0_1_IRQHandler
 80008fc:	080005c9 	.word	0x080005c9
/* ======================================================================== */
     Insert_ExceptionHandler CCU40_0_IRQHandler
 8000900:	080005d3 	.word	0x080005d3
/* ======================================================================== */
     Insert_ExceptionHandler CCU40_1_IRQHandler
 8000904:	080005dd 	.word	0x080005dd
/* ======================================================================== */
     Insert_ExceptionHandler CCU40_2_IRQHandler
 8000908:	080005e7 	.word	0x080005e7
/* ======================================================================== */
     Insert_ExceptionHandler CCU40_3_IRQHandler
 800090c:	080005f1 	.word	0x080005f1
/* ======================================================================== */
     Insert_ExceptionHandler CCU41_0_IRQHandler
 8000910:	080005fb 	.word	0x080005fb
/* ======================================================================== */
     Insert_ExceptionHandler CCU41_1_IRQHandler
 8000914:	08000605 	.word	0x08000605
/* ======================================================================== */
     Insert_ExceptionHandler CCU41_2_IRQHandler
 8000918:	0800060f 	.word	0x0800060f
/* ======================================================================== */
     Insert_ExceptionHandler CCU41_3_IRQHandler
 800091c:	08000619 	.word	0x08000619
/* ======================================================================== */
     Insert_ExceptionHandler CCU42_0_IRQHandler
 8000920:	08000623 	.word	0x08000623
/* ======================================================================== */
     Insert_ExceptionHandler CCU42_1_IRQHandler
 8000924:	0800062d 	.word	0x0800062d
/* ======================================================================== */
     Insert_ExceptionHandler CCU42_2_IRQHandler
 8000928:	08000637 	.word	0x08000637
/* ======================================================================== */
     Insert_ExceptionHandler CCU42_3_IRQHandler
 800092c:	08000641 	.word	0x08000641
/* ======================================================================== */
     Insert_ExceptionHandler CCU43_0_IRQHandler
 8000930:	0800064b 	.word	0x0800064b
/* ======================================================================== */
     Insert_ExceptionHandler CCU43_1_IRQHandler
 8000934:	08000655 	.word	0x08000655
/* ======================================================================== */
     Insert_ExceptionHandler CCU43_2_IRQHandler
 8000938:	0800065f 	.word	0x0800065f
/* ======================================================================== */
     Insert_ExceptionHandler CCU43_3_IRQHandler
 800093c:	08000669 	.word	0x08000669
/* ======================================================================== */
     Insert_ExceptionHandler CCU80_0_IRQHandler
 8000940:	08000673 	.word	0x08000673
/* ======================================================================== */
     Insert_ExceptionHandler CCU80_1_IRQHandler
 8000944:	0800067d 	.word	0x0800067d
/* ======================================================================== */
     Insert_ExceptionHandler CCU80_2_IRQHandler
 8000948:	08000687 	.word	0x08000687
/* ======================================================================== */
     Insert_ExceptionHandler CCU80_3_IRQHandler
 800094c:	08000691 	.word	0x08000691
/* ======================================================================== */
     Insert_ExceptionHandler CCU81_0_IRQHandler
 8000950:	0800069b 	.word	0x0800069b
/* ======================================================================== */
     Insert_ExceptionHandler CCU81_1_IRQHandler
 8000954:	080006a5 	.word	0x080006a5
/* ======================================================================== */
     Insert_ExceptionHandler CCU81_2_IRQHandler
 8000958:	080006af 	.word	0x080006af
/* ======================================================================== */
     Insert_ExceptionHandler CCU81_3_IRQHandler
 800095c:	080006b9 	.word	0x080006b9
/* ======================================================================== */
     Insert_ExceptionHandler POSIF0_0_IRQHandler
 8000960:	080006c3 	.word	0x080006c3
/* ======================================================================== */
     Insert_ExceptionHandler POSIF0_1_IRQHandler
 8000964:	080006cd 	.word	0x080006cd
/* ======================================================================== */
     Insert_ExceptionHandler POSIF1_0_IRQHandler
 8000968:	080006d7 	.word	0x080006d7
/* ======================================================================== */
     Insert_ExceptionHandler POSIF1_1_IRQHandler
 800096c:	080006e1 	.word	0x080006e1
/* ======================================================================== */
     Insert_ExceptionHandler CAN0_0_IRQHandler
 8000970:	080006eb 	.word	0x080006eb
/* ======================================================================== */
     Insert_ExceptionHandler CAN0_1_IRQHandler
 8000974:	080006f5 	.word	0x080006f5
/* ======================================================================== */
     Insert_ExceptionHandler CAN0_2_IRQHandler
 8000978:	0800a389 	.word	0x0800a389
/* ======================================================================== */
     Insert_ExceptionHandler CAN0_3_IRQHandler
 800097c:	0800a3b9 	.word	0x0800a3b9
/* ======================================================================== */
     Insert_ExceptionHandler CAN0_4_IRQHandler
 8000980:	0800a3f5 	.word	0x0800a3f5
/* ======================================================================== */
     Insert_ExceptionHandler CAN0_5_IRQHandler
 8000984:	0800a425 	.word	0x0800a425
/* ======================================================================== */
     Insert_ExceptionHandler CAN0_6_IRQHandler
 8000988:	0800a455 	.word	0x0800a455
/* ======================================================================== */
     Insert_ExceptionHandler CAN0_7_IRQHandler
 800098c:	0800a491 	.word	0x0800a491
/* ======================================================================== */
     Insert_ExceptionHandler USIC0_0_IRQHandler
 8000990:	0800073b 	.word	0x0800073b
/* ======================================================================== */
     Insert_ExceptionHandler USIC0_1_IRQHandler
 8000994:	08009cf5 	.word	0x08009cf5
/* ======================================================================== */
     Insert_ExceptionHandler USIC0_2_IRQHandler
 8000998:	08009ce5 	.word	0x08009ce5
/* ======================================================================== */
     Insert_ExceptionHandler USIC0_3_IRQHandler
 800099c:	08000759 	.word	0x08000759
/* ======================================================================== */
     Insert_ExceptionHandler USIC0_4_IRQHandler
 80009a0:	08000763 	.word	0x08000763
/* ======================================================================== */
     Insert_ExceptionHandler USIC0_5_IRQHandler
 80009a4:	0800076d 	.word	0x0800076d
/* ======================================================================== */
     Insert_ExceptionHandler USIC1_0_IRQHandler
 80009a8:	08000777 	.word	0x08000777
/* ======================================================================== */
     Insert_ExceptionHandler USIC1_1_IRQHandler
 80009ac:	08000781 	.word	0x08000781
/* ======================================================================== */
     Insert_ExceptionHandler USIC1_2_IRQHandler
 80009b0:	0800078b 	.word	0x0800078b
/* ======================================================================== */
     Insert_ExceptionHandler USIC1_3_IRQHandler
 80009b4:	08000795 	.word	0x08000795
/* ======================================================================== */
     Insert_ExceptionHandler USIC1_4_IRQHandler
 80009b8:	0800079f 	.word	0x0800079f
/* ======================================================================== */
     Insert_ExceptionHandler USIC1_5_IRQHandler
 80009bc:	080007a9 	.word	0x080007a9
/* ======================================================================== */
     Insert_ExceptionHandler USIC2_0_IRQHandler
 80009c0:	080007b3 	.word	0x080007b3
/* ======================================================================== */
     Insert_ExceptionHandler USIC2_1_IRQHandler
 80009c4:	080007bd 	.word	0x080007bd
/* ======================================================================== */
     Insert_ExceptionHandler USIC2_2_IRQHandler
 80009c8:	080007c7 	.word	0x080007c7
/* ======================================================================== */
     Insert_ExceptionHandler USIC2_3_IRQHandler
 80009cc:	080007d1 	.word	0x080007d1
/* ======================================================================== */
     Insert_ExceptionHandler USIC2_4_IRQHandler
 80009d0:	080007db 	.word	0x080007db
/* ======================================================================== */
     Insert_ExceptionHandler USIC2_5_IRQHandler
 80009d4:	080007e5 	.word	0x080007e5
/* ======================================================================== */
     Insert_ExceptionHandler LEDTS0_0_IRQHandler
 80009d8:	080007ef 	.word	0x080007ef
/* ======================================================================== */
     Insert_ExceptionHandler FCE0_0_IRQHandler
 80009dc:	080007f9 	.word	0x080007f9
/* ======================================================================== */
     Insert_ExceptionHandler GPDMA0_0_IRQHandler
 80009e0:	08000803 	.word	0x08000803
/* ======================================================================== */
     Insert_ExceptionHandler SDMMC0_0_IRQHandler
 80009e4:	0800080d 	.word	0x0800080d
/* ======================================================================== */
     Insert_ExceptionHandler USB0_0_IRQHandler
 80009e8:	08000817 	.word	0x08000817
/* ======================================================================== */
     Insert_ExceptionHandler ETH0_0_IRQHandler
 80009ec:	080044e5 	.word	0x080044e5
/* ======================================================================== */
     Insert_ExceptionHandler GPDMA1_0_IRQHandler
 80009f0:	0800082b 	.word	0x0800082b

080009f4 <SystemCoreClockUpdate>:


/*----------------------------------------------------------------------------
  Clock Variable definitions
 *----------------------------------------------------------------------------*/
if (SCU_CLK->SYSCLKCR ==  0x00010000)
 80009f4:	4b19      	ldr	r3, [pc, #100]	; (8000a5c <SystemCoreClockUpdate+0x68>)
 80009f6:	68db      	ldr	r3, [r3, #12]
 80009f8:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80009fc:	d127      	bne.n	8000a4e <SystemCoreClockUpdate+0x5a>
{
	if (SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk){
 80009fe:	4b18      	ldr	r3, [pc, #96]	; (8000a60 <SystemCoreClockUpdate+0x6c>)
 8000a00:	681b      	ldr	r3, [r3, #0]
 8000a02:	f013 0f04 	tst.w	r3, #4
 8000a06:	d028      	beq.n	8000a5a <SystemCoreClockUpdate+0x66>
  * @note   -  
  * @param  None
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
 8000a08:	b410      	push	{r4}
if (SCU_CLK->SYSCLKCR ==  0x00010000)
{
	if (SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk){
		/* check if PLL is locked */
		/* read back divider settings */
		 PDIV = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_PDIV_Msk)>>24)+1;
 8000a0a:	4815      	ldr	r0, [pc, #84]	; (8000a60 <SystemCoreClockUpdate+0x6c>)
 8000a0c:	6881      	ldr	r1, [r0, #8]
 8000a0e:	f3c1 6103 	ubfx	r1, r1, #24, #4
 8000a12:	1c4c      	adds	r4, r1, #1
		 NDIV = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_NDIV_Msk)>>8)+1;
 8000a14:	6883      	ldr	r3, [r0, #8]
 8000a16:	f3c3 2306 	ubfx	r3, r3, #8, #7
 8000a1a:	3301      	adds	r3, #1
		 K2DIV  = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_K2DIV_Msk)>>16)+1;
 8000a1c:	6882      	ldr	r2, [r0, #8]
 8000a1e:	f3c2 4206 	ubfx	r2, r2, #16, #7
 8000a22:	3201      	adds	r2, #1

		if(SCU_PLL->PLLCON2 & SCU_PLL_PLLCON2_PINSEL_Msk){
 8000a24:	68c1      	ldr	r1, [r0, #12]
 8000a26:	f011 0f01 	tst.w	r1, #1
		/* the selected clock is the Backup clock fofi */
		VCO = (CLOCK_BACK_UP/PDIV)*NDIV;
		SystemCoreClock = VCO/K2DIV;
		/* in case the sysclock div is used */
		SystemCoreClock = SystemCoreClock/((SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSDIV_Msk)+1);
 8000a2a:	490c      	ldr	r1, [pc, #48]	; (8000a5c <SystemCoreClockUpdate+0x68>)
 8000a2c:	68c8      	ldr	r0, [r1, #12]
		 NDIV = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_NDIV_Msk)>>8)+1;
		 K2DIV  = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_K2DIV_Msk)>>16)+1;

		if(SCU_PLL->PLLCON2 & SCU_PLL_PLLCON2_PINSEL_Msk){
		/* the selected clock is the Backup clock fofi */
		VCO = (CLOCK_BACK_UP/PDIV)*NDIV;
 8000a2e:	bf14      	ite	ne
 8000a30:	490c      	ldrne	r1, [pc, #48]	; (8000a64 <SystemCoreClockUpdate+0x70>)
		
		}
		else
		{
		/* the selected clock is the PLL external oscillator */		
		VCO = (CLOCK_CRYSTAL_FREQUENCY/PDIV)*NDIV;
 8000a32:	490d      	ldreq	r1, [pc, #52]	; (8000a68 <SystemCoreClockUpdate+0x74>)
 8000a34:	fbb1 f1f4 	udiv	r1, r1, r4
 8000a38:	fb03 f301 	mul.w	r3, r3, r1
		SystemCoreClock = VCO/K2DIV;
 8000a3c:	fbb3 f2f2 	udiv	r2, r3, r2
		/* in case the sysclock div is used */
		SystemCoreClock = SystemCoreClock/((SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSDIV_Msk)+1);
 8000a40:	b2c3      	uxtb	r3, r0
 8000a42:	3301      	adds	r3, #1
 8000a44:	fbb2 f2f3 	udiv	r2, r2, r3
 8000a48:	4b08      	ldr	r3, [pc, #32]	; (8000a6c <SystemCoreClockUpdate+0x78>)
 8000a4a:	601a      	str	r2, [r3, #0]
 8000a4c:	e003      	b.n	8000a56 <SystemCoreClockUpdate+0x62>
	
	}
}
else
{
SystemCoreClock = CLOCK_BACK_UP;
 8000a4e:	4a05      	ldr	r2, [pc, #20]	; (8000a64 <SystemCoreClockUpdate+0x70>)
 8000a50:	4b06      	ldr	r3, [pc, #24]	; (8000a6c <SystemCoreClockUpdate+0x78>)
 8000a52:	601a      	str	r2, [r3, #0]
 8000a54:	4770      	bx	lr
}


}
 8000a56:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000a5a:	4770      	bx	lr
 8000a5c:	50004600 	.word	0x50004600
 8000a60:	50004710 	.word	0x50004710
 8000a64:	016e3600 	.word	0x016e3600
 8000a68:	00b71b00 	.word	0x00b71b00
 8000a6c:	2000d570 	.word	0x2000d570

08000a70 <SystemInit>:
  *         SystemCoreClock variable.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 8000a70:	b508      	push	{r3, lr}
int temp;
	
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
SCB->CPACR |= ((3UL << 10*2) |                 /* set CP10 Full Access */
 8000a72:	4ba4      	ldr	r3, [pc, #656]	; (8000d04 <SystemInit+0x294>)
 8000a74:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8000a78:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 8000a7c:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
               (3UL << 11*2)  );               /* set CP11 Full Access */
#endif

/* Enable unaligned memory access - SCB_CCR.UNALIGN_TRP = 0 */
SCB->CCR &= ~(SCB_CCR_UNALIGN_TRP_Msk);
 8000a80:	695a      	ldr	r2, [r3, #20]
 8000a82:	f022 0208 	bic.w	r2, r2, #8
 8000a86:	615a      	str	r2, [r3, #20]
	
/* Setup the WDT */
#if WDT_SETUP

WDT->CTR &= ~WDTENB_nVal; 
 8000a88:	4a9f      	ldr	r2, [pc, #636]	; (8000d08 <SystemInit+0x298>)
 8000a8a:	6853      	ldr	r3, [r2, #4]
 8000a8c:	f023 0301 	bic.w	r3, r3, #1
 8000a90:	6053      	str	r3, [r2, #4]

#endif

/* Setup the Flash Wait State */
#if PMU_FLASH
temp = FLASH0->FCON; 
 8000a92:	499e      	ldr	r1, [pc, #632]	; (8000d0c <SystemInit+0x29c>)
 8000a94:	f241 0214 	movw	r2, #4116	; 0x1014
 8000a98:	588b      	ldr	r3, [r1, r2]
temp &= ~FLASH_FCON_WSPFLASH_Msk;
 8000a9a:	f023 030f 	bic.w	r3, r3, #15
temp |= PMU_FLASH_WS+3;
 8000a9e:	f043 0303 	orr.w	r3, r3, #3
FLASH0->FCON = temp;
 8000aa2:	508b      	str	r3, [r1, r2]

	
/* Setup the clockout */
#if SCU_CLOCKOUT_SETUP

SCU_CLK->EXTCLKCR	|= SCU_CLOCKOUT_SOURCE;
 8000aa4:	4b9a      	ldr	r3, [pc, #616]	; (8000d10 <SystemInit+0x2a0>)
 8000aa6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8000aa8:	f042 0203 	orr.w	r2, r2, #3
 8000aac:	629a      	str	r2, [r3, #40]	; 0x28
/*set PLL div for clkout */
SCU_CLK->EXTCLKCR	|= SCU_CLOCKOUT_DIV<<16;
 8000aae:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8000ab0:	f442 2210 	orr.w	r2, r2, #589824	; 0x90000
 8000ab4:	629a      	str	r2, [r3, #40]	; 0x28

if (SCU_CLOCKOUT_PIN) {
						PORT0->IOCR8 = 0x00000088;   /*P0.8 --> ALT1 select +  HWSEL */
 8000ab6:	4b97      	ldr	r3, [pc, #604]	; (8000d14 <SystemInit+0x2a4>)
 8000ab8:	2288      	movs	r2, #136	; 0x88
 8000aba:	619a      	str	r2, [r3, #24]
					    PORT0->HWSEL &= (~PORT0_HWSEL_HW8_Msk);
 8000abc:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8000abe:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
 8000ac2:	675a      	str	r2, [r3, #116]	; 0x74
int temp;
unsigned int long VCO;
int stepping_K2DIV;	

/* this weak function enables DAVE3 clock App usage */	
if(AllowPLLInitByStartup()){
 8000ac4:	f7ff feb6 	bl	8000834 <AllowPLLInitByStartup>
 8000ac8:	2800      	cmp	r0, #0
 8000aca:	f000 80d4 	beq.w	8000c76 <SystemInit+0x206>
	
/* check if PLL is switched on */
if ((SCU_PLL->PLLCON0 &(SCU_PLL_PLLCON0_VCOPWD_Msk | SCU_PLL_PLLCON0_PLLPWD_Msk)) != 0){
 8000ace:	4b92      	ldr	r3, [pc, #584]	; (8000d18 <SystemInit+0x2a8>)
 8000ad0:	685a      	ldr	r2, [r3, #4]
 8000ad2:	4b92      	ldr	r3, [pc, #584]	; (8000d1c <SystemInit+0x2ac>)
 8000ad4:	4013      	ands	r3, r2
 8000ad6:	b133      	cbz	r3, 8000ae6 <SystemInit+0x76>
/* enable PLL first */
  SCU_PLL->PLLCON0 &= ~(SCU_PLL_PLLCON0_VCOPWD_Msk | SCU_PLL_PLLCON0_PLLPWD_Msk);
 8000ad8:	4a8f      	ldr	r2, [pc, #572]	; (8000d18 <SystemInit+0x2a8>)
 8000ada:	6853      	ldr	r3, [r2, #4]
 8000adc:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8000ae0:	f023 0302 	bic.w	r3, r3, #2
 8000ae4:	6053      	str	r3, [r2, #4]
  {
	/********************************************************************************************************************/
	/*   Use external crystal for PLL clock input                                                                            */
	/********************************************************************************************************************/

   if (SCU_OSC->OSCHPCTRL & SCU_OSC_OSCHPCTRL_MODE_Msk){
 8000ae6:	4b8e      	ldr	r3, [pc, #568]	; (8000d20 <SystemInit+0x2b0>)
 8000ae8:	685b      	ldr	r3, [r3, #4]
 8000aea:	f013 0f30 	tst.w	r3, #48	; 0x30
 8000aee:	d031      	beq.n	8000b54 <SystemInit+0xe4>
	   SCU_OSC->OSCHPCTRL &= ~(SCU_OSC_HP_MODE);	 /*enable the OSC_HP*/
 8000af0:	4b8b      	ldr	r3, [pc, #556]	; (8000d20 <SystemInit+0x2b0>)
 8000af2:	685a      	ldr	r2, [r3, #4]
 8000af4:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8000af8:	605a      	str	r2, [r3, #4]
	   /* setup OSC WDG devider */
	   SCU_OSC->OSCHPCTRL |= (SCU_OSCHPWDGDIV<<16);         
 8000afa:	685a      	ldr	r2, [r3, #4]
 8000afc:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8000b00:	605a      	str	r2, [r3, #4]
	   /* select external OSC as PLL input */
	   SCU_PLL->PLLCON2 &= ~SCU_PLL_PLLCON2_PINSEL_Msk;
 8000b02:	3310      	adds	r3, #16
 8000b04:	68da      	ldr	r2, [r3, #12]
 8000b06:	f022 0201 	bic.w	r2, r2, #1
 8000b0a:	60da      	str	r2, [r3, #12]
	   /* restart OSC Watchdog */
	   SCU_PLL->PLLCON0 &= ~SCU_PLL_PLLCON0_OSCRES_Msk;  
 8000b0c:	685a      	ldr	r2, [r3, #4]
 8000b0e:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 8000b12:	605a      	str	r2, [r3, #4]

       /* Timeout for wait loop ~150ms */
	   /********************************/
	   SysTick->LOAD  = ((5000000+100) & SysTick_LOAD_RELOAD_Msk) - 1;/* set reload register */
 8000b14:	4b83      	ldr	r3, [pc, #524]	; (8000d24 <SystemInit+0x2b4>)
 8000b16:	4a84      	ldr	r2, [pc, #528]	; (8000d28 <SystemInit+0x2b8>)
 8000b18:	605a      	str	r2, [r3, #4]
	   SysTick->VAL   = 0;                                         /* Load the SysTick Counter Value */
 8000b1a:	2200      	movs	r2, #0
 8000b1c:	609a      	str	r2, [r3, #8]
	   SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000b1e:	2205      	movs	r2, #5
 8000b20:	601a      	str	r2, [r3, #0]
	                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */		  
	   do 
	   {
       ;/* wait for ~150ms  */
	   }while((((SCU_PLL->PLLSTAT) & (SCU_PLL_PLLSTAT_PLLHV_Msk | SCU_PLL_PLLSTAT_PLLLV_Msk |SCU_PLL_PLLSTAT_PLLSP_Msk)) != 0x380)&&(SysTick->VAL >= 500)); 
 8000b22:	4a7d      	ldr	r2, [pc, #500]	; (8000d18 <SystemInit+0x2a8>)
 8000b24:	4619      	mov	r1, r3
 8000b26:	6813      	ldr	r3, [r2, #0]
 8000b28:	f403 7360 	and.w	r3, r3, #896	; 0x380
 8000b2c:	f5b3 7f60 	cmp.w	r3, #896	; 0x380
 8000b30:	d003      	beq.n	8000b3a <SystemInit+0xca>
 8000b32:	688b      	ldr	r3, [r1, #8]
 8000b34:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 8000b38:	d2f5      	bcs.n	8000b26 <SystemInit+0xb6>

	   SysTick->CTRL  &= ~SysTick_CTRL_ENABLE_Msk;                 /* Stop SysTick Timer */
 8000b3a:	4a7a      	ldr	r2, [pc, #488]	; (8000d24 <SystemInit+0x2b4>)
 8000b3c:	6813      	ldr	r3, [r2, #0]
 8000b3e:	f023 0301 	bic.w	r3, r3, #1
 8000b42:	6013      	str	r3, [r2, #0]
	   if (((SCU_PLL->PLLSTAT) & (SCU_PLL_PLLSTAT_PLLHV_Msk | SCU_PLL_PLLSTAT_PLLLV_Msk |SCU_PLL_PLLSTAT_PLLSP_Msk)) != 0x380)
 8000b44:	4b74      	ldr	r3, [pc, #464]	; (8000d18 <SystemInit+0x2a8>)
 8000b46:	681b      	ldr	r3, [r3, #0]
 8000b48:	f403 7360 	and.w	r3, r3, #896	; 0x380
 8000b4c:	f5b3 7f60 	cmp.w	r3, #896	; 0x380
 8000b50:	f040 8091 	bne.w	8000c76 <SystemInit+0x206>

	/********************************************************************************************************************/
	/*   Setup and look the main PLL                                                                                    */
	/********************************************************************************************************************/

if (!(SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk)){
 8000b54:	4b70      	ldr	r3, [pc, #448]	; (8000d18 <SystemInit+0x2a8>)
 8000b56:	681b      	ldr	r3, [r3, #0]
 8000b58:	f013 0f04 	tst.w	r3, #4
 8000b5c:	f040 808b 	bne.w	8000c76 <SystemInit+0x206>
	/* Systen is still running from internal clock */
		   /* select FOFI as system clock */
		   if((SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSSEL_Msk) != 0x0)SCU_CLK->SYSCLKCR &= ~SCU_CLK_SYSCLKCR_SYSSEL_Msk; /*Select FOFI*/
 8000b60:	4b6b      	ldr	r3, [pc, #428]	; (8000d10 <SystemInit+0x2a0>)
 8000b62:	68db      	ldr	r3, [r3, #12]
 8000b64:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 8000b68:	d004      	beq.n	8000b74 <SystemInit+0x104>
 8000b6a:	4a69      	ldr	r2, [pc, #420]	; (8000d10 <SystemInit+0x2a0>)
 8000b6c:	68d3      	ldr	r3, [r2, #12]
 8000b6e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8000b72:	60d3      	str	r3, [r2, #12]
			 if ((SCU_PLL_CLOCK_INPUT == SCU_CLOCK_BACK_UP_AUTOMATIC) ||(SCU_PLL_CLOCK_INPUT == SCU_CLOCK_BACK_UP_FACTORY))
					VCO = (CLOCK_BACK_UP/(SCU_PLL_PDIV+1))*(SCU_PLL_NDIV+1);
	 
			 stepping_K2DIV = (VCO/24000000)-1;	
			 /* Go to bypass the Main PLL */
		   SCU_PLL->PLLCON0 |= SCU_PLL_PLLCON0_VCOBYP_Msk;
 8000b74:	4b68      	ldr	r3, [pc, #416]	; (8000d18 <SystemInit+0x2a8>)
 8000b76:	685a      	ldr	r2, [r3, #4]
 8000b78:	f042 0201 	orr.w	r2, r2, #1
 8000b7c:	605a      	str	r2, [r3, #4]
		   /* disconnect OSC_HP to PLL */
		   SCU_PLL->PLLCON0 |= SCU_PLL_PLLCON0_FINDIS_Msk;
 8000b7e:	685a      	ldr	r2, [r3, #4]
 8000b80:	f042 0210 	orr.w	r2, r2, #16
 8000b84:	605a      	str	r2, [r3, #4]
		   /* Setup devider settings for main PLL */
		   SCU_PLL->PLLCON1 = ((SCU_PLL_K1DIV) | (SCU_PLL_NDIV<<8) | (stepping_K2DIV<<16) | (SCU_PLL_PDIV<<24));
 8000b86:	4a69      	ldr	r2, [pc, #420]	; (8000d2c <SystemInit+0x2bc>)
 8000b88:	609a      	str	r2, [r3, #8]
		   /* we may have to set OSCDISCDIS */
		   SCU_PLL->PLLCON0 |= SCU_PLL_PLLCON0_OSCDISCDIS_Msk;
 8000b8a:	685a      	ldr	r2, [r3, #4]
 8000b8c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8000b90:	605a      	str	r2, [r3, #4]
		   /* connect OSC_HP to PLL */
		   SCU_PLL->PLLCON0 &= ~SCU_PLL_PLLCON0_FINDIS_Msk;
 8000b92:	685a      	ldr	r2, [r3, #4]
 8000b94:	f022 0210 	bic.w	r2, r2, #16
 8000b98:	605a      	str	r2, [r3, #4]
		   /* restart PLL Lock detection */
		   SCU_PLL->PLLCON0 |= SCU_PLL_PLLCON0_RESLD_Msk;
 8000b9a:	685a      	ldr	r2, [r3, #4]
 8000b9c:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8000ba0:	605a      	str	r2, [r3, #4]
		   /* wait for PLL Lock */
		   /* setup time out loop */
	       /* Timeout for wait loo ~150ms */
		   /********************************/
		   SysTick->LOAD  = ((5000000+100) & SysTick_LOAD_RELOAD_Msk) - 1;/* set reload register */
 8000ba2:	4b60      	ldr	r3, [pc, #384]	; (8000d24 <SystemInit+0x2b4>)
 8000ba4:	4a60      	ldr	r2, [pc, #384]	; (8000d28 <SystemInit+0x2b8>)
 8000ba6:	605a      	str	r2, [r3, #4]
		   SysTick->VAL   = 0;                                         /* Load the SysTick Counter Value */
 8000ba8:	2200      	movs	r2, #0
 8000baa:	609a      	str	r2, [r3, #8]
		   SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000bac:	2205      	movs	r2, #5
 8000bae:	601a      	str	r2, [r3, #0]
		                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */		  
		   
		   while ((!(SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk))&&(SysTick->VAL >= 500));
 8000bb0:	4a59      	ldr	r2, [pc, #356]	; (8000d18 <SystemInit+0x2a8>)
 8000bb2:	4619      	mov	r1, r3
 8000bb4:	6813      	ldr	r3, [r2, #0]
 8000bb6:	f013 0f04 	tst.w	r3, #4
 8000bba:	d103      	bne.n	8000bc4 <SystemInit+0x154>
 8000bbc:	688b      	ldr	r3, [r1, #8]
 8000bbe:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 8000bc2:	d2f7      	bcs.n	8000bb4 <SystemInit+0x144>
	       SysTick->CTRL  &= ~SysTick_CTRL_ENABLE_Msk;                 /* Stop SysTick Timer */
 8000bc4:	4a57      	ldr	r2, [pc, #348]	; (8000d24 <SystemInit+0x2b4>)
 8000bc6:	6813      	ldr	r3, [r2, #0]
 8000bc8:	f023 0301 	bic.w	r3, r3, #1
 8000bcc:	6013      	str	r3, [r2, #0]

		   if ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk)==SCU_PLL_PLLSTAT_VCOLOCK_Msk)
 8000bce:	4b52      	ldr	r3, [pc, #328]	; (8000d18 <SystemInit+0x2a8>)
 8000bd0:	681b      	ldr	r3, [r3, #0]
 8000bd2:	f013 0f04 	tst.w	r3, #4
 8000bd6:	d04e      	beq.n	8000c76 <SystemInit+0x206>
		   		{
				/* Go back to the Main PLL */
				SCU_PLL->PLLCON0 &= ~SCU_PLL_PLLCON0_VCOBYP_Msk;
 8000bd8:	494f      	ldr	r1, [pc, #316]	; (8000d18 <SystemInit+0x2a8>)
 8000bda:	684b      	ldr	r3, [r1, #4]
 8000bdc:	f023 0301 	bic.w	r3, r3, #1
 8000be0:	604b      	str	r3, [r1, #4]
	
	   /*********************************************************
	   here we need to setup the system clock divider
	   *********************************************************/
	
		SCU_CLK->CPUCLKCR = SCU_CPUCLKCR_DIV;
 8000be2:	4b4b      	ldr	r3, [pc, #300]	; (8000d10 <SystemInit+0x2a0>)
 8000be4:	2200      	movs	r2, #0
 8000be6:	611a      	str	r2, [r3, #16]
		SCU_CLK->PBCLKCR = SCU_PBCLKCR_DIV;	
 8000be8:	615a      	str	r2, [r3, #20]
		SCU_CLK->CCUCLKCR = SCU_CCUCLKCR_DIV;
 8000bea:	621a      	str	r2, [r3, #32]
	

		 /* Switch system clock to PLL */
	   SCU_CLK->SYSCLKCR |=  0x00010000; 
 8000bec:	68d8      	ldr	r0, [r3, #12]
 8000bee:	f440 3080 	orr.w	r0, r0, #65536	; 0x10000
 8000bf2:	60d8      	str	r0, [r3, #12]
				
	   /* we may have to reset OSCDISCDIS */
	   SCU_PLL->PLLCON0 &= ~SCU_PLL_PLLCON0_OSCDISCDIS_Msk;
 8000bf4:	684b      	ldr	r3, [r1, #4]
 8000bf6:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8000bfa:	604b      	str	r3, [r1, #4]
				
																  
		 /*********************************************************/
		 /* Delay for next K2 step ~50�s */
		 /*********************************************************/
		 SysTick->LOAD  = ((1250+100) & SysTick_LOAD_RELOAD_Msk) - 1;/* set reload register */
 8000bfc:	4b49      	ldr	r3, [pc, #292]	; (8000d24 <SystemInit+0x2b4>)
 8000bfe:	f240 5145 	movw	r1, #1349	; 0x545
 8000c02:	6059      	str	r1, [r3, #4]
		 SysTick->VAL   = 0;                                         /* Load the SysTick Counter Value */
 8000c04:	609a      	str	r2, [r3, #8]
		 SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000c06:	2205      	movs	r2, #5
 8000c08:	601a      	str	r2, [r3, #0]
										 SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
	
		 while (SysTick->VAL >= 100);								   /* wait for ~50�s  */
 8000c0a:	461a      	mov	r2, r3
 8000c0c:	6893      	ldr	r3, [r2, #8]
 8000c0e:	2b63      	cmp	r3, #99	; 0x63
 8000c10:	d8fc      	bhi.n	8000c0c <SystemInit+0x19c>
		 SysTick->CTRL  &= ~SysTick_CTRL_ENABLE_Msk;                 /* Stop SysTick Timer */
 8000c12:	4b44      	ldr	r3, [pc, #272]	; (8000d24 <SystemInit+0x2b4>)
 8000c14:	681a      	ldr	r2, [r3, #0]
 8000c16:	f022 0201 	bic.w	r2, r2, #1
 8000c1a:	601a      	str	r2, [r3, #0]
					VCO = (CLOCK_BACK_UP/(SCU_PLL_PDIV+1))*(SCU_PLL_NDIV+1);
	 
			 stepping_K2DIV = (VCO/60000000)-1;	

			 /* Setup devider settings for main PLL */
				SCU_PLL->PLLCON1 = ((SCU_PLL_K1DIV) | (SCU_PLL_NDIV<<8) | (stepping_K2DIV<<16) | (SCU_PLL_PDIV<<24));
 8000c1c:	4944      	ldr	r1, [pc, #272]	; (8000d30 <SystemInit+0x2c0>)
 8000c1e:	4a3e      	ldr	r2, [pc, #248]	; (8000d18 <SystemInit+0x2a8>)
 8000c20:	6091      	str	r1, [r2, #8]
		 }

		 /*********************************************************/
		 /* Delay for next K2 step ~50�s */
		 /*********************************************************/
	   SysTick->LOAD  = ((3000+100) & SysTick_LOAD_RELOAD_Msk) - 1;
 8000c22:	f640 421b 	movw	r2, #3099	; 0xc1b
 8000c26:	605a      	str	r2, [r3, #4]
	   SysTick->VAL   = 0;                                         /* Load the SysTick Counter Value */
 8000c28:	2200      	movs	r2, #0
 8000c2a:	609a      	str	r2, [r3, #8]
	   SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000c2c:	2205      	movs	r2, #5
 8000c2e:	601a      	str	r2, [r3, #0]
	                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
	
	   while (SysTick->VAL >= 100);								   /* wait for ~50�s  */
 8000c30:	461a      	mov	r2, r3
 8000c32:	6893      	ldr	r3, [r2, #8]
 8000c34:	2b63      	cmp	r3, #99	; 0x63
 8000c36:	d8fc      	bhi.n	8000c32 <SystemInit+0x1c2>
	   SysTick->CTRL  &= ~SysTick_CTRL_ENABLE_Msk;                 /* Stop SysTick Timer */
 8000c38:	4b3a      	ldr	r3, [pc, #232]	; (8000d24 <SystemInit+0x2b4>)
 8000c3a:	681a      	ldr	r2, [r3, #0]
 8000c3c:	f022 0201 	bic.w	r2, r2, #1
 8000c40:	601a      	str	r2, [r3, #0]
					VCO = (CLOCK_BACK_UP/(SCU_PLL_PDIV+1))*(SCU_PLL_NDIV+1);

			 stepping_K2DIV = (VCO/90000000)-1;			

			 /* Setup devider settings for main PLL */
				SCU_PLL->PLLCON1 = ((SCU_PLL_K1DIV) | (SCU_PLL_NDIV<<8) | (stepping_K2DIV<<16) | (SCU_PLL_PDIV<<24));
 8000c42:	493c      	ldr	r1, [pc, #240]	; (8000d34 <SystemInit+0x2c4>)
 8000c44:	4a34      	ldr	r2, [pc, #208]	; (8000d18 <SystemInit+0x2a8>)
 8000c46:	6091      	str	r1, [r2, #8]
		 }
	
		 /*********************************************************/
		 /* Delay for next K2 step ~50�s */
		 /*********************************************************/
	   SysTick->LOAD  = ((4800+100) & SysTick_LOAD_RELOAD_Msk) - 1;
 8000c48:	f241 3223 	movw	r2, #4899	; 0x1323
 8000c4c:	605a      	str	r2, [r3, #4]
	   SysTick->VAL   = 0;                                         /* Load the SysTick Counter Value */
 8000c4e:	2200      	movs	r2, #0
 8000c50:	609a      	str	r2, [r3, #8]
	   SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000c52:	2205      	movs	r2, #5
 8000c54:	601a      	str	r2, [r3, #0]
	                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
	
	   while (SysTick->VAL >= 100);								   /* wait for ~50�s  */
 8000c56:	461a      	mov	r2, r3
 8000c58:	6893      	ldr	r3, [r2, #8]
 8000c5a:	2b63      	cmp	r3, #99	; 0x63
 8000c5c:	d8fc      	bhi.n	8000c58 <SystemInit+0x1e8>
	   SysTick->CTRL  &= ~SysTick_CTRL_ENABLE_Msk;                 /* Stop SysTick Timer */
 8000c5e:	4a31      	ldr	r2, [pc, #196]	; (8000d24 <SystemInit+0x2b4>)
 8000c60:	6813      	ldr	r3, [r2, #0]
 8000c62:	f023 0301 	bic.w	r3, r3, #1
 8000c66:	6013      	str	r3, [r2, #0]
	   /********************************/
	
	   /* Setup devider settings for main PLL */
	   SCU_PLL->PLLCON1 = ((SCU_PLL_K1DIV) | (SCU_PLL_NDIV<<8) | (SCU_PLL_K2DIV<<16) | (SCU_PLL_PDIV<<24));
 8000c68:	4a33      	ldr	r2, [pc, #204]	; (8000d38 <SystemInit+0x2c8>)
 8000c6a:	4b2b      	ldr	r3, [pc, #172]	; (8000d18 <SystemInit+0x2a8>)
 8000c6c:	609a      	str	r2, [r3, #8]
	
	   SCU_TRAP->TRAPCLR = SCU_TRAP_TRAPCLR_SOSCWDGT_Msk | SCU_TRAP_TRAPCLR_SVCOLCKT_Msk;  /* clear request for System OCS Watchdog Trap and System VCO Lock Trap  */
 8000c6e:	2205      	movs	r2, #5
 8000c70:	f5a3 63b6 	sub.w	r3, r3, #1456	; 0x5b0
 8000c74:	60da      	str	r2, [r3, #12]
#endif

/*----------------------------------------------------------------------------
  Clock Variable definitions
 *----------------------------------------------------------------------------*/
SystemCoreClockUpdate();/*!< System Clock Frequency (Core Clock)*/
 8000c76:	f7ff febd 	bl	80009f4 <SystemCoreClockUpdate>
  */
#if (SCU_USB_CLOCK_SETUP == 1)
static int USBClockSetup(void)
{
/* this weak function enables DAVE3 clock App usage */	
if(AllowPLLInitByStartup()){
 8000c7a:	f7ff fddb 	bl	8000834 <AllowPLLInitByStartup>
 8000c7e:	2800      	cmp	r0, #0
 8000c80:	f000 8088 	beq.w	8000d94 <SystemInit+0x324>

	/* check if PLL is switched on */
if ((SCU_PLL->USBPLLCON &(SCU_PLL_USBPLLCON_VCOPWD_Msk | SCU_PLL_USBPLLCON_PLLPWD_Msk)) != 0){
 8000c84:	4b24      	ldr	r3, [pc, #144]	; (8000d18 <SystemInit+0x2a8>)
 8000c86:	695a      	ldr	r2, [r3, #20]
 8000c88:	4b24      	ldr	r3, [pc, #144]	; (8000d1c <SystemInit+0x2ac>)
 8000c8a:	4013      	ands	r3, r2
 8000c8c:	b133      	cbz	r3, 8000c9c <SystemInit+0x22c>
	/* enable PLL first */
  SCU_PLL->USBPLLCON &= ~(SCU_PLL_USBPLLCON_VCOPWD_Msk | SCU_PLL_USBPLLCON_PLLPWD_Msk);
 8000c8e:	4a22      	ldr	r2, [pc, #136]	; (8000d18 <SystemInit+0x2a8>)
 8000c90:	6953      	ldr	r3, [r2, #20]
 8000c92:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8000c96:	f023 0302 	bic.w	r3, r3, #2
 8000c9a:	6153      	str	r3, [r2, #20]
}

/* check and if not already running enable OSC_HP */
   if (SCU_OSC->OSCHPCTRL & SCU_OSC_OSCHPCTRL_MODE_Msk){
 8000c9c:	4b20      	ldr	r3, [pc, #128]	; (8000d20 <SystemInit+0x2b0>)
 8000c9e:	685b      	ldr	r3, [r3, #4]
 8000ca0:	f013 0f30 	tst.w	r3, #48	; 0x30
 8000ca4:	d056      	beq.n	8000d54 <SystemInit+0x2e4>
		 /* check if Main PLL is switched on for OSC WD*/
		 if ((SCU_PLL->PLLCON0 &(SCU_PLL_PLLCON0_VCOPWD_Msk | SCU_PLL_PLLCON0_PLLPWD_Msk)) != 0){
 8000ca6:	4b1c      	ldr	r3, [pc, #112]	; (8000d18 <SystemInit+0x2a8>)
 8000ca8:	685a      	ldr	r2, [r3, #4]
 8000caa:	4b1c      	ldr	r3, [pc, #112]	; (8000d1c <SystemInit+0x2ac>)
 8000cac:	4013      	ands	r3, r2
 8000cae:	b133      	cbz	r3, 8000cbe <SystemInit+0x24e>
			/* enable PLL first */
  			SCU_PLL->PLLCON0 &= ~(SCU_PLL_PLLCON0_VCOPWD_Msk | SCU_PLL_PLLCON0_PLLPWD_Msk);
 8000cb0:	4a19      	ldr	r2, [pc, #100]	; (8000d18 <SystemInit+0x2a8>)
 8000cb2:	6853      	ldr	r3, [r2, #4]
 8000cb4:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8000cb8:	f023 0302 	bic.w	r3, r3, #2
 8000cbc:	6053      	str	r3, [r2, #4]
		 }
	   SCU_OSC->OSCHPCTRL &= ~(SCU_OSC_HP_MODE);	 /*enable the OSC_HP*/
 8000cbe:	4b18      	ldr	r3, [pc, #96]	; (8000d20 <SystemInit+0x2b0>)
 8000cc0:	685a      	ldr	r2, [r3, #4]
 8000cc2:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8000cc6:	605a      	str	r2, [r3, #4]
	   /* setup OSC WDG devider */
	   SCU_OSC->OSCHPCTRL |= (SCU_OSCHPWDGDIV<<16);         
 8000cc8:	685a      	ldr	r2, [r3, #4]
 8000cca:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8000cce:	605a      	str	r2, [r3, #4]
	   /* restart OSC Watchdog */
	   SCU_PLL->PLLCON0 &= ~SCU_PLL_PLLCON0_OSCRES_Msk;  
 8000cd0:	4a11      	ldr	r2, [pc, #68]	; (8000d18 <SystemInit+0x2a8>)
 8000cd2:	6853      	ldr	r3, [r2, #4]
 8000cd4:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 8000cd8:	6053      	str	r3, [r2, #4]
	
       /* Timeout for wait loop ~150ms */
	   /********************************/
	   SysTick->LOAD  = ((5000000+100) & SysTick_LOAD_RELOAD_Msk) - 1;/* set reload register */
 8000cda:	4b12      	ldr	r3, [pc, #72]	; (8000d24 <SystemInit+0x2b4>)
 8000cdc:	4a12      	ldr	r2, [pc, #72]	; (8000d28 <SystemInit+0x2b8>)
 8000cde:	605a      	str	r2, [r3, #4]
	   SysTick->VAL   = 0;                                         /* Load the SysTick Counter Value */
 8000ce0:	2200      	movs	r2, #0
 8000ce2:	609a      	str	r2, [r3, #8]
	   SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000ce4:	2205      	movs	r2, #5
 8000ce6:	601a      	str	r2, [r3, #0]
	                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */		  
	   do 
	   {
       ;/* wait for ~150ms  */
	   }while((((SCU_PLL->PLLSTAT) & (SCU_PLL_PLLSTAT_PLLHV_Msk | SCU_PLL_PLLSTAT_PLLLV_Msk |SCU_PLL_PLLSTAT_PLLSP_Msk)) != 0x380)&&(SysTick->VAL >= 500)); 
 8000ce8:	4a0b      	ldr	r2, [pc, #44]	; (8000d18 <SystemInit+0x2a8>)
 8000cea:	4619      	mov	r1, r3
 8000cec:	6813      	ldr	r3, [r2, #0]
 8000cee:	f403 7360 	and.w	r3, r3, #896	; 0x380
 8000cf2:	f5b3 7f60 	cmp.w	r3, #896	; 0x380
 8000cf6:	d021      	beq.n	8000d3c <SystemInit+0x2cc>
 8000cf8:	688b      	ldr	r3, [r1, #8]
 8000cfa:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 8000cfe:	d2f5      	bcs.n	8000cec <SystemInit+0x27c>
 8000d00:	e01c      	b.n	8000d3c <SystemInit+0x2cc>
 8000d02:	bf00      	nop
 8000d04:	e000ed00 	.word	0xe000ed00
 8000d08:	50008000 	.word	0x50008000
 8000d0c:	58001000 	.word	0x58001000
 8000d10:	50004600 	.word	0x50004600
 8000d14:	48028000 	.word	0x48028000
 8000d18:	50004710 	.word	0x50004710
 8000d1c:	00010002 	.word	0x00010002
 8000d20:	50004700 	.word	0x50004700
 8000d24:	e000e010 	.word	0xe000e010
 8000d28:	004c4ba3 	.word	0x004c4ba3
 8000d2c:	01134f01 	.word	0x01134f01
 8000d30:	01074f01 	.word	0x01074f01
 8000d34:	01044f01 	.word	0x01044f01
 8000d38:	01034f01 	.word	0x01034f01

	   SysTick->CTRL  &= ~SysTick_CTRL_ENABLE_Msk;                 /* Stop SysTick Timer */
 8000d3c:	4a16      	ldr	r2, [pc, #88]	; (8000d98 <SystemInit+0x328>)
 8000d3e:	6813      	ldr	r3, [r2, #0]
 8000d40:	f023 0301 	bic.w	r3, r3, #1
 8000d44:	6013      	str	r3, [r2, #0]
	   if (((SCU_PLL->PLLSTAT) & (SCU_PLL_PLLSTAT_PLLHV_Msk | SCU_PLL_PLLSTAT_PLLLV_Msk |SCU_PLL_PLLSTAT_PLLSP_Msk)) != 0x380)
 8000d46:	4b15      	ldr	r3, [pc, #84]	; (8000d9c <SystemInit+0x32c>)
 8000d48:	681b      	ldr	r3, [r3, #0]
 8000d4a:	f403 7360 	and.w	r3, r3, #896	; 0x380
 8000d4e:	f5b3 7f60 	cmp.w	r3, #896	; 0x380
 8000d52:	d11f      	bne.n	8000d94 <SystemInit+0x324>
  }


/* Setup USB PLL */
   /* Go to bypass the Main PLL */
   SCU_PLL->USBPLLCON |= SCU_PLL_USBPLLCON_VCOBYP_Msk;
 8000d54:	4b11      	ldr	r3, [pc, #68]	; (8000d9c <SystemInit+0x32c>)
 8000d56:	695a      	ldr	r2, [r3, #20]
 8000d58:	f042 0201 	orr.w	r2, r2, #1
 8000d5c:	615a      	str	r2, [r3, #20]
   /* disconnect OSC_FI to PLL */
   SCU_PLL->USBPLLCON |= SCU_PLL_USBPLLCON_FINDIS_Msk;
 8000d5e:	695a      	ldr	r2, [r3, #20]
 8000d60:	f042 0210 	orr.w	r2, r2, #16
 8000d64:	615a      	str	r2, [r3, #20]
   /* Setup devider settings for main PLL */
   SCU_PLL->USBPLLCON = ((SCU_USBPLL_NDIV<<8) | (SCU_USBPLL_PDIV<<24));
 8000d66:	f44f 52f8 	mov.w	r2, #7936	; 0x1f00
 8000d6a:	615a      	str	r2, [r3, #20]
   /* Setup USBDIV settings USB clock */
   SCU_CLK->USBCLKCR = SCU_USBDIV;
 8000d6c:	2103      	movs	r1, #3
 8000d6e:	4a0c      	ldr	r2, [pc, #48]	; (8000da0 <SystemInit+0x330>)
 8000d70:	6191      	str	r1, [r2, #24]
   /* we may have to set OSCDISCDIS */
   SCU_PLL->USBPLLCON |= SCU_PLL_USBPLLCON_OSCDISCDIS_Msk;
 8000d72:	695a      	ldr	r2, [r3, #20]
 8000d74:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8000d78:	615a      	str	r2, [r3, #20]
   /* connect OSC_FI to PLL */
   SCU_PLL->USBPLLCON &= ~SCU_PLL_USBPLLCON_FINDIS_Msk;
 8000d7a:	695a      	ldr	r2, [r3, #20]
 8000d7c:	f022 0210 	bic.w	r2, r2, #16
 8000d80:	615a      	str	r2, [r3, #20]
   /* restart PLL Lock detection */
   SCU_PLL->USBPLLCON |= SCU_PLL_USBPLLCON_RESLD_Msk;
 8000d82:	695a      	ldr	r2, [r3, #20]
 8000d84:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8000d88:	615a      	str	r2, [r3, #20]
   /* wait for PLL Lock */
   while (!(SCU_PLL->USBPLLSTAT & SCU_PLL_USBPLLSTAT_VCOLOCK_Msk));
 8000d8a:	461a      	mov	r2, r3
 8000d8c:	6913      	ldr	r3, [r2, #16]
 8000d8e:	f013 0f04 	tst.w	r3, #4
 8000d92:	d0fb      	beq.n	8000d8c <SystemInit+0x31c>
 8000d94:	bd08      	pop	{r3, pc}
 8000d96:	bf00      	nop
 8000d98:	e000e010 	.word	0xe000e010
 8000d9c:	50004710 	.word	0x50004710
 8000da0:	50004600 	.word	0x50004600

08000da4 <XMC_GPIO_Init>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

void XMC_GPIO_Init(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_CONFIG_t *const config)
{
 8000da4:	b4f0      	push	{r4, r5, r6, r7}
 8000da6:	f001 03fc 	and.w	r3, r1, #252	; 0xfc
 8000daa:	4403      	add	r3, r0
  XMC_ASSERT("XMC_GPIO_Init: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_Init: Invalid mode", XMC_GPIO_IsModeValid(config->mode));
 
  /* Switch to input */
  port->IOCR[pin >> 2U] &= (uint32_t)~(PORT_IOCR_PC_Msk << (PORT_IOCR_PC_Size * (pin & 0x3U)));
 8000dac:	691e      	ldr	r6, [r3, #16]
 8000dae:	f001 0403 	and.w	r4, r1, #3
 8000db2:	00e4      	lsls	r4, r4, #3
 8000db4:	25f8      	movs	r5, #248	; 0xf8
 8000db6:	40a5      	lsls	r5, r4
 8000db8:	ea26 0505 	bic.w	r5, r6, r5
 8000dbc:	611d      	str	r5, [r3, #16]

  /* HW port control is disabled */
  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));
 8000dbe:	6f46      	ldr	r6, [r0, #116]	; 0x74
 8000dc0:	004f      	lsls	r7, r1, #1
 8000dc2:	2503      	movs	r5, #3
 8000dc4:	40bd      	lsls	r5, r7
 8000dc6:	ea26 0505 	bic.w	r5, r6, r5
 8000dca:	6745      	str	r5, [r0, #116]	; 0x74


  /* Enable digital input */
  if (XMC_GPIO_CHECK_ANALOG_PORT(port))
 8000dcc:	4d17      	ldr	r5, [pc, #92]	; (8000e2c <XMC_GPIO_Init+0x88>)
 8000dce:	42a8      	cmp	r0, r5
 8000dd0:	d003      	beq.n	8000dda <XMC_GPIO_Init+0x36>
 8000dd2:	f505 7580 	add.w	r5, r5, #256	; 0x100
 8000dd6:	42a8      	cmp	r0, r5
 8000dd8:	d107      	bne.n	8000dea <XMC_GPIO_Init+0x46>
  {
    port->PDISC &= ~(uint32_t)((uint32_t)0x1U << pin);
 8000dda:	6e05      	ldr	r5, [r0, #96]	; 0x60
 8000ddc:	2601      	movs	r6, #1
 8000dde:	fa06 f101 	lsl.w	r1, r6, r1
 8000de2:	ea25 0101 	bic.w	r1, r5, r1
 8000de6:	6601      	str	r1, [r0, #96]	; 0x60
 8000de8:	e018      	b.n	8000e1c <XMC_GPIO_Init+0x78>
  }
  else
  {
    if ((config->mode & XMC_GPIO_MODE_OE) != 0)
 8000dea:	f992 5000 	ldrsb.w	r5, [r2]
 8000dee:	2d00      	cmp	r5, #0
 8000df0:	da14      	bge.n	8000e1c <XMC_GPIO_Init+0x78>
    {
      /* If output is enabled */

      /* Set output level */
      port->OMR = (uint32_t)config->output_level << pin;
 8000df2:	6855      	ldr	r5, [r2, #4]
 8000df4:	408d      	lsls	r5, r1
 8000df6:	6045      	str	r5, [r0, #4]
 8000df8:	08cd      	lsrs	r5, r1, #3
 8000dfa:	eb00 0085 	add.w	r0, r0, r5, lsl #2

      /* Set output driver strength */
      port->PDR[pin >> 3U] &= (uint32_t)~(PORT_PDR_Msk << ((uint32_t)PORT_PDR_Size * ((uint32_t)pin & 0x7U)));
 8000dfe:	6c06      	ldr	r6, [r0, #64]	; 0x40
 8000e00:	f001 0107 	and.w	r1, r1, #7
 8000e04:	0089      	lsls	r1, r1, #2
 8000e06:	2507      	movs	r5, #7
 8000e08:	408d      	lsls	r5, r1
 8000e0a:	ea26 0505 	bic.w	r5, r6, r5
 8000e0e:	6405      	str	r5, [r0, #64]	; 0x40
      port->PDR[pin >> 3U] |= (uint32_t)config->output_strength << ((uint32_t)PORT_PDR_Size * ((uint32_t)pin & 0x7U));
 8000e10:	6c05      	ldr	r5, [r0, #64]	; 0x40
 8000e12:	7a16      	ldrb	r6, [r2, #8]
 8000e14:	fa06 f101 	lsl.w	r1, r6, r1
 8000e18:	4329      	orrs	r1, r5
 8000e1a:	6401      	str	r1, [r0, #64]	; 0x40
    }
  }

  /* Set mode */
  port->IOCR[pin >> 2U] |= (uint32_t)config->mode << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U));
 8000e1c:	6919      	ldr	r1, [r3, #16]
 8000e1e:	7812      	ldrb	r2, [r2, #0]
 8000e20:	40a2      	lsls	r2, r4
 8000e22:	430a      	orrs	r2, r1
 8000e24:	611a      	str	r2, [r3, #16]
}
 8000e26:	bcf0      	pop	{r4, r5, r6, r7}
 8000e28:	4770      	bx	lr
 8000e2a:	bf00      	nop
 8000e2c:	48028e00 	.word	0x48028e00

08000e30 <XMC_RTC_Enable>:

/*
 * Enables RTC peripheral for programming its registers
 */
void XMC_RTC_Enable(void)
{
 8000e30:	b508      	push	{r3, lr}
  XMC_SCU_HIB_EnableHibernateDomain();
 8000e32:	f000 f8f9 	bl	8001028 <XMC_SCU_HIB_EnableHibernateDomain>
 8000e36:	bd08      	pop	{r3, pc}

08000e38 <XMC_RTC_Disable>:

/*
 * Disables RTC peripheral for programming its registers
 */
void XMC_RTC_Disable(void)
{
 8000e38:	4770      	bx	lr
 8000e3a:	bf00      	nop

08000e3c <XMC_RTC_Init>:
 * \par<b>Related APIs:</b><br>
 * XMC_RTC_Start(), XMC_RTC_Stop()
 */ 
__STATIC_INLINE bool XMC_RTC_IsRunning(void)
{
  return (bool)(RTC->CTR & RTC_CTR_ENB_Msk);
 8000e3c:	4b1b      	ldr	r3, [pc, #108]	; (8000eac <XMC_RTC_Init+0x70>)
 8000e3e:	685b      	ldr	r3, [r3, #4]
/*
 * Initialize the RTC peripheral
 */
XMC_RTC_STATUS_t XMC_RTC_Init(const XMC_RTC_CONFIG_t *const config)
{
  if (XMC_RTC_IsRunning() == false)
 8000e40:	f013 0f01 	tst.w	r3, #1
 8000e44:	d12f      	bne.n	8000ea6 <XMC_RTC_Init+0x6a>

/*
 * Initialize the RTC peripheral
 */
XMC_RTC_STATUS_t XMC_RTC_Init(const XMC_RTC_CONFIG_t *const config)
{
 8000e46:	b510      	push	{r4, lr}
 8000e48:	4604      	mov	r4, r0
  if (XMC_RTC_IsRunning() == false)
  {
    if (XMC_SCU_HIB_IsHibernateDomainEnabled() == false)
 8000e4a:	f000 f90d 	bl	8001068 <XMC_SCU_HIB_IsHibernateDomainEnabled>
 8000e4e:	b908      	cbnz	r0, 8000e54 <XMC_RTC_Init+0x18>
    {
      XMC_SCU_HIB_EnableHibernateDomain();
 8000e50:	f000 f8ea 	bl	8001028 <XMC_SCU_HIB_EnableHibernateDomain>
    }
    
    XMC_RTC_SetPrescaler(config->prescaler);
 8000e54:	8a20      	ldrh	r0, [r4, #16]
 8000e56:	f000 fd33 	bl	80018c0 <XMC_RTC_SetPrescaler>
 * is busy with executing the previous operation.\n
 * Note: There is no hibernate domain in XMC1x devices. This register is retained for legacy purpose.
 */
__STATIC_INLINE uint32_t XMC_SCU_GetMirrorStatus(void)
{
  return(SCU_GENERAL->MIRRSTS);
 8000e5a:	4a15      	ldr	r2, [pc, #84]	; (8000eb0 <XMC_RTC_Init+0x74>)
 8000e5c:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
    
    while ((XMC_SCU_GetMirrorStatus() & SCU_GENERAL_MIRRSTS_RTC_TIM0_Msk) != 0U)
 8000e60:	f413 6f00 	tst.w	r3, #2048	; 0x800
 8000e64:	d1fa      	bne.n	8000e5c <XMC_RTC_Init+0x20>
    {
      /* check SCU_MIRRSTS to ensure that no transfer over serial interface is pending */
    }
    RTC->TIM0 = config->time.raw0;
 8000e66:	6822      	ldr	r2, [r4, #0]
 8000e68:	4b10      	ldr	r3, [pc, #64]	; (8000eac <XMC_RTC_Init+0x70>)
 8000e6a:	621a      	str	r2, [r3, #32]
 8000e6c:	4a10      	ldr	r2, [pc, #64]	; (8000eb0 <XMC_RTC_Init+0x74>)
 8000e6e:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
    
    while ((XMC_SCU_GetMirrorStatus() & SCU_GENERAL_MIRRSTS_RTC_TIM1_Msk) != 0U)
 8000e72:	f413 5f80 	tst.w	r3, #4096	; 0x1000
 8000e76:	d1fa      	bne.n	8000e6e <XMC_RTC_Init+0x32>
    {
      /* check SCU_MIRRSTS to ensure that no transfer over serial interface is pending */
    }
    RTC->TIM1 = config->time.raw1;
 8000e78:	6862      	ldr	r2, [r4, #4]
 8000e7a:	4b0c      	ldr	r3, [pc, #48]	; (8000eac <XMC_RTC_Init+0x70>)
 8000e7c:	625a      	str	r2, [r3, #36]	; 0x24
 8000e7e:	4a0c      	ldr	r2, [pc, #48]	; (8000eb0 <XMC_RTC_Init+0x74>)
 8000e80:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
    
    while ((XMC_SCU_GetMirrorStatus() & SCU_GENERAL_MIRRSTS_RTC_ATIM0_Msk) != 0U)
 8000e84:	f413 7f00 	tst.w	r3, #512	; 0x200
 8000e88:	d1fa      	bne.n	8000e80 <XMC_RTC_Init+0x44>
    {
      /* check SCU_MIRRSTS to ensure that no transfer over serial interface is pending */
    }
    RTC->ATIM0 = config->alarm.raw0;
 8000e8a:	68a2      	ldr	r2, [r4, #8]
 8000e8c:	4b07      	ldr	r3, [pc, #28]	; (8000eac <XMC_RTC_Init+0x70>)
 8000e8e:	619a      	str	r2, [r3, #24]
 8000e90:	4a07      	ldr	r2, [pc, #28]	; (8000eb0 <XMC_RTC_Init+0x74>)
 8000e92:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
    
    while ((XMC_SCU_GetMirrorStatus() & SCU_GENERAL_MIRRSTS_RTC_ATIM1_Msk) != 0U)
 8000e96:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8000e9a:	d1fa      	bne.n	8000e92 <XMC_RTC_Init+0x56>
    {
      /* check SCU_MIRRSTS to ensure that no transfer over serial interface is pending */
    }
    RTC->ATIM1 = config->alarm.raw1;    
 8000e9c:	68e2      	ldr	r2, [r4, #12]
 8000e9e:	4b03      	ldr	r3, [pc, #12]	; (8000eac <XMC_RTC_Init+0x70>)
 8000ea0:	61da      	str	r2, [r3, #28]
  }  
  return XMC_RTC_STATUS_OK;
}
 8000ea2:	2000      	movs	r0, #0
 8000ea4:	bd10      	pop	{r4, pc}
 8000ea6:	2000      	movs	r0, #0
 8000ea8:	4770      	bx	lr
 8000eaa:	bf00      	nop
 8000eac:	50004a00 	.word	0x50004a00
 8000eb0:	50004000 	.word	0x50004000

08000eb4 <XMC_RTC_EnableEvent>:
 8000eb4:	4a05      	ldr	r2, [pc, #20]	; (8000ecc <XMC_RTC_EnableEvent+0x18>)
 8000eb6:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
/*
 * Enable RTC periodic and alarm event(s)
 */ 
void XMC_RTC_EnableEvent(const uint32_t event)
{
  while ((XMC_SCU_GetMirrorStatus() & SCU_GENERAL_MIRRSTS_RTC_MSKSR_Msk) != 0U)
 8000eba:	f413 4f80 	tst.w	r3, #16384	; 0x4000
 8000ebe:	d1fa      	bne.n	8000eb6 <XMC_RTC_EnableEvent+0x2>
  {
    /* check SCU_MIRRSTS to ensure that no transfer over serial interface is pending */
  }
  RTC->MSKSR |= event;
 8000ec0:	4a03      	ldr	r2, [pc, #12]	; (8000ed0 <XMC_RTC_EnableEvent+0x1c>)
 8000ec2:	6913      	ldr	r3, [r2, #16]
 8000ec4:	4318      	orrs	r0, r3
 8000ec6:	6110      	str	r0, [r2, #16]
 8000ec8:	4770      	bx	lr
 8000eca:	bf00      	nop
 8000ecc:	50004000 	.word	0x50004000
 8000ed0:	50004a00 	.word	0x50004a00

08000ed4 <XMC_RTC_EnableHibernationWakeUp>:
 8000ed4:	4a05      	ldr	r2, [pc, #20]	; (8000eec <XMC_RTC_EnableHibernationWakeUp+0x18>)
 8000ed6:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
  RTC->CLRSR = event;
}

void XMC_RTC_EnableHibernationWakeUp(const uint32_t event)
{
  while((XMC_SCU_GetMirrorStatus() & SCU_GENERAL_MIRRSTS_RTC_CTR_Msk) != 0U)
 8000eda:	f413 7f80 	tst.w	r3, #256	; 0x100
 8000ede:	d1fa      	bne.n	8000ed6 <XMC_RTC_EnableHibernationWakeUp+0x2>
  {
    /* check SCU_MIRRSTS to ensure that no transfer over serial interface is pending */
  }
  RTC->CTR |= event;
 8000ee0:	4a03      	ldr	r2, [pc, #12]	; (8000ef0 <XMC_RTC_EnableHibernationWakeUp+0x1c>)
 8000ee2:	6853      	ldr	r3, [r2, #4]
 8000ee4:	4318      	orrs	r0, r3
 8000ee6:	6050      	str	r0, [r2, #4]
 8000ee8:	4770      	bx	lr
 8000eea:	bf00      	nop
 8000eec:	50004000 	.word	0x50004000
 8000ef0:	50004a00 	.word	0x50004a00

08000ef4 <XMC_SCU_INTERRUPT_EnableEvent>:
}

/* API to enable the SCU event */
void XMC_SCU_INTERRUPT_EnableEvent(const XMC_SCU_INTERRUPT_EVENT_t event)
{
  SCU_INTERRUPT->SRMSK |= (uint32_t)event;
 8000ef4:	4a02      	ldr	r2, [pc, #8]	; (8000f00 <XMC_SCU_INTERRUPT_EnableEvent+0xc>)
 8000ef6:	6893      	ldr	r3, [r2, #8]
 8000ef8:	4318      	orrs	r0, r3
 8000efa:	6090      	str	r0, [r2, #8]
 8000efc:	4770      	bx	lr
 8000efe:	bf00      	nop
 8000f00:	50004074 	.word	0x50004074

08000f04 <XMC_SCU_INTERUPT_GetEventStatus>:
}

/* API to retrieve the SCU event status */
XMC_SCU_INTERRUPT_EVENT_t XMC_SCU_INTERUPT_GetEventStatus(void)
{
  return (SCU_INTERRUPT->SRRAW);
 8000f04:	4b01      	ldr	r3, [pc, #4]	; (8000f0c <XMC_SCU_INTERUPT_GetEventStatus+0x8>)
 8000f06:	6858      	ldr	r0, [r3, #4]
}
 8000f08:	4770      	bx	lr
 8000f0a:	bf00      	nop
 8000f0c:	50004074 	.word	0x50004074

08000f10 <XMC_SCU_INTERRUPT_ClearEventStatus>:

/* API to clear the SCU event status */
void XMC_SCU_INTERRUPT_ClearEventStatus(const XMC_SCU_INTERRUPT_EVENT_t event)
{
  SCU_INTERRUPT->SRCLR = (uint32_t)event;
 8000f10:	4b01      	ldr	r3, [pc, #4]	; (8000f18 <XMC_SCU_INTERRUPT_ClearEventStatus+0x8>)
 8000f12:	60d8      	str	r0, [r3, #12]
 8000f14:	4770      	bx	lr
 8000f16:	bf00      	nop
 8000f18:	50004074 	.word	0x50004074

08000f1c <XMC_SCU_GetBootMode>:


/* API to retrieve the currently deployed device bootmode */
uint32_t XMC_SCU_GetBootMode(void)
{
  return (uint32_t)(SCU_GENERAL->STCON & SCU_GENERAL_STCON_SWCON_Msk);
 8000f1c:	4b02      	ldr	r3, [pc, #8]	; (8000f28 <XMC_SCU_GetBootMode+0xc>)
 8000f1e:	6918      	ldr	r0, [r3, #16]
}
 8000f20:	f400 6070 	and.w	r0, r0, #3840	; 0xf00
 8000f24:	4770      	bx	lr
 8000f26:	bf00      	nop
 8000f28:	50004000 	.word	0x50004000

08000f2c <XMC_SCU_TRAP_Enable>:
}

/* API to enable a trap source */
void XMC_SCU_TRAP_Enable(const uint32_t trap)
{
  SCU_TRAP->TRAPDIS &= (uint32_t)~trap;
 8000f2c:	4a02      	ldr	r2, [pc, #8]	; (8000f38 <XMC_SCU_TRAP_Enable+0xc>)
 8000f2e:	6893      	ldr	r3, [r2, #8]
 8000f30:	ea23 0000 	bic.w	r0, r3, r0
 8000f34:	6090      	str	r0, [r2, #8]
 8000f36:	4770      	bx	lr
 8000f38:	50004160 	.word	0x50004160

08000f3c <XMC_SCU_TRAP_GetStatus>:
}

/* API to determine if a trap source has generated event */
uint32_t XMC_SCU_TRAP_GetStatus(void)
{
  return (SCU_TRAP->TRAPRAW);
 8000f3c:	4b01      	ldr	r3, [pc, #4]	; (8000f44 <XMC_SCU_TRAP_GetStatus+0x8>)
 8000f3e:	6858      	ldr	r0, [r3, #4]
}
 8000f40:	4770      	bx	lr
 8000f42:	bf00      	nop
 8000f44:	50004160 	.word	0x50004160

08000f48 <XMC_SCU_TRAP_ClearStatus>:
}

/* API to clear a trap event */
void XMC_SCU_TRAP_ClearStatus(const uint32_t trap)
{
  SCU_TRAP->TRAPCLR = (uint32_t)trap;
 8000f48:	4b01      	ldr	r3, [pc, #4]	; (8000f50 <XMC_SCU_TRAP_ClearStatus+0x8>)
 8000f4a:	60d8      	str	r0, [r3, #12]
 8000f4c:	4770      	bx	lr
 8000f4e:	bf00      	nop
 8000f50:	50004160 	.word	0x50004160

08000f54 <XMC_SCU_INTERRUPT_EnableNmiRequest>:
}

/* Enables a NMI source */
void XMC_SCU_INTERRUPT_EnableNmiRequest(const uint32_t request)
{
  SCU_INTERRUPT->NMIREQEN |= (uint32_t)request;
 8000f54:	4a02      	ldr	r2, [pc, #8]	; (8000f60 <XMC_SCU_INTERRUPT_EnableNmiRequest+0xc>)
 8000f56:	6953      	ldr	r3, [r2, #20]
 8000f58:	4318      	orrs	r0, r3
 8000f5a:	6150      	str	r0, [r2, #20]
 8000f5c:	4770      	bx	lr
 8000f5e:	bf00      	nop
 8000f60:	50004074 	.word	0x50004074

08000f64 <XMC_SCU_RESET_AssertPeripheralReset>:
}

/* API to manually assert a reset request */
void XMC_SCU_RESET_AssertPeripheralReset(const XMC_SCU_PERIPHERAL_RESET_t peripheral)
{
  uint32_t index = (uint32_t)((((uint32_t)peripheral) & 0xf0000000UL) >> 28UL);
 8000f64:	0f03      	lsrs	r3, r0, #28
  uint32_t mask = (((uint32_t)peripheral) & ((uint32_t)~0xf0000000UL));

  *(uint32_t *)(&(SCU_RESET->PRSET0) + (index * 3U)) = (uint32_t)mask;
 8000f66:	eb03 0343 	add.w	r3, r3, r3, lsl #1

/* API to manually assert a reset request */
void XMC_SCU_RESET_AssertPeripheralReset(const XMC_SCU_PERIPHERAL_RESET_t peripheral)
{
  uint32_t index = (uint32_t)((((uint32_t)peripheral) & 0xf0000000UL) >> 28UL);
  uint32_t mask = (((uint32_t)peripheral) & ((uint32_t)~0xf0000000UL));
 8000f6a:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000

  *(uint32_t *)(&(SCU_RESET->PRSET0) + (index * 3U)) = (uint32_t)mask;
 8000f6e:	4a02      	ldr	r2, [pc, #8]	; (8000f78 <XMC_SCU_RESET_AssertPeripheralReset+0x14>)
 8000f70:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
 8000f74:	4770      	bx	lr
 8000f76:	bf00      	nop
 8000f78:	50004410 	.word	0x50004410

08000f7c <XMC_SCU_RESET_DeassertPeripheralReset>:
}

/* API to manually de-assert a reset request */
void XMC_SCU_RESET_DeassertPeripheralReset(const XMC_SCU_PERIPHERAL_RESET_t peripheral)
{
  uint32_t index = (uint32_t)((((uint32_t)peripheral) & 0xf0000000UL) >> 28UL);
 8000f7c:	0f03      	lsrs	r3, r0, #28
  uint32_t mask = (((uint32_t)peripheral) & ((uint32_t)~0xf0000000UL));

  *(uint32_t *)(&(SCU_RESET->PRCLR0) + (index * 3U)) = (uint32_t)mask;
 8000f7e:	eb03 0343 	add.w	r3, r3, r3, lsl #1

/* API to manually de-assert a reset request */
void XMC_SCU_RESET_DeassertPeripheralReset(const XMC_SCU_PERIPHERAL_RESET_t peripheral)
{
  uint32_t index = (uint32_t)((((uint32_t)peripheral) & 0xf0000000UL) >> 28UL);
  uint32_t mask = (((uint32_t)peripheral) & ((uint32_t)~0xf0000000UL));
 8000f82:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000

  *(uint32_t *)(&(SCU_RESET->PRCLR0) + (index * 3U)) = (uint32_t)mask;
 8000f86:	4a02      	ldr	r2, [pc, #8]	; (8000f90 <XMC_SCU_RESET_DeassertPeripheralReset+0x14>)
 8000f88:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
 8000f8c:	4770      	bx	lr
 8000f8e:	bf00      	nop
 8000f90:	50004414 	.word	0x50004414

08000f94 <XMC_SCU_CLOCK_GetPeripheralClockFrequency>:
 * API to retrieve clock frequency of peripherals on the peripheral bus using a shared functional clock
 */
uint32_t XMC_SCU_CLOCK_GetPeripheralClockFrequency(void)
{
  return (uint32_t)(XMC_SCU_CLOCK_GetCpuClockFrequency() >>
         ((SCU_CLK->PBCLKCR & SCU_CLK_PBCLKCR_PBDIV_Msk) >> SCU_CLK_PBCLKCR_PBDIV_Pos));  
 8000f94:	4b03      	ldr	r3, [pc, #12]	; (8000fa4 <XMC_SCU_CLOCK_GetPeripheralClockFrequency+0x10>)
 8000f96:	695b      	ldr	r3, [r3, #20]
/*
 * API to retrieve clock frequency of peripherals on the peripheral bus using a shared functional clock
 */
uint32_t XMC_SCU_CLOCK_GetPeripheralClockFrequency(void)
{
  return (uint32_t)(XMC_SCU_CLOCK_GetCpuClockFrequency() >>
 8000f98:	f003 0301 	and.w	r3, r3, #1
 8000f9c:	4a02      	ldr	r2, [pc, #8]	; (8000fa8 <XMC_SCU_CLOCK_GetPeripheralClockFrequency+0x14>)
 8000f9e:	6810      	ldr	r0, [r2, #0]
         ((SCU_CLK->PBCLKCR & SCU_CLK_PBCLKCR_PBDIV_Msk) >> SCU_CLK_PBCLKCR_PBDIV_Pos));  
}
 8000fa0:	40d8      	lsrs	r0, r3
 8000fa2:	4770      	bx	lr
 8000fa4:	50004600 	.word	0x50004600
 8000fa8:	2000d570 	.word	0x2000d570

08000fac <XMC_SCU_CLOCK_SetWdtClockSource>:
}

/* API to select fWDT */
void XMC_SCU_CLOCK_SetWdtClockSource(const XMC_SCU_CLOCK_WDTCLKSRC_t source)
{
  SCU_CLK->WDTCLKCR = (SCU_CLK->WDTCLKCR & ((uint32_t)~SCU_CLK_WDTCLKCR_WDTSEL_Msk)) |
 8000fac:	4a03      	ldr	r2, [pc, #12]	; (8000fbc <XMC_SCU_CLOCK_SetWdtClockSource+0x10>)
 8000fae:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8000fb0:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
 8000fb4:	4318      	orrs	r0, r3
 8000fb6:	6250      	str	r0, [r2, #36]	; 0x24
 8000fb8:	4770      	bx	lr
 8000fba:	bf00      	nop
 8000fbc:	50004600 	.word	0x50004600

08000fc0 <XMC_SCU_HIB_SetRtcClockSource>:

/* API to select fRTC */
void XMC_SCU_HIB_SetRtcClockSource(const XMC_SCU_HIB_RTCCLKSRC_t source)
{ 
  /* Wait until the update of HDCR register in hibernate domain is completed */
  while((SCU_GENERAL->MIRRSTS) & SCU_GENERAL_MIRRSTS_HDCR_Msk)
 8000fc0:	4a06      	ldr	r2, [pc, #24]	; (8000fdc <XMC_SCU_HIB_SetRtcClockSource+0x1c>)
 8000fc2:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
 8000fc6:	f013 0f08 	tst.w	r3, #8
 8000fca:	d1fa      	bne.n	8000fc2 <XMC_SCU_HIB_SetRtcClockSource+0x2>
  {
  }

  SCU_HIBERNATE->HDCR = (SCU_HIBERNATE->HDCR & ((uint32_t)~SCU_HIBERNATE_HDCR_RCS_Msk)) |
 8000fcc:	4a04      	ldr	r2, [pc, #16]	; (8000fe0 <XMC_SCU_HIB_SetRtcClockSource+0x20>)
 8000fce:	68d3      	ldr	r3, [r2, #12]
 8000fd0:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8000fd4:	4318      	orrs	r0, r3
 8000fd6:	60d0      	str	r0, [r2, #12]
 8000fd8:	4770      	bx	lr
 8000fda:	bf00      	nop
 8000fdc:	50004000 	.word	0x50004000
 8000fe0:	50004300 	.word	0x50004300

08000fe4 <XMC_SCU_CLOCK_SetWdtClockDivider>:
void XMC_SCU_CLOCK_SetWdtClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetWdtClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_WDTCLKCR_WDTDIV_Msk + 1UL) ) );

  SCU_CLK->WDTCLKCR = (SCU_CLK->WDTCLKCR & ((uint32_t)~SCU_CLK_WDTCLKCR_WDTDIV_Msk)) |
 8000fe4:	4a03      	ldr	r2, [pc, #12]	; (8000ff4 <XMC_SCU_CLOCK_SetWdtClockDivider+0x10>)
 8000fe6:	6a53      	ldr	r3, [r2, #36]	; 0x24
                      (uint32_t)(((uint32_t)(divider - 1UL)) << SCU_CLK_WDTCLKCR_WDTDIV_Pos);
 8000fe8:	3801      	subs	r0, #1
void XMC_SCU_CLOCK_SetWdtClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetWdtClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_WDTCLKCR_WDTDIV_Msk + 1UL) ) );

  SCU_CLK->WDTCLKCR = (SCU_CLK->WDTCLKCR & ((uint32_t)~SCU_CLK_WDTCLKCR_WDTDIV_Msk)) |
 8000fea:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 8000fee:	4303      	orrs	r3, r0
 8000ff0:	6253      	str	r3, [r2, #36]	; 0x24
 8000ff2:	4770      	bx	lr
 8000ff4:	50004600 	.word	0x50004600

08000ff8 <XMC_SCU_CLOCK_EnableClock>:
#endif

/* API to enable a given module clock */
void XMC_SCU_CLOCK_EnableClock(const XMC_SCU_CLOCK_t clock)
{
  SCU_CLK->CLKSET = ((uint32_t)clock);
 8000ff8:	4b01      	ldr	r3, [pc, #4]	; (8001000 <XMC_SCU_CLOCK_EnableClock+0x8>)
 8000ffa:	6058      	str	r0, [r3, #4]
 8000ffc:	4770      	bx	lr
 8000ffe:	bf00      	nop
 8001000:	50004600 	.word	0x50004600

08001004 <XMC_SCU_POWER_GetEVR33Voltage>:
  return (SCU_POWER->EVRVADCSTAT & SCU_POWER_EVRVADCSTAT_VADC13V_Msk) * XMC_SCU_POWER_LSB13V;
}

float XMC_SCU_POWER_GetEVR33Voltage(void)
{
  return ((SCU_POWER->EVRVADCSTAT & SCU_POWER_EVRVADCSTAT_VADC33V_Msk) >> SCU_POWER_EVRVADCSTAT_VADC33V_Pos) * XMC_SCU_POWER_LSB33V;
 8001004:	4b06      	ldr	r3, [pc, #24]	; (8001020 <XMC_SCU_POWER_GetEVR33Voltage+0x1c>)
 8001006:	695b      	ldr	r3, [r3, #20]
 8001008:	f3c3 2307 	ubfx	r3, r3, #8, #8
 800100c:	ee00 3a10 	vmov	s0, r3
 8001010:	eeb8 0a40 	vcvt.f32.u32	s0, s0
}
 8001014:	eddf 7a03 	vldr	s15, [pc, #12]	; 8001024 <XMC_SCU_POWER_GetEVR33Voltage+0x20>
 8001018:	ee20 0a27 	vmul.f32	s0, s0, s15
 800101c:	4770      	bx	lr
 800101e:	bf00      	nop
 8001020:	50004200 	.word	0x50004200
 8001024:	3cb851ec 	.word	0x3cb851ec

08001028 <XMC_SCU_HIB_EnableHibernateDomain>:

/* API to power up the hibernation domain */
void XMC_SCU_HIB_EnableHibernateDomain(void)
{
  /* Power up HIB domain if and only if it is currently powered down */
  if((SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) == 0UL)
 8001028:	4b0d      	ldr	r3, [pc, #52]	; (8001060 <XMC_SCU_HIB_EnableHibernateDomain+0x38>)
 800102a:	681b      	ldr	r3, [r3, #0]
 800102c:	f013 0f01 	tst.w	r3, #1
 8001030:	d107      	bne.n	8001042 <XMC_SCU_HIB_EnableHibernateDomain+0x1a>
  {
    SCU_POWER->PWRSET = (uint32_t)SCU_POWER_PWRSET_HIB_Msk;
 8001032:	2201      	movs	r2, #1
 8001034:	4b0a      	ldr	r3, [pc, #40]	; (8001060 <XMC_SCU_HIB_EnableHibernateDomain+0x38>)
 8001036:	605a      	str	r2, [r3, #4]
    
    while((SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) == 0UL)
 8001038:	461a      	mov	r2, r3
 800103a:	6813      	ldr	r3, [r2, #0]
 800103c:	f013 0f01 	tst.w	r3, #1
 8001040:	d0fb      	beq.n	800103a <XMC_SCU_HIB_EnableHibernateDomain+0x12>
      /* wait until HIB domain is enabled */
    }    
  }
  
  /* Remove the reset only if HIB domain were in a state of reset */
  if((SCU_RESET->RSTSTAT) & SCU_RESET_RSTSTAT_HIBRS_Msk)
 8001042:	4b08      	ldr	r3, [pc, #32]	; (8001064 <XMC_SCU_HIB_EnableHibernateDomain+0x3c>)
 8001044:	681b      	ldr	r3, [r3, #0]
 8001046:	f413 7f00 	tst.w	r3, #512	; 0x200
 800104a:	d008      	beq.n	800105e <XMC_SCU_HIB_EnableHibernateDomain+0x36>
  {
    SCU_RESET->RSTCLR = (uint32_t)SCU_RESET_RSTCLR_HIBRS_Msk;
 800104c:	f44f 7200 	mov.w	r2, #512	; 0x200
 8001050:	4b04      	ldr	r3, [pc, #16]	; (8001064 <XMC_SCU_HIB_EnableHibernateDomain+0x3c>)
 8001052:	609a      	str	r2, [r3, #8]
    while((SCU_RESET->RSTSTAT & SCU_RESET_RSTSTAT_HIBRS_Msk) != 0UL)
 8001054:	461a      	mov	r2, r3
 8001056:	6813      	ldr	r3, [r2, #0]
 8001058:	f413 7f00 	tst.w	r3, #512	; 0x200
 800105c:	d1fb      	bne.n	8001056 <XMC_SCU_HIB_EnableHibernateDomain+0x2e>
 800105e:	4770      	bx	lr
 8001060:	50004200 	.word	0x50004200
 8001064:	50004400 	.word	0x50004400

08001068 <XMC_SCU_HIB_IsHibernateDomainEnabled>:
}

/* API to check the hibernation domain is enabled or not */
bool XMC_SCU_HIB_IsHibernateDomainEnabled(void)
{
  return ((bool)(SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) && 
 8001068:	4b06      	ldr	r3, [pc, #24]	; (8001084 <XMC_SCU_HIB_IsHibernateDomainEnabled+0x1c>)
 800106a:	681b      	ldr	r3, [r3, #0]
 800106c:	f013 0f01 	tst.w	r3, #1
 8001070:	d006      	beq.n	8001080 <XMC_SCU_HIB_IsHibernateDomainEnabled+0x18>
          !(bool)(SCU_RESET->RSTSTAT & SCU_RESET_RSTSTAT_HIBRS_Msk));
 8001072:	4b05      	ldr	r3, [pc, #20]	; (8001088 <XMC_SCU_HIB_IsHibernateDomainEnabled+0x20>)
 8001074:	6818      	ldr	r0, [r3, #0]
}

/* API to check the hibernation domain is enabled or not */
bool XMC_SCU_HIB_IsHibernateDomainEnabled(void)
{
  return ((bool)(SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) && 
 8001076:	f480 7000 	eor.w	r0, r0, #512	; 0x200
 800107a:	f3c0 2040 	ubfx	r0, r0, #9, #1
 800107e:	4770      	bx	lr
 8001080:	2000      	movs	r0, #0
          !(bool)(SCU_RESET->RSTSTAT & SCU_RESET_RSTSTAT_HIBRS_Msk));
}
 8001082:	4770      	bx	lr
 8001084:	50004200 	.word	0x50004200
 8001088:	50004400 	.word	0x50004400

0800108c <XMC_SCU_INTERRUPT_SetEventHandler>:
{
  uint32_t index;
  XMC_SCU_STATUS_t status;
  
  index = 0U;
  while (((event & ((XMC_SCU_INTERRUPT_EVENT_t)1 << index)) == 0U) && (index < XMC_SCU_INTERRUPT_EVENT_MAX))
 800108c:	f010 0f01 	tst.w	r0, #1
 8001090:	d10d      	bne.n	80010ae <XMC_SCU_INTERRUPT_SetEventHandler+0x22>
 8001092:	2300      	movs	r3, #0
  {
    index++;
 8001094:	3301      	adds	r3, #1
{
  uint32_t index;
  XMC_SCU_STATUS_t status;
  
  index = 0U;
  while (((event & ((XMC_SCU_INTERRUPT_EVENT_t)1 << index)) == 0U) && (index < XMC_SCU_INTERRUPT_EVENT_MAX))
 8001096:	fa20 f203 	lsr.w	r2, r0, r3
 800109a:	f012 0f01 	tst.w	r2, #1
 800109e:	d103      	bne.n	80010a8 <XMC_SCU_INTERRUPT_SetEventHandler+0x1c>
 80010a0:	2b20      	cmp	r3, #32
 80010a2:	d1f7      	bne.n	8001094 <XMC_SCU_INTERRUPT_SetEventHandler+0x8>
    index++;
  }
  
  if (index == XMC_SCU_INTERRUPT_EVENT_MAX)
  {
    status = XMC_SCU_STATUS_ERROR;
 80010a4:	2001      	movs	r0, #1
 80010a6:	4770      	bx	lr
  while (((event & ((XMC_SCU_INTERRUPT_EVENT_t)1 << index)) == 0U) && (index < XMC_SCU_INTERRUPT_EVENT_MAX))
  {
    index++;
  }
  
  if (index == XMC_SCU_INTERRUPT_EVENT_MAX)
 80010a8:	2b20      	cmp	r3, #32
 80010aa:	d101      	bne.n	80010b0 <XMC_SCU_INTERRUPT_SetEventHandler+0x24>
 80010ac:	e005      	b.n	80010ba <XMC_SCU_INTERRUPT_SetEventHandler+0x2e>
                                                   const XMC_SCU_INTERRUPT_EVENT_HANDLER_t handler)
{
  uint32_t index;
  XMC_SCU_STATUS_t status;
  
  index = 0U;
 80010ae:	2300      	movs	r3, #0
  {
    status = XMC_SCU_STATUS_ERROR;
  }
  else
  {
    event_handler_list[index] = handler;
 80010b0:	4a03      	ldr	r2, [pc, #12]	; (80010c0 <XMC_SCU_INTERRUPT_SetEventHandler+0x34>)
 80010b2:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    status = XMC_SCU_STATUS_OK;      
 80010b6:	2000      	movs	r0, #0
 80010b8:	4770      	bx	lr
    index++;
  }
  
  if (index == XMC_SCU_INTERRUPT_EVENT_MAX)
  {
    status = XMC_SCU_STATUS_ERROR;
 80010ba:	2001      	movs	r0, #1
    event_handler_list[index] = handler;
    status = XMC_SCU_STATUS_OK;      
  }
  
  return (status);
}
 80010bc:	4770      	bx	lr
 80010be:	bf00      	nop
 80010c0:	2000d438 	.word	0x2000d438

080010c4 <XMC_SCU_IRQHandler>:

/*
 * API to execute callback functions for multiple events.
 */
void XMC_SCU_IRQHandler(uint32_t sr_num)
{
 80010c4:	b510      	push	{r4, lr}
}

/* API to retrieve the SCU event status */
XMC_SCU_INTERRUPT_EVENT_t XMC_SCU_INTERUPT_GetEventStatus(void)
{
  return (SCU_INTERRUPT->SRRAW);
 80010c6:	4b0e      	ldr	r3, [pc, #56]	; (8001100 <XMC_SCU_IRQHandler+0x3c>)
 80010c8:	6859      	ldr	r1, [r3, #4]
  
  index = 0U;
  event = XMC_SCU_INTERUPT_GetEventStatus();
  while (index < XMC_SCU_INTERRUPT_EVENT_MAX)
  {    
    if ((event & ((XMC_SCU_INTERRUPT_EVENT_t)1 << index)) != 0U)
 80010ca:	f011 0f01 	tst.w	r1, #1
 80010ce:	d107      	bne.n	80010e0 <XMC_SCU_IRQHandler+0x1c>
 80010d0:	2301      	movs	r3, #1
 80010d2:	461c      	mov	r4, r3
 80010d4:	fa21 f203 	lsr.w	r2, r1, r3
 80010d8:	f012 0f01 	tst.w	r2, #1
 80010dc:	d00c      	beq.n	80010f8 <XMC_SCU_IRQHandler+0x34>
 80010de:	e001      	b.n	80010e4 <XMC_SCU_IRQHandler+0x20>
 80010e0:	2400      	movs	r4, #0
  XMC_SCU_INTERRUPT_EVENT_t event;
  XMC_SCU_INTERRUPT_EVENT_HANDLER_t event_handler;
  
  XMC_UNUSED_ARG(sr_num);
  
  index = 0U;
 80010e2:	4623      	mov	r3, r4
  event = XMC_SCU_INTERUPT_GetEventStatus();
  while (index < XMC_SCU_INTERRUPT_EVENT_MAX)
  {    
    if ((event & ((XMC_SCU_INTERRUPT_EVENT_t)1 << index)) != 0U)
    {
      event_handler = event_handler_list[index];
 80010e4:	4a07      	ldr	r2, [pc, #28]	; (8001104 <XMC_SCU_IRQHandler+0x40>)
 80010e6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
      if (event_handler != NULL)
 80010ea:	b103      	cbz	r3, 80010ee <XMC_SCU_IRQHandler+0x2a>
      {
          (event_handler)();
 80010ec:	4798      	blx	r3
      }
      
      XMC_SCU_INTERRUPT_ClearEventStatus((uint32_t)(1UL << index));
 80010ee:	2301      	movs	r3, #1
 80010f0:	40a3      	lsls	r3, r4
}

/* API to clear the SCU event status */
void XMC_SCU_INTERRUPT_ClearEventStatus(const XMC_SCU_INTERRUPT_EVENT_t event)
{
  SCU_INTERRUPT->SRCLR = (uint32_t)event;
 80010f2:	4a03      	ldr	r2, [pc, #12]	; (8001100 <XMC_SCU_IRQHandler+0x3c>)
 80010f4:	60d3      	str	r3, [r2, #12]
 80010f6:	bd10      	pop	{r4, pc}
      
      XMC_SCU_INTERRUPT_ClearEventStatus((uint32_t)(1UL << index));
      
      break;
    }   
    index++;    
 80010f8:	3301      	adds	r3, #1
  
  XMC_UNUSED_ARG(sr_num);
  
  index = 0U;
  event = XMC_SCU_INTERUPT_GetEventStatus();
  while (index < XMC_SCU_INTERRUPT_EVENT_MAX)
 80010fa:	2b20      	cmp	r3, #32
 80010fc:	d1e9      	bne.n	80010d2 <XMC_SCU_IRQHandler+0xe>
 80010fe:	bd10      	pop	{r4, pc}
 8001100:	50004074 	.word	0x50004074
 8001104:	2000d438 	.word	0x2000d438

08001108 <XMC_CAN_NODE_NominalBitTimeConfigureEx>:
#define XMC_CAN_NODE_MIN_TSEG1 3
#define XMC_CAN_NODE_MIN_TSEG2 2

int32_t XMC_CAN_NODE_NominalBitTimeConfigureEx(XMC_CAN_NODE_t *const can_node,
                                               const XMC_CAN_NODE_NOMINAL_BIT_TIME_CONFIG_t *const bit_time_config)
{
 8001108:	b4f0      	push	{r4, r5, r6, r7}
  /* Check that the CAN frequency is a multiple of the required baudrate */
  if ((bit_time_config->can_frequency % bit_time_config->baudrate) == 0)
 800110a:	680b      	ldr	r3, [r1, #0]
 800110c:	684c      	ldr	r4, [r1, #4]
 800110e:	fbb3 f2f4 	udiv	r2, r3, r4
 8001112:	fb04 3212 	mls	r2, r4, r2, r3
 8001116:	2a00      	cmp	r2, #0
 8001118:	d14c      	bne.n	80011b4 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xac>
  {
  uint32_t prescaler;
  uint32_t div8 = 0;

  /* Calculate the factor between can frequency and required baudrate, this is equal to (prescaler x ntq) */
    uint32_t fcan_div = bit_time_config->can_frequency / bit_time_config->baudrate;
 800111a:	fbb3 f4f4 	udiv	r4, r3, r4

    /* start with highest ntq, i.e as much as possible time quanta should be used to construct a bit time */
    uint32_t ntq = XMC_CAN_NODE_MAX_NTQ;
 800111e:	2319      	movs	r3, #25
    while (ntq >= XMC_CAN_NODE_MIN_NTQ)
    {
      /* consider this ntq, only if fcan_div is multiple of ntq */
    if ((fcan_div % ntq) == 0)
 8001120:	fbb4 f2f3 	udiv	r2, r4, r3
 8001124:	fb03 4212 	mls	r2, r3, r2, r4
 8001128:	b952      	cbnz	r2, 8001140 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0x38>
    {
        prescaler = fcan_div / ntq;
 800112a:	fbb4 f2f3 	udiv	r2, r4, r3
        if ((prescaler > 0) && (prescaler <= XMC_CAN_NODE_MAX_PRESCALER))
 800112e:	1e55      	subs	r5, r2, #1
 8001130:	f5b5 7f00 	cmp.w	r5, #512	; 0x200
 8001134:	d204      	bcs.n	8001140 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0x38>
        {
          if (prescaler >= 64)
 8001136:	2a3f      	cmp	r2, #63	; 0x3f
 8001138:	d907      	bls.n	800114a <XMC_CAN_NODE_NominalBitTimeConfigureEx+0x42>
          {
          /* consider prescaler >=64, if it is integer divisible by 8*/
            if ((prescaler & 0x7U) == 0)
 800113a:	f012 0f07 	tst.w	r2, #7
 800113e:	d006      	beq.n	800114e <XMC_CAN_NODE_NominalBitTimeConfigureEx+0x46>
          {
            break;
          }
        }
      }
      --ntq;
 8001140:	3b01      	subs	r3, #1
  /* Calculate the factor between can frequency and required baudrate, this is equal to (prescaler x ntq) */
    uint32_t fcan_div = bit_time_config->can_frequency / bit_time_config->baudrate;

    /* start with highest ntq, i.e as much as possible time quanta should be used to construct a bit time */
    uint32_t ntq = XMC_CAN_NODE_MAX_NTQ;
    while (ntq >= XMC_CAN_NODE_MIN_NTQ)
 8001142:	2b07      	cmp	r3, #7
 8001144:	d1ec      	bne.n	8001120 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0x18>

      return XMC_CAN_STATUS_SUCCESS;
    }
  }

  return XMC_CAN_STATUS_ERROR;
 8001146:	2001      	movs	r0, #1
 8001148:	e03d      	b.n	80011c6 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xbe>
{
  /* Check that the CAN frequency is a multiple of the required baudrate */
  if ((bit_time_config->can_frequency % bit_time_config->baudrate) == 0)
  {
  uint32_t prescaler;
  uint32_t div8 = 0;
 800114a:	2600      	movs	r6, #0
 800114c:	e000      	b.n	8001150 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0x48>
          if (prescaler >= 64)
          {
          /* consider prescaler >=64, if it is integer divisible by 8*/
            if ((prescaler & 0x7U) == 0)
        {
              div8 = 1;
 800114e:	2601      	movs	r6, #1
        }
      }
      --ntq;
    }

    if (ntq >= XMC_CAN_NODE_MIN_NTQ)
 8001150:	2b07      	cmp	r3, #7
 8001152:	d931      	bls.n	80011b8 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xb0>
    {
      uint32_t tseg1 = ((ntq - 1) * bit_time_config->sample_point) / 1000;
 8001154:	1e5c      	subs	r4, r3, #1
 8001156:	890d      	ldrh	r5, [r1, #8]
 8001158:	fb05 f404 	mul.w	r4, r5, r4
 800115c:	4d1b      	ldr	r5, [pc, #108]	; (80011cc <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xc4>)
 800115e:	fba5 5404 	umull	r5, r4, r5, r4
 8001162:	09a4      	lsrs	r4, r4, #6
      uint32_t tseg2 = ntq - tseg1 - 1;

      if ((tseg1 < XMC_CAN_NODE_MIN_TSEG1) || (tseg2 < XMC_CAN_NODE_MIN_TSEG2) || (tseg2 < bit_time_config->sjw))
 8001164:	2c02      	cmp	r4, #2
 8001166:	d929      	bls.n	80011bc <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xb4>
    }

    if (ntq >= XMC_CAN_NODE_MIN_NTQ)
    {
      uint32_t tseg1 = ((ntq - 1) * bit_time_config->sample_point) / 1000;
      uint32_t tseg2 = ntq - tseg1 - 1;
 8001168:	1b1b      	subs	r3, r3, r4
 800116a:	1e5d      	subs	r5, r3, #1

      if ((tseg1 < XMC_CAN_NODE_MIN_TSEG1) || (tseg2 < XMC_CAN_NODE_MIN_TSEG2) || (tseg2 < bit_time_config->sjw))
 800116c:	2d01      	cmp	r5, #1
 800116e:	d927      	bls.n	80011c0 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xb8>
 8001170:	894f      	ldrh	r7, [r1, #10]
 8001172:	42bd      	cmp	r5, r7
 8001174:	d326      	bcc.n	80011c4 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xbc>
 *
 */

__STATIC_INLINE void XMC_CAN_NODE_EnableConfigurationChange(XMC_CAN_NODE_t *const can_node)
{
  can_node->NCR |= (uint32_t)CAN_NODE_NCR_CCE_Msk;
 8001176:	6805      	ldr	r5, [r0, #0]
 8001178:	f045 0540 	orr.w	r5, r5, #64	; 0x40
 800117c:	6005      	str	r5, [r0, #0]

      /* Configure bit timing register */
      can_node->NBTR = (((tseg2 - 1u) << CAN_NODE_NBTR_TSEG2_Pos) & (uint32_t)CAN_NODE_NBTR_TSEG2_Msk) |
                        (((bit_time_config->sjw - 1U) << CAN_NODE_NBTR_SJW_Pos) & (uint32_t)CAN_NODE_NBTR_SJW_Msk) |
                        (((tseg1 - 1U) << CAN_NODE_NBTR_TSEG1_Pos) & (uint32_t)CAN_NODE_NBTR_TSEG1_Msk) |
                        (((prescaler - 1U) << CAN_NODE_NBTR_BRP_Pos) & (uint32_t)CAN_NODE_NBTR_BRP_Msk) |
 800117e:	3a01      	subs	r2, #1
 8001180:	f002 023f 	and.w	r2, r2, #63	; 0x3f
 8001184:	ea42 32c6 	orr.w	r2, r2, r6, lsl #15

      XMC_CAN_NODE_EnableConfigurationChange(can_node);

      /* Configure bit timing register */
      can_node->NBTR = (((tseg2 - 1u) << CAN_NODE_NBTR_TSEG2_Pos) & (uint32_t)CAN_NODE_NBTR_TSEG2_Msk) |
                        (((bit_time_config->sjw - 1U) << CAN_NODE_NBTR_SJW_Pos) & (uint32_t)CAN_NODE_NBTR_SJW_Msk) |
 8001188:	8949      	ldrh	r1, [r1, #10]
 800118a:	3901      	subs	r1, #1
 800118c:	0189      	lsls	r1, r1, #6
 800118e:	b2c9      	uxtb	r1, r1
 8001190:	430a      	orrs	r2, r1
                        (((tseg1 - 1U) << CAN_NODE_NBTR_TSEG1_Pos) & (uint32_t)CAN_NODE_NBTR_TSEG1_Msk) |
 8001192:	1e61      	subs	r1, r4, #1
 8001194:	0209      	lsls	r1, r1, #8
 8001196:	f401 6170 	and.w	r1, r1, #3840	; 0xf00
 800119a:	430a      	orrs	r2, r1
      }

      XMC_CAN_NODE_EnableConfigurationChange(can_node);

      /* Configure bit timing register */
      can_node->NBTR = (((tseg2 - 1u) << CAN_NODE_NBTR_TSEG2_Pos) & (uint32_t)CAN_NODE_NBTR_TSEG2_Msk) |
 800119c:	3b02      	subs	r3, #2
 800119e:	031b      	lsls	r3, r3, #12
 80011a0:	f403 43e0 	and.w	r3, r3, #28672	; 0x7000
                        (((bit_time_config->sjw - 1U) << CAN_NODE_NBTR_SJW_Pos) & (uint32_t)CAN_NODE_NBTR_SJW_Msk) |
                        (((tseg1 - 1U) << CAN_NODE_NBTR_TSEG1_Pos) & (uint32_t)CAN_NODE_NBTR_TSEG1_Msk) |
                        (((prescaler - 1U) << CAN_NODE_NBTR_BRP_Pos) & (uint32_t)CAN_NODE_NBTR_BRP_Msk) |
 80011a4:	431a      	orrs	r2, r3
      }

      XMC_CAN_NODE_EnableConfigurationChange(can_node);

      /* Configure bit timing register */
      can_node->NBTR = (((tseg2 - 1u) << CAN_NODE_NBTR_TSEG2_Pos) & (uint32_t)CAN_NODE_NBTR_TSEG2_Msk) |
 80011a6:	6102      	str	r2, [r0, #16]
 *
 */

__STATIC_INLINE void XMC_CAN_NODE_DisableConfigurationChange(XMC_CAN_NODE_t *const can_node)
{
  can_node->NCR &= ~(uint32_t)CAN_NODE_NCR_CCE_Msk;
 80011a8:	6803      	ldr	r3, [r0, #0]
 80011aa:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80011ae:	6003      	str	r3, [r0, #0]
                        (((prescaler - 1U) << CAN_NODE_NBTR_BRP_Pos) & (uint32_t)CAN_NODE_NBTR_BRP_Msk) |
                        ((div8 << CAN_NODE_NBTR_DIV8_Pos) & (uint32_t)CAN_NODE_NBTR_DIV8_Msk);

      XMC_CAN_NODE_DisableConfigurationChange(can_node);

      return XMC_CAN_STATUS_SUCCESS;
 80011b0:	2000      	movs	r0, #0
 80011b2:	e008      	b.n	80011c6 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xbe>
    }
  }

  return XMC_CAN_STATUS_ERROR;
 80011b4:	2001      	movs	r0, #1
 80011b6:	e006      	b.n	80011c6 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xbe>
 80011b8:	2001      	movs	r0, #1
 80011ba:	e004      	b.n	80011c6 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xbe>
      uint32_t tseg1 = ((ntq - 1) * bit_time_config->sample_point) / 1000;
      uint32_t tseg2 = ntq - tseg1 - 1;

      if ((tseg1 < XMC_CAN_NODE_MIN_TSEG1) || (tseg2 < XMC_CAN_NODE_MIN_TSEG2) || (tseg2 < bit_time_config->sjw))
      {
      return XMC_CAN_STATUS_ERROR;
 80011bc:	2001      	movs	r0, #1
 80011be:	e002      	b.n	80011c6 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xbe>
 80011c0:	2001      	movs	r0, #1
 80011c2:	e000      	b.n	80011c6 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xbe>
 80011c4:	2001      	movs	r0, #1
      return XMC_CAN_STATUS_SUCCESS;
    }
  }

  return XMC_CAN_STATUS_ERROR;
}
 80011c6:	bcf0      	pop	{r4, r5, r6, r7}
 80011c8:	4770      	bx	lr
 80011ca:	bf00      	nop
 80011cc:	10624dd3 	.word	0x10624dd3

080011d0 <XMC_CAN_AllocateMOtoNodeList>:
 *  XMC_CAN_PanelControl()
 *
 */
__STATIC_INLINE bool XMC_CAN_IsPanelControlReady(XMC_CAN_t *const obj)
{
  return (bool)((obj->PANCTR & (CAN_PANCTR_BUSY_Msk | CAN_PANCTR_RBUSY_Msk)) == 0);
 80011d0:	f8d0 31c4 	ldr.w	r3, [r0, #452]	; 0x1c4
}
/* Function to allocate message object from free list to node list */
void XMC_CAN_AllocateMOtoNodeList(XMC_CAN_t *const obj, const uint8_t node_num, const uint8_t mo_num)
{
  /* wait while panel operation is in progress. */
  while (XMC_CAN_IsPanelControlReady(obj) == false)
 80011d4:	f413 7f40 	tst.w	r3, #768	; 0x300
 80011d8:	d1fa      	bne.n	80011d0 <XMC_CAN_AllocateMOtoNodeList>
                                          const XMC_CAN_PANCMD_t pancmd,
                                      const uint8_t arg1,
                                      const uint8_t arg2)
{
  obj->PANCTR = (((uint32_t)pancmd << CAN_PANCTR_PANCMD_Pos) & (uint32_t)CAN_PANCTR_PANCMD_Msk) |
            (((uint32_t)arg1 << CAN_PANCTR_PANAR1_Pos) & (uint32_t)CAN_PANCTR_PANAR1_Msk) |
 80011da:	0412      	lsls	r2, r2, #16
__STATIC_INLINE void XMC_CAN_PanelControl(XMC_CAN_t *const obj,
                                          const XMC_CAN_PANCMD_t pancmd,
                                      const uint8_t arg1,
                                      const uint8_t arg2)
{
  obj->PANCTR = (((uint32_t)pancmd << CAN_PANCTR_PANCMD_Pos) & (uint32_t)CAN_PANCTR_PANCMD_Msk) |
 80011dc:	f042 0202 	orr.w	r2, r2, #2
  {
    /*Do nothing*/
  };

  /* Panel Command for  allocation of MO to node list */
  XMC_CAN_PanelControl(obj, XMC_CAN_PANCMD_STATIC_ALLOCATE,mo_num,(node_num + 1U));
 80011e0:	3101      	adds	r1, #1
            (((uint32_t)arg1 << CAN_PANCTR_PANAR1_Pos) & (uint32_t)CAN_PANCTR_PANAR1_Msk) |
 80011e2:	ea42 6101 	orr.w	r1, r2, r1, lsl #24
__STATIC_INLINE void XMC_CAN_PanelControl(XMC_CAN_t *const obj,
                                          const XMC_CAN_PANCMD_t pancmd,
                                      const uint8_t arg1,
                                      const uint8_t arg2)
{
  obj->PANCTR = (((uint32_t)pancmd << CAN_PANCTR_PANCMD_Pos) & (uint32_t)CAN_PANCTR_PANCMD_Msk) |
 80011e6:	f8c0 11c4 	str.w	r1, [r0, #452]	; 0x1c4
 80011ea:	4770      	bx	lr

080011ec <XMC_CAN_Disable>:
}

/* Disable XMC_CAN Peripheral */
void XMC_CAN_Disable(XMC_CAN_t *const obj)
{
 80011ec:	b508      	push	{r3, lr}
  /* Disable CAN Module */
  obj->CLC = CAN_CLC_DISR_Msk;
 80011ee:	2301      	movs	r3, #1
 80011f0:	6003      	str	r3, [r0, #0]
#if defined(PERIPHERAL_RESET_SUPPORTED)
  XMC_SCU_RESET_AssertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_MCAN);
 80011f2:	4802      	ldr	r0, [pc, #8]	; (80011fc <XMC_CAN_Disable+0x10>)
 80011f4:	f7ff feb6 	bl	8000f64 <XMC_SCU_RESET_AssertPeripheralReset>
 80011f8:	bd08      	pop	{r3, pc}
 80011fa:	bf00      	nop
 80011fc:	10000010 	.word	0x10000010

08001200 <XMC_CAN_Enable>:
#endif
}

/* Enable XMC_CAN Peripheral */
void XMC_CAN_Enable(XMC_CAN_t *const obj)
{
 8001200:	b510      	push	{r4, lr}
 8001202:	4604      	mov	r4, r0
#if defined(CLOCK_GATING_SUPPORTED)
  XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_MCAN);
#endif
#if defined(PERIPHERAL_RESET_SUPPORTED)
  XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_MCAN);
 8001204:	4805      	ldr	r0, [pc, #20]	; (800121c <XMC_CAN_Enable+0x1c>)
 8001206:	f7ff feb9 	bl	8000f7c <XMC_SCU_RESET_DeassertPeripheralReset>
#endif
  /* Enable CAN Module */
  obj->CLC &= ~(uint32_t)CAN_CLC_DISR_Msk;
 800120a:	6823      	ldr	r3, [r4, #0]
 800120c:	f023 0301 	bic.w	r3, r3, #1
 8001210:	6023      	str	r3, [r4, #0]
  while (obj->CLC & CAN_CLC_DISS_Msk)
 8001212:	6823      	ldr	r3, [r4, #0]
 8001214:	f013 0f02 	tst.w	r3, #2
 8001218:	d1fb      	bne.n	8001212 <XMC_CAN_Enable+0x12>
  {
    /*Do nothing*/
  };
}
 800121a:	bd10      	pop	{r4, pc}
 800121c:	10000010 	.word	0x10000010

08001220 <XMC_CAN_InitEx>:

  return frequency;
}

uint32_t XMC_CAN_InitEx(XMC_CAN_t *const obj, XMC_CAN_CANCLKSRC_t clksrc, uint32_t can_frequency)
{
 8001220:	b538      	push	{r3, r4, r5, lr}
 8001222:	4605      	mov	r5, r0
 8001224:	4614      	mov	r4, r2
  uint32_t peripheral_frequency;

  XMC_ASSERT("XMC_CAN_Init: frequency not supported", can_frequency <= peripheral_frequency);

  /*Enabling the module*/
  XMC_CAN_Enable(obj);
 8001226:	f7ff ffeb 	bl	8001200 <XMC_CAN_Enable>
    default:
      frequency = 0;
      break;
  }
#else
  frequency = XMC_SCU_CLOCK_GetPeripheralClockFrequency();
 800122a:	f7ff feb3 	bl	8000f94 <XMC_SCU_CLOCK_GetPeripheralClockFrequency>

  XMC_CAN_SetBaudrateClockSource(obj, clksrc);
  peripheral_frequency = XMC_CAN_GetBaudrateClockFrequency(obj);

  /* Normal divider mode */
  step_n = (uint32_t)min(max(0U, (1024U - (peripheral_frequency / can_frequency))), 1023U);
 800122e:	fbb0 f3f4 	udiv	r3, r0, r4
 8001232:	f5c3 6380 	rsb	r3, r3, #1024	; 0x400
#if defined(CAN)
#include "xmc_scu.h"

__STATIC_INLINE uint32_t max(uint32_t a, uint32_t b)
{
  return (a > b) ? a : b;
 8001236:	2b00      	cmp	r3, #0
 8001238:	bf38      	it	cc
 800123a:	2300      	movcc	r3, #0
}

__STATIC_INLINE uint32_t min(uint32_t a, uint32_t b)
{
  return (a < b) ? a : b;
 800123c:	f240 32ff 	movw	r2, #1023	; 0x3ff
 8001240:	4293      	cmp	r3, r2
 8001242:	bf28      	it	cs
 8001244:	4613      	movcs	r3, r2

  /* Normal divider mode */
  step_n = (uint32_t)min(max(0U, (1024U - (peripheral_frequency / can_frequency))), 1023U);
  freq_n = (uint32_t)(peripheral_frequency / (1024U - step_n));

  obj->FDR &= (uint32_t) ~(CAN_FDR_DM_Msk | CAN_FDR_STEP_Msk);
 8001246:	68ea      	ldr	r2, [r5, #12]
 8001248:	f422 4243 	bic.w	r2, r2, #49920	; 0xc300
 800124c:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 8001250:	60ea      	str	r2, [r5, #12]
  obj->FDR |= ((uint32_t)XMC_CAN_DM_NORMAL << CAN_FDR_DM_Pos) | ((uint32_t)step_n << CAN_FDR_STEP_Pos);
 8001252:	68ea      	ldr	r2, [r5, #12]
 8001254:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8001258:	431a      	orrs	r2, r3
 800125a:	60ea      	str	r2, [r5, #12]
  XMC_CAN_SetBaudrateClockSource(obj, clksrc);
  peripheral_frequency = XMC_CAN_GetBaudrateClockFrequency(obj);

  /* Normal divider mode */
  step_n = (uint32_t)min(max(0U, (1024U - (peripheral_frequency / can_frequency))), 1023U);
  freq_n = (uint32_t)(peripheral_frequency / (1024U - step_n));
 800125c:	f5c3 6380 	rsb	r3, r3, #1024	; 0x400

  obj->FDR &= (uint32_t) ~(CAN_FDR_DM_Msk | CAN_FDR_STEP_Msk);
  obj->FDR |= ((uint32_t)XMC_CAN_DM_NORMAL << CAN_FDR_DM_Pos) | ((uint32_t)step_n << CAN_FDR_STEP_Pos);

  return freq_n;
}
 8001260:	fbb0 f0f3 	udiv	r0, r0, r3
 8001264:	bd38      	pop	{r3, r4, r5, pc}
 8001266:	bf00      	nop

08001268 <XMC_CAN_MO_UpdateData>:
/* Update of XMC_CAN Object */
XMC_CAN_STATUS_t XMC_CAN_MO_UpdateData(const XMC_CAN_MO_t *const can_mo)
{
  XMC_CAN_STATUS_t error = XMC_CAN_STATUS_MO_NOT_ACCEPTABLE;
  /* Check whether message object is transmit message object */
  if (can_mo->can_mo_type == XMC_CAN_MO_TYPE_TRANSMSGOBJ)
 8001268:	7e03      	ldrb	r3, [r0, #24]
 800126a:	2b01      	cmp	r3, #1
 800126c:	d117      	bne.n	800129e <XMC_CAN_MO_UpdateData+0x36>
  {
    can_mo->can_mo_ptr->MOCTR = CAN_MO_MOCTR_RESMSGVAL_Msk;
 800126e:	6803      	ldr	r3, [r0, #0]
 8001270:	2220      	movs	r2, #32
 8001272:	61da      	str	r2, [r3, #28]
    /* Configure data length */
    can_mo->can_mo_ptr->MOFCR = ((can_mo->can_mo_ptr->MOFCR) & ~(uint32_t)(CAN_MO_MOFCR_DLC_Msk)) |
 8001274:	6801      	ldr	r1, [r0, #0]
 8001276:	680b      	ldr	r3, [r1, #0]
                                (((uint32_t) can_mo->can_data_length << CAN_MO_MOFCR_DLC_Pos) & (uint32_t)CAN_MO_MOFCR_DLC_Msk);
 8001278:	7b02      	ldrb	r2, [r0, #12]
 800127a:	0612      	lsls	r2, r2, #24
 800127c:	f002 6270 	and.w	r2, r2, #251658240	; 0xf000000
  /* Check whether message object is transmit message object */
  if (can_mo->can_mo_type == XMC_CAN_MO_TYPE_TRANSMSGOBJ)
  {
    can_mo->can_mo_ptr->MOCTR = CAN_MO_MOCTR_RESMSGVAL_Msk;
    /* Configure data length */
    can_mo->can_mo_ptr->MOFCR = ((can_mo->can_mo_ptr->MOFCR) & ~(uint32_t)(CAN_MO_MOFCR_DLC_Msk)) |
 8001280:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
 8001284:	4313      	orrs	r3, r2
 8001286:	600b      	str	r3, [r1, #0]
                                (((uint32_t) can_mo->can_data_length << CAN_MO_MOFCR_DLC_Pos) & (uint32_t)CAN_MO_MOFCR_DLC_Msk);
    /* Configure Data registers*/
    can_mo->can_mo_ptr->MODATAL = can_mo->can_data[0];
 8001288:	6803      	ldr	r3, [r0, #0]
 800128a:	6902      	ldr	r2, [r0, #16]
 800128c:	611a      	str	r2, [r3, #16]
    can_mo->can_mo_ptr->MODATAH = can_mo->can_data[1];
 800128e:	6803      	ldr	r3, [r0, #0]
 8001290:	6942      	ldr	r2, [r0, #20]
 8001292:	615a      	str	r2, [r3, #20]
    /* Reset RTSEL and Set MSGVAL ,TXEN0 and TXEN1 bits */
    can_mo->can_mo_ptr->MOCTR = (CAN_MO_MOCTR_SETNEWDAT_Msk| CAN_MO_MOCTR_SETMSGVAL_Msk |CAN_MO_MOCTR_RESRTSEL_Msk);
 8001294:	6803      	ldr	r3, [r0, #0]
 8001296:	4a03      	ldr	r2, [pc, #12]	; (80012a4 <XMC_CAN_MO_UpdateData+0x3c>)
 8001298:	61da      	str	r2, [r3, #28]
    error = XMC_CAN_STATUS_SUCCESS;
 800129a:	2000      	movs	r0, #0
 800129c:	4770      	bx	lr
  }
  else
  {
    error = XMC_CAN_STATUS_MO_NOT_ACCEPTABLE;
 800129e:	2003      	movs	r0, #3
  }
  return error;
}
 80012a0:	4770      	bx	lr
 80012a2:	bf00      	nop
 80012a4:	00280040 	.word	0x00280040

080012a8 <XMC_CAN_MO_Config>:
  can_mo->can_id_mask = can_id_mask;
}

/* Initialization of XMC_CAN MO Object */
void XMC_CAN_MO_Config(const XMC_CAN_MO_t *const can_mo)
{
 80012a8:	b538      	push	{r3, r4, r5, lr}
  uint32_t reg;
  
  /* Configure MPN */
  uint32_t num = ((uint32_t)(can_mo->can_mo_ptr) - CAN_BASE - 0x1000U)/0x0020U;
 80012aa:	6802      	ldr	r2, [r0, #0]
 80012ac:	f102 4338 	add.w	r3, r2, #3087007744	; 0xb8000000
 80012b0:	f5a3 33a8 	sub.w	r3, r3, #86016	; 0x15000
  uint32_t set = (((uint32_t)(num/32) << (CAN_MO_MOIPR_MPN_Pos + 5U)) | ((uint32_t)(num%32) << CAN_MO_MOIPR_MPN_Pos));
  can_mo->can_mo_ptr->MOIPR &= ~(CAN_MO_MOIPR_MPN_Msk);
 80012b4:	6891      	ldr	r1, [r2, #8]
 80012b6:	f421 417f 	bic.w	r1, r1, #65280	; 0xff00
 80012ba:	6091      	str	r1, [r2, #8]
  can_mo->can_mo_ptr->MOIPR |= set;
 80012bc:	6804      	ldr	r4, [r0, #0]
 80012be:	68a1      	ldr	r1, [r4, #8]
{
  uint32_t reg;
  
  /* Configure MPN */
  uint32_t num = ((uint32_t)(can_mo->can_mo_ptr) - CAN_BASE - 0x1000U)/0x0020U;
  uint32_t set = (((uint32_t)(num/32) << (CAN_MO_MOIPR_MPN_Pos + 5U)) | ((uint32_t)(num%32) << CAN_MO_MOIPR_MPN_Pos));
 80012c0:	0a9d      	lsrs	r5, r3, #10
 80012c2:	f3c3 1344 	ubfx	r3, r3, #5, #5
 80012c6:	021a      	lsls	r2, r3, #8
 80012c8:	ea42 3345 	orr.w	r3, r2, r5, lsl #13
  can_mo->can_mo_ptr->MOIPR &= ~(CAN_MO_MOIPR_MPN_Msk);
  can_mo->can_mo_ptr->MOIPR |= set;
 80012cc:	430b      	orrs	r3, r1
 80012ce:	60a3      	str	r3, [r4, #8]
  
  if (((can_mo->can_id_mode != (uint32_t) XMC_CAN_FRAME_TYPE_STANDARD_11BITS) &&
 80012d0:	7e03      	ldrb	r3, [r0, #24]
 80012d2:	2b01      	cmp	r3, #1
 80012d4:	d830      	bhi.n	8001338 <XMC_CAN_MO_Config+0x90>
  }
  else
  {

    /* Disable Message object */
    can_mo->can_mo_ptr->MOCTR = CAN_MO_MOCTR_RESMSGVAL_Msk;
 80012d6:	6803      	ldr	r3, [r0, #0]
 80012d8:	2220      	movs	r2, #32
 80012da:	61da      	str	r2, [r3, #28]
    if (can_mo->can_id_mode == (uint32_t)XMC_CAN_FRAME_TYPE_STANDARD_11BITS)
 80012dc:	79c3      	ldrb	r3, [r0, #7]
 80012de:	f013 0f20 	tst.w	r3, #32
 80012e2:	d10e      	bne.n	8001302 <XMC_CAN_MO_Config+0x5a>
    {
      reg = can_mo->mo_ar;
 80012e4:	6842      	ldr	r2, [r0, #4]
      reg &= (uint32_t) ~(CAN_MO_MOAR_ID_Msk);
 80012e6:	f002 4360 	and.w	r3, r2, #3758096384	; 0xe0000000
      reg |= (can_mo->can_identifier << XMC_CAN_MO_MOAR_STDID_Pos);
 80012ea:	ea43 4382 	orr.w	r3, r3, r2, lsl #18
      can_mo->can_mo_ptr->MOAR = reg;
 80012ee:	6802      	ldr	r2, [r0, #0]
 80012f0:	6193      	str	r3, [r2, #24]

      reg = can_mo->mo_amr;
 80012f2:	6882      	ldr	r2, [r0, #8]
      reg &= (uint32_t) ~(CAN_MO_MOAMR_AM_Msk);
 80012f4:	f002 4360 	and.w	r3, r2, #3758096384	; 0xe0000000
      reg |= (can_mo->can_id_mask << XMC_CAN_MO_MOAR_STDID_Pos);
 80012f8:	ea43 4382 	orr.w	r3, r3, r2, lsl #18
      can_mo->can_mo_ptr->MOAMR = reg;
 80012fc:	6802      	ldr	r2, [r0, #0]
 80012fe:	60d3      	str	r3, [r2, #12]
 8001300:	e005      	b.n	800130e <XMC_CAN_MO_Config+0x66>
    }
    else
    {
      can_mo->can_mo_ptr->MOAR = can_mo->mo_ar;
 8001302:	6803      	ldr	r3, [r0, #0]
 8001304:	6842      	ldr	r2, [r0, #4]
 8001306:	619a      	str	r2, [r3, #24]
      can_mo->can_mo_ptr->MOAMR = can_mo->mo_amr;
 8001308:	6803      	ldr	r3, [r0, #0]
 800130a:	6882      	ldr	r2, [r0, #8]
 800130c:	60da      	str	r2, [r3, #12]
    }
    /* Check whether message object is transmit message object */
    if (can_mo->can_mo_type == XMC_CAN_MO_TYPE_TRANSMSGOBJ)
 800130e:	7e03      	ldrb	r3, [r0, #24]
 8001310:	2b01      	cmp	r3, #1
 8001312:	d10a      	bne.n	800132a <XMC_CAN_MO_Config+0x82>
 8001314:	4604      	mov	r4, r0
    {
      /* Set MO as Transmit message object  */
      XMC_CAN_MO_UpdateData(can_mo);
 8001316:	f7ff ffa7 	bl	8001268 <XMC_CAN_MO_UpdateData>
      can_mo->can_mo_ptr->MOCTR = CAN_MO_MOCTR_SETDIR_Msk;
 800131a:	6823      	ldr	r3, [r4, #0]
 800131c:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8001320:	61da      	str	r2, [r3, #28]

      /* Reset RTSEL and Set MSGVAL, TXEN0 and TXEN1 bits */
      can_mo->can_mo_ptr->MOCTR = (CAN_MO_MOCTR_SETTXEN0_Msk | CAN_MO_MOCTR_SETTXEN1_Msk | CAN_MO_MOCTR_SETMSGVAL_Msk |
 8001322:	6823      	ldr	r3, [r4, #0]
 8001324:	4a05      	ldr	r2, [pc, #20]	; (800133c <XMC_CAN_MO_Config+0x94>)
 8001326:	61da      	str	r2, [r3, #28]
 8001328:	bd38      	pop	{r3, r4, r5, pc}
                                   CAN_MO_MOCTR_RESRXEN_Msk  | CAN_MO_MOCTR_RESRTSEL_Msk);
    }
    else
    {
      /* Set MO as Receive message object and set RXEN bit */
      can_mo->can_mo_ptr->MOCTR = CAN_MO_MOCTR_RESDIR_Msk;
 800132a:	6803      	ldr	r3, [r0, #0]
 800132c:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8001330:	61da      	str	r2, [r3, #28]

      /* Reset RTSEL, TXEN1 and TXEN2 and Set MSGVAL and RXEN bits */
      can_mo->can_mo_ptr->MOCTR = (CAN_MO_MOCTR_RESTXEN0_Msk | CAN_MO_MOCTR_RESTXEN1_Msk | CAN_MO_MOCTR_SETMSGVAL_Msk |
 8001332:	6803      	ldr	r3, [r0, #0]
 8001334:	4a02      	ldr	r2, [pc, #8]	; (8001340 <XMC_CAN_MO_Config+0x98>)
 8001336:	61da      	str	r2, [r3, #28]
 8001338:	bd38      	pop	{r3, r4, r5, pc}
 800133a:	bf00      	nop
 800133c:	062000c0 	.word	0x062000c0
 8001340:	00a00640 	.word	0x00a00640

08001344 <XMC_CAN_MO_ReceiveData>:
XMC_CAN_STATUS_t XMC_CAN_MO_ReceiveData (XMC_CAN_MO_t *can_mo)
{
  XMC_CAN_STATUS_t error = XMC_CAN_STATUS_ERROR;
  uint8_t rx_pnd = 0U;
  uint8_t new_data = 0U;
  uint32_t mo_type = (uint32_t)((can_mo->can_mo_ptr->MOSTAT) & CAN_MO_MOSTAT_DIR_Msk) >> CAN_MO_MOSTAT_DIR_Pos;
 8001344:	6803      	ldr	r3, [r0, #0]
 8001346:	69da      	ldr	r2, [r3, #28]
  uint32_t mo_recepcion_ongoing = (uint32_t)((can_mo->can_mo_ptr->MOSTAT) & CAN_MO_MOSTAT_RXUPD_Msk) >> CAN_MO_MOSTAT_RXUPD_Pos;
 8001348:	69d9      	ldr	r1, [r3, #28]
  /* check if message object is a receive message object */
  if (mo_type != (uint32_t)XMC_CAN_MO_TYPE_RECMSGOBJ)
 800134a:	f412 6f00 	tst.w	r2, #2048	; 0x800
 800134e:	d111      	bne.n	8001374 <XMC_CAN_MO_ReceiveData+0x30>
  {
    error = XMC_CAN_STATUS_MO_NOT_ACCEPTABLE;
  }
  /* check if reception is ongoing on message object */
  else if (mo_recepcion_ongoing == 1U)
 8001350:	f011 0f04 	tst.w	r1, #4
 8001354:	d110      	bne.n	8001378 <XMC_CAN_MO_ReceiveData+0x34>
  else
  {
    /* read message parameters */
    do
    {
      can_mo->can_data[0] = can_mo->can_mo_ptr->MODATAL;
 8001356:	691a      	ldr	r2, [r3, #16]
 8001358:	6102      	str	r2, [r0, #16]
      can_mo->can_data[1] = can_mo->can_mo_ptr->MODATAH;
 800135a:	695a      	ldr	r2, [r3, #20]
 800135c:	6142      	str	r2, [r0, #20]

      rx_pnd = (uint8_t)((uint32_t)((can_mo->can_mo_ptr->MOSTAT) & CAN_MO_MOSTAT_RXUPD_Msk) >> CAN_MO_MOSTAT_RXUPD_Pos);
 800135e:	69d9      	ldr	r1, [r3, #28]
      new_data = (uint8_t)((uint32_t)((can_mo->can_mo_ptr->MOSTAT) & CAN_MO_MOSTAT_NEWDAT_Msk) >> CAN_MO_MOSTAT_NEWDAT_Pos);
 8001360:	69da      	ldr	r2, [r3, #28]
 8001362:	f3c2 02c0 	ubfx	r2, r2, #3, #1
    } while ((rx_pnd != 0U) && (new_data != 0U));
 8001366:	f011 0f04 	tst.w	r1, #4
 800136a:	d007      	beq.n	800137c <XMC_CAN_MO_ReceiveData+0x38>
 800136c:	2a00      	cmp	r2, #0
 800136e:	d1f2      	bne.n	8001356 <XMC_CAN_MO_ReceiveData+0x12>

    error = XMC_CAN_STATUS_SUCCESS;
 8001370:	2000      	movs	r0, #0
 8001372:	4770      	bx	lr
  uint32_t mo_type = (uint32_t)((can_mo->can_mo_ptr->MOSTAT) & CAN_MO_MOSTAT_DIR_Msk) >> CAN_MO_MOSTAT_DIR_Pos;
  uint32_t mo_recepcion_ongoing = (uint32_t)((can_mo->can_mo_ptr->MOSTAT) & CAN_MO_MOSTAT_RXUPD_Msk) >> CAN_MO_MOSTAT_RXUPD_Pos;
  /* check if message object is a receive message object */
  if (mo_type != (uint32_t)XMC_CAN_MO_TYPE_RECMSGOBJ)
  {
    error = XMC_CAN_STATUS_MO_NOT_ACCEPTABLE;
 8001374:	2003      	movs	r0, #3
 8001376:	4770      	bx	lr
  }
  /* check if reception is ongoing on message object */
  else if (mo_recepcion_ongoing == 1U)
  {
    error = XMC_CAN_STATUS_BUSY;
 8001378:	2002      	movs	r0, #2
 800137a:	4770      	bx	lr

      rx_pnd = (uint8_t)((uint32_t)((can_mo->can_mo_ptr->MOSTAT) & CAN_MO_MOSTAT_RXUPD_Msk) >> CAN_MO_MOSTAT_RXUPD_Pos);
      new_data = (uint8_t)((uint32_t)((can_mo->can_mo_ptr->MOSTAT) & CAN_MO_MOSTAT_NEWDAT_Msk) >> CAN_MO_MOSTAT_NEWDAT_Pos);
    } while ((rx_pnd != 0U) && (new_data != 0U));

    error = XMC_CAN_STATUS_SUCCESS;
 800137c:	2000      	movs	r0, #0
  }
  return error;
}
 800137e:	4770      	bx	lr

08001380 <XMC_CAN_NODE_EnableEvent>:
}

/* Function to enable node event */
void XMC_CAN_NODE_EnableEvent(XMC_CAN_NODE_t *const can_node, const XMC_CAN_NODE_EVENT_t event)
{
  if(event != XMC_CAN_NODE_EVENT_CFCIE)
 8001380:	f5b1 0f80 	cmp.w	r1, #4194304	; 0x400000
 8001384:	d003      	beq.n	800138e <XMC_CAN_NODE_EnableEvent+0xe>
  {
    can_node->NCR |= (uint32_t)event;
 8001386:	6803      	ldr	r3, [r0, #0]
 8001388:	4319      	orrs	r1, r3
 800138a:	6001      	str	r1, [r0, #0]
 800138c:	4770      	bx	lr
  }
  else
  {
    can_node->NFCR |= (uint32_t)event;
 800138e:	6983      	ldr	r3, [r0, #24]
 8001390:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8001394:	6183      	str	r3, [r0, #24]
 8001396:	4770      	bx	lr

08001398 <XMC_ETH_MAC_InitRxDescriptors>:
  return status;
}

/* Initialize RX descriptors */
void XMC_ETH_MAC_InitRxDescriptors(XMC_ETH_MAC_t *const eth_mac)
{
 8001398:	b4f0      	push	{r4, r5, r6, r7}

  /*
   * Chained structure (ETH_MAC_DMA_RDES1_RCH), second address in the descriptor
   * (buffer2) is the next descriptor address
   */
  for (i = 0U; i < eth_mac->num_rx_buf; ++i)
 800139a:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
 800139e:	b313      	cbz	r3, 80013e6 <XMC_ETH_MAC_InitRxDescriptors+0x4e>
 80013a0:	2500      	movs	r5, #0
 80013a2:	462a      	mov	r2, r5
  {
  eth_mac->rx_desc[i].status = (uint32_t)ETH_MAC_DMA_RDES0_OWN;
 80013a4:	f04f 4700 	mov.w	r7, #2147483648	; 0x80000000
  eth_mac->rx_desc[i].length = (uint32_t)ETH_MAC_DMA_RDES1_RCH | (uint32_t)XMC_ETH_MAC_BUF_SIZE;
 80013a8:	f244 56f4 	movw	r6, #17908	; 0x45f4
 80013ac:	0153      	lsls	r3, r2, #5
   * Chained structure (ETH_MAC_DMA_RDES1_RCH), second address in the descriptor
   * (buffer2) is the next descriptor address
   */
  for (i = 0U; i < eth_mac->num_rx_buf; ++i)
  {
  eth_mac->rx_desc[i].status = (uint32_t)ETH_MAC_DMA_RDES0_OWN;
 80013ae:	6901      	ldr	r1, [r0, #16]
 80013b0:	50cf      	str	r7, [r1, r3]
  eth_mac->rx_desc[i].length = (uint32_t)ETH_MAC_DMA_RDES1_RCH | (uint32_t)XMC_ETH_MAC_BUF_SIZE;
 80013b2:	6901      	ldr	r1, [r0, #16]
 80013b4:	4419      	add	r1, r3
 80013b6:	604e      	str	r6, [r1, #4]
  eth_mac->rx_desc[i].buffer1 = (uint32_t)&(eth_mac->rx_buf[i * XMC_ETH_MAC_BUF_SIZE]);
 80013b8:	6901      	ldr	r1, [r0, #16]
 80013ba:	4419      	add	r1, r3
 80013bc:	6984      	ldr	r4, [r0, #24]
 80013be:	442c      	add	r4, r5
 80013c0:	608c      	str	r4, [r1, #8]
    next = i + 1U;
 80013c2:	3201      	adds	r2, #1
    if (next == eth_mac->num_rx_buf)
 80013c4:	f890 1024 	ldrb.w	r1, [r0, #36]	; 0x24
    {
      next = 0U;
 80013c8:	4291      	cmp	r1, r2
 80013ca:	bf14      	ite	ne
 80013cc:	4614      	movne	r4, r2
 80013ce:	2400      	moveq	r4, #0
    }
    eth_mac->rx_desc[i].buffer2 = (uint32_t)&(eth_mac->rx_desc[next]);
 80013d0:	6901      	ldr	r1, [r0, #16]
 80013d2:	440b      	add	r3, r1
 80013d4:	eb01 1144 	add.w	r1, r1, r4, lsl #5
 80013d8:	60d9      	str	r1, [r3, #12]
 80013da:	f205 55f4 	addw	r5, r5, #1524	; 0x5f4

  /*
   * Chained structure (ETH_MAC_DMA_RDES1_RCH), second address in the descriptor
   * (buffer2) is the next descriptor address
   */
  for (i = 0U; i < eth_mac->num_rx_buf; ++i)
 80013de:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
 80013e2:	4293      	cmp	r3, r2
 80013e4:	d8e2      	bhi.n	80013ac <XMC_ETH_MAC_InitRxDescriptors+0x14>
    {
      next = 0U;
    }
    eth_mac->rx_desc[i].buffer2 = (uint32_t)&(eth_mac->rx_desc[next]);
  }
  eth_mac->regs->RECEIVE_DESCRIPTOR_LIST_ADDRESS = (uint32_t)&(eth_mac->rx_desc[0]);
 80013e6:	6802      	ldr	r2, [r0, #0]
 80013e8:	6901      	ldr	r1, [r0, #16]
 80013ea:	f241 030c 	movw	r3, #4108	; 0x100c
 80013ee:	50d1      	str	r1, [r2, r3]
  eth_mac->rx_index = 0U;
 80013f0:	2300      	movs	r3, #0
 80013f2:	f880 3027 	strb.w	r3, [r0, #39]	; 0x27
}
 80013f6:	bcf0      	pop	{r4, r5, r6, r7}
 80013f8:	4770      	bx	lr
 80013fa:	bf00      	nop

080013fc <XMC_ETH_MAC_InitTxDescriptors>:

/* Initialize TX descriptors */
void XMC_ETH_MAC_InitTxDescriptors(XMC_ETH_MAC_t *const eth_mac)
{
 80013fc:	b470      	push	{r4, r5, r6}
  uint32_t next;

  XMC_ASSERT("XMC_ETH_MAC_InitTxDescriptors: eth_mac is invalid", XMC_ETH_MAC_IsValidModule(eth_mac->regs));

  /* Chained structure (ETH_MAC_DMA_TDES0_TCH), second address in the descriptor (buffer2) is the next descriptor address */
  for (i = 0U; i < eth_mac->num_tx_buf; ++i)
 80013fe:	f890 3025 	ldrb.w	r3, [r0, #37]	; 0x25
 8001402:	b1e3      	cbz	r3, 800143e <XMC_ETH_MAC_InitTxDescriptors+0x42>
 8001404:	2500      	movs	r5, #0
 8001406:	462b      	mov	r3, r5
  {
  eth_mac->tx_desc[i].status = ETH_MAC_DMA_TDES0_TCH | ETH_MAC_DMA_TDES0_LS | ETH_MAC_DMA_TDES0_FS;
 8001408:	4e12      	ldr	r6, [pc, #72]	; (8001454 <XMC_ETH_MAC_InitTxDescriptors+0x58>)
 800140a:	015a      	lsls	r2, r3, #5
 800140c:	6941      	ldr	r1, [r0, #20]
 800140e:	508e      	str	r6, [r1, r2]
  eth_mac->tx_desc[i].buffer1 = (uint32_t)&(eth_mac->tx_buf[i * XMC_ETH_MAC_BUF_SIZE]);
 8001410:	6941      	ldr	r1, [r0, #20]
 8001412:	4411      	add	r1, r2
 8001414:	69c4      	ldr	r4, [r0, #28]
 8001416:	442c      	add	r4, r5
 8001418:	608c      	str	r4, [r1, #8]
    next = i + 1U;
 800141a:	3301      	adds	r3, #1
    if (next == eth_mac->num_tx_buf)
 800141c:	f890 1025 	ldrb.w	r1, [r0, #37]	; 0x25
    {
        next = 0U;
 8001420:	4299      	cmp	r1, r3
 8001422:	bf14      	ite	ne
 8001424:	461c      	movne	r4, r3
 8001426:	2400      	moveq	r4, #0
    }
    eth_mac->tx_desc[i].buffer2 = (uint32_t)&(eth_mac->tx_desc[next]);
 8001428:	6941      	ldr	r1, [r0, #20]
 800142a:	440a      	add	r2, r1
 800142c:	eb01 1144 	add.w	r1, r1, r4, lsl #5
 8001430:	60d1      	str	r1, [r2, #12]
 8001432:	f205 55f4 	addw	r5, r5, #1524	; 0x5f4
  uint32_t next;

  XMC_ASSERT("XMC_ETH_MAC_InitTxDescriptors: eth_mac is invalid", XMC_ETH_MAC_IsValidModule(eth_mac->regs));

  /* Chained structure (ETH_MAC_DMA_TDES0_TCH), second address in the descriptor (buffer2) is the next descriptor address */
  for (i = 0U; i < eth_mac->num_tx_buf; ++i)
 8001436:	f890 2025 	ldrb.w	r2, [r0, #37]	; 0x25
 800143a:	429a      	cmp	r2, r3
 800143c:	d8e5      	bhi.n	800140a <XMC_ETH_MAC_InitTxDescriptors+0xe>
    {
        next = 0U;
    }
    eth_mac->tx_desc[i].buffer2 = (uint32_t)&(eth_mac->tx_desc[next]);
  }
  eth_mac->regs->TRANSMIT_DESCRIPTOR_LIST_ADDRESS = (uint32_t)&(eth_mac->tx_desc[0]);
 800143e:	6802      	ldr	r2, [r0, #0]
 8001440:	6941      	ldr	r1, [r0, #20]
 8001442:	f241 0310 	movw	r3, #4112	; 0x1010
 8001446:	50d1      	str	r1, [r2, r3]
  eth_mac->tx_index = 0U;
 8001448:	2300      	movs	r3, #0
 800144a:	f880 3026 	strb.w	r3, [r0, #38]	; 0x26
}
 800144e:	bc70      	pop	{r4, r5, r6}
 8001450:	4770      	bx	lr
 8001452:	bf00      	nop
 8001454:	30100000 	.word	0x30100000

08001458 <XMC_ETH_MAC_InitEx>:
}

#endif

void XMC_ETH_MAC_InitEx(XMC_ETH_MAC_t *const eth_mac)
{
 8001458:	b510      	push	{r4, lr}
 800145a:	4604      	mov	r4, r0
 * \par
 * The function resets the ETH MAC peripheral. It blocks until reset.
 */
__STATIC_INLINE void XMC_ETH_MAC_Reset(XMC_ETH_MAC_t *const eth_mac)
{
  eth_mac->regs->BUS_MODE |= (uint32_t)ETH_BUS_MODE_SWR_Msk;
 800145c:	6803      	ldr	r3, [r0, #0]
 800145e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8001462:	681a      	ldr	r2, [r3, #0]
 8001464:	f042 0201 	orr.w	r2, r2, #1
 8001468:	601a      	str	r2, [r3, #0]
  while ((eth_mac->regs->BUS_MODE & (uint32_t)ETH_BUS_MODE_SWR_Msk) != 0U)
 800146a:	6801      	ldr	r1, [r0, #0]
 800146c:	f501 5280 	add.w	r2, r1, #4096	; 0x1000
 8001470:	6813      	ldr	r3, [r2, #0]
 8001472:	f013 0f01 	tst.w	r3, #1
 8001476:	d1fb      	bne.n	8001470 <XMC_ETH_MAC_InitEx+0x18>
  XMC_ASSERT("XMC_ETH_MAC_InitEx: eth_mac is invalid", XMC_ETH_MAC_IsValidModule(eth_mac->regs));

  XMC_ETH_MAC_Reset(eth_mac);

  /* Initialize MAC configuration */
  eth_mac->regs->MAC_CONFIGURATION = (uint32_t)ETH_MAC_CONFIGURATION_IPC_Msk;
 8001478:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800147c:	600b      	str	r3, [r1, #0]

  /* Initialize Filter registers */
  eth_mac->regs->FLOW_CONTROL = ETH_FLOW_CONTROL_DZPQ_Msk; /* Disable Zero Quanta Pause */
 800147e:	6823      	ldr	r3, [r4, #0]
 8001480:	2280      	movs	r2, #128	; 0x80
 8001482:	619a      	str	r2, [r3, #24]

  eth_mac->regs->OPERATION_MODE = (uint32_t)ETH_OPERATION_MODE_RSF_Msk |
 8001484:	6822      	ldr	r2, [r4, #0]
 8001486:	4914      	ldr	r1, [pc, #80]	; (80014d8 <XMC_ETH_MAC_InitEx+0x80>)
 8001488:	f241 0318 	movw	r3, #4120	; 0x1018
 800148c:	50d1      	str	r1, [r2, r3]
	                              (uint32_t)ETH_OPERATION_MODE_TSF_Msk |
	                              (uint32_t)ETH_OPERATION_MODE_OSF_Msk;

  /* Increase enhanced descriptor to 8 WORDS, required when the Advanced Time-Stamp feature or Full IPC Offload Engine is enabled */
  eth_mac->regs->BUS_MODE = (uint32_t)ETH_BUS_MODE_ATDS_Msk |
 800148e:	6823      	ldr	r3, [r4, #0]
 8001490:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8001494:	4a11      	ldr	r2, [pc, #68]	; (80014dc <XMC_ETH_MAC_InitEx+0x84>)
 8001496:	601a      	str	r2, [r3, #0]
	                        (uint32_t)ETH_BUS_MODE_AAL_Msk | /* the AHB interface generates all bursts aligned to the start address LS bits */
	                        (uint32_t)ETH_BUS_MODE_FB_Msk | /* DMA attempts to execute fixed-length Burst transfers on the AHB Master interface */
	                        (uint32_t)(0x20 << ETH_BUS_MODE_PBL_Pos); /* maximum Burst length */

  /* Initialize DMA Descriptors */
  XMC_ETH_MAC_InitRxDescriptors(eth_mac);
 8001498:	4620      	mov	r0, r4
 800149a:	f7ff ff7d 	bl	8001398 <XMC_ETH_MAC_InitRxDescriptors>
  XMC_ETH_MAC_InitTxDescriptors(eth_mac);
 800149e:	4620      	mov	r0, r4
 80014a0:	f7ff ffac 	bl	80013fc <XMC_ETH_MAC_InitTxDescriptors>

  /* Clear interrupts */
  eth_mac->regs->STATUS = 0xFFFFFFFFUL;
 80014a4:	6822      	ldr	r2, [r4, #0]
 80014a6:	f04f 31ff 	mov.w	r1, #4294967295
 80014aa:	f241 0314 	movw	r3, #4116	; 0x1014
 80014ae:	50d1      	str	r1, [r2, r3]

  /* Disable MMC interrupt events */
  eth_mac->regs->MMC_TRANSMIT_INTERRUPT_MASK = ETH_MAC_DISABLE_MMC_INTERRUPT_MSK;
 80014b0:	6822      	ldr	r2, [r4, #0]
 80014b2:	f06f 437c 	mvn.w	r3, #4227858432	; 0xfc000000
 80014b6:	f8c2 3110 	str.w	r3, [r2, #272]	; 0x110
  eth_mac->regs->MMC_RECEIVE_INTERRUPT_MASK = ETH_MAC_DISABLE_MMC_INTERRUPT_MSK;
 80014ba:	6822      	ldr	r2, [r4, #0]
 80014bc:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
  eth_mac->regs->MMC_IPC_RECEIVE_INTERRUPT_MASK = ETH_MAC_DISABLE_MMC_IPC_RECEIVE_INTERRUPT_MSK;
 80014c0:	6823      	ldr	r3, [r4, #0]
 80014c2:	f06f 22c0 	mvn.w	r2, #3221274624	; 0xc000c000
 80014c6:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200

  /* Disable PMT and timestamp interrupt events */
  eth_mac->regs->INTERRUPT_MASK = ETH_INTERRUPT_MASK_PMTIM_Msk | ETH_INTERRUPT_MASK_TSIM_Msk;
 80014ca:	6823      	ldr	r3, [r4, #0]
 80014cc:	f44f 7202 	mov.w	r2, #520	; 0x208
 80014d0:	63da      	str	r2, [r3, #60]	; 0x3c

  eth_mac->frame_end = NULL;
 80014d2:	2300      	movs	r3, #0
 80014d4:	6223      	str	r3, [r4, #32]
 80014d6:	bd10      	pop	{r4, pc}
 80014d8:	02200004 	.word	0x02200004
 80014dc:	02012080 	.word	0x02012080

080014e0 <XMC_ETH_MAC_GetRxFrameSize>:
uint32_t XMC_ETH_MAC_GetRxFrameSize(XMC_ETH_MAC_t *const eth_mac)
{
  uint32_t status;
  uint32_t len = 0U;

  status = eth_mac->rx_desc[eth_mac->rx_index].status;
 80014e0:	f890 3027 	ldrb.w	r3, [r0, #39]	; 0x27
 80014e4:	6902      	ldr	r2, [r0, #16]
 80014e6:	015b      	lsls	r3, r3, #5
 80014e8:	58d0      	ldr	r0, [r2, r3]

  if (status & ETH_MAC_DMA_RDES0_OWN)
 80014ea:	2800      	cmp	r0, #0
 80014ec:	db08      	blt.n	8001500 <XMC_ETH_MAC_GetRxFrameSize+0x20>
  {
    /* Owned by DMA */
    len = 0U;
  }
  else if (((status & ETH_MAC_DMA_RDES0_ES) != 0U) ||
           ((status & ETH_MAC_DMA_RDES0_FS) == 0U) ||
 80014ee:	f400 4303 	and.w	r3, r0, #33536	; 0x8300
  if (status & ETH_MAC_DMA_RDES0_OWN)
  {
    /* Owned by DMA */
    len = 0U;
  }
  else if (((status & ETH_MAC_DMA_RDES0_ES) != 0U) ||
 80014f2:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 80014f6:	d105      	bne.n	8001504 <XMC_ETH_MAC_GetRxFrameSize+0x24>
    len = 0xFFFFFFFFU;
  }
  else 
  {
    /* Subtract CRC */
    len = ((status & ETH_MAC_DMA_RDES0_FL) >> 16U) - 4U;
 80014f8:	f3c0 400d 	ubfx	r0, r0, #16, #14
 80014fc:	3804      	subs	r0, #4
 80014fe:	4770      	bx	lr
  status = eth_mac->rx_desc[eth_mac->rx_index].status;

  if (status & ETH_MAC_DMA_RDES0_OWN)
  {
    /* Owned by DMA */
    len = 0U;
 8001500:	2000      	movs	r0, #0
 8001502:	4770      	bx	lr
  else if (((status & ETH_MAC_DMA_RDES0_ES) != 0U) ||
           ((status & ETH_MAC_DMA_RDES0_FS) == 0U) ||
           ((status & ETH_MAC_DMA_RDES0_LS) == 0U)) 
  {
    /* Error, this block is invalid */
    len = 0xFFFFFFFFU;
 8001504:	f04f 30ff 	mov.w	r0, #4294967295
    /* Subtract CRC */
    len = ((status & ETH_MAC_DMA_RDES0_FL) >> 16U) - 4U;
  }

  return len;
}
 8001508:	4770      	bx	lr
 800150a:	bf00      	nop

0800150c <XMC_ETH_MAC_SetManagmentClockDivider>:
 * \par<b>Related APIs:</b><BR>
 * XMC_SCU_CLOCK_GetUsbPllClockFrequency() \n\n\n
 */
__STATIC_INLINE uint32_t XMC_SCU_CLOCK_GetSystemClockFrequency(void)
{
  return SystemCoreClock << ((SCU_CLK->CPUCLKCR & SCU_CLK_CPUCLKCR_CPUDIV_Msk) >> SCU_CLK_CPUCLKCR_CPUDIV_Pos);
 800150c:	4b19      	ldr	r3, [pc, #100]	; (8001574 <XMC_ETH_MAC_SetManagmentClockDivider+0x68>)
 800150e:	691a      	ldr	r2, [r3, #16]
 8001510:	f002 0201 	and.w	r2, r2, #1
 8001514:	4b18      	ldr	r3, [pc, #96]	; (8001578 <XMC_ETH_MAC_SetManagmentClockDivider+0x6c>)
 8001516:	681b      	ldr	r3, [r3, #0]
 8001518:	4093      	lsls	r3, r2
 * \par<b>Related APIs:</b><BR>
 * XMC_SCU_CLOCK_GetSystemClockFrequency() \n\n\n
 */
__STATIC_INLINE uint32_t XMC_SCU_CLOCK_GetEthernetClockFrequency(void)
{
  return XMC_SCU_CLOCK_GetSystemClockFrequency() >> 1U;
 800151a:	085b      	lsrs	r3, r3, #1
  __IO uint32_t *reg;

  eth_mac_clk = XMC_SCU_CLOCK_GetEthernetClockFrequency();
  status = XMC_ETH_MAC_STATUS_OK;

  reg = &(eth_mac->regs->GMII_ADDRESS);
 800151c:	6801      	ldr	r1, [r0, #0]
  if (eth_mac_clk <= XMC_ETH_MAC_CLK_SPEED_35MHZ)
 800151e:	4a17      	ldr	r2, [pc, #92]	; (800157c <XMC_ETH_MAC_SetManagmentClockDivider+0x70>)
 8001520:	4293      	cmp	r3, r2
 8001522:	d803      	bhi.n	800152c <XMC_ETH_MAC_SetManagmentClockDivider+0x20>
  {
    *reg = XMC_ETH_MAC_MDC_DIVIDER_16;
 8001524:	2308      	movs	r3, #8
 8001526:	610b      	str	r3, [r1, #16]
  uint32_t eth_mac_clk;
  XMC_ETH_MAC_STATUS_t status;
  __IO uint32_t *reg;

  eth_mac_clk = XMC_SCU_CLOCK_GetEthernetClockFrequency();
  status = XMC_ETH_MAC_STATUS_OK;
 8001528:	2000      	movs	r0, #0
 800152a:	4770      	bx	lr
  reg = &(eth_mac->regs->GMII_ADDRESS);
  if (eth_mac_clk <= XMC_ETH_MAC_CLK_SPEED_35MHZ)
  {
    *reg = XMC_ETH_MAC_MDC_DIVIDER_16;
  }
  else if (eth_mac_clk <= XMC_ETH_MAC_CLK_SPEED_60MHZ)
 800152c:	4a14      	ldr	r2, [pc, #80]	; (8001580 <XMC_ETH_MAC_SetManagmentClockDivider+0x74>)
 800152e:	4293      	cmp	r3, r2
 8001530:	d803      	bhi.n	800153a <XMC_ETH_MAC_SetManagmentClockDivider+0x2e>
  {
    *reg = XMC_ETH_MAC_MDC_DIVIDER_26;
 8001532:	230c      	movs	r3, #12
 8001534:	610b      	str	r3, [r1, #16]
  uint32_t eth_mac_clk;
  XMC_ETH_MAC_STATUS_t status;
  __IO uint32_t *reg;

  eth_mac_clk = XMC_SCU_CLOCK_GetEthernetClockFrequency();
  status = XMC_ETH_MAC_STATUS_OK;
 8001536:	2000      	movs	r0, #0
 8001538:	4770      	bx	lr
  }
  else if (eth_mac_clk <= XMC_ETH_MAC_CLK_SPEED_60MHZ)
  {
    *reg = XMC_ETH_MAC_MDC_DIVIDER_26;
  }
  else if (eth_mac_clk <= XMC_ETH_MAC_CLK_SPEED_100MHZ)
 800153a:	4a12      	ldr	r2, [pc, #72]	; (8001584 <XMC_ETH_MAC_SetManagmentClockDivider+0x78>)
 800153c:	4293      	cmp	r3, r2
 800153e:	d802      	bhi.n	8001546 <XMC_ETH_MAC_SetManagmentClockDivider+0x3a>
  {
    *reg = XMC_ETH_MAC_MDC_DIVIDER_42;
 8001540:	2000      	movs	r0, #0
 8001542:	6108      	str	r0, [r1, #16]
 8001544:	4770      	bx	lr
  }
  else if (eth_mac_clk <= XMC_ETH_MAC_CLK_SPEED_150MHZ)
 8001546:	4a10      	ldr	r2, [pc, #64]	; (8001588 <XMC_ETH_MAC_SetManagmentClockDivider+0x7c>)
 8001548:	4293      	cmp	r3, r2
 800154a:	d803      	bhi.n	8001554 <XMC_ETH_MAC_SetManagmentClockDivider+0x48>
  {
    *reg = XMC_ETH_MAC_MDC_DIVIDER_62;
 800154c:	2304      	movs	r3, #4
 800154e:	610b      	str	r3, [r1, #16]
  uint32_t eth_mac_clk;
  XMC_ETH_MAC_STATUS_t status;
  __IO uint32_t *reg;

  eth_mac_clk = XMC_SCU_CLOCK_GetEthernetClockFrequency();
  status = XMC_ETH_MAC_STATUS_OK;
 8001550:	2000      	movs	r0, #0
 8001552:	4770      	bx	lr
  }
  else if (eth_mac_clk <= XMC_ETH_MAC_CLK_SPEED_150MHZ)
  {
    *reg = XMC_ETH_MAC_MDC_DIVIDER_62;
  }
  else if (eth_mac_clk <= XMC_ETH_MAC_CLK_SPEED_200MHZ)
 8001554:	4a0d      	ldr	r2, [pc, #52]	; (800158c <XMC_ETH_MAC_SetManagmentClockDivider+0x80>)
 8001556:	4293      	cmp	r3, r2
 8001558:	d803      	bhi.n	8001562 <XMC_ETH_MAC_SetManagmentClockDivider+0x56>
  {
    *reg = XMC_ETH_MAC_MDC_DIVIDER_102;
 800155a:	2310      	movs	r3, #16
 800155c:	610b      	str	r3, [r1, #16]
  uint32_t eth_mac_clk;
  XMC_ETH_MAC_STATUS_t status;
  __IO uint32_t *reg;

  eth_mac_clk = XMC_SCU_CLOCK_GetEthernetClockFrequency();
  status = XMC_ETH_MAC_STATUS_OK;
 800155e:	2000      	movs	r0, #0
 8001560:	4770      	bx	lr
  }
  else if (eth_mac_clk <= XMC_ETH_MAC_CLK_SPEED_200MHZ)
  {
    *reg = XMC_ETH_MAC_MDC_DIVIDER_102;
  }
  else if (eth_mac_clk <= XMC_ETH_MAC_CLK_SPEED_250MHZ)
 8001562:	4a0b      	ldr	r2, [pc, #44]	; (8001590 <XMC_ETH_MAC_SetManagmentClockDivider+0x84>)
 8001564:	4293      	cmp	r3, r2
  {
    *reg = XMC_ETH_MAC_MDC_DIVIDER_124;
 8001566:	bf9d      	ittte	ls
 8001568:	2314      	movls	r3, #20
 800156a:	610b      	strls	r3, [r1, #16]
  uint32_t eth_mac_clk;
  XMC_ETH_MAC_STATUS_t status;
  __IO uint32_t *reg;

  eth_mac_clk = XMC_SCU_CLOCK_GetEthernetClockFrequency();
  status = XMC_ETH_MAC_STATUS_OK;
 800156c:	2000      	movls	r0, #0
  {
    *reg = XMC_ETH_MAC_MDC_DIVIDER_124;
  }
  else
  {
    status = XMC_ETH_MAC_STATUS_ERROR;
 800156e:	2002      	movhi	r0, #2
  }

  return status;
}
 8001570:	4770      	bx	lr
 8001572:	bf00      	nop
 8001574:	50004600 	.word	0x50004600
 8001578:	2000d570 	.word	0x2000d570
 800157c:	02160ec0 	.word	0x02160ec0
 8001580:	03938700 	.word	0x03938700
 8001584:	05f5e100 	.word	0x05f5e100
 8001588:	08f0d180 	.word	0x08f0d180
 800158c:	0bebc200 	.word	0x0bebc200
 8001590:	0ee6b280 	.word	0x0ee6b280

08001594 <XMC_ETH_MAC_Enable>:

/* ETH MAC enable */
void XMC_ETH_MAC_Enable(XMC_ETH_MAC_t *const eth_mac)
{
 8001594:	b508      	push	{r3, lr}
  XMC_UNUSED_ARG(eth_mac);

  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_ETH);
 8001596:	2004      	movs	r0, #4
 8001598:	f7ff fd2e 	bl	8000ff8 <XMC_SCU_CLOCK_EnableClock>
#if UC_DEVICE != XMC4500
  XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_ETH0);
#endif
  XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_ETH0);
 800159c:	4801      	ldr	r0, [pc, #4]	; (80015a4 <XMC_ETH_MAC_Enable+0x10>)
 800159e:	f7ff fced 	bl	8000f7c <XMC_SCU_RESET_DeassertPeripheralReset>
 80015a2:	bd08      	pop	{r3, pc}
 80015a4:	20000004 	.word	0x20000004

080015a8 <XMC_ETH_MAC_Init>:
  eth_mac->frame_end = NULL;
}

/* ETH MAC initialize */
XMC_ETH_MAC_STATUS_t XMC_ETH_MAC_Init(XMC_ETH_MAC_t *const eth_mac)
{
 80015a8:	b538      	push	{r3, r4, r5, lr}
 80015aa:	4604      	mov	r4, r0
  XMC_ETH_MAC_STATUS_t status;

  XMC_ASSERT("XMC_ETH_MAC_Init: eth_mac is invalid", XMC_ETH_MAC_IsValidModule(eth_mac->regs));

  XMC_ETH_MAC_Enable(eth_mac);
 80015ac:	f7ff fff2 	bl	8001594 <XMC_ETH_MAC_Enable>
  status = XMC_ETH_MAC_SetManagmentClockDivider(eth_mac);
 80015b0:	4620      	mov	r0, r4
 80015b2:	f7ff ffab 	bl	800150c <XMC_ETH_MAC_SetManagmentClockDivider>
 80015b6:	4605      	mov	r5, r0

  XMC_ETH_MAC_InitEx(eth_mac);
 80015b8:	4620      	mov	r0, r4
 80015ba:	f7ff ff4d 	bl	8001458 <XMC_ETH_MAC_InitEx>

  XMC_ETH_MAC_SetAddress(eth_mac, eth_mac->address);
 80015be:	68a2      	ldr	r2, [r4, #8]
 80015c0:	68e1      	ldr	r1, [r4, #12]
 * The function sets the MAC address by writing to the MAC_ADDRESS0_HIGH and
 * MAC_ADDRESS0_LOW registers.
 */
__STATIC_INLINE void XMC_ETH_MAC_SetAddress(XMC_ETH_MAC_t *const eth_mac, uint64_t addr)
{
  eth_mac->regs->MAC_ADDRESS0_HIGH = (uint32_t)(addr >> 32);
 80015c2:	6823      	ldr	r3, [r4, #0]
 80015c4:	6419      	str	r1, [r3, #64]	; 0x40
  eth_mac->regs->MAC_ADDRESS0_LOW = (uint32_t)addr;
 80015c6:	6823      	ldr	r3, [r4, #0]
 80015c8:	645a      	str	r2, [r3, #68]	; 0x44

  return status;
}
 80015ca:	4628      	mov	r0, r5
 80015cc:	bd38      	pop	{r3, r4, r5, pc}
 80015ce:	bf00      	nop

080015d0 <XMC_ETH_MAC_ReadPhy>:
  XMC_SCU_CLOCK_DisableClock(XMC_SCU_CLOCK_ETH);
}

/* Read physical layer and obtain status */
XMC_ETH_MAC_STATUS_t XMC_ETH_MAC_ReadPhy(XMC_ETH_MAC_t *eth_mac, uint8_t phy_addr, uint8_t reg_addr, uint16_t *data)
{
 80015d0:	b430      	push	{r4, r5}
  uint32_t retries;

  XMC_ASSERT("XMC_ETH_MAC_PhyRead: Parameter error", data != NULL);

  eth_mac->regs->GMII_ADDRESS = (uint32_t)((eth_mac->regs->GMII_ADDRESS & (uint32_t)ETH_GMII_ADDRESS_CR_Msk) |
 80015d2:	6805      	ldr	r5, [r0, #0]
 80015d4:	692c      	ldr	r4, [r5, #16]
 80015d6:	f004 043c 	and.w	r4, r4, #60	; 0x3c
 80015da:	f044 0401 	orr.w	r4, r4, #1
 80015de:	ea44 1282 	orr.w	r2, r4, r2, lsl #6
 80015e2:	ea42 21c1 	orr.w	r1, r2, r1, lsl #11
 80015e6:	6129      	str	r1, [r5, #16]

  /* Poll busy bit during max PHY_TIMEOUT time */
  retries = 0U;
  do
  {
    if ((eth_mac->regs->GMII_ADDRESS & ETH_GMII_ADDRESS_MB_Msk) == 0U)
 80015e8:	6800      	ldr	r0, [r0, #0]
 80015ea:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80015ee:	6901      	ldr	r1, [r0, #16]
 80015f0:	f011 0f01 	tst.w	r1, #1
 80015f4:	d103      	bne.n	80015fe <XMC_ETH_MAC_ReadPhy+0x2e>
    {
      *data = (uint16_t)(eth_mac->regs->GMII_DATA & ETH_GMII_DATA_MD_Msk);
 80015f6:	6942      	ldr	r2, [r0, #20]
 80015f8:	801a      	strh	r2, [r3, #0]
      return XMC_ETH_MAC_STATUS_OK;
 80015fa:	2000      	movs	r0, #0
 80015fc:	e002      	b.n	8001604 <XMC_ETH_MAC_ReadPhy+0x34>
    }
    ++retries;
  } while (retries < XMC_ETH_MAC_PHY_MAX_RETRIES);
 80015fe:	3a01      	subs	r2, #1
 8001600:	d1f5      	bne.n	80015ee <XMC_ETH_MAC_ReadPhy+0x1e>

  return XMC_ETH_MAC_STATUS_ERROR;
 8001602:	2002      	movs	r0, #2
}
 8001604:	bc30      	pop	{r4, r5}
 8001606:	4770      	bx	lr

08001608 <XMC_ETH_MAC_WritePhy>:

/* Write physical layer and return status */
XMC_ETH_MAC_STATUS_t XMC_ETH_MAC_WritePhy(XMC_ETH_MAC_t *eth_mac, uint8_t phy_addr, uint8_t reg_addr, uint16_t data)
{
 8001608:	b410      	push	{r4}
  uint32_t retries;

  eth_mac->regs->GMII_DATA  = data;
 800160a:	6804      	ldr	r4, [r0, #0]
 800160c:	6163      	str	r3, [r4, #20]
  eth_mac->regs->GMII_ADDRESS = (uint32_t)((eth_mac->regs->GMII_ADDRESS & (uint32_t)ETH_GMII_ADDRESS_CR_Msk) |
 800160e:	6804      	ldr	r4, [r0, #0]
 8001610:	6923      	ldr	r3, [r4, #16]
 8001612:	f003 033c 	and.w	r3, r3, #60	; 0x3c
 8001616:	f043 0303 	orr.w	r3, r3, #3
 800161a:	ea43 1282 	orr.w	r2, r3, r2, lsl #6
 800161e:	ea42 21c1 	orr.w	r1, r2, r1, lsl #11
 8001622:	6121      	str	r1, [r4, #16]

   /* Poll busy bit during max PHY_TIMEOUT time */
  retries = 0U;
  do
  {
    if ((eth_mac->regs->GMII_ADDRESS & ETH_GMII_ADDRESS_MB_Msk) == 0U)
 8001624:	6801      	ldr	r1, [r0, #0]
 8001626:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800162a:	690a      	ldr	r2, [r1, #16]
 800162c:	f012 0f01 	tst.w	r2, #1
 8001630:	d003      	beq.n	800163a <XMC_ETH_MAC_WritePhy+0x32>
    {
      return XMC_ETH_MAC_STATUS_OK;
    }
    ++retries;
  } while (retries < XMC_ETH_MAC_PHY_MAX_RETRIES);
 8001632:	3b01      	subs	r3, #1
 8001634:	d1f9      	bne.n	800162a <XMC_ETH_MAC_WritePhy+0x22>

  return XMC_ETH_MAC_STATUS_ERROR;
 8001636:	2002      	movs	r0, #2
 8001638:	e000      	b.n	800163c <XMC_ETH_MAC_WritePhy+0x34>
  retries = 0U;
  do
  {
    if ((eth_mac->regs->GMII_ADDRESS & ETH_GMII_ADDRESS_MB_Msk) == 0U)
    {
      return XMC_ETH_MAC_STATUS_OK;
 800163a:	2000      	movs	r0, #0
    }
    ++retries;
  } while (retries < XMC_ETH_MAC_PHY_MAX_RETRIES);

  return XMC_ETH_MAC_STATUS_ERROR;
}
 800163c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001640:	4770      	bx	lr
 8001642:	bf00      	nop

08001644 <XMC_ETH_MAC_EnableEvent>:
/* Enable event */
void XMC_ETH_MAC_EnableEvent(XMC_ETH_MAC_t *const eth_mac, uint32_t event)
{
  XMC_ASSERT("XMC_ETH_MAC_EnableDMAEvent: eth_mac is invalid", XMC_ETH_MAC_IsValidModule(eth_mac->regs));

  eth_mac->regs->INTERRUPT_MASK &= ~(event >> 16U);
 8001644:	6802      	ldr	r2, [r0, #0]
 8001646:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 8001648:	ea23 4311 	bic.w	r3, r3, r1, lsr #16
 800164c:	63d3      	str	r3, [r2, #60]	; 0x3c

  event &= (uint16_t)0x7fffU;
 800164e:	f3c1 030e 	ubfx	r3, r1, #0, #15
  if (XCM_ETH_MAC_IsNormalEvent(event))
 8001652:	f244 0245 	movw	r2, #16453	; 0x4045
 8001656:	4211      	tst	r1, r2
  {
  event |= (uint32_t)ETH_INTERRUPT_ENABLE_NIE_Msk;
 8001658:	bf18      	it	ne
 800165a:	f443 3380 	orrne.w	r3, r3, #65536	; 0x10000
  }

  if (XCM_ETH_MAC_IsAbnormalEvent(event))
 800165e:	f242 72ba 	movw	r2, #10170	; 0x27ba
 8001662:	4213      	tst	r3, r2
  {
  event |= (uint32_t)ETH_INTERRUPT_ENABLE_AIE_Msk;
 8001664:	bf18      	it	ne
 8001666:	f443 4300 	orrne.w	r3, r3, #32768	; 0x8000
  }

  eth_mac->regs->INTERRUPT_ENABLE |= event;
 800166a:	6800      	ldr	r0, [r0, #0]
 800166c:	f241 011c 	movw	r1, #4124	; 0x101c
 8001670:	5842      	ldr	r2, [r0, r1]
 8001672:	4313      	orrs	r3, r2
 8001674:	5043      	str	r3, [r0, r1]
 8001676:	4770      	bx	lr

08001678 <XMC_ETH_MAC_ClearEventStatus>:
/* Clear event status */
void XMC_ETH_MAC_ClearEventStatus(XMC_ETH_MAC_t *const eth_mac, uint32_t event)
{
  XMC_ASSERT("XMC_ETH_MAC_ClearEventStatus: eth_mac is invalid", XMC_ETH_MAC_IsValidModule(eth_mac->regs));

  if ((eth_mac->regs->STATUS & ETH_STATUS_NIS_Msk) != 0U)
 8001678:	6803      	ldr	r3, [r0, #0]
 800167a:	f241 0214 	movw	r2, #4116	; 0x1014
 800167e:	589a      	ldr	r2, [r3, r2]
 8001680:	f412 3f80 	tst.w	r2, #65536	; 0x10000
  {
    event |= (uint32_t)ETH_STATUS_NIS_Msk;
 8001684:	bf18      	it	ne
 8001686:	f441 3180 	orrne.w	r1, r1, #65536	; 0x10000
  }

  if ((eth_mac->regs->STATUS & ETH_STATUS_AIS_Msk) != 0U)
 800168a:	f241 0214 	movw	r2, #4116	; 0x1014
 800168e:	589a      	ldr	r2, [r3, r2]
 8001690:	f412 4f00 	tst.w	r2, #32768	; 0x8000
  {
    event |= (uint32_t)ETH_STATUS_AIS_Msk;
 8001694:	bf18      	it	ne
 8001696:	f441 4100 	orrne.w	r1, r1, #32768	; 0x8000
  }

  eth_mac->regs->STATUS = event & 0x0001FFFFU;
 800169a:	f3c1 0110 	ubfx	r1, r1, #0, #17
 800169e:	f241 0214 	movw	r2, #4116	; 0x1014
 80016a2:	5099      	str	r1, [r3, r2]
 80016a4:	4770      	bx	lr
 80016a6:	bf00      	nop

080016a8 <XMC_ETH_MAC_GetEventStatus>:
uint32_t XMC_ETH_MAC_GetEventStatus(const XMC_ETH_MAC_t *const eth_mac)
{
  uint32_t temp_status = 0;
  XMC_ASSERT("XMC_ETH_MAC_GetEventStatus: eth_mac is invalid", XMC_ETH_MAC_IsValidModule(eth_mac->regs));
  
  temp_status =  (eth_mac->regs->STATUS & (uint32_t)0x7ffUL);
 80016a8:	6802      	ldr	r2, [r0, #0]
 80016aa:	f241 0314 	movw	r3, #4116	; 0x1014
 80016ae:	58d3      	ldr	r3, [r2, r3]

  return ((uint32_t)((eth_mac->regs->INTERRUPT_STATUS & (ETH_INTERRUPT_MASK_PMTIM_Msk | ETH_INTERRUPT_MASK_TSIM_Msk)) << 16U) |
 80016b0:	6b90      	ldr	r0, [r2, #56]	; 0x38
 80016b2:	f400 7002 	and.w	r0, r0, #520	; 0x208
uint32_t XMC_ETH_MAC_GetEventStatus(const XMC_ETH_MAC_t *const eth_mac)
{
  uint32_t temp_status = 0;
  XMC_ASSERT("XMC_ETH_MAC_GetEventStatus: eth_mac is invalid", XMC_ETH_MAC_IsValidModule(eth_mac->regs));
  
  temp_status =  (eth_mac->regs->STATUS & (uint32_t)0x7ffUL);
 80016b6:	f3c3 030a 	ubfx	r3, r3, #0, #11

  return ((uint32_t)((eth_mac->regs->INTERRUPT_STATUS & (ETH_INTERRUPT_MASK_PMTIM_Msk | ETH_INTERRUPT_MASK_TSIM_Msk)) << 16U) |
      temp_status);
}
 80016ba:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 80016be:	4770      	bx	lr

080016c0 <XMC_ETH_MAC_ReturnRxDescriptor>:

/* Return RX descriptor */
void XMC_ETH_MAC_ReturnRxDescriptor(XMC_ETH_MAC_t *const eth_mac)
{
  eth_mac->rx_desc[eth_mac->rx_index].status |= ETH_MAC_DMA_RDES0_OWN;
 80016c0:	f890 3027 	ldrb.w	r3, [r0, #39]	; 0x27
 80016c4:	015b      	lsls	r3, r3, #5
 80016c6:	6901      	ldr	r1, [r0, #16]
 80016c8:	58ca      	ldr	r2, [r1, r3]
 80016ca:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 80016ce:	50ca      	str	r2, [r1, r3]
  eth_mac->rx_index++;
 80016d0:	f890 3027 	ldrb.w	r3, [r0, #39]	; 0x27
 80016d4:	3301      	adds	r3, #1
 80016d6:	b2db      	uxtb	r3, r3
 80016d8:	f880 3027 	strb.w	r3, [r0, #39]	; 0x27
  if (eth_mac->rx_index == eth_mac->num_rx_buf)
 80016dc:	f890 2024 	ldrb.w	r2, [r0, #36]	; 0x24
 80016e0:	429a      	cmp	r2, r3
  {
    eth_mac->rx_index = 0U;
 80016e2:	bf04      	itt	eq
 80016e4:	2300      	moveq	r3, #0
 80016e6:	f880 3027 	strbeq.w	r3, [r0, #39]	; 0x27
 80016ea:	4770      	bx	lr

080016ec <XMC_ETH_MAC_ReturnTxDescriptor>:
}

/* Return TX descriptor */
void XMC_ETH_MAC_ReturnTxDescriptor(XMC_ETH_MAC_t *const eth_mac)
{
  eth_mac->tx_ts_index = eth_mac->tx_index;
 80016ec:	f890 3026 	ldrb.w	r3, [r0, #38]	; 0x26
 80016f0:	f880 3028 	strb.w	r3, [r0, #40]	; 0x28

  eth_mac->tx_desc[eth_mac->tx_index].status |= ETH_MAC_DMA_TDES0_CIC |ETH_MAC_DMA_TDES0_OWN;
 80016f4:	015b      	lsls	r3, r3, #5
 80016f6:	6941      	ldr	r1, [r0, #20]
 80016f8:	58ca      	ldr	r2, [r1, r3]
 80016fa:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 80016fe:	f442 0240 	orr.w	r2, r2, #12582912	; 0xc00000
 8001702:	50ca      	str	r2, [r1, r3]
  eth_mac->tx_index++;
 8001704:	f890 3026 	ldrb.w	r3, [r0, #38]	; 0x26
 8001708:	3301      	adds	r3, #1
 800170a:	b2db      	uxtb	r3, r3
 800170c:	f880 3026 	strb.w	r3, [r0, #38]	; 0x26
  if (eth_mac->tx_index == eth_mac->num_tx_buf)
 8001710:	f890 2025 	ldrb.w	r2, [r0, #37]	; 0x25
 8001714:	429a      	cmp	r2, r3
  {
    eth_mac->tx_index = 0U;
 8001716:	bf04      	itt	eq
 8001718:	2300      	moveq	r3, #0
 800171a:	f880 3026 	strbeq.w	r3, [r0, #38]	; 0x26
  } 

  eth_mac->frame_end = NULL;
 800171e:	2300      	movs	r3, #0
 8001720:	6203      	str	r3, [r0, #32]
 8001722:	4770      	bx	lr

08001724 <XMC_ETH_PHY_Reset>:
  return status;
}

/* Reset */
int32_t XMC_ETH_PHY_Reset(XMC_ETH_MAC_t *const eth_mac, uint8_t phy_addr)
{
 8001724:	b570      	push	{r4, r5, r6, lr}
 8001726:	b082      	sub	sp, #8
 8001728:	4604      	mov	r4, r0
 800172a:	460d      	mov	r5, r1
  int32_t status;
  uint16_t reg_bmcr;

  /* Reset PHY*/
  status = (int32_t)XMC_ETH_MAC_WritePhy(eth_mac, phy_addr, REG_BMCR, BMCR_RESET);
 800172c:	2200      	movs	r2, #0
 800172e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8001732:	f7ff ff69 	bl	8001608 <XMC_ETH_MAC_WritePhy>
 8001736:	4603      	mov	r3, r0
  if (status == (int32_t)XMC_ETH_PHY_STATUS_OK)
 8001738:	b95b      	cbnz	r3, 8001752 <XMC_ETH_PHY_Reset+0x2e>
  {      
    /* Wait for the reset to complete */
    do 
    {
      status = XMC_ETH_MAC_ReadPhy(eth_mac, phy_addr, REG_BMCR, &reg_bmcr);
 800173a:	2600      	movs	r6, #0
 800173c:	4620      	mov	r0, r4
 800173e:	4629      	mov	r1, r5
 8001740:	4632      	mov	r2, r6
 8001742:	f10d 0306 	add.w	r3, sp, #6
 8001746:	f7ff ff43 	bl	80015d0 <XMC_ETH_MAC_ReadPhy>
    } while ((reg_bmcr & BMCR_RESET) != 0);
 800174a:	f9bd 3006 	ldrsh.w	r3, [sp, #6]
 800174e:	2b00      	cmp	r3, #0
 8001750:	dbf4      	blt.n	800173c <XMC_ETH_PHY_Reset+0x18>
  }
    
  return status;
}
 8001752:	b002      	add	sp, #8
 8001754:	bd70      	pop	{r4, r5, r6, pc}
 8001756:	bf00      	nop

08001758 <XMC_ETH_PHY_Init>:
  return (int32_t)status;
}

/* PHY initialize */
int32_t XMC_ETH_PHY_Init(XMC_ETH_MAC_t *const eth_mac, uint8_t phy_addr, const XMC_ETH_PHY_CONFIG_t *const config)
{
 8001758:	b570      	push	{r4, r5, r6, lr}
 800175a:	b082      	sub	sp, #8
 800175c:	4606      	mov	r6, r0
 800175e:	460d      	mov	r5, r1
 8001760:	4614      	mov	r4, r2
  uint16_t phy_id1;
  uint16_t phy_id2;
  XMC_ETH_PHY_STATUS_t status;

  /* Check Device Identification. */
  if ((XMC_ETH_MAC_ReadPhy(eth_mac, phy_addr, REG_PHYIDR1, &phy_id1) == XMC_ETH_MAC_STATUS_OK) &&
 8001762:	2202      	movs	r2, #2
 8001764:	ab01      	add	r3, sp, #4
 8001766:	f7ff ff33 	bl	80015d0 <XMC_ETH_MAC_ReadPhy>
 800176a:	2800      	cmp	r0, #0
 800176c:	d13a      	bne.n	80017e4 <XMC_ETH_PHY_Init+0x8c>
      (XMC_ETH_MAC_ReadPhy(eth_mac, phy_addr, REG_PHYIDR2, &phy_id2) == XMC_ETH_MAC_STATUS_OK))
 800176e:	4630      	mov	r0, r6
 8001770:	4629      	mov	r1, r5
 8001772:	2203      	movs	r2, #3
 8001774:	f10d 0306 	add.w	r3, sp, #6
 8001778:	f7ff ff2a 	bl	80015d0 <XMC_ETH_MAC_ReadPhy>
  uint16_t phy_id1;
  uint16_t phy_id2;
  XMC_ETH_PHY_STATUS_t status;

  /* Check Device Identification. */
  if ((XMC_ETH_MAC_ReadPhy(eth_mac, phy_addr, REG_PHYIDR1, &phy_id1) == XMC_ETH_MAC_STATUS_OK) &&
 800177c:	bba0      	cbnz	r0, 80017e8 <XMC_ETH_PHY_Init+0x90>
      (XMC_ETH_MAC_ReadPhy(eth_mac, phy_addr, REG_PHYIDR2, &phy_id2) == XMC_ETH_MAC_STATUS_OK))
  {
    if ((phy_id1 == PHY_ID1) && ((phy_id2 & (uint16_t)0xfff0) == PHY_ID2))
 800177e:	f8bd 3004 	ldrh.w	r3, [sp, #4]
 8001782:	2b22      	cmp	r3, #34	; 0x22
 8001784:	d132      	bne.n	80017ec <XMC_ETH_PHY_Init+0x94>
 8001786:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 800178a:	f023 030f 	bic.w	r3, r3, #15
 800178e:	b29b      	uxth	r3, r3
 8001790:	f5b3 5fab 	cmp.w	r3, #5472	; 0x1560
 8001794:	d01e      	beq.n	80017d4 <XMC_ETH_PHY_Init+0x7c>
    {
      status = XMC_ETH_PHY_STATUS_OK;
    }
    else
    {
      status = XMC_ETH_PHY_STATUS_ERROR_DEVICE_ID;
 8001796:	2303      	movs	r3, #3
 8001798:	e029      	b.n	80017ee <XMC_ETH_PHY_Init+0x96>
    status = XMC_ETH_PHY_Reset(eth_mac, phy_addr);
    
    if (status == (int32_t)XMC_ETH_PHY_STATUS_OK)
    {
      reg_bmcr = 0U;
      if (config->speed == XMC_ETH_LINK_SPEED_100M)
 800179a:	8863      	ldrh	r3, [r4, #2]
      {
        reg_bmcr |= BMCR_SPEED_SEL;
 800179c:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 80017a0:	bf14      	ite	ne
 80017a2:	2300      	movne	r3, #0
 80017a4:	f44f 5300 	moveq.w	r3, #8192	; 0x2000
      }

      if (config->duplex == XMC_ETH_LINK_DUPLEX_FULL)
 80017a8:	88a2      	ldrh	r2, [r4, #4]
 80017aa:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
      {
        reg_bmcr |= BMCR_DUPLEX;
 80017ae:	bf04      	itt	eq
 80017b0:	f443 7380 	orreq.w	r3, r3, #256	; 0x100
 80017b4:	b29b      	uxtheq	r3, r3
      }

      if (config->enable_auto_negotiate == true)
 80017b6:	79a2      	ldrb	r2, [r4, #6]
 80017b8:	b10a      	cbz	r2, 80017be <XMC_ETH_PHY_Init+0x66>
      {
        reg_bmcr |= BMCR_ANEG_EN;
 80017ba:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
      }

      if (config->enable_loop_back == true)
 80017be:	79e2      	ldrb	r2, [r4, #7]
 80017c0:	b10a      	cbz	r2, 80017c6 <XMC_ETH_PHY_Init+0x6e>
      {
        reg_bmcr |= BMCR_LOOPBACK;
 80017c2:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
      }

      status = (int32_t)XMC_ETH_MAC_WritePhy(eth_mac, phy_addr, REG_BMCR, reg_bmcr);
 80017c6:	4630      	mov	r0, r6
 80017c8:	4629      	mov	r1, r5
 80017ca:	2200      	movs	r2, #0
 80017cc:	f7ff ff1c 	bl	8001608 <XMC_ETH_MAC_WritePhy>
 80017d0:	4603      	mov	r3, r0
 80017d2:	e00c      	b.n	80017ee <XMC_ETH_PHY_Init+0x96>

  status = XMC_ETH_PHY_IsDeviceIdValid(eth_mac, phy_addr);

  if (status == (int32_t)XMC_ETH_PHY_STATUS_OK)
  {
    status = XMC_ETH_PHY_Reset(eth_mac, phy_addr);
 80017d4:	4630      	mov	r0, r6
 80017d6:	4629      	mov	r1, r5
 80017d8:	f7ff ffa4 	bl	8001724 <XMC_ETH_PHY_Reset>
    
    if (status == (int32_t)XMC_ETH_PHY_STATUS_OK)
 80017dc:	4603      	mov	r3, r0
 80017de:	2800      	cmp	r0, #0
 80017e0:	d0db      	beq.n	800179a <XMC_ETH_PHY_Init+0x42>
 80017e2:	e004      	b.n	80017ee <XMC_ETH_PHY_Init+0x96>
      status = XMC_ETH_PHY_STATUS_ERROR_DEVICE_ID;
    }
  }
  else
  {
    status = XMC_ETH_PHY_STATUS_ERROR_TIMEOUT;
 80017e4:	2304      	movs	r3, #4
 80017e6:	e002      	b.n	80017ee <XMC_ETH_PHY_Init+0x96>
 80017e8:	2304      	movs	r3, #4
 80017ea:	e000      	b.n	80017ee <XMC_ETH_PHY_Init+0x96>
    {
      status = XMC_ETH_PHY_STATUS_OK;
    }
    else
    {
      status = XMC_ETH_PHY_STATUS_ERROR_DEVICE_ID;
 80017ec:	2303      	movs	r3, #3
      status = (int32_t)XMC_ETH_MAC_WritePhy(eth_mac, phy_addr, REG_BMCR, reg_bmcr);
    }
  }

  return status;
}
 80017ee:	4618      	mov	r0, r3
 80017f0:	b002      	add	sp, #8
 80017f2:	bd70      	pop	{r4, r5, r6, pc}

080017f4 <XMC_ETH_PHY_GetLinkStatus>:
  return status;
}

/* Get link status */
XMC_ETH_LINK_STATUS_t XMC_ETH_PHY_GetLinkStatus(XMC_ETH_MAC_t *const eth_mac, uint8_t phy_addr)
{
 80017f4:	b500      	push	{lr}
 80017f6:	b083      	sub	sp, #12
  uint16_t val;

  XMC_ETH_MAC_ReadPhy(eth_mac, phy_addr, REG_BMSR, &val);
 80017f8:	2201      	movs	r2, #1
 80017fa:	f10d 0306 	add.w	r3, sp, #6
 80017fe:	f7ff fee7 	bl	80015d0 <XMC_ETH_MAC_ReadPhy>

  return (XMC_ETH_LINK_STATUS_t)((val & BMSR_LINK_STAT) ? XMC_ETH_LINK_STATUS_UP : XMC_ETH_LINK_STATUS_DOWN);
 8001802:	f8bd 0006 	ldrh.w	r0, [sp, #6]
}
 8001806:	f3c0 0080 	ubfx	r0, r0, #2, #1
 800180a:	b003      	add	sp, #12
 800180c:	f85d fb04 	ldr.w	pc, [sp], #4

08001810 <XMC_ETH_PHY_GetLinkSpeed>:

/* Get link speed */
XMC_ETH_LINK_SPEED_t XMC_ETH_PHY_GetLinkSpeed(XMC_ETH_MAC_t *const eth_mac, uint8_t phy_addr)
{
 8001810:	b500      	push	{lr}
 8001812:	b083      	sub	sp, #12
  uint16_t val;

  XMC_ETH_MAC_ReadPhy(eth_mac, phy_addr, REG_PHYCTRL1, &val);
 8001814:	221e      	movs	r2, #30
 8001816:	f10d 0306 	add.w	r3, sp, #6
 800181a:	f7ff fed9 	bl	80015d0 <XMC_ETH_MAC_ReadPhy>

  return (XMC_ETH_LINK_SPEED_t)(((val & PHYCTRL1_OPMODE_SPEED) - 1U) ? XMC_ETH_LINK_SPEED_100M : XMC_ETH_LINK_SPEED_10M);
 800181e:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8001822:	f003 0303 	and.w	r3, r3, #3
 8001826:	2b01      	cmp	r3, #1
}
 8001828:	bf14      	ite	ne
 800182a:	f44f 4080 	movne.w	r0, #16384	; 0x4000
 800182e:	2000      	moveq	r0, #0
 8001830:	b003      	add	sp, #12
 8001832:	f85d fb04 	ldr.w	pc, [sp], #4
 8001836:	bf00      	nop

08001838 <XMC_ETH_PHY_GetLinkDuplex>:

/* Get link duplex settings */
XMC_ETH_LINK_DUPLEX_t XMC_ETH_PHY_GetLinkDuplex(XMC_ETH_MAC_t *const eth_mac, uint8_t phy_addr)
{
 8001838:	b500      	push	{lr}
 800183a:	b083      	sub	sp, #12
  uint16_t val;

  XMC_ETH_MAC_ReadPhy(eth_mac, phy_addr, REG_PHYCTRL1, &val);
 800183c:	221e      	movs	r2, #30
 800183e:	f10d 0306 	add.w	r3, sp, #6
 8001842:	f7ff fec5 	bl	80015d0 <XMC_ETH_MAC_ReadPhy>

  return (XMC_ETH_LINK_DUPLEX_t)((val & PHYCTRL1_OPMODE_DUPLEX) ? XMC_ETH_LINK_DUPLEX_FULL : XMC_ETH_LINK_DUPLEX_HALF);
 8001846:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 800184a:	f003 0304 	and.w	r3, r3, #4
 800184e:	b29b      	uxth	r3, r3
 8001850:	2b00      	cmp	r3, #0
}
 8001852:	bf14      	ite	ne
 8001854:	f44f 6000 	movne.w	r0, #2048	; 0x800
 8001858:	2000      	moveq	r0, #0
 800185a:	b003      	add	sp, #12
 800185c:	f85d fb04 	ldr.w	pc, [sp], #4

08001860 <XMC_GPIO_SetHardwareControl>:
  port->IOCR[(uint32_t)pin >> 2U] &= ~(uint32_t)((uint32_t)PORT_IOCR_PC_Msk << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U)));
  port->IOCR[(uint32_t)pin >> 2U] |= (uint32_t)mode << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U));
}

void XMC_GPIO_SetHardwareControl(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_HWCTRL_t hwctrl)
{
 8001860:	b410      	push	{r4}
  XMC_ASSERT("XMC_GPIO_SetHardwareControl: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_SetHardwareControl: Invalid hwctrl", XMC_GPIO_CHECK_HWCTRL(hwctrl));

  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));
 8001862:	6f43      	ldr	r3, [r0, #116]	; 0x74
 8001864:	0049      	lsls	r1, r1, #1
 8001866:	2403      	movs	r4, #3
 8001868:	408c      	lsls	r4, r1
 800186a:	ea23 0304 	bic.w	r3, r3, r4
 800186e:	6743      	str	r3, [r0, #116]	; 0x74
  port->HWSEL |= (uint32_t)hwctrl << ((uint32_t)pin << 1U);
 8001870:	6f43      	ldr	r3, [r0, #116]	; 0x74
 8001872:	408a      	lsls	r2, r1
 8001874:	4313      	orrs	r3, r2
 8001876:	6743      	str	r3, [r0, #116]	; 0x74
}
 8001878:	f85d 4b04 	ldr.w	r4, [sp], #4
 800187c:	4770      	bx	lr
 800187e:	bf00      	nop

08001880 <XMC_RTC_Start>:
 8001880:	4a05      	ldr	r2, [pc, #20]	; (8001898 <XMC_RTC_Start+0x18>)
 8001882:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
/*
 * Enables RTC peripheral to start counting time
 */
void XMC_RTC_Start(void)
{
  while((XMC_SCU_GetMirrorStatus() & SCU_GENERAL_MIRRSTS_RTC_CTR_Msk) != 0U)
 8001886:	f413 7f80 	tst.w	r3, #256	; 0x100
 800188a:	d1fa      	bne.n	8001882 <XMC_RTC_Start+0x2>
  {
    /* check SCU_MIRRSTS to ensure that no transfer over serial interface is pending */
  }
  RTC->CTR |= (uint32_t)RTC_CTR_ENB_Msk;
 800188c:	4a03      	ldr	r2, [pc, #12]	; (800189c <XMC_RTC_Start+0x1c>)
 800188e:	6853      	ldr	r3, [r2, #4]
 8001890:	f043 0301 	orr.w	r3, r3, #1
 8001894:	6053      	str	r3, [r2, #4]
 8001896:	4770      	bx	lr
 8001898:	50004000 	.word	0x50004000
 800189c:	50004a00 	.word	0x50004a00

080018a0 <XMC_RTC_Stop>:
 80018a0:	4a05      	ldr	r2, [pc, #20]	; (80018b8 <XMC_RTC_Stop+0x18>)
 80018a2:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
/*
 * Disables RTC peripheral to start counting time
 */
void XMC_RTC_Stop(void)
{
  while((XMC_SCU_GetMirrorStatus() & SCU_GENERAL_MIRRSTS_RTC_CTR_Msk) != 0U)
 80018a6:	f413 7f80 	tst.w	r3, #256	; 0x100
 80018aa:	d1fa      	bne.n	80018a2 <XMC_RTC_Stop+0x2>
  {
    /* check SCU_MIRRSTS to ensure that no transfer over serial interface is pending */
  }
  RTC->CTR &= ~(uint32_t)RTC_CTR_ENB_Msk;
 80018ac:	4a03      	ldr	r2, [pc, #12]	; (80018bc <XMC_RTC_Stop+0x1c>)
 80018ae:	6853      	ldr	r3, [r2, #4]
 80018b0:	f023 0301 	bic.w	r3, r3, #1
 80018b4:	6053      	str	r3, [r2, #4]
 80018b6:	4770      	bx	lr
 80018b8:	50004000 	.word	0x50004000
 80018bc:	50004a00 	.word	0x50004a00

080018c0 <XMC_RTC_SetPrescaler>:
 80018c0:	4a06      	ldr	r2, [pc, #24]	; (80018dc <XMC_RTC_SetPrescaler+0x1c>)
 80018c2:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
 */
void XMC_RTC_SetPrescaler(uint16_t prescaler)
{
  XMC_ASSERT("XMC_RTC_SetPrescaler:Wrong prescaler value", (prescaler < XMC_RTC_MAXPRESCALER));
  
  while((XMC_SCU_GetMirrorStatus() & SCU_GENERAL_MIRRSTS_RTC_CTR_Msk) != 0U)
 80018c6:	f413 7f80 	tst.w	r3, #256	; 0x100
 80018ca:	d1fa      	bne.n	80018c2 <XMC_RTC_SetPrescaler+0x2>
  {
    /* check SCU_MIRRSTS to ensure that no transfer over serial interface is pending */
  }
  RTC->CTR = (RTC->CTR & ~(uint32_t)RTC_CTR_DIV_Msk) |
 80018cc:	4a04      	ldr	r2, [pc, #16]	; (80018e0 <XMC_RTC_SetPrescaler+0x20>)
 80018ce:	6853      	ldr	r3, [r2, #4]
 80018d0:	b29b      	uxth	r3, r3
 80018d2:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 80018d6:	6050      	str	r0, [r2, #4]
 80018d8:	4770      	bx	lr
 80018da:	bf00      	nop
 80018dc:	50004000 	.word	0x50004000
 80018e0:	50004a00 	.word	0x50004a00

080018e4 <XMC_RTC_SetTime>:
 80018e4:	4a09      	ldr	r2, [pc, #36]	; (800190c <XMC_RTC_SetTime+0x28>)
 80018e6:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
  XMC_ASSERT("XMC_RTC_SetTime:Wrong week day value", ((uint32_t)time->daysofweek < XMC_RTC_MAXDAYSOFWEEK));
  XMC_ASSERT("XMC_RTC_SetTime:Wrong month value", ((uint32_t)time->month < XMC_RTC_MAXMONTH));
  XMC_ASSERT("XMC_RTC_SetTime:Wrong year value", ((uint32_t)time->year < XMC_RTC_MAXYEAR));

  #if (XMC_RTC_INIT_SEQUENCE == 1U)
      while ((XMC_SCU_GetMirrorStatus() & SCU_GENERAL_MIRRSTS_RTC_TIM0_Msk) != 0U)
 80018ea:	f413 6f00 	tst.w	r3, #2048	; 0x800
 80018ee:	d1fa      	bne.n	80018e6 <XMC_RTC_SetTime+0x2>
      { 
         /* check SCU_MIRRSTS to ensure that no transfer over serial interface is pending */
      }
      RTC->TIM0 = time->raw0;
 80018f0:	6802      	ldr	r2, [r0, #0]
 80018f2:	4b07      	ldr	r3, [pc, #28]	; (8001910 <XMC_RTC_SetTime+0x2c>)
 80018f4:	621a      	str	r2, [r3, #32]
 80018f6:	4a05      	ldr	r2, [pc, #20]	; (800190c <XMC_RTC_SetTime+0x28>)
 80018f8:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
      
      while ((XMC_SCU_GetMirrorStatus() & SCU_GENERAL_MIRRSTS_RTC_TIM1_Msk) != 0U)
 80018fc:	f413 5f80 	tst.w	r3, #4096	; 0x1000
 8001900:	d1fa      	bne.n	80018f8 <XMC_RTC_SetTime+0x14>
      {
        /* check SCU_MIRRSTS to ensure that no transfer over serial interface is pending */
      }
      RTC->TIM1 = time->raw1;	     
 8001902:	6842      	ldr	r2, [r0, #4]
 8001904:	4b02      	ldr	r3, [pc, #8]	; (8001910 <XMC_RTC_SetTime+0x2c>)
 8001906:	625a      	str	r2, [r3, #36]	; 0x24
 8001908:	4770      	bx	lr
 800190a:	bf00      	nop
 800190c:	50004000 	.word	0x50004000
 8001910:	50004a00 	.word	0x50004a00

08001914 <XMC_RTC_GetTimeStdFormat>:

/*
 * Gets the RTC module time values in standard format
 */
void XMC_RTC_GetTimeStdFormat(struct tm *const stdtime)
{
 8001914:	b082      	sub	sp, #8
  XMC_RTC_TIME_t time;
  time.raw0 = RTC->TIM0;
 8001916:	4b12      	ldr	r3, [pc, #72]	; (8001960 <XMC_RTC_GetTimeStdFormat+0x4c>)
 8001918:	6a1a      	ldr	r2, [r3, #32]
 800191a:	9200      	str	r2, [sp, #0]
  time.raw1 = RTC->TIM1;
 800191c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  
  stdtime->tm_sec = (int8_t)time.seconds;
 800191e:	f89d 2000 	ldrb.w	r2, [sp]
 8001922:	f002 023f 	and.w	r2, r2, #63	; 0x3f
 8001926:	6002      	str	r2, [r0, #0]
  stdtime->tm_min = (int8_t)time.minutes;
 8001928:	f89d 2001 	ldrb.w	r2, [sp, #1]
 800192c:	f002 023f 	and.w	r2, r2, #63	; 0x3f
 8001930:	6042      	str	r2, [r0, #4]
  stdtime->tm_hour = (int8_t)time.hours;
 8001932:	f89d 2002 	ldrb.w	r2, [sp, #2]
 8001936:	f002 021f 	and.w	r2, r2, #31
 800193a:	6082      	str	r2, [r0, #8]
  stdtime->tm_mday = ((int8_t)time.days + (int8_t)1);
 800193c:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8001940:	f002 021f 	and.w	r2, r2, #31
 8001944:	3201      	adds	r2, #1
 8001946:	60c2      	str	r2, [r0, #12]
  stdtime->tm_mon = (int8_t)time.month;
 8001948:	f3c3 2203 	ubfx	r2, r3, #8, #4
 800194c:	6102      	str	r2, [r0, #16]
  stdtime->tm_year = (int32_t)time.year - (int32_t)XMC_RTC_YEAR_OFFSET;
 800194e:	0c1a      	lsrs	r2, r3, #16
 8001950:	f2a2 726c 	subw	r2, r2, #1900	; 0x76c
 8001954:	6142      	str	r2, [r0, #20]
  stdtime->tm_wday = (int8_t)time.daysofweek;
 8001956:	f003 0307 	and.w	r3, r3, #7
 800195a:	6183      	str	r3, [r0, #24]
}
 800195c:	b002      	add	sp, #8
 800195e:	4770      	bx	lr
 8001960:	50004a00 	.word	0x50004a00

08001964 <XMC_RTC_SetAlarm>:
 8001964:	4a09      	ldr	r2, [pc, #36]	; (800198c <XMC_RTC_SetAlarm+0x28>)
 8001966:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
  XMC_ASSERT("XMC_RTC_SetAlarm:Wrong days value", ((uint32_t)alarm->days < XMC_RTC_MAXDAYS));
  XMC_ASSERT("XMC_RTC_SetAlarm:Wrong month value", ((uint32_t)alarm->month < XMC_RTC_MAXMONTH));
  XMC_ASSERT("XMC_RTC_SetAlarm:Wrong year value", ((uint32_t)alarm->year < XMC_RTC_MAXYEAR));

  #if (XMC_RTC_INIT_SEQUENCE == 1U)
      while ((XMC_SCU_GetMirrorStatus() & SCU_GENERAL_MIRRSTS_RTC_ATIM0_Msk) != 0U)
 800196a:	f413 7f00 	tst.w	r3, #512	; 0x200
 800196e:	d1fa      	bne.n	8001966 <XMC_RTC_SetAlarm+0x2>
      {
        /* check SCU_MIRRSTS to ensure that no transfer over serial interface is pending */
      }
      RTC->ATIM0 = alarm->raw0;
 8001970:	6802      	ldr	r2, [r0, #0]
 8001972:	4b07      	ldr	r3, [pc, #28]	; (8001990 <XMC_RTC_SetAlarm+0x2c>)
 8001974:	619a      	str	r2, [r3, #24]
 8001976:	4a05      	ldr	r2, [pc, #20]	; (800198c <XMC_RTC_SetAlarm+0x28>)
 8001978:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
      
      while ((XMC_SCU_GetMirrorStatus() & SCU_GENERAL_MIRRSTS_RTC_ATIM1_Msk) != 0U)
 800197c:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8001980:	d1fa      	bne.n	8001978 <XMC_RTC_SetAlarm+0x14>
      {
        /* check SCU_MIRRSTS to ensure that no transfer over serial interface is pending */
      }
      RTC->ATIM1 = alarm->raw1; 
 8001982:	6842      	ldr	r2, [r0, #4]
 8001984:	4b02      	ldr	r3, [pc, #8]	; (8001990 <XMC_RTC_SetAlarm+0x2c>)
 8001986:	61da      	str	r2, [r3, #28]
 8001988:	4770      	bx	lr
 800198a:	bf00      	nop
 800198c:	50004000 	.word	0x50004000
 8001990:	50004a00 	.word	0x50004a00

08001994 <XMC_RTC_GetAlarmStdFormat>:

/*
 * Gets the RTC module alarm time value in standard format
 */
void XMC_RTC_GetAlarmStdFormat(struct tm *const stdtime)
{
 8001994:	b082      	sub	sp, #8
  XMC_RTC_ALARM_t alarm;
  
  alarm.raw0 = RTC->ATIM0;
 8001996:	4b11      	ldr	r3, [pc, #68]	; (80019dc <XMC_RTC_GetAlarmStdFormat+0x48>)
 8001998:	699a      	ldr	r2, [r3, #24]
 800199a:	9200      	str	r2, [sp, #0]
  alarm.raw1 = RTC->ATIM1;
 800199c:	69db      	ldr	r3, [r3, #28]

  stdtime->tm_sec = (int8_t)alarm.seconds;
 800199e:	f89d 2000 	ldrb.w	r2, [sp]
 80019a2:	f002 023f 	and.w	r2, r2, #63	; 0x3f
 80019a6:	6002      	str	r2, [r0, #0]
  stdtime->tm_min = (int8_t)alarm.minutes;
 80019a8:	f89d 2001 	ldrb.w	r2, [sp, #1]
 80019ac:	f002 023f 	and.w	r2, r2, #63	; 0x3f
 80019b0:	6042      	str	r2, [r0, #4]
  stdtime->tm_hour = (int8_t)alarm.hours;
 80019b2:	f89d 2002 	ldrb.w	r2, [sp, #2]
 80019b6:	f002 021f 	and.w	r2, r2, #31
 80019ba:	6082      	str	r2, [r0, #8]
  stdtime->tm_mday = ((int8_t)alarm.days + (int8_t)1);
 80019bc:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80019c0:	f002 021f 	and.w	r2, r2, #31
 80019c4:	3201      	adds	r2, #1
 80019c6:	60c2      	str	r2, [r0, #12]
  stdtime->tm_mon = (int8_t)alarm.month;
 80019c8:	f3c3 2203 	ubfx	r2, r3, #8, #4
 80019cc:	6102      	str	r2, [r0, #16]
  stdtime->tm_year = (int32_t)alarm.year - (int32_t)XMC_RTC_YEAR_OFFSET;
 80019ce:	0c1b      	lsrs	r3, r3, #16
 80019d0:	f2a3 736c 	subw	r3, r3, #1900	; 0x76c
 80019d4:	6143      	str	r3, [r0, #20]
}
 80019d6:	b002      	add	sp, #8
 80019d8:	4770      	bx	lr
 80019da:	bf00      	nop
 80019dc:	50004a00 	.word	0x50004a00

080019e0 <XMC_UART_CH_Init>:
/*********************************************************************************************************************
 * API IMPLEMENTATION
 *********************************************************************************************************************/

void XMC_UART_CH_Init(XMC_USIC_CH_t *channel, const XMC_UART_CH_CONFIG_t *const config)
{
 80019e0:	b570      	push	{r4, r5, r6, lr}
 80019e2:	4605      	mov	r5, r0
 80019e4:	460e      	mov	r6, r1
  uint32_t oversampling = XMC_UART_CH_OVERSAMPLING;

  /* USIC channel switched on*/
  XMC_USIC_CH_Enable(channel);
 80019e6:	f000 f887 	bl	8001af8 <XMC_USIC_CH_Enable>
  
  if(config->oversampling != 0U)
 80019ea:	79f4      	ldrb	r4, [r6, #7]
  {
    oversampling = (uint32_t)config->oversampling;
 80019ec:	2c00      	cmp	r4, #0
 80019ee:	bf08      	it	eq
 80019f0:	2410      	moveq	r4, #16
  }
  
  /* Configure baud rate */
  (void)XMC_USIC_CH_SetBaudrate(channel, config->baudrate, oversampling);
 80019f2:	4628      	mov	r0, r5
 80019f4:	6831      	ldr	r1, [r6, #0]
 80019f6:	4622      	mov	r2, r4
 80019f8:	f000 f8b6 	bl	8001b68 <XMC_USIC_CH_SetBaudrate>
   * i.e. the 0 level is signaled during the complete bit time
   * Sampling point set equal to the half of the oversampling period
   * Enable Sample Majority Decision 
   * Enable Transfer Status BUSY
   */
  channel->PCR_ASCMode = (uint32_t)(((config->stop_bits - 1UL) << USIC_CH_PCR_ASCMode_STPB_Pos) |
 80019fc:	79b3      	ldrb	r3, [r6, #6]
 80019fe:	3b01      	subs	r3, #1
 8001a00:	005b      	lsls	r3, r3, #1
 8001a02:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
 8001a06:	f043 0301 	orr.w	r3, r3, #1
                                    (((oversampling >> 1UL) + 1UL) << USIC_CH_PCR_ASCMode_SP_Pos) |
 8001a0a:	0864      	lsrs	r4, r4, #1
 8001a0c:	3401      	adds	r4, #1
   * i.e. the 0 level is signaled during the complete bit time
   * Sampling point set equal to the half of the oversampling period
   * Enable Sample Majority Decision 
   * Enable Transfer Status BUSY
   */
  channel->PCR_ASCMode = (uint32_t)(((config->stop_bits - 1UL) << USIC_CH_PCR_ASCMode_STPB_Pos) |
 8001a0e:	ea43 2304 	orr.w	r3, r3, r4, lsl #8
 8001a12:	63eb      	str	r3, [r5, #60]	; 0x3c
  /* Set passive data level, high
     Set word length. Data bits - 1
     If frame length is > 0, frame_lemgth-1; else, FLE = WLE (Data bits - 1)
     Transmission Mode: The shift control signal is considered active if it
     is at 1-level. This is the setting to be programmed to allow data transfers */
  channel->SCTR = (uint32_t)((((uint32_t)config->data_bits - 1UL) << USIC_CH_SCTR_WLE_Pos) |
 8001a14:	7933      	ldrb	r3, [r6, #4]
 8001a16:	3b01      	subs	r3, #1
 8001a18:	061b      	lsls	r3, r3, #24
 8001a1a:	f443 7381 	orr.w	r3, r3, #258	; 0x102
 8001a1e:	636b      	str	r3, [r5, #52]	; 0x34
                             ((0x1UL << USIC_CH_SCTR_TRM_Pos) | USIC_CH_SCTR_PDL_Msk));

  if (config->frame_length != 0U)
 8001a20:	7973      	ldrb	r3, [r6, #5]
 8001a22:	b12b      	cbz	r3, 8001a30 <XMC_UART_CH_Init+0x50>
  {
    channel->SCTR |= (uint32_t)(((uint32_t)config->frame_length - 1UL) << USIC_CH_SCTR_FLE_Pos);
 8001a24:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 8001a26:	3b01      	subs	r3, #1
 8001a28:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
 8001a2c:	636b      	str	r3, [r5, #52]	; 0x34
 8001a2e:	e005      	b.n	8001a3c <XMC_UART_CH_Init+0x5c>
  }
  else
  {
    channel->SCTR |= (uint32_t)(((uint32_t)config->data_bits - 1UL) << USIC_CH_SCTR_FLE_Pos);
 8001a30:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 8001a32:	7933      	ldrb	r3, [r6, #4]
 8001a34:	3b01      	subs	r3, #1
 8001a36:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
 8001a3a:	636b      	str	r3, [r5, #52]	; 0x34
  }

  /* Enable transfer buffer */
  channel->TCSR = (0x1UL << USIC_CH_TCSR_TDEN_Pos) |
 8001a3c:	f44f 63a0 	mov.w	r3, #1280	; 0x500
 8001a40:	63ab      	str	r3, [r5, #56]	; 0x38
                  USIC_CH_TCSR_TDSSM_Msk;

  /* Clear protocol status */
  channel->PSCR = 0xFFFFFFFFUL;
 8001a42:	f04f 33ff 	mov.w	r3, #4294967295
 8001a46:	64eb      	str	r3, [r5, #76]	; 0x4c

  /* Set parity settings */
  channel->CCR = (uint32_t)config->parity_mode;
 8001a48:	8933      	ldrh	r3, [r6, #8]
 8001a4a:	642b      	str	r3, [r5, #64]	; 0x40
 8001a4c:	bd70      	pop	{r4, r5, r6, pc}
 8001a4e:	bf00      	nop

08001a50 <XMC_UART_CH_SetBaudrate>:
}

XMC_UART_CH_STATUS_t XMC_UART_CH_SetBaudrate(XMC_USIC_CH_t *const channel, uint32_t rate, uint32_t oversampling)
{
 8001a50:	b570      	push	{r4, r5, r6, lr}
 8001a52:	4606      	mov	r6, r0
 8001a54:	460c      	mov	r4, r1
 8001a56:	4615      	mov	r5, r2
  XMC_UART_CH_STATUS_t status;
  
  status = XMC_UART_CH_STATUS_ERROR;
  
  if ((rate <= (XMC_SCU_CLOCK_GetPeripheralClockFrequency() >> 2U)) && (oversampling >= XMC_UART_CH_OVERSAMPLING_MIN_VAL))
 8001a58:	f7ff fa9c 	bl	8000f94 <XMC_SCU_CLOCK_GetPeripheralClockFrequency>
 8001a5c:	ebb4 0f90 	cmp.w	r4, r0, lsr #2
 8001a60:	d80a      	bhi.n	8001a78 <XMC_UART_CH_SetBaudrate+0x28>
 8001a62:	2d03      	cmp	r5, #3
 8001a64:	d90a      	bls.n	8001a7c <XMC_UART_CH_SetBaudrate+0x2c>
  {
    if (XMC_USIC_CH_SetBaudrate(channel, rate, oversampling) == XMC_USIC_CH_STATUS_OK)
 8001a66:	4630      	mov	r0, r6
 8001a68:	4621      	mov	r1, r4
 8001a6a:	462a      	mov	r2, r5
 8001a6c:	f000 f87c 	bl	8001b68 <XMC_USIC_CH_SetBaudrate>

XMC_UART_CH_STATUS_t XMC_UART_CH_SetBaudrate(XMC_USIC_CH_t *const channel, uint32_t rate, uint32_t oversampling)
{
  XMC_UART_CH_STATUS_t status;
  
  status = XMC_UART_CH_STATUS_ERROR;
 8001a70:	3000      	adds	r0, #0
 8001a72:	bf18      	it	ne
 8001a74:	2001      	movne	r0, #1
 8001a76:	bd70      	pop	{r4, r5, r6, pc}
 8001a78:	2001      	movs	r0, #1
 8001a7a:	bd70      	pop	{r4, r5, r6, pc}
 8001a7c:	2001      	movs	r0, #1
    {
      status = XMC_UART_CH_STATUS_OK;
    }
  } 
  return status;
}
 8001a7e:	bd70      	pop	{r4, r5, r6, pc}

08001a80 <XMC_UART_CH_Transmit>:

void XMC_UART_CH_Transmit(XMC_USIC_CH_t *const channel, const uint16_t data)
{
  /* Check FIFO size */
  if ((channel->TBCTR & USIC_CH_TBCTR_SIZE_Msk) == 0UL)
 8001a80:	f8d0 3108 	ldr.w	r3, [r0, #264]	; 0x108
 8001a84:	f013 6fe0 	tst.w	r3, #117440512	; 0x7000000
 8001a88:	d109      	bne.n	8001a9e <XMC_UART_CH_Transmit+0x1e>
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_SetDataOutputMode() \n\n\n
 */
__STATIC_INLINE XMC_USIC_CH_TBUF_STATUS_t XMC_USIC_CH_GetTransmitBufferStatus(XMC_USIC_CH_t *const channel)
{
  return (XMC_USIC_CH_TBUF_STATUS_t)(channel->TCSR & USIC_CH_TCSR_TDV_Msk);
 8001a8a:	6b83      	ldr	r3, [r0, #56]	; 0x38
  {
    /* Wait till the Transmit Buffer is free for transmission */
    while(XMC_USIC_CH_GetTransmitBufferStatus(channel) == XMC_USIC_CH_TBUF_STATUS_BUSY)
 8001a8c:	f013 0f80 	tst.w	r3, #128	; 0x80
 8001a90:	d1fb      	bne.n	8001a8a <XMC_UART_CH_Transmit+0xa>
 * \par<b>Related APIs:</b><BR>
 * XMC_UART_CH_DisableEvent(),  XMC_UART_CH_GetStatusFlag()\n\n\n
 */
__STATIC_INLINE void XMC_UART_CH_ClearStatusFlag(XMC_USIC_CH_t *const channel, const uint32_t flag)
{
  channel->PSCR = flag;
 8001a92:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8001a96:	64c3      	str	r3, [r0, #76]	; 0x4c
  
    /* Clear the Transmit Buffer indication flag */
    XMC_UART_CH_ClearStatusFlag(channel, (uint32_t)XMC_UART_CH_STATUS_FLAG_TRANSMIT_BUFFER_INDICATION);
  
    /*Transmit data */
    channel->TBUF[0U] = data;
 8001a98:	f8c0 1080 	str.w	r1, [r0, #128]	; 0x80
 8001a9c:	4770      	bx	lr
  }
  else
  {
    channel->IN[0U] = data;
 8001a9e:	f8c0 1180 	str.w	r1, [r0, #384]	; 0x180
 8001aa2:	4770      	bx	lr

08001aa4 <XMC_UART_CH_GetReceivedData>:
uint16_t XMC_UART_CH_GetReceivedData(XMC_USIC_CH_t *const channel)
{
  uint16_t retval;

  /* Check FIFO size */
  if ((channel->RBCTR & USIC_CH_RBCTR_SIZE_Msk) == 0U)
 8001aa4:	f8d0 310c 	ldr.w	r3, [r0, #268]	; 0x10c
 8001aa8:	f013 6fe0 	tst.w	r3, #117440512	; 0x7000000
  {
    retval = (uint16_t)channel->RBUF;
 8001aac:	bf0c      	ite	eq
 8001aae:	6d40      	ldreq	r0, [r0, #84]	; 0x54
  }
  else
  {
    retval = (uint16_t)channel->OUTR;
 8001ab0:	f8d0 011c 	ldrne.w	r0, [r0, #284]	; 0x11c
 8001ab4:	b280      	uxth	r0, r0
  }

  return retval;
}
 8001ab6:	4770      	bx	lr

08001ab8 <XMC_UART_CH_Stop>:
 8001ab8:	6b83      	ldr	r3, [r0, #56]	; 0x38

XMC_UART_CH_STATUS_t XMC_UART_CH_Stop(XMC_USIC_CH_t *const channel)
{
  XMC_UART_CH_STATUS_t status = XMC_UART_CH_STATUS_OK;

  if (((XMC_USIC_CH_GetTransmitBufferStatus(channel) & (uint32_t) XMC_USIC_CH_TBUF_STATUS_BUSY) != 0U) ||
 8001aba:	f013 0f80 	tst.w	r3, #128	; 0x80
 8001abe:	d109      	bne.n	8001ad4 <XMC_UART_CH_Stop+0x1c>
 * \par<b>Related APIs:</b><BR>
 * XMC_UART_CH_EnableEvent(),  XMC_UART_CH_ClearStatusFlag()\n\n\n
 */
__STATIC_INLINE uint32_t XMC_UART_CH_GetStatusFlag(XMC_USIC_CH_t *const channel)
{
  return channel->PSR_ASCMode;
 8001ac0:	6c83      	ldr	r3, [r0, #72]	; 0x48
 8001ac2:	f413 7f00 	tst.w	r3, #512	; 0x200
 8001ac6:	d107      	bne.n	8001ad8 <XMC_UART_CH_Stop+0x20>
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_Enable(), XMC_USIC_CH_Enable() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_SetMode(XMC_USIC_CH_t *const channel, const XMC_USIC_CH_OPERATING_MODE_t mode)
{
  channel->CCR = (uint32_t)(channel->CCR & (~(USIC_CH_CCR_MODE_Msk))) | (uint32_t)mode;
 8001ac8:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8001aca:	f023 030f 	bic.w	r3, r3, #15
 8001ace:	6403      	str	r3, [r0, #64]	; 0x40
  return retval;
}

XMC_UART_CH_STATUS_t XMC_UART_CH_Stop(XMC_USIC_CH_t *const channel)
{
  XMC_UART_CH_STATUS_t status = XMC_UART_CH_STATUS_OK;
 8001ad0:	2000      	movs	r0, #0
 8001ad2:	4770      	bx	lr

  if (((XMC_USIC_CH_GetTransmitBufferStatus(channel) & (uint32_t) XMC_USIC_CH_TBUF_STATUS_BUSY) != 0U) ||
      ((XMC_UART_CH_GetStatusFlag(channel) & XMC_UART_CH_STATUS_FLAG_TRANSFER_STATUS_BUSY) != 0))
  {
    status = XMC_UART_CH_STATUS_BUSY;
 8001ad4:	2002      	movs	r0, #2
 8001ad6:	4770      	bx	lr
 8001ad8:	2002      	movs	r0, #2
  {
    /* USIC channel in IDLE mode */
    XMC_USIC_CH_SetMode(channel, XMC_USIC_CH_OPERATING_MODE_IDLE);
  }
  return status;
}
 8001ada:	4770      	bx	lr

08001adc <XMC_UART_CH_DisableEvent>:
  channel->PCR_ASCMode |= (event&0xf8U);
}

void XMC_UART_CH_DisableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
  channel->CCR &= (uint32_t)~(event&0x1fc00U);
 8001adc:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8001ade:	f401 32fe 	and.w	r2, r1, #130048	; 0x1fc00
 8001ae2:	ea23 0302 	bic.w	r3, r3, r2
 8001ae6:	6403      	str	r3, [r0, #64]	; 0x40
  channel->PCR_ASCMode &= (uint32_t)~(event&0xf8U);
 8001ae8:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 8001aea:	f001 01f8 	and.w	r1, r1, #248	; 0xf8
 8001aee:	ea23 0101 	bic.w	r1, r3, r1
 8001af2:	63c1      	str	r1, [r0, #60]	; 0x3c
 8001af4:	4770      	bx	lr
 8001af6:	bf00      	nop

08001af8 <XMC_USIC_CH_Enable>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

void XMC_USIC_CH_Enable(XMC_USIC_CH_t *const channel)
{
 8001af8:	b510      	push	{r4, lr}
 8001afa:	4604      	mov	r4, r0
  XMC_ASSERT("XMC_USIC_CH_Enable: channel not valid", XMC_USIC_IsChannelValid(channel));

  if ((channel == XMC_USIC0_CH0) || (channel == XMC_USIC0_CH1))
 8001afc:	4b15      	ldr	r3, [pc, #84]	; (8001b54 <XMC_USIC_CH_Enable+0x5c>)
 8001afe:	4298      	cmp	r0, r3
 8001b00:	d003      	beq.n	8001b0a <XMC_USIC_CH_Enable+0x12>
 8001b02:	f503 7300 	add.w	r3, r3, #512	; 0x200
 8001b06:	4298      	cmp	r0, r3
 8001b08:	d104      	bne.n	8001b14 <XMC_USIC_CH_Enable+0x1c>
  {
#if defined(CLOCK_GATING_SUPPORTED)
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_USIC0);
#endif
#if defined(PERIPHERAL_RESET_SUPPORTED)
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_USIC0);
 8001b0a:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8001b0e:	f7ff fa35 	bl	8000f7c <XMC_SCU_RESET_DeassertPeripheralReset>
 8001b12:	e014      	b.n	8001b3e <XMC_USIC_CH_Enable+0x46>
  if ((channel == XMC_USIC0_CH0) || (channel == XMC_USIC0_CH1))
  {
    XMC_USIC_Enable(XMC_USIC0);
  }
#if defined(USIC1)
  else if((channel == XMC_USIC1_CH0) || (channel == XMC_USIC1_CH1))
 8001b14:	4b10      	ldr	r3, [pc, #64]	; (8001b58 <XMC_USIC_CH_Enable+0x60>)
 8001b16:	4298      	cmp	r0, r3
 8001b18:	d003      	beq.n	8001b22 <XMC_USIC_CH_Enable+0x2a>
 8001b1a:	f503 7300 	add.w	r3, r3, #512	; 0x200
 8001b1e:	4298      	cmp	r0, r3
 8001b20:	d103      	bne.n	8001b2a <XMC_USIC_CH_Enable+0x32>
  {
#if defined(CLOCK_GATING_SUPPORTED)
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_USIC1);
#endif	
#if defined(PERIPHERAL_RESET_SUPPORTED)
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_USIC1);
 8001b22:	480e      	ldr	r0, [pc, #56]	; (8001b5c <XMC_USIC_CH_Enable+0x64>)
 8001b24:	f7ff fa2a 	bl	8000f7c <XMC_SCU_RESET_DeassertPeripheralReset>
 8001b28:	e009      	b.n	8001b3e <XMC_USIC_CH_Enable+0x46>
  {
    XMC_USIC_Enable(XMC_USIC1);
  }
#endif
#if defined(USIC2)
  else if((channel == XMC_USIC2_CH0) || (channel == XMC_USIC2_CH1))
 8001b2a:	4b0d      	ldr	r3, [pc, #52]	; (8001b60 <XMC_USIC_CH_Enable+0x68>)
 8001b2c:	4298      	cmp	r0, r3
 8001b2e:	d003      	beq.n	8001b38 <XMC_USIC_CH_Enable+0x40>
 8001b30:	f503 7300 	add.w	r3, r3, #512	; 0x200
 8001b34:	4298      	cmp	r0, r3
 8001b36:	d102      	bne.n	8001b3e <XMC_USIC_CH_Enable+0x46>
  {
#if defined(CLOCK_GATING_SUPPORTED) 
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_USIC2);
#endif
#if defined(PERIPHERAL_RESET_SUPPORTED)
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_USIC2);
 8001b38:	480a      	ldr	r0, [pc, #40]	; (8001b64 <XMC_USIC_CH_Enable+0x6c>)
 8001b3a:	f7ff fa1f 	bl	8000f7c <XMC_SCU_RESET_DeassertPeripheralReset>
  {
    XMC_ASSERT("USIC module not available", 0U/*Always*/);
  }

  /* USIC channel switched on*/
  channel->KSCFG = (USIC_CH_KSCFG_MODEN_Msk | USIC_CH_KSCFG_BPMODEN_Msk);
 8001b3e:	2303      	movs	r3, #3
 8001b40:	60e3      	str	r3, [r4, #12]
  while ((channel->KSCFG & USIC_CH_KSCFG_MODEN_Msk) == 0U)
 8001b42:	68e3      	ldr	r3, [r4, #12]
 8001b44:	f013 0f01 	tst.w	r3, #1
 8001b48:	d0fb      	beq.n	8001b42 <XMC_USIC_CH_Enable+0x4a>
  {
    /* Wait till the channel is enabled */
  }

  /* Set USIC channel in IDLE mode */
  channel->CCR &= (uint32_t)~USIC_CH_CCR_MODE_Msk;
 8001b4a:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8001b4c:	f023 030f 	bic.w	r3, r3, #15
 8001b50:	6423      	str	r3, [r4, #64]	; 0x40
 8001b52:	bd10      	pop	{r4, pc}
 8001b54:	40030000 	.word	0x40030000
 8001b58:	48020000 	.word	0x48020000
 8001b5c:	10000080 	.word	0x10000080
 8001b60:	48024000 	.word	0x48024000
 8001b64:	10000100 	.word	0x10000100

08001b68 <XMC_USIC_CH_SetBaudrate>:
  
  uint32_t pdiv_frac;
  uint32_t pdiv_frac_min;

  /* The rate and peripheral clock are divided by 100 to be able to use only 32bit arithmetic */
  if ((rate >= 100U) && (oversampling != 0U))
 8001b68:	2963      	cmp	r1, #99	; 0x63
 8001b6a:	d93d      	bls.n	8001be8 <XMC_USIC_CH_SetBaudrate+0x80>
 8001b6c:	2a00      	cmp	r2, #0
 8001b6e:	d03d      	beq.n	8001bec <XMC_USIC_CH_SetBaudrate+0x84>
{
  channel->KSCFG = (uint32_t)((channel->KSCFG & (~USIC_CH_KSCFG_MODEN_Msk)) | USIC_CH_KSCFG_BPMODEN_Msk);
}

XMC_USIC_CH_STATUS_t XMC_USIC_CH_SetBaudrate(XMC_USIC_CH_t *const channel, uint32_t rate, uint32_t oversampling)
{
 8001b70:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001b74:	4617      	mov	r7, r2
 8001b76:	460c      	mov	r4, r1
 8001b78:	4680      	mov	r8, r0
  uint32_t pdiv_frac_min;

  /* The rate and peripheral clock are divided by 100 to be able to use only 32bit arithmetic */
  if ((rate >= 100U) && (oversampling != 0U))
  {
    peripheral_clock = XMC_SCU_CLOCK_GetPeripheralClockFrequency() / 100U;
 8001b7a:	f7ff fa0b 	bl	8000f94 <XMC_SCU_CLOCK_GetPeripheralClockFrequency>
 8001b7e:	4e1c      	ldr	r6, [pc, #112]	; (8001bf0 <XMC_USIC_CH_SetBaudrate+0x88>)
 8001b80:	fba6 3200 	umull	r3, r2, r6, r0
 8001b84:	0952      	lsrs	r2, r2, #5
    rate = rate / 100U;
 8001b86:	fba6 3604 	umull	r3, r6, r6, r4
 8001b8a:	0976      	lsrs	r6, r6, #5
    pdiv_int_min = 1U;
    pdiv_frac_min = 0x3ffU;

    for(clock_divider = 1023U; clock_divider > 0U; --clock_divider)
    {
      pdiv = ((peripheral_clock * clock_divider) / (rate * oversampling));
 8001b8c:	fb07 f606 	mul.w	r6, r7, r6
 8001b90:	ebc2 2482 	rsb	r4, r2, r2, lsl #10
    peripheral_clock = XMC_SCU_CLOCK_GetPeripheralClockFrequency() / 100U;
    rate = rate / 100U;

    clock_divider_min = 1U;
    pdiv_int_min = 1U;
    pdiv_frac_min = 0x3ffU;
 8001b94:	f240 30ff 	movw	r0, #1023	; 0x3ff
  {
    peripheral_clock = XMC_SCU_CLOCK_GetPeripheralClockFrequency() / 100U;
    rate = rate / 100U;

    clock_divider_min = 1U;
    pdiv_int_min = 1U;
 8001b98:	f04f 0e01 	mov.w	lr, #1
  if ((rate >= 100U) && (oversampling != 0U))
  {
    peripheral_clock = XMC_SCU_CLOCK_GetPeripheralClockFrequency() / 100U;
    rate = rate / 100U;

    clock_divider_min = 1U;
 8001b9c:	46f4      	mov	ip, lr
    pdiv_int_min = 1U;
    pdiv_frac_min = 0x3ffU;

    for(clock_divider = 1023U; clock_divider > 0U; --clock_divider)
 8001b9e:	4601      	mov	r1, r0
    {
      pdiv = ((peripheral_clock * clock_divider) / (rate * oversampling));
 8001ba0:	fbb4 f3f6 	udiv	r3, r4, r6
      pdiv_int = pdiv >> 10U;
 8001ba4:	0a9d      	lsrs	r5, r3, #10
      pdiv_frac = pdiv & 0x3ffU;

      if ((pdiv_int < 1024U) && (pdiv_frac < pdiv_frac_min))
 8001ba6:	f5b5 6f80 	cmp.w	r5, #1024	; 0x400
 8001baa:	d206      	bcs.n	8001bba <XMC_USIC_CH_SetBaudrate+0x52>

    for(clock_divider = 1023U; clock_divider > 0U; --clock_divider)
    {
      pdiv = ((peripheral_clock * clock_divider) / (rate * oversampling));
      pdiv_int = pdiv >> 10U;
      pdiv_frac = pdiv & 0x3ffU;
 8001bac:	f3c3 0309 	ubfx	r3, r3, #0, #10

      if ((pdiv_int < 1024U) && (pdiv_frac < pdiv_frac_min))
 8001bb0:	4283      	cmp	r3, r0
 8001bb2:	d202      	bcs.n	8001bba <XMC_USIC_CH_SetBaudrate+0x52>
      {
        pdiv_frac_min = pdiv_frac;
 8001bb4:	4618      	mov	r0, r3
        pdiv_int_min = pdiv_int;
 8001bb6:	46ae      	mov	lr, r5
    {
      pdiv = ((peripheral_clock * clock_divider) / (rate * oversampling));
      pdiv_int = pdiv >> 10U;
      pdiv_frac = pdiv & 0x3ffU;

      if ((pdiv_int < 1024U) && (pdiv_frac < pdiv_frac_min))
 8001bb8:	468c      	mov	ip, r1
 8001bba:	1aa4      	subs	r4, r4, r2

    clock_divider_min = 1U;
    pdiv_int_min = 1U;
    pdiv_frac_min = 0x3ffU;

    for(clock_divider = 1023U; clock_divider > 0U; --clock_divider)
 8001bbc:	3901      	subs	r1, #1
 8001bbe:	d1ef      	bne.n	8001ba0 <XMC_USIC_CH_SetBaudrate+0x38>
        pdiv_int_min = pdiv_int;
        clock_divider_min = clock_divider;
      }
    }

    channel->FDR = XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_FRACTIONAL |
 8001bc0:	f44c 4300 	orr.w	r3, ip, #32768	; 0x8000
 8001bc4:	f8c8 3010 	str.w	r3, [r8, #16]
                   (clock_divider_min << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
 8001bc8:	f8d8 2014 	ldr.w	r2, [r8, #20]
                                     USIC_CH_BRG_PDIV_Msk |
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
 8001bcc:	3f01      	subs	r7, #1
    }

    channel->FDR = XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_FRACTIONAL |
                   (clock_divider_min << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
 8001bce:	4b09      	ldr	r3, [pc, #36]	; (8001bf4 <XMC_USIC_CH_SetBaudrate+0x8c>)
 8001bd0:	4013      	ands	r3, r2
                                     USIC_CH_BRG_PDIV_Msk |
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
 8001bd2:	ea43 2387 	orr.w	r3, r3, r7, lsl #10
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
                   ((pdiv_int_min - 1U) << USIC_CH_BRG_PDIV_Pos);
 8001bd6:	f10e 3eff 	add.w	lr, lr, #4294967295

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
                                     USIC_CH_BRG_PDIV_Msk |
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
 8001bda:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
    }

    channel->FDR = XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_FRACTIONAL |
                   (clock_divider_min << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
 8001bde:	f8c8 3014 	str.w	r3, [r8, #20]
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
                   ((pdiv_int_min - 1U) << USIC_CH_BRG_PDIV_Pos);
                    
    status = XMC_USIC_CH_STATUS_OK;
 8001be2:	2000      	movs	r0, #0
 8001be4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  }
  else 
  {
    status = XMC_USIC_CH_STATUS_ERROR;
 8001be8:	2001      	movs	r0, #1
 8001bea:	4770      	bx	lr
 8001bec:	2001      	movs	r0, #1
 8001bee:	4770      	bx	lr
 8001bf0:	51eb851f 	.word	0x51eb851f
 8001bf4:	fc0080ef 	.word	0xfc0080ef

08001bf8 <XMC_USIC_CH_TXFIFO_Configure>:

void XMC_USIC_CH_TXFIFO_Configure(XMC_USIC_CH_t *const channel,
                                  const uint32_t data_pointer,
                                  const XMC_USIC_CH_FIFO_SIZE_t size,
                                  const uint32_t limit)
{
 8001bf8:	b430      	push	{r4, r5}
  /* Disable FIFO */
  channel->TBCTR &= (uint32_t)~USIC_CH_TBCTR_SIZE_Msk;
 8001bfa:	f8d0 4108 	ldr.w	r4, [r0, #264]	; 0x108
 8001bfe:	f024 64e0 	bic.w	r4, r4, #117440512	; 0x7000000
 8001c02:	f8c0 4108 	str.w	r4, [r0, #264]	; 0x108
  /* LOF = 0, A standard transmit buffer event occurs when the filling level equals the limit value and gets
   * lower due to transmission of a data word
   * STBTEN = 0, the trigger of the standard transmit buffer event is based on the transition of the fill level
   *  from equal to below the limit, not the fact being below
   */
  channel->TBCTR = (uint32_t)(channel->TBCTR & (uint32_t)~(USIC_CH_TBCTR_LIMIT_Msk |
 8001c06:	f8d0 5108 	ldr.w	r5, [r0, #264]	; 0x108
 8001c0a:	4c05      	ldr	r4, [pc, #20]	; (8001c20 <XMC_USIC_CH_TXFIFO_Configure+0x28>)
 8001c0c:	402c      	ands	r4, r5
 8001c0e:	4321      	orrs	r1, r4
 8001c10:	ea41 6202 	orr.w	r2, r1, r2, lsl #24
                                                           USIC_CH_TBCTR_DPTR_Msk |
                                                           USIC_CH_TBCTR_SIZE_Msk)) |
 8001c14:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
  /* LOF = 0, A standard transmit buffer event occurs when the filling level equals the limit value and gets
   * lower due to transmission of a data word
   * STBTEN = 0, the trigger of the standard transmit buffer event is based on the transition of the fill level
   *  from equal to below the limit, not the fact being below
   */
  channel->TBCTR = (uint32_t)(channel->TBCTR & (uint32_t)~(USIC_CH_TBCTR_LIMIT_Msk |
 8001c18:	f8c0 3108 	str.w	r3, [r0, #264]	; 0x108
                                                           USIC_CH_TBCTR_DPTR_Msk |
                                                           USIC_CH_TBCTR_SIZE_Msk)) |
                   (uint32_t)((limit << USIC_CH_TBCTR_LIMIT_Pos) |
                   (data_pointer << USIC_CH_TBCTR_DPTR_Pos) |
                   ((uint32_t)size << USIC_CH_TBCTR_SIZE_Pos));
}
 8001c1c:	bc30      	pop	{r4, r5}
 8001c1e:	4770      	bx	lr
 8001c20:	f8ffc0c0 	.word	0xf8ffc0c0

08001c24 <XMC_USIC_CH_RXFIFO_Configure>:

void XMC_USIC_CH_RXFIFO_Configure(XMC_USIC_CH_t *const channel,
                                  const uint32_t data_pointer,
                                  const XMC_USIC_CH_FIFO_SIZE_t size,
                                  const uint32_t limit)
{
 8001c24:	b430      	push	{r4, r5}
  /* Disable FIFO */
  channel->RBCTR &= (uint32_t)~USIC_CH_RBCTR_SIZE_Msk;
 8001c26:	f8d0 410c 	ldr.w	r4, [r0, #268]	; 0x10c
 8001c2a:	f024 64e0 	bic.w	r4, r4, #117440512	; 0x7000000
 8001c2e:	f8c0 410c 	str.w	r4, [r0, #268]	; 0x10c

  /* LOF = 1, A standard receive buffer event occurs when the filling level equals the limit value and gets bigger
   *  due to the reception of a new data word
   */
  channel->RBCTR = (uint32_t)((channel->RBCTR & (uint32_t)~(USIC_CH_RBCTR_LIMIT_Msk |
 8001c32:	f8d0 510c 	ldr.w	r5, [r0, #268]	; 0x10c
 8001c36:	4c06      	ldr	r4, [pc, #24]	; (8001c50 <XMC_USIC_CH_RXFIFO_Configure+0x2c>)
 8001c38:	402c      	ands	r4, r5
 8001c3a:	f044 5480 	orr.w	r4, r4, #268435456	; 0x10000000
 8001c3e:	4321      	orrs	r1, r4
 8001c40:	ea41 6202 	orr.w	r2, r1, r2, lsl #24
 8001c44:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
 8001c48:	f8c0 310c 	str.w	r3, [r0, #268]	; 0x10c
                                                            USIC_CH_RBCTR_LOF_Msk)) |
                   ((limit << USIC_CH_RBCTR_LIMIT_Pos) |
                   (data_pointer << USIC_CH_RBCTR_DPTR_Pos) |
                   ((uint32_t)size << USIC_CH_RBCTR_SIZE_Pos) |
                   (uint32_t)USIC_CH_RBCTR_LOF_Msk));
}
 8001c4c:	bc30      	pop	{r4, r5}
 8001c4e:	4770      	bx	lr
 8001c50:	efffc0c0 	.word	0xefffc0c0

08001c54 <XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit>:
void XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit(XMC_USIC_CH_t *const channel,
                                            const XMC_USIC_CH_FIFO_SIZE_t size,
                                            const uint32_t limit)
{
  /* Disable FIFO */
  channel->RBCTR &= (uint32_t)~USIC_CH_RBCTR_SIZE_Msk;
 8001c54:	f8d0 310c 	ldr.w	r3, [r0, #268]	; 0x10c
 8001c58:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
 8001c5c:	f8c0 310c 	str.w	r3, [r0, #268]	; 0x10c

  channel->RBCTR = (uint32_t)((uint32_t)(channel->RBCTR & (uint32_t)~USIC_CH_RBCTR_LIMIT_Msk) |
 8001c60:	f8d0 310c 	ldr.w	r3, [r0, #268]	; 0x10c
                   (limit << USIC_CH_RBCTR_LIMIT_Pos) |
                   ((uint32_t)size << USIC_CH_RBCTR_SIZE_Pos));
 8001c64:	0609      	lsls	r1, r1, #24
 8001c66:	ea41 2202 	orr.w	r2, r1, r2, lsl #8
                                            const uint32_t limit)
{
  /* Disable FIFO */
  channel->RBCTR &= (uint32_t)~USIC_CH_RBCTR_SIZE_Msk;

  channel->RBCTR = (uint32_t)((uint32_t)(channel->RBCTR & (uint32_t)~USIC_CH_RBCTR_LIMIT_Msk) |
 8001c6a:	f423 537c 	bic.w	r3, r3, #16128	; 0x3f00
 8001c6e:	4313      	orrs	r3, r2
 8001c70:	f8c0 310c 	str.w	r3, [r0, #268]	; 0x10c
 8001c74:	4770      	bx	lr
 8001c76:	bf00      	nop

08001c78 <XMC_USIC_CH_TXFIFO_SetInterruptNodePointer>:
}

void XMC_USIC_CH_TXFIFO_SetInterruptNodePointer(XMC_USIC_CH_t *const channel,
                                                const XMC_USIC_CH_TXFIFO_INTERRUPT_NODE_POINTER_t interrupt_node,
                                                const uint32_t service_request)
{
 8001c78:	b410      	push	{r4}
  channel->TBCTR = (uint32_t)((channel->TBCTR & (~(uint32_t)(USIC_CH_INPR_Msk << (uint32_t)interrupt_node))) |
 8001c7a:	f8d0 4108 	ldr.w	r4, [r0, #264]	; 0x108
 8001c7e:	2307      	movs	r3, #7
 8001c80:	408b      	lsls	r3, r1
 8001c82:	ea24 0303 	bic.w	r3, r4, r3
                   (service_request << (uint32_t)interrupt_node));
 8001c86:	408a      	lsls	r2, r1

void XMC_USIC_CH_TXFIFO_SetInterruptNodePointer(XMC_USIC_CH_t *const channel,
                                                const XMC_USIC_CH_TXFIFO_INTERRUPT_NODE_POINTER_t interrupt_node,
                                                const uint32_t service_request)
{
  channel->TBCTR = (uint32_t)((channel->TBCTR & (~(uint32_t)(USIC_CH_INPR_Msk << (uint32_t)interrupt_node))) |
 8001c88:	431a      	orrs	r2, r3
 8001c8a:	f8c0 2108 	str.w	r2, [r0, #264]	; 0x108
                   (service_request << (uint32_t)interrupt_node));
}
 8001c8e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001c92:	4770      	bx	lr

08001c94 <XMC_USIC_CH_RXFIFO_SetInterruptNodePointer>:

void XMC_USIC_CH_RXFIFO_SetInterruptNodePointer(XMC_USIC_CH_t *const channel,
                                                const XMC_USIC_CH_RXFIFO_INTERRUPT_NODE_POINTER_t interrupt_node,
                                                const uint32_t service_request)
{
 8001c94:	b410      	push	{r4}
  channel->RBCTR = (uint32_t)((channel->RBCTR & (~(uint32_t)(USIC_CH_INPR_Msk << (uint32_t)interrupt_node))) |
 8001c96:	f8d0 410c 	ldr.w	r4, [r0, #268]	; 0x10c
 8001c9a:	2307      	movs	r3, #7
 8001c9c:	408b      	lsls	r3, r1
 8001c9e:	ea24 0303 	bic.w	r3, r4, r3
                   (service_request << (uint32_t)interrupt_node));
 8001ca2:	408a      	lsls	r2, r1

void XMC_USIC_CH_RXFIFO_SetInterruptNodePointer(XMC_USIC_CH_t *const channel,
                                                const XMC_USIC_CH_RXFIFO_INTERRUPT_NODE_POINTER_t interrupt_node,
                                                const uint32_t service_request)
{
  channel->RBCTR = (uint32_t)((channel->RBCTR & (~(uint32_t)(USIC_CH_INPR_Msk << (uint32_t)interrupt_node))) |
 8001ca4:	431a      	orrs	r2, r3
 8001ca6:	f8c0 210c 	str.w	r2, [r0, #268]	; 0x10c
                   (service_request << (uint32_t)interrupt_node));
}
 8001caa:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001cae:	4770      	bx	lr

08001cb0 <XMC_WDT_Enable>:
 * API IMPLEMENTATION
  ********************************************************************************************************************/

/* Enables watchdog clock and releases watchdog reset. */
void XMC_WDT_Enable(void)
{
 8001cb0:	b508      	push	{r3, lr}
#if UC_FAMILY == XMC4
  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_WDT);
 8001cb2:	2020      	movs	r0, #32
 8001cb4:	f7ff f9a0 	bl	8000ff8 <XMC_SCU_CLOCK_EnableClock>

#if defined(CLOCK_GATING_SUPPORTED)
  XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_WDT);
#endif
#if defined(PERIPHERAL_RESET_SUPPORTED)
  XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_WDT);
 8001cb8:	4801      	ldr	r0, [pc, #4]	; (8001cc0 <XMC_WDT_Enable+0x10>)
 8001cba:	f7ff f95f 	bl	8000f7c <XMC_SCU_RESET_DeassertPeripheralReset>
 8001cbe:	bd08      	pop	{r3, pc}
 8001cc0:	20000002 	.word	0x20000002

08001cc4 <XMC_WDT_Init>:
  XMC_SCU_CLOCK_DisableClock(XMC_SCU_CLOCK_WDT);
#endif
}
/* Initializes and configures watchdog with configuration data pointed by \a config. */
void XMC_WDT_Init(const XMC_WDT_CONFIG_t *const config)
{
 8001cc4:	b510      	push	{r4, lr}
 8001cc6:	4604      	mov	r4, r0
  XMC_WDT_Enable();
 8001cc8:	f7ff fff2 	bl	8001cb0 <XMC_WDT_Enable>
  WDT->CTR = config->wdt_ctr;
 8001ccc:	68a2      	ldr	r2, [r4, #8]
 8001cce:	4b03      	ldr	r3, [pc, #12]	; (8001cdc <XMC_WDT_Init+0x18>)
 8001cd0:	605a      	str	r2, [r3, #4]
  WDT->WLB = config->window_lower_bound;
 8001cd2:	6862      	ldr	r2, [r4, #4]
 8001cd4:	611a      	str	r2, [r3, #16]
  WDT->WUB = config->window_upper_bound;
 8001cd6:	6822      	ldr	r2, [r4, #0]
 8001cd8:	615a      	str	r2, [r3, #20]
 8001cda:	bd10      	pop	{r4, pc}
 8001cdc:	50008000 	.word	0x50008000

08001ce0 <prvTaskExitError>:
    return pxTopOfStack;
}
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
 8001ce0:	b082      	sub	sp, #8
    volatile uint32_t ulDummy = 0;
 8001ce2:	2300      	movs	r3, #0
 8001ce4:	9301      	str	r3, [sp, #4]
     * its caller as there is nothing to return to.  If a task wants to exit it
     * should instead call vTaskDelete( NULL ).
     *
     * Artificially force an assert() to be triggered if configASSERT() is
     * defined, then stop here so application writers can catch the error. */
    configASSERT( uxCriticalNesting == ~0UL );
 8001ce6:	4b0d      	ldr	r3, [pc, #52]	; (8001d1c <prvTaskExitError+0x3c>)
 8001ce8:	681b      	ldr	r3, [r3, #0]
 8001cea:	f1b3 3fff 	cmp.w	r3, #4294967295
 8001cee:	d008      	beq.n	8001d02 <prvTaskExitError+0x22>

    portFORCE_INLINE static void vPortRaiseBASEPRI( void )
    {
        uint32_t ulNewBASEPRI;

        __asm volatile
 8001cf0:	f04f 0314 	mov.w	r3, #20
 8001cf4:	f383 8811 	msr	BASEPRI, r3
 8001cf8:	f3bf 8f6f 	isb	sy
 8001cfc:	f3bf 8f4f 	dsb	sy
 8001d00:	e7fe      	b.n	8001d00 <prvTaskExitError+0x20>
 8001d02:	f04f 0314 	mov.w	r3, #20
 8001d06:	f383 8811 	msr	BASEPRI, r3
 8001d0a:	f3bf 8f6f 	isb	sy
 8001d0e:	f3bf 8f4f 	dsb	sy
    portDISABLE_INTERRUPTS();

    while( ulDummy == 0 )
 8001d12:	9b01      	ldr	r3, [sp, #4]
 8001d14:	2b00      	cmp	r3, #0
 8001d16:	d0fc      	beq.n	8001d12 <prvTaskExitError+0x32>
         * about code appearing after this function is called - making ulDummy
         * volatile makes the compiler think the function could return and
         * therefore not output an 'unreachable code' warning for code that appears
         * after it. */
    }
}
 8001d18:	b002      	add	sp, #8
 8001d1a:	4770      	bx	lr
 8001d1c:	2000d574 	.word	0x2000d574

08001d20 <prvPortStartFirstTask>:
{
    /* Start the first task.  This also clears the bit that indicates the FPU is
     * in use in case the FPU was used before the scheduler was started - which
     * would otherwise result in the unnecessary leaving of space in the SVC stack
     * for lazy saving of FPU registers. */
    __asm volatile (
 8001d20:	4808      	ldr	r0, [pc, #32]	; (8001d44 <prvPortStartFirstTask+0x24>)
 8001d22:	6800      	ldr	r0, [r0, #0]
 8001d24:	6800      	ldr	r0, [r0, #0]
 8001d26:	f380 8808 	msr	MSP, r0
 8001d2a:	f04f 0000 	mov.w	r0, #0
 8001d2e:	f380 8814 	msr	CONTROL, r0
 8001d32:	b662      	cpsie	i
 8001d34:	b661      	cpsie	f
 8001d36:	f3bf 8f4f 	dsb	sy
 8001d3a:	f3bf 8f6f 	isb	sy
 8001d3e:	df00      	svc	0
 8001d40:	bf00      	nop
 8001d42:	0000      	.short	0x0000
 8001d44:	e000ed08 	.word	0xe000ed08

08001d48 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
    __asm volatile
 8001d48:	f8df 000c 	ldr.w	r0, [pc, #12]	; 8001d58 <vPortEnableVFP+0x10>
 8001d4c:	6801      	ldr	r1, [r0, #0]
 8001d4e:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8001d52:	6001      	str	r1, [r0, #0]
 8001d54:	4770      	bx	lr
 8001d56:	0000      	.short	0x0000
 8001d58:	e000ed88 	.word	0xe000ed88

08001d5c <pxPortInitialiseStack>:

    /* Offset added to account for the way the MCU uses the stack on entry/exit
     * of interrupts, and to ensure alignment. */
    pxTopOfStack--;

    *pxTopOfStack = portINITIAL_XPSR;                                    /* xPSR */
 8001d5c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8001d60:	f840 3c04 	str.w	r3, [r0, #-4]
    pxTopOfStack--;
    *pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK; /* PC */
 8001d64:	f021 0101 	bic.w	r1, r1, #1
 8001d68:	f840 1c08 	str.w	r1, [r0, #-8]
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;             /* LR */
 8001d6c:	4b05      	ldr	r3, [pc, #20]	; (8001d84 <pxPortInitialiseStack+0x28>)
 8001d6e:	f840 3c0c 	str.w	r3, [r0, #-12]

    /* Save code space by skipping register initialisation. */
    pxTopOfStack -= 5;                            /* R12, R3, R2 and R1. */
    *pxTopOfStack = ( StackType_t ) pvParameters; /* R0 */
 8001d72:	f840 2c20 	str.w	r2, [r0, #-32]

    /* A save method is being used that requires each task to maintain its
     * own exec return value. */
    pxTopOfStack--;
    *pxTopOfStack = portINITIAL_EXC_RETURN;
 8001d76:	f06f 0302 	mvn.w	r3, #2
 8001d7a:	f840 3c24 	str.w	r3, [r0, #-36]

    pxTopOfStack -= 8; /* R11, R10, R9, R8, R7, R6, R5 and R4. */

    return pxTopOfStack;
}
 8001d7e:	3844      	subs	r0, #68	; 0x44
 8001d80:	4770      	bx	lr
 8001d82:	bf00      	nop
 8001d84:	08001ce1 	.word	0x08001ce1
	...

08001d90 <SVC_Handler>:
}
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
    __asm volatile (
 8001d90:	4b07      	ldr	r3, [pc, #28]	; (8001db0 <pxCurrentTCBConst2>)
 8001d92:	6819      	ldr	r1, [r3, #0]
 8001d94:	6808      	ldr	r0, [r1, #0]
 8001d96:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001d9a:	f380 8809 	msr	PSP, r0
 8001d9e:	f3bf 8f6f 	isb	sy
 8001da2:	f04f 0000 	mov.w	r0, #0
 8001da6:	f380 8811 	msr	BASEPRI, r0
 8001daa:	4770      	bx	lr
 8001dac:	f3af 8000 	nop.w

08001db0 <pxCurrentTCBConst2>:
 8001db0:	200008fc 	.word	0x200008fc
 8001db4:	f3af 8000 	nop.w
 8001db8:	f3af 8000 	nop.w
 8001dbc:	f3af 8000 	nop.w

08001dc0 <vPortEnterCritical>:
 8001dc0:	f04f 0314 	mov.w	r3, #20
 8001dc4:	f383 8811 	msr	BASEPRI, r3
 8001dc8:	f3bf 8f6f 	isb	sy
 8001dcc:	f3bf 8f4f 	dsb	sy
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
    portDISABLE_INTERRUPTS();
    uxCriticalNesting++;
 8001dd0:	4a0a      	ldr	r2, [pc, #40]	; (8001dfc <vPortEnterCritical+0x3c>)
 8001dd2:	6813      	ldr	r3, [r2, #0]
 8001dd4:	3301      	adds	r3, #1
 8001dd6:	6013      	str	r3, [r2, #0]
    /* This is not the interrupt safe version of the enter critical function so
     * assert() if it is being called from an interrupt context.  Only API
     * functions that end in "FromISR" can be used in an interrupt.  Only assert if
     * the critical nesting count is 1 to protect against recursive calls if the
     * assert function also uses a critical section. */
    if( uxCriticalNesting == 1 )
 8001dd8:	2b01      	cmp	r3, #1
 8001dda:	d10d      	bne.n	8001df8 <vPortEnterCritical+0x38>
    {
        configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 8001ddc:	4b08      	ldr	r3, [pc, #32]	; (8001e00 <vPortEnterCritical+0x40>)
 8001dde:	681b      	ldr	r3, [r3, #0]
 8001de0:	f013 0fff 	tst.w	r3, #255	; 0xff
 8001de4:	d008      	beq.n	8001df8 <vPortEnterCritical+0x38>
 8001de6:	f04f 0314 	mov.w	r3, #20
 8001dea:	f383 8811 	msr	BASEPRI, r3
 8001dee:	f3bf 8f6f 	isb	sy
 8001df2:	f3bf 8f4f 	dsb	sy
 8001df6:	e7fe      	b.n	8001df6 <vPortEnterCritical+0x36>
 8001df8:	4770      	bx	lr
 8001dfa:	bf00      	nop
 8001dfc:	2000d574 	.word	0x2000d574
 8001e00:	e000ed04 	.word	0xe000ed04

08001e04 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
    configASSERT( uxCriticalNesting );
 8001e04:	4b09      	ldr	r3, [pc, #36]	; (8001e2c <vPortExitCritical+0x28>)
 8001e06:	681b      	ldr	r3, [r3, #0]
 8001e08:	b943      	cbnz	r3, 8001e1c <vPortExitCritical+0x18>
 8001e0a:	f04f 0314 	mov.w	r3, #20
 8001e0e:	f383 8811 	msr	BASEPRI, r3
 8001e12:	f3bf 8f6f 	isb	sy
 8001e16:	f3bf 8f4f 	dsb	sy
 8001e1a:	e7fe      	b.n	8001e1a <vPortExitCritical+0x16>
    uxCriticalNesting--;
 8001e1c:	3b01      	subs	r3, #1
 8001e1e:	4a03      	ldr	r2, [pc, #12]	; (8001e2c <vPortExitCritical+0x28>)
 8001e20:	6013      	str	r3, [r2, #0]

    if( uxCriticalNesting == 0 )
 8001e22:	b90b      	cbnz	r3, 8001e28 <vPortExitCritical+0x24>
    }
/*-----------------------------------------------------------*/

    portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
    {
        __asm volatile
 8001e24:	f383 8811 	msr	BASEPRI, r3
 8001e28:	4770      	bx	lr
 8001e2a:	bf00      	nop
 8001e2c:	2000d574 	.word	0x2000d574

08001e30 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
    /* This is a naked function. */

    __asm volatile
 8001e30:	f3ef 8009 	mrs	r0, PSP
 8001e34:	f3bf 8f6f 	isb	sy
 8001e38:	4b15      	ldr	r3, [pc, #84]	; (8001e90 <pxCurrentTCBConst>)
 8001e3a:	681a      	ldr	r2, [r3, #0]
 8001e3c:	f01e 0f10 	tst.w	lr, #16
 8001e40:	bf08      	it	eq
 8001e42:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 8001e46:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001e4a:	6010      	str	r0, [r2, #0]
 8001e4c:	e92d 0009 	stmdb	sp!, {r0, r3}
 8001e50:	f04f 0014 	mov.w	r0, #20
 8001e54:	f380 8811 	msr	BASEPRI, r0
 8001e58:	f3bf 8f4f 	dsb	sy
 8001e5c:	f3bf 8f6f 	isb	sy
 8001e60:	f001 fb3a 	bl	80034d8 <vTaskSwitchContext>
 8001e64:	f04f 0000 	mov.w	r0, #0
 8001e68:	f380 8811 	msr	BASEPRI, r0
 8001e6c:	bc09      	pop	{r0, r3}
 8001e6e:	6819      	ldr	r1, [r3, #0]
 8001e70:	6808      	ldr	r0, [r1, #0]
 8001e72:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001e76:	f01e 0f10 	tst.w	lr, #16
 8001e7a:	bf08      	it	eq
 8001e7c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 8001e80:	f380 8809 	msr	PSP, r0
 8001e84:	f3bf 8f6f 	isb	sy
 8001e88:	4770      	bx	lr
 8001e8a:	bf00      	nop
 8001e8c:	f3af 8000 	nop.w

08001e90 <pxCurrentTCBConst>:
 8001e90:	200008fc 	.word	0x200008fc
 8001e94:	f3af 8000 	nop.w
 8001e98:	f3af 8000 	nop.w
 8001e9c:	f3af 8000 	nop.w

08001ea0 <SysTick_Handler>:
    );
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 8001ea0:	b508      	push	{r3, lr}

    portFORCE_INLINE static void vPortRaiseBASEPRI( void )
    {
        uint32_t ulNewBASEPRI;

        __asm volatile
 8001ea2:	f04f 0314 	mov.w	r3, #20
 8001ea6:	f383 8811 	msr	BASEPRI, r3
 8001eaa:	f3bf 8f6f 	isb	sy
 8001eae:	f3bf 8f4f 	dsb	sy
     * save and then restore the interrupt mask value as its value is already
     * known. */
    portDISABLE_INTERRUPTS();
    {
        /* Increment the RTOS tick. */
        if( xTaskIncrementTick() != pdFALSE )
 8001eb2:	f001 f989 	bl	80031c8 <xTaskIncrementTick>
 8001eb6:	b118      	cbz	r0, 8001ec0 <SysTick_Handler+0x20>
        {
            /* A context switch is required.  Context switching is performed in
             * the PendSV interrupt.  Pend the PendSV interrupt. */
            portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 8001eb8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8001ebc:	4b02      	ldr	r3, [pc, #8]	; (8001ec8 <SysTick_Handler+0x28>)
 8001ebe:	601a      	str	r2, [r3, #0]
    }
/*-----------------------------------------------------------*/

    portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
    {
        __asm volatile
 8001ec0:	2300      	movs	r3, #0
 8001ec2:	f383 8811 	msr	BASEPRI, r3
 8001ec6:	bd08      	pop	{r3, pc}
 8001ec8:	e000ed04 	.word	0xe000ed04

08001ecc <vPortSetupTimerInterrupt>:
            ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
        }
    #endif /* configUSE_TICKLESS_IDLE */

    /* Stop and clear the SysTick. */
    portNVIC_SYSTICK_CTRL_REG = 0UL;
 8001ecc:	4a08      	ldr	r2, [pc, #32]	; (8001ef0 <vPortSetupTimerInterrupt+0x24>)
 8001ece:	2300      	movs	r3, #0
 8001ed0:	6013      	str	r3, [r2, #0]
    portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 8001ed2:	4908      	ldr	r1, [pc, #32]	; (8001ef4 <vPortSetupTimerInterrupt+0x28>)
 8001ed4:	600b      	str	r3, [r1, #0]

    /* Configure SysTick to interrupt at the requested rate. */
    portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8001ed6:	4b08      	ldr	r3, [pc, #32]	; (8001ef8 <vPortSetupTimerInterrupt+0x2c>)
 8001ed8:	681b      	ldr	r3, [r3, #0]
 8001eda:	4908      	ldr	r1, [pc, #32]	; (8001efc <vPortSetupTimerInterrupt+0x30>)
 8001edc:	fba1 1303 	umull	r1, r3, r1, r3
 8001ee0:	099b      	lsrs	r3, r3, #6
 8001ee2:	3b01      	subs	r3, #1
 8001ee4:	4906      	ldr	r1, [pc, #24]	; (8001f00 <vPortSetupTimerInterrupt+0x34>)
 8001ee6:	600b      	str	r3, [r1, #0]
    portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 8001ee8:	2307      	movs	r3, #7
 8001eea:	6013      	str	r3, [r2, #0]
 8001eec:	4770      	bx	lr
 8001eee:	bf00      	nop
 8001ef0:	e000e010 	.word	0xe000e010
 8001ef4:	e000e018 	.word	0xe000e018
 8001ef8:	2000d570 	.word	0x2000d570
 8001efc:	10624dd3 	.word	0x10624dd3
 8001f00:	e000e014 	.word	0xe000e014

08001f04 <xPortStartScheduler>:
    configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );

    /* This port can be used on all revisions of the Cortex-M7 core other than
     * the r0p1 parts.  r0p1 parts should use the port from the
     * /source/portable/GCC/ARM_CM7/r0p1 directory. */
    configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 8001f04:	4b3c      	ldr	r3, [pc, #240]	; (8001ff8 <xPortStartScheduler+0xf4>)
 8001f06:	681a      	ldr	r2, [r3, #0]
 8001f08:	4b3c      	ldr	r3, [pc, #240]	; (8001ffc <xPortStartScheduler+0xf8>)
 8001f0a:	429a      	cmp	r2, r3
 8001f0c:	d108      	bne.n	8001f20 <xPortStartScheduler+0x1c>

    portFORCE_INLINE static void vPortRaiseBASEPRI( void )
    {
        uint32_t ulNewBASEPRI;

        __asm volatile
 8001f0e:	f04f 0314 	mov.w	r3, #20
 8001f12:	f383 8811 	msr	BASEPRI, r3
 8001f16:	f3bf 8f6f 	isb	sy
 8001f1a:	f3bf 8f4f 	dsb	sy
 8001f1e:	e7fe      	b.n	8001f1e <xPortStartScheduler+0x1a>
    configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
 8001f20:	4b35      	ldr	r3, [pc, #212]	; (8001ff8 <xPortStartScheduler+0xf4>)
 8001f22:	681a      	ldr	r2, [r3, #0]
 8001f24:	4b36      	ldr	r3, [pc, #216]	; (8002000 <xPortStartScheduler+0xfc>)
 8001f26:	429a      	cmp	r2, r3
 8001f28:	d108      	bne.n	8001f3c <xPortStartScheduler+0x38>
 8001f2a:	f04f 0314 	mov.w	r3, #20
 8001f2e:	f383 8811 	msr	BASEPRI, r3
 8001f32:	f3bf 8f6f 	isb	sy
 8001f36:	f3bf 8f4f 	dsb	sy
 8001f3a:	e7fe      	b.n	8001f3a <xPortStartScheduler+0x36>

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
 8001f3c:	b510      	push	{r4, lr}
 8001f3e:	b082      	sub	sp, #8
             * functions can be called.  ISR safe functions are those that end in
             * "FromISR".  FreeRTOS maintains separate thread and ISR API functions to
             * ensure interrupt entry is as fast and simple as possible.
             *
             * Save the interrupt priority value that is about to be clobbered. */
            ulOriginalPriority = *pucFirstUserPriorityRegister;
 8001f40:	4b30      	ldr	r3, [pc, #192]	; (8002004 <xPortStartScheduler+0x100>)
 8001f42:	781a      	ldrb	r2, [r3, #0]
 8001f44:	b2d2      	uxtb	r2, r2
 8001f46:	9201      	str	r2, [sp, #4]

            /* Determine the number of priority bits available.  First write to all
             * possible bits. */
            *pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 8001f48:	22ff      	movs	r2, #255	; 0xff
 8001f4a:	701a      	strb	r2, [r3, #0]

            /* Read the value back to see how many bits stuck. */
            ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 8001f4c:	781b      	ldrb	r3, [r3, #0]
 8001f4e:	b2db      	uxtb	r3, r3
 8001f50:	f88d 3003 	strb.w	r3, [sp, #3]

            /* Use the same mask on the maximum system call priority. */
            ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8001f54:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001f58:	f003 0314 	and.w	r3, r3, #20
 8001f5c:	4a2a      	ldr	r2, [pc, #168]	; (8002008 <xPortStartScheduler+0x104>)
 8001f5e:	7013      	strb	r3, [r2, #0]

            /* Calculate the maximum acceptable priority group value for the number
             * of bits read back. */
            ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 8001f60:	2207      	movs	r2, #7
 8001f62:	4b2a      	ldr	r3, [pc, #168]	; (800200c <xPortStartScheduler+0x108>)
 8001f64:	601a      	str	r2, [r3, #0]

            while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8001f66:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001f6a:	f013 0f80 	tst.w	r3, #128	; 0x80
 8001f6e:	d012      	beq.n	8001f96 <xPortStartScheduler+0x92>
 8001f70:	2306      	movs	r3, #6
 8001f72:	e000      	b.n	8001f76 <xPortStartScheduler+0x72>
 8001f74:	460b      	mov	r3, r1
            {
                ulMaxPRIGROUPValue--;
                ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 8001f76:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8001f7a:	0052      	lsls	r2, r2, #1
 8001f7c:	b2d2      	uxtb	r2, r2
 8001f7e:	f88d 2003 	strb.w	r2, [sp, #3]

            /* Calculate the maximum acceptable priority group value for the number
             * of bits read back. */
            ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;

            while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8001f82:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8001f86:	1e59      	subs	r1, r3, #1
 8001f88:	f012 0f80 	tst.w	r2, #128	; 0x80
 8001f8c:	d1f2      	bne.n	8001f74 <xPortStartScheduler+0x70>
 8001f8e:	4a1f      	ldr	r2, [pc, #124]	; (800200c <xPortStartScheduler+0x108>)
 8001f90:	6013      	str	r3, [r2, #0]
            #ifdef configPRIO_BITS
                {
                    /* Check the FreeRTOS configuration that defines the number of
                     * priority bits matches the number of priority bits actually queried
                     * from the hardware. */
                    configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
 8001f92:	2b01      	cmp	r3, #1
 8001f94:	d008      	beq.n	8001fa8 <xPortStartScheduler+0xa4>
 8001f96:	f04f 0314 	mov.w	r3, #20
 8001f9a:	f383 8811 	msr	BASEPRI, r3
 8001f9e:	f3bf 8f6f 	isb	sy
 8001fa2:	f3bf 8f4f 	dsb	sy
 8001fa6:	e7fe      	b.n	8001fa6 <xPortStartScheduler+0xa2>
                }
            #endif

            /* Shift the priority group value back to its position within the AIRCR
             * register. */
            ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
 8001fa8:	021b      	lsls	r3, r3, #8
            ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 8001faa:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8001fae:	4a17      	ldr	r2, [pc, #92]	; (800200c <xPortStartScheduler+0x108>)
 8001fb0:	6013      	str	r3, [r2, #0]

            /* Restore the clobbered interrupt priority register to its original
             * value. */
            *pucFirstUserPriorityRegister = ulOriginalPriority;
 8001fb2:	9b01      	ldr	r3, [sp, #4]
 8001fb4:	b2db      	uxtb	r3, r3
 8001fb6:	4a13      	ldr	r2, [pc, #76]	; (8002004 <xPortStartScheduler+0x100>)
 8001fb8:	7013      	strb	r3, [r2, #0]
        }
    #endif /* conifgASSERT_DEFINED */

    /* Make PendSV and SysTick the lowest priority interrupts. */
    portNVIC_SHPR3_REG |= portNVIC_PENDSV_PRI;
 8001fba:	4b15      	ldr	r3, [pc, #84]	; (8002010 <xPortStartScheduler+0x10c>)
 8001fbc:	681a      	ldr	r2, [r3, #0]
 8001fbe:	f442 027c 	orr.w	r2, r2, #16515072	; 0xfc0000
 8001fc2:	601a      	str	r2, [r3, #0]
    portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;
 8001fc4:	681a      	ldr	r2, [r3, #0]
 8001fc6:	f042 427c 	orr.w	r2, r2, #4227858432	; 0xfc000000
 8001fca:	601a      	str	r2, [r3, #0]

    /* Start the timer that generates the tick ISR.  Interrupts are disabled
     * here already. */
    vPortSetupTimerInterrupt();
 8001fcc:	f7ff ff7e 	bl	8001ecc <vPortSetupTimerInterrupt>

    /* Initialise the critical nesting count ready for the first task. */
    uxCriticalNesting = 0;
 8001fd0:	2400      	movs	r4, #0
 8001fd2:	4b10      	ldr	r3, [pc, #64]	; (8002014 <xPortStartScheduler+0x110>)
 8001fd4:	601c      	str	r4, [r3, #0]

    /* Ensure the VFP is enabled - it should be anyway. */
    vPortEnableVFP();
 8001fd6:	f7ff feb7 	bl	8001d48 <vPortEnableVFP>

    /* Lazy save always. */
    *( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 8001fda:	4a0f      	ldr	r2, [pc, #60]	; (8002018 <xPortStartScheduler+0x114>)
 8001fdc:	6813      	ldr	r3, [r2, #0]
 8001fde:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
 8001fe2:	6013      	str	r3, [r2, #0]

    /* Start the first task. */
    prvPortStartFirstTask();
 8001fe4:	f7ff fe9c 	bl	8001d20 <prvPortStartFirstTask>
     * exit error function to prevent compiler warnings about a static function
     * not being called in the case that the application writer overrides this
     * functionality by defining configTASK_RETURN_ADDRESS.  Call
     * vTaskSwitchContext() so link time optimisation does not remove the
     * symbol. */
    vTaskSwitchContext();
 8001fe8:	f001 fa76 	bl	80034d8 <vTaskSwitchContext>
    prvTaskExitError();
 8001fec:	f7ff fe78 	bl	8001ce0 <prvTaskExitError>

    /* Should not get here! */
    return 0;
}
 8001ff0:	4620      	mov	r0, r4
 8001ff2:	b002      	add	sp, #8
 8001ff4:	bd10      	pop	{r4, pc}
 8001ff6:	bf00      	nop
 8001ff8:	e000ed00 	.word	0xe000ed00
 8001ffc:	410fc271 	.word	0x410fc271
 8002000:	410fc270 	.word	0x410fc270
 8002004:	e000e400 	.word	0xe000e400
 8002008:	20000800 	.word	0x20000800
 800200c:	20000804 	.word	0x20000804
 8002010:	e000ed20 	.word	0xe000ed20
 8002014:	2000d574 	.word	0x2000d574
 8002018:	e000ef34 	.word	0xe000ef34

0800201c <vPortValidateInterruptPriority>:
    {
        uint32_t ulCurrentInterrupt;
        uint8_t ucCurrentPriority;

        /* Obtain the number of the currently executing interrupt. */
        __asm volatile ( "mrs %0, ipsr" : "=r" ( ulCurrentInterrupt )::"memory" );
 800201c:	f3ef 8305 	mrs	r3, IPSR

        /* Is the interrupt number a user defined interrupt? */
        if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 8002020:	2b0f      	cmp	r3, #15
 8002022:	d90f      	bls.n	8002044 <vPortValidateInterruptPriority+0x28>
        {
            /* Look up the interrupt's priority. */
            ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 8002024:	4a10      	ldr	r2, [pc, #64]	; (8002068 <vPortValidateInterruptPriority+0x4c>)
 8002026:	5c9b      	ldrb	r3, [r3, r2]
 8002028:	b2db      	uxtb	r3, r3
             * interrupt entry is as fast and simple as possible.
             *
             * The following links provide detailed information:
             * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html
             * https://www.FreeRTOS.org/FAQHelp.html */
            configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 800202a:	4a10      	ldr	r2, [pc, #64]	; (800206c <vPortValidateInterruptPriority+0x50>)
 800202c:	7812      	ldrb	r2, [r2, #0]
 800202e:	429a      	cmp	r2, r3
 8002030:	d908      	bls.n	8002044 <vPortValidateInterruptPriority+0x28>
 8002032:	f04f 0314 	mov.w	r3, #20
 8002036:	f383 8811 	msr	BASEPRI, r3
 800203a:	f3bf 8f6f 	isb	sy
 800203e:	f3bf 8f4f 	dsb	sy
 8002042:	e7fe      	b.n	8002042 <vPortValidateInterruptPriority+0x26>
         * configuration then the correct setting can be achieved on all Cortex-M
         * devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
         * scheduler.  Note however that some vendor specific peripheral libraries
         * assume a non-zero priority group setting, in which cases using a value
         * of zero will result in unpredictable behaviour. */
        configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 8002044:	4b0a      	ldr	r3, [pc, #40]	; (8002070 <vPortValidateInterruptPriority+0x54>)
 8002046:	681b      	ldr	r3, [r3, #0]
 8002048:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800204c:	4a09      	ldr	r2, [pc, #36]	; (8002074 <vPortValidateInterruptPriority+0x58>)
 800204e:	6812      	ldr	r2, [r2, #0]
 8002050:	4293      	cmp	r3, r2
 8002052:	d908      	bls.n	8002066 <vPortValidateInterruptPriority+0x4a>
 8002054:	f04f 0314 	mov.w	r3, #20
 8002058:	f383 8811 	msr	BASEPRI, r3
 800205c:	f3bf 8f6f 	isb	sy
 8002060:	f3bf 8f4f 	dsb	sy
 8002064:	e7fe      	b.n	8002064 <vPortValidateInterruptPriority+0x48>
 8002066:	4770      	bx	lr
 8002068:	e000e3f0 	.word	0xe000e3f0
 800206c:	20000800 	.word	0x20000800
 8002070:	e000ed0c 	.word	0xe000ed0c
 8002074:	20000804 	.word	0x20000804

08002078 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    EventGroupHandle_t xEventGroupCreate( void )
    {
 8002078:	b510      	push	{r4, lr}
         * TickType_t alignment requirements the cast is safe.  In other cases,
         * where the natural word size of the architecture is less than
         * sizeof( TickType_t ), the TickType_t variables will be accessed in two
         * or more reads operations, and the alignment requirements is only that
         * of each individual read. */
        pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
 800207a:	201c      	movs	r0, #28
 800207c:	f001 ff2e 	bl	8003edc <pvPortMalloc>

        if( pxEventBits != NULL )
 8002080:	4604      	mov	r4, r0
 8002082:	b120      	cbz	r0, 800208e <xEventGroupCreate+0x16>
        {
            pxEventBits->uxEventBits = 0;
 8002084:	2300      	movs	r3, #0
 8002086:	f840 3b04 	str.w	r3, [r0], #4
            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
 800208a:	f000 f92f 	bl	80022ec <vListInitialise>
        {
            traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
        }

        return pxEventBits;
    }
 800208e:	4620      	mov	r0, r4
 8002090:	bd10      	pop	{r4, pc}
 8002092:	bf00      	nop

08002094 <xEventGroupWaitBits>:
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait )
{
 8002094:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8002098:	f8dd 9020 	ldr.w	r9, [sp, #32]
    BaseType_t xWaitConditionMet, xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;

    /* Check the user is not attempting to wait on the bits used by the kernel
     * itself, and that at least one bit is being requested. */
    configASSERT( xEventGroup );
 800209c:	b940      	cbnz	r0, 80020b0 <xEventGroupWaitBits+0x1c>
 800209e:	f04f 0314 	mov.w	r3, #20
 80020a2:	f383 8811 	msr	BASEPRI, r3
 80020a6:	f3bf 8f6f 	isb	sy
 80020aa:	f3bf 8f4f 	dsb	sy
 80020ae:	e7fe      	b.n	80020ae <xEventGroupWaitBits+0x1a>
 80020b0:	4606      	mov	r6, r0
    configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 80020b2:	f011 4f7f 	tst.w	r1, #4278190080	; 0xff000000
 80020b6:	d008      	beq.n	80020ca <xEventGroupWaitBits+0x36>
 80020b8:	f04f 0314 	mov.w	r3, #20
 80020bc:	f383 8811 	msr	BASEPRI, r3
 80020c0:	f3bf 8f6f 	isb	sy
 80020c4:	f3bf 8f4f 	dsb	sy
 80020c8:	e7fe      	b.n	80020c8 <xEventGroupWaitBits+0x34>
    configASSERT( uxBitsToWaitFor != 0 );
 80020ca:	b941      	cbnz	r1, 80020de <xEventGroupWaitBits+0x4a>
 80020cc:	f04f 0314 	mov.w	r3, #20
 80020d0:	f383 8811 	msr	BASEPRI, r3
 80020d4:	f3bf 8f6f 	isb	sy
 80020d8:	f3bf 8f4f 	dsb	sy
 80020dc:	e7fe      	b.n	80020dc <xEventGroupWaitBits+0x48>
 80020de:	4698      	mov	r8, r3
 80020e0:	4617      	mov	r7, r2
 80020e2:	460c      	mov	r4, r1
    #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 80020e4:	f001 fbb0 	bl	8003848 <xTaskGetSchedulerState>
 80020e8:	b958      	cbnz	r0, 8002102 <xEventGroupWaitBits+0x6e>
 80020ea:	f1b9 0f00 	cmp.w	r9, #0
 80020ee:	d008      	beq.n	8002102 <xEventGroupWaitBits+0x6e>
 80020f0:	f04f 0314 	mov.w	r3, #20
 80020f4:	f383 8811 	msr	BASEPRI, r3
 80020f8:	f3bf 8f6f 	isb	sy
 80020fc:	f3bf 8f4f 	dsb	sy
 8002100:	e7fe      	b.n	8002100 <xEventGroupWaitBits+0x6c>
        }
    #endif

    vTaskSuspendAll();
 8002102:	f001 f853 	bl	80031ac <vTaskSuspendAll>
    {
        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
 8002106:	6835      	ldr	r5, [r6, #0]
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
    BaseType_t xWaitConditionMet = pdFALSE;

    if( xWaitForAllBits == pdFALSE )
 8002108:	f1b8 0f00 	cmp.w	r8, #0
 800210c:	d104      	bne.n	8002118 <xEventGroupWaitBits+0x84>
    {
        /* Task only has to wait for one bit within uxBitsToWaitFor to be
         * set.  Is one already set? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
 800210e:	422c      	tst	r4, r5
 8002110:	bf14      	ite	ne
 8002112:	2301      	movne	r3, #1
 8002114:	2300      	moveq	r3, #0
 8002116:	e005      	b.n	8002124 <xEventGroupWaitBits+0x90>
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
 8002118:	ea04 0305 	and.w	r3, r4, r5
 800211c:	429c      	cmp	r4, r3
 800211e:	bf14      	ite	ne
 8002120:	2300      	movne	r3, #0
 8002122:	2301      	moveq	r3, #1
        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;

        /* Check to see if the wait condition is already met or not. */
        xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );

        if( xWaitConditionMet != pdFALSE )
 8002124:	b12b      	cbz	r3, 8002132 <xEventGroupWaitBits+0x9e>
             * block. */
            uxReturn = uxCurrentEventBits;
            xTicksToWait = ( TickType_t ) 0;

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
 8002126:	2f00      	cmp	r7, #0
 8002128:	d041      	beq.n	80021ae <xEventGroupWaitBits+0x11a>
            {
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 800212a:	ea25 0404 	bic.w	r4, r5, r4
 800212e:	6034      	str	r4, [r6, #0]
 8002130:	e03d      	b.n	80021ae <xEventGroupWaitBits+0x11a>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else if( xTicksToWait == ( TickType_t ) 0 )
 8002132:	f1b9 0f00 	cmp.w	r9, #0
 8002136:	d03a      	beq.n	80021ae <xEventGroupWaitBits+0x11a>
             * set.  uxControlBits are used to remember the specified behaviour of
             * this call to xEventGroupWaitBits() - for use when the event bits
             * unblock the task. */
            if( xClearOnExit != pdFALSE )
            {
                uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
 8002138:	2f00      	cmp	r7, #0
 800213a:	bf0c      	ite	eq
 800213c:	2100      	moveq	r1, #0
 800213e:	f04f 7180 	movne.w	r1, #16777216	; 0x1000000
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if( xWaitForAllBits != pdFALSE )
 8002142:	f1b8 0f00 	cmp.w	r8, #0
 8002146:	d001      	beq.n	800214c <xEventGroupWaitBits+0xb8>
            {
                uxControlBits |= eventWAIT_FOR_ALL_BITS;
 8002148:	f041 6180 	orr.w	r1, r1, #67108864	; 0x4000000
            }

            /* Store the bits that the calling task is waiting for in the
             * task's event list item so the kernel knows when a match is
             * found.  Then enter the blocked state. */
            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
 800214c:	1d30      	adds	r0, r6, #4
 800214e:	4321      	orrs	r1, r4
 8002150:	464a      	mov	r2, r9
 8002152:	f001 fa2f 	bl	80035b4 <vTaskPlaceOnUnorderedEventList>
            uxReturn = 0;

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
 8002156:	f001 f8c9 	bl	80032ec <xTaskResumeAll>

    if( xTicksToWait != ( TickType_t ) 0 )
    {
        if( xAlreadyYielded == pdFALSE )
 800215a:	b938      	cbnz	r0, 800216c <xEventGroupWaitBits+0xd8>
        {
            portYIELD_WITHIN_API();
 800215c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8002160:	4b15      	ldr	r3, [pc, #84]	; (80021b8 <xEventGroupWaitBits+0x124>)
 8002162:	601a      	str	r2, [r3, #0]
 8002164:	f3bf 8f4f 	dsb	sy
 8002168:	f3bf 8f6f 	isb	sy

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
 800216c:	f001 fc80 	bl	8003a70 <uxTaskResetEventItemValue>
 8002170:	4605      	mov	r5, r0

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
 8002172:	f010 7f00 	tst.w	r0, #33554432	; 0x2000000
 8002176:	d117      	bne.n	80021a8 <xEventGroupWaitBits+0x114>
        {
            taskENTER_CRITICAL();
 8002178:	f7ff fe22 	bl	8001dc0 <vPortEnterCritical>
            {
                /* The task timed out, just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
 800217c:	6835      	ldr	r5, [r6, #0]
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
    BaseType_t xWaitConditionMet = pdFALSE;

    if( xWaitForAllBits == pdFALSE )
 800217e:	f1b8 0f00 	cmp.w	r8, #0
 8002182:	d104      	bne.n	800218e <xEventGroupWaitBits+0xfa>
    {
        /* Task only has to wait for one bit within uxBitsToWaitFor to be
         * set.  Is one already set? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
 8002184:	422c      	tst	r4, r5
 8002186:	bf14      	ite	ne
 8002188:	2301      	movne	r3, #1
 800218a:	2300      	moveq	r3, #0
 800218c:	e005      	b.n	800219a <xEventGroupWaitBits+0x106>
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
 800218e:	ea04 0305 	and.w	r3, r4, r5
 8002192:	429c      	cmp	r4, r3
 8002194:	bf14      	ite	ne
 8002196:	2300      	movne	r3, #0
 8002198:	2301      	moveq	r3, #1
                /* The task timed out, just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;

                /* It is possible that the event bits were updated between this
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
 800219a:	b11b      	cbz	r3, 80021a4 <xEventGroupWaitBits+0x110>
                {
                    if( xClearOnExit != pdFALSE )
 800219c:	b117      	cbz	r7, 80021a4 <xEventGroupWaitBits+0x110>
                    {
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 800219e:	ea25 0404 	bic.w	r4, r5, r4
 80021a2:	6034      	str	r4, [r6, #0]
                    mtCOVERAGE_TEST_MARKER();
                }

                xTimeoutOccurred = pdTRUE;
            }
            taskEXIT_CRITICAL();
 80021a4:	f7ff fe2e 	bl	8001e04 <vPortExitCritical>
        {
            /* The task unblocked because the bits were set. */
        }

        /* The task blocked so control bits may have been set. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
 80021a8:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
 80021ac:	e001      	b.n	80021b2 <xEventGroupWaitBits+0x11e>
            uxReturn = 0;

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
 80021ae:	f001 f89d 	bl	80032ec <xTaskResumeAll>

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
}
 80021b2:	4628      	mov	r0, r5
 80021b4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80021b8:	e000ed04 	.word	0xe000ed04

080021bc <xEventGroupClearBits>:
    EventGroup_t * pxEventBits = xEventGroup;
    EventBits_t uxReturn;

    /* Check the user is not attempting to clear the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
 80021bc:	b940      	cbnz	r0, 80021d0 <xEventGroupClearBits+0x14>
 80021be:	f04f 0314 	mov.w	r3, #20
 80021c2:	f383 8811 	msr	BASEPRI, r3
 80021c6:	f3bf 8f6f 	isb	sy
 80021ca:	f3bf 8f4f 	dsb	sy
 80021ce:	e7fe      	b.n	80021ce <xEventGroupClearBits+0x12>
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                  const EventBits_t uxBitsToClear )
{
 80021d0:	b570      	push	{r4, r5, r6, lr}
 80021d2:	4605      	mov	r5, r0
    EventBits_t uxReturn;

    /* Check the user is not attempting to clear the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 80021d4:	f011 4f7f 	tst.w	r1, #4278190080	; 0xff000000
 80021d8:	d008      	beq.n	80021ec <xEventGroupClearBits+0x30>
 80021da:	f04f 0314 	mov.w	r3, #20
 80021de:	f383 8811 	msr	BASEPRI, r3
 80021e2:	f3bf 8f6f 	isb	sy
 80021e6:	f3bf 8f4f 	dsb	sy
 80021ea:	e7fe      	b.n	80021ea <xEventGroupClearBits+0x2e>
 80021ec:	460c      	mov	r4, r1

    taskENTER_CRITICAL();
 80021ee:	f7ff fde7 	bl	8001dc0 <vPortEnterCritical>
    {
        traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

        /* The value returned is the event group value prior to the bits being
         * cleared. */
        uxReturn = pxEventBits->uxEventBits;
 80021f2:	682e      	ldr	r6, [r5, #0]

        /* Clear the bits. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
 80021f4:	ea26 0104 	bic.w	r1, r6, r4
 80021f8:	6029      	str	r1, [r5, #0]
    }
    taskEXIT_CRITICAL();
 80021fa:	f7ff fe03 	bl	8001e04 <vPortExitCritical>

    return uxReturn;
}
 80021fe:	4630      	mov	r0, r6
 8002200:	bd70      	pop	{r4, r5, r6, pc}
 8002202:	bf00      	nop

08002204 <xEventGroupSetBits>:
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet )
{
 8002204:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    EventGroup_t * pxEventBits = xEventGroup;
    BaseType_t xMatchFound = pdFALSE;

    /* Check the user is not attempting to set the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
 8002206:	b940      	cbnz	r0, 800221a <xEventGroupSetBits+0x16>
 8002208:	f04f 0314 	mov.w	r3, #20
 800220c:	f383 8811 	msr	BASEPRI, r3
 8002210:	f3bf 8f6f 	isb	sy
 8002214:	f3bf 8f4f 	dsb	sy
 8002218:	e7fe      	b.n	8002218 <xEventGroupSetBits+0x14>
 800221a:	4604      	mov	r4, r0
    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 800221c:	f011 4f7f 	tst.w	r1, #4278190080	; 0xff000000
 8002220:	d008      	beq.n	8002234 <xEventGroupSetBits+0x30>
 8002222:	f04f 0314 	mov.w	r3, #20
 8002226:	f383 8811 	msr	BASEPRI, r3
 800222a:	f3bf 8f6f 	isb	sy
 800222e:	f3bf 8f4f 	dsb	sy
 8002232:	e7fe      	b.n	8002232 <xEventGroupSetBits+0x2e>
 8002234:	460d      	mov	r5, r1

    pxList = &( pxEventBits->xTasksWaitingForBits );
    pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8002236:	f100 060c 	add.w	r6, r0, #12
    vTaskSuspendAll();
 800223a:	f000 ffb7 	bl	80031ac <vTaskSuspendAll>
    {
        traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

        pxListItem = listGET_HEAD_ENTRY( pxList );
 800223e:	6920      	ldr	r0, [r4, #16]

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;
 8002240:	6821      	ldr	r1, [r4, #0]
 8002242:	4329      	orrs	r1, r5
 8002244:	6021      	str	r1, [r4, #0]

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
 8002246:	4286      	cmp	r6, r0
 8002248:	d021      	beq.n	800228e <xEventGroupSetBits+0x8a>
 800224a:	2500      	movs	r5, #0
        {
            pxNext = listGET_NEXT( pxListItem );
 800224c:	6847      	ldr	r7, [r0, #4]
            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
 800224e:	6801      	ldr	r1, [r0, #0]
            xMatchFound = pdFALSE;

            /* Split the bits waited for from the control bits. */
            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
 8002250:	f021 427f 	bic.w	r2, r1, #4278190080	; 0xff000000

            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
 8002254:	f011 6f80 	tst.w	r1, #67108864	; 0x4000000
 8002258:	d105      	bne.n	8002266 <xEventGroupSetBits+0x62>
            {
                /* Just looking for single bit being set. */
                if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
 800225a:	6823      	ldr	r3, [r4, #0]
 800225c:	421a      	tst	r2, r3
 800225e:	bf14      	ite	ne
 8002260:	2301      	movne	r3, #1
 8002262:	2300      	moveq	r3, #0
 8002264:	e005      	b.n	8002272 <xEventGroupSetBits+0x6e>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
 8002266:	6823      	ldr	r3, [r4, #0]
 8002268:	4013      	ands	r3, r2
 800226a:	429a      	cmp	r2, r3
 800226c:	bf14      	ite	ne
 800226e:	2300      	movne	r3, #0
 8002270:	2301      	moveq	r3, #1
            else
            {
                /* Need all bits to be set, but not all the bits were set. */
            }

            if( xMatchFound != pdFALSE )
 8002272:	b143      	cbz	r3, 8002286 <xEventGroupSetBits+0x82>
            {
                /* The bits match.  Should the bits be cleared on exit? */
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
 8002274:	f011 7f80 	tst.w	r1, #16777216	; 0x1000000
                {
                    uxBitsToClear |= uxBitsWaitedFor;
 8002278:	bf18      	it	ne
 800227a:	4315      	orrne	r5, r2
                /* Store the actual event flag value in the task's event list
                 * item before removing the task from the event list.  The
                 * eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
                 * that is was unblocked due to its required bits matching, rather
                 * than because it timed out. */
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
 800227c:	6821      	ldr	r1, [r4, #0]
 800227e:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
 8002282:	f001 fa27 	bl	80036d4 <vTaskRemoveFromUnorderedEventList>
 8002286:	4638      	mov	r0, r7

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
 8002288:	42be      	cmp	r6, r7
 800228a:	d1df      	bne.n	800224c <xEventGroupSetBits+0x48>
 800228c:	e000      	b.n	8002290 <xEventGroupSetBits+0x8c>
                                const EventBits_t uxBitsToSet )
{
    ListItem_t * pxListItem, * pxNext;
    ListItem_t const * pxListEnd;
    List_t const * pxList;
    EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
 800228e:	2500      	movs	r5, #0
            pxListItem = pxNext;
        }

        /* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
         * bit was set in the control word. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
 8002290:	6823      	ldr	r3, [r4, #0]
 8002292:	ea23 0305 	bic.w	r3, r3, r5
 8002296:	6023      	str	r3, [r4, #0]
    }
    ( void ) xTaskResumeAll();
 8002298:	f001 f828 	bl	80032ec <xTaskResumeAll>

    return pxEventBits->uxEventBits;
}
 800229c:	6820      	ldr	r0, [r4, #0]
 800229e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080022a0 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
 80022a0:	b570      	push	{r4, r5, r6, lr}
 80022a2:	4604      	mov	r4, r0
    EventGroup_t * pxEventBits = xEventGroup;
    const List_t * pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );

    vTaskSuspendAll();
 80022a4:	f000 ff82 	bl	80031ac <vTaskSuspendAll>
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
 80022a8:	6863      	ldr	r3, [r4, #4]
 80022aa:	b1cb      	cbz	r3, 80022e0 <vEventGroupDelete+0x40>
        {
            /* Unblock the task, returning 0 as the event list is being deleted
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
 80022ac:	6920      	ldr	r0, [r4, #16]
 80022ae:	f104 050c 	add.w	r5, r4, #12
 80022b2:	42a8      	cmp	r0, r5
 80022b4:	d005      	beq.n	80022c2 <vEventGroupDelete+0x22>
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
 80022b6:	f04f 7600 	mov.w	r6, #33554432	; 0x2000000
 80022ba:	e00b      	b.n	80022d4 <vEventGroupDelete+0x34>

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
        {
            /* Unblock the task, returning 0 as the event list is being deleted
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
 80022bc:	6920      	ldr	r0, [r4, #16]
 80022be:	42a8      	cmp	r0, r5
 80022c0:	d108      	bne.n	80022d4 <vEventGroupDelete+0x34>
 80022c2:	f04f 0314 	mov.w	r3, #20
 80022c6:	f383 8811 	msr	BASEPRI, r3
 80022ca:	f3bf 8f6f 	isb	sy
 80022ce:	f3bf 8f4f 	dsb	sy
 80022d2:	e7fe      	b.n	80022d2 <vEventGroupDelete+0x32>
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
 80022d4:	4631      	mov	r1, r6
 80022d6:	f001 f9fd 	bl	80036d4 <vTaskRemoveFromUnorderedEventList>

    vTaskSuspendAll();
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
 80022da:	6863      	ldr	r3, [r4, #4]
 80022dc:	2b00      	cmp	r3, #0
 80022de:	d1ed      	bne.n	80022bc <vEventGroupDelete+0x1c>

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
            {
                /* The event group can only have been allocated dynamically - free
                 * it again. */
                vPortFree( pxEventBits );
 80022e0:	4620      	mov	r0, r4
 80022e2:	f001 fe9f 	bl	8004024 <vPortFree>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    ( void ) xTaskResumeAll();
 80022e6:	f001 f801 	bl	80032ec <xTaskResumeAll>
 80022ea:	bd70      	pop	{r4, r5, r6, pc}

080022ec <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80022ec:	f100 0308 	add.w	r3, r0, #8
 80022f0:	6043      	str	r3, [r0, #4]

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
 80022f2:	f04f 32ff 	mov.w	r2, #4294967295
 80022f6:	6082      	str	r2, [r0, #8]

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80022f8:	60c3      	str	r3, [r0, #12]
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80022fa:	6103      	str	r3, [r0, #16]

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 80022fc:	2300      	movs	r3, #0
 80022fe:	6003      	str	r3, [r0, #0]
 8002300:	4770      	bx	lr
 8002302:	bf00      	nop

08002304 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
 8002304:	2300      	movs	r3, #0
 8002306:	6103      	str	r3, [r0, #16]
 8002308:	4770      	bx	lr
 800230a:	bf00      	nop

0800230c <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    ListItem_t * const pxIndex = pxList->pxIndex;
 800230c:	6843      	ldr	r3, [r0, #4]
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
 800230e:	604b      	str	r3, [r1, #4]
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8002310:	689a      	ldr	r2, [r3, #8]
 8002312:	608a      	str	r2, [r1, #8]

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
 8002314:	689a      	ldr	r2, [r3, #8]
 8002316:	6051      	str	r1, [r2, #4]
    pxIndex->pxPrevious = pxNewListItem;
 8002318:	6099      	str	r1, [r3, #8]

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
 800231a:	6108      	str	r0, [r1, #16]

    ( pxList->uxNumberOfItems )++;
 800231c:	6803      	ldr	r3, [r0, #0]
 800231e:	3301      	adds	r3, #1
 8002320:	6003      	str	r3, [r0, #0]
 8002322:	4770      	bx	lr

08002324 <vListInsert>:
}
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
 8002324:	b430      	push	{r4, r5}
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 8002326:	680d      	ldr	r5, [r1, #0]
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
 8002328:	f1b5 3fff 	cmp.w	r5, #4294967295
 800232c:	d101      	bne.n	8002332 <vListInsert+0xe>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
 800232e:	6902      	ldr	r2, [r0, #16]
 8002330:	e007      	b.n	8002342 <vListInsert+0x1e>
        *   4) Using a queue or semaphore before it has been initialised or
        *      before the scheduler has been started (are interrupts firing
        *      before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 8002332:	f100 0208 	add.w	r2, r0, #8
 8002336:	e000      	b.n	800233a <vListInsert+0x16>
 8002338:	461a      	mov	r2, r3
 800233a:	6853      	ldr	r3, [r2, #4]
 800233c:	681c      	ldr	r4, [r3, #0]
 800233e:	42a5      	cmp	r5, r4
 8002340:	d2fa      	bcs.n	8002338 <vListInsert+0x14>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
 8002342:	6853      	ldr	r3, [r2, #4]
 8002344:	604b      	str	r3, [r1, #4]
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 8002346:	6099      	str	r1, [r3, #8]
    pxNewListItem->pxPrevious = pxIterator;
 8002348:	608a      	str	r2, [r1, #8]
    pxIterator->pxNext = pxNewListItem;
 800234a:	6051      	str	r1, [r2, #4]

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
 800234c:	6108      	str	r0, [r1, #16]

    ( pxList->uxNumberOfItems )++;
 800234e:	6803      	ldr	r3, [r0, #0]
 8002350:	3301      	adds	r3, #1
 8002352:	6003      	str	r3, [r0, #0]
}
 8002354:	bc30      	pop	{r4, r5}
 8002356:	4770      	bx	lr

08002358 <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
 8002358:	6903      	ldr	r3, [r0, #16]

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 800235a:	6842      	ldr	r2, [r0, #4]
 800235c:	6881      	ldr	r1, [r0, #8]
 800235e:	6091      	str	r1, [r2, #8]
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8002360:	6882      	ldr	r2, [r0, #8]
 8002362:	6841      	ldr	r1, [r0, #4]
 8002364:	6051      	str	r1, [r2, #4]

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
 8002366:	685a      	ldr	r2, [r3, #4]
 8002368:	4282      	cmp	r2, r0
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
 800236a:	bf04      	itt	eq
 800236c:	6892      	ldreq	r2, [r2, #8]
 800236e:	605a      	streq	r2, [r3, #4]
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
 8002370:	2200      	movs	r2, #0
 8002372:	6102      	str	r2, [r0, #16]
    ( pxList->uxNumberOfItems )--;
 8002374:	681a      	ldr	r2, [r3, #0]
 8002376:	3a01      	subs	r2, #1
 8002378:	601a      	str	r2, [r3, #0]

    return pxList->uxNumberOfItems;
 800237a:	6818      	ldr	r0, [r3, #0]
}
 800237c:	4770      	bx	lr
 800237e:	bf00      	nop

08002380 <prvIsQueueEmpty>:
    taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
 8002380:	b510      	push	{r4, lr}
 8002382:	4604      	mov	r4, r0
    BaseType_t xReturn;

    taskENTER_CRITICAL();
 8002384:	f7ff fd1c 	bl	8001dc0 <vPortEnterCritical>
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 8002388:	6ba4      	ldr	r4, [r4, #56]	; 0x38
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
 800238a:	f7ff fd3b 	bl	8001e04 <vPortExitCritical>

    return xReturn;
}
 800238e:	fab4 f084 	clz	r0, r4
 8002392:	0940      	lsrs	r0, r0, #5
 8002394:	bd10      	pop	{r4, pc}
 8002396:	bf00      	nop

08002398 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
 8002398:	b570      	push	{r4, r5, r6, lr}
 800239a:	4604      	mov	r4, r0
 800239c:	4616      	mov	r6, r2
    BaseType_t xReturn = pdFALSE;
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800239e:	6b85      	ldr	r5, [r0, #56]	; 0x38

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 80023a0:	6c02      	ldr	r2, [r0, #64]	; 0x40
 80023a2:	b93a      	cbnz	r2, 80023b4 <prvCopyDataToQueue+0x1c>
    {
        #if ( configUSE_MUTEXES == 1 )
            {
                if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 80023a4:	6803      	ldr	r3, [r0, #0]
 80023a6:	bb43      	cbnz	r3, 80023fa <prvCopyDataToQueue+0x62>
                {
                    /* The mutex is no longer being held. */
                    xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
 80023a8:	6880      	ldr	r0, [r0, #8]
 80023aa:	f001 fab3 	bl	8003914 <xTaskPriorityDisinherit>
                    pxQueue->u.xSemaphore.xMutexHolder = NULL;
 80023ae:	2300      	movs	r3, #0
 80023b0:	60a3      	str	r3, [r4, #8]
 80023b2:	e029      	b.n	8002408 <prvCopyDataToQueue+0x70>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
 80023b4:	b96e      	cbnz	r6, 80023d2 <prvCopyDataToQueue+0x3a>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 80023b6:	6840      	ldr	r0, [r0, #4]
 80023b8:	f007 fd94 	bl	8009ee4 <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 80023bc:	6862      	ldr	r2, [r4, #4]
 80023be:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80023c0:	4413      	add	r3, r2
 80023c2:	6063      	str	r3, [r4, #4]

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80023c4:	68a2      	ldr	r2, [r4, #8]
 80023c6:	4293      	cmp	r3, r2
 80023c8:	d319      	bcc.n	80023fe <prvCopyDataToQueue+0x66>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
 80023ca:	6823      	ldr	r3, [r4, #0]
 80023cc:	6063      	str	r3, [r4, #4]

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
    BaseType_t xReturn = pdFALSE;
 80023ce:	2000      	movs	r0, #0
 80023d0:	e01a      	b.n	8002408 <prvCopyDataToQueue+0x70>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
 80023d2:	68c0      	ldr	r0, [r0, #12]
 80023d4:	f007 fd86 	bl	8009ee4 <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 80023d8:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80023da:	425b      	negs	r3, r3
 80023dc:	68e2      	ldr	r2, [r4, #12]
 80023de:	441a      	add	r2, r3
 80023e0:	60e2      	str	r2, [r4, #12]

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80023e2:	6821      	ldr	r1, [r4, #0]
 80023e4:	428a      	cmp	r2, r1
 80023e6:	d202      	bcs.n	80023ee <prvCopyDataToQueue+0x56>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
 80023e8:	68a2      	ldr	r2, [r4, #8]
 80023ea:	4413      	add	r3, r2
 80023ec:	60e3      	str	r3, [r4, #12]
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
 80023ee:	2e02      	cmp	r6, #2
 80023f0:	d107      	bne.n	8002402 <prvCopyDataToQueue+0x6a>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 80023f2:	b145      	cbz	r5, 8002406 <prvCopyDataToQueue+0x6e>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
 80023f4:	3d01      	subs	r5, #1

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
    BaseType_t xReturn = pdFALSE;
 80023f6:	2000      	movs	r0, #0
 80023f8:	e006      	b.n	8002408 <prvCopyDataToQueue+0x70>
 80023fa:	2000      	movs	r0, #0
 80023fc:	e004      	b.n	8002408 <prvCopyDataToQueue+0x70>
 80023fe:	2000      	movs	r0, #0
 8002400:	e002      	b.n	8002408 <prvCopyDataToQueue+0x70>
 8002402:	2000      	movs	r0, #0
 8002404:	e000      	b.n	8002408 <prvCopyDataToQueue+0x70>
 8002406:	2000      	movs	r0, #0
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8002408:	3501      	adds	r5, #1
 800240a:	63a5      	str	r5, [r4, #56]	; 0x38

    return xReturn;
}
 800240c:	bd70      	pop	{r4, r5, r6, pc}
 800240e:	bf00      	nop

08002410 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8002410:	6c02      	ldr	r2, [r0, #64]	; 0x40
 8002412:	b172      	cbz	r2, 8002432 <prvCopyDataFromQueue+0x22>
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
 8002414:	b510      	push	{r4, lr}
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 8002416:	68c3      	ldr	r3, [r0, #12]
 8002418:	4413      	add	r3, r2
 800241a:	60c3      	str	r3, [r0, #12]

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 800241c:	6884      	ldr	r4, [r0, #8]
 800241e:	42a3      	cmp	r3, r4
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 8002420:	bf24      	itt	cs
 8002422:	6803      	ldrcs	r3, [r0, #0]
 8002424:	60c3      	strcs	r3, [r0, #12]
 8002426:	4603      	mov	r3, r0
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 8002428:	4608      	mov	r0, r1
 800242a:	68d9      	ldr	r1, [r3, #12]
 800242c:	f007 fd5a 	bl	8009ee4 <memcpy>
 8002430:	bd10      	pop	{r4, pc}
 8002432:	4770      	bx	lr

08002434 <prvUnlockQueue>:
    }
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 8002434:	b570      	push	{r4, r5, r6, lr}
 8002436:	4605      	mov	r5, r0

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
 8002438:	f7ff fcc2 	bl	8001dc0 <vPortEnterCritical>
    {
        int8_t cTxLock = pxQueue->cTxLock;
 800243c:	f895 3045 	ldrb.w	r3, [r5, #69]	; 0x45
 8002440:	b2dc      	uxtb	r4, r3

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8002442:	b263      	sxtb	r3, r4
 8002444:	2b00      	cmp	r3, #0
 8002446:	dd11      	ble.n	800246c <prvUnlockQueue+0x38>
                }
            #else /* configUSE_QUEUE_SETS */
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8002448:	6a6b      	ldr	r3, [r5, #36]	; 0x24
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800244a:	f105 0624 	add.w	r6, r5, #36	; 0x24
                }
            #else /* configUSE_QUEUE_SETS */
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800244e:	b91b      	cbnz	r3, 8002458 <prvUnlockQueue+0x24>
 8002450:	e00c      	b.n	800246c <prvUnlockQueue+0x38>
 8002452:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8002454:	b903      	cbnz	r3, 8002458 <prvUnlockQueue+0x24>
 8002456:	e009      	b.n	800246c <prvUnlockQueue+0x38>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8002458:	4630      	mov	r0, r6
 800245a:	f001 f8f7 	bl	800364c <xTaskRemoveFromEventList>
 800245e:	b108      	cbz	r0, 8002464 <prvUnlockQueue+0x30>
                        {
                            /* The task waiting has a higher priority so record that
                             * a context switch is required. */
                            vTaskMissedYield();
 8002460:	f001 f9e6 	bl	8003830 <vTaskMissedYield>
 8002464:	1e63      	subs	r3, r4, #1
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8002466:	f013 04ff 	ands.w	r4, r3, #255	; 0xff
 800246a:	d1f2      	bne.n	8002452 <prvUnlockQueue+0x1e>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
 800246c:	23ff      	movs	r3, #255	; 0xff
 800246e:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
    }
    taskEXIT_CRITICAL();
 8002472:	f7ff fcc7 	bl	8001e04 <vPortExitCritical>

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
 8002476:	f7ff fca3 	bl	8001dc0 <vPortEnterCritical>
    {
        int8_t cRxLock = pxQueue->cRxLock;
 800247a:	f895 3044 	ldrb.w	r3, [r5, #68]	; 0x44
 800247e:	b2dc      	uxtb	r4, r3

        while( cRxLock > queueLOCKED_UNMODIFIED )
 8002480:	b263      	sxtb	r3, r4
 8002482:	2b00      	cmp	r3, #0
 8002484:	dd11      	ble.n	80024aa <prvUnlockQueue+0x76>
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8002486:	692b      	ldr	r3, [r5, #16]
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8002488:	f105 0610 	add.w	r6, r5, #16
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800248c:	b91b      	cbnz	r3, 8002496 <prvUnlockQueue+0x62>
 800248e:	e00c      	b.n	80024aa <prvUnlockQueue+0x76>
 8002490:	692b      	ldr	r3, [r5, #16]
 8002492:	b903      	cbnz	r3, 8002496 <prvUnlockQueue+0x62>
 8002494:	e009      	b.n	80024aa <prvUnlockQueue+0x76>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8002496:	4630      	mov	r0, r6
 8002498:	f001 f8d8 	bl	800364c <xTaskRemoveFromEventList>
 800249c:	b108      	cbz	r0, 80024a2 <prvUnlockQueue+0x6e>
                {
                    vTaskMissedYield();
 800249e:	f001 f9c7 	bl	8003830 <vTaskMissedYield>
 80024a2:	1e63      	subs	r3, r4, #1
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
 80024a4:	f013 04ff 	ands.w	r4, r3, #255	; 0xff
 80024a8:	d1f2      	bne.n	8002490 <prvUnlockQueue+0x5c>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
 80024aa:	23ff      	movs	r3, #255	; 0xff
 80024ac:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
    }
    taskEXIT_CRITICAL();
 80024b0:	f7ff fca8 	bl	8001e04 <vPortExitCritical>
 80024b4:	bd70      	pop	{r4, r5, r6, pc}
 80024b6:	bf00      	nop

080024b8 <xQueueGenericReset>:
    taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
 80024b8:	b538      	push	{r3, r4, r5, lr}
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );
 80024ba:	b940      	cbnz	r0, 80024ce <xQueueGenericReset+0x16>
 80024bc:	f04f 0314 	mov.w	r3, #20
 80024c0:	f383 8811 	msr	BASEPRI, r3
 80024c4:	f3bf 8f6f 	isb	sy
 80024c8:	f3bf 8f4f 	dsb	sy
 80024cc:	e7fe      	b.n	80024cc <xQueueGenericReset+0x14>
 80024ce:	4604      	mov	r4, r0
 80024d0:	460d      	mov	r5, r1

    taskENTER_CRITICAL();
 80024d2:	f7ff fc75 	bl	8001dc0 <vPortEnterCritical>
    {
        pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 80024d6:	6822      	ldr	r2, [r4, #0]
 80024d8:	6c21      	ldr	r1, [r4, #64]	; 0x40
 80024da:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80024dc:	fb03 f301 	mul.w	r3, r3, r1
 80024e0:	18d0      	adds	r0, r2, r3
 80024e2:	60a0      	str	r0, [r4, #8]
        pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 80024e4:	2000      	movs	r0, #0
 80024e6:	63a0      	str	r0, [r4, #56]	; 0x38
        pxQueue->pcWriteTo = pxQueue->pcHead;
 80024e8:	6062      	str	r2, [r4, #4]
        pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 80024ea:	1a5b      	subs	r3, r3, r1
 80024ec:	4413      	add	r3, r2
 80024ee:	60e3      	str	r3, [r4, #12]
        pxQueue->cRxLock = queueUNLOCKED;
 80024f0:	23ff      	movs	r3, #255	; 0xff
 80024f2:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
        pxQueue->cTxLock = queueUNLOCKED;
 80024f6:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45

        if( xNewQueue == pdFALSE )
 80024fa:	b97d      	cbnz	r5, 800251c <xQueueGenericReset+0x64>
            /* If there are tasks blocked waiting to read from the queue, then
             * the tasks will remain blocked as after this function exits the queue
             * will still be empty.  If there are tasks blocked waiting to write to
             * the queue, then one should be unblocked as after this function exits
             * it will be possible to write to it. */
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80024fc:	6923      	ldr	r3, [r4, #16]
 80024fe:	b1ab      	cbz	r3, 800252c <xQueueGenericReset+0x74>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8002500:	f104 0010 	add.w	r0, r4, #16
 8002504:	f001 f8a2 	bl	800364c <xTaskRemoveFromEventList>
 8002508:	b180      	cbz	r0, 800252c <xQueueGenericReset+0x74>
                {
                    queueYIELD_IF_USING_PREEMPTION();
 800250a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800250e:	4b09      	ldr	r3, [pc, #36]	; (8002534 <xQueueGenericReset+0x7c>)
 8002510:	601a      	str	r2, [r3, #0]
 8002512:	f3bf 8f4f 	dsb	sy
 8002516:	f3bf 8f6f 	isb	sy
 800251a:	e007      	b.n	800252c <xQueueGenericReset+0x74>
            }
        }
        else
        {
            /* Ensure the event queues start in the correct state. */
            vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 800251c:	f104 0010 	add.w	r0, r4, #16
 8002520:	f7ff fee4 	bl	80022ec <vListInitialise>
            vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 8002524:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8002528:	f7ff fee0 	bl	80022ec <vListInitialise>
        }
    }
    taskEXIT_CRITICAL();
 800252c:	f7ff fc6a 	bl	8001e04 <vPortExitCritical>

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return pdPASS;
}
 8002530:	2001      	movs	r0, #1
 8002532:	bd38      	pop	{r3, r4, r5, pc}
 8002534:	e000ed04 	.word	0xe000ed04

08002538 <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
 8002538:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        Queue_t * pxNewQueue;
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 800253a:	b940      	cbnz	r0, 800254e <xQueueGenericCreate+0x16>
 800253c:	f04f 0314 	mov.w	r3, #20
 8002540:	f383 8811 	msr	BASEPRI, r3
 8002544:	f3bf 8f6f 	isb	sy
 8002548:	f3bf 8f4f 	dsb	sy
 800254c:	e7fe      	b.n	800254c <xQueueGenericCreate+0x14>
 800254e:	460d      	mov	r5, r1
 8002550:	4617      	mov	r7, r2
 8002552:	4606      	mov	r6, r0

        /* Allocate enough space to hold the maximum number of items that
         * can be in the queue at any time.  It is valid for uxItemSize to be
         * zero in the case the queue is used as a semaphore. */
        xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002554:	fb01 f000 	mul.w	r0, r1, r0

        /* Check for multiplication overflow. */
        configASSERT( ( uxItemSize == 0 ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );
 8002558:	b1b9      	cbz	r1, 800258a <xQueueGenericCreate+0x52>
 800255a:	fbb0 f3f1 	udiv	r3, r0, r1
 800255e:	429e      	cmp	r6, r3
 8002560:	d01e      	beq.n	80025a0 <xQueueGenericCreate+0x68>
 8002562:	f04f 0314 	mov.w	r3, #20
 8002566:	f383 8811 	msr	BASEPRI, r3
 800256a:	f3bf 8f6f 	isb	sy
 800256e:	f3bf 8f4f 	dsb	sy
 8002572:	e7fe      	b.n	8002572 <xQueueGenericCreate+0x3a>
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
 8002574:	63e6      	str	r6, [r4, #60]	; 0x3c
    pxNewQueue->uxItemSize = uxItemSize;
 8002576:	6425      	str	r5, [r4, #64]	; 0x40
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 8002578:	4620      	mov	r0, r4
 800257a:	2101      	movs	r1, #1
 800257c:	f7ff ff9c 	bl	80024b8 <xQueueGenericReset>

    #if ( configUSE_TRACE_FACILITY == 1 )
        {
            pxNewQueue->ucQueueType = ucQueueType;
 8002580:	f884 704c 	strb.w	r7, [r4, #76]	; 0x4c
 8002584:	e012      	b.n	80025ac <xQueueGenericCreate+0x74>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 8002586:	6024      	str	r4, [r4, #0]
 8002588:	e7f4      	b.n	8002574 <xQueueGenericCreate+0x3c>
         * alignment requirements of the Queue_t structure - which in this case
         * is an int8_t *.  Therefore, whenever the stack alignment requirements
         * are greater than or equal to the pointer to char requirements the cast
         * is safe.  In other cases alignment requirements are not strict (one or
         * two bytes). */
        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
 800258a:	3050      	adds	r0, #80	; 0x50
 800258c:	f001 fca6 	bl	8003edc <pvPortMalloc>

        if( pxNewQueue != NULL )
 8002590:	4604      	mov	r4, r0
 8002592:	2800      	cmp	r0, #0
 8002594:	d1f7      	bne.n	8002586 <xQueueGenericCreate+0x4e>
 8002596:	e009      	b.n	80025ac <xQueueGenericCreate+0x74>
        {
            /* Jump past the queue structure to find the location of the queue
             * storage area. */
            pucQueueStorage = ( uint8_t * ) pxNewQueue;
            pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8002598:	f104 0350 	add.w	r3, r4, #80	; 0x50
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 800259c:	6023      	str	r3, [r4, #0]
 800259e:	e7e9      	b.n	8002574 <xQueueGenericCreate+0x3c>
         * alignment requirements of the Queue_t structure - which in this case
         * is an int8_t *.  Therefore, whenever the stack alignment requirements
         * are greater than or equal to the pointer to char requirements the cast
         * is safe.  In other cases alignment requirements are not strict (one or
         * two bytes). */
        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
 80025a0:	3050      	adds	r0, #80	; 0x50
 80025a2:	f001 fc9b 	bl	8003edc <pvPortMalloc>

        if( pxNewQueue != NULL )
 80025a6:	4604      	mov	r4, r0
 80025a8:	2800      	cmp	r0, #0
 80025aa:	d1f5      	bne.n	8002598 <xQueueGenericCreate+0x60>
            traceQUEUE_CREATE_FAILED( ucQueueType );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    }
 80025ac:	4620      	mov	r0, r4
 80025ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080025b0 <xQueueCreateCountingSemaphore>:
    QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount,
                                                 const UBaseType_t uxInitialCount )
    {
        QueueHandle_t xHandle;

        configASSERT( uxMaxCount != 0 );
 80025b0:	b940      	cbnz	r0, 80025c4 <xQueueCreateCountingSemaphore+0x14>
 80025b2:	f04f 0314 	mov.w	r3, #20
 80025b6:	f383 8811 	msr	BASEPRI, r3
 80025ba:	f3bf 8f6f 	isb	sy
 80025be:	f3bf 8f4f 	dsb	sy
 80025c2:	e7fe      	b.n	80025c2 <xQueueCreateCountingSemaphore+0x12>
        configASSERT( uxInitialCount <= uxMaxCount );
 80025c4:	4288      	cmp	r0, r1
 80025c6:	d208      	bcs.n	80025da <xQueueCreateCountingSemaphore+0x2a>
 80025c8:	f04f 0314 	mov.w	r3, #20
 80025cc:	f383 8811 	msr	BASEPRI, r3
 80025d0:	f3bf 8f6f 	isb	sy
 80025d4:	f3bf 8f4f 	dsb	sy
 80025d8:	e7fe      	b.n	80025d8 <xQueueCreateCountingSemaphore+0x28>

#if ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

    QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount,
                                                 const UBaseType_t uxInitialCount )
    {
 80025da:	b510      	push	{r4, lr}
 80025dc:	460c      	mov	r4, r1
        QueueHandle_t xHandle;

        configASSERT( uxMaxCount != 0 );
        configASSERT( uxInitialCount <= uxMaxCount );

        xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
 80025de:	2100      	movs	r1, #0
 80025e0:	2202      	movs	r2, #2
 80025e2:	f7ff ffa9 	bl	8002538 <xQueueGenericCreate>

        if( xHandle != NULL )
 80025e6:	4603      	mov	r3, r0
 80025e8:	b100      	cbz	r0, 80025ec <xQueueCreateCountingSemaphore+0x3c>
        {
            ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 80025ea:	6384      	str	r4, [r0, #56]	; 0x38
        {
            traceCREATE_COUNTING_SEMAPHORE_FAILED();
        }

        return xHandle;
    }
 80025ec:	4618      	mov	r0, r3
 80025ee:	bd10      	pop	{r4, pc}

080025f0 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
 80025f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80025f4:	b085      	sub	sp, #20
 80025f6:	9201      	str	r2, [sp, #4]
    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );
 80025f8:	b940      	cbnz	r0, 800260c <xQueueGenericSend+0x1c>
 80025fa:	f04f 0314 	mov.w	r3, #20
 80025fe:	f383 8811 	msr	BASEPRI, r3
 8002602:	f3bf 8f6f 	isb	sy
 8002606:	f3bf 8f4f 	dsb	sy
 800260a:	e7fe      	b.n	800260a <xQueueGenericSend+0x1a>
 800260c:	4604      	mov	r4, r0
    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800260e:	b951      	cbnz	r1, 8002626 <xQueueGenericSend+0x36>
 8002610:	6c02      	ldr	r2, [r0, #64]	; 0x40
 8002612:	b142      	cbz	r2, 8002626 <xQueueGenericSend+0x36>
 8002614:	f04f 0314 	mov.w	r3, #20
 8002618:	f383 8811 	msr	BASEPRI, r3
 800261c:	f3bf 8f6f 	isb	sy
 8002620:	f3bf 8f4f 	dsb	sy
 8002624:	e7fe      	b.n	8002624 <xQueueGenericSend+0x34>
    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 8002626:	2b02      	cmp	r3, #2
 8002628:	d10b      	bne.n	8002642 <xQueueGenericSend+0x52>
 800262a:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800262c:	2a01      	cmp	r2, #1
 800262e:	d008      	beq.n	8002642 <xQueueGenericSend+0x52>
 8002630:	f04f 0314 	mov.w	r3, #20
 8002634:	f383 8811 	msr	BASEPRI, r3
 8002638:	f3bf 8f6f 	isb	sy
 800263c:	f3bf 8f4f 	dsb	sy
 8002640:	e7fe      	b.n	8002640 <xQueueGenericSend+0x50>
 8002642:	461d      	mov	r5, r3
 8002644:	460e      	mov	r6, r1
    #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8002646:	f001 f8ff 	bl	8003848 <xTaskGetSchedulerState>
 800264a:	b950      	cbnz	r0, 8002662 <xQueueGenericSend+0x72>
 800264c:	9b01      	ldr	r3, [sp, #4]
 800264e:	b153      	cbz	r3, 8002666 <xQueueGenericSend+0x76>
 8002650:	f04f 0314 	mov.w	r3, #20
 8002654:	f383 8811 	msr	BASEPRI, r3
 8002658:	f3bf 8f6f 	isb	sy
 800265c:	f3bf 8f4f 	dsb	sy
 8002660:	e7fe      	b.n	8002660 <xQueueGenericSend+0x70>
 8002662:	2700      	movs	r7, #0
 8002664:	e000      	b.n	8002668 <xQueueGenericSend+0x78>
 8002666:	2700      	movs	r7, #0
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
                    xEntryTimeSet = pdTRUE;
 8002668:	f04f 0901 	mov.w	r9, #1
                 * task is already in a ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
                {
                    portYIELD_WITHIN_API();
 800266c:	f8df 8104 	ldr.w	r8, [pc, #260]	; 8002774 <xQueueGenericSend+0x184>
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
 8002670:	f7ff fba6 	bl	8001dc0 <vPortEnterCritical>
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8002674:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8002676:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8002678:	429a      	cmp	r2, r3
 800267a:	d301      	bcc.n	8002680 <xQueueGenericSend+0x90>
 800267c:	2d02      	cmp	r5, #2
 800267e:	d121      	bne.n	80026c4 <xQueueGenericSend+0xd4>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8002680:	4620      	mov	r0, r4
 8002682:	4631      	mov	r1, r6
 8002684:	462a      	mov	r2, r5
 8002686:	f7ff fe87 	bl	8002398 <prvCopyDataToQueue>

                        /* If there was a task waiting for data to arrive on the
                         * queue then unblock it now. */
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800268a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800268c:	b16b      	cbz	r3, 80026aa <xQueueGenericSend+0xba>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800268e:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8002692:	f000 ffdb 	bl	800364c <xTaskRemoveFromEventList>
 8002696:	b188      	cbz	r0, 80026bc <xQueueGenericSend+0xcc>
                            {
                                /* The unblocked task has a priority higher than
                                 * our own so yield immediately.  Yes it is ok to do
                                 * this from within the critical section - the kernel
                                 * takes care of that. */
                                queueYIELD_IF_USING_PREEMPTION();
 8002698:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800269c:	4b35      	ldr	r3, [pc, #212]	; (8002774 <xQueueGenericSend+0x184>)
 800269e:	601a      	str	r2, [r3, #0]
 80026a0:	f3bf 8f4f 	dsb	sy
 80026a4:	f3bf 8f6f 	isb	sy
 80026a8:	e008      	b.n	80026bc <xQueueGenericSend+0xcc>
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                        else if( xYieldRequired != pdFALSE )
 80026aa:	b138      	cbz	r0, 80026bc <xQueueGenericSend+0xcc>
                        {
                            /* This path is a special case that will only get
                             * executed if the task was holding multiple mutexes and
                             * the mutexes were given back in an order that is
                             * different to that in which they were taken. */
                            queueYIELD_IF_USING_PREEMPTION();
 80026ac:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80026b0:	4b30      	ldr	r3, [pc, #192]	; (8002774 <xQueueGenericSend+0x184>)
 80026b2:	601a      	str	r2, [r3, #0]
 80026b4:	f3bf 8f4f 	dsb	sy
 80026b8:	f3bf 8f6f 	isb	sy
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
 80026bc:	f7ff fba2 	bl	8001e04 <vPortExitCritical>
                return pdPASS;
 80026c0:	2001      	movs	r0, #1
 80026c2:	e054      	b.n	800276e <xQueueGenericSend+0x17e>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
 80026c4:	9b01      	ldr	r3, [sp, #4]
 80026c6:	b91b      	cbnz	r3, 80026d0 <xQueueGenericSend+0xe0>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
 80026c8:	f7ff fb9c 	bl	8001e04 <vPortExitCritical>

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
 80026cc:	2000      	movs	r0, #0
 80026ce:	e04e      	b.n	800276e <xQueueGenericSend+0x17e>
                }
                else if( xEntryTimeSet == pdFALSE )
 80026d0:	b91f      	cbnz	r7, 80026da <xQueueGenericSend+0xea>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
 80026d2:	a802      	add	r0, sp, #8
 80026d4:	f001 f85e 	bl	8003794 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
 80026d8:	464f      	mov	r7, r9
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
 80026da:	f7ff fb93 	bl	8001e04 <vPortExitCritical>

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
 80026de:	f000 fd65 	bl	80031ac <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 80026e2:	f7ff fb6d 	bl	8001dc0 <vPortEnterCritical>
 80026e6:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 80026ea:	b25b      	sxtb	r3, r3
 80026ec:	f1b3 3fff 	cmp.w	r3, #4294967295
 80026f0:	bf04      	itt	eq
 80026f2:	2300      	moveq	r3, #0
 80026f4:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
 80026f8:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 80026fc:	b25b      	sxtb	r3, r3
 80026fe:	f1b3 3fff 	cmp.w	r3, #4294967295
 8002702:	bf04      	itt	eq
 8002704:	2300      	moveq	r3, #0
 8002706:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
 800270a:	f7ff fb7b 	bl	8001e04 <vPortExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800270e:	a802      	add	r0, sp, #8
 8002710:	a901      	add	r1, sp, #4
 8002712:	f001 f84b 	bl	80037ac <xTaskCheckForTimeOut>
 8002716:	bb20      	cbnz	r0, 8002762 <xQueueGenericSend+0x172>

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
 8002718:	f7ff fb52 	bl	8001dc0 <vPortEnterCritical>
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 800271c:	f8d4 b038 	ldr.w	fp, [r4, #56]	; 0x38
 8002720:	f8d4 a03c 	ldr.w	sl, [r4, #60]	; 0x3c
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
 8002724:	f7ff fb6e 	bl	8001e04 <vPortExitCritical>
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
 8002728:	45d3      	cmp	fp, sl
 800272a:	d114      	bne.n	8002756 <xQueueGenericSend+0x166>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 800272c:	f104 0010 	add.w	r0, r4, #16
 8002730:	9901      	ldr	r1, [sp, #4]
 8002732:	f000 ff27 	bl	8003584 <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list.  It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready last instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
 8002736:	4620      	mov	r0, r4
 8002738:	f7ff fe7c 	bl	8002434 <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in a ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
 800273c:	f000 fdd6 	bl	80032ec <xTaskResumeAll>
 8002740:	2800      	cmp	r0, #0
 8002742:	d195      	bne.n	8002670 <xQueueGenericSend+0x80>
                {
                    portYIELD_WITHIN_API();
 8002744:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8002748:	f8c8 3000 	str.w	r3, [r8]
 800274c:	f3bf 8f4f 	dsb	sy
 8002750:	f3bf 8f6f 	isb	sy
 8002754:	e78c      	b.n	8002670 <xQueueGenericSend+0x80>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
 8002756:	4620      	mov	r0, r4
 8002758:	f7ff fe6c 	bl	8002434 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
 800275c:	f000 fdc6 	bl	80032ec <xTaskResumeAll>
 8002760:	e786      	b.n	8002670 <xQueueGenericSend+0x80>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
 8002762:	4620      	mov	r0, r4
 8002764:	f7ff fe66 	bl	8002434 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
 8002768:	f000 fdc0 	bl	80032ec <xTaskResumeAll>

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
 800276c:	2000      	movs	r0, #0
        }
    } /*lint -restore */
}
 800276e:	b005      	add	sp, #20
 8002770:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8002774:	e000ed04 	.word	0xe000ed04

08002778 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

    QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
    {
 8002778:	b510      	push	{r4, lr}
 800277a:	4602      	mov	r2, r0
        QueueHandle_t xNewQueue;
        const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;

        xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 800277c:	2001      	movs	r0, #1
 800277e:	2100      	movs	r1, #0
 8002780:	f7ff feda 	bl	8002538 <xQueueGenericCreate>

#if ( configUSE_MUTEXES == 1 )

    static void prvInitialiseMutex( Queue_t * pxNewQueue )
    {
        if( pxNewQueue != NULL )
 8002784:	4604      	mov	r4, r0
 8002786:	b138      	cbz	r0, 8002798 <xQueueCreateMutex+0x20>
        {
            /* The queue create function will set all the queue structure members
            * correctly for a generic queue, but this function is creating a
            * mutex.  Overwrite those members that need to be set differently -
            * in particular the information required for priority inheritance. */
            pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 8002788:	2300      	movs	r3, #0
 800278a:	6083      	str	r3, [r0, #8]
            pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 800278c:	6003      	str	r3, [r0, #0]

            /* In case this is a recursive mutex. */
            pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
 800278e:	60c3      	str	r3, [r0, #12]

            traceCREATE_MUTEX( pxNewQueue );

            /* Start with the semaphore in the expected state. */
            ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 8002790:	4619      	mov	r1, r3
 8002792:	461a      	mov	r2, r3
 8002794:	f7ff ff2c 	bl	80025f0 <xQueueGenericSend>

        xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
        prvInitialiseMutex( ( Queue_t * ) xNewQueue );

        return xNewQueue;
    }
 8002798:	4620      	mov	r0, r4
 800279a:	bd10      	pop	{r4, pc}

0800279c <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
 800279c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );
 80027a0:	b940      	cbnz	r0, 80027b4 <xQueueGenericSendFromISR+0x18>
 80027a2:	f04f 0314 	mov.w	r3, #20
 80027a6:	f383 8811 	msr	BASEPRI, r3
 80027aa:	f3bf 8f6f 	isb	sy
 80027ae:	f3bf 8f4f 	dsb	sy
 80027b2:	e7fe      	b.n	80027b2 <xQueueGenericSendFromISR+0x16>
 80027b4:	4604      	mov	r4, r0
    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80027b6:	b951      	cbnz	r1, 80027ce <xQueueGenericSendFromISR+0x32>
 80027b8:	6c00      	ldr	r0, [r0, #64]	; 0x40
 80027ba:	b140      	cbz	r0, 80027ce <xQueueGenericSendFromISR+0x32>
 80027bc:	f04f 0314 	mov.w	r3, #20
 80027c0:	f383 8811 	msr	BASEPRI, r3
 80027c4:	f3bf 8f6f 	isb	sy
 80027c8:	f3bf 8f4f 	dsb	sy
 80027cc:	e7fe      	b.n	80027cc <xQueueGenericSendFromISR+0x30>
    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 80027ce:	2b02      	cmp	r3, #2
 80027d0:	d10b      	bne.n	80027ea <xQueueGenericSendFromISR+0x4e>
 80027d2:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 80027d4:	2801      	cmp	r0, #1
 80027d6:	d008      	beq.n	80027ea <xQueueGenericSendFromISR+0x4e>
 80027d8:	f04f 0314 	mov.w	r3, #20
 80027dc:	f383 8811 	msr	BASEPRI, r3
 80027e0:	f3bf 8f6f 	isb	sy
 80027e4:	f3bf 8f4f 	dsb	sy
 80027e8:	e7fe      	b.n	80027e8 <xQueueGenericSendFromISR+0x4c>
 80027ea:	4698      	mov	r8, r3
 80027ec:	4616      	mov	r6, r2
 80027ee:	4689      	mov	r9, r1
     * that have been assigned a priority at or (logically) below the maximum
     * system call interrupt priority.  FreeRTOS maintains a separate interrupt
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 80027f0:	f7ff fc14 	bl	800201c <vPortValidateInterruptPriority>

    portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
    {
        uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

        __asm volatile
 80027f4:	f3ef 8711 	mrs	r7, BASEPRI
 80027f8:	f04f 0314 	mov.w	r3, #20
 80027fc:	f383 8811 	msr	BASEPRI, r3
 8002800:	f3bf 8f6f 	isb	sy
 8002804:	f3bf 8f4f 	dsb	sy
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8002808:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800280a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800280c:	429a      	cmp	r2, r3
 800280e:	d302      	bcc.n	8002816 <xQueueGenericSendFromISR+0x7a>
 8002810:	f1b8 0f02 	cmp.w	r8, #2
 8002814:	d129      	bne.n	800286a <xQueueGenericSendFromISR+0xce>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
 8002816:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
 800281a:	b2ed      	uxtb	r5, r5
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 800281c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800281e:	4620      	mov	r0, r4
 8002820:	4649      	mov	r1, r9
 8002822:	4642      	mov	r2, r8
 8002824:	f7ff fdb8 	bl	8002398 <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
 8002828:	b26b      	sxtb	r3, r5
 800282a:	f1b3 3fff 	cmp.w	r3, #4294967295
 800282e:	d10a      	bne.n	8002846 <xQueueGenericSendFromISR+0xaa>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8002830:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8002832:	b1e3      	cbz	r3, 800286e <xQueueGenericSendFromISR+0xd2>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8002834:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8002838:	f000 ff08 	bl	800364c <xTaskRemoveFromEventList>
 800283c:	b1c8      	cbz	r0, 8002872 <xQueueGenericSendFromISR+0xd6>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
 800283e:	b1d6      	cbz	r6, 8002876 <xQueueGenericSendFromISR+0xda>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
 8002840:	2001      	movs	r0, #1
 8002842:	6030      	str	r0, [r6, #0]
 8002844:	e018      	b.n	8002878 <xQueueGenericSendFromISR+0xdc>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );
 8002846:	b26b      	sxtb	r3, r5
 8002848:	2b7f      	cmp	r3, #127	; 0x7f
 800284a:	d108      	bne.n	800285e <xQueueGenericSendFromISR+0xc2>

    portFORCE_INLINE static void vPortRaiseBASEPRI( void )
    {
        uint32_t ulNewBASEPRI;

        __asm volatile
 800284c:	f04f 0314 	mov.w	r3, #20
 8002850:	f383 8811 	msr	BASEPRI, r3
 8002854:	f3bf 8f6f 	isb	sy
 8002858:	f3bf 8f4f 	dsb	sy
 800285c:	e7fe      	b.n	800285c <xQueueGenericSendFromISR+0xc0>

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 800285e:	1c6b      	adds	r3, r5, #1
 8002860:	b2db      	uxtb	r3, r3
 8002862:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
            }

            xReturn = pdPASS;
 8002866:	2001      	movs	r0, #1
 8002868:	e006      	b.n	8002878 <xQueueGenericSendFromISR+0xdc>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
 800286a:	2000      	movs	r0, #0
 800286c:	e004      	b.n	8002878 <xQueueGenericSendFromISR+0xdc>
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
            }

            xReturn = pdPASS;
 800286e:	2001      	movs	r0, #1
 8002870:	e002      	b.n	8002878 <xQueueGenericSendFromISR+0xdc>
 8002872:	2001      	movs	r0, #1
 8002874:	e000      	b.n	8002878 <xQueueGenericSendFromISR+0xdc>
 8002876:	2001      	movs	r0, #1
    }
/*-----------------------------------------------------------*/

    portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
    {
        __asm volatile
 8002878:	f387 8811 	msr	BASEPRI, r7
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
 800287c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

08002880 <xQueueGiveFromISR>:
     * item size is 0.  Don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */

    configASSERT( pxQueue );
 8002880:	b940      	cbnz	r0, 8002894 <xQueueGiveFromISR+0x14>

    portFORCE_INLINE static void vPortRaiseBASEPRI( void )
    {
        uint32_t ulNewBASEPRI;

        __asm volatile
 8002882:	f04f 0314 	mov.w	r3, #20
 8002886:	f383 8811 	msr	BASEPRI, r3
 800288a:	f3bf 8f6f 	isb	sy
 800288e:	f3bf 8f4f 	dsb	sy
 8002892:	e7fe      	b.n	8002892 <xQueueGiveFromISR+0x12>
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
 8002894:	b570      	push	{r4, r5, r6, lr}
 8002896:	4604      	mov	r4, r0

    configASSERT( pxQueue );

    /* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
     * if the item size is not 0. */
    configASSERT( pxQueue->uxItemSize == 0 );
 8002898:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800289a:	b143      	cbz	r3, 80028ae <xQueueGiveFromISR+0x2e>
 800289c:	f04f 0314 	mov.w	r3, #20
 80028a0:	f383 8811 	msr	BASEPRI, r3
 80028a4:	f3bf 8f6f 	isb	sy
 80028a8:	f3bf 8f4f 	dsb	sy
 80028ac:	e7fe      	b.n	80028ac <xQueueGiveFromISR+0x2c>

    /* Normally a mutex would not be given from an interrupt, especially if
     * there is a mutex holder, as priority inheritance makes no sense for an
     * interrupts, only tasks. */
    configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
 80028ae:	6803      	ldr	r3, [r0, #0]
 80028b0:	b953      	cbnz	r3, 80028c8 <xQueueGiveFromISR+0x48>
 80028b2:	6883      	ldr	r3, [r0, #8]
 80028b4:	b143      	cbz	r3, 80028c8 <xQueueGiveFromISR+0x48>
 80028b6:	f04f 0314 	mov.w	r3, #20
 80028ba:	f383 8811 	msr	BASEPRI, r3
 80028be:	f3bf 8f6f 	isb	sy
 80028c2:	f3bf 8f4f 	dsb	sy
 80028c6:	e7fe      	b.n	80028c6 <xQueueGiveFromISR+0x46>
 80028c8:	460d      	mov	r5, r1
     * that have been assigned a priority at or (logically) below the maximum
     * system call interrupt priority.  FreeRTOS maintains a separate interrupt
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 80028ca:	f7ff fba7 	bl	800201c <vPortValidateInterruptPriority>

    portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
    {
        uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

        __asm volatile
 80028ce:	f3ef 8611 	mrs	r6, BASEPRI
 80028d2:	f04f 0314 	mov.w	r3, #20
 80028d6:	f383 8811 	msr	BASEPRI, r3
 80028da:	f3bf 8f6f 	isb	sy
 80028de:	f3bf 8f4f 	dsb	sy

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 80028e2:	6ba3      	ldr	r3, [r4, #56]	; 0x38

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
 80028e4:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 80028e6:	4293      	cmp	r3, r2
 80028e8:	d223      	bcs.n	8002932 <xQueueGiveFromISR+0xb2>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
 80028ea:	f894 2045 	ldrb.w	r2, [r4, #69]	; 0x45
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 80028ee:	3301      	adds	r3, #1
 80028f0:	63a3      	str	r3, [r4, #56]	; 0x38

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
 80028f2:	b2d3      	uxtb	r3, r2
 80028f4:	2aff      	cmp	r2, #255	; 0xff
 80028f6:	d10a      	bne.n	800290e <xQueueGiveFromISR+0x8e>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80028f8:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80028fa:	b1e3      	cbz	r3, 8002936 <xQueueGiveFromISR+0xb6>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80028fc:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8002900:	f000 fea4 	bl	800364c <xTaskRemoveFromEventList>
 8002904:	b1c8      	cbz	r0, 800293a <xQueueGiveFromISR+0xba>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
 8002906:	b1d5      	cbz	r5, 800293e <xQueueGiveFromISR+0xbe>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
 8002908:	2001      	movs	r0, #1
 800290a:	6028      	str	r0, [r5, #0]
 800290c:	e018      	b.n	8002940 <xQueueGiveFromISR+0xc0>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );
 800290e:	b25a      	sxtb	r2, r3
 8002910:	2a7f      	cmp	r2, #127	; 0x7f
 8002912:	d108      	bne.n	8002926 <xQueueGiveFromISR+0xa6>

    portFORCE_INLINE static void vPortRaiseBASEPRI( void )
    {
        uint32_t ulNewBASEPRI;

        __asm volatile
 8002914:	f04f 0314 	mov.w	r3, #20
 8002918:	f383 8811 	msr	BASEPRI, r3
 800291c:	f3bf 8f6f 	isb	sy
 8002920:	f3bf 8f4f 	dsb	sy
 8002924:	e7fe      	b.n	8002924 <xQueueGiveFromISR+0xa4>

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 8002926:	3301      	adds	r3, #1
 8002928:	b2db      	uxtb	r3, r3
 800292a:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
            }

            xReturn = pdPASS;
 800292e:	2001      	movs	r0, #1
 8002930:	e006      	b.n	8002940 <xQueueGiveFromISR+0xc0>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
 8002932:	2000      	movs	r0, #0
 8002934:	e004      	b.n	8002940 <xQueueGiveFromISR+0xc0>
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
            }

            xReturn = pdPASS;
 8002936:	2001      	movs	r0, #1
 8002938:	e002      	b.n	8002940 <xQueueGiveFromISR+0xc0>
 800293a:	2001      	movs	r0, #1
 800293c:	e000      	b.n	8002940 <xQueueGiveFromISR+0xc0>
 800293e:	2001      	movs	r0, #1
    }
/*-----------------------------------------------------------*/

    portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
    {
        __asm volatile
 8002940:	f386 8811 	msr	BASEPRI, r6
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
 8002944:	bd70      	pop	{r4, r5, r6, pc}
 8002946:	bf00      	nop

08002948 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
 8002948:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800294c:	b085      	sub	sp, #20
 800294e:	9201      	str	r2, [sp, #4]
    BaseType_t xEntryTimeSet = pdFALSE;
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;

    /* Check the pointer is not NULL. */
    configASSERT( ( pxQueue ) );
 8002950:	b940      	cbnz	r0, 8002964 <xQueueReceive+0x1c>

    portFORCE_INLINE static void vPortRaiseBASEPRI( void )
    {
        uint32_t ulNewBASEPRI;

        __asm volatile
 8002952:	f04f 0314 	mov.w	r3, #20
 8002956:	f383 8811 	msr	BASEPRI, r3
 800295a:	f3bf 8f6f 	isb	sy
 800295e:	f3bf 8f4f 	dsb	sy
 8002962:	e7fe      	b.n	8002962 <xQueueReceive+0x1a>
 8002964:	4604      	mov	r4, r0

    /* The buffer into which data is received can only be NULL if the data size
     * is zero (so no data is copied into the buffer). */
    configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8002966:	b951      	cbnz	r1, 800297e <xQueueReceive+0x36>
 8002968:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800296a:	b143      	cbz	r3, 800297e <xQueueReceive+0x36>
 800296c:	f04f 0314 	mov.w	r3, #20
 8002970:	f383 8811 	msr	BASEPRI, r3
 8002974:	f3bf 8f6f 	isb	sy
 8002978:	f3bf 8f4f 	dsb	sy
 800297c:	e7fe      	b.n	800297c <xQueueReceive+0x34>
 800297e:	460e      	mov	r6, r1

    /* Cannot block if the scheduler is suspended. */
    #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8002980:	f000 ff62 	bl	8003848 <xTaskGetSchedulerState>
 8002984:	b950      	cbnz	r0, 800299c <xQueueReceive+0x54>
 8002986:	9b01      	ldr	r3, [sp, #4]
 8002988:	b153      	cbz	r3, 80029a0 <xQueueReceive+0x58>
 800298a:	f04f 0314 	mov.w	r3, #20
 800298e:	f383 8811 	msr	BASEPRI, r3
 8002992:	f3bf 8f6f 	isb	sy
 8002996:	f3bf 8f4f 	dsb	sy
 800299a:	e7fe      	b.n	800299a <xQueueReceive+0x52>
 800299c:	2700      	movs	r7, #0
 800299e:	e000      	b.n	80029a2 <xQueueReceive+0x5a>
 80029a0:	2700      	movs	r7, #0
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
                    xEntryTimeSet = pdTRUE;
 80029a2:	f04f 0901 	mov.w	r9, #1
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
                prvUnlockQueue( pxQueue );

                if( xTaskResumeAll() == pdFALSE )
                {
                    portYIELD_WITHIN_API();
 80029a6:	f8df 80ec 	ldr.w	r8, [pc, #236]	; 8002a94 <xQueueReceive+0x14c>
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
 80029aa:	f7ff fa09 	bl	8001dc0 <vPortEnterCritical>
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 80029ae:	6ba5      	ldr	r5, [r4, #56]	; 0x38

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 80029b0:	b1c5      	cbz	r5, 80029e4 <xQueueReceive+0x9c>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
 80029b2:	4620      	mov	r0, r4
 80029b4:	4631      	mov	r1, r6
 80029b6:	f7ff fd2b 	bl	8002410 <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 80029ba:	3d01      	subs	r5, #1
 80029bc:	63a5      	str	r5, [r4, #56]	; 0x38

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80029be:	6923      	ldr	r3, [r4, #16]
 80029c0:	b163      	cbz	r3, 80029dc <xQueueReceive+0x94>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80029c2:	f104 0010 	add.w	r0, r4, #16
 80029c6:	f000 fe41 	bl	800364c <xTaskRemoveFromEventList>
 80029ca:	b138      	cbz	r0, 80029dc <xQueueReceive+0x94>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
 80029cc:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80029d0:	4b30      	ldr	r3, [pc, #192]	; (8002a94 <xQueueReceive+0x14c>)
 80029d2:	601a      	str	r2, [r3, #0]
 80029d4:	f3bf 8f4f 	dsb	sy
 80029d8:	f3bf 8f6f 	isb	sy
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
 80029dc:	f7ff fa12 	bl	8001e04 <vPortExitCritical>
                return pdPASS;
 80029e0:	2001      	movs	r0, #1
 80029e2:	e053      	b.n	8002a8c <xQueueReceive+0x144>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
 80029e4:	9b01      	ldr	r3, [sp, #4]
 80029e6:	b91b      	cbnz	r3, 80029f0 <xQueueReceive+0xa8>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
 80029e8:	f7ff fa0c 	bl	8001e04 <vPortExitCritical>
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
 80029ec:	2000      	movs	r0, #0
 80029ee:	e04d      	b.n	8002a8c <xQueueReceive+0x144>
                }
                else if( xEntryTimeSet == pdFALSE )
 80029f0:	b91f      	cbnz	r7, 80029fa <xQueueReceive+0xb2>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
 80029f2:	a802      	add	r0, sp, #8
 80029f4:	f000 fece 	bl	8003794 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
 80029f8:	464f      	mov	r7, r9
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
 80029fa:	f7ff fa03 	bl	8001e04 <vPortExitCritical>

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
 80029fe:	f000 fbd5 	bl	80031ac <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 8002a02:	f7ff f9dd 	bl	8001dc0 <vPortEnterCritical>
 8002a06:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8002a0a:	b25b      	sxtb	r3, r3
 8002a0c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8002a10:	bf04      	itt	eq
 8002a12:	2300      	moveq	r3, #0
 8002a14:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
 8002a18:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8002a1c:	b25b      	sxtb	r3, r3
 8002a1e:	f1b3 3fff 	cmp.w	r3, #4294967295
 8002a22:	bf04      	itt	eq
 8002a24:	2300      	moveq	r3, #0
 8002a26:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
 8002a2a:	f7ff f9eb 	bl	8001e04 <vPortExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8002a2e:	a802      	add	r0, sp, #8
 8002a30:	a901      	add	r1, sp, #4
 8002a32:	f000 febb 	bl	80037ac <xTaskCheckForTimeOut>
 8002a36:	b9f0      	cbnz	r0, 8002a76 <xQueueReceive+0x12e>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8002a38:	4620      	mov	r0, r4
 8002a3a:	f7ff fca1 	bl	8002380 <prvIsQueueEmpty>
 8002a3e:	b1a0      	cbz	r0, 8002a6a <xQueueReceive+0x122>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8002a40:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8002a44:	9901      	ldr	r1, [sp, #4]
 8002a46:	f000 fd9d 	bl	8003584 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
 8002a4a:	4620      	mov	r0, r4
 8002a4c:	f7ff fcf2 	bl	8002434 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
 8002a50:	f000 fc4c 	bl	80032ec <xTaskResumeAll>
 8002a54:	2800      	cmp	r0, #0
 8002a56:	d1a8      	bne.n	80029aa <xQueueReceive+0x62>
                {
                    portYIELD_WITHIN_API();
 8002a58:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8002a5c:	f8c8 3000 	str.w	r3, [r8]
 8002a60:	f3bf 8f4f 	dsb	sy
 8002a64:	f3bf 8f6f 	isb	sy
 8002a68:	e79f      	b.n	80029aa <xQueueReceive+0x62>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
 8002a6a:	4620      	mov	r0, r4
 8002a6c:	f7ff fce2 	bl	8002434 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
 8002a70:	f000 fc3c 	bl	80032ec <xTaskResumeAll>
 8002a74:	e799      	b.n	80029aa <xQueueReceive+0x62>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
 8002a76:	4620      	mov	r0, r4
 8002a78:	f7ff fcdc 	bl	8002434 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
 8002a7c:	f000 fc36 	bl	80032ec <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8002a80:	4620      	mov	r0, r4
 8002a82:	f7ff fc7d 	bl	8002380 <prvIsQueueEmpty>
 8002a86:	2800      	cmp	r0, #0
 8002a88:	d08f      	beq.n	80029aa <xQueueReceive+0x62>
            {
                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
 8002a8a:	2000      	movs	r0, #0
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
 8002a8c:	b005      	add	sp, #20
 8002a8e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8002a92:	bf00      	nop
 8002a94:	e000ed04 	.word	0xe000ed04

08002a98 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
 8002a98:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002a9c:	b084      	sub	sp, #16
 8002a9e:	9101      	str	r1, [sp, #4]
    #if ( configUSE_MUTEXES == 1 )
        BaseType_t xInheritanceOccurred = pdFALSE;
    #endif

    /* Check the queue pointer is not NULL. */
    configASSERT( ( pxQueue ) );
 8002aa0:	b940      	cbnz	r0, 8002ab4 <xQueueSemaphoreTake+0x1c>
 8002aa2:	f04f 0314 	mov.w	r3, #20
 8002aa6:	f383 8811 	msr	BASEPRI, r3
 8002aaa:	f3bf 8f6f 	isb	sy
 8002aae:	f3bf 8f4f 	dsb	sy
 8002ab2:	e7fe      	b.n	8002ab2 <xQueueSemaphoreTake+0x1a>
 8002ab4:	4604      	mov	r4, r0

    /* Check this really is a semaphore, in which case the item size will be
     * 0. */
    configASSERT( pxQueue->uxItemSize == 0 );
 8002ab6:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8002ab8:	b143      	cbz	r3, 8002acc <xQueueSemaphoreTake+0x34>
 8002aba:	f04f 0314 	mov.w	r3, #20
 8002abe:	f383 8811 	msr	BASEPRI, r3
 8002ac2:	f3bf 8f6f 	isb	sy
 8002ac6:	f3bf 8f4f 	dsb	sy
 8002aca:	e7fe      	b.n	8002aca <xQueueSemaphoreTake+0x32>

    /* Cannot block if the scheduler is suspended. */
    #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8002acc:	f000 febc 	bl	8003848 <xTaskGetSchedulerState>
 8002ad0:	b950      	cbnz	r0, 8002ae8 <xQueueSemaphoreTake+0x50>
 8002ad2:	9b01      	ldr	r3, [sp, #4]
 8002ad4:	b15b      	cbz	r3, 8002aee <xQueueSemaphoreTake+0x56>
 8002ad6:	f04f 0314 	mov.w	r3, #20
 8002ada:	f383 8811 	msr	BASEPRI, r3
 8002ade:	f3bf 8f6f 	isb	sy
 8002ae2:	f3bf 8f4f 	dsb	sy
 8002ae6:	e7fe      	b.n	8002ae6 <xQueueSemaphoreTake+0x4e>
 8002ae8:	2500      	movs	r5, #0
 8002aea:	462e      	mov	r6, r5
 8002aec:	e001      	b.n	8002af2 <xQueueSemaphoreTake+0x5a>
 8002aee:	2500      	movs	r5, #0
 8002af0:	462e      	mov	r6, r5
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
                    xEntryTimeSet = pdTRUE;
 8002af2:	f04f 0801 	mov.w	r8, #1
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
                prvUnlockQueue( pxQueue );

                if( xTaskResumeAll() == pdFALSE )
                {
                    portYIELD_WITHIN_API();
 8002af6:	4f4e      	ldr	r7, [pc, #312]	; (8002c30 <xQueueSemaphoreTake+0x198>)
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
 8002af8:	f7ff f962 	bl	8001dc0 <vPortEnterCritical>
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 8002afc:	6ba3      	ldr	r3, [r4, #56]	; 0x38

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 8002afe:	b1cb      	cbz	r3, 8002b34 <xQueueSemaphoreTake+0x9c>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
 8002b00:	3b01      	subs	r3, #1
 8002b02:	63a3      	str	r3, [r4, #56]	; 0x38

                #if ( configUSE_MUTEXES == 1 )
                    {
                        if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8002b04:	6823      	ldr	r3, [r4, #0]
 8002b06:	b913      	cbnz	r3, 8002b0e <xQueueSemaphoreTake+0x76>
                        {
                            /* Record the information required to implement
                             * priority inheritance should it become necessary. */
                            pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
 8002b08:	f000 ffbe 	bl	8003a88 <pvTaskIncrementMutexHeldCount>
 8002b0c:	60a0      	str	r0, [r4, #8]
                    }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8002b0e:	6923      	ldr	r3, [r4, #16]
 8002b10:	b163      	cbz	r3, 8002b2c <xQueueSemaphoreTake+0x94>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8002b12:	f104 0010 	add.w	r0, r4, #16
 8002b16:	f000 fd99 	bl	800364c <xTaskRemoveFromEventList>
 8002b1a:	b138      	cbz	r0, 8002b2c <xQueueSemaphoreTake+0x94>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
 8002b1c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8002b20:	4b43      	ldr	r3, [pc, #268]	; (8002c30 <xQueueSemaphoreTake+0x198>)
 8002b22:	601a      	str	r2, [r3, #0]
 8002b24:	f3bf 8f4f 	dsb	sy
 8002b28:	f3bf 8f6f 	isb	sy
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
 8002b2c:	f7ff f96a 	bl	8001e04 <vPortExitCritical>
                return pdPASS;
 8002b30:	2001      	movs	r0, #1
 8002b32:	e079      	b.n	8002c28 <xQueueSemaphoreTake+0x190>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
 8002b34:	9b01      	ldr	r3, [sp, #4]
 8002b36:	b96b      	cbnz	r3, 8002b54 <xQueueSemaphoreTake+0xbc>
                    /* For inheritance to have occurred there must have been an
                     * initial timeout, and an adjusted timeout cannot become 0, as
                     * if it were 0 the function would have exited. */
                    #if ( configUSE_MUTEXES == 1 )
                        {
                            configASSERT( xInheritanceOccurred == pdFALSE );
 8002b38:	b145      	cbz	r5, 8002b4c <xQueueSemaphoreTake+0xb4>
 8002b3a:	f04f 0314 	mov.w	r3, #20
 8002b3e:	f383 8811 	msr	BASEPRI, r3
 8002b42:	f3bf 8f6f 	isb	sy
 8002b46:	f3bf 8f4f 	dsb	sy
 8002b4a:	e7fe      	b.n	8002b4a <xQueueSemaphoreTake+0xb2>
                        }
                    #endif /* configUSE_MUTEXES */

                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
 8002b4c:	f7ff f95a 	bl	8001e04 <vPortExitCritical>
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
 8002b50:	2000      	movs	r0, #0
 8002b52:	e069      	b.n	8002c28 <xQueueSemaphoreTake+0x190>
                }
                else if( xEntryTimeSet == pdFALSE )
 8002b54:	b91e      	cbnz	r6, 8002b5e <xQueueSemaphoreTake+0xc6>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
 8002b56:	a802      	add	r0, sp, #8
 8002b58:	f000 fe1c 	bl	8003794 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
 8002b5c:	4646      	mov	r6, r8
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
 8002b5e:	f7ff f951 	bl	8001e04 <vPortExitCritical>

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
 8002b62:	f000 fb23 	bl	80031ac <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 8002b66:	f7ff f92b 	bl	8001dc0 <vPortEnterCritical>
 8002b6a:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8002b6e:	b25b      	sxtb	r3, r3
 8002b70:	f1b3 3fff 	cmp.w	r3, #4294967295
 8002b74:	bf04      	itt	eq
 8002b76:	2300      	moveq	r3, #0
 8002b78:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
 8002b7c:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8002b80:	b25b      	sxtb	r3, r3
 8002b82:	f1b3 3fff 	cmp.w	r3, #4294967295
 8002b86:	bf04      	itt	eq
 8002b88:	2300      	moveq	r3, #0
 8002b8a:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
 8002b8e:	f7ff f939 	bl	8001e04 <vPortExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8002b92:	a802      	add	r0, sp, #8
 8002b94:	a901      	add	r1, sp, #4
 8002b96:	f000 fe09 	bl	80037ac <xTaskCheckForTimeOut>
 8002b9a:	bb38      	cbnz	r0, 8002bec <xQueueSemaphoreTake+0x154>
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8002b9c:	4620      	mov	r0, r4
 8002b9e:	f7ff fbef 	bl	8002380 <prvIsQueueEmpty>
 8002ba2:	b1e8      	cbz	r0, 8002be0 <xQueueSemaphoreTake+0x148>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

                #if ( configUSE_MUTEXES == 1 )
                    {
                        if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8002ba4:	6823      	ldr	r3, [r4, #0]
 8002ba6:	b93b      	cbnz	r3, 8002bb8 <xQueueSemaphoreTake+0x120>
                        {
                            taskENTER_CRITICAL();
 8002ba8:	f7ff f90a 	bl	8001dc0 <vPortEnterCritical>
                            {
                                xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
 8002bac:	68a0      	ldr	r0, [r4, #8]
 8002bae:	f000 fe5b 	bl	8003868 <xTaskPriorityInherit>
 8002bb2:	4605      	mov	r5, r0
                            }
                            taskEXIT_CRITICAL();
 8002bb4:	f7ff f926 	bl	8001e04 <vPortExitCritical>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8002bb8:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8002bbc:	9901      	ldr	r1, [sp, #4]
 8002bbe:	f000 fce1 	bl	8003584 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
 8002bc2:	4620      	mov	r0, r4
 8002bc4:	f7ff fc36 	bl	8002434 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
 8002bc8:	f000 fb90 	bl	80032ec <xTaskResumeAll>
 8002bcc:	2800      	cmp	r0, #0
 8002bce:	d193      	bne.n	8002af8 <xQueueSemaphoreTake+0x60>
                {
                    portYIELD_WITHIN_API();
 8002bd0:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8002bd4:	603b      	str	r3, [r7, #0]
 8002bd6:	f3bf 8f4f 	dsb	sy
 8002bda:	f3bf 8f6f 	isb	sy
 8002bde:	e78b      	b.n	8002af8 <xQueueSemaphoreTake+0x60>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
 8002be0:	4620      	mov	r0, r4
 8002be2:	f7ff fc27 	bl	8002434 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
 8002be6:	f000 fb81 	bl	80032ec <xTaskResumeAll>
 8002bea:	e785      	b.n	8002af8 <xQueueSemaphoreTake+0x60>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
 8002bec:	4620      	mov	r0, r4
 8002bee:	f7ff fc21 	bl	8002434 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
 8002bf2:	f000 fb7b 	bl	80032ec <xTaskResumeAll>

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8002bf6:	4620      	mov	r0, r4
 8002bf8:	f7ff fbc2 	bl	8002380 <prvIsQueueEmpty>
 8002bfc:	2800      	cmp	r0, #0
 8002bfe:	f43f af7b 	beq.w	8002af8 <xQueueSemaphoreTake+0x60>
                #if ( configUSE_MUTEXES == 1 )
                    {
                        /* xInheritanceOccurred could only have be set if
                         * pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
                         * test the mutex type again to check it is actually a mutex. */
                        if( xInheritanceOccurred != pdFALSE )
 8002c02:	b185      	cbz	r5, 8002c26 <xQueueSemaphoreTake+0x18e>
                        {
                            taskENTER_CRITICAL();
 8002c04:	f7ff f8dc 	bl	8001dc0 <vPortEnterCritical>
         * priority, but the waiting task times out, then the holder should
         * disinherit the priority - but only down to the highest priority of any
         * other tasks that are waiting for the same mutex.  For this purpose,
         * return the priority of the highest priority task that is waiting for the
         * mutex. */
        if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
 8002c08:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8002c0a:	b123      	cbz	r3, 8002c16 <xQueueSemaphoreTake+0x17e>
        {
            uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
 8002c0c:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002c0e:	6819      	ldr	r1, [r3, #0]
 8002c10:	f1c1 010a 	rsb	r1, r1, #10
 8002c14:	e000      	b.n	8002c18 <xQueueSemaphoreTake+0x180>
        }
        else
        {
            uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
 8002c16:	2100      	movs	r1, #0
                                 * task to inherit this task's priority.  Now this task
                                 * has timed out the priority should be disinherited
                                 * again, but only as low as the next highest priority
                                 * task that is waiting for the same mutex. */
                                uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
                                vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
 8002c18:	68a0      	ldr	r0, [r4, #8]
 8002c1a:	f000 fecf 	bl	80039bc <vTaskPriorityDisinheritAfterTimeout>
                            }
                            taskEXIT_CRITICAL();
 8002c1e:	f7ff f8f1 	bl	8001e04 <vPortExitCritical>
                        }
                    }
                #endif /* configUSE_MUTEXES */

                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
 8002c22:	2000      	movs	r0, #0
 8002c24:	e000      	b.n	8002c28 <xQueueSemaphoreTake+0x190>
 8002c26:	2000      	movs	r0, #0
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
 8002c28:	b004      	add	sp, #16
 8002c2a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002c2e:	bf00      	nop
 8002c30:	e000ed04 	.word	0xe000ed04

08002c34 <uxQueueMessagesWaiting>:

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    UBaseType_t uxReturn;

    configASSERT( xQueue );
 8002c34:	b940      	cbnz	r0, 8002c48 <uxQueueMessagesWaiting+0x14>
 8002c36:	f04f 0314 	mov.w	r3, #20
 8002c3a:	f383 8811 	msr	BASEPRI, r3
 8002c3e:	f3bf 8f6f 	isb	sy
 8002c42:	f3bf 8f4f 	dsb	sy
 8002c46:	e7fe      	b.n	8002c46 <uxQueueMessagesWaiting+0x12>
    return xReturn;
}
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
 8002c48:	b510      	push	{r4, lr}
 8002c4a:	4604      	mov	r4, r0
    UBaseType_t uxReturn;

    configASSERT( xQueue );

    taskENTER_CRITICAL();
 8002c4c:	f7ff f8b8 	bl	8001dc0 <vPortEnterCritical>
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 8002c50:	6ba4      	ldr	r4, [r4, #56]	; 0x38
    }
    taskEXIT_CRITICAL();
 8002c52:	f7ff f8d7 	bl	8001e04 <vPortExitCritical>

    return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 8002c56:	4620      	mov	r0, r4
 8002c58:	bd10      	pop	{r4, pc}
 8002c5a:	bf00      	nop

08002c5c <vQueueAddToRegistry>:

#if ( configQUEUE_REGISTRY_SIZE > 0 )

    void vQueueAddToRegistry( QueueHandle_t xQueue,
                              const char * pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    {
 8002c5c:	b410      	push	{r4}

        /* See if there is an empty space in the registry.  A NULL name denotes
         * a free slot. */
        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
        {
            if( xQueueRegistry[ ux ].pcQueueName == NULL )
 8002c5e:	4b0b      	ldr	r3, [pc, #44]	; (8002c8c <vQueueAddToRegistry+0x30>)
 8002c60:	681b      	ldr	r3, [r3, #0]
 8002c62:	b12b      	cbz	r3, 8002c70 <vQueueAddToRegistry+0x14>
 8002c64:	2301      	movs	r3, #1
 8002c66:	4c09      	ldr	r4, [pc, #36]	; (8002c8c <vQueueAddToRegistry+0x30>)
 8002c68:	f854 2033 	ldr.w	r2, [r4, r3, lsl #3]
 8002c6c:	b942      	cbnz	r2, 8002c80 <vQueueAddToRegistry+0x24>
 8002c6e:	e000      	b.n	8002c72 <vQueueAddToRegistry+0x16>
    {
        UBaseType_t ux;

        /* See if there is an empty space in the registry.  A NULL name denotes
         * a free slot. */
        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8002c70:	2300      	movs	r3, #0
        {
            if( xQueueRegistry[ ux ].pcQueueName == NULL )
            {
                /* Store the information on this queue. */
                xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 8002c72:	4a06      	ldr	r2, [pc, #24]	; (8002c8c <vQueueAddToRegistry+0x30>)
 8002c74:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
                xQueueRegistry[ ux ].xHandle = xQueue;
 8002c78:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8002c7c:	6058      	str	r0, [r3, #4]

                traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
                break;
 8002c7e:	e002      	b.n	8002c86 <vQueueAddToRegistry+0x2a>
    {
        UBaseType_t ux;

        /* See if there is an empty space in the registry.  A NULL name denotes
         * a free slot. */
        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8002c80:	3301      	adds	r3, #1
 8002c82:	2b08      	cmp	r3, #8
 8002c84:	d1f0      	bne.n	8002c68 <vQueueAddToRegistry+0xc>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
 8002c86:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002c8a:	4770      	bx	lr
 8002c8c:	2000d4b8 	.word	0x2000d4b8

08002c90 <vQueueUnregisterQueue>:

        /* See if the handle of the queue being unregistered in actually in the
         * registry. */
        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
        {
            if( xQueueRegistry[ ux ].xHandle == xQueue )
 8002c90:	4b0b      	ldr	r3, [pc, #44]	; (8002cc0 <vQueueUnregisterQueue+0x30>)
 8002c92:	685b      	ldr	r3, [r3, #4]
 8002c94:	4283      	cmp	r3, r0
 8002c96:	d005      	beq.n	8002ca4 <vQueueUnregisterQueue+0x14>
 8002c98:	4a09      	ldr	r2, [pc, #36]	; (8002cc0 <vQueueUnregisterQueue+0x30>)
    {
        UBaseType_t ux;

        /* See if the handle of the queue being unregistered in actually in the
         * registry. */
        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8002c9a:	2301      	movs	r3, #1
        {
            if( xQueueRegistry[ ux ].xHandle == xQueue )
 8002c9c:	68d1      	ldr	r1, [r2, #12]
 8002c9e:	4281      	cmp	r1, r0
 8002ca0:	d109      	bne.n	8002cb6 <vQueueUnregisterQueue+0x26>
 8002ca2:	e000      	b.n	8002ca6 <vQueueUnregisterQueue+0x16>
    {
        UBaseType_t ux;

        /* See if the handle of the queue being unregistered in actually in the
         * registry. */
        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8002ca4:	2300      	movs	r3, #0
        {
            if( xQueueRegistry[ ux ].xHandle == xQueue )
            {
                /* Set the name to NULL to show that this slot if free again. */
                xQueueRegistry[ ux ].pcQueueName = NULL;
 8002ca6:	4a06      	ldr	r2, [pc, #24]	; (8002cc0 <vQueueUnregisterQueue+0x30>)
 8002ca8:	2100      	movs	r1, #0
 8002caa:	f842 1033 	str.w	r1, [r2, r3, lsl #3]

                /* Set the handle to NULL to ensure the same queue handle cannot
                 * appear in the registry twice if it is added, removed, then
                 * added again. */
                xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
 8002cae:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8002cb2:	6059      	str	r1, [r3, #4]
                break;
 8002cb4:	4770      	bx	lr
    {
        UBaseType_t ux;

        /* See if the handle of the queue being unregistered in actually in the
         * registry. */
        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8002cb6:	3301      	adds	r3, #1
 8002cb8:	3208      	adds	r2, #8
 8002cba:	2b08      	cmp	r3, #8
 8002cbc:	d1ee      	bne.n	8002c9c <vQueueUnregisterQueue+0xc>
 8002cbe:	4770      	bx	lr
 8002cc0:	2000d4b8 	.word	0x2000d4b8

08002cc4 <vQueueDelete>:

void vQueueDelete( QueueHandle_t xQueue )
{
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );
 8002cc4:	b940      	cbnz	r0, 8002cd8 <vQueueDelete+0x14>
 8002cc6:	f04f 0314 	mov.w	r3, #20
 8002cca:	f383 8811 	msr	BASEPRI, r3
 8002cce:	f3bf 8f6f 	isb	sy
 8002cd2:	f3bf 8f4f 	dsb	sy
 8002cd6:	e7fe      	b.n	8002cd6 <vQueueDelete+0x12>
    return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
 8002cd8:	b510      	push	{r4, lr}
 8002cda:	4604      	mov	r4, r0
    configASSERT( pxQueue );
    traceQUEUE_DELETE( pxQueue );

    #if ( configQUEUE_REGISTRY_SIZE > 0 )
        {
            vQueueUnregisterQueue( pxQueue );
 8002cdc:	f7ff ffd8 	bl	8002c90 <vQueueUnregisterQueue>

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
        {
            /* The queue can only have been allocated dynamically - free it
             * again. */
            vPortFree( pxQueue );
 8002ce0:	4620      	mov	r0, r4
 8002ce2:	f001 f99f 	bl	8004024 <vPortFree>
 8002ce6:	bd10      	pop	{r4, pc}

08002ce8 <vQueueWaitForMessageRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
 8002ce8:	b570      	push	{r4, r5, r6, lr}
 8002cea:	4604      	mov	r4, r0
 8002cec:	460e      	mov	r6, r1
 8002cee:	4615      	mov	r5, r2
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
 8002cf0:	f7ff f866 	bl	8001dc0 <vPortEnterCritical>
 8002cf4:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8002cf8:	b25b      	sxtb	r3, r3
 8002cfa:	f1b3 3fff 	cmp.w	r3, #4294967295
 8002cfe:	bf04      	itt	eq
 8002d00:	2300      	moveq	r3, #0
 8002d02:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
 8002d06:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8002d0a:	b25b      	sxtb	r3, r3
 8002d0c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8002d10:	bf04      	itt	eq
 8002d12:	2300      	moveq	r3, #0
 8002d14:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
 8002d18:	f7ff f874 	bl	8001e04 <vPortExitCritical>

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 8002d1c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002d1e:	b92b      	cbnz	r3, 8002d2c <vQueueWaitForMessageRestricted+0x44>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
 8002d20:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8002d24:	4631      	mov	r1, r6
 8002d26:	462a      	mov	r2, r5
 8002d28:	f000 fc72 	bl	8003610 <vTaskPlaceOnEventListRestricted>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
 8002d2c:	4620      	mov	r0, r4
 8002d2e:	f7ff fb81 	bl	8002434 <prvUnlockQueue>
 8002d32:	bd70      	pop	{r4, r5, r6, pc}

08002d34 <prvResetNextTaskUnblockTime>:
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8002d34:	4b07      	ldr	r3, [pc, #28]	; (8002d54 <prvResetNextTaskUnblockTime+0x20>)
 8002d36:	681b      	ldr	r3, [r3, #0]
 8002d38:	681b      	ldr	r3, [r3, #0]
 8002d3a:	b923      	cbnz	r3, 8002d46 <prvResetNextTaskUnblockTime+0x12>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
 8002d3c:	f04f 32ff 	mov.w	r2, #4294967295
 8002d40:	4b05      	ldr	r3, [pc, #20]	; (8002d58 <prvResetNextTaskUnblockTime+0x24>)
 8002d42:	601a      	str	r2, [r3, #0]
 8002d44:	4770      	bx	lr
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
 8002d46:	4b03      	ldr	r3, [pc, #12]	; (8002d54 <prvResetNextTaskUnblockTime+0x20>)
 8002d48:	681b      	ldr	r3, [r3, #0]
 8002d4a:	68db      	ldr	r3, [r3, #12]
 8002d4c:	681a      	ldr	r2, [r3, #0]
 8002d4e:	4b02      	ldr	r3, [pc, #8]	; (8002d58 <prvResetNextTaskUnblockTime+0x24>)
 8002d50:	601a      	str	r2, [r3, #0]
 8002d52:	4770      	bx	lr
 8002d54:	2000080c 	.word	0x2000080c
 8002d58:	2000092c 	.word	0x2000092c

08002d5c <prvAddCurrentTaskToDelayedList>:
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
 8002d5c:	b570      	push	{r4, r5, r6, lr}
 8002d5e:	4604      	mov	r4, r0
 8002d60:	460e      	mov	r6, r1
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
 8002d62:	4b1c      	ldr	r3, [pc, #112]	; (8002dd4 <prvAddCurrentTaskToDelayedList+0x78>)
 8002d64:	681d      	ldr	r5, [r3, #0]
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8002d66:	4b1c      	ldr	r3, [pc, #112]	; (8002dd8 <prvAddCurrentTaskToDelayedList+0x7c>)
 8002d68:	6818      	ldr	r0, [r3, #0]
 8002d6a:	3004      	adds	r0, #4
 8002d6c:	f7ff faf4 	bl	8002358 <uxListRemove>
 8002d70:	b948      	cbnz	r0, 8002d86 <prvAddCurrentTaskToDelayedList+0x2a>
    {
        /* The current task must be in a ready list, so there is no need to
         * check, and the port reset macro can be called directly. */
        portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentTCB cannot change as it is the calling task.  pxCurrentTCB->uxPriority and uxTopReadyPriority cannot change as called with scheduler suspended or in a critical section. */
 8002d72:	4b19      	ldr	r3, [pc, #100]	; (8002dd8 <prvAddCurrentTaskToDelayedList+0x7c>)
 8002d74:	681b      	ldr	r3, [r3, #0]
 8002d76:	4919      	ldr	r1, [pc, #100]	; (8002ddc <prvAddCurrentTaskToDelayedList+0x80>)
 8002d78:	680a      	ldr	r2, [r1, #0]
 8002d7a:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 8002d7c:	2301      	movs	r3, #1
 8002d7e:	4083      	lsls	r3, r0
 8002d80:	ea22 0303 	bic.w	r3, r2, r3
 8002d84:	600b      	str	r3, [r1, #0]
        mtCOVERAGE_TEST_MARKER();
    }

    #if ( INCLUDE_vTaskSuspend == 1 )
        {
            if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 8002d86:	f1b4 3fff 	cmp.w	r4, #4294967295
 8002d8a:	d107      	bne.n	8002d9c <prvAddCurrentTaskToDelayedList+0x40>
 8002d8c:	b136      	cbz	r6, 8002d9c <prvAddCurrentTaskToDelayedList+0x40>
            {
                /* Add the task to the suspended task list instead of a delayed task
                 * list to ensure it is not woken by a timing event.  It will block
                 * indefinitely. */
                vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8002d8e:	4b12      	ldr	r3, [pc, #72]	; (8002dd8 <prvAddCurrentTaskToDelayedList+0x7c>)
 8002d90:	6819      	ldr	r1, [r3, #0]
 8002d92:	4813      	ldr	r0, [pc, #76]	; (8002de0 <prvAddCurrentTaskToDelayedList+0x84>)
 8002d94:	3104      	adds	r1, #4
 8002d96:	f7ff fab9 	bl	800230c <vListInsertEnd>
 8002d9a:	bd70      	pop	{r4, r5, r6, pc}
            else
            {
                /* Calculate the time at which the task should be woken if the event
                 * does not occur.  This may overflow but this doesn't matter, the
                 * kernel will manage it correctly. */
                xTimeToWake = xConstTickCount + xTicksToWait;
 8002d9c:	442c      	add	r4, r5

                /* The list item will be inserted in wake time order. */
                listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8002d9e:	4b0e      	ldr	r3, [pc, #56]	; (8002dd8 <prvAddCurrentTaskToDelayedList+0x7c>)
 8002da0:	681b      	ldr	r3, [r3, #0]
 8002da2:	605c      	str	r4, [r3, #4]

                if( xTimeToWake < xConstTickCount )
 8002da4:	42a5      	cmp	r5, r4
 8002da6:	d907      	bls.n	8002db8 <prvAddCurrentTaskToDelayedList+0x5c>
                {
                    /* Wake time has overflowed.  Place this item in the overflow
                     * list. */
                    vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8002da8:	4b0e      	ldr	r3, [pc, #56]	; (8002de4 <prvAddCurrentTaskToDelayedList+0x88>)
 8002daa:	6818      	ldr	r0, [r3, #0]
 8002dac:	4b0a      	ldr	r3, [pc, #40]	; (8002dd8 <prvAddCurrentTaskToDelayedList+0x7c>)
 8002dae:	6819      	ldr	r1, [r3, #0]
 8002db0:	3104      	adds	r1, #4
 8002db2:	f7ff fab7 	bl	8002324 <vListInsert>
 8002db6:	bd70      	pop	{r4, r5, r6, pc}
                }
                else
                {
                    /* The wake time has not overflowed, so the current block list
                     * is used. */
                    vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8002db8:	4b0b      	ldr	r3, [pc, #44]	; (8002de8 <prvAddCurrentTaskToDelayedList+0x8c>)
 8002dba:	6818      	ldr	r0, [r3, #0]
 8002dbc:	4b06      	ldr	r3, [pc, #24]	; (8002dd8 <prvAddCurrentTaskToDelayedList+0x7c>)
 8002dbe:	6819      	ldr	r1, [r3, #0]
 8002dc0:	3104      	adds	r1, #4
 8002dc2:	f7ff faaf 	bl	8002324 <vListInsert>

                    /* If the task entering the blocked state was placed at the
                     * head of the list of blocked tasks then xNextTaskUnblockTime
                     * needs to be updated too. */
                    if( xTimeToWake < xNextTaskUnblockTime )
 8002dc6:	4b09      	ldr	r3, [pc, #36]	; (8002dec <prvAddCurrentTaskToDelayedList+0x90>)
 8002dc8:	681b      	ldr	r3, [r3, #0]
 8002dca:	429c      	cmp	r4, r3
                    {
                        xNextTaskUnblockTime = xTimeToWake;
 8002dcc:	bf3c      	itt	cc
 8002dce:	4b07      	ldrcc	r3, [pc, #28]	; (8002dec <prvAddCurrentTaskToDelayedList+0x90>)
 8002dd0:	601c      	strcc	r4, [r3, #0]
 8002dd2:	bd70      	pop	{r4, r5, r6, pc}
 8002dd4:	20000928 	.word	0x20000928
 8002dd8:	200008fc 	.word	0x200008fc
 8002ddc:	20000968 	.word	0x20000968
 8002de0:	20000954 	.word	0x20000954
 8002de4:	20000828 	.word	0x20000828
 8002de8:	2000080c 	.word	0x2000080c
 8002dec:	2000092c 	.word	0x2000092c

08002df0 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 8002df0:	b580      	push	{r7, lr}
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8002df2:	4d17      	ldr	r5, [pc, #92]	; (8002e50 <prvIdleTask+0x60>)
            {
                taskENTER_CRITICAL();
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8002df4:	4f17      	ldr	r7, [pc, #92]	; (8002e54 <prvIdleTask+0x64>)
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
                    --uxCurrentNumberOfTasks;
 8002df6:	4e18      	ldr	r6, [pc, #96]	; (8002e58 <prvIdleTask+0x68>)
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
                {
                    taskYIELD();
 8002df8:	f8df 8064 	ldr.w	r8, [pc, #100]	; 8002e60 <prvIdleTask+0x70>
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8002dfc:	682b      	ldr	r3, [r5, #0]
 8002dfe:	b1bb      	cbz	r3, 8002e30 <prvIdleTask+0x40>
            {
                taskENTER_CRITICAL();
 8002e00:	f7fe ffde 	bl	8001dc0 <vPortEnterCritical>
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8002e04:	68fb      	ldr	r3, [r7, #12]
 8002e06:	68dc      	ldr	r4, [r3, #12]
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8002e08:	1d20      	adds	r0, r4, #4
 8002e0a:	f7ff faa5 	bl	8002358 <uxListRemove>
                    --uxCurrentNumberOfTasks;
 8002e0e:	6833      	ldr	r3, [r6, #0]
 8002e10:	3b01      	subs	r3, #1
 8002e12:	6033      	str	r3, [r6, #0]
                    --uxDeletedTasksWaitingCleanUp;
 8002e14:	682b      	ldr	r3, [r5, #0]
 8002e16:	3b01      	subs	r3, #1
 8002e18:	602b      	str	r3, [r5, #0]
                }
                taskEXIT_CRITICAL();
 8002e1a:	f7fe fff3 	bl	8001e04 <vPortExitCritical>

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
            {
                /* The task can only have been allocated dynamically - free both
                 * the stack and TCB. */
                vPortFree( pxTCB->pxStack );
 8002e1e:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8002e20:	f001 f900 	bl	8004024 <vPortFree>
                vPortFree( pxTCB );
 8002e24:	4620      	mov	r0, r4
 8002e26:	f001 f8fd 	bl	8004024 <vPortFree>
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8002e2a:	682b      	ldr	r3, [r5, #0]
 8002e2c:	2b00      	cmp	r3, #0
 8002e2e:	d1e7      	bne.n	8002e00 <prvIdleTask+0x10>
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 8002e30:	4b0a      	ldr	r3, [pc, #40]	; (8002e5c <prvIdleTask+0x6c>)
 8002e32:	681b      	ldr	r3, [r3, #0]
 8002e34:	2b01      	cmp	r3, #1
 8002e36:	d907      	bls.n	8002e48 <prvIdleTask+0x58>
                {
                    taskYIELD();
 8002e38:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8002e3c:	f8c8 3000 	str.w	r3, [r8]
 8002e40:	f3bf 8f4f 	dsb	sy
 8002e44:	f3bf 8f6f 	isb	sy
                /* Call the user defined function from within the idle task.  This
                 * allows the application designer to add background functionality
                 * without the overhead of a separate task.
                 * NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
                 * CALL A FUNCTION THAT MIGHT BLOCK. */
                vApplicationIdleHook();
 8002e48:	f007 fe4e 	bl	800aae8 <vApplicationIdleHook>
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_TICKLESS_IDLE */
    }
 8002e4c:	e7d6      	b.n	8002dfc <prvIdleTask+0xc>
 8002e4e:	bf00      	nop
 8002e50:	2000094c 	.word	0x2000094c
 8002e54:	20000814 	.word	0x20000814
 8002e58:	20000948 	.word	0x20000948
 8002e5c:	20000830 	.word	0x20000830
 8002e60:	e000ed04 	.word	0xe000ed04

08002e64 <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
 8002e64:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002e68:	4680      	mov	r8, r0
 8002e6a:	460f      	mov	r7, r1
 8002e6c:	4699      	mov	r9, r3
 8002e6e:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
        #else /* portSTACK_GROWTH */
            {
                StackType_t * pxStack;

                /* Allocate space for the stack used by the task being created. */
                pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 8002e70:	0095      	lsls	r5, r2, #2
 8002e72:	4628      	mov	r0, r5
 8002e74:	f001 f832 	bl	8003edc <pvPortMalloc>

                if( pxStack != NULL )
 8002e78:	2800      	cmp	r0, #0
 8002e7a:	f000 80c4 	beq.w	8003006 <xTaskCreate+0x1a2>
 8002e7e:	4682      	mov	sl, r0
                {
                    /* Allocate space for the TCB. */
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
 8002e80:	2060      	movs	r0, #96	; 0x60
 8002e82:	f001 f82b 	bl	8003edc <pvPortMalloc>

                    if( pxNewTCB != NULL )
 8002e86:	4604      	mov	r4, r0
 8002e88:	b168      	cbz	r0, 8002ea6 <xTaskCreate+0x42>
                    {
                        /* Store the stack location in the TCB. */
                        pxNewTCB->pxStack = pxStack;
 8002e8a:	f8c0 a030 	str.w	sl, [r0, #48]	; 0x30

    /* Avoid dependency on memset() if it is not required. */
    #if ( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
        {
            /* Fill the stack with a known value to assist debugging. */
            ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 8002e8e:	4650      	mov	r0, sl
 8002e90:	21a5      	movs	r1, #165	; 0xa5
 8002e92:	462a      	mov	r2, r5
 8002e94:	f007 f852 	bl	8009f3c <memset>
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
        {
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 8002e98:	3d04      	subs	r5, #4
 8002e9a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002e9c:	441d      	add	r5, r3
            pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 8002e9e:	f025 0507 	bic.w	r5, r5, #7
            pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
        }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
 8002ea2:	b927      	cbnz	r7, 8002eae <xTaskCreate+0x4a>
 8002ea4:	e019      	b.n	8002eda <xTaskCreate+0x76>
                    }
                    else
                    {
                        /* The stack cannot be used as the TCB was not created.  Free
                         * it again. */
                        vPortFree( pxStack );
 8002ea6:	4650      	mov	r0, sl
 8002ea8:	f001 f8bc 	bl	8004024 <vPortFree>
 8002eac:	e0ab      	b.n	8003006 <xTaskCreate+0x1a2>
    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8002eae:	783b      	ldrb	r3, [r7, #0]
 8002eb0:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
 8002eb4:	783b      	ldrb	r3, [r7, #0]
 8002eb6:	b163      	cbz	r3, 8002ed2 <xTaskCreate+0x6e>
 8002eb8:	463b      	mov	r3, r7
 8002eba:	f104 0234 	add.w	r2, r4, #52	; 0x34
 8002ebe:	f107 0113 	add.w	r1, r7, #19
    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8002ec2:	f813 0f01 	ldrb.w	r0, [r3, #1]!
 8002ec6:	f802 0f01 	strb.w	r0, [r2, #1]!

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
 8002eca:	7818      	ldrb	r0, [r3, #0]
 8002ecc:	b108      	cbz	r0, 8002ed2 <xTaskCreate+0x6e>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 8002ece:	428b      	cmp	r3, r1
 8002ed0:	d1f7      	bne.n	8002ec2 <xTaskCreate+0x5e>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8002ed2:	2300      	movs	r3, #0
 8002ed4:	f884 3047 	strb.w	r3, [r4, #71]	; 0x47
 8002ed8:	e002      	b.n	8002ee0 <xTaskCreate+0x7c>
    }
    else
    {
        /* The task has not been given a name, so just ensure there is a NULL
         * terminator when it is read out. */
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
 8002eda:	2300      	movs	r3, #0
 8002edc:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 8002ee0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8002ee2:	2b09      	cmp	r3, #9
 8002ee4:	bf28      	it	cs
 8002ee6:	2309      	movcs	r3, #9
 8002ee8:	461f      	mov	r7, r3
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
 8002eea:	62e3      	str	r3, [r4, #44]	; 0x2c
    #if ( configUSE_MUTEXES == 1 )
        {
            pxNewTCB->uxBasePriority = uxPriority;
 8002eec:	6523      	str	r3, [r4, #80]	; 0x50
            pxNewTCB->uxMutexesHeld = 0;
 8002eee:	f04f 0a00 	mov.w	sl, #0
 8002ef2:	f8c4 a054 	str.w	sl, [r4, #84]	; 0x54
        }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8002ef6:	f104 0b04 	add.w	fp, r4, #4
 8002efa:	4658      	mov	r0, fp
 8002efc:	f7ff fa02 	bl	8002304 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 8002f00:	f104 0018 	add.w	r0, r4, #24
 8002f04:	f7ff f9fe 	bl	8002304 <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 8002f08:	6124      	str	r4, [r4, #16]

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002f0a:	f1c7 030a 	rsb	r3, r7, #10
 8002f0e:	61a3      	str	r3, [r4, #24]
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 8002f10:	6264      	str	r4, [r4, #36]	; 0x24
        }
    #endif

    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        {
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
 8002f12:	f884 a058 	strb.w	sl, [r4, #88]	; 0x58
 8002f16:	f884 a059 	strb.w	sl, [r4, #89]	; 0x59
 8002f1a:	f884 a05a 	strb.w	sl, [r4, #90]	; 0x5a
 8002f1e:	f884 a05b 	strb.w	sl, [r4, #91]	; 0x5b
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
 8002f22:	f884 a05c 	strb.w	sl, [r4, #92]	; 0x5c
                        }
                    #endif /* portSTACK_GROWTH */
                }
            #else /* portHAS_STACK_OVERFLOW_CHECKING */
                {
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8002f26:	4628      	mov	r0, r5
 8002f28:	4641      	mov	r1, r8
 8002f2a:	464a      	mov	r2, r9
 8002f2c:	f7fe ff16 	bl	8001d5c <pxPortInitialiseStack>
 8002f30:	6020      	str	r0, [r4, #0]
                }
            #endif /* portHAS_STACK_OVERFLOW_CHECKING */
        }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
 8002f32:	b106      	cbz	r6, 8002f36 <xTaskCreate+0xd2>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8002f34:	6034      	str	r4, [r6, #0]

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
 8002f36:	f7fe ff43 	bl	8001dc0 <vPortEnterCritical>
    {
        uxCurrentNumberOfTasks++;
 8002f3a:	4a35      	ldr	r2, [pc, #212]	; (8003010 <xTaskCreate+0x1ac>)
 8002f3c:	6813      	ldr	r3, [r2, #0]
 8002f3e:	3301      	adds	r3, #1
 8002f40:	6013      	str	r3, [r2, #0]

        if( pxCurrentTCB == NULL )
 8002f42:	4b34      	ldr	r3, [pc, #208]	; (8003014 <xTaskCreate+0x1b0>)
 8002f44:	681b      	ldr	r3, [r3, #0]
 8002f46:	bb1b      	cbnz	r3, 8002f90 <xTaskCreate+0x12c>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
 8002f48:	4b32      	ldr	r3, [pc, #200]	; (8003014 <xTaskCreate+0x1b0>)
 8002f4a:	601c      	str	r4, [r3, #0]

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8002f4c:	6813      	ldr	r3, [r2, #0]
 8002f4e:	2b01      	cmp	r3, #1
 8002f50:	d129      	bne.n	8002fa6 <xTaskCreate+0x142>
 8002f52:	4d31      	ldr	r5, [pc, #196]	; (8003018 <xTaskCreate+0x1b4>)
 8002f54:	f105 06c8 	add.w	r6, r5, #200	; 0xc8
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8002f58:	4628      	mov	r0, r5
 8002f5a:	f7ff f9c7 	bl	80022ec <vListInitialise>
 8002f5e:	3514      	adds	r5, #20

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8002f60:	42b5      	cmp	r5, r6
 8002f62:	d1f9      	bne.n	8002f58 <xTaskCreate+0xf4>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
 8002f64:	4e2d      	ldr	r6, [pc, #180]	; (800301c <xTaskCreate+0x1b8>)
 8002f66:	4630      	mov	r0, r6
 8002f68:	f7ff f9c0 	bl	80022ec <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
 8002f6c:	4d2c      	ldr	r5, [pc, #176]	; (8003020 <xTaskCreate+0x1bc>)
 8002f6e:	4628      	mov	r0, r5
 8002f70:	f7ff f9bc 	bl	80022ec <vListInitialise>
    vListInitialise( &xPendingReadyList );
 8002f74:	482b      	ldr	r0, [pc, #172]	; (8003024 <xTaskCreate+0x1c0>)
 8002f76:	f7ff f9b9 	bl	80022ec <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
        {
            vListInitialise( &xTasksWaitingTermination );
 8002f7a:	482b      	ldr	r0, [pc, #172]	; (8003028 <xTaskCreate+0x1c4>)
 8002f7c:	f7ff f9b6 	bl	80022ec <vListInitialise>
        }
    #endif /* INCLUDE_vTaskDelete */

    #if ( INCLUDE_vTaskSuspend == 1 )
        {
            vListInitialise( &xSuspendedTaskList );
 8002f80:	482a      	ldr	r0, [pc, #168]	; (800302c <xTaskCreate+0x1c8>)
 8002f82:	f7ff f9b3 	bl	80022ec <vListInitialise>
        }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
 8002f86:	4b2a      	ldr	r3, [pc, #168]	; (8003030 <xTaskCreate+0x1cc>)
 8002f88:	601e      	str	r6, [r3, #0]
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8002f8a:	4b2a      	ldr	r3, [pc, #168]	; (8003034 <xTaskCreate+0x1d0>)
 8002f8c:	601d      	str	r5, [r3, #0]
 8002f8e:	e00a      	b.n	8002fa6 <xTaskCreate+0x142>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
 8002f90:	4b29      	ldr	r3, [pc, #164]	; (8003038 <xTaskCreate+0x1d4>)
 8002f92:	681b      	ldr	r3, [r3, #0]
 8002f94:	b93b      	cbnz	r3, 8002fa6 <xTaskCreate+0x142>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 8002f96:	4b1f      	ldr	r3, [pc, #124]	; (8003014 <xTaskCreate+0x1b0>)
 8002f98:	681b      	ldr	r3, [r3, #0]
 8002f9a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002f9c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8002f9e:	429a      	cmp	r2, r3
                {
                    pxCurrentTCB = pxNewTCB;
 8002fa0:	bf9c      	itt	ls
 8002fa2:	4b1c      	ldrls	r3, [pc, #112]	; (8003014 <xTaskCreate+0x1b0>)
 8002fa4:	601c      	strls	r4, [r3, #0]
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
 8002fa6:	4a25      	ldr	r2, [pc, #148]	; (800303c <xTaskCreate+0x1d8>)
 8002fa8:	6813      	ldr	r3, [r2, #0]
 8002faa:	3301      	adds	r3, #1
 8002fac:	6013      	str	r3, [r2, #0]

        #if ( configUSE_TRACE_FACILITY == 1 )
            {
                /* Add a counter into the TCB for tracing only. */
                pxNewTCB->uxTCBNumber = uxTaskNumber;
 8002fae:	64a3      	str	r3, [r4, #72]	; 0x48
            }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
 8002fb0:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8002fb2:	4923      	ldr	r1, [pc, #140]	; (8003040 <xTaskCreate+0x1dc>)
 8002fb4:	680a      	ldr	r2, [r1, #0]
 8002fb6:	2301      	movs	r3, #1
 8002fb8:	4083      	lsls	r3, r0
 8002fba:	4313      	orrs	r3, r2
 8002fbc:	600b      	str	r3, [r1, #0]
 8002fbe:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002fc2:	4b15      	ldr	r3, [pc, #84]	; (8003018 <xTaskCreate+0x1b4>)
 8002fc4:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8002fc8:	4659      	mov	r1, fp
 8002fca:	f7ff f99f 	bl	800230c <vListInsertEnd>

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
 8002fce:	f7fe ff19 	bl	8001e04 <vPortExitCritical>

    if( xSchedulerRunning != pdFALSE )
 8002fd2:	4b19      	ldr	r3, [pc, #100]	; (8003038 <xTaskCreate+0x1d4>)
 8002fd4:	681b      	ldr	r3, [r3, #0]
 8002fd6:	b183      	cbz	r3, 8002ffa <xTaskCreate+0x196>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 8002fd8:	4b0e      	ldr	r3, [pc, #56]	; (8003014 <xTaskCreate+0x1b0>)
 8002fda:	681b      	ldr	r3, [r3, #0]
 8002fdc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002fde:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8002fe0:	429a      	cmp	r2, r3
 8002fe2:	d20d      	bcs.n	8003000 <xTaskCreate+0x19c>
        {
            taskYIELD_IF_USING_PREEMPTION();
 8002fe4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8002fe8:	4b16      	ldr	r3, [pc, #88]	; (8003044 <xTaskCreate+0x1e0>)
 8002fea:	601a      	str	r2, [r3, #0]
 8002fec:	f3bf 8f4f 	dsb	sy
 8002ff0:	f3bf 8f6f 	isb	sy
                }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
            prvAddNewTaskToReadyList( pxNewTCB );
            xReturn = pdPASS;
 8002ff4:	2001      	movs	r0, #1
 8002ff6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8002ffa:	2001      	movs	r0, #1
 8002ffc:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8003000:	2001      	movs	r0, #1
 8003002:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8003006:	f04f 30ff 	mov.w	r0, #4294967295
        }

        return xReturn;
    }
 800300a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800300e:	bf00      	nop
 8003010:	20000948 	.word	0x20000948
 8003014:	200008fc 	.word	0x200008fc
 8003018:	20000830 	.word	0x20000830
 800301c:	20000914 	.word	0x20000914
 8003020:	20000930 	.word	0x20000930
 8003024:	20000900 	.word	0x20000900
 8003028:	20000814 	.word	0x20000814
 800302c:	20000954 	.word	0x20000954
 8003030:	2000080c 	.word	0x2000080c
 8003034:	20000828 	.word	0x20000828
 8003038:	20000810 	.word	0x20000810
 800303c:	20000944 	.word	0x20000944
 8003040:	20000968 	.word	0x20000968
 8003044:	e000ed04 	.word	0xe000ed04

08003048 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
 8003048:	b538      	push	{r3, r4, r5, lr}
 800304a:	4604      	mov	r4, r0
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
 800304c:	f7fe feb8 	bl	8001dc0 <vPortEnterCritical>
        {
            /* If null is passed in here then it is the calling task that is
             * being deleted. */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 8003050:	b90c      	cbnz	r4, 8003056 <vTaskDelete+0xe>
 8003052:	4b2b      	ldr	r3, [pc, #172]	; (8003100 <vTaskDelete+0xb8>)
 8003054:	681c      	ldr	r4, [r3, #0]

            /* Remove task from the ready/delayed list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8003056:	1d25      	adds	r5, r4, #4
 8003058:	4628      	mov	r0, r5
 800305a:	f7ff f97d 	bl	8002358 <uxListRemove>
 800305e:	b968      	cbnz	r0, 800307c <vTaskDelete+0x34>
            {
                taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8003060:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8003062:	eb01 0381 	add.w	r3, r1, r1, lsl #2
 8003066:	009b      	lsls	r3, r3, #2
 8003068:	4a26      	ldr	r2, [pc, #152]	; (8003104 <vTaskDelete+0xbc>)
 800306a:	58d3      	ldr	r3, [r2, r3]
 800306c:	b933      	cbnz	r3, 800307c <vTaskDelete+0x34>
 800306e:	4826      	ldr	r0, [pc, #152]	; (8003108 <vTaskDelete+0xc0>)
 8003070:	6803      	ldr	r3, [r0, #0]
 8003072:	2201      	movs	r2, #1
 8003074:	408a      	lsls	r2, r1
 8003076:	ea23 0302 	bic.w	r3, r3, r2
 800307a:	6003      	str	r3, [r0, #0]
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 800307c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800307e:	b11b      	cbz	r3, 8003088 <vTaskDelete+0x40>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8003080:	f104 0018 	add.w	r0, r4, #24
 8003084:	f7ff f968 	bl	8002358 <uxListRemove>

            /* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. */
            uxTaskNumber++;
 8003088:	4a20      	ldr	r2, [pc, #128]	; (800310c <vTaskDelete+0xc4>)
 800308a:	6813      	ldr	r3, [r2, #0]
 800308c:	3301      	adds	r3, #1
 800308e:	6013      	str	r3, [r2, #0]

            if( pxTCB == pxCurrentTCB )
 8003090:	4b1b      	ldr	r3, [pc, #108]	; (8003100 <vTaskDelete+0xb8>)
 8003092:	681b      	ldr	r3, [r3, #0]
 8003094:	429c      	cmp	r4, r3
 8003096:	d108      	bne.n	80030aa <vTaskDelete+0x62>
                /* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
 8003098:	481d      	ldr	r0, [pc, #116]	; (8003110 <vTaskDelete+0xc8>)
 800309a:	4629      	mov	r1, r5
 800309c:	f7ff f936 	bl	800230c <vListInsertEnd>

                /* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. */
                ++uxDeletedTasksWaitingCleanUp;
 80030a0:	4a1c      	ldr	r2, [pc, #112]	; (8003114 <vTaskDelete+0xcc>)
 80030a2:	6813      	ldr	r3, [r2, #0]
 80030a4:	3301      	adds	r3, #1
 80030a6:	6013      	str	r3, [r2, #0]
 80030a8:	e00b      	b.n	80030c2 <vTaskDelete+0x7a>
                 * required. */
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
            }
            else
            {
                --uxCurrentNumberOfTasks;
 80030aa:	4a1b      	ldr	r2, [pc, #108]	; (8003118 <vTaskDelete+0xd0>)
 80030ac:	6813      	ldr	r3, [r2, #0]
 80030ae:	3b01      	subs	r3, #1
 80030b0:	6013      	str	r3, [r2, #0]

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
            {
                /* The task can only have been allocated dynamically - free both
                 * the stack and TCB. */
                vPortFree( pxTCB->pxStack );
 80030b2:	6b20      	ldr	r0, [r4, #48]	; 0x30
 80030b4:	f000 ffb6 	bl	8004024 <vPortFree>
                vPortFree( pxTCB );
 80030b8:	4620      	mov	r0, r4
 80030ba:	f000 ffb3 	bl	8004024 <vPortFree>
                traceTASK_DELETE( pxTCB );
                prvDeleteTCB( pxTCB );

                /* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. */
                prvResetNextTaskUnblockTime();
 80030be:	f7ff fe39 	bl	8002d34 <prvResetNextTaskUnblockTime>
            }
        }
        taskEXIT_CRITICAL();
 80030c2:	f7fe fe9f 	bl	8001e04 <vPortExitCritical>

        /* Force a reschedule if it is the currently running task that has just
         * been deleted. */
        if( xSchedulerRunning != pdFALSE )
 80030c6:	4b15      	ldr	r3, [pc, #84]	; (800311c <vTaskDelete+0xd4>)
 80030c8:	681b      	ldr	r3, [r3, #0]
 80030ca:	b1bb      	cbz	r3, 80030fc <vTaskDelete+0xb4>
        {
            if( pxTCB == pxCurrentTCB )
 80030cc:	4b0c      	ldr	r3, [pc, #48]	; (8003100 <vTaskDelete+0xb8>)
 80030ce:	681b      	ldr	r3, [r3, #0]
 80030d0:	429c      	cmp	r4, r3
 80030d2:	d113      	bne.n	80030fc <vTaskDelete+0xb4>
            {
                configASSERT( uxSchedulerSuspended == 0 );
 80030d4:	4b12      	ldr	r3, [pc, #72]	; (8003120 <vTaskDelete+0xd8>)
 80030d6:	681b      	ldr	r3, [r3, #0]
 80030d8:	b143      	cbz	r3, 80030ec <vTaskDelete+0xa4>
 80030da:	f04f 0314 	mov.w	r3, #20
 80030de:	f383 8811 	msr	BASEPRI, r3
 80030e2:	f3bf 8f6f 	isb	sy
 80030e6:	f3bf 8f4f 	dsb	sy
 80030ea:	e7fe      	b.n	80030ea <vTaskDelete+0xa2>
                portYIELD_WITHIN_API();
 80030ec:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80030f0:	4b0c      	ldr	r3, [pc, #48]	; (8003124 <vTaskDelete+0xdc>)
 80030f2:	601a      	str	r2, [r3, #0]
 80030f4:	f3bf 8f4f 	dsb	sy
 80030f8:	f3bf 8f6f 	isb	sy
 80030fc:	bd38      	pop	{r3, r4, r5, pc}
 80030fe:	bf00      	nop
 8003100:	200008fc 	.word	0x200008fc
 8003104:	20000830 	.word	0x20000830
 8003108:	20000968 	.word	0x20000968
 800310c:	20000944 	.word	0x20000944
 8003110:	20000814 	.word	0x20000814
 8003114:	2000094c 	.word	0x2000094c
 8003118:	20000948 	.word	0x20000948
 800311c:	20000810 	.word	0x20000810
 8003120:	200008f8 	.word	0x200008f8
 8003124:	e000ed04 	.word	0xe000ed04

08003128 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 8003128:	b500      	push	{lr}
 800312a:	b083      	sub	sp, #12
            }
        }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
        {
            /* The Idle task is being created using dynamically allocated RAM. */
            xReturn = xTaskCreate( prvIdleTask,
 800312c:	2300      	movs	r3, #0
 800312e:	9300      	str	r3, [sp, #0]
 8003130:	4a18      	ldr	r2, [pc, #96]	; (8003194 <vTaskStartScheduler+0x6c>)
 8003132:	9201      	str	r2, [sp, #4]
 8003134:	4818      	ldr	r0, [pc, #96]	; (8003198 <vTaskStartScheduler+0x70>)
 8003136:	4919      	ldr	r1, [pc, #100]	; (800319c <vTaskStartScheduler+0x74>)
 8003138:	2278      	movs	r2, #120	; 0x78
 800313a:	f7ff fe93 	bl	8002e64 <xTaskCreate>
        }
    #endif /* configSUPPORT_STATIC_ALLOCATION */

    #if ( configUSE_TIMERS == 1 )
        {
            if( xReturn == pdPASS )
 800313e:	2801      	cmp	r0, #1
 8003140:	d118      	bne.n	8003174 <vTaskStartScheduler+0x4c>
            {
                xReturn = xTimerCreateTimerTask();
 8003142:	f000 fcff 	bl	8003b44 <xTimerCreateTimerTask>
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
 8003146:	2801      	cmp	r0, #1
 8003148:	d114      	bne.n	8003174 <vTaskStartScheduler+0x4c>
 800314a:	f04f 0314 	mov.w	r3, #20
 800314e:	f383 8811 	msr	BASEPRI, r3
 8003152:	f3bf 8f6f 	isb	sy
 8003156:	f3bf 8f4f 	dsb	sy
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */

        xNextTaskUnblockTime = portMAX_DELAY;
 800315a:	f04f 32ff 	mov.w	r2, #4294967295
 800315e:	4b10      	ldr	r3, [pc, #64]	; (80031a0 <vTaskStartScheduler+0x78>)
 8003160:	601a      	str	r2, [r3, #0]
        xSchedulerRunning = pdTRUE;
 8003162:	2201      	movs	r2, #1
 8003164:	4b0f      	ldr	r3, [pc, #60]	; (80031a4 <vTaskStartScheduler+0x7c>)
 8003166:	601a      	str	r2, [r3, #0]
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 8003168:	2200      	movs	r2, #0
 800316a:	4b0f      	ldr	r3, [pc, #60]	; (80031a8 <vTaskStartScheduler+0x80>)
 800316c:	601a      	str	r2, [r3, #0]

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        if( xPortStartScheduler() != pdFALSE )
 800316e:	f7fe fec9 	bl	8001f04 <xPortStartScheduler>
 8003172:	e00b      	b.n	800318c <vTaskStartScheduler+0x64>
    else
    {
        /* This line will only be reached if the kernel could not be started,
         * because there was not enough FreeRTOS heap to create the idle task
         * or the timer task. */
        configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 8003174:	f1b0 3fff 	cmp.w	r0, #4294967295
 8003178:	d108      	bne.n	800318c <vTaskStartScheduler+0x64>
 800317a:	f04f 0314 	mov.w	r3, #20
 800317e:	f383 8811 	msr	BASEPRI, r3
 8003182:	f3bf 8f6f 	isb	sy
 8003186:	f3bf 8f4f 	dsb	sy
 800318a:	e7fe      	b.n	800318a <vTaskStartScheduler+0x62>
    }

    /* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;
}
 800318c:	b003      	add	sp, #12
 800318e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003192:	bf00      	nop
 8003194:	20000950 	.word	0x20000950
 8003198:	08002df1 	.word	0x08002df1
 800319c:	0800ab48 	.word	0x0800ab48
 80031a0:	2000092c 	.word	0x2000092c
 80031a4:	20000810 	.word	0x20000810
 80031a8:	20000928 	.word	0x20000928

080031ac <vTaskSuspendAll>:
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
 80031ac:	4a02      	ldr	r2, [pc, #8]	; (80031b8 <vTaskSuspendAll+0xc>)
 80031ae:	6813      	ldr	r3, [r2, #0]
 80031b0:	3301      	adds	r3, #1
 80031b2:	6013      	str	r3, [r2, #0]

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
 80031b4:	4770      	bx	lr
 80031b6:	bf00      	nop
 80031b8:	200008f8 	.word	0x200008f8

080031bc <xTaskGetTickCount>:
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    {
        xTicks = xTickCount;
 80031bc:	4b01      	ldr	r3, [pc, #4]	; (80031c4 <xTaskGetTickCount+0x8>)
 80031be:	6818      	ldr	r0, [r3, #0]
    }
    portTICK_TYPE_EXIT_CRITICAL();

    return xTicks;
}
 80031c0:	4770      	bx	lr
 80031c2:	bf00      	nop
 80031c4:	20000928 	.word	0x20000928

080031c8 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 80031c8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80031cc:	4b3c      	ldr	r3, [pc, #240]	; (80032c0 <xTaskIncrementTick+0xf8>)
 80031ce:	681b      	ldr	r3, [r3, #0]
 80031d0:	2b00      	cmp	r3, #0
 80031d2:	d16d      	bne.n	80032b0 <xTaskIncrementTick+0xe8>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 80031d4:	4b3b      	ldr	r3, [pc, #236]	; (80032c4 <xTaskIncrementTick+0xfc>)
 80031d6:	681d      	ldr	r5, [r3, #0]
 80031d8:	3501      	adds	r5, #1

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
 80031da:	601d      	str	r5, [r3, #0]

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 80031dc:	b9c5      	cbnz	r5, 8003210 <xTaskIncrementTick+0x48>
        {
            taskSWITCH_DELAYED_LISTS();
 80031de:	4b3a      	ldr	r3, [pc, #232]	; (80032c8 <xTaskIncrementTick+0x100>)
 80031e0:	681b      	ldr	r3, [r3, #0]
 80031e2:	681b      	ldr	r3, [r3, #0]
 80031e4:	b143      	cbz	r3, 80031f8 <xTaskIncrementTick+0x30>
 80031e6:	f04f 0314 	mov.w	r3, #20
 80031ea:	f383 8811 	msr	BASEPRI, r3
 80031ee:	f3bf 8f6f 	isb	sy
 80031f2:	f3bf 8f4f 	dsb	sy
 80031f6:	e7fe      	b.n	80031f6 <xTaskIncrementTick+0x2e>
 80031f8:	4a33      	ldr	r2, [pc, #204]	; (80032c8 <xTaskIncrementTick+0x100>)
 80031fa:	6811      	ldr	r1, [r2, #0]
 80031fc:	4b33      	ldr	r3, [pc, #204]	; (80032cc <xTaskIncrementTick+0x104>)
 80031fe:	6818      	ldr	r0, [r3, #0]
 8003200:	6010      	str	r0, [r2, #0]
 8003202:	6019      	str	r1, [r3, #0]
 8003204:	4a32      	ldr	r2, [pc, #200]	; (80032d0 <xTaskIncrementTick+0x108>)
 8003206:	6813      	ldr	r3, [r2, #0]
 8003208:	3301      	adds	r3, #1
 800320a:	6013      	str	r3, [r2, #0]
 800320c:	f7ff fd92 	bl	8002d34 <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
 8003210:	4b30      	ldr	r3, [pc, #192]	; (80032d4 <xTaskIncrementTick+0x10c>)
 8003212:	681b      	ldr	r3, [r3, #0]
 8003214:	429d      	cmp	r5, r3
 8003216:	d201      	bcs.n	800321c <xTaskIncrementTick+0x54>

BaseType_t xTaskIncrementTick( void )
{
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
 8003218:	2400      	movs	r4, #0
 800321a:	e038      	b.n	800328e <xTaskIncrementTick+0xc6>
 800321c:	2400      	movs	r4, #0
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800321e:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 80032c8 <xTaskIncrementTick+0x100>
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
 8003222:	4f2d      	ldr	r7, [pc, #180]	; (80032d8 <xTaskIncrementTick+0x110>)
 8003224:	f8df a0b8 	ldr.w	sl, [pc, #184]	; 80032e0 <xTaskIncrementTick+0x118>
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8003228:	f8d8 3000 	ldr.w	r3, [r8]
 800322c:	681b      	ldr	r3, [r3, #0]
 800322e:	b923      	cbnz	r3, 800323a <xTaskIncrementTick+0x72>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8003230:	f04f 32ff 	mov.w	r2, #4294967295
 8003234:	4b27      	ldr	r3, [pc, #156]	; (80032d4 <xTaskIncrementTick+0x10c>)
 8003236:	601a      	str	r2, [r3, #0]
                    break;
 8003238:	e029      	b.n	800328e <xTaskIncrementTick+0xc6>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800323a:	f8d8 3000 	ldr.w	r3, [r8]
 800323e:	68db      	ldr	r3, [r3, #12]
 8003240:	68de      	ldr	r6, [r3, #12]
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 8003242:	6873      	ldr	r3, [r6, #4]

                    if( xConstTickCount < xItemValue )
 8003244:	429d      	cmp	r5, r3
 8003246:	d202      	bcs.n	800324e <xTaskIncrementTick+0x86>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
 8003248:	4a22      	ldr	r2, [pc, #136]	; (80032d4 <xTaskIncrementTick+0x10c>)
 800324a:	6013      	str	r3, [r2, #0]
                        break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
 800324c:	e01f      	b.n	800328e <xTaskIncrementTick+0xc6>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800324e:	f106 0904 	add.w	r9, r6, #4
 8003252:	4648      	mov	r0, r9
 8003254:	f7ff f880 	bl	8002358 <uxListRemove>

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8003258:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 800325a:	b11b      	cbz	r3, 8003264 <xTaskIncrementTick+0x9c>
                    {
                        ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800325c:	f106 0018 	add.w	r0, r6, #24
 8003260:	f7ff f87a 	bl	8002358 <uxListRemove>
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
 8003264:	6af0      	ldr	r0, [r6, #44]	; 0x2c
 8003266:	683b      	ldr	r3, [r7, #0]
 8003268:	2201      	movs	r2, #1
 800326a:	4082      	lsls	r2, r0
 800326c:	4313      	orrs	r3, r2
 800326e:	603b      	str	r3, [r7, #0]
 8003270:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8003274:	eb0a 0080 	add.w	r0, sl, r0, lsl #2
 8003278:	4649      	mov	r1, r9
 800327a:	f7ff f847 	bl	800230c <vListInsertEnd>
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800327e:	4b17      	ldr	r3, [pc, #92]	; (80032dc <xTaskIncrementTick+0x114>)
 8003280:	681b      	ldr	r3, [r3, #0]
 8003282:	6af2      	ldr	r2, [r6, #44]	; 0x2c
 8003284:	6adb      	ldr	r3, [r3, #44]	; 0x2c
                            {
                                xSwitchRequired = pdTRUE;
 8003286:	429a      	cmp	r2, r3
 8003288:	bf28      	it	cs
 800328a:	2401      	movcs	r4, #1
 800328c:	e7cc      	b.n	8003228 <xTaskIncrementTick+0x60>
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 800328e:	4b13      	ldr	r3, [pc, #76]	; (80032dc <xTaskIncrementTick+0x114>)
 8003290:	681b      	ldr	r3, [r3, #0]
 8003292:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003294:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8003298:	009b      	lsls	r3, r3, #2
 800329a:	4a11      	ldr	r2, [pc, #68]	; (80032e0 <xTaskIncrementTick+0x118>)
 800329c:	58d3      	ldr	r3, [r2, r3]
                {
                    xSwitchRequired = pdTRUE;
 800329e:	2b02      	cmp	r3, #2
 80032a0:	bf28      	it	cs
 80032a2:	2401      	movcs	r4, #1
            }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
            {
                if( xYieldPending != pdFALSE )
 80032a4:	4b0f      	ldr	r3, [pc, #60]	; (80032e4 <xTaskIncrementTick+0x11c>)
 80032a6:	681b      	ldr	r3, [r3, #0]
                {
                    xSwitchRequired = pdTRUE;
 80032a8:	2b00      	cmp	r3, #0
 80032aa:	bf18      	it	ne
 80032ac:	2401      	movne	r4, #1
 80032ae:	e004      	b.n	80032ba <xTaskIncrementTick+0xf2>
            }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
 80032b0:	4a0d      	ldr	r2, [pc, #52]	; (80032e8 <xTaskIncrementTick+0x120>)
 80032b2:	6813      	ldr	r3, [r2, #0]
 80032b4:	3301      	adds	r3, #1
 80032b6:	6013      	str	r3, [r2, #0]

BaseType_t xTaskIncrementTick( void )
{
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
 80032b8:	2400      	movs	r4, #0
            }
        #endif
    }

    return xSwitchRequired;
}
 80032ba:	4620      	mov	r0, r4
 80032bc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80032c0:	200008f8 	.word	0x200008f8
 80032c4:	20000928 	.word	0x20000928
 80032c8:	2000080c 	.word	0x2000080c
 80032cc:	20000828 	.word	0x20000828
 80032d0:	20000808 	.word	0x20000808
 80032d4:	2000092c 	.word	0x2000092c
 80032d8:	20000968 	.word	0x20000968
 80032dc:	200008fc 	.word	0x200008fc
 80032e0:	20000830 	.word	0x20000830
 80032e4:	2000096c 	.word	0x2000096c
 80032e8:	2000082c 	.word	0x2000082c

080032ec <xTaskResumeAll>:
    TCB_t * pxTCB = NULL;
    BaseType_t xAlreadyYielded = pdFALSE;

    /* If uxSchedulerSuspended is zero then this function does not match a
     * previous call to vTaskSuspendAll(). */
    configASSERT( uxSchedulerSuspended );
 80032ec:	4b35      	ldr	r3, [pc, #212]	; (80033c4 <xTaskResumeAll+0xd8>)
 80032ee:	681b      	ldr	r3, [r3, #0]
 80032f0:	b943      	cbnz	r3, 8003304 <xTaskResumeAll+0x18>
 80032f2:	f04f 0314 	mov.w	r3, #20
 80032f6:	f383 8811 	msr	BASEPRI, r3
 80032fa:	f3bf 8f6f 	isb	sy
 80032fe:	f3bf 8f4f 	dsb	sy
 8003302:	e7fe      	b.n	8003302 <xTaskResumeAll+0x16>

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 8003304:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
 8003308:	f7fe fd5a 	bl	8001dc0 <vPortEnterCritical>
    {
        --uxSchedulerSuspended;
 800330c:	4b2d      	ldr	r3, [pc, #180]	; (80033c4 <xTaskResumeAll+0xd8>)
 800330e:	681a      	ldr	r2, [r3, #0]
 8003310:	3a01      	subs	r2, #1
 8003312:	601a      	str	r2, [r3, #0]

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8003314:	681b      	ldr	r3, [r3, #0]
 8003316:	2b00      	cmp	r3, #0
 8003318:	d14b      	bne.n	80033b2 <xTaskResumeAll+0xc6>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 800331a:	4b2b      	ldr	r3, [pc, #172]	; (80033c8 <xTaskResumeAll+0xdc>)
 800331c:	681b      	ldr	r3, [r3, #0]
 800331e:	bb13      	cbnz	r3, 8003366 <xTaskResumeAll+0x7a>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    TCB_t * pxTCB = NULL;
    BaseType_t xAlreadyYielded = pdFALSE;
 8003320:	2400      	movs	r4, #0
 8003322:	e049      	b.n	80033b8 <xTaskResumeAll+0xcc>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8003324:	68f3      	ldr	r3, [r6, #12]
 8003326:	68dc      	ldr	r4, [r3, #12]
                    ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8003328:	f104 0018 	add.w	r0, r4, #24
 800332c:	f7ff f814 	bl	8002358 <uxListRemove>
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8003330:	1d27      	adds	r7, r4, #4
 8003332:	4638      	mov	r0, r7
 8003334:	f7ff f810 	bl	8002358 <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
 8003338:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 800333a:	682b      	ldr	r3, [r5, #0]
 800333c:	2201      	movs	r2, #1
 800333e:	4082      	lsls	r2, r0
 8003340:	4313      	orrs	r3, r2
 8003342:	602b      	str	r3, [r5, #0]
 8003344:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8003348:	eb08 0080 	add.w	r0, r8, r0, lsl #2
 800334c:	4639      	mov	r1, r7
 800334e:	f7fe ffdd 	bl	800230c <vListInsertEnd>

                    /* If the moved task has a priority higher than the current
                     * task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8003352:	4b1e      	ldr	r3, [pc, #120]	; (80033cc <xTaskResumeAll+0xe0>)
 8003354:	681b      	ldr	r3, [r3, #0]
 8003356:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8003358:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800335a:	429a      	cmp	r2, r3
 800335c:	d308      	bcc.n	8003370 <xTaskResumeAll+0x84>
                    {
                        xYieldPending = pdTRUE;
 800335e:	2201      	movs	r2, #1
 8003360:	4b1b      	ldr	r3, [pc, #108]	; (80033d0 <xTaskResumeAll+0xe4>)
 8003362:	601a      	str	r2, [r3, #0]
 8003364:	e004      	b.n	8003370 <xTaskResumeAll+0x84>
 8003366:	2400      	movs	r4, #0
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8003368:	4e1a      	ldr	r6, [pc, #104]	; (80033d4 <xTaskResumeAll+0xe8>)
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
                    ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
                    prvAddTaskToReadyList( pxTCB );
 800336a:	4d1b      	ldr	r5, [pc, #108]	; (80033d8 <xTaskResumeAll+0xec>)
 800336c:	f8df 8074 	ldr.w	r8, [pc, #116]	; 80033e4 <xTaskResumeAll+0xf8>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8003370:	6833      	ldr	r3, [r6, #0]
 8003372:	2b00      	cmp	r3, #0
 8003374:	d1d6      	bne.n	8003324 <xTaskResumeAll+0x38>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
 8003376:	b10c      	cbz	r4, 800337c <xTaskResumeAll+0x90>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
 8003378:	f7ff fcdc 	bl	8002d34 <prvResetNextTaskUnblockTime>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
 800337c:	4b17      	ldr	r3, [pc, #92]	; (80033dc <xTaskResumeAll+0xf0>)
 800337e:	681c      	ldr	r4, [r3, #0]

                    if( xPendedCounts > ( TickType_t ) 0U )
 8003380:	b154      	cbz	r4, 8003398 <xTaskResumeAll+0xac>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
                            {
                                xYieldPending = pdTRUE;
 8003382:	4e13      	ldr	r6, [pc, #76]	; (80033d0 <xTaskResumeAll+0xe4>)
 8003384:	2501      	movs	r5, #1

                    if( xPendedCounts > ( TickType_t ) 0U )
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
 8003386:	f7ff ff1f 	bl	80031c8 <xTaskIncrementTick>
 800338a:	b100      	cbz	r0, 800338e <xTaskResumeAll+0xa2>
                            {
                                xYieldPending = pdTRUE;
 800338c:	6035      	str	r5, [r6, #0]
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
                        } while( xPendedCounts > ( TickType_t ) 0U );
 800338e:	3c01      	subs	r4, #1
 8003390:	d1f9      	bne.n	8003386 <xTaskResumeAll+0x9a>

                        xPendedTicks = 0;
 8003392:	2200      	movs	r2, #0
 8003394:	4b11      	ldr	r3, [pc, #68]	; (80033dc <xTaskResumeAll+0xf0>)
 8003396:	601a      	str	r2, [r3, #0]
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
 8003398:	4b0d      	ldr	r3, [pc, #52]	; (80033d0 <xTaskResumeAll+0xe4>)
 800339a:	681b      	ldr	r3, [r3, #0]
 800339c:	b15b      	cbz	r3, 80033b6 <xTaskResumeAll+0xca>
                    #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
                        }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
 800339e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80033a2:	4b0f      	ldr	r3, [pc, #60]	; (80033e0 <xTaskResumeAll+0xf4>)
 80033a4:	601a      	str	r2, [r3, #0]
 80033a6:	f3bf 8f4f 	dsb	sy
 80033aa:	f3bf 8f6f 	isb	sy

                if( xYieldPending != pdFALSE )
                {
                    #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
 80033ae:	2401      	movs	r4, #1
 80033b0:	e002      	b.n	80033b8 <xTaskResumeAll+0xcc>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    TCB_t * pxTCB = NULL;
    BaseType_t xAlreadyYielded = pdFALSE;
 80033b2:	2400      	movs	r4, #0
 80033b4:	e000      	b.n	80033b8 <xTaskResumeAll+0xcc>
 80033b6:	2400      	movs	r4, #0
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
 80033b8:	f7fe fd24 	bl	8001e04 <vPortExitCritical>

    return xAlreadyYielded;
}
 80033bc:	4620      	mov	r0, r4
 80033be:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80033c2:	bf00      	nop
 80033c4:	200008f8 	.word	0x200008f8
 80033c8:	20000948 	.word	0x20000948
 80033cc:	200008fc 	.word	0x200008fc
 80033d0:	2000096c 	.word	0x2000096c
 80033d4:	20000900 	.word	0x20000900
 80033d8:	20000968 	.word	0x20000968
 80033dc:	2000082c 	.word	0x2000082c
 80033e0:	e000ed04 	.word	0xe000ed04
 80033e4:	20000830 	.word	0x20000830

080033e8 <vTaskDelayUntil>:

#if ( INCLUDE_vTaskDelayUntil == 1 )

    void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                          const TickType_t xTimeIncrement )
    {
 80033e8:	b538      	push	{r3, r4, r5, lr}
        TickType_t xTimeToWake;
        BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;

        configASSERT( pxPreviousWakeTime );
 80033ea:	b940      	cbnz	r0, 80033fe <vTaskDelayUntil+0x16>
 80033ec:	f04f 0314 	mov.w	r3, #20
 80033f0:	f383 8811 	msr	BASEPRI, r3
 80033f4:	f3bf 8f6f 	isb	sy
 80033f8:	f3bf 8f4f 	dsb	sy
 80033fc:	e7fe      	b.n	80033fc <vTaskDelayUntil+0x14>
 80033fe:	4605      	mov	r5, r0
        configASSERT( ( xTimeIncrement > 0U ) );
 8003400:	b941      	cbnz	r1, 8003414 <vTaskDelayUntil+0x2c>
 8003402:	f04f 0314 	mov.w	r3, #20
 8003406:	f383 8811 	msr	BASEPRI, r3
 800340a:	f3bf 8f6f 	isb	sy
 800340e:	f3bf 8f4f 	dsb	sy
 8003412:	e7fe      	b.n	8003412 <vTaskDelayUntil+0x2a>
        configASSERT( uxSchedulerSuspended == 0 );
 8003414:	4b1a      	ldr	r3, [pc, #104]	; (8003480 <vTaskDelayUntil+0x98>)
 8003416:	681b      	ldr	r3, [r3, #0]
 8003418:	b143      	cbz	r3, 800342c <vTaskDelayUntil+0x44>
 800341a:	f04f 0314 	mov.w	r3, #20
 800341e:	f383 8811 	msr	BASEPRI, r3
 8003422:	f3bf 8f6f 	isb	sy
 8003426:	f3bf 8f4f 	dsb	sy
 800342a:	e7fe      	b.n	800342a <vTaskDelayUntil+0x42>
 800342c:	460c      	mov	r4, r1

        vTaskSuspendAll();
 800342e:	f7ff febd 	bl	80031ac <vTaskSuspendAll>
        {
            /* Minor optimisation.  The tick count cannot change in this
             * block. */
            const TickType_t xConstTickCount = xTickCount;
 8003432:	4b14      	ldr	r3, [pc, #80]	; (8003484 <vTaskDelayUntil+0x9c>)
 8003434:	6818      	ldr	r0, [r3, #0]

            /* Generate the tick time at which the task wants to wake. */
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 8003436:	682a      	ldr	r2, [r5, #0]
 8003438:	1913      	adds	r3, r2, r4

            if( xConstTickCount < *pxPreviousWakeTime )
 800343a:	4290      	cmp	r0, r2
 800343c:	d205      	bcs.n	800344a <vTaskDelayUntil+0x62>
                /* The tick count has overflowed since this function was
                 * lasted called.  In this case the only time we should ever
                 * actually delay is if the wake time has also  overflowed,
                 * and the wake time is greater than the tick time.  When this
                 * is the case it is as if neither time had overflowed. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 800343e:	429a      	cmp	r2, r3
 8003440:	d91a      	bls.n	8003478 <vTaskDelayUntil+0x90>
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            /* Update the wake time ready for the next call. */
            *pxPreviousWakeTime = xTimeToWake;
 8003442:	602b      	str	r3, [r5, #0]

            if( xShouldDelay != pdFALSE )
 8003444:	4298      	cmp	r0, r3
 8003446:	d209      	bcs.n	800345c <vTaskDelayUntil+0x74>
 8003448:	e004      	b.n	8003454 <vTaskDelayUntil+0x6c>
            else
            {
                /* The tick time has not overflowed.  In this case we will
                 * delay if either the wake time has overflowed, and/or the
                 * tick time is less than the wake time. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 800344a:	429a      	cmp	r2, r3
 800344c:	d812      	bhi.n	8003474 <vTaskDelayUntil+0x8c>
 800344e:	4298      	cmp	r0, r3
 8003450:	d310      	bcc.n	8003474 <vTaskDelayUntil+0x8c>
 8003452:	e011      	b.n	8003478 <vTaskDelayUntil+0x90>
            {
                traceTASK_DELAY_UNTIL( xTimeToWake );

                /* prvAddCurrentTaskToDelayedList() needs the block time, not
                 * the time to wake, so subtract the current tick count. */
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
 8003454:	1a18      	subs	r0, r3, r0
 8003456:	2100      	movs	r1, #0
 8003458:	f7ff fc80 	bl	8002d5c <prvAddCurrentTaskToDelayedList>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        xAlreadyYielded = xTaskResumeAll();
 800345c:	f7ff ff46 	bl	80032ec <xTaskResumeAll>

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
 8003460:	b960      	cbnz	r0, 800347c <vTaskDelayUntil+0x94>
        {
            portYIELD_WITHIN_API();
 8003462:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8003466:	4b08      	ldr	r3, [pc, #32]	; (8003488 <vTaskDelayUntil+0xa0>)
 8003468:	601a      	str	r2, [r3, #0]
 800346a:	f3bf 8f4f 	dsb	sy
 800346e:	f3bf 8f6f 	isb	sy
 8003472:	bd38      	pop	{r3, r4, r5, pc}
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            /* Update the wake time ready for the next call. */
            *pxPreviousWakeTime = xTimeToWake;
 8003474:	602b      	str	r3, [r5, #0]
 8003476:	e7ed      	b.n	8003454 <vTaskDelayUntil+0x6c>
 8003478:	602b      	str	r3, [r5, #0]
 800347a:	e7ef      	b.n	800345c <vTaskDelayUntil+0x74>
 800347c:	bd38      	pop	{r3, r4, r5, pc}
 800347e:	bf00      	nop
 8003480:	200008f8 	.word	0x200008f8
 8003484:	20000928 	.word	0x20000928
 8003488:	e000ed04 	.word	0xe000ed04

0800348c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
 800348c:	b510      	push	{r4, lr}
        BaseType_t xAlreadyYielded = pdFALSE;

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
 800348e:	b1a8      	cbz	r0, 80034bc <vTaskDelay+0x30>
 8003490:	4604      	mov	r4, r0
        {
            configASSERT( uxSchedulerSuspended == 0 );
 8003492:	4b0f      	ldr	r3, [pc, #60]	; (80034d0 <vTaskDelay+0x44>)
 8003494:	681b      	ldr	r3, [r3, #0]
 8003496:	b143      	cbz	r3, 80034aa <vTaskDelay+0x1e>
 8003498:	f04f 0314 	mov.w	r3, #20
 800349c:	f383 8811 	msr	BASEPRI, r3
 80034a0:	f3bf 8f6f 	isb	sy
 80034a4:	f3bf 8f4f 	dsb	sy
 80034a8:	e7fe      	b.n	80034a8 <vTaskDelay+0x1c>
            vTaskSuspendAll();
 80034aa:	f7ff fe7f 	bl	80031ac <vTaskSuspendAll>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 80034ae:	4620      	mov	r0, r4
 80034b0:	2100      	movs	r1, #0
 80034b2:	f7ff fc53 	bl	8002d5c <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
 80034b6:	f7ff ff19 	bl	80032ec <xTaskResumeAll>
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
 80034ba:	b938      	cbnz	r0, 80034cc <vTaskDelay+0x40>
        {
            portYIELD_WITHIN_API();
 80034bc:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80034c0:	4b04      	ldr	r3, [pc, #16]	; (80034d4 <vTaskDelay+0x48>)
 80034c2:	601a      	str	r2, [r3, #0]
 80034c4:	f3bf 8f4f 	dsb	sy
 80034c8:	f3bf 8f6f 	isb	sy
 80034cc:	bd10      	pop	{r4, pc}
 80034ce:	bf00      	nop
 80034d0:	200008f8 	.word	0x200008f8
 80034d4:	e000ed04 	.word	0xe000ed04

080034d8 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 80034d8:	4b25      	ldr	r3, [pc, #148]	; (8003570 <vTaskSwitchContext+0x98>)
 80034da:	681b      	ldr	r3, [r3, #0]
 80034dc:	b11b      	cbz	r3, 80034e6 <vTaskSwitchContext+0xe>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
 80034de:	2201      	movs	r2, #1
 80034e0:	4b24      	ldr	r3, [pc, #144]	; (8003574 <vTaskSwitchContext+0x9c>)
 80034e2:	601a      	str	r2, [r3, #0]
 80034e4:	4770      	bx	lr

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 80034e6:	b510      	push	{r4, lr}
         * switch. */
        xYieldPending = pdTRUE;
    }
    else
    {
        xYieldPending = pdFALSE;
 80034e8:	2200      	movs	r2, #0
 80034ea:	4b22      	ldr	r3, [pc, #136]	; (8003574 <vTaskSwitchContext+0x9c>)
 80034ec:	601a      	str	r2, [r3, #0]
                ulTaskSwitchedInTime = ulTotalRunTime;
            }
        #endif /* configGENERATE_RUN_TIME_STATS */

        /* Check for stack overflow, if configured. */
        taskCHECK_FOR_STACK_OVERFLOW();
 80034ee:	4b22      	ldr	r3, [pc, #136]	; (8003578 <vTaskSwitchContext+0xa0>)
 80034f0:	681a      	ldr	r2, [r3, #0]
 80034f2:	681b      	ldr	r3, [r3, #0]
 80034f4:	6812      	ldr	r2, [r2, #0]
 80034f6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80034f8:	429a      	cmp	r2, r3
 80034fa:	d805      	bhi.n	8003508 <vTaskSwitchContext+0x30>
 80034fc:	4b1e      	ldr	r3, [pc, #120]	; (8003578 <vTaskSwitchContext+0xa0>)
 80034fe:	6818      	ldr	r0, [r3, #0]
 8003500:	6819      	ldr	r1, [r3, #0]
 8003502:	3134      	adds	r1, #52	; 0x34
 8003504:	f007 faee 	bl	800aae4 <vApplicationStackOverflowHook>
            }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8003508:	4b1c      	ldr	r3, [pc, #112]	; (800357c <vTaskSwitchContext+0xa4>)
 800350a:	681b      	ldr	r3, [r3, #0]
/* Generic helper function. */
        __attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitmap )
        {
            uint8_t ucReturn;

            __asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 800350c:	fab3 f383 	clz	r3, r3
 8003510:	b2db      	uxtb	r3, r3
 8003512:	f1c3 031f 	rsb	r3, r3, #31
 8003516:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 800351a:	0092      	lsls	r2, r2, #2
 800351c:	4918      	ldr	r1, [pc, #96]	; (8003580 <vTaskSwitchContext+0xa8>)
 800351e:	588a      	ldr	r2, [r1, r2]
 8003520:	b942      	cbnz	r2, 8003534 <vTaskSwitchContext+0x5c>

    portFORCE_INLINE static void vPortRaiseBASEPRI( void )
    {
        uint32_t ulNewBASEPRI;

        __asm volatile
 8003522:	f04f 0314 	mov.w	r3, #20
 8003526:	f383 8811 	msr	BASEPRI, r3
 800352a:	f3bf 8f6f 	isb	sy
 800352e:	f3bf 8f4f 	dsb	sy
 8003532:	e7fe      	b.n	8003532 <vTaskSwitchContext+0x5a>
 8003534:	4a12      	ldr	r2, [pc, #72]	; (8003580 <vTaskSwitchContext+0xa8>)
 8003536:	0099      	lsls	r1, r3, #2
 8003538:	18c8      	adds	r0, r1, r3
 800353a:	eb02 0080 	add.w	r0, r2, r0, lsl #2
 800353e:	6844      	ldr	r4, [r0, #4]
 8003540:	6864      	ldr	r4, [r4, #4]
 8003542:	6044      	str	r4, [r0, #4]
 8003544:	4602      	mov	r2, r0
 8003546:	3208      	adds	r2, #8
 8003548:	4294      	cmp	r4, r2
 800354a:	d106      	bne.n	800355a <vTaskSwitchContext+0x82>
 800354c:	6860      	ldr	r0, [r4, #4]
 800354e:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 8003552:	4a0b      	ldr	r2, [pc, #44]	; (8003580 <vTaskSwitchContext+0xa8>)
 8003554:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 8003558:	6050      	str	r0, [r2, #4]
 800355a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800355e:	4a08      	ldr	r2, [pc, #32]	; (8003580 <vTaskSwitchContext+0xa8>)
 8003560:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8003564:	685b      	ldr	r3, [r3, #4]
 8003566:	68da      	ldr	r2, [r3, #12]
 8003568:	4b03      	ldr	r3, [pc, #12]	; (8003578 <vTaskSwitchContext+0xa0>)
 800356a:	601a      	str	r2, [r3, #0]
 800356c:	bd10      	pop	{r4, pc}
 800356e:	bf00      	nop
 8003570:	200008f8 	.word	0x200008f8
 8003574:	2000096c 	.word	0x2000096c
 8003578:	200008fc 	.word	0x200008fc
 800357c:	20000968 	.word	0x20000968
 8003580:	20000830 	.word	0x20000830

08003584 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
    configASSERT( pxEventList );
 8003584:	b940      	cbnz	r0, 8003598 <vTaskPlaceOnEventList+0x14>
 8003586:	f04f 0314 	mov.w	r3, #20
 800358a:	f383 8811 	msr	BASEPRI, r3
 800358e:	f3bf 8f6f 	isb	sy
 8003592:	f3bf 8f4f 	dsb	sy
 8003596:	e7fe      	b.n	8003596 <vTaskPlaceOnEventList+0x12>
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
 8003598:	b510      	push	{r4, lr}
 800359a:	460c      	mov	r4, r1

    /* Place the event list item of the TCB in the appropriate event list.
     * This is placed in the list in priority order so the highest priority task
     * is the first to be woken by the event.  The queue that contains the event
     * list is locked, preventing simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 800359c:	4b04      	ldr	r3, [pc, #16]	; (80035b0 <vTaskPlaceOnEventList+0x2c>)
 800359e:	6819      	ldr	r1, [r3, #0]
 80035a0:	3118      	adds	r1, #24
 80035a2:	f7fe febf 	bl	8002324 <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 80035a6:	4620      	mov	r0, r4
 80035a8:	2101      	movs	r1, #1
 80035aa:	f7ff fbd7 	bl	8002d5c <prvAddCurrentTaskToDelayedList>
 80035ae:	bd10      	pop	{r4, pc}
 80035b0:	200008fc 	.word	0x200008fc

080035b4 <vTaskPlaceOnUnorderedEventList>:

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
    configASSERT( pxEventList );
 80035b4:	b940      	cbnz	r0, 80035c8 <vTaskPlaceOnUnorderedEventList+0x14>
 80035b6:	f04f 0314 	mov.w	r3, #20
 80035ba:	f383 8811 	msr	BASEPRI, r3
 80035be:	f3bf 8f6f 	isb	sy
 80035c2:	f3bf 8f4f 	dsb	sy
 80035c6:	e7fe      	b.n	80035c6 <vTaskPlaceOnUnorderedEventList+0x12>
 80035c8:	4603      	mov	r3, r0

    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event groups implementation. */
    configASSERT( uxSchedulerSuspended != 0 );
 80035ca:	480f      	ldr	r0, [pc, #60]	; (8003608 <vTaskPlaceOnUnorderedEventList+0x54>)
 80035cc:	6800      	ldr	r0, [r0, #0]
 80035ce:	b940      	cbnz	r0, 80035e2 <vTaskPlaceOnUnorderedEventList+0x2e>
 80035d0:	f04f 0314 	mov.w	r3, #20
 80035d4:	f383 8811 	msr	BASEPRI, r3
 80035d8:	f3bf 8f6f 	isb	sy
 80035dc:	f3bf 8f4f 	dsb	sy
 80035e0:	e7fe      	b.n	80035e0 <vTaskPlaceOnUnorderedEventList+0x2c>
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
 80035e2:	b510      	push	{r4, lr}
 80035e4:	4618      	mov	r0, r3
 80035e6:	4614      	mov	r4, r2
 80035e8:	460b      	mov	r3, r1
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 80035ea:	4a08      	ldr	r2, [pc, #32]	; (800360c <vTaskPlaceOnUnorderedEventList+0x58>)
 80035ec:	6811      	ldr	r1, [r2, #0]
 80035ee:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80035f2:	618b      	str	r3, [r1, #24]
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 80035f4:	6811      	ldr	r1, [r2, #0]
 80035f6:	3118      	adds	r1, #24
 80035f8:	f7fe fe88 	bl	800230c <vListInsertEnd>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 80035fc:	4620      	mov	r0, r4
 80035fe:	2101      	movs	r1, #1
 8003600:	f7ff fbac 	bl	8002d5c <prvAddCurrentTaskToDelayedList>
 8003604:	bd10      	pop	{r4, pc}
 8003606:	bf00      	nop
 8003608:	200008f8 	.word	0x200008f8
 800360c:	200008fc 	.word	0x200008fc

08003610 <vTaskPlaceOnEventListRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vTaskPlaceOnEventListRestricted( List_t * const pxEventList,
                                          TickType_t xTicksToWait,
                                          const BaseType_t xWaitIndefinitely )
    {
 8003610:	b538      	push	{r3, r4, r5, lr}
        configASSERT( pxEventList );
 8003612:	b940      	cbnz	r0, 8003626 <vTaskPlaceOnEventListRestricted+0x16>
 8003614:	f04f 0314 	mov.w	r3, #20
 8003618:	f383 8811 	msr	BASEPRI, r3
 800361c:	f3bf 8f6f 	isb	sy
 8003620:	f3bf 8f4f 	dsb	sy
 8003624:	e7fe      	b.n	8003624 <vTaskPlaceOnEventListRestricted+0x14>
 8003626:	4614      	mov	r4, r2
 8003628:	460d      	mov	r5, r1

        /* Place the event list item of the TCB in the appropriate event list.
         * In this case it is assume that this is the only task that is going to
         * be waiting on this event list, so the faster vListInsertEnd() function
         * can be used in place of vListInsert. */
        vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 800362a:	4b07      	ldr	r3, [pc, #28]	; (8003648 <vTaskPlaceOnEventListRestricted+0x38>)
 800362c:	6819      	ldr	r1, [r3, #0]
 800362e:	3118      	adds	r1, #24
 8003630:	f7fe fe6c 	bl	800230c <vListInsertEnd>
        /* If the task should block indefinitely then set the block time to a
         * value that will be recognised as an indefinite delay inside the
         * prvAddCurrentTaskToDelayedList() function. */
        if( xWaitIndefinitely != pdFALSE )
        {
            xTicksToWait = portMAX_DELAY;
 8003634:	2c00      	cmp	r4, #0
        }

        traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
        prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
 8003636:	bf0c      	ite	eq
 8003638:	4628      	moveq	r0, r5
 800363a:	f04f 30ff 	movne.w	r0, #4294967295
 800363e:	4621      	mov	r1, r4
 8003640:	f7ff fb8c 	bl	8002d5c <prvAddCurrentTaskToDelayedList>
 8003644:	bd38      	pop	{r3, r4, r5, pc}
 8003646:	bf00      	nop
 8003648:	200008fc 	.word	0x200008fc

0800364c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
 800364c:	b538      	push	{r3, r4, r5, lr}
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800364e:	68c3      	ldr	r3, [r0, #12]
 8003650:	68dc      	ldr	r4, [r3, #12]
    configASSERT( pxUnblockedTCB );
 8003652:	b944      	cbnz	r4, 8003666 <xTaskRemoveFromEventList+0x1a>
 8003654:	f04f 0314 	mov.w	r3, #20
 8003658:	f383 8811 	msr	BASEPRI, r3
 800365c:	f3bf 8f6f 	isb	sy
 8003660:	f3bf 8f4f 	dsb	sy
 8003664:	e7fe      	b.n	8003664 <xTaskRemoveFromEventList+0x18>
    ( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 8003666:	f104 0518 	add.w	r5, r4, #24
 800366a:	4628      	mov	r0, r5
 800366c:	f7fe fe74 	bl	8002358 <uxListRemove>

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8003670:	4b12      	ldr	r3, [pc, #72]	; (80036bc <xTaskRemoveFromEventList+0x70>)
 8003672:	681b      	ldr	r3, [r3, #0]
 8003674:	b99b      	cbnz	r3, 800369e <xTaskRemoveFromEventList+0x52>
    {
        ( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 8003676:	1d25      	adds	r5, r4, #4
 8003678:	4628      	mov	r0, r5
 800367a:	f7fe fe6d 	bl	8002358 <uxListRemove>
        prvAddTaskToReadyList( pxUnblockedTCB );
 800367e:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8003680:	490f      	ldr	r1, [pc, #60]	; (80036c0 <xTaskRemoveFromEventList+0x74>)
 8003682:	680b      	ldr	r3, [r1, #0]
 8003684:	2201      	movs	r2, #1
 8003686:	4082      	lsls	r2, r0
 8003688:	4313      	orrs	r3, r2
 800368a:	600b      	str	r3, [r1, #0]
 800368c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8003690:	4b0c      	ldr	r3, [pc, #48]	; (80036c4 <xTaskRemoveFromEventList+0x78>)
 8003692:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8003696:	4629      	mov	r1, r5
 8003698:	f7fe fe38 	bl	800230c <vListInsertEnd>
 800369c:	e003      	b.n	80036a6 <xTaskRemoveFromEventList+0x5a>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 800369e:	480a      	ldr	r0, [pc, #40]	; (80036c8 <xTaskRemoveFromEventList+0x7c>)
 80036a0:	4629      	mov	r1, r5
 80036a2:	f7fe fe33 	bl	800230c <vListInsertEnd>
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 80036a6:	4b09      	ldr	r3, [pc, #36]	; (80036cc <xTaskRemoveFromEventList+0x80>)
 80036a8:	681b      	ldr	r3, [r3, #0]
 80036aa:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80036ac:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80036ae:	429a      	cmp	r2, r3
         * it should force a context switch now. */
        xReturn = pdTRUE;

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
 80036b0:	bf83      	ittte	hi
 80036b2:	2001      	movhi	r0, #1
 80036b4:	4b06      	ldrhi	r3, [pc, #24]	; (80036d0 <xTaskRemoveFromEventList+0x84>)
 80036b6:	6018      	strhi	r0, [r3, #0]
    }
    else
    {
        xReturn = pdFALSE;
 80036b8:	2000      	movls	r0, #0
    }

    return xReturn;
}
 80036ba:	bd38      	pop	{r3, r4, r5, pc}
 80036bc:	200008f8 	.word	0x200008f8
 80036c0:	20000968 	.word	0x20000968
 80036c4:	20000830 	.word	0x20000830
 80036c8:	20000900 	.word	0x20000900
 80036cc:	200008fc 	.word	0x200008fc
 80036d0:	2000096c 	.word	0x2000096c

080036d4 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
 80036d4:	b538      	push	{r3, r4, r5, lr}
    TCB_t * pxUnblockedTCB;

    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );
 80036d6:	4b1c      	ldr	r3, [pc, #112]	; (8003748 <vTaskRemoveFromUnorderedEventList+0x74>)
 80036d8:	681b      	ldr	r3, [r3, #0]
 80036da:	b943      	cbnz	r3, 80036ee <vTaskRemoveFromUnorderedEventList+0x1a>
 80036dc:	f04f 0314 	mov.w	r3, #20
 80036e0:	f383 8811 	msr	BASEPRI, r3
 80036e4:	f3bf 8f6f 	isb	sy
 80036e8:	f3bf 8f4f 	dsb	sy
 80036ec:	e7fe      	b.n	80036ec <vTaskRemoveFromUnorderedEventList+0x18>

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 80036ee:	f041 4300 	orr.w	r3, r1, #2147483648	; 0x80000000
 80036f2:	6003      	str	r3, [r0, #0]

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80036f4:	68c4      	ldr	r4, [r0, #12]
    configASSERT( pxUnblockedTCB );
 80036f6:	b944      	cbnz	r4, 800370a <vTaskRemoveFromUnorderedEventList+0x36>
 80036f8:	f04f 0314 	mov.w	r3, #20
 80036fc:	f383 8811 	msr	BASEPRI, r3
 8003700:	f3bf 8f6f 	isb	sy
 8003704:	f3bf 8f4f 	dsb	sy
 8003708:	e7fe      	b.n	8003708 <vTaskRemoveFromUnorderedEventList+0x34>
    ( void ) uxListRemove( pxEventListItem );
 800370a:	f7fe fe25 	bl	8002358 <uxListRemove>
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    ( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 800370e:	1d25      	adds	r5, r4, #4
 8003710:	4628      	mov	r0, r5
 8003712:	f7fe fe21 	bl	8002358 <uxListRemove>
    prvAddTaskToReadyList( pxUnblockedTCB );
 8003716:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8003718:	490c      	ldr	r1, [pc, #48]	; (800374c <vTaskRemoveFromUnorderedEventList+0x78>)
 800371a:	680b      	ldr	r3, [r1, #0]
 800371c:	2201      	movs	r2, #1
 800371e:	4082      	lsls	r2, r0
 8003720:	4313      	orrs	r3, r2
 8003722:	600b      	str	r3, [r1, #0]
 8003724:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8003728:	4b09      	ldr	r3, [pc, #36]	; (8003750 <vTaskRemoveFromUnorderedEventList+0x7c>)
 800372a:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800372e:	4629      	mov	r1, r5
 8003730:	f7fe fdec 	bl	800230c <vListInsertEnd>

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 8003734:	4b07      	ldr	r3, [pc, #28]	; (8003754 <vTaskRemoveFromUnorderedEventList+0x80>)
 8003736:	681b      	ldr	r3, [r3, #0]
 8003738:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800373a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800373c:	429a      	cmp	r2, r3
 800373e:	d902      	bls.n	8003746 <vTaskRemoveFromUnorderedEventList+0x72>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
 8003740:	2201      	movs	r2, #1
 8003742:	4b05      	ldr	r3, [pc, #20]	; (8003758 <vTaskRemoveFromUnorderedEventList+0x84>)
 8003744:	601a      	str	r2, [r3, #0]
 8003746:	bd38      	pop	{r3, r4, r5, pc}
 8003748:	200008f8 	.word	0x200008f8
 800374c:	20000968 	.word	0x20000968
 8003750:	20000830 	.word	0x20000830
 8003754:	200008fc 	.word	0x200008fc
 8003758:	2000096c 	.word	0x2000096c

0800375c <vTaskSetTimeOutState>:
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    configASSERT( pxTimeOut );
 800375c:	b940      	cbnz	r0, 8003770 <vTaskSetTimeOutState+0x14>
 800375e:	f04f 0314 	mov.w	r3, #20
 8003762:	f383 8811 	msr	BASEPRI, r3
 8003766:	f3bf 8f6f 	isb	sy
 800376a:	f3bf 8f4f 	dsb	sy
 800376e:	e7fe      	b.n	800376e <vTaskSetTimeOutState+0x12>
    }
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
 8003770:	b510      	push	{r4, lr}
 8003772:	4604      	mov	r4, r0
    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
 8003774:	f7fe fb24 	bl	8001dc0 <vPortEnterCritical>
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
 8003778:	4b04      	ldr	r3, [pc, #16]	; (800378c <vTaskSetTimeOutState+0x30>)
 800377a:	681b      	ldr	r3, [r3, #0]
 800377c:	6023      	str	r3, [r4, #0]
        pxTimeOut->xTimeOnEntering = xTickCount;
 800377e:	4b04      	ldr	r3, [pc, #16]	; (8003790 <vTaskSetTimeOutState+0x34>)
 8003780:	681b      	ldr	r3, [r3, #0]
 8003782:	6063      	str	r3, [r4, #4]
    }
    taskEXIT_CRITICAL();
 8003784:	f7fe fb3e 	bl	8001e04 <vPortExitCritical>
 8003788:	bd10      	pop	{r4, pc}
 800378a:	bf00      	nop
 800378c:	20000808 	.word	0x20000808
 8003790:	20000928 	.word	0x20000928

08003794 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
 8003794:	4b03      	ldr	r3, [pc, #12]	; (80037a4 <vTaskInternalSetTimeOutState+0x10>)
 8003796:	681b      	ldr	r3, [r3, #0]
 8003798:	6003      	str	r3, [r0, #0]
    pxTimeOut->xTimeOnEntering = xTickCount;
 800379a:	4b03      	ldr	r3, [pc, #12]	; (80037a8 <vTaskInternalSetTimeOutState+0x14>)
 800379c:	681b      	ldr	r3, [r3, #0]
 800379e:	6043      	str	r3, [r0, #4]
 80037a0:	4770      	bx	lr
 80037a2:	bf00      	nop
 80037a4:	20000808 	.word	0x20000808
 80037a8:	20000928 	.word	0x20000928

080037ac <xTaskCheckForTimeOut>:
BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
 80037ac:	b940      	cbnz	r0, 80037c0 <xTaskCheckForTimeOut+0x14>
 80037ae:	f04f 0314 	mov.w	r3, #20
 80037b2:	f383 8811 	msr	BASEPRI, r3
 80037b6:	f3bf 8f6f 	isb	sy
 80037ba:	f3bf 8f4f 	dsb	sy
 80037be:	e7fe      	b.n	80037be <xTaskCheckForTimeOut+0x12>
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
 80037c0:	b570      	push	{r4, r5, r6, lr}
 80037c2:	4605      	mov	r5, r0
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );
 80037c4:	b941      	cbnz	r1, 80037d8 <xTaskCheckForTimeOut+0x2c>
 80037c6:	f04f 0314 	mov.w	r3, #20
 80037ca:	f383 8811 	msr	BASEPRI, r3
 80037ce:	f3bf 8f6f 	isb	sy
 80037d2:	f3bf 8f4f 	dsb	sy
 80037d6:	e7fe      	b.n	80037d6 <xTaskCheckForTimeOut+0x2a>
 80037d8:	460c      	mov	r4, r1

    taskENTER_CRITICAL();
 80037da:	f7fe faf1 	bl	8001dc0 <vPortEnterCritical>
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
 80037de:	4b12      	ldr	r3, [pc, #72]	; (8003828 <xTaskCheckForTimeOut+0x7c>)
 80037e0:	681a      	ldr	r2, [r3, #0]
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 80037e2:	6869      	ldr	r1, [r5, #4]
            }
            else
        #endif

        #if ( INCLUDE_vTaskSuspend == 1 )
            if( *pxTicksToWait == portMAX_DELAY )
 80037e4:	6823      	ldr	r3, [r4, #0]
 80037e6:	f1b3 3fff 	cmp.w	r3, #4294967295
 80037ea:	d018      	beq.n	800381e <xTaskCheckForTimeOut+0x72>
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 80037ec:	480f      	ldr	r0, [pc, #60]	; (800382c <xTaskCheckForTimeOut+0x80>)
 80037ee:	6800      	ldr	r0, [r0, #0]
 80037f0:	682e      	ldr	r6, [r5, #0]
 80037f2:	4286      	cmp	r6, r0
 80037f4:	d005      	beq.n	8003802 <xTaskCheckForTimeOut+0x56>
 80037f6:	428a      	cmp	r2, r1
 80037f8:	d303      	bcc.n	8003802 <xTaskCheckForTimeOut+0x56>
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
            *pxTicksToWait = ( TickType_t ) 0;
 80037fa:	2300      	movs	r3, #0
 80037fc:	6023      	str	r3, [r4, #0]
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
 80037fe:	2401      	movs	r4, #1
            *pxTicksToWait = ( TickType_t ) 0;
 8003800:	e00e      	b.n	8003820 <xTaskCheckForTimeOut+0x74>

    taskENTER_CRITICAL();
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 8003802:	1a52      	subs	r2, r2, r1
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
            *pxTicksToWait = ( TickType_t ) 0;
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 8003804:	429a      	cmp	r2, r3
 8003806:	d206      	bcs.n	8003816 <xTaskCheckForTimeOut+0x6a>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
 8003808:	1a9b      	subs	r3, r3, r2
 800380a:	6023      	str	r3, [r4, #0]
            vTaskInternalSetTimeOutState( pxTimeOut );
 800380c:	4628      	mov	r0, r5
 800380e:	f7ff ffc1 	bl	8003794 <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
 8003812:	2400      	movs	r4, #0
 8003814:	e004      	b.n	8003820 <xTaskCheckForTimeOut+0x74>
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
 8003816:	2300      	movs	r3, #0
 8003818:	6023      	str	r3, [r4, #0]
            xReturn = pdTRUE;
 800381a:	2401      	movs	r4, #1
 800381c:	e000      	b.n	8003820 <xTaskCheckForTimeOut+0x74>
            if( *pxTicksToWait == portMAX_DELAY )
            {
                /* If INCLUDE_vTaskSuspend is set to 1 and the block time
                 * specified is the maximum block time then the task should block
                 * indefinitely, and therefore never time out. */
                xReturn = pdFALSE;
 800381e:	2400      	movs	r4, #0
        {
            *pxTicksToWait = ( TickType_t ) 0;
            xReturn = pdTRUE;
        }
    }
    taskEXIT_CRITICAL();
 8003820:	f7fe faf0 	bl	8001e04 <vPortExitCritical>

    return xReturn;
}
 8003824:	4620      	mov	r0, r4
 8003826:	bd70      	pop	{r4, r5, r6, pc}
 8003828:	20000928 	.word	0x20000928
 800382c:	20000808 	.word	0x20000808

08003830 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    xYieldPending = pdTRUE;
 8003830:	2201      	movs	r2, #1
 8003832:	4b01      	ldr	r3, [pc, #4]	; (8003838 <vTaskMissedYield+0x8>)
 8003834:	601a      	str	r2, [r3, #0]
 8003836:	4770      	bx	lr
 8003838:	2000096c 	.word	0x2000096c

0800383c <xTaskGetCurrentTaskHandle>:
        TaskHandle_t xReturn;

        /* A critical section is not required as this is not called from
         * an interrupt and the current TCB will always be the same for any
         * individual execution thread. */
        xReturn = pxCurrentTCB;
 800383c:	4b01      	ldr	r3, [pc, #4]	; (8003844 <xTaskGetCurrentTaskHandle+0x8>)
 800383e:	6818      	ldr	r0, [r3, #0]

        return xReturn;
    }
 8003840:	4770      	bx	lr
 8003842:	bf00      	nop
 8003844:	200008fc 	.word	0x200008fc

08003848 <xTaskGetSchedulerState>:

    BaseType_t xTaskGetSchedulerState( void )
    {
        BaseType_t xReturn;

        if( xSchedulerRunning == pdFALSE )
 8003848:	4b05      	ldr	r3, [pc, #20]	; (8003860 <xTaskGetSchedulerState+0x18>)
 800384a:	681b      	ldr	r3, [r3, #0]
 800384c:	b133      	cbz	r3, 800385c <xTaskGetSchedulerState+0x14>
        {
            xReturn = taskSCHEDULER_NOT_STARTED;
        }
        else
        {
            if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800384e:	4b05      	ldr	r3, [pc, #20]	; (8003864 <xTaskGetSchedulerState+0x1c>)
 8003850:	681b      	ldr	r3, [r3, #0]
            {
                xReturn = taskSCHEDULER_RUNNING;
            }
            else
            {
                xReturn = taskSCHEDULER_SUSPENDED;
 8003852:	2b00      	cmp	r3, #0
 8003854:	bf0c      	ite	eq
 8003856:	2002      	moveq	r0, #2
 8003858:	2000      	movne	r0, #0
 800385a:	4770      	bx	lr
    {
        BaseType_t xReturn;

        if( xSchedulerRunning == pdFALSE )
        {
            xReturn = taskSCHEDULER_NOT_STARTED;
 800385c:	2001      	movs	r0, #1
                xReturn = taskSCHEDULER_SUSPENDED;
            }
        }

        return xReturn;
    }
 800385e:	4770      	bx	lr
 8003860:	20000810 	.word	0x20000810
 8003864:	200008f8 	.word	0x200008f8

08003868 <xTaskPriorityInherit>:
        BaseType_t xReturn = pdFALSE;

        /* If the mutex was given back by an interrupt while the queue was
         * locked then the mutex holder might now be NULL.  _RB_ Is this still
         * needed as interrupts can no longer use mutexes? */
        if( pxMutexHolder != NULL )
 8003868:	2800      	cmp	r0, #0
 800386a:	d04a      	beq.n	8003902 <xTaskPriorityInherit+0x9a>
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
    {
 800386c:	b538      	push	{r3, r4, r5, lr}
 800386e:	4603      	mov	r3, r0
        if( pxMutexHolder != NULL )
        {
            /* If the holder of the mutex has a priority below the priority of
             * the task attempting to obtain the mutex then it will temporarily
             * inherit the priority of the task attempting to obtain the mutex. */
            if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
 8003870:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8003872:	4925      	ldr	r1, [pc, #148]	; (8003908 <xTaskPriorityInherit+0xa0>)
 8003874:	6809      	ldr	r1, [r1, #0]
 8003876:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 8003878:	428a      	cmp	r2, r1
 800387a:	d239      	bcs.n	80038f0 <xTaskPriorityInherit+0x88>
            {
                /* Adjust the mutex holder state to account for its new
                 * priority.  Only reset the event list item value if the value is
                 * not being used for anything else. */
                if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 800387c:	6981      	ldr	r1, [r0, #24]
 800387e:	2900      	cmp	r1, #0
 8003880:	db05      	blt.n	800388e <xTaskPriorityInherit+0x26>
                {
                    listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8003882:	4921      	ldr	r1, [pc, #132]	; (8003908 <xTaskPriorityInherit+0xa0>)
 8003884:	6809      	ldr	r1, [r1, #0]
 8003886:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 8003888:	f1c1 010a 	rsb	r1, r1, #10
 800388c:	6181      	str	r1, [r0, #24]
                    mtCOVERAGE_TEST_MARKER();
                }

                /* If the task being modified is in the ready state it will need
                 * to be moved into a new list. */
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 800388e:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8003892:	491e      	ldr	r1, [pc, #120]	; (800390c <xTaskPriorityInherit+0xa4>)
 8003894:	eb01 0282 	add.w	r2, r1, r2, lsl #2
 8003898:	6959      	ldr	r1, [r3, #20]
 800389a:	4291      	cmp	r1, r2
 800389c:	d122      	bne.n	80038e4 <xTaskPriorityInherit+0x7c>
 800389e:	461c      	mov	r4, r3
                {
                    if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80038a0:	1d1d      	adds	r5, r3, #4
 80038a2:	4628      	mov	r0, r5
 80038a4:	f7fe fd58 	bl	8002358 <uxListRemove>
 80038a8:	b938      	cbnz	r0, 80038ba <xTaskPriorityInherit+0x52>
                    {
                        /* It is known that the task is in its ready list so
                         * there is no need to check again and the port level
                         * reset macro can be called directly. */
                        portRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority, uxTopReadyPriority );
 80038aa:	4919      	ldr	r1, [pc, #100]	; (8003910 <xTaskPriorityInherit+0xa8>)
 80038ac:	680a      	ldr	r2, [r1, #0]
 80038ae:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 80038b0:	2301      	movs	r3, #1
 80038b2:	4083      	lsls	r3, r0
 80038b4:	ea22 0303 	bic.w	r3, r2, r3
 80038b8:	600b      	str	r3, [r1, #0]
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Inherit the priority before being moved into the new list. */
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 80038ba:	4b13      	ldr	r3, [pc, #76]	; (8003908 <xTaskPriorityInherit+0xa0>)
 80038bc:	681b      	ldr	r3, [r3, #0]
 80038be:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 80038c0:	62e0      	str	r0, [r4, #44]	; 0x2c
                    prvAddTaskToReadyList( pxMutexHolderTCB );
 80038c2:	4a13      	ldr	r2, [pc, #76]	; (8003910 <xTaskPriorityInherit+0xa8>)
 80038c4:	6813      	ldr	r3, [r2, #0]
 80038c6:	2401      	movs	r4, #1
 80038c8:	fa04 f100 	lsl.w	r1, r4, r0
 80038cc:	430b      	orrs	r3, r1
 80038ce:	6013      	str	r3, [r2, #0]
 80038d0:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80038d4:	4b0d      	ldr	r3, [pc, #52]	; (800390c <xTaskPriorityInherit+0xa4>)
 80038d6:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 80038da:	4629      	mov	r1, r5
 80038dc:	f7fe fd16 	bl	800230c <vListInsertEnd>
                }

                traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

                /* Inheritance occurred. */
                xReturn = pdTRUE;
 80038e0:	4620      	mov	r0, r4
 80038e2:	bd38      	pop	{r3, r4, r5, pc}
                    prvAddTaskToReadyList( pxMutexHolderTCB );
                }
                else
                {
                    /* Just inherit the priority. */
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 80038e4:	4a08      	ldr	r2, [pc, #32]	; (8003908 <xTaskPriorityInherit+0xa0>)
 80038e6:	6812      	ldr	r2, [r2, #0]
 80038e8:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 80038ea:	62da      	str	r2, [r3, #44]	; 0x2c
                }

                traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

                /* Inheritance occurred. */
                xReturn = pdTRUE;
 80038ec:	2001      	movs	r0, #1
 80038ee:	bd38      	pop	{r3, r4, r5, pc}
            }
            else
            {
                if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
 80038f0:	4a05      	ldr	r2, [pc, #20]	; (8003908 <xTaskPriorityInherit+0xa0>)
 80038f2:	6812      	ldr	r2, [r2, #0]
 80038f4:	6d03      	ldr	r3, [r0, #80]	; 0x50
 80038f6:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
 80038f8:	4283      	cmp	r3, r0
 80038fa:	bf2c      	ite	cs
 80038fc:	2000      	movcs	r0, #0
 80038fe:	2001      	movcc	r0, #1
 8003900:	bd38      	pop	{r3, r4, r5, pc}
#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
    {
        TCB_t * const pxMutexHolderTCB = pxMutexHolder;
        BaseType_t xReturn = pdFALSE;
 8003902:	2000      	movs	r0, #0
 8003904:	4770      	bx	lr
 8003906:	bf00      	nop
 8003908:	200008fc 	.word	0x200008fc
 800390c:	20000830 	.word	0x20000830
 8003910:	20000968 	.word	0x20000968

08003914 <xTaskPriorityDisinherit>:
    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
        TCB_t * const pxTCB = pxMutexHolder;
        BaseType_t xReturn = pdFALSE;

        if( pxMutexHolder != NULL )
 8003914:	2800      	cmp	r0, #0
 8003916:	d044      	beq.n	80039a2 <xTaskPriorityDisinherit+0x8e>
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
 8003918:	b538      	push	{r3, r4, r5, lr}
 800391a:	4603      	mov	r3, r0
        {
            /* A task can only have an inherited priority if it holds the mutex.
             * If the mutex is held by a task then it cannot be given from an
             * interrupt, and if a mutex is given by the holding task then it must
             * be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
 800391c:	4a24      	ldr	r2, [pc, #144]	; (80039b0 <xTaskPriorityDisinherit+0x9c>)
 800391e:	6812      	ldr	r2, [r2, #0]
 8003920:	4290      	cmp	r0, r2
 8003922:	d008      	beq.n	8003936 <xTaskPriorityDisinherit+0x22>
 8003924:	f04f 0314 	mov.w	r3, #20
 8003928:	f383 8811 	msr	BASEPRI, r3
 800392c:	f3bf 8f6f 	isb	sy
 8003930:	f3bf 8f4f 	dsb	sy
 8003934:	e7fe      	b.n	8003934 <xTaskPriorityDisinherit+0x20>
            configASSERT( pxTCB->uxMutexesHeld );
 8003936:	6d42      	ldr	r2, [r0, #84]	; 0x54
 8003938:	b942      	cbnz	r2, 800394c <xTaskPriorityDisinherit+0x38>
 800393a:	f04f 0314 	mov.w	r3, #20
 800393e:	f383 8811 	msr	BASEPRI, r3
 8003942:	f3bf 8f6f 	isb	sy
 8003946:	f3bf 8f4f 	dsb	sy
 800394a:	e7fe      	b.n	800394a <xTaskPriorityDisinherit+0x36>
            ( pxTCB->uxMutexesHeld )--;
 800394c:	3a01      	subs	r2, #1
 800394e:	6542      	str	r2, [r0, #84]	; 0x54

            /* Has the holder of the mutex inherited the priority of another
             * task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8003950:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 8003952:	6d19      	ldr	r1, [r3, #80]	; 0x50
 8003954:	4288      	cmp	r0, r1
 8003956:	d026      	beq.n	80039a6 <xTaskPriorityDisinherit+0x92>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 8003958:	bb3a      	cbnz	r2, 80039aa <xTaskPriorityDisinherit+0x96>
 800395a:	461c      	mov	r4, r3
                    /* A task can only have an inherited priority if it holds
                     * the mutex.  If the mutex is held by a task then it cannot be
                     * given from an interrupt, and if a mutex is given by the
                     * holding task then it must be the running state task.  Remove
                     * the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800395c:	1d1d      	adds	r5, r3, #4
 800395e:	4628      	mov	r0, r5
 8003960:	f7fe fcfa 	bl	8002358 <uxListRemove>
 8003964:	b938      	cbnz	r0, 8003976 <xTaskPriorityDisinherit+0x62>
                    {
                        portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
 8003966:	4913      	ldr	r1, [pc, #76]	; (80039b4 <xTaskPriorityDisinherit+0xa0>)
 8003968:	680b      	ldr	r3, [r1, #0]
 800396a:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 800396c:	2201      	movs	r2, #1
 800396e:	4082      	lsls	r2, r0
 8003970:	ea23 0302 	bic.w	r3, r3, r2
 8003974:	600b      	str	r3, [r1, #0]
                    }

                    /* Disinherit the priority before adding the task into the
                     * new  ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
 8003976:	6d20      	ldr	r0, [r4, #80]	; 0x50
 8003978:	62e0      	str	r0, [r4, #44]	; 0x2c

                    /* Reset the event list item value.  It cannot be in use for
                     * any other purpose if this task is running, and it must be
                     * running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800397a:	f1c0 030a 	rsb	r3, r0, #10
 800397e:	61a3      	str	r3, [r4, #24]
                    prvAddTaskToReadyList( pxTCB );
 8003980:	4a0c      	ldr	r2, [pc, #48]	; (80039b4 <xTaskPriorityDisinherit+0xa0>)
 8003982:	6813      	ldr	r3, [r2, #0]
 8003984:	2401      	movs	r4, #1
 8003986:	fa04 f100 	lsl.w	r1, r4, r0
 800398a:	430b      	orrs	r3, r1
 800398c:	6013      	str	r3, [r2, #0]
 800398e:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8003992:	4b09      	ldr	r3, [pc, #36]	; (80039b8 <xTaskPriorityDisinherit+0xa4>)
 8003994:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8003998:	4629      	mov	r1, r5
 800399a:	f7fe fcb7 	bl	800230c <vListInsertEnd>
                     * in an order different to that in which they were taken.
                     * If a context switch did not occur when the first mutex was
                     * returned, even if a task was waiting on it, then a context
                     * switch should occur when the last mutex is returned whether
                     * a task is waiting on it or not. */
                    xReturn = pdTRUE;
 800399e:	4620      	mov	r0, r4
 80039a0:	bd38      	pop	{r3, r4, r5, pc}
#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
        TCB_t * const pxTCB = pxMutexHolder;
        BaseType_t xReturn = pdFALSE;
 80039a2:	2000      	movs	r0, #0
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
 80039a4:	4770      	bx	lr
#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
        TCB_t * const pxTCB = pxMutexHolder;
        BaseType_t xReturn = pdFALSE;
 80039a6:	2000      	movs	r0, #0
 80039a8:	bd38      	pop	{r3, r4, r5, pc}
 80039aa:	2000      	movs	r0, #0
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
 80039ac:	bd38      	pop	{r3, r4, r5, pc}
 80039ae:	bf00      	nop
 80039b0:	200008fc 	.word	0x200008fc
 80039b4:	20000968 	.word	0x20000968
 80039b8:	20000830 	.word	0x20000830

080039bc <vTaskPriorityDisinheritAfterTimeout>:
    {
        TCB_t * const pxTCB = pxMutexHolder;
        UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
        const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;

        if( pxMutexHolder != NULL )
 80039bc:	2800      	cmp	r0, #0
 80039be:	d04f      	beq.n	8003a60 <vTaskPriorityDisinheritAfterTimeout+0xa4>

#if ( configUSE_MUTEXES == 1 )

    void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder,
                                              UBaseType_t uxHighestPriorityWaitingTask )
    {
 80039c0:	b538      	push	{r3, r4, r5, lr}
 80039c2:	4603      	mov	r3, r0

        if( pxMutexHolder != NULL )
        {
            /* If pxMutexHolder is not NULL then the holder must hold at least
             * one mutex. */
            configASSERT( pxTCB->uxMutexesHeld );
 80039c4:	6d40      	ldr	r0, [r0, #84]	; 0x54
 80039c6:	b940      	cbnz	r0, 80039da <vTaskPriorityDisinheritAfterTimeout+0x1e>
 80039c8:	f04f 0314 	mov.w	r3, #20
 80039cc:	f383 8811 	msr	BASEPRI, r3
 80039d0:	f3bf 8f6f 	isb	sy
 80039d4:	f3bf 8f4f 	dsb	sy
 80039d8:	e7fe      	b.n	80039d8 <vTaskPriorityDisinheritAfterTimeout+0x1c>

            /* Determine the priority to which the priority of the task that
             * holds the mutex should be set.  This will be the greater of the
             * holding task's base priority and the priority of the highest
             * priority task that is waiting to obtain the mutex. */
            if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
 80039da:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 80039dc:	428a      	cmp	r2, r1
 80039de:	bf38      	it	cc
 80039e0:	460a      	movcc	r2, r1
            {
                uxPriorityToUse = pxTCB->uxBasePriority;
            }

            /* Does the priority need to change? */
            if( pxTCB->uxPriority != uxPriorityToUse )
 80039e2:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 80039e4:	4291      	cmp	r1, r2
 80039e6:	d03a      	beq.n	8003a5e <vTaskPriorityDisinheritAfterTimeout+0xa2>
            {
                /* Only disinherit if no other mutexes are held.  This is a
                 * simplification in the priority inheritance implementation.  If
                 * the task that holds the mutex is also holding other mutexes then
                 * the other mutexes may have caused the priority inheritance. */
                if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
 80039e8:	2801      	cmp	r0, #1
 80039ea:	d138      	bne.n	8003a5e <vTaskPriorityDisinheritAfterTimeout+0xa2>
                {
                    /* If a task has timed out because it already holds the
                     * mutex it was trying to obtain then it cannot of inherited
                     * its own priority. */
                    configASSERT( pxTCB != pxCurrentTCB );
 80039ec:	481d      	ldr	r0, [pc, #116]	; (8003a64 <vTaskPriorityDisinheritAfterTimeout+0xa8>)
 80039ee:	6800      	ldr	r0, [r0, #0]
 80039f0:	4283      	cmp	r3, r0
 80039f2:	d108      	bne.n	8003a06 <vTaskPriorityDisinheritAfterTimeout+0x4a>
 80039f4:	f04f 0314 	mov.w	r3, #20
 80039f8:	f383 8811 	msr	BASEPRI, r3
 80039fc:	f3bf 8f6f 	isb	sy
 8003a00:	f3bf 8f4f 	dsb	sy
 8003a04:	e7fe      	b.n	8003a04 <vTaskPriorityDisinheritAfterTimeout+0x48>
                    /* Disinherit the priority, remembering the previous
                     * priority to facilitate determining the subject task's
                     * state. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, uxPriorityToUse );
                    uxPriorityUsedOnEntry = pxTCB->uxPriority;
                    pxTCB->uxPriority = uxPriorityToUse;
 8003a06:	62da      	str	r2, [r3, #44]	; 0x2c

                    /* Only reset the event list item value if the value is not
                     * being used for anything else. */
                    if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8003a08:	6998      	ldr	r0, [r3, #24]
 8003a0a:	2800      	cmp	r0, #0
                    {
                        listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8003a0c:	bfa4      	itt	ge
 8003a0e:	f1c2 020a 	rsbge	r2, r2, #10
 8003a12:	619a      	strge	r2, [r3, #24]
                     * then the task that holds the mutex could be in either the
                     * Ready, Blocked or Suspended states.  Only remove the task
                     * from its current state list if it is in the Ready state as
                     * the task's priority is going to change and there is one
                     * Ready list per priority. */
                    if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 8003a14:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 8003a18:	4a13      	ldr	r2, [pc, #76]	; (8003a68 <vTaskPriorityDisinheritAfterTimeout+0xac>)
 8003a1a:	eb02 0181 	add.w	r1, r2, r1, lsl #2
 8003a1e:	695a      	ldr	r2, [r3, #20]
 8003a20:	428a      	cmp	r2, r1
 8003a22:	d11c      	bne.n	8003a5e <vTaskPriorityDisinheritAfterTimeout+0xa2>
 8003a24:	461c      	mov	r4, r3
                    {
                        if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8003a26:	1d1d      	adds	r5, r3, #4
 8003a28:	4628      	mov	r0, r5
 8003a2a:	f7fe fc95 	bl	8002358 <uxListRemove>
 8003a2e:	b938      	cbnz	r0, 8003a40 <vTaskPriorityDisinheritAfterTimeout+0x84>
                        {
                            /* It is known that the task is in its ready list so
                             * there is no need to check again and the port level
                             * reset macro can be called directly. */
                            portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
 8003a30:	490e      	ldr	r1, [pc, #56]	; (8003a6c <vTaskPriorityDisinheritAfterTimeout+0xb0>)
 8003a32:	680b      	ldr	r3, [r1, #0]
 8003a34:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8003a36:	2201      	movs	r2, #1
 8003a38:	4082      	lsls	r2, r0
 8003a3a:	ea23 0302 	bic.w	r3, r3, r2
 8003a3e:	600b      	str	r3, [r1, #0]
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }

                        prvAddTaskToReadyList( pxTCB );
 8003a40:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8003a42:	490a      	ldr	r1, [pc, #40]	; (8003a6c <vTaskPriorityDisinheritAfterTimeout+0xb0>)
 8003a44:	680b      	ldr	r3, [r1, #0]
 8003a46:	2201      	movs	r2, #1
 8003a48:	4082      	lsls	r2, r0
 8003a4a:	4313      	orrs	r3, r2
 8003a4c:	600b      	str	r3, [r1, #0]
 8003a4e:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8003a52:	4b05      	ldr	r3, [pc, #20]	; (8003a68 <vTaskPriorityDisinheritAfterTimeout+0xac>)
 8003a54:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8003a58:	4629      	mov	r1, r5
 8003a5a:	f7fe fc57 	bl	800230c <vListInsertEnd>
 8003a5e:	bd38      	pop	{r3, r4, r5, pc}
 8003a60:	4770      	bx	lr
 8003a62:	bf00      	nop
 8003a64:	200008fc 	.word	0x200008fc
 8003a68:	20000830 	.word	0x20000830
 8003a6c:	20000968 	.word	0x20000968

08003a70 <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 8003a70:	4b04      	ldr	r3, [pc, #16]	; (8003a84 <uxTaskResetEventItemValue+0x14>)
 8003a72:	681a      	ldr	r2, [r3, #0]
 8003a74:	6990      	ldr	r0, [r2, #24]

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8003a76:	681a      	ldr	r2, [r3, #0]
 8003a78:	681b      	ldr	r3, [r3, #0]
 8003a7a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003a7c:	f1c3 030a 	rsb	r3, r3, #10
 8003a80:	6193      	str	r3, [r2, #24]

    return uxReturn;
}
 8003a82:	4770      	bx	lr
 8003a84:	200008fc 	.word	0x200008fc

08003a88 <pvTaskIncrementMutexHeldCount>:

    TaskHandle_t pvTaskIncrementMutexHeldCount( void )
    {
        /* If xSemaphoreCreateMutex() is called before any tasks have been created
         * then pxCurrentTCB will be NULL. */
        if( pxCurrentTCB != NULL )
 8003a88:	4b05      	ldr	r3, [pc, #20]	; (8003aa0 <pvTaskIncrementMutexHeldCount+0x18>)
 8003a8a:	681b      	ldr	r3, [r3, #0]
 8003a8c:	b123      	cbz	r3, 8003a98 <pvTaskIncrementMutexHeldCount+0x10>
        {
            ( pxCurrentTCB->uxMutexesHeld )++;
 8003a8e:	4b04      	ldr	r3, [pc, #16]	; (8003aa0 <pvTaskIncrementMutexHeldCount+0x18>)
 8003a90:	681a      	ldr	r2, [r3, #0]
 8003a92:	6d53      	ldr	r3, [r2, #84]	; 0x54
 8003a94:	3301      	adds	r3, #1
 8003a96:	6553      	str	r3, [r2, #84]	; 0x54
        }

        return pxCurrentTCB;
 8003a98:	4b01      	ldr	r3, [pc, #4]	; (8003aa0 <pvTaskIncrementMutexHeldCount+0x18>)
 8003a9a:	6818      	ldr	r0, [r3, #0]
    }
 8003a9c:	4770      	bx	lr
 8003a9e:	bf00      	nop
 8003aa0:	200008fc 	.word	0x200008fc

08003aa4 <prvInsertTimerInActiveList>:

    static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer,
                                                  const TickType_t xNextExpiryTime,
                                                  const TickType_t xTimeNow,
                                                  const TickType_t xCommandTime )
    {
 8003aa4:	b510      	push	{r4, lr}
 8003aa6:	4604      	mov	r4, r0
        BaseType_t xProcessTimerNow = pdFALSE;

        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 8003aa8:	6041      	str	r1, [r0, #4]
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8003aaa:	6120      	str	r0, [r4, #16]

        if( xNextExpiryTime <= xTimeNow )
 8003aac:	4291      	cmp	r1, r2
 8003aae:	d80a      	bhi.n	8003ac6 <prvInsertTimerInActiveList+0x22>
        {
            /* Has the expiry time elapsed between the command to start/reset a
             * timer was issued, and the time the command was processed? */
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8003ab0:	1ad2      	subs	r2, r2, r3
 8003ab2:	6983      	ldr	r3, [r0, #24]
 8003ab4:	429a      	cmp	r2, r3
 8003ab6:	d211      	bcs.n	8003adc <prvInsertTimerInActiveList+0x38>
                 * processed actually exceeds the timers period.  */
                xProcessTimerNow = pdTRUE;
            }
            else
            {
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 8003ab8:	4b0a      	ldr	r3, [pc, #40]	; (8003ae4 <prvInsertTimerInActiveList+0x40>)
 8003aba:	6818      	ldr	r0, [r3, #0]
 8003abc:	1d21      	adds	r1, r4, #4
 8003abe:	f7fe fc31 	bl	8002324 <vListInsert>
    static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer,
                                                  const TickType_t xNextExpiryTime,
                                                  const TickType_t xTimeNow,
                                                  const TickType_t xCommandTime )
    {
        BaseType_t xProcessTimerNow = pdFALSE;
 8003ac2:	2000      	movs	r0, #0
 8003ac4:	bd10      	pop	{r4, pc}
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
            }
        }
        else
        {
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 8003ac6:	429a      	cmp	r2, r3
 8003ac8:	d201      	bcs.n	8003ace <prvInsertTimerInActiveList+0x2a>
 8003aca:	4299      	cmp	r1, r3
 8003acc:	d208      	bcs.n	8003ae0 <prvInsertTimerInActiveList+0x3c>
                 * its expiry time and should be processed immediately. */
                xProcessTimerNow = pdTRUE;
            }
            else
            {
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8003ace:	4b06      	ldr	r3, [pc, #24]	; (8003ae8 <prvInsertTimerInActiveList+0x44>)
 8003ad0:	6818      	ldr	r0, [r3, #0]
 8003ad2:	1d21      	adds	r1, r4, #4
 8003ad4:	f7fe fc26 	bl	8002324 <vListInsert>
    static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer,
                                                  const TickType_t xNextExpiryTime,
                                                  const TickType_t xTimeNow,
                                                  const TickType_t xCommandTime )
    {
        BaseType_t xProcessTimerNow = pdFALSE;
 8003ad8:	2000      	movs	r0, #0
 8003ada:	bd10      	pop	{r4, pc}
             * timer was issued, and the time the command was processed? */
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
            {
                /* The time between a command being issued and the command being
                 * processed actually exceeds the timers period.  */
                xProcessTimerNow = pdTRUE;
 8003adc:	2001      	movs	r0, #1
 8003ade:	bd10      	pop	{r4, pc}
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
            {
                /* If, since the command was issued, the tick count has overflowed
                 * but the expiry time has not, then the timer must have already passed
                 * its expiry time and should be processed immediately. */
                xProcessTimerNow = pdTRUE;
 8003ae0:	2001      	movs	r0, #1
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
            }
        }

        return xProcessTimerNow;
    }
 8003ae2:	bd10      	pop	{r4, pc}
 8003ae4:	200009a0 	.word	0x200009a0
 8003ae8:	20000970 	.word	0x20000970

08003aec <prvCheckForValidListAndQueue>:
        pxOverflowTimerList = pxTemp;
    }
/*-----------------------------------------------------------*/

    static void prvCheckForValidListAndQueue( void )
    {
 8003aec:	b538      	push	{r3, r4, r5, lr}
        /* Check that the list from which active timers are referenced, and the
         * queue used to communicate with the timer service, have been
         * initialised. */
        taskENTER_CRITICAL();
 8003aee:	f7fe f967 	bl	8001dc0 <vPortEnterCritical>
        {
            if( xTimerQueue == NULL )
 8003af2:	4b0e      	ldr	r3, [pc, #56]	; (8003b2c <prvCheckForValidListAndQueue+0x40>)
 8003af4:	681b      	ldr	r3, [r3, #0]
 8003af6:	b9b3      	cbnz	r3, 8003b26 <prvCheckForValidListAndQueue+0x3a>
            {
                vListInitialise( &xActiveTimerList1 );
 8003af8:	4d0d      	ldr	r5, [pc, #52]	; (8003b30 <prvCheckForValidListAndQueue+0x44>)
 8003afa:	4628      	mov	r0, r5
 8003afc:	f7fe fbf6 	bl	80022ec <vListInitialise>
                vListInitialise( &xActiveTimerList2 );
 8003b00:	4c0c      	ldr	r4, [pc, #48]	; (8003b34 <prvCheckForValidListAndQueue+0x48>)
 8003b02:	4620      	mov	r0, r4
 8003b04:	f7fe fbf2 	bl	80022ec <vListInitialise>
                pxCurrentTimerList = &xActiveTimerList1;
 8003b08:	4b0b      	ldr	r3, [pc, #44]	; (8003b38 <prvCheckForValidListAndQueue+0x4c>)
 8003b0a:	601d      	str	r5, [r3, #0]
                pxOverflowTimerList = &xActiveTimerList2;
 8003b0c:	4b0b      	ldr	r3, [pc, #44]	; (8003b3c <prvCheckForValidListAndQueue+0x50>)
 8003b0e:	601c      	str	r4, [r3, #0]

                        xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
                    }
                #else
                    {
                        xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 8003b10:	2005      	movs	r0, #5
 8003b12:	210c      	movs	r1, #12
 8003b14:	2200      	movs	r2, #0
 8003b16:	f7fe fd0f 	bl	8002538 <xQueueGenericCreate>
 8003b1a:	4b04      	ldr	r3, [pc, #16]	; (8003b2c <prvCheckForValidListAndQueue+0x40>)
 8003b1c:	6018      	str	r0, [r3, #0]
                    }
                #endif /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */

                #if ( configQUEUE_REGISTRY_SIZE > 0 )
                    {
                        if( xTimerQueue != NULL )
 8003b1e:	b110      	cbz	r0, 8003b26 <prvCheckForValidListAndQueue+0x3a>
                        {
                            vQueueAddToRegistry( xTimerQueue, "TmrQ" );
 8003b20:	4907      	ldr	r1, [pc, #28]	; (8003b40 <prvCheckForValidListAndQueue+0x54>)
 8003b22:	f7ff f89b 	bl	8002c5c <vQueueAddToRegistry>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
 8003b26:	f7fe f96d 	bl	8001e04 <vPortExitCritical>
 8003b2a:	bd38      	pop	{r3, r4, r5, pc}
 8003b2c:	2000099c 	.word	0x2000099c
 8003b30:	20000974 	.word	0x20000974
 8003b34:	20000988 	.word	0x20000988
 8003b38:	20000970 	.word	0x20000970
 8003b3c:	200009a0 	.word	0x200009a0
 8003b40:	0800ab50 	.word	0x0800ab50

08003b44 <xTimerCreateTimerTask>:
                                       TimerCallbackFunction_t pxCallbackFunction,
                                       Timer_t * pxNewTimer ) PRIVILEGED_FUNCTION;
/*-----------------------------------------------------------*/

    BaseType_t xTimerCreateTimerTask( void )
    {
 8003b44:	b500      	push	{lr}
 8003b46:	b083      	sub	sp, #12

        /* This function is called when the scheduler is started if
         * configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
         * timer service task has been created/initialised.  If timers have already
         * been created then the initialisation will already have been performed. */
        prvCheckForValidListAndQueue();
 8003b48:	f7ff ffd0 	bl	8003aec <prvCheckForValidListAndQueue>

        if( xTimerQueue != NULL )
 8003b4c:	4b0c      	ldr	r3, [pc, #48]	; (8003b80 <xTimerCreateTimerTask+0x3c>)
 8003b4e:	681b      	ldr	r3, [r3, #0]
 8003b50:	b153      	cbz	r3, 8003b68 <xTimerCreateTimerTask+0x24>
                        xReturn = pdPASS;
                    }
                }
            #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
                {
                    xReturn = xTaskCreate( prvTimerTask,
 8003b52:	2301      	movs	r3, #1
 8003b54:	9300      	str	r3, [sp, #0]
 8003b56:	4b0b      	ldr	r3, [pc, #44]	; (8003b84 <xTimerCreateTimerTask+0x40>)
 8003b58:	9301      	str	r3, [sp, #4]
 8003b5a:	480b      	ldr	r0, [pc, #44]	; (8003b88 <xTimerCreateTimerTask+0x44>)
 8003b5c:	490b      	ldr	r1, [pc, #44]	; (8003b8c <xTimerCreateTimerTask+0x48>)
 8003b5e:	22f0      	movs	r2, #240	; 0xf0
 8003b60:	2300      	movs	r3, #0
 8003b62:	f7ff f97f 	bl	8002e64 <xTaskCreate>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        configASSERT( xReturn );
 8003b66:	b940      	cbnz	r0, 8003b7a <xTimerCreateTimerTask+0x36>
 8003b68:	f04f 0314 	mov.w	r3, #20
 8003b6c:	f383 8811 	msr	BASEPRI, r3
 8003b70:	f3bf 8f6f 	isb	sy
 8003b74:	f3bf 8f4f 	dsb	sy
 8003b78:	e7fe      	b.n	8003b78 <xTimerCreateTimerTask+0x34>
        return xReturn;
    }
 8003b7a:	b003      	add	sp, #12
 8003b7c:	f85d fb04 	ldr.w	pc, [sp], #4
 8003b80:	2000099c 	.word	0x2000099c
 8003b84:	200009a4 	.word	0x200009a4
 8003b88:	08003ca1 	.word	0x08003ca1
 8003b8c:	0800ab58 	.word	0x0800ab58

08003b90 <xTimerGenericCommand>:
                                     const TickType_t xTicksToWait )
    {
        BaseType_t xReturn = pdFAIL;
        DaemonTaskMessage_t xMessage;

        configASSERT( xTimer );
 8003b90:	b940      	cbnz	r0, 8003ba4 <xTimerGenericCommand+0x14>
 8003b92:	f04f 0314 	mov.w	r3, #20
 8003b96:	f383 8811 	msr	BASEPRI, r3
 8003b9a:	f3bf 8f6f 	isb	sy
 8003b9e:	f3bf 8f4f 	dsb	sy
 8003ba2:	e7fe      	b.n	8003ba2 <xTimerGenericCommand+0x12>
    BaseType_t xTimerGenericCommand( TimerHandle_t xTimer,
                                     const BaseType_t xCommandID,
                                     const TickType_t xOptionalValue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const TickType_t xTicksToWait )
    {
 8003ba4:	b530      	push	{r4, r5, lr}
 8003ba6:	b085      	sub	sp, #20
 8003ba8:	4615      	mov	r5, r2
 8003baa:	4604      	mov	r4, r0

        configASSERT( xTimer );

        /* Send a message to the timer service task to perform a particular action
         * on a particular timer definition. */
        if( xTimerQueue != NULL )
 8003bac:	4a0f      	ldr	r2, [pc, #60]	; (8003bec <xTimerGenericCommand+0x5c>)
 8003bae:	6810      	ldr	r0, [r2, #0]
 8003bb0:	b1c0      	cbz	r0, 8003be4 <xTimerGenericCommand+0x54>
 8003bb2:	461a      	mov	r2, r3
        {
            /* Send a command to the timer service task to start the xTimer timer. */
            xMessage.xMessageID = xCommandID;
 8003bb4:	9101      	str	r1, [sp, #4]
            xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 8003bb6:	9502      	str	r5, [sp, #8]
            xMessage.u.xTimerParameters.pxTimer = xTimer;
 8003bb8:	9403      	str	r4, [sp, #12]

            if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 8003bba:	2905      	cmp	r1, #5
 8003bbc:	dc0d      	bgt.n	8003bda <xTimerGenericCommand+0x4a>
            {
                if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 8003bbe:	f7ff fe43 	bl	8003848 <xTaskGetSchedulerState>
 8003bc2:	2802      	cmp	r0, #2
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 8003bc4:	4b09      	ldr	r3, [pc, #36]	; (8003bec <xTimerGenericCommand+0x5c>)
 8003bc6:	6818      	ldr	r0, [r3, #0]
 8003bc8:	a901      	add	r1, sp, #4
 8003bca:	bf07      	ittee	eq
 8003bcc:	9a08      	ldreq	r2, [sp, #32]
 8003bce:	2300      	moveq	r3, #0
                }
                else
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 8003bd0:	2200      	movne	r2, #0
 8003bd2:	4613      	movne	r3, r2
 8003bd4:	f7fe fd0c 	bl	80025f0 <xQueueGenericSend>
 8003bd8:	e005      	b.n	8003be6 <xTimerGenericCommand+0x56>
                }
            }
            else
            {
                xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 8003bda:	a901      	add	r1, sp, #4
 8003bdc:	2300      	movs	r3, #0
 8003bde:	f7fe fddd 	bl	800279c <xQueueGenericSendFromISR>
 8003be2:	e000      	b.n	8003be6 <xTimerGenericCommand+0x56>
                                     const BaseType_t xCommandID,
                                     const TickType_t xOptionalValue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const TickType_t xTicksToWait )
    {
        BaseType_t xReturn = pdFAIL;
 8003be4:	2000      	movs	r0, #0
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
 8003be6:	b005      	add	sp, #20
 8003be8:	bd30      	pop	{r4, r5, pc}
 8003bea:	bf00      	nop
 8003bec:	2000099c 	.word	0x2000099c

08003bf0 <prvSampleTimeNow>:
        return xNextExpireTime;
    }
/*-----------------------------------------------------------*/

    static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
    {
 8003bf0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8003bf4:	b082      	sub	sp, #8
 8003bf6:	4607      	mov	r7, r0
        TickType_t xTimeNow;
        PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

        xTimeNow = xTaskGetTickCount();
 8003bf8:	f7ff fae0 	bl	80031bc <xTaskGetTickCount>
 8003bfc:	4606      	mov	r6, r0

        if( xTimeNow < xLastTime )
 8003bfe:	4b25      	ldr	r3, [pc, #148]	; (8003c94 <prvSampleTimeNow+0xa4>)
 8003c00:	681b      	ldr	r3, [r3, #0]
 8003c02:	4298      	cmp	r0, r3
 8003c04:	d23d      	bcs.n	8003c82 <prvSampleTimeNow+0x92>
 8003c06:	e02d      	b.n	8003c64 <prvSampleTimeNow+0x74>
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8003c08:	68db      	ldr	r3, [r3, #12]
 8003c0a:	f8d3 a000 	ldr.w	sl, [r3]

            /* Remove the timer from the list. */
            pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8003c0e:	68dc      	ldr	r4, [r3, #12]
            ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8003c10:	f104 0904 	add.w	r9, r4, #4
 8003c14:	4648      	mov	r0, r9
 8003c16:	f7fe fb9f 	bl	8002358 <uxListRemove>
            traceTIMER_EXPIRED( pxTimer );

            /* Execute its callback, then send a command to restart the timer if
             * it is an auto-reload timer.  It cannot be restarted here as the lists
             * have not yet been switched. */
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8003c1a:	6a23      	ldr	r3, [r4, #32]
 8003c1c:	4620      	mov	r0, r4
 8003c1e:	4798      	blx	r3

            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 8003c20:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 8003c24:	f013 0f04 	tst.w	r3, #4
 8003c28:	d01f      	beq.n	8003c6a <prvSampleTimeNow+0x7a>
                 * the timer going into the same timer list then it has already expired
                 * and the timer should be re-inserted into the current list so it is
                 * processed again within this loop.  Otherwise a command should be sent
                 * to restart the timer to ensure it is only inserted into a list after
                 * the lists have been swapped. */
                xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 8003c2a:	69a3      	ldr	r3, [r4, #24]
 8003c2c:	4453      	add	r3, sl

                if( xReloadTime > xNextExpireTime )
 8003c2e:	4553      	cmp	r3, sl
 8003c30:	d906      	bls.n	8003c40 <prvSampleTimeNow+0x50>
                {
                    listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 8003c32:	6063      	str	r3, [r4, #4]
                    listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8003c34:	6124      	str	r4, [r4, #16]
                    vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8003c36:	6828      	ldr	r0, [r5, #0]
 8003c38:	4649      	mov	r1, r9
 8003c3a:	f7fe fb73 	bl	8002324 <vListInsert>
 8003c3e:	e014      	b.n	8003c6a <prvSampleTimeNow+0x7a>
                }
                else
                {
                    xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 8003c40:	f8cd 8000 	str.w	r8, [sp]
 8003c44:	4620      	mov	r0, r4
 8003c46:	4641      	mov	r1, r8
 8003c48:	4652      	mov	r2, sl
 8003c4a:	4643      	mov	r3, r8
 8003c4c:	f7ff ffa0 	bl	8003b90 <xTimerGenericCommand>
                    configASSERT( xResult );
 8003c50:	b958      	cbnz	r0, 8003c6a <prvSampleTimeNow+0x7a>
 8003c52:	f04f 0314 	mov.w	r3, #20
 8003c56:	f383 8811 	msr	BASEPRI, r3
 8003c5a:	f3bf 8f6f 	isb	sy
 8003c5e:	f3bf 8f4f 	dsb	sy
 8003c62:	e7fe      	b.n	8003c62 <prvSampleTimeNow+0x72>

        /* The tick count has overflowed.  The timer lists must be switched.
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 8003c64:	4d0c      	ldr	r5, [pc, #48]	; (8003c98 <prvSampleTimeNow+0xa8>)
                    listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
                    vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
                }
                else
                {
                    xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 8003c66:	f04f 0800 	mov.w	r8, #0

        /* The tick count has overflowed.  The timer lists must be switched.
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 8003c6a:	682b      	ldr	r3, [r5, #0]
 8003c6c:	681a      	ldr	r2, [r3, #0]
 8003c6e:	2a00      	cmp	r2, #0
 8003c70:	d1ca      	bne.n	8003c08 <prvSampleTimeNow+0x18>
                mtCOVERAGE_TEST_MARKER();
            }
        }

        pxTemp = pxCurrentTimerList;
        pxCurrentTimerList = pxOverflowTimerList;
 8003c72:	4a0a      	ldr	r2, [pc, #40]	; (8003c9c <prvSampleTimeNow+0xac>)
 8003c74:	6810      	ldr	r0, [r2, #0]
 8003c76:	4908      	ldr	r1, [pc, #32]	; (8003c98 <prvSampleTimeNow+0xa8>)
 8003c78:	6008      	str	r0, [r1, #0]
        pxOverflowTimerList = pxTemp;
 8003c7a:	6013      	str	r3, [r2, #0]
        xTimeNow = xTaskGetTickCount();

        if( xTimeNow < xLastTime )
        {
            prvSwitchTimerLists();
            *pxTimerListsWereSwitched = pdTRUE;
 8003c7c:	2301      	movs	r3, #1
 8003c7e:	603b      	str	r3, [r7, #0]
 8003c80:	e001      	b.n	8003c86 <prvSampleTimeNow+0x96>
        }
        else
        {
            *pxTimerListsWereSwitched = pdFALSE;
 8003c82:	2300      	movs	r3, #0
 8003c84:	603b      	str	r3, [r7, #0]
        }

        xLastTime = xTimeNow;
 8003c86:	4b03      	ldr	r3, [pc, #12]	; (8003c94 <prvSampleTimeNow+0xa4>)
 8003c88:	601e      	str	r6, [r3, #0]

        return xTimeNow;
    }
 8003c8a:	4630      	mov	r0, r6
 8003c8c:	b002      	add	sp, #8
 8003c8e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8003c92:	bf00      	nop
 8003c94:	200009a8 	.word	0x200009a8
 8003c98:	20000970 	.word	0x20000970
 8003c9c:	200009a0 	.word	0x200009a0

08003ca0 <prvTimerTask>:
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    }
/*-----------------------------------------------------------*/

    static portTASK_FUNCTION( prvTimerTask, pvParameters )
    {
 8003ca0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8003ca4:	b086      	sub	sp, #24
         * the timer with the nearest expiry time will expire.  If there are no
         * active timers then just set the next expire time to 0.  That will cause
         * this task to unblock when the tick count overflows, at which point the
         * timer lists will be switched and the next expiry time can be
         * re-assessed.  */
        *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 8003ca6:	4e73      	ldr	r6, [pc, #460]	; (8003e74 <prvTimerTask+0x1d4>)
                        /* The current timer list is empty - is the overflow list
                         * also empty? */
                        xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
                    }

                    vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
 8003ca8:	4d73      	ldr	r5, [pc, #460]	; (8003e78 <prvTimerTask+0x1d8>)
                    {
                        /* Yield to wait for either a command to arrive, or the
                         * block time to expire.  If a command arrived between the
                         * critical section being exited and this yield then the yield
                         * will not cause the task to block. */
                        portYIELD_WITHIN_API();
 8003caa:	f8df 81d4 	ldr.w	r8, [pc, #468]	; 8003e80 <prvTimerTask+0x1e0>
                     * case when the current timer list is empty. */
                    if( xListWasEmpty != pdFALSE )
                    {
                        /* The current timer list is empty - is the overflow list
                         * also empty? */
                        xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 8003cae:	4f73      	ldr	r7, [pc, #460]	; (8003e7c <prvTimerTask+0x1dc>)
         * the timer with the nearest expiry time will expire.  If there are no
         * active timers then just set the next expire time to 0.  That will cause
         * this task to unblock when the tick count overflows, at which point the
         * timer lists will be switched and the next expiry time can be
         * re-assessed.  */
        *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 8003cb0:	6833      	ldr	r3, [r6, #0]
 8003cb2:	681a      	ldr	r2, [r3, #0]

        if( *pxListWasEmpty == pdFALSE )
 8003cb4:	b15a      	cbz	r2, 8003cce <prvTimerTask+0x2e>
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8003cb6:	68db      	ldr	r3, [r3, #12]
 8003cb8:	f8d3 9000 	ldr.w	r9, [r3]
                                            BaseType_t xListWasEmpty )
    {
        TickType_t xTimeNow;
        BaseType_t xTimerListsWereSwitched;

        vTaskSuspendAll();
 8003cbc:	f7ff fa76 	bl	80031ac <vTaskSuspendAll>
            /* Obtain the time now to make an assessment as to whether the timer
             * has expired or not.  If obtaining the time causes the lists to switch
             * then don't process this timer as any timers that remained in the list
             * when the lists were switched will have been processed within the
             * prvSampleTimeNow() function. */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 8003cc0:	a803      	add	r0, sp, #12
 8003cc2:	f7ff ff95 	bl	8003bf0 <prvSampleTimeNow>
 8003cc6:	4604      	mov	r4, r0

            if( xTimerListsWereSwitched == pdFALSE )
 8003cc8:	9b03      	ldr	r3, [sp, #12]
 8003cca:	b14b      	cbz	r3, 8003ce0 <prvTimerTask+0x40>
 8003ccc:	e058      	b.n	8003d80 <prvTimerTask+0xe0>
                                            BaseType_t xListWasEmpty )
    {
        TickType_t xTimeNow;
        BaseType_t xTimerListsWereSwitched;

        vTaskSuspendAll();
 8003cce:	f7ff fa6d 	bl	80031ac <vTaskSuspendAll>
            /* Obtain the time now to make an assessment as to whether the timer
             * has expired or not.  If obtaining the time causes the lists to switch
             * then don't process this timer as any timers that remained in the list
             * when the lists were switched will have been processed within the
             * prvSampleTimeNow() function. */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 8003cd2:	a803      	add	r0, sp, #12
 8003cd4:	f7ff ff8c 	bl	8003bf0 <prvSampleTimeNow>
 8003cd8:	4604      	mov	r4, r0

            if( xTimerListsWereSwitched == pdFALSE )
 8003cda:	9b03      	ldr	r3, [sp, #12]
 8003cdc:	b3b3      	cbz	r3, 8003d4c <prvTimerTask+0xac>
 8003cde:	e04f      	b.n	8003d80 <prvTimerTask+0xe0>
            {
                /* The tick count has not overflowed, has the timer expired? */
                if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 8003ce0:	4581      	cmp	r9, r0
 8003ce2:	bf88      	it	hi
 8003ce4:	2200      	movhi	r2, #0
 8003ce6:	d839      	bhi.n	8003d5c <prvTimerTask+0xbc>
                {
                    ( void ) xTaskResumeAll();
 8003ce8:	f7ff fb00 	bl	80032ec <xTaskResumeAll>

    static void prvProcessExpiredTimer( const TickType_t xNextExpireTime,
                                        const TickType_t xTimeNow )
    {
        BaseType_t xResult;
        Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8003cec:	6833      	ldr	r3, [r6, #0]
 8003cee:	68db      	ldr	r3, [r3, #12]
 8003cf0:	f8d3 a00c 	ldr.w	sl, [r3, #12]

        /* Remove the timer from the list of active timers.  A check has already
         * been performed to ensure the list is not empty. */

        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8003cf4:	f10a 0004 	add.w	r0, sl, #4
 8003cf8:	f7fe fb2e 	bl	8002358 <uxListRemove>
        traceTIMER_EXPIRED( pxTimer );

        /* If the timer is an auto-reload timer then calculate the next
         * expiry time and re-insert the timer in the list of active timers. */
        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 8003cfc:	f89a 3028 	ldrb.w	r3, [sl, #40]	; 0x28
 8003d00:	f013 0f04 	tst.w	r3, #4
 8003d04:	d019      	beq.n	8003d3a <prvTimerTask+0x9a>
        {
            /* The timer is inserted into a list using a time relative to anything
             * other than the current time.  It will therefore be inserted into the
             * correct list relative to the time this task thinks it is now. */
            if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
 8003d06:	f8da 1018 	ldr.w	r1, [sl, #24]
 8003d0a:	4650      	mov	r0, sl
 8003d0c:	4449      	add	r1, r9
 8003d0e:	4622      	mov	r2, r4
 8003d10:	464b      	mov	r3, r9
 8003d12:	f7ff fec7 	bl	8003aa4 <prvInsertTimerInActiveList>
 8003d16:	b1a0      	cbz	r0, 8003d42 <prvTimerTask+0xa2>
            {
                /* The timer expired before it was added to the active timer
                 * list.  Reload it now.  */
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 8003d18:	2300      	movs	r3, #0
 8003d1a:	9300      	str	r3, [sp, #0]
 8003d1c:	4650      	mov	r0, sl
 8003d1e:	4619      	mov	r1, r3
 8003d20:	464a      	mov	r2, r9
 8003d22:	f7ff ff35 	bl	8003b90 <xTimerGenericCommand>
                configASSERT( xResult );
 8003d26:	b960      	cbnz	r0, 8003d42 <prvTimerTask+0xa2>
 8003d28:	f04f 0314 	mov.w	r3, #20
 8003d2c:	f383 8811 	msr	BASEPRI, r3
 8003d30:	f3bf 8f6f 	isb	sy
 8003d34:	f3bf 8f4f 	dsb	sy
 8003d38:	e7fe      	b.n	8003d38 <prvTimerTask+0x98>
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else
        {
            pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 8003d3a:	f023 0301 	bic.w	r3, r3, #1
 8003d3e:	f88a 3028 	strb.w	r3, [sl, #40]	; 0x28
            mtCOVERAGE_TEST_MARKER();
        }

        /* Call the timer callback. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8003d42:	f8da 3020 	ldr.w	r3, [sl, #32]
 8003d46:	4650      	mov	r0, sl
 8003d48:	4798      	blx	r3
 8003d4a:	e08a      	b.n	8003e62 <prvTimerTask+0x1c2>
                     * case when the current timer list is empty. */
                    if( xListWasEmpty != pdFALSE )
                    {
                        /* The current timer list is empty - is the overflow list
                         * also empty? */
                        xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 8003d4c:	683b      	ldr	r3, [r7, #0]
 8003d4e:	681a      	ldr	r2, [r3, #0]
 8003d50:	fab2 f282 	clz	r2, r2
 8003d54:	0952      	lsrs	r2, r2, #5
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
        }
        else
        {
            /* Ensure the task unblocks when the tick count rolls over. */
            xNextExpireTime = ( TickType_t ) 0U;
 8003d56:	f04f 0900 	mov.w	r9, #0
 8003d5a:	e7ff      	b.n	8003d5c <prvTimerTask+0xbc>
                        /* The current timer list is empty - is the overflow list
                         * also empty? */
                        xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
                    }

                    vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
 8003d5c:	6828      	ldr	r0, [r5, #0]
 8003d5e:	ebc4 0109 	rsb	r1, r4, r9
 8003d62:	f7fe ffc1 	bl	8002ce8 <vQueueWaitForMessageRestricted>

                    if( xTaskResumeAll() == pdFALSE )
 8003d66:	f7ff fac1 	bl	80032ec <xTaskResumeAll>
 8003d6a:	2800      	cmp	r0, #0
 8003d6c:	d179      	bne.n	8003e62 <prvTimerTask+0x1c2>
                    {
                        /* Yield to wait for either a command to arrive, or the
                         * block time to expire.  If a command arrived between the
                         * critical section being exited and this yield then the yield
                         * will not cause the task to block. */
                        portYIELD_WITHIN_API();
 8003d6e:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8003d72:	f8c8 3000 	str.w	r3, [r8]
 8003d76:	f3bf 8f4f 	dsb	sy
 8003d7a:	f3bf 8f6f 	isb	sy
 8003d7e:	e070      	b.n	8003e62 <prvTimerTask+0x1c2>
                    }
                }
            }
            else
            {
                ( void ) xTaskResumeAll();
 8003d80:	f7ff fab4 	bl	80032ec <xTaskResumeAll>
 8003d84:	e06d      	b.n	8003e62 <prvTimerTask+0x1c2>
                }
            #endif /* INCLUDE_xTimerPendFunctionCall */

            /* Commands that are positive are timer commands rather than pended
             * function calls. */
            if( xMessage.xMessageID >= ( BaseType_t ) 0 )
 8003d86:	9b03      	ldr	r3, [sp, #12]
 8003d88:	2b00      	cmp	r3, #0
 8003d8a:	db6b      	blt.n	8003e64 <prvTimerTask+0x1c4>
            {
                /* The messages uses the xTimerParameters member to work on a
                 * software timer. */
                pxTimer = xMessage.u.xTimerParameters.pxTimer;
 8003d8c:	9c05      	ldr	r4, [sp, #20]

                if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
 8003d8e:	6963      	ldr	r3, [r4, #20]
 8003d90:	b113      	cbz	r3, 8003d98 <prvTimerTask+0xf8>
                {
                    /* The timer is in a list, remove it. */
                    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8003d92:	1d20      	adds	r0, r4, #4
 8003d94:	f7fe fae0 	bl	8002358 <uxListRemove>
                 *  it must be present in the function call.  prvSampleTimeNow() must be
                 *  called after the message is received from xTimerQueue so there is no
                 *  possibility of a higher priority task adding a message to the message
                 *  queue with a time that is ahead of the timer daemon task (because it
                 *  pre-empted the timer daemon task after the xTimeNow value was set). */
                xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 8003d98:	a802      	add	r0, sp, #8
 8003d9a:	f7ff ff29 	bl	8003bf0 <prvSampleTimeNow>
 8003d9e:	4686      	mov	lr, r0

                switch( xMessage.xMessageID )
 8003da0:	9a03      	ldr	r2, [sp, #12]
 8003da2:	2a09      	cmp	r2, #9
 8003da4:	d85d      	bhi.n	8003e62 <prvTimerTask+0x1c2>
 8003da6:	e8df f002 	tbb	[pc, r2]
 8003daa:	0505      	.short	0x0505
 8003dac:	4f362f05 	.word	0x4f362f05
 8003db0:	362f0505 	.word	0x362f0505
                    case tmrCOMMAND_START_FROM_ISR:
                    case tmrCOMMAND_RESET:
                    case tmrCOMMAND_RESET_FROM_ISR:
                    case tmrCOMMAND_START_DONT_TRACE:
                        /* Start or restart a timer. */
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 8003db4:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 8003db8:	f043 0301 	orr.w	r3, r3, #1
 8003dbc:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28

                        if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 8003dc0:	9b04      	ldr	r3, [sp, #16]
 8003dc2:	69a1      	ldr	r1, [r4, #24]
 8003dc4:	4620      	mov	r0, r4
 8003dc6:	4419      	add	r1, r3
 8003dc8:	4672      	mov	r2, lr
 8003dca:	f7ff fe6b 	bl	8003aa4 <prvInsertTimerInActiveList>
 8003dce:	2800      	cmp	r0, #0
 8003dd0:	d047      	beq.n	8003e62 <prvTimerTask+0x1c2>
                        {
                            /* The timer expired before it was added to the active
                             * timer list.  Process it now. */
                            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8003dd2:	6a23      	ldr	r3, [r4, #32]
 8003dd4:	4620      	mov	r0, r4
 8003dd6:	4798      	blx	r3
                            traceTIMER_EXPIRED( pxTimer );

                            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 8003dd8:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 8003ddc:	f013 0f04 	tst.w	r3, #4
 8003de0:	d03f      	beq.n	8003e62 <prvTimerTask+0x1c2>
                            {
                                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 8003de2:	69a2      	ldr	r2, [r4, #24]
 8003de4:	2300      	movs	r3, #0
 8003de6:	9300      	str	r3, [sp, #0]
 8003de8:	4620      	mov	r0, r4
 8003dea:	4619      	mov	r1, r3
 8003dec:	9c04      	ldr	r4, [sp, #16]
 8003dee:	4422      	add	r2, r4
 8003df0:	f7ff fece 	bl	8003b90 <xTimerGenericCommand>
                                configASSERT( xResult );
 8003df4:	bba8      	cbnz	r0, 8003e62 <prvTimerTask+0x1c2>
 8003df6:	f04f 0314 	mov.w	r3, #20
 8003dfa:	f383 8811 	msr	BASEPRI, r3
 8003dfe:	f3bf 8f6f 	isb	sy
 8003e02:	f3bf 8f4f 	dsb	sy
 8003e06:	e7fe      	b.n	8003e06 <prvTimerTask+0x166>
                        break;

                    case tmrCOMMAND_STOP:
                    case tmrCOMMAND_STOP_FROM_ISR:
                        /* The timer has already been removed from the active list. */
                        pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 8003e08:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 8003e0c:	f023 0301 	bic.w	r3, r3, #1
 8003e10:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
 8003e14:	e025      	b.n	8003e62 <prvTimerTask+0x1c2>
                        break;

                    case tmrCOMMAND_CHANGE_PERIOD:
                    case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR:
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 8003e16:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 8003e1a:	f043 0301 	orr.w	r3, r3, #1
 8003e1e:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
                        pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 8003e22:	9904      	ldr	r1, [sp, #16]
 8003e24:	61a1      	str	r1, [r4, #24]
                        configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 8003e26:	b941      	cbnz	r1, 8003e3a <prvTimerTask+0x19a>
 8003e28:	f04f 0314 	mov.w	r3, #20
 8003e2c:	f383 8811 	msr	BASEPRI, r3
 8003e30:	f3bf 8f6f 	isb	sy
 8003e34:	f3bf 8f4f 	dsb	sy
 8003e38:	e7fe      	b.n	8003e38 <prvTimerTask+0x198>
                         * be longer or shorter than the old one.  The command time is
                         * therefore set to the current time, and as the period cannot
                         * be zero the next expiry time can only be in the future,
                         * meaning (unlike for the xTimerStart() case above) there is
                         * no fail case that needs to be handled here. */
                        ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 8003e3a:	4620      	mov	r0, r4
 8003e3c:	4471      	add	r1, lr
 8003e3e:	4672      	mov	r2, lr
 8003e40:	4673      	mov	r3, lr
 8003e42:	f7ff fe2f 	bl	8003aa4 <prvInsertTimerInActiveList>
 8003e46:	e00c      	b.n	8003e62 <prvTimerTask+0x1c2>
                        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
                            {
                                /* The timer has already been removed from the active list,
                                 * just free up the memory if the memory was dynamically
                                 * allocated. */
                                if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
 8003e48:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 8003e4c:	f013 0f02 	tst.w	r3, #2
 8003e50:	d103      	bne.n	8003e5a <prvTimerTask+0x1ba>
                                {
                                    vPortFree( pxTimer );
 8003e52:	4620      	mov	r0, r4
 8003e54:	f000 f8e6 	bl	8004024 <vPortFree>
 8003e58:	e003      	b.n	8003e62 <prvTimerTask+0x1c2>
                                }
                                else
                                {
                                    pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 8003e5a:	f023 0301 	bic.w	r3, r3, #1
 8003e5e:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
        DaemonTaskMessage_t xMessage;
        Timer_t * pxTimer;
        BaseType_t xTimerListsWereSwitched, xResult;
        TickType_t xTimeNow;

        while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 8003e62:	2400      	movs	r4, #0
 8003e64:	6828      	ldr	r0, [r5, #0]
 8003e66:	a903      	add	r1, sp, #12
 8003e68:	4622      	mov	r2, r4
 8003e6a:	f7fe fd6d 	bl	8002948 <xQueueReceive>
 8003e6e:	2800      	cmp	r0, #0
 8003e70:	d189      	bne.n	8003d86 <prvTimerTask+0xe6>
 8003e72:	e71d      	b.n	8003cb0 <prvTimerTask+0x10>
 8003e74:	20000970 	.word	0x20000970
 8003e78:	2000099c 	.word	0x2000099c
 8003e7c:	200009a0 	.word	0x200009a0
 8003e80:	e000ed04 	.word	0xe000ed04

08003e84 <prvInsertBlockIntoFreeList>:
    BlockLink_t * pxIterator;
    uint8_t * puc;

    /* Iterate through the list until a block is found that has a higher address
     * than the block being inserted. */
    for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 8003e84:	4a13      	ldr	r2, [pc, #76]	; (8003ed4 <prvInsertBlockIntoFreeList+0x50>)
 8003e86:	e000      	b.n	8003e8a <prvInsertBlockIntoFreeList+0x6>
 8003e88:	461a      	mov	r2, r3
 8003e8a:	6813      	ldr	r3, [r2, #0]
 8003e8c:	4283      	cmp	r3, r0
 8003e8e:	d3fb      	bcc.n	8003e88 <prvInsertBlockIntoFreeList+0x4>
    xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t * pxBlockToInsert ) /* PRIVILEGED_FUNCTION */
{
 8003e90:	b430      	push	{r4, r5}
 8003e92:	4611      	mov	r1, r2

    /* Do the block being inserted, and the block it is being inserted after
     * make a contiguous block of memory? */
    puc = ( uint8_t * ) pxIterator;

    if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 8003e94:	6854      	ldr	r4, [r2, #4]
 8003e96:	1915      	adds	r5, r2, r4
 8003e98:	4285      	cmp	r5, r0
 8003e9a:	d103      	bne.n	8003ea4 <prvInsertBlockIntoFreeList+0x20>
    {
        pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 8003e9c:	6868      	ldr	r0, [r5, #4]
 8003e9e:	4404      	add	r4, r0
 8003ea0:	6054      	str	r4, [r2, #4]
 8003ea2:	4610      	mov	r0, r2

    /* Do the block being inserted, and the block it is being inserted before
     * make a contiguous block of memory? */
    puc = ( uint8_t * ) pxBlockToInsert;

    if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 8003ea4:	6842      	ldr	r2, [r0, #4]
 8003ea6:	1884      	adds	r4, r0, r2
 8003ea8:	429c      	cmp	r4, r3
 8003eaa:	d10c      	bne.n	8003ec6 <prvInsertBlockIntoFreeList+0x42>
    {
        if( pxIterator->pxNextFreeBlock != pxEnd )
 8003eac:	4b0a      	ldr	r3, [pc, #40]	; (8003ed8 <prvInsertBlockIntoFreeList+0x54>)
 8003eae:	681b      	ldr	r3, [r3, #0]
 8003eb0:	429c      	cmp	r4, r3
 8003eb2:	d006      	beq.n	8003ec2 <prvInsertBlockIntoFreeList+0x3e>
        {
            /* Form one big block from the two blocks. */
            pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8003eb4:	6863      	ldr	r3, [r4, #4]
 8003eb6:	441a      	add	r2, r3
 8003eb8:	6042      	str	r2, [r0, #4]
            pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 8003eba:	680b      	ldr	r3, [r1, #0]
 8003ebc:	681b      	ldr	r3, [r3, #0]
 8003ebe:	6003      	str	r3, [r0, #0]
 8003ec0:	e002      	b.n	8003ec8 <prvInsertBlockIntoFreeList+0x44>
        }
        else
        {
            pxBlockToInsert->pxNextFreeBlock = pxEnd;
 8003ec2:	6004      	str	r4, [r0, #0]
 8003ec4:	e000      	b.n	8003ec8 <prvInsertBlockIntoFreeList+0x44>
        }
    }
    else
    {
        pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 8003ec6:	6003      	str	r3, [r0, #0]

    /* If the block being inserted plugged a gab, so was merged with the block
     * before and the block after, then it's pxNextFreeBlock pointer will have
     * already been set, and should not be set here as that would make it point
     * to itself. */
    if( pxIterator != pxBlockToInsert )
 8003ec8:	4281      	cmp	r1, r0
    {
        pxIterator->pxNextFreeBlock = pxBlockToInsert;
 8003eca:	bf18      	it	ne
 8003ecc:	6008      	strne	r0, [r1, #0]
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
 8003ece:	bc30      	pop	{r4, r5}
 8003ed0:	4770      	bx	lr
 8003ed2:	bf00      	nop
 8003ed4:	200009b8 	.word	0x200009b8
 8003ed8:	200009b4 	.word	0x200009b4

08003edc <pvPortMalloc>:
PRIVILEGED_DATA static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
 8003edc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003ede:	4604      	mov	r4, r0
    BlockLink_t * pxBlock, * pxPreviousBlock, * pxNewBlockLink;
    void * pvReturn = NULL;

    vTaskSuspendAll();
 8003ee0:	f7ff f964 	bl	80031ac <vTaskSuspendAll>
    {
        /* If this is the first call to malloc then the heap will require
         * initialisation to setup the list of free blocks. */
        if( pxEnd == NULL )
 8003ee4:	4b48      	ldr	r3, [pc, #288]	; (8004008 <pvPortMalloc+0x12c>)
 8003ee6:	681b      	ldr	r3, [r3, #0]
 8003ee8:	bb23      	cbnz	r3, 8003f34 <pvPortMalloc+0x58>
    uint8_t * pucAlignedHeap;
    size_t uxAddress;
    size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;

    /* Ensure the heap starts on a correctly aligned boundary. */
    uxAddress = ( size_t ) ucHeap;
 8003eea:	4a48      	ldr	r2, [pc, #288]	; (800400c <pvPortMalloc+0x130>)

    if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 8003eec:	f012 0f07 	tst.w	r2, #7
 8003ef0:	d007      	beq.n	8003f02 <pvPortMalloc+0x26>
    {
        uxAddress += ( portBYTE_ALIGNMENT - 1 );
 8003ef2:	1dd1      	adds	r1, r2, #7
        uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8003ef4:	f021 0107 	bic.w	r1, r1, #7
 8003ef8:	f502 4340 	add.w	r3, r2, #49152	; 0xc000
        xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 8003efc:	1a5b      	subs	r3, r3, r1
    uxAddress = ( size_t ) ucHeap;

    if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
    {
        uxAddress += ( portBYTE_ALIGNMENT - 1 );
        uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8003efe:	460a      	mov	r2, r1
 8003f00:	e001      	b.n	8003f06 <pvPortMalloc+0x2a>
static void prvHeapInit( void ) /* PRIVILEGED_FUNCTION */
{
    BlockLink_t * pxFirstFreeBlock;
    uint8_t * pucAlignedHeap;
    size_t uxAddress;
    size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
 8003f02:	f44f 4340 	mov.w	r3, #49152	; 0xc000

    pucAlignedHeap = ( uint8_t * ) uxAddress;

    /* xStart is used to hold a pointer to the first item in the list of free
     * blocks.  The void cast is used to prevent compiler warnings. */
    xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 8003f06:	4842      	ldr	r0, [pc, #264]	; (8004010 <pvPortMalloc+0x134>)
 8003f08:	6002      	str	r2, [r0, #0]
    xStart.xBlockSize = ( size_t ) 0;
 8003f0a:	2100      	movs	r1, #0
 8003f0c:	6041      	str	r1, [r0, #4]

    /* pxEnd is used to mark the end of the list of free blocks and is inserted
     * at the end of the heap space. */
    uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
 8003f0e:	4413      	add	r3, r2
    uxAddress -= xHeapStructSize;
 8003f10:	3b08      	subs	r3, #8
    uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8003f12:	f023 0307 	bic.w	r3, r3, #7
    pxEnd = ( void * ) uxAddress;
 8003f16:	483c      	ldr	r0, [pc, #240]	; (8004008 <pvPortMalloc+0x12c>)
 8003f18:	6003      	str	r3, [r0, #0]
    pxEnd->xBlockSize = 0;
 8003f1a:	6059      	str	r1, [r3, #4]
    pxEnd->pxNextFreeBlock = NULL;
 8003f1c:	6019      	str	r1, [r3, #0]

    /* To start with there is a single free block that is sized to take up the
     * entire heap space, minus the space taken by pxEnd. */
    pxFirstFreeBlock = ( void * ) pucAlignedHeap;
    pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 8003f1e:	1a99      	subs	r1, r3, r2
 8003f20:	6051      	str	r1, [r2, #4]
    pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 8003f22:	6013      	str	r3, [r2, #0]

    /* Only one block exists - and it covers the entire usable heap space. */
    xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8003f24:	4b3b      	ldr	r3, [pc, #236]	; (8004014 <pvPortMalloc+0x138>)
 8003f26:	6019      	str	r1, [r3, #0]
    xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8003f28:	4b3b      	ldr	r3, [pc, #236]	; (8004018 <pvPortMalloc+0x13c>)
 8003f2a:	6019      	str	r1, [r3, #0]

    /* Work out the position of the top bit in a size_t variable. */
    xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 8003f2c:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 8003f30:	4b3a      	ldr	r3, [pc, #232]	; (800401c <pvPortMalloc+0x140>)
 8003f32:	601a      	str	r2, [r3, #0]

        /* Check the requested block size is not so large that the top bit is
         * set.  The top bit of the block size member of the BlockLink_t structure
         * is used to determine who owns the block - the application or the
         * kernel, so it must be free. */
        if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 8003f34:	4b39      	ldr	r3, [pc, #228]	; (800401c <pvPortMalloc+0x140>)
 8003f36:	681e      	ldr	r6, [r3, #0]
 8003f38:	4234      	tst	r4, r6
 8003f3a:	d15c      	bne.n	8003ff6 <pvPortMalloc+0x11a>
        {
            /* The wanted size is increased so it can contain a BlockLink_t
             * structure in addition to the requested amount of bytes. */
            if( xWantedSize > 0 )
 8003f3c:	2c00      	cmp	r4, #0
 8003f3e:	d05d      	beq.n	8003ffc <pvPortMalloc+0x120>
            {
                xWantedSize += xHeapStructSize;
 8003f40:	f104 0308 	add.w	r3, r4, #8

                /* Ensure that blocks are always aligned to the required number
                 * of bytes. */
                if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 8003f44:	f013 0f07 	tst.w	r3, #7
                {
                    /* Byte alignment required. */
                    xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 8003f48:	bf1c      	itt	ne
 8003f4a:	f023 0307 	bicne.w	r3, r3, #7
 8003f4e:	3308      	addne	r3, #8
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 8003f50:	2b00      	cmp	r3, #0
 8003f52:	d050      	beq.n	8003ff6 <pvPortMalloc+0x11a>
 8003f54:	4a30      	ldr	r2, [pc, #192]	; (8004018 <pvPortMalloc+0x13c>)
 8003f56:	6817      	ldr	r7, [r2, #0]
 8003f58:	42bb      	cmp	r3, r7
 8003f5a:	d84c      	bhi.n	8003ff6 <pvPortMalloc+0x11a>
            {
                /* Traverse the list from the start	(lowest address) block until
                 * one	of adequate size is found. */
                pxPreviousBlock = &xStart;
                pxBlock = xStart.pxNextFreeBlock;
 8003f5c:	4a2c      	ldr	r2, [pc, #176]	; (8004010 <pvPortMalloc+0x134>)
 8003f5e:	6814      	ldr	r4, [r2, #0]

                while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8003f60:	e001      	b.n	8003f66 <pvPortMalloc+0x8a>
 8003f62:	4622      	mov	r2, r4
                {
                    pxPreviousBlock = pxBlock;
                    pxBlock = pxBlock->pxNextFreeBlock;
 8003f64:	460c      	mov	r4, r1
                /* Traverse the list from the start	(lowest address) block until
                 * one	of adequate size is found. */
                pxPreviousBlock = &xStart;
                pxBlock = xStart.pxNextFreeBlock;

                while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8003f66:	6861      	ldr	r1, [r4, #4]
 8003f68:	428b      	cmp	r3, r1
 8003f6a:	d902      	bls.n	8003f72 <pvPortMalloc+0x96>
 8003f6c:	6821      	ldr	r1, [r4, #0]
 8003f6e:	2900      	cmp	r1, #0
 8003f70:	d1f7      	bne.n	8003f62 <pvPortMalloc+0x86>
                    pxBlock = pxBlock->pxNextFreeBlock;
                }

                /* If the end marker was reached then a block of adequate size
                 * was	not found. */
                if( pxBlock != pxEnd )
 8003f72:	4925      	ldr	r1, [pc, #148]	; (8004008 <pvPortMalloc+0x12c>)
 8003f74:	6809      	ldr	r1, [r1, #0]
 8003f76:	428c      	cmp	r4, r1
 8003f78:	d03d      	beq.n	8003ff6 <pvPortMalloc+0x11a>
                {
                    /* Return the memory space pointed to - jumping over the
                     * BlockLink_t structure at its start. */
                    pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 8003f7a:	6815      	ldr	r5, [r2, #0]

                    /* This block is being returned for use so must be taken out
                     * of the list of free blocks. */
                    pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 8003f7c:	6821      	ldr	r1, [r4, #0]
 8003f7e:	6011      	str	r1, [r2, #0]

                    /* If the block is larger than required it can be split into
                     * two. */
                    if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 8003f80:	6862      	ldr	r2, [r4, #4]
 8003f82:	1ad2      	subs	r2, r2, r3
 8003f84:	2a10      	cmp	r2, #16
 8003f86:	d910      	bls.n	8003faa <pvPortMalloc+0xce>
                    {
                        /* This block is to be split into two.  Create a new
                         * block following the number of bytes requested. The void
                         * cast is used to prevent byte alignment warnings from the
                         * compiler. */
                        pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 8003f88:	18e0      	adds	r0, r4, r3
                        configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 8003f8a:	f010 0f07 	tst.w	r0, #7
 8003f8e:	d008      	beq.n	8003fa2 <pvPortMalloc+0xc6>
 8003f90:	f04f 0314 	mov.w	r3, #20
 8003f94:	f383 8811 	msr	BASEPRI, r3
 8003f98:	f3bf 8f6f 	isb	sy
 8003f9c:	f3bf 8f4f 	dsb	sy
 8003fa0:	e7fe      	b.n	8003fa0 <pvPortMalloc+0xc4>

                        /* Calculate the sizes of two blocks split from the
                         * single block. */
                        pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 8003fa2:	6042      	str	r2, [r0, #4]
                        pxBlock->xBlockSize = xWantedSize;
 8003fa4:	6063      	str	r3, [r4, #4]

                        /* Insert the new block into the list of free blocks. */
                        prvInsertBlockIntoFreeList( pxNewBlockLink );
 8003fa6:	f7ff ff6d 	bl	8003e84 <prvInsertBlockIntoFreeList>
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    xFreeBytesRemaining -= pxBlock->xBlockSize;
 8003faa:	6862      	ldr	r2, [r4, #4]
 8003fac:	1abb      	subs	r3, r7, r2
 8003fae:	491a      	ldr	r1, [pc, #104]	; (8004018 <pvPortMalloc+0x13c>)
 8003fb0:	600b      	str	r3, [r1, #0]

                    if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8003fb2:	4918      	ldr	r1, [pc, #96]	; (8004014 <pvPortMalloc+0x138>)
 8003fb4:	6809      	ldr	r1, [r1, #0]
 8003fb6:	428b      	cmp	r3, r1
                    {
                        xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 8003fb8:	bf3c      	itt	cc
 8003fba:	4916      	ldrcc	r1, [pc, #88]	; (8004014 <pvPortMalloc+0x138>)
 8003fbc:	600b      	strcc	r3, [r1, #0]
                 * was	not found. */
                if( pxBlock != pxEnd )
                {
                    /* Return the memory space pointed to - jumping over the
                     * BlockLink_t structure at its start. */
                    pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 8003fbe:	3508      	adds	r5, #8
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* The block is being returned - it is allocated and owned
                     * by the application and has no "next" block. */
                    pxBlock->xBlockSize |= xBlockAllocatedBit;
 8003fc0:	4316      	orrs	r6, r2
 8003fc2:	6066      	str	r6, [r4, #4]
                    pxBlock->pxNextFreeBlock = NULL;
 8003fc4:	2300      	movs	r3, #0
 8003fc6:	6023      	str	r3, [r4, #0]
                    xNumberOfSuccessfulAllocations++;
 8003fc8:	4a15      	ldr	r2, [pc, #84]	; (8004020 <pvPortMalloc+0x144>)
 8003fca:	6813      	ldr	r3, [r2, #0]
 8003fcc:	3301      	adds	r3, #1
 8003fce:	6013      	str	r3, [r2, #0]
            mtCOVERAGE_TEST_MARKER();
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
 8003fd0:	f7ff f98c 	bl	80032ec <xTaskResumeAll>

    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )
        {
            if( pvReturn == NULL )
 8003fd4:	b91d      	cbnz	r5, 8003fde <pvPortMalloc+0x102>
            {
                extern void vApplicationMallocFailedHook( void );
                vApplicationMallocFailedHook();
 8003fd6:	f006 fd93 	bl	800ab00 <vApplicationMallocFailedHook>
 8003fda:	2500      	movs	r5, #0
 8003fdc:	e011      	b.n	8004002 <pvPortMalloc+0x126>
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* if ( configUSE_MALLOC_FAILED_HOOK == 1 ) */

    configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 8003fde:	f015 0f07 	tst.w	r5, #7
 8003fe2:	d00e      	beq.n	8004002 <pvPortMalloc+0x126>
 8003fe4:	f04f 0314 	mov.w	r3, #20
 8003fe8:	f383 8811 	msr	BASEPRI, r3
 8003fec:	f3bf 8f6f 	isb	sy
 8003ff0:	f3bf 8f4f 	dsb	sy
 8003ff4:	e7fe      	b.n	8003ff4 <pvPortMalloc+0x118>
            mtCOVERAGE_TEST_MARKER();
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
 8003ff6:	f7ff f979 	bl	80032ec <xTaskResumeAll>
 8003ffa:	e7ec      	b.n	8003fd6 <pvPortMalloc+0xfa>
 8003ffc:	f7ff f976 	bl	80032ec <xTaskResumeAll>
 8004000:	e7e9      	b.n	8003fd6 <pvPortMalloc+0xfa>
        }
    #endif /* if ( configUSE_MALLOC_FAILED_HOOK == 1 ) */

    configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
    return pvReturn;
}
 8004002:	4628      	mov	r0, r5
 8004004:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004006:	bf00      	nop
 8004008:	200009b4 	.word	0x200009b4
 800400c:	200009c4 	.word	0x200009c4
 8004010:	200009b8 	.word	0x200009b8
 8004014:	2000c9c8 	.word	0x2000c9c8
 8004018:	200009b0 	.word	0x200009b0
 800401c:	2000c9c4 	.word	0x2000c9c4
 8004020:	200009ac 	.word	0x200009ac

08004024 <vPortFree>:
void vPortFree( void * pv )
{
    uint8_t * puc = ( uint8_t * ) pv;
    BlockLink_t * pxLink;

    if( pv != NULL )
 8004024:	2800      	cmp	r0, #0
 8004026:	d033      	beq.n	8004090 <vPortFree+0x6c>
    return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
 8004028:	b510      	push	{r4, lr}
 800402a:	4604      	mov	r4, r0

        /* This casting is to keep the compiler from issuing warnings. */
        pxLink = ( void * ) puc;

        /* Check the block is actually allocated. */
        configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 800402c:	f850 3c04 	ldr.w	r3, [r0, #-4]
 8004030:	4a18      	ldr	r2, [pc, #96]	; (8004094 <vPortFree+0x70>)
 8004032:	6812      	ldr	r2, [r2, #0]
 8004034:	421a      	tst	r2, r3
 8004036:	d108      	bne.n	800404a <vPortFree+0x26>
 8004038:	f04f 0314 	mov.w	r3, #20
 800403c:	f383 8811 	msr	BASEPRI, r3
 8004040:	f3bf 8f6f 	isb	sy
 8004044:	f3bf 8f4f 	dsb	sy
 8004048:	e7fe      	b.n	8004048 <vPortFree+0x24>
        configASSERT( pxLink->pxNextFreeBlock == NULL );
 800404a:	f850 1c08 	ldr.w	r1, [r0, #-8]
 800404e:	b141      	cbz	r1, 8004062 <vPortFree+0x3e>
 8004050:	f04f 0314 	mov.w	r3, #20
 8004054:	f383 8811 	msr	BASEPRI, r3
 8004058:	f3bf 8f6f 	isb	sy
 800405c:	f3bf 8f4f 	dsb	sy
 8004060:	e7fe      	b.n	8004060 <vPortFree+0x3c>
        {
            if( pxLink->pxNextFreeBlock == NULL )
            {
                /* The block is being returned to the heap - it is no longer
                 * allocated. */
                pxLink->xBlockSize &= ~xBlockAllocatedBit;
 8004062:	ea23 0302 	bic.w	r3, r3, r2
 8004066:	f840 3c04 	str.w	r3, [r0, #-4]

                vTaskSuspendAll();
 800406a:	f7ff f89f 	bl	80031ac <vTaskSuspendAll>
                {
                    /* Add this block to the list of free blocks. */
                    xFreeBytesRemaining += pxLink->xBlockSize;
 800406e:	4a0a      	ldr	r2, [pc, #40]	; (8004098 <vPortFree+0x74>)
 8004070:	6811      	ldr	r1, [r2, #0]
 8004072:	f854 3c04 	ldr.w	r3, [r4, #-4]
 8004076:	440b      	add	r3, r1
 8004078:	6013      	str	r3, [r2, #0]
                    traceFREE( pv, pxLink->xBlockSize );
                    prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 800407a:	f1a4 0008 	sub.w	r0, r4, #8
 800407e:	f7ff ff01 	bl	8003e84 <prvInsertBlockIntoFreeList>
                    xNumberOfSuccessfulFrees++;
 8004082:	4a06      	ldr	r2, [pc, #24]	; (800409c <vPortFree+0x78>)
 8004084:	6813      	ldr	r3, [r2, #0]
 8004086:	3301      	adds	r3, #1
 8004088:	6013      	str	r3, [r2, #0]
                }
                ( void ) xTaskResumeAll();
 800408a:	f7ff f92f 	bl	80032ec <xTaskResumeAll>
 800408e:	bd10      	pop	{r4, pc}
 8004090:	4770      	bx	lr
 8004092:	bf00      	nop
 8004094:	2000c9c4 	.word	0x2000c9c4
 8004098:	200009b0 	.word	0x200009b0
 800409c:	200009c0 	.word	0x200009c0

080040a0 <prvEMACHandlerTask>:
 *
 * <i>Imp Note:</i>
 *
 */
void prvEMACHandlerTask( void *pvParameters )
{
 80040a0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80040a4:	b083      	sub	sp, #12
    /* Local variables */
    NetworkBufferDescriptor_t *pxNetworkBufferDescriptor = NULL;
    uint8_t * p_buffer_l = NULL;
    /* Used to indicate that xSendEventStructToIPTask() is being called because
     * of an Ethernet receive event. */
    IPStackEvent_t xRxEvent = { eNetworkRxEvent, NULL };
 80040a6:	2301      	movs	r3, #1
 80040a8:	f88d 3000 	strb.w	r3, [sp]
 80040ac:	2500      	movs	r5, #0
 80040ae:	9501      	str	r5, [sp, #4]

    /* Loop processing for task */
	for( ; ; )
	{
		/* Wait for the EMAC interrupt to indicate that another packet has been received. */
        if( xSemaphoreTake( xEthRxEventSemaphore, portMAX_DELAY ) == pdPASS )
 80040b0:	4e35      	ldr	r6, [pc, #212]	; (8004188 <prvEMACHandlerTask+0xe8>)
        }/* End of semaphore if block */

        /* Give mutex back */
        if( pdTRUE == xMutex )
        {
        	xSemaphoreGive( xEthRxEventMutex );
 80040b2:	4f36      	ldr	r7, [pc, #216]	; (800418c <prvEMACHandlerTask+0xec>)
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80040b4:	4c36      	ldr	r4, [pc, #216]	; (8004190 <prvEMACHandlerTask+0xf0>)

    /* Loop processing for task */
	for( ; ; )
	{
		/* Wait for the EMAC interrupt to indicate that another packet has been received. */
        if( xSemaphoreTake( xEthRxEventSemaphore, portMAX_DELAY ) == pdPASS )
 80040b6:	6830      	ldr	r0, [r6, #0]
 80040b8:	f04f 31ff 	mov.w	r1, #4294967295
 80040bc:	f7fe fcec 	bl	8002a98 <xQueueSemaphoreTake>
 80040c0:	2801      	cmp	r0, #1
 80040c2:	d152      	bne.n	800416a <prvEMACHandlerTask+0xca>
 80040c4:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80040c8:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 80040cc:	f3bf 8f4f 	dsb	sy
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 */
__STATIC_FORCEINLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
 80040d0:	f3bf 8f6f 	isb	sy
        {
        	/* Disable Ethernet interrupt */
        	NVIC_DisableIRQ( (IRQn_Type)ETH0_0_IRQn );

        	/* Take Rx mutex */
        	xMutex = xSemaphoreTake( xEthRxEventMutex, portMAX_DELAY );
 80040d4:	6838      	ldr	r0, [r7, #0]
 80040d6:	f04f 31ff 	mov.w	r1, #4294967295
 80040da:	f7fe fcdd 	bl	8002a98 <xQueueSemaphoreTake>
 80040de:	4605      	mov	r5, r0
        	if( pdTRUE == xMutex )
 80040e0:	2801      	cmp	r0, #1
 80040e2:	d14b      	bne.n	800417c <prvEMACHandlerTask+0xdc>
 * \par
 * The function checks if the RX descriptor is owned by the DMA.
 */
__STATIC_INLINE bool XMC_ETH_MAC_IsRxDescriptorOwnedByDma(XMC_ETH_MAC_t *const eth_mac)
{
  return ((eth_mac->rx_desc[eth_mac->rx_index].status & ETH_MAC_DMA_RDES0_OWN) != 0U);
 80040e4:	4a2b      	ldr	r2, [pc, #172]	; (8004194 <prvEMACHandlerTask+0xf4>)
 80040e6:	f892 3027 	ldrb.w	r3, [r2, #39]	; 0x27
 80040ea:	6912      	ldr	r2, [r2, #16]
 80040ec:	015b      	lsls	r3, r3, #5
        	{
            	/* Check descriptor */
            	if( XMC_ETH_MAC_IsRxDescriptorOwnedByDma( &ethernet_mac_handle ) )
 80040ee:	58d3      	ldr	r3, [r2, r3]
 80040f0:	2b00      	cmp	r3, #0
 80040f2:	da0a      	bge.n	800410a <prvEMACHandlerTask+0x6a>
 * If that descriptor is not available (owned by the CPU), the transmission
 * returns to the suspend state else the transmission resumes.
 */
__STATIC_INLINE void XMC_ETH_MAC_ResumeRx(XMC_ETH_MAC_t *const eth_mac)
{
  eth_mac->regs->STATUS = (uint32_t)ETH_STATUS_RU_Msk;
 80040f4:	4b27      	ldr	r3, [pc, #156]	; (8004194 <prvEMACHandlerTask+0xf4>)
 80040f6:	681b      	ldr	r3, [r3, #0]
 80040f8:	2180      	movs	r1, #128	; 0x80
 80040fa:	f241 0214 	movw	r2, #4116	; 0x1014
 80040fe:	5099      	str	r1, [r3, r2]
  eth_mac->regs->RECEIVE_POLL_DEMAND = 0U;
 8004100:	2100      	movs	r1, #0
 8004102:	f241 0208 	movw	r2, #4104	; 0x1008
 8004106:	5099      	str	r1, [r3, r2]
 8004108:	e031      	b.n	800416e <prvEMACHandlerTask+0xce>
            		XMC_ETH_MAC_ResumeRx( &ethernet_mac_handle );
            	}
            	else/* Descriptor available, Check for data size received */
            	{
            		/* Check data using HAL */
            		length_l = XMC_ETH_MAC_GetRxFrameSize( &ethernet_mac_handle );
 800410a:	4822      	ldr	r0, [pc, #136]	; (8004194 <prvEMACHandlerTask+0xf4>)
 800410c:	f7fd f9e8 	bl	80014e0 <XMC_ETH_MAC_GetRxFrameSize>
                    /* If data length is valid, enter to get a network descriptor */
                    if( length_l > 0 )
 8004110:	4605      	mov	r5, r0
 8004112:	b360      	cbz	r0, 800416e <prvEMACHandlerTask+0xce>
                    {
                        /* Obtain a network buffer to pass this data into the
                           stack.  No storage is required as the network buffer
                           will point directly to the buffer that already holds
                           the received data. */
                        pxNetworkBufferDescriptor = pxGetNetworkBufferWithDescriptor( length_l, ( TickType_t ) 0 );
 8004114:	2100      	movs	r1, #0
 8004116:	f000 fa7d 	bl	8004614 <pxGetNetworkBufferWithDescriptor>
                        /* Check Network Descriptor validity */
                        if( pxNetworkBufferDescriptor != NULL )
 800411a:	4681      	mov	r9, r0
 800411c:	b338      	cbz	r0, 800416e <prvEMACHandlerTask+0xce>
 * \par<b>Description: </b><br>
 * Returns the current RX buffer.
 */
__STATIC_INLINE uint8_t *XMC_ETH_MAC_GetRxBuffer(XMC_ETH_MAC_t *const eth_mac)
{
  return (uint8_t *)(eth_mac->rx_desc[eth_mac->rx_index].buffer1); 
 800411e:	f8df 8074 	ldr.w	r8, [pc, #116]	; 8004194 <prvEMACHandlerTask+0xf4>
 8004122:	f898 2027 	ldrb.w	r2, [r8, #39]	; 0x27
 8004126:	f8d8 3010 	ldr.w	r3, [r8, #16]
 800412a:	eb03 1342 	add.w	r3, r3, r2, lsl #5
                        {
                            /* Read descriptor buffer and assign to pcBuffer */
                        	p_buffer_l = XMC_ETH_MAC_GetRxBuffer( &ethernet_mac_handle );
                        	/* Copy the descriptor buffer data into network buffer */
                            memcpy( pxNetworkBufferDescriptor->pucEthernetBuffer, p_buffer_l, length_l );
 800412e:	6980      	ldr	r0, [r0, #24]
 8004130:	6899      	ldr	r1, [r3, #8]
 8004132:	462a      	mov	r2, r5
 8004134:	f005 fed6 	bl	8009ee4 <memcpy>
                            pxNetworkBufferDescriptor->xDataLength = length_l;
 8004138:	f8c9 501c 	str.w	r5, [r9, #28]
                            /* Return RX descriptor */
                            XMC_ETH_MAC_ReturnRxDescriptor( &ethernet_mac_handle );
 800413c:	4640      	mov	r0, r8
 800413e:	f7fd fabf 	bl	80016c0 <XMC_ETH_MAC_ReturnRxDescriptor>
 * If that descriptor is not available (owned by the CPU), the transmission
 * returns to the suspend state else the transmission resumes.
 */
__STATIC_INLINE void XMC_ETH_MAC_ResumeRx(XMC_ETH_MAC_t *const eth_mac)
{
  eth_mac->regs->STATUS = (uint32_t)ETH_STATUS_RU_Msk;
 8004142:	f8d8 3000 	ldr.w	r3, [r8]
 8004146:	2180      	movs	r1, #128	; 0x80
 8004148:	f241 0214 	movw	r2, #4116	; 0x1014
 800414c:	5099      	str	r1, [r3, r2]
  eth_mac->regs->RECEIVE_POLL_DEMAND = 0U;
 800414e:	2100      	movs	r1, #0
 8004150:	f241 0208 	movw	r2, #4104	; 0x1008
 8004154:	5099      	str	r1, [r3, r2]
                            /* Resume Rx operation */
                            XMC_ETH_MAC_ResumeRx( &ethernet_mac_handle );

                            /* Can check for Receive data using Zero copy */
                            xRxEvent.pvData = ( void * ) pxNetworkBufferDescriptor;
 8004156:	f8cd 9004 	str.w	r9, [sp, #4]

                            /* Data was received and stored.  Send a message to the IP
                               task to let it know. */
                            if( xSendEventStructToIPTask( &xRxEvent, ( TickType_t ) 0 ) == pdFAIL )
 800415a:	4668      	mov	r0, sp
 800415c:	f001 f826 	bl	80051ac <xSendEventStructToIPTask>
 8004160:	b928      	cbnz	r0, 800416e <prvEMACHandlerTask+0xce>
                            {
                                vReleaseNetworkBufferAndDescriptor( pxNetworkBufferDescriptor );
 8004162:	4648      	mov	r0, r9
 8004164:	f000 fa34 	bl	80045d0 <vReleaseNetworkBufferAndDescriptor>
 8004168:	e001      	b.n	800416e <prvEMACHandlerTask+0xce>
        		/* Could not take Mutex */
        	}
        }/* End of semaphore if block */

        /* Give mutex back */
        if( pdTRUE == xMutex )
 800416a:	2d01      	cmp	r5, #1
 800416c:	d106      	bne.n	800417c <prvEMACHandlerTask+0xdc>
        {
        	xSemaphoreGive( xEthRxEventMutex );
 800416e:	6838      	ldr	r0, [r7, #0]
 8004170:	2100      	movs	r1, #0
 8004172:	460a      	mov	r2, r1
 8004174:	460b      	mov	r3, r1
 8004176:	f7fe fa3b 	bl	80025f0 <xQueueGenericSend>
 800417a:	2501      	movs	r5, #1
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 800417c:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8004180:	f8c4 318c 	str.w	r3, [r4, #396]	; 0x18c
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8004184:	60e3      	str	r3, [r4, #12]
 8004186:	e796      	b.n	80040b6 <prvEMACHandlerTask+0x16>
 8004188:	2000c9dc 	.word	0x2000c9dc
 800418c:	2000c9d4 	.word	0x2000c9d4
 8004190:	e000e100 	.word	0xe000e100
 8004194:	2000d578 	.word	0x2000d578

08004198 <xNetworkInterfaceInitialise>:
 *
 * <i>Imp Note:</i>
 *
 */
BaseType_t xNetworkInterfaceInitialise( void )
{
 8004198:	b538      	push	{r3, r4, r5, lr}
    /* Local Variables */
    BaseType_t xResult = pdPASS;

    /* Check for PHY Link status */
    while( XMC_ETH_PHY_GetLinkStatus(&ethernet_mac_handle, ETH_0_PHY_ADDR) != XMC_ETH_LINK_STATUS_UP );
 800419a:	4d2f      	ldr	r5, [pc, #188]	; (8004258 <xNetworkInterfaceInitialise+0xc0>)
 800419c:	2400      	movs	r4, #0
 800419e:	4628      	mov	r0, r5
 80041a0:	4621      	mov	r1, r4
 80041a2:	f7fd fb27 	bl	80017f4 <XMC_ETH_PHY_GetLinkStatus>
 80041a6:	2801      	cmp	r0, #1
 80041a8:	d1f9      	bne.n	800419e <xNetworkInterfaceInitialise+0x6>

	/* Enter critical section */
	vPortEnterCritical();
 80041aa:	f7fd fe09 	bl	8001dc0 <vPortEnterCritical>
	/* Set network speed and set it up */
	XMC_ETH_MAC_SetLink( &ethernet_mac_handle,
 80041ae:	4c2a      	ldr	r4, [pc, #168]	; (8004258 <xNetworkInterfaceInitialise+0xc0>)
 80041b0:	4620      	mov	r0, r4
 80041b2:	2100      	movs	r1, #0
 80041b4:	f7fd fb2c 	bl	8001810 <XMC_ETH_PHY_GetLinkSpeed>
 80041b8:	4605      	mov	r5, r0
 80041ba:	4620      	mov	r0, r4
 80041bc:	2100      	movs	r1, #0
 80041be:	f7fd fb3b 	bl	8001838 <XMC_ETH_PHY_GetLinkDuplex>
 */
__STATIC_INLINE void XMC_ETH_MAC_SetLink(XMC_ETH_MAC_t *const eth_mac,
                                         XMC_ETH_LINK_SPEED_t speed,
                                         XMC_ETH_LINK_DUPLEX_t duplex)
{
  eth_mac->regs->MAC_CONFIGURATION = (eth_mac->regs->MAC_CONFIGURATION &
 80041c2:	6822      	ldr	r2, [r4, #0]
 80041c4:	6813      	ldr	r3, [r2, #0]
 80041c6:	4328      	orrs	r0, r5
 80041c8:	b280      	uxth	r0, r0
 80041ca:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
                                      (uint32_t)~(ETH_MAC_CONFIGURATION_DM_Msk | ETH_MAC_CONFIGURATION_FES_Msk)) |
                                     (uint32_t)speed | (uint32_t)duplex;
 80041ce:	4303      	orrs	r3, r0
 */
__STATIC_INLINE void XMC_ETH_MAC_SetLink(XMC_ETH_MAC_t *const eth_mac,
                                         XMC_ETH_LINK_SPEED_t speed,
                                         XMC_ETH_LINK_DUPLEX_t duplex)
{
  eth_mac->regs->MAC_CONFIGURATION = (eth_mac->regs->MAC_CONFIGURATION &
 80041d0:	6013      	str	r3, [r2, #0]
			XMC_ETH_PHY_GetLinkSpeed( &ethernet_mac_handle, ETH_0_PHY_ADDR ),
			XMC_ETH_PHY_GetLinkDuplex( &ethernet_mac_handle, ETH_0_PHY_ADDR ) );
	/* Enable Ethernet interrupts */
	XMC_ETH_MAC_EnableEvent( &ethernet_mac_handle, (uint32_t)XMC_ETH_MAC_EVENT_RECEIVE );
 80041d2:	4620      	mov	r0, r4
 80041d4:	2140      	movs	r1, #64	; 0x40
 80041d6:	f7fd fa35 	bl	8001644 <XMC_ETH_MAC_EnableEvent>
	XMC_ETH_MAC_EnableEvent( &ethernet_mac_handle, (uint32_t)XMC_ETH_MAC_EVENT_PMT );
 80041da:	4620      	mov	r0, r4
 80041dc:	f44f 2100 	mov.w	r1, #524288	; 0x80000
 80041e0:	f7fd fa30 	bl	8001644 <XMC_ETH_MAC_EnableEvent>
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80041e4:	4b1d      	ldr	r3, [pc, #116]	; (800425c <xNetworkInterfaceInitialise+0xc4>)
 80041e6:	68db      	ldr	r3, [r3, #12]
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 80041e8:	f3c3 2302 	ubfx	r3, r3, #8, #3
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80041ec:	f1c3 0107 	rsb	r1, r3, #7
 80041f0:	2906      	cmp	r1, #6
 80041f2:	bf28      	it	cs
 80041f4:	2106      	movcs	r1, #6
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80041f6:	1d9a      	adds	r2, r3, #6
 80041f8:	2a06      	cmp	r2, #6
 80041fa:	bf8c      	ite	hi
 80041fc:	f103 32ff 	addhi.w	r2, r3, #4294967295
 8004200:	2200      	movls	r2, #0

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8004202:	2401      	movs	r4, #1
 8004204:	fa04 f301 	lsl.w	r3, r4, r1
 8004208:	3b01      	subs	r3, #1
 800420a:	f003 0330 	and.w	r3, r3, #48	; 0x30
 800420e:	4093      	lsls	r3, r2
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8004210:	009b      	lsls	r3, r3, #2
 8004212:	b2db      	uxtb	r3, r3
 8004214:	4a12      	ldr	r2, [pc, #72]	; (8004260 <xNetworkInterfaceInitialise+0xc8>)
 8004216:	f882 336c 	strb.w	r3, [r2, #876]	; 0x36c
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 800421a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800421e:	f8c2 318c 	str.w	r3, [r2, #396]	; 0x18c
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8004222:	60d3      	str	r3, [r2, #12]
 * transmit process in running state. The DMA then checks the TX list at the
 * current position for transmitting a frame.
 */
__STATIC_INLINE void XMC_ETH_MAC_EnableTx(XMC_ETH_MAC_t *const eth_mac)
{
  eth_mac->regs->OPERATION_MODE |= (uint32_t)ETH_OPERATION_MODE_ST_Msk;
 8004224:	480c      	ldr	r0, [pc, #48]	; (8004258 <xNetworkInterfaceInitialise+0xc0>)
 8004226:	6803      	ldr	r3, [r0, #0]
 8004228:	f241 0218 	movw	r2, #4120	; 0x1018
 800422c:	5899      	ldr	r1, [r3, r2]
 800422e:	f441 5100 	orr.w	r1, r1, #8192	; 0x2000
 8004232:	5099      	str	r1, [r3, r2]
  eth_mac->regs->MAC_CONFIGURATION |= (uint32_t)ETH_MAC_CONFIGURATION_TE_Msk;
 8004234:	6819      	ldr	r1, [r3, #0]
 8004236:	f041 0108 	orr.w	r1, r1, #8
 800423a:	6019      	str	r1, [r3, #0]
 * receive process in running state. The DMA then acquires the descriptor
 * from the receive list and processes the received frames.
 */
__STATIC_INLINE void XMC_ETH_MAC_EnableRx(XMC_ETH_MAC_t *const eth_mac)
{
  eth_mac->regs->OPERATION_MODE |= (uint32_t)ETH_OPERATION_MODE_SR_Msk;
 800423c:	6803      	ldr	r3, [r0, #0]
 800423e:	5899      	ldr	r1, [r3, r2]
 8004240:	f041 0102 	orr.w	r1, r1, #2
 8004244:	5099      	str	r1, [r3, r2]
  eth_mac->regs->MAC_CONFIGURATION |= (uint32_t)ETH_MAC_CONFIGURATION_RE_Msk;
 8004246:	681a      	ldr	r2, [r3, #0]
 8004248:	f042 0204 	orr.w	r2, r2, #4
 800424c:	601a      	str	r2, [r3, #0]

	/* Enable transmission and reception */
	XMC_ETH_MAC_EnableTx( &ethernet_mac_handle );
	XMC_ETH_MAC_EnableRx( &ethernet_mac_handle );
	/* Exit critical section */
	vPortExitCritical();
 800424e:	f7fd fdd9 	bl	8001e04 <vPortExitCritical>

    /* Return status */
	return xResult;
}
 8004252:	4620      	mov	r0, r4
 8004254:	bd38      	pop	{r3, r4, r5, pc}
 8004256:	bf00      	nop
 8004258:	2000d578 	.word	0x2000d578
 800425c:	e000ed00 	.word	0xe000ed00
 8004260:	e000e100 	.word	0xe000e100

08004264 <xNetworkInterfaceOutput>:
 *
 * <i>Imp Note:</i>
 *
 */
BaseType_t xNetworkInterfaceOutput( NetworkBufferDescriptor_t * const pxNetworkBuffer, BaseType_t xReleaseAfterSend )
{
 8004264:	b570      	push	{r4, r5, r6, lr}
 8004266:	4604      	mov	r4, r0
 8004268:	460e      	mov	r6, r1
    /* Local variables */
	NetworkBufferDescriptor_t * const pxDescriptor_l = pxNetworkBuffer;
	uint8_t * p_buffer_l = NULL;
    BaseType_t xReturn = pdFAIL;
    size_t frame_lenght_l = pxDescriptor_l->xDataLength;
 800426a:	69c5      	ldr	r5, [r0, #28]

	/* Open a do {} while ( 0 ) loop to be able to call break. */
	do
	{
        /* Check link status */
        link_status_l = XMC_ETH_PHY_GetLinkStatus( &ethernet_mac_handle, ETH_0_PHY_ADDR );
 800426c:	4828      	ldr	r0, [pc, #160]	; (8004310 <xNetworkInterfaceOutput+0xac>)
 800426e:	2100      	movs	r1, #0
 8004270:	f7fd fac0 	bl	80017f4 <XMC_ETH_PHY_GetLinkStatus>
		if( XMC_ETH_LINK_STATUS_UP == link_status_l )
 8004274:	2801      	cmp	r0, #1
 8004276:	d146      	bne.n	8004306 <xNetworkInterfaceOutput+0xa2>
		{/* Process data to be sent to Ethernet */
			/* Check the data size to be sent and decide transmission state */
			if( (frame_lenght_l > (size_t) XMC_ETH_MAC_BUF_SIZE) ||
 8004278:	1e6a      	subs	r2, r5, #1
 800427a:	f240 53f3 	movw	r3, #1523	; 0x5f3
 800427e:	429a      	cmp	r2, r3
 8004280:	d841      	bhi.n	8004306 <xNetworkInterfaceOutput+0xa2>
				xReturn = pdFAIL;
			}
			else
			{
				/* Take Mutex */
				xMutex = xSemaphoreTake( xEthTxEventMutex, portMAX_DELAY );
 8004282:	4b24      	ldr	r3, [pc, #144]	; (8004314 <xNetworkInterfaceOutput+0xb0>)
 8004284:	6818      	ldr	r0, [r3, #0]
 8004286:	f04f 31ff 	mov.w	r1, #4294967295
 800428a:	f7fe fc05 	bl	8002a98 <xQueueSemaphoreTake>
				if( pdTRUE == xMutex )
 800428e:	2801      	cmp	r0, #1
 8004290:	d139      	bne.n	8004306 <xNetworkInterfaceOutput+0xa2>
 * \par
 * The function checks if the TX descriptor is owned by the DMA.
 */
__STATIC_INLINE bool XMC_ETH_MAC_IsTxDescriptorOwnedByDma(XMC_ETH_MAC_t *const eth_mac)
{
  return ((eth_mac->tx_desc[eth_mac->tx_index].status & ETH_MAC_DMA_TDES0_OWN) != 0U);
 8004292:	4a1f      	ldr	r2, [pc, #124]	; (8004310 <xNetworkInterfaceOutput+0xac>)
 8004294:	f892 3026 	ldrb.w	r3, [r2, #38]	; 0x26
 8004298:	015b      	lsls	r3, r3, #5
 800429a:	6952      	ldr	r2, [r2, #20]
 800429c:	18d1      	adds	r1, r2, r3
				{
					/* Check the data size and get the DMA descriptor to send data */
					if( pdTRUE == XMC_ETH_MAC_IsTxDescriptorOwnedByDma( &ethernet_mac_handle ) )
 800429e:	58d3      	ldr	r3, [r2, r3]
 80042a0:	2b00      	cmp	r3, #0
 80042a2:	da0d      	bge.n	80042c0 <xNetworkInterfaceOutput+0x5c>
					{
						vReleaseNetworkBuffer( pxDescriptor_l->pucEthernetBuffer );
 80042a4:	69a0      	ldr	r0, [r4, #24]
 80042a6:	f000 f98b 	bl	80045c0 <vReleaseNetworkBuffer>
 * If that descriptor is not available (owned by the CPU), the transmission
 * returns to the suspend state else the transmission resumes.
 */
__STATIC_INLINE void XMC_ETH_MAC_ResumeTx(XMC_ETH_MAC_t *const eth_mac)
{
  eth_mac->regs->STATUS = (uint32_t)ETH_STATUS_TPS_Msk;
 80042aa:	4b19      	ldr	r3, [pc, #100]	; (8004310 <xNetworkInterfaceOutput+0xac>)
 80042ac:	681b      	ldr	r3, [r3, #0]
 80042ae:	2102      	movs	r1, #2
 80042b0:	f241 0214 	movw	r2, #4116	; 0x1014
 80042b4:	5099      	str	r1, [r3, r2]
  eth_mac->regs->TRANSMIT_POLL_DEMAND = 0U;
 80042b6:	2500      	movs	r5, #0
 80042b8:	f241 0204 	movw	r2, #4100	; 0x1004
 80042bc:	509d      	str	r5, [r3, r2]
 80042be:	e01a      	b.n	80042f6 <xNetworkInterfaceOutput+0x92>
 * \par<b>Description: </b><br>
 * Returns the current TX buffer.
 */
__STATIC_INLINE uint8_t *XMC_ETH_MAC_GetTxBuffer(XMC_ETH_MAC_t *const eth_mac)
{
  return (uint8_t *)(eth_mac->tx_desc[eth_mac->tx_index].buffer1);
 80042c0:	6888      	ldr	r0, [r1, #8]
 * \par<b>Description: </b><br>
 * Sets the current TX buffer size.
 */
__STATIC_INLINE void XMC_ETH_MAC_SetTxBufferSize(XMC_ETH_MAC_t *const eth_mac, uint32_t size)
{
  eth_mac->tx_desc[eth_mac->tx_index].length = size;
 80042c2:	604d      	str	r5, [r1, #4]
					{
						/* Get the buffer for transmission */
						p_buffer_l = XMC_ETH_MAC_GetTxBuffer( &ethernet_mac_handle );
						XMC_ETH_MAC_SetTxBufferSize( &ethernet_mac_handle, frame_lenght_l );
						/* Copy Network layer data into buffer and trigger transmission */
						memcpy( p_buffer_l, pxDescriptor_l->pucEthernetBuffer, frame_lenght_l );
 80042c4:	69a1      	ldr	r1, [r4, #24]
 80042c6:	462a      	mov	r2, r5
 80042c8:	f005 fe0c 	bl	8009ee4 <memcpy>
 * If that descriptor is not available (owned by the CPU), the transmission
 * returns to the suspend state else the transmission resumes.
 */
__STATIC_INLINE void XMC_ETH_MAC_ResumeTx(XMC_ETH_MAC_t *const eth_mac)
{
  eth_mac->regs->STATUS = (uint32_t)ETH_STATUS_TPS_Msk;
 80042cc:	4810      	ldr	r0, [pc, #64]	; (8004310 <xNetworkInterfaceOutput+0xac>)
 80042ce:	6803      	ldr	r3, [r0, #0]
 80042d0:	2102      	movs	r1, #2
 80042d2:	f241 0214 	movw	r2, #4116	; 0x1014
 80042d6:	5099      	str	r1, [r3, r2]
  eth_mac->regs->TRANSMIT_POLL_DEMAND = 0U;
 80042d8:	2100      	movs	r1, #0
 80042da:	f241 0204 	movw	r2, #4100	; 0x1004
 80042de:	5099      	str	r1, [r3, r2]
						XMC_ETH_MAC_ResumeTx( &ethernet_mac_handle );
						XMC_ETH_MAC_ReturnTxDescriptor( &ethernet_mac_handle );
 80042e0:	f7fd fa04 	bl	80016ec <XMC_ETH_MAC_ReturnTxDescriptor>

						/* Call the standard trace macro to log the send event */
						iptraceNETWORK_INTERFACE_TRANSMIT();

						/* Update return status */
						xReturn = pdTRUE;
 80042e4:	2501      	movs	r5, #1
 80042e6:	e006      	b.n	80042f6 <xNetworkInterfaceOutput+0x92>
    {
    	xSemaphoreGive( xEthTxEventMutex );
    }

	/* The buffer has been sent so can be released. */
	if( xReleaseAfterSend != pdFALSE )
 80042e8:	b17e      	cbz	r6, 800430a <xNetworkInterfaceOutput+0xa6>
	{
		pxDescriptor_l->pucEthernetBuffer = NULL;
 80042ea:	2300      	movs	r3, #0
 80042ec:	61a3      	str	r3, [r4, #24]
		vReleaseNetworkBufferAndDescriptor( pxDescriptor_l );
 80042ee:	4620      	mov	r0, r4
 80042f0:	f000 f96e 	bl	80045d0 <vReleaseNetworkBufferAndDescriptor>
 80042f4:	e009      	b.n	800430a <xNetworkInterfaceOutput+0xa6>
	} while( 0 );

	/* Give mutex back */
    if( pdTRUE == xMutex )
    {
    	xSemaphoreGive( xEthTxEventMutex );
 80042f6:	4b07      	ldr	r3, [pc, #28]	; (8004314 <xNetworkInterfaceOutput+0xb0>)
 80042f8:	6818      	ldr	r0, [r3, #0]
 80042fa:	2100      	movs	r1, #0
 80042fc:	460a      	mov	r2, r1
 80042fe:	460b      	mov	r3, r1
 8004300:	f7fe f976 	bl	80025f0 <xQueueGenericSend>
 8004304:	e7f0      	b.n	80042e8 <xNetworkInterfaceOutput+0x84>
 *
 * <i>Imp Note:</i>
 *
 */
BaseType_t xNetworkInterfaceOutput( NetworkBufferDescriptor_t * const pxNetworkBuffer, BaseType_t xReleaseAfterSend )
{
 8004306:	2500      	movs	r5, #0
 8004308:	e7ee      	b.n	80042e8 <xNetworkInterfaceOutput+0x84>
		vReleaseNetworkBufferAndDescriptor( pxDescriptor_l );
	}

    /* Return status */
	return xReturn;
}
 800430a:	4628      	mov	r0, r5
 800430c:	bd70      	pop	{r4, r5, r6, pc}
 800430e:	bf00      	nop
 8004310:	2000d578 	.word	0x2000d578
 8004314:	2000c9d8 	.word	0x2000c9d8

08004318 <xGetPhyLinkStatus>:
 *
 * <i>Imp Note:</i>
 *
 */
BaseType_t xGetPhyLinkStatus( void )
{
 8004318:	b508      	push	{r3, lr}
	return (XMC_ETH_LINK_STATUS_UP == XMC_ETH_PHY_GetLinkStatus( &ethernet_mac_handle, ETH_0_PHY_ADDR ));
 800431a:	4804      	ldr	r0, [pc, #16]	; (800432c <xGetPhyLinkStatus+0x14>)
 800431c:	2100      	movs	r1, #0
 800431e:	f7fd fa69 	bl	80017f4 <XMC_ETH_PHY_GetLinkStatus>
}
 8004322:	2801      	cmp	r0, #1
 8004324:	bf14      	ite	ne
 8004326:	2000      	movne	r0, #0
 8004328:	2001      	moveq	r0, #1
 800432a:	bd08      	pop	{r3, pc}
 800432c:	2000d578 	.word	0x2000d578

08004330 <initialize_ethernet_mac>:
 *
 * <i>Imp Note:</i>
 *
 */
BaseType_t initialize_ethernet_mac( void )
{
 8004330:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004332:	b085      	sub	sp, #20
    BaseType_t xResult = pdFAIL;
    /** Local Variables **/
	unsigned char count_outer_l = 0;

    /* Ethernet PHY configuration */
    const XMC_ETH_PHY_CONFIG_t eth_phy_config_l =
 8004334:	4a4f      	ldr	r2, [pc, #316]	; (8004474 <initialize_ethernet_mac+0x144>)
 8004336:	ab02      	add	r3, sp, #8
 8004338:	6810      	ldr	r0, [r2, #0]
 800433a:	6851      	ldr	r1, [r2, #4]
 800433c:	c303      	stmia	r3!, {r0, r1}
 800433e:	4b4e      	ldr	r3, [pc, #312]	; (8004478 <initialize_ethernet_mac+0x148>)
 8004340:	681a      	ldr	r2, [r3, #0]
 *
 */
__STATIC_INLINE void XMC_ETH_MAC_SetPortControl(XMC_ETH_MAC_t *const eth_mac, const XMC_ETH_MAC_PORT_CTRL_t port_ctrl)
{
  XMC_UNUSED_ARG(eth_mac);
  ETH0_CON->CON = (uint32_t)port_ctrl.raw;
 8004342:	4b4e      	ldr	r3, [pc, #312]	; (800447c <initialize_ethernet_mac+0x14c>)
 8004344:	601a      	str	r2, [r3, #0]
    };

    /* Set port control for EMAC */
    XMC_ETH_MAC_SetPortControl( &ethernet_mac_handle, port_control_l );

    XMC_ETH_MAC_Init( &ethernet_mac_handle );
 8004346:	4c4e      	ldr	r4, [pc, #312]	; (8004480 <initialize_ethernet_mac+0x150>)
 8004348:	4620      	mov	r0, r4
 800434a:	f7fd f92d 	bl	80015a8 <XMC_ETH_MAC_Init>
 * \par
 * The function can be used to disable jumbo frames.
 */
__STATIC_INLINE void XMC_ETH_MAC_DisableJumboFrame(XMC_ETH_MAC_t *const eth_mac)
{
  eth_mac->regs->MAC_CONFIGURATION &= (uint32_t)~ETH_MAC_CONFIGURATION_JE_Msk;
 800434e:	6822      	ldr	r2, [r4, #0]
 8004350:	6813      	ldr	r3, [r2, #0]
 8004352:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 8004356:	6013      	str	r3, [r2, #0]
 * \par
 * This function enables the AFM module to pass all received broadcast frames.
 */
__STATIC_INLINE void XMC_ETH_MAC_EnableReceptionBroadcastFrames(XMC_ETH_MAC_t *const eth_mac)
{
  eth_mac->regs->MAC_FRAME_FILTER &= (uint32_t)~ETH_MAC_FRAME_FILTER_DBF_Msk;
 8004358:	6822      	ldr	r2, [r4, #0]
 800435a:	6853      	ldr	r3, [r2, #4]
 800435c:	f023 0320 	bic.w	r3, r3, #32
 8004360:	6053      	str	r3, [r2, #4]
    XMC_ETH_MAC_DisableJumboFrame( &ethernet_mac_handle );
    XMC_ETH_MAC_EnableReceptionBroadcastFrames( &ethernet_mac_handle );

    /* Initialize PHY */
    if( XMC_ETH_PHY_STATUS_OK == XMC_ETH_PHY_Init( &ethernet_mac_handle, ETH_0_PHY_ADDR, &eth_phy_config_l ) )
 8004362:	4620      	mov	r0, r4
 8004364:	2100      	movs	r1, #0
 8004366:	aa02      	add	r2, sp, #8
 8004368:	f7fd f9f6 	bl	8001758 <XMC_ETH_PHY_Init>
 800436c:	2800      	cmp	r0, #0
 800436e:	d17c      	bne.n	800446a <initialize_ethernet_mac+0x13a>
 8004370:	4c44      	ldr	r4, [pc, #272]	; (8004484 <initialize_ethernet_mac+0x154>)
 8004372:	f504 55be 	add.w	r5, r4, #6080	; 0x17c0
 8004376:	3510      	adds	r5, #16
    {
        /* Initialize Network descriptor buffers */
        for( count_outer_l = 0; count_outer_l < ETH_0_NUM_TX_BUF; ++count_outer_l )
        {
        	memset( (uint8_t *) (ETH_0_tx_buf + count_outer_l), '\0', XMC_ETH_MAC_BUF_SIZE );
 8004378:	f240 57f4 	movw	r7, #1524	; 0x5f4
 800437c:	2600      	movs	r6, #0
 800437e:	4620      	mov	r0, r4
 8004380:	4631      	mov	r1, r6
 8004382:	463a      	mov	r2, r7
 8004384:	f005 fdda 	bl	8009f3c <memset>
 8004388:	f204 54f4 	addw	r4, r4, #1524	; 0x5f4

    /* Initialize PHY */
    if( XMC_ETH_PHY_STATUS_OK == XMC_ETH_PHY_Init( &ethernet_mac_handle, ETH_0_PHY_ADDR, &eth_phy_config_l ) )
    {
        /* Initialize Network descriptor buffers */
        for( count_outer_l = 0; count_outer_l < ETH_0_NUM_TX_BUF; ++count_outer_l )
 800438c:	42ac      	cmp	r4, r5
 800438e:	d1f6      	bne.n	800437e <initialize_ethernet_mac+0x4e>
 8004390:	4c3d      	ldr	r4, [pc, #244]	; (8004488 <initialize_ethernet_mac+0x158>)
 8004392:	f504 55be 	add.w	r5, r4, #6080	; 0x17c0
 8004396:	3510      	adds	r5, #16
        {
        	memset( (uint8_t *) (ETH_0_tx_buf + count_outer_l), '\0', XMC_ETH_MAC_BUF_SIZE );
        }
        for( count_outer_l = 0; count_outer_l < ETH_0_NUM_RX_BUF; ++count_outer_l )
        {
        	memset( (uint8_t *) (ETH_0_rx_buf + count_outer_l), '\0', XMC_ETH_MAC_BUF_SIZE );
 8004398:	f240 57f4 	movw	r7, #1524	; 0x5f4
 800439c:	2600      	movs	r6, #0
 800439e:	4620      	mov	r0, r4
 80043a0:	4631      	mov	r1, r6
 80043a2:	463a      	mov	r2, r7
 80043a4:	f005 fdca 	bl	8009f3c <memset>
 80043a8:	f204 54f4 	addw	r4, r4, #1524	; 0x5f4
        /* Initialize Network descriptor buffers */
        for( count_outer_l = 0; count_outer_l < ETH_0_NUM_TX_BUF; ++count_outer_l )
        {
        	memset( (uint8_t *) (ETH_0_tx_buf + count_outer_l), '\0', XMC_ETH_MAC_BUF_SIZE );
        }
        for( count_outer_l = 0; count_outer_l < ETH_0_NUM_RX_BUF; ++count_outer_l )
 80043ac:	42ac      	cmp	r4, r5
 80043ae:	d1f6      	bne.n	800439e <initialize_ethernet_mac+0x6e>
        {
        	memset( (uint8_t *) (ETH_0_rx_buf + count_outer_l), '\0', XMC_ETH_MAC_BUF_SIZE );
        }
        while( XMC_ETH_PHY_GetLinkStatus(&ethernet_mac_handle, ETH_0_PHY_ADDR) != XMC_ETH_LINK_STATUS_UP );
 80043b0:	4d33      	ldr	r5, [pc, #204]	; (8004480 <initialize_ethernet_mac+0x150>)
 80043b2:	2400      	movs	r4, #0
 80043b4:	4628      	mov	r0, r5
 80043b6:	4621      	mov	r1, r4
 80043b8:	f7fd fa1c 	bl	80017f4 <XMC_ETH_PHY_GetLinkStatus>
 80043bc:	2801      	cmp	r0, #1
 80043be:	d1f9      	bne.n	80043b4 <initialize_ethernet_mac+0x84>
    	/* PHY successfully initialized */

        /* Create Semaphore for EMAC Handler task */
        vSemaphoreCreateBinary( xEthRxEventSemaphore );
 80043c0:	2100      	movs	r1, #0
 80043c2:	2203      	movs	r2, #3
 80043c4:	f7fe f8b8 	bl	8002538 <xQueueGenericCreate>
 80043c8:	4b30      	ldr	r3, [pc, #192]	; (800448c <initialize_ethernet_mac+0x15c>)
 80043ca:	6018      	str	r0, [r3, #0]
 80043cc:	b120      	cbz	r0, 80043d8 <initialize_ethernet_mac+0xa8>
 80043ce:	2100      	movs	r1, #0
 80043d0:	460a      	mov	r2, r1
 80043d2:	460b      	mov	r3, r1
 80043d4:	f7fe f90c 	bl	80025f0 <xQueueGenericSend>
        xEthTxEventMutex = xSemaphoreCreateMutex();
 80043d8:	2001      	movs	r0, #1
 80043da:	f7fe f9cd 	bl	8002778 <xQueueCreateMutex>
 80043de:	4b2c      	ldr	r3, [pc, #176]	; (8004490 <initialize_ethernet_mac+0x160>)
 80043e0:	6018      	str	r0, [r3, #0]
        xEthRxEventMutex = xSemaphoreCreateMutex();
 80043e2:	2001      	movs	r0, #1
 80043e4:	f7fe f9c8 	bl	8002778 <xQueueCreateMutex>
 80043e8:	4b2a      	ldr	r3, [pc, #168]	; (8004494 <initialize_ethernet_mac+0x164>)
 80043ea:	6018      	str	r0, [r3, #0]
        configASSERT( xEthRxEventSemaphore );
 80043ec:	4b27      	ldr	r3, [pc, #156]	; (800448c <initialize_ethernet_mac+0x15c>)
 80043ee:	681b      	ldr	r3, [r3, #0]
 80043f0:	b943      	cbnz	r3, 8004404 <initialize_ethernet_mac+0xd4>
 80043f2:	f04f 0314 	mov.w	r3, #20
 80043f6:	f383 8811 	msr	BASEPRI, r3
 80043fa:	f3bf 8f6f 	isb	sy
 80043fe:	f3bf 8f4f 	dsb	sy
 8004402:	e7fe      	b.n	8004402 <initialize_ethernet_mac+0xd2>
        configASSERT( xEthTxEventMutex );
 8004404:	4b22      	ldr	r3, [pc, #136]	; (8004490 <initialize_ethernet_mac+0x160>)
 8004406:	681b      	ldr	r3, [r3, #0]
 8004408:	b943      	cbnz	r3, 800441c <initialize_ethernet_mac+0xec>
 800440a:	f04f 0314 	mov.w	r3, #20
 800440e:	f383 8811 	msr	BASEPRI, r3
 8004412:	f3bf 8f6f 	isb	sy
 8004416:	f3bf 8f4f 	dsb	sy
 800441a:	e7fe      	b.n	800441a <initialize_ethernet_mac+0xea>
        configASSERT( xEthRxEventMutex );
 800441c:	b940      	cbnz	r0, 8004430 <initialize_ethernet_mac+0x100>
 800441e:	f04f 0314 	mov.w	r3, #20
 8004422:	f383 8811 	msr	BASEPRI, r3
 8004426:	f3bf 8f6f 	isb	sy
 800442a:	f3bf 8f4f 	dsb	sy
 800442e:	e7fe      	b.n	800442e <initialize_ethernet_mac+0xfe>

        /* Create EMAC handler Task to process received frames */
        xResult = xTaskCreate( prvEMACHandlerTask, "EMAC Task", configEMAC_TASK_STACK_SIZE,
 8004430:	2302      	movs	r3, #2
 8004432:	9300      	str	r3, [sp, #0]
 8004434:	4b18      	ldr	r3, [pc, #96]	; (8004498 <initialize_ethernet_mac+0x168>)
 8004436:	9301      	str	r3, [sp, #4]
 8004438:	4818      	ldr	r0, [pc, #96]	; (800449c <initialize_ethernet_mac+0x16c>)
 800443a:	4919      	ldr	r1, [pc, #100]	; (80044a0 <initialize_ethernet_mac+0x170>)
 800443c:	22f0      	movs	r2, #240	; 0xf0
 800443e:	2300      	movs	r3, #0
 8004440:	f7fe fd10 	bl	8002e64 <xTaskCreate>
 8004444:	4604      	mov	r4, r0
        		NULL, configEMAC_TASK_PRIORITY, &xEMACTaskHandle );
        /* Check return status */
        if( xResult != pdTRUE )
 8004446:	2801      	cmp	r0, #1
 8004448:	d010      	beq.n	800446c <initialize_ethernet_mac+0x13c>
        {
        	vSemaphoreDelete( xEthRxEventSemaphore );
 800444a:	4b10      	ldr	r3, [pc, #64]	; (800448c <initialize_ethernet_mac+0x15c>)
 800444c:	6818      	ldr	r0, [r3, #0]
 800444e:	f7fe fc39 	bl	8002cc4 <vQueueDelete>
        	vSemaphoreDelete( xEthTxEventMutex );
 8004452:	4b0f      	ldr	r3, [pc, #60]	; (8004490 <initialize_ethernet_mac+0x160>)
 8004454:	6818      	ldr	r0, [r3, #0]
 8004456:	f7fe fc35 	bl	8002cc4 <vQueueDelete>
			vSemaphoreDelete( xEthRxEventMutex );
 800445a:	4b0e      	ldr	r3, [pc, #56]	; (8004494 <initialize_ethernet_mac+0x164>)
 800445c:	6818      	ldr	r0, [r3, #0]
 800445e:	f7fe fc31 	bl	8002cc4 <vQueueDelete>
        	/* Free Resources */
        	vTaskDelete( NULL );
 8004462:	2000      	movs	r0, #0
 8004464:	f7fe fdf0 	bl	8003048 <vTaskDelete>
 8004468:	e000      	b.n	800446c <initialize_ethernet_mac+0x13c>
 *
 */
BaseType_t initialize_ethernet_mac( void )
{
    /* Local Variables */
    BaseType_t xResult = pdFAIL;
 800446a:	2400      	movs	r4, #0
        	vTaskDelete( NULL );
        }
    }

    return xResult;
}
 800446c:	4620      	mov	r0, r4
 800446e:	b005      	add	sp, #20
 8004470:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004472:	bf00      	nop
 8004474:	0800ab60 	.word	0x0800ab60
 8004478:	0800ab68 	.word	0x0800ab68
 800447c:	50004040 	.word	0x50004040
 8004480:	2000d578 	.word	0x2000d578
 8004484:	30000000 	.word	0x30000000
 8004488:	300017d0 	.word	0x300017d0
 800448c:	2000c9dc 	.word	0x2000c9dc
 8004490:	2000c9d8 	.word	0x2000c9d8
 8004494:	2000c9d4 	.word	0x2000c9d4
 8004498:	2000c9cc 	.word	0x2000c9cc
 800449c:	080040a1 	.word	0x080040a1
 80044a0:	0800ab6c 	.word	0x0800ab6c

080044a4 <vApplicationIPNetworkEventHook>:
 * <i>Imp Note:</i>
 *
 */
void vApplicationIPNetworkEventHook( eIPCallbackEvent_t eNetworkEvent )
{
	switch( eNetworkEvent )
 80044a4:	2801      	cmp	r0, #1
 80044a6:	d117      	bne.n	80044d8 <vApplicationIPNetworkEventHook+0x34>
 *
 * <i>Imp Note:</i>
 *
 */
void vApplicationIPNetworkEventHook( eIPCallbackEvent_t eNetworkEvent )
{
 80044a8:	b538      	push	{r3, r4, r5, lr}
		case eNetworkUp:
		break;

		case eNetworkDown:
			/* Get link status, TODO: Note: Time Consuming for hooks */
			if( 1 == xGetPhyLinkStatus() )
 80044aa:	f7ff ff35 	bl	8004318 <xGetPhyLinkStatus>
 80044ae:	2801      	cmp	r0, #1
 80044b0:	d111      	bne.n	80044d6 <vApplicationIPNetworkEventHook+0x32>
			{
    			/* Set network speed and set it up */
    			XMC_ETH_MAC_SetLink( &ethernet_mac_handle,
 80044b2:	4d0a      	ldr	r5, [pc, #40]	; (80044dc <vApplicationIPNetworkEventHook+0x38>)
 80044b4:	4628      	mov	r0, r5
 80044b6:	2100      	movs	r1, #0
 80044b8:	f7fd f9aa 	bl	8001810 <XMC_ETH_PHY_GetLinkSpeed>
 80044bc:	4604      	mov	r4, r0
 80044be:	4628      	mov	r0, r5
 80044c0:	2100      	movs	r1, #0
 80044c2:	f7fd f9b9 	bl	8001838 <XMC_ETH_PHY_GetLinkDuplex>
 */
__STATIC_INLINE void XMC_ETH_MAC_SetLink(XMC_ETH_MAC_t *const eth_mac,
                                         XMC_ETH_LINK_SPEED_t speed,
                                         XMC_ETH_LINK_DUPLEX_t duplex)
{
  eth_mac->regs->MAC_CONFIGURATION = (eth_mac->regs->MAC_CONFIGURATION &
 80044c6:	682a      	ldr	r2, [r5, #0]
 80044c8:	6813      	ldr	r3, [r2, #0]
 80044ca:	4320      	orrs	r0, r4
 80044cc:	b280      	uxth	r0, r0
 80044ce:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
                                      (uint32_t)~(ETH_MAC_CONFIGURATION_DM_Msk | ETH_MAC_CONFIGURATION_FES_Msk)) |
                                     (uint32_t)speed | (uint32_t)duplex;
 80044d2:	4303      	orrs	r3, r0
 */
__STATIC_INLINE void XMC_ETH_MAC_SetLink(XMC_ETH_MAC_t *const eth_mac,
                                         XMC_ETH_LINK_SPEED_t speed,
                                         XMC_ETH_LINK_DUPLEX_t duplex)
{
  eth_mac->regs->MAC_CONFIGURATION = (eth_mac->regs->MAC_CONFIGURATION &
 80044d4:	6013      	str	r3, [r2, #0]
 80044d6:	bd38      	pop	{r3, r4, r5, pc}
 80044d8:	4770      	bx	lr
 80044da:	bf00      	nop
 80044dc:	2000d578 	.word	0x2000d578

080044e0 <vApplicationPingReplyHook>:
#endif

#if (ipconfigSUPPORT_OUTGOING_PINGS == 1)

void vApplicationPingReplyHook( ePingReplyStatus_t eStatus, uint16_t usIdentifier )
{
 80044e0:	4770      	bx	lr
 80044e2:	bf00      	nop

080044e4 <ETH0_0_IRQHandler>:
 * <i>Imp Note:</i>
 * 				can be named as IRQ_Hdlr_108 also
 *
 */
void ETH0_0_IRQHandler( void )
{
 80044e4:	b500      	push	{lr}
 80044e6:	b083      	sub	sp, #12
	/* Local variables */
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
 80044e8:	2300      	movs	r3, #0
 80044ea:	9301      	str	r3, [sp, #4]
	static unsigned long status_l = 0;

	if( xEMACTaskHandle != NULL )
 80044ec:	4b10      	ldr	r3, [pc, #64]	; (8004530 <ETH0_0_IRQHandler+0x4c>)
 80044ee:	681b      	ldr	r3, [r3, #0]
 80044f0:	b1d3      	cbz	r3, 8004528 <ETH0_0_IRQHandler+0x44>
	{
		/* Get Event status */
		status_l = XMC_ETH_MAC_GetEventStatus( &ethernet_mac_handle );
 80044f2:	4810      	ldr	r0, [pc, #64]	; (8004534 <ETH0_0_IRQHandler+0x50>)
 80044f4:	f7fd f8d8 	bl	80016a8 <XMC_ETH_MAC_GetEventStatus>
 80044f8:	4b0f      	ldr	r3, [pc, #60]	; (8004538 <ETH0_0_IRQHandler+0x54>)
 80044fa:	6018      	str	r0, [r3, #0]
		/* Check for receive status */
		if( status_l & XMC_ETH_MAC_EVENT_RECEIVE )
 80044fc:	f010 0f40 	tst.w	r0, #64	; 0x40
 8004500:	d004      	beq.n	800450c <ETH0_0_IRQHandler+0x28>
		{
			/* Trigger semaphore indicating that some data has been received using FromISR */
			xSemaphoreGiveFromISR( xEthRxEventSemaphore, &xHigherPriorityTaskWoken );
 8004502:	4b0e      	ldr	r3, [pc, #56]	; (800453c <ETH0_0_IRQHandler+0x58>)
 8004504:	6818      	ldr	r0, [r3, #0]
 8004506:	a901      	add	r1, sp, #4
 8004508:	f7fe f9ba 	bl	8002880 <xQueueGiveFromISR>
		}

		/* Clear Interrupt Flag */
		XMC_ETH_MAC_ClearEventStatus( &ethernet_mac_handle, XMC_ETH_MAC_EVENT_RECEIVE );
 800450c:	4809      	ldr	r0, [pc, #36]	; (8004534 <ETH0_0_IRQHandler+0x50>)
 800450e:	2140      	movs	r1, #64	; 0x40
 8004510:	f7fd f8b2 	bl	8001678 <XMC_ETH_MAC_ClearEventStatus>

	    /* Can call user defined callback function from here to process some other things */

		/* Leave ISR */
	    portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
 8004514:	9b01      	ldr	r3, [sp, #4]
 8004516:	b13b      	cbz	r3, 8004528 <ETH0_0_IRQHandler+0x44>
 8004518:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800451c:	4b08      	ldr	r3, [pc, #32]	; (8004540 <ETH0_0_IRQHandler+0x5c>)
 800451e:	601a      	str	r2, [r3, #0]
 8004520:	f3bf 8f4f 	dsb	sy
 8004524:	f3bf 8f6f 	isb	sy
	}
}
 8004528:	b003      	add	sp, #12
 800452a:	f85d fb04 	ldr.w	pc, [sp], #4
 800452e:	bf00      	nop
 8004530:	2000c9cc 	.word	0x2000c9cc
 8004534:	2000d578 	.word	0x2000d578
 8004538:	2000c9d0 	.word	0x2000c9d0
 800453c:	2000c9dc 	.word	0x2000c9dc
 8004540:	e000ed04 	.word	0xe000ed04

08004544 <xNetworkBuffersInitialise>:
static SemaphoreHandle_t xNetworkBufferSemaphore = NULL;

/*-----------------------------------------------------------*/

BaseType_t xNetworkBuffersInitialise( void )
{
 8004544:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
BaseType_t xReturn;
uint32_t x;

	/* Only initialise the buffers and their associated kernel objects if they
	have not been initialised before. */
	if( xNetworkBufferSemaphore == NULL )
 8004546:	4b19      	ldr	r3, [pc, #100]	; (80045ac <xNetworkBuffersInitialise+0x68>)
 8004548:	681b      	ldr	r3, [r3, #0]
 800454a:	bb4b      	cbnz	r3, 80045a0 <xNetworkBuffersInitialise+0x5c>
	{
		xNetworkBufferSemaphore = xSemaphoreCreateCounting( ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS, ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS );
 800454c:	203c      	movs	r0, #60	; 0x3c
 800454e:	4601      	mov	r1, r0
 8004550:	f7fe f82e 	bl	80025b0 <xQueueCreateCountingSemaphore>
 8004554:	4b15      	ldr	r3, [pc, #84]	; (80045ac <xNetworkBuffersInitialise+0x68>)
 8004556:	6018      	str	r0, [r3, #0]
		configASSERT( xNetworkBufferSemaphore != NULL );
 8004558:	b940      	cbnz	r0, 800456c <xNetworkBuffersInitialise+0x28>
 800455a:	f04f 0314 	mov.w	r3, #20
 800455e:	f383 8811 	msr	BASEPRI, r3
 8004562:	f3bf 8f6f 	isb	sy
 8004566:	f3bf 8f4f 	dsb	sy
 800456a:	e7fe      	b.n	800456a <xNetworkBuffersInitialise+0x26>

		if( xNetworkBufferSemaphore != NULL )
		{
			#if ( configQUEUE_REGISTRY_SIZE > 0 )
			{
				vQueueAddToRegistry( xNetworkBufferSemaphore, "NetBufSem" );
 800456c:	4910      	ldr	r1, [pc, #64]	; (80045b0 <xNetworkBuffersInitialise+0x6c>)
 800456e:	f7fe fb75 	bl	8002c5c <vQueueAddToRegistry>
				vTraceSetQueueName( xNetworkEventQueue, "IPStackEvent" );
				vTraceSetQueueName( xNetworkBufferSemaphore, "NetworkBufferCount" );
			}
			#endif /*  ipconfigINCLUDE_EXAMPLE_FREERTOS_PLUS_TRACE_CALLS == 1 */

			vListInitialise( &xFreeBuffersList );
 8004572:	4810      	ldr	r0, [pc, #64]	; (80045b4 <xNetworkBuffersInitialise+0x70>)
 8004574:	f7fd feba 	bl	80022ec <vListInitialise>
 8004578:	4c0f      	ldr	r4, [pc, #60]	; (80045b8 <xNetworkBuffersInitialise+0x74>)
 800457a:	f504 6707 	add.w	r7, r4, #2160	; 0x870
			/* Initialise all the network buffers.  No storage is allocated to
			the buffers yet. */
			for( x = 0U; x < ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS; x++ )
			{
				/* Initialise and set the owner of the buffer list items. */
				xNetworkBufferDescriptors[ x ].pucEthernetBuffer = NULL;
 800457e:	2600      	movs	r6, #0
				vListInitialiseItem( &( xNetworkBufferDescriptors[ x ].xBufferListItem ) );
				listSET_LIST_ITEM_OWNER( &( xNetworkBufferDescriptors[ x ].xBufferListItem ), &xNetworkBufferDescriptors[ x ] );

				/* Currently, all buffers are available for use. */
				vListInsert( &xFreeBuffersList, &( xNetworkBufferDescriptors[ x ].xBufferListItem ) );
 8004580:	4d0c      	ldr	r5, [pc, #48]	; (80045b4 <xNetworkBuffersInitialise+0x70>)
			/* Initialise all the network buffers.  No storage is allocated to
			the buffers yet. */
			for( x = 0U; x < ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS; x++ )
			{
				/* Initialise and set the owner of the buffer list items. */
				xNetworkBufferDescriptors[ x ].pucEthernetBuffer = NULL;
 8004582:	61a6      	str	r6, [r4, #24]
				vListInitialiseItem( &( xNetworkBufferDescriptors[ x ].xBufferListItem ) );
 8004584:	4620      	mov	r0, r4
 8004586:	f7fd febd 	bl	8002304 <vListInitialiseItem>
				listSET_LIST_ITEM_OWNER( &( xNetworkBufferDescriptors[ x ].xBufferListItem ), &xNetworkBufferDescriptors[ x ] );
 800458a:	60e4      	str	r4, [r4, #12]

				/* Currently, all buffers are available for use. */
				vListInsert( &xFreeBuffersList, &( xNetworkBufferDescriptors[ x ].xBufferListItem ) );
 800458c:	4628      	mov	r0, r5
 800458e:	4621      	mov	r1, r4
 8004590:	f7fd fec8 	bl	8002324 <vListInsert>
 8004594:	3424      	adds	r4, #36	; 0x24

			vListInitialise( &xFreeBuffersList );

			/* Initialise all the network buffers.  No storage is allocated to
			the buffers yet. */
			for( x = 0U; x < ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS; x++ )
 8004596:	42bc      	cmp	r4, r7
 8004598:	d1f3      	bne.n	8004582 <xNetworkBuffersInitialise+0x3e>

				/* Currently, all buffers are available for use. */
				vListInsert( &xFreeBuffersList, &( xNetworkBufferDescriptors[ x ].xBufferListItem ) );
			}

			uxMinimumFreeNetworkBuffers = ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS;
 800459a:	223c      	movs	r2, #60	; 0x3c
 800459c:	4b07      	ldr	r3, [pc, #28]	; (80045bc <xNetworkBuffersInitialise+0x78>)
 800459e:	601a      	str	r2, [r3, #0]
		}
	}

	if( xNetworkBufferSemaphore == NULL )
 80045a0:	4b02      	ldr	r3, [pc, #8]	; (80045ac <xNetworkBuffersInitialise+0x68>)
 80045a2:	6818      	ldr	r0, [r3, #0]
	{
		xReturn = pdPASS;
	}

	return xReturn;
}
 80045a4:	3000      	adds	r0, #0
 80045a6:	bf18      	it	ne
 80045a8:	2001      	movne	r0, #1
 80045aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80045ac:	2000d250 	.word	0x2000d250
 80045b0:	0800ab78 	.word	0x0800ab78
 80045b4:	2000d254 	.word	0x2000d254
 80045b8:	2000c9e0 	.word	0x2000c9e0
 80045bc:	2000d268 	.word	0x2000d268

080045c0 <vReleaseNetworkBuffer>:
void vReleaseNetworkBuffer( uint8_t *pucEthernetBuffer )
{
	/* There is space before the Ethernet buffer in which a pointer to the
	network buffer that references this Ethernet buffer is stored.  Remove the
	space before freeing the buffer. */
	if( pucEthernetBuffer != NULL )
 80045c0:	b120      	cbz	r0, 80045cc <vReleaseNetworkBuffer+0xc>
	return pucEthernetBuffer;
}
/*-----------------------------------------------------------*/

void vReleaseNetworkBuffer( uint8_t *pucEthernetBuffer )
{
 80045c2:	b508      	push	{r3, lr}
	network buffer that references this Ethernet buffer is stored.  Remove the
	space before freeing the buffer. */
	if( pucEthernetBuffer != NULL )
	{
		pucEthernetBuffer -= ipBUFFER_PADDING;
		vPortFree( ( void * ) pucEthernetBuffer );
 80045c4:	380a      	subs	r0, #10
 80045c6:	f7ff fd2d 	bl	8004024 <vPortFree>
 80045ca:	bd08      	pop	{r3, pc}
 80045cc:	4770      	bx	lr
 80045ce:	bf00      	nop

080045d0 <vReleaseNetworkBufferAndDescriptor>:
	return pxReturn;
}
/*-----------------------------------------------------------*/

void vReleaseNetworkBufferAndDescriptor( NetworkBufferDescriptor_t * const pxNetworkBuffer )
{
 80045d0:	b510      	push	{r4, lr}
 80045d2:	4604      	mov	r4, r0
	/* Ensure the buffer is returned to the list of free buffers before the
	counting semaphore is 'given' to say a buffer is available.  Release the
	storage allocated to the buffer payload.  THIS FILE SHOULD NOT BE USED
	IF THE PROJECT INCLUDES A MEMORY ALLOCATOR THAT WILL FRAGMENT THE HEAP
	MEMORY.  For example, heap_2 must not be used, heap_4 can be used. */
	vReleaseNetworkBuffer( pxNetworkBuffer->pucEthernetBuffer );
 80045d4:	6980      	ldr	r0, [r0, #24]
 80045d6:	f7ff fff3 	bl	80045c0 <vReleaseNetworkBuffer>
	pxNetworkBuffer->pucEthernetBuffer = NULL;
 80045da:	2300      	movs	r3, #0
 80045dc:	61a3      	str	r3, [r4, #24]

	taskENTER_CRITICAL();
 80045de:	f7fd fbef 	bl	8001dc0 <vPortEnterCritical>
	{
		xListItemAlreadyInFreeList = listIS_CONTAINED_WITHIN( &xFreeBuffersList, &( pxNetworkBuffer->xBufferListItem ) );

		if( xListItemAlreadyInFreeList == pdFALSE )
 80045e2:	6922      	ldr	r2, [r4, #16]
 80045e4:	4b09      	ldr	r3, [pc, #36]	; (800460c <vReleaseNetworkBufferAndDescriptor+0x3c>)
 80045e6:	429a      	cmp	r2, r3
 80045e8:	d00d      	beq.n	8004606 <vReleaseNetworkBufferAndDescriptor+0x36>
		{
			vListInsertEnd( &xFreeBuffersList, &( pxNetworkBuffer->xBufferListItem ) );
 80045ea:	4618      	mov	r0, r3
 80045ec:	4621      	mov	r1, r4
 80045ee:	f7fd fe8d 	bl	800230c <vListInsertEnd>
		}
	}
	taskEXIT_CRITICAL();
 80045f2:	f7fd fc07 	bl	8001e04 <vPortExitCritical>
	 * Update the network state machine, unless the program fails to release its 'xNetworkBufferSemaphore'.
	 * The program should only try to release its semaphore if 'xListItemAlreadyInFreeList' is false.
	 */
	if( xListItemAlreadyInFreeList == pdFALSE )
	{
		if ( xSemaphoreGive( xNetworkBufferSemaphore ) == pdTRUE )
 80045f6:	4b06      	ldr	r3, [pc, #24]	; (8004610 <vReleaseNetworkBufferAndDescriptor+0x40>)
 80045f8:	6818      	ldr	r0, [r3, #0]
 80045fa:	2100      	movs	r1, #0
 80045fc:	460a      	mov	r2, r1
 80045fe:	460b      	mov	r3, r1
 8004600:	f7fd fff6 	bl	80025f0 <xQueueGenericSend>
 8004604:	bd10      	pop	{r4, pc}
		if( xListItemAlreadyInFreeList == pdFALSE )
		{
			vListInsertEnd( &xFreeBuffersList, &( pxNetworkBuffer->xBufferListItem ) );
		}
	}
	taskEXIT_CRITICAL();
 8004606:	f7fd fbfd 	bl	8001e04 <vPortExitCritical>
 800460a:	bd10      	pop	{r4, pc}
 800460c:	2000d254 	.word	0x2000d254
 8004610:	2000d250 	.word	0x2000d250

08004614 <pxGetNetworkBufferWithDescriptor>:
	}
}
/*-----------------------------------------------------------*/

NetworkBufferDescriptor_t *pxGetNetworkBufferWithDescriptor( size_t xRequestedSizeBytes, TickType_t xBlockTimeTicks )
{
 8004614:	b570      	push	{r4, r5, r6, lr}
NetworkBufferDescriptor_t *pxReturn = NULL;
size_t uxCount;

	if( xNetworkBufferSemaphore != NULL )
 8004616:	4b24      	ldr	r3, [pc, #144]	; (80046a8 <pxGetNetworkBufferWithDescriptor+0x94>)
 8004618:	681b      	ldr	r3, [r3, #0]
 800461a:	2b00      	cmp	r3, #0
 800461c:	d03e      	beq.n	800469c <pxGetNetworkBufferWithDescriptor+0x88>
	{
		if( ( xRequestedSizeBytes != 0U ) && ( xRequestedSizeBytes < ( size_t ) baMINIMAL_BUFFER_SIZE ) )
 800461e:	1e42      	subs	r2, r0, #1
 8004620:	2a44      	cmp	r2, #68	; 0x44
 8004622:	d907      	bls.n	8004634 <pxGetNetworkBufferWithDescriptor+0x20>
			xRequestedSizeBytes = baMINIMAL_BUFFER_SIZE;
		}

		/* Add 2 bytes to xRequestedSizeBytes and round up xRequestedSizeBytes
		to the nearest multiple of N bytes, where N equals 'sizeof( size_t )'. */
		xRequestedSizeBytes += 2U;
 8004624:	1c85      	adds	r5, r0, #2
		if( ( xRequestedSizeBytes & ( sizeof( size_t ) - 1U ) ) != 0U )
 8004626:	f015 0f03 	tst.w	r5, #3
 800462a:	d004      	beq.n	8004636 <pxGetNetworkBufferWithDescriptor+0x22>
		{
			xRequestedSizeBytes = ( xRequestedSizeBytes | ( sizeof( size_t ) - 1U ) ) + 1U;
 800462c:	f045 0503 	orr.w	r5, r5, #3
 8004630:	3501      	adds	r5, #1
 8004632:	e000      	b.n	8004636 <pxGetNetworkBufferWithDescriptor+0x22>
			xRequestedSizeBytes = baMINIMAL_BUFFER_SIZE;
		}

		/* Add 2 bytes to xRequestedSizeBytes and round up xRequestedSizeBytes
		to the nearest multiple of N bytes, where N equals 'sizeof( size_t )'. */
		xRequestedSizeBytes += 2U;
 8004634:	2548      	movs	r5, #72	; 0x48
		{
			xRequestedSizeBytes = ( xRequestedSizeBytes | ( sizeof( size_t ) - 1U ) ) + 1U;
		}

		/* If there is a semaphore available, there is a network buffer available. */
		if( xSemaphoreTake( xNetworkBufferSemaphore, xBlockTimeTicks ) == pdPASS )
 8004636:	4618      	mov	r0, r3
 8004638:	f7fe fa2e 	bl	8002a98 <xQueueSemaphoreTake>
 800463c:	2801      	cmp	r0, #1
 800463e:	d12f      	bne.n	80046a0 <pxGetNetworkBufferWithDescriptor+0x8c>
		{
			/* Protect the structure as it is accessed from tasks and interrupts. */
			taskENTER_CRITICAL();
 8004640:	f7fd fbbe 	bl	8001dc0 <vPortEnterCritical>
			{
				pxReturn = ( NetworkBufferDescriptor_t * ) listGET_OWNER_OF_HEAD_ENTRY( &xFreeBuffersList );
 8004644:	4e19      	ldr	r6, [pc, #100]	; (80046ac <pxGetNetworkBufferWithDescriptor+0x98>)
 8004646:	68f3      	ldr	r3, [r6, #12]
 8004648:	68dc      	ldr	r4, [r3, #12]
				( void ) uxListRemove( &( pxReturn->xBufferListItem ) );
 800464a:	4620      	mov	r0, r4
 800464c:	f7fd fe84 	bl	8002358 <uxListRemove>
			}
			taskEXIT_CRITICAL();
 8004650:	f7fd fbd8 	bl	8001e04 <vPortExitCritical>

			/* Reading UBaseType_t, no critical section needed. */
			uxCount = listCURRENT_LIST_LENGTH( &xFreeBuffersList );
 8004654:	6833      	ldr	r3, [r6, #0]

			if( uxMinimumFreeNetworkBuffers > uxCount )
 8004656:	4a16      	ldr	r2, [pc, #88]	; (80046b0 <pxGetNetworkBufferWithDescriptor+0x9c>)
 8004658:	6812      	ldr	r2, [r2, #0]
 800465a:	4293      	cmp	r3, r2
			{
				uxMinimumFreeNetworkBuffers = uxCount;
 800465c:	bf3c      	itt	cc
 800465e:	4a14      	ldrcc	r2, [pc, #80]	; (80046b0 <pxGetNetworkBufferWithDescriptor+0x9c>)
 8004660:	6013      	strcc	r3, [r2, #0]
			}

			/* Allocate storage of exactly the requested size to the buffer. */
			configASSERT( pxReturn->pucEthernetBuffer == NULL );
 8004662:	69a3      	ldr	r3, [r4, #24]
 8004664:	b143      	cbz	r3, 8004678 <pxGetNetworkBufferWithDescriptor+0x64>
 8004666:	f04f 0314 	mov.w	r3, #20
 800466a:	f383 8811 	msr	BASEPRI, r3
 800466e:	f3bf 8f6f 	isb	sy
 8004672:	f3bf 8f4f 	dsb	sy
 8004676:	e7fe      	b.n	8004676 <pxGetNetworkBufferWithDescriptor+0x62>
			if( xRequestedSizeBytes > 0U )
 8004678:	b19d      	cbz	r5, 80046a2 <pxGetNetworkBufferWithDescriptor+0x8e>
			{
				/* Extra space is obtained so a pointer to the network buffer can
				be stored at the beginning of the buffer. */
				pxReturn->pucEthernetBuffer = ( uint8_t * ) pvPortMalloc( xRequestedSizeBytes + ipBUFFER_PADDING );
 800467a:	f105 000a 	add.w	r0, r5, #10
 800467e:	f7ff fc2d 	bl	8003edc <pvPortMalloc>
 8004682:	61a0      	str	r0, [r4, #24]

				if( pxReturn->pucEthernetBuffer == NULL )
 8004684:	b920      	cbnz	r0, 8004690 <pxGetNetworkBufferWithDescriptor+0x7c>
				{
					/* The attempt to allocate storage for the buffer payload failed,
					so the network buffer structure cannot be used and must be
					released. */
					vReleaseNetworkBufferAndDescriptor( pxReturn );
 8004686:	4620      	mov	r0, r4
 8004688:	f7ff ffa2 	bl	80045d0 <vReleaseNetworkBufferAndDescriptor>
					pxReturn = NULL;
 800468c:	2400      	movs	r4, #0
 800468e:	e008      	b.n	80046a2 <pxGetNetworkBufferWithDescriptor+0x8e>
				{
					/* Store a pointer to the network buffer structure in the
					buffer storage area, then move the buffer pointer on past the
					stored pointer so the pointer value is not overwritten by the
					application when the buffer is used. */
					*( ( NetworkBufferDescriptor_t ** ) ( pxReturn->pucEthernetBuffer ) ) = pxReturn;
 8004690:	6004      	str	r4, [r0, #0]
					pxReturn->pucEthernetBuffer += ipBUFFER_PADDING;
 8004692:	69a3      	ldr	r3, [r4, #24]
 8004694:	330a      	adds	r3, #10
 8004696:	61a3      	str	r3, [r4, #24]

					/* Store the actual size of the allocated buffer, which may be
					greater than the original requested size. */
					pxReturn->xDataLength = xRequestedSizeBytes;
 8004698:	61e5      	str	r5, [r4, #28]
 800469a:	e002      	b.n	80046a2 <pxGetNetworkBufferWithDescriptor+0x8e>
}
/*-----------------------------------------------------------*/

NetworkBufferDescriptor_t *pxGetNetworkBufferWithDescriptor( size_t xRequestedSizeBytes, TickType_t xBlockTimeTicks )
{
NetworkBufferDescriptor_t *pxReturn = NULL;
 800469c:	2400      	movs	r4, #0
 800469e:	e000      	b.n	80046a2 <pxGetNetworkBufferWithDescriptor+0x8e>
 80046a0:	2400      	movs	r4, #0
		/* No action. */
		iptraceNETWORK_BUFFER_OBTAINED( pxReturn );
	}

	return pxReturn;
}
 80046a2:	4620      	mov	r0, r4
 80046a4:	bd70      	pop	{r4, r5, r6, pc}
 80046a6:	bf00      	nop
 80046a8:	2000d250 	.word	0x2000d250
 80046ac:	2000d254 	.word	0x2000d254
 80046b0:	2000d268 	.word	0x2000d268

080046b4 <vARPRefreshCacheEntry>:

#endif	/* ipconfigUSE_ARP_REMOVE_ENTRY != 0 */
/*-----------------------------------------------------------*/

void vARPRefreshCacheEntry( const MACAddress_t * pxMACAddress, const uint32_t ulIPAddress )
{
 80046b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80046b8:	b083      	sub	sp, #12

#if( ipconfigARP_STORES_REMOTE_ADDRESSES == 0 )
	/* Only process the IP address if it is on the local network.
	Unless: when '*ipLOCAL_IP_ADDRESS_POINTER' equals zero, the IP-address
	and netmask are still unknown. */
	if( ( ( ulIPAddress & xNetworkAddressing.ulNetMask ) == ( ( *ipLOCAL_IP_ADDRESS_POINTER ) & xNetworkAddressing.ulNetMask ) ) ||
 80046ba:	4b47      	ldr	r3, [pc, #284]	; (80047d8 <vARPRefreshCacheEntry+0x124>)
 80046bc:	695b      	ldr	r3, [r3, #20]
 80046be:	ea81 0403 	eor.w	r4, r1, r3
 80046c2:	4a46      	ldr	r2, [pc, #280]	; (80047dc <vARPRefreshCacheEntry+0x128>)
 80046c4:	6852      	ldr	r2, [r2, #4]
 80046c6:	4214      	tst	r4, r2
 80046c8:	d002      	beq.n	80046d0 <vARPRefreshCacheEntry+0x1c>
 80046ca:	2b00      	cmp	r3, #0
 80046cc:	f040 8081 	bne.w	80047d2 <vARPRefreshCacheEntry+0x11e>
 80046d0:	460f      	mov	r7, r1
 80046d2:	4606      	mov	r6, r0
 80046d4:	4c42      	ldr	r4, [pc, #264]	; (80047e0 <vARPRefreshCacheEntry+0x12c>)

#endif	/* ipconfigUSE_ARP_REMOVE_ENTRY != 0 */
/*-----------------------------------------------------------*/

void vARPRefreshCacheEntry( const MACAddress_t * pxMACAddress, const uint32_t ulIPAddress )
{
 80046d6:	f04f 0bff 	mov.w	fp, #255	; 0xff
 80046da:	2300      	movs	r3, #0
 80046dc:	9301      	str	r3, [sp, #4]
 80046de:	f04f 38ff 	mov.w	r8, #4294967295
 80046e2:	46c1      	mov	r9, r8
 80046e4:	461d      	mov	r5, r3
		{
		BaseType_t xMatchingMAC;

			if( pxMACAddress != NULL )
			{
				if( memcmp( xARPCache[ x ].xMACAddress.ucBytes, pxMACAddress->ucBytes, sizeof( pxMACAddress->ucBytes ) ) == 0 )
 80046e6:	f04f 0a06 	mov.w	sl, #6
		/* For each entry in the ARP cache table. */
		for( x = 0; x < ipconfigARP_CACHE_ENTRIES; x++ )
		{
		BaseType_t xMatchingMAC;

			if( pxMACAddress != NULL )
 80046ea:	2e00      	cmp	r6, #0
 80046ec:	d05c      	beq.n	80047a8 <vARPRefreshCacheEntry+0xf4>
			{
				if( memcmp( xARPCache[ x ].xMACAddress.ucBytes, pxMACAddress->ucBytes, sizeof( pxMACAddress->ucBytes ) ) == 0 )
 80046ee:	4620      	mov	r0, r4
 80046f0:	4631      	mov	r1, r6
 80046f2:	4652      	mov	r2, sl
 80046f4:	f005 fbe2 	bl	8009ebc <memcmp>
 80046f8:	fab0 f080 	clz	r0, r0
 80046fc:	0940      	lsrs	r0, r0, #5
			{
				xMatchingMAC = pdFALSE;
			}
			/* Does this line in the cache table hold an entry for the IP
			address	being queried? */
			if( xARPCache[ x ].ulIPAddress == ulIPAddress )
 80046fe:	f854 3c04 	ldr.w	r3, [r4, #-4]
 8004702:	42bb      	cmp	r3, r7
 8004704:	d10a      	bne.n	800471c <vARPRefreshCacheEntry+0x68>
					xIpEntry = x;
					break;
				}

				/* See if the MAC-address also matches. */
				if( xMatchingMAC != pdFALSE )
 8004706:	b180      	cbz	r0, 800472a <vARPRefreshCacheEntry+0x76>
				{
					/* This function will be called for each received packet
					As this is by far the most common path the coding standard
					is relaxed in this case and a return is permitted as an
					optimisation. */
					xARPCache[ x ].ucAge = ( uint8_t ) ipconfigMAX_ARP_AGE;
 8004708:	4b36      	ldr	r3, [pc, #216]	; (80047e4 <vARPRefreshCacheEntry+0x130>)
 800470a:	006a      	lsls	r2, r5, #1
 800470c:	1951      	adds	r1, r2, r5
 800470e:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 8004712:	2096      	movs	r0, #150	; 0x96
 8004714:	7288      	strb	r0, [r1, #10]
					xARPCache[ x ].ucValid = ( uint8_t ) pdTRUE;
 8004716:	2201      	movs	r2, #1
 8004718:	72ca      	strb	r2, [r1, #11]
					return;
 800471a:	e05a      	b.n	80047d2 <vARPRefreshCacheEntry+0x11e>
				for an ARP reply.  Still want to see if there is match with the
				given MAC address.ucBytes.  If found, either of the two entries
				must be cleared. */
				xIpEntry = x;
			}
			else if( xMatchingMAC != pdFALSE )
 800471c:	b938      	cbnz	r0, 800472e <vARPRefreshCacheEntry+0x7a>
				xMacEntry = x;
	#endif
			}
			/* _HT_
			Shouldn't we test for xARPCache[ x ].ucValid == pdFALSE here ? */
			else if( xARPCache[ x ].ucAge < ucMinAgeFound )
 800471e:	79a3      	ldrb	r3, [r4, #6]
 8004720:	455b      	cmp	r3, fp
 8004722:	d205      	bcs.n	8004730 <vARPRefreshCacheEntry+0x7c>
			{
				/* As the table is traversed, remember the table row that
				contains the oldest entry (the lowest age count, as ages are
				decremented to zero) so the row can be re-used if this function
				needs to add an entry that does not already exist. */
				ucMinAgeFound = xARPCache[ x ].ucAge;
 8004724:	469b      	mov	fp, r3
				xMacEntry = x;
	#endif
			}
			/* _HT_
			Shouldn't we test for xARPCache[ x ].ucValid == pdFALSE here ? */
			else if( xARPCache[ x ].ucAge < ucMinAgeFound )
 8004726:	9501      	str	r5, [sp, #4]
 8004728:	e002      	b.n	8004730 <vARPRefreshCacheEntry+0x7c>
 800472a:	46a9      	mov	r9, r5
 800472c:	e000      	b.n	8004730 <vARPRefreshCacheEntry+0x7c>
 800472e:	46a8      	mov	r8, r5
	{
		/* Start with the maximum possible number. */
		ucMinAgeFound--;

		/* For each entry in the ARP cache table. */
		for( x = 0; x < ipconfigARP_CACHE_ENTRIES; x++ )
 8004730:	3501      	adds	r5, #1
 8004732:	340c      	adds	r4, #12
 8004734:	2d06      	cmp	r5, #6
 8004736:	d1d8      	bne.n	80046ea <vARPRefreshCacheEntry+0x36>
 8004738:	e000      	b.n	800473c <vARPRefreshCacheEntry+0x88>
			{
				xMatchingMAC = pdFALSE;
			}
			/* Does this line in the cache table hold an entry for the IP
			address	being queried? */
			if( xARPCache[ x ].ulIPAddress == ulIPAddress )
 800473a:	46a9      	mov	r9, r5
			{
				/* Nothing happes to this cache entry for now. */
			}
		}

		if( xMacEntry >= 0 )
 800473c:	f1b8 0f00 	cmp.w	r8, #0
 8004740:	db0f      	blt.n	8004762 <vARPRefreshCacheEntry+0xae>
		{
			xUseEntry = xMacEntry;

			if( xIpEntry >= 0 )
 8004742:	f1b9 0f00 	cmp.w	r9, #0
 8004746:	db34      	blt.n	80047b2 <vARPRefreshCacheEntry+0xfe>
			{
				/* Both the MAC address as well as the IP address were found in
				different locations: clear the entry which matches the
				IP-address */
				( void ) memset( &( xARPCache[ xIpEntry ] ), 0, sizeof( ARPCacheRow_t ) );
 8004748:	4926      	ldr	r1, [pc, #152]	; (80047e4 <vARPRefreshCacheEntry+0x130>)
 800474a:	eb09 0949 	add.w	r9, r9, r9, lsl #1
 800474e:	ea4f 0989 	mov.w	r9, r9, lsl #2
 8004752:	eb01 0309 	add.w	r3, r1, r9
 8004756:	2200      	movs	r2, #0
 8004758:	f841 2009 	str.w	r2, [r1, r9]
 800475c:	605a      	str	r2, [r3, #4]
 800475e:	609a      	str	r2, [r3, #8]
 8004760:	e030      	b.n	80047c4 <vARPRefreshCacheEntry+0x110>
			}
		}
		else if( xIpEntry >= 0 )
 8004762:	f1b9 0f00 	cmp.w	r9, #0
 8004766:	da2c      	bge.n	80047c2 <vARPRefreshCacheEntry+0x10e>
 8004768:	f8dd 8004 	ldr.w	r8, [sp, #4]
 800476c:	e021      	b.n	80047b2 <vARPRefreshCacheEntry+0xfe>
		/* If the entry was not found, we use the oldest entry and set the IPaddress */
		xARPCache[ xUseEntry ].ulIPAddress = ulIPAddress;

		if( pxMACAddress != NULL )
		{
			( void ) memcpy( xARPCache[ xUseEntry ].xMACAddress.ucBytes, pxMACAddress->ucBytes, sizeof( pxMACAddress->ucBytes ) );
 800476e:	4a1d      	ldr	r2, [pc, #116]	; (80047e4 <vARPRefreshCacheEntry+0x130>)
 8004770:	ea4f 0148 	mov.w	r1, r8, lsl #1
 8004774:	eb01 0308 	add.w	r3, r1, r8
 8004778:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 800477c:	6830      	ldr	r0, [r6, #0]
 800477e:	6058      	str	r0, [r3, #4]
 8004780:	88b0      	ldrh	r0, [r6, #4]
 8004782:	8118      	strh	r0, [r3, #8]

			iptraceARP_TABLE_ENTRY_CREATED( ulIPAddress, (*pxMACAddress) );
			/* And this entry does not need immediate attention */
			xARPCache[ xUseEntry ].ucAge = ( uint8_t ) ipconfigMAX_ARP_AGE;
 8004784:	2096      	movs	r0, #150	; 0x96
 8004786:	7298      	strb	r0, [r3, #10]
			xARPCache[ xUseEntry ].ucValid = ( uint8_t ) pdTRUE;
 8004788:	461a      	mov	r2, r3
 800478a:	2301      	movs	r3, #1
 800478c:	72d3      	strb	r3, [r2, #11]
 800478e:	e020      	b.n	80047d2 <vARPRefreshCacheEntry+0x11e>
		}
		else if( xIpEntry < 0 )
		{
			xARPCache[ xUseEntry ].ucAge = ( uint8_t ) ipconfigMAX_ARP_RETRANSMISSIONS;
 8004790:	4b14      	ldr	r3, [pc, #80]	; (80047e4 <vARPRefreshCacheEntry+0x130>)
 8004792:	ea4f 0248 	mov.w	r2, r8, lsl #1
 8004796:	eb02 0108 	add.w	r1, r2, r8
 800479a:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 800479e:	2005      	movs	r0, #5
 80047a0:	7288      	strb	r0, [r1, #10]
			xARPCache[ xUseEntry ].ucValid = ( uint8_t ) pdFALSE;
 80047a2:	2200      	movs	r2, #0
 80047a4:	72ca      	strb	r2, [r1, #11]
 80047a6:	e014      	b.n	80047d2 <vARPRefreshCacheEntry+0x11e>
			{
				xMatchingMAC = pdFALSE;
			}
			/* Does this line in the cache table hold an entry for the IP
			address	being queried? */
			if( xARPCache[ x ].ulIPAddress == ulIPAddress )
 80047a8:	f854 3c04 	ldr.w	r3, [r4, #-4]
 80047ac:	42bb      	cmp	r3, r7
 80047ae:	d1b6      	bne.n	800471e <vARPRefreshCacheEntry+0x6a>
 80047b0:	e7c3      	b.n	800473a <vARPRefreshCacheEntry+0x86>
		{
			/* No matching entry found. */
		}

		/* If the entry was not found, we use the oldest entry and set the IPaddress */
		xARPCache[ xUseEntry ].ulIPAddress = ulIPAddress;
 80047b2:	eb08 0348 	add.w	r3, r8, r8, lsl #1
 80047b6:	4a0b      	ldr	r2, [pc, #44]	; (80047e4 <vARPRefreshCacheEntry+0x130>)
 80047b8:	f842 7023 	str.w	r7, [r2, r3, lsl #2]

		if( pxMACAddress != NULL )
 80047bc:	2e00      	cmp	r6, #0
 80047be:	d1d6      	bne.n	800476e <vARPRefreshCacheEntry+0xba>
 80047c0:	e7e6      	b.n	8004790 <vARPRefreshCacheEntry+0xdc>
 80047c2:	46c8      	mov	r8, r9
		{
			/* No matching entry found. */
		}

		/* If the entry was not found, we use the oldest entry and set the IPaddress */
		xARPCache[ xUseEntry ].ulIPAddress = ulIPAddress;
 80047c4:	eb08 0348 	add.w	r3, r8, r8, lsl #1
 80047c8:	4a06      	ldr	r2, [pc, #24]	; (80047e4 <vARPRefreshCacheEntry+0x130>)
 80047ca:	f842 7023 	str.w	r7, [r2, r3, lsl #2]

		if( pxMACAddress != NULL )
 80047ce:	2e00      	cmp	r6, #0
 80047d0:	d1cd      	bne.n	800476e <vARPRefreshCacheEntry+0xba>
		else
		{
			/* Nothing will be stored. */
		}
	}
}
 80047d2:	b003      	add	sp, #12
 80047d4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80047d8:	2000d5c0 	.word	0x2000d5c0
 80047dc:	2000d36c 	.word	0x2000d36c
 80047e0:	2000d274 	.word	0x2000d274
 80047e4:	2000d270 	.word	0x2000d270

080047e8 <eARPProcessPacket>:
#endif /* ipconfigARP_USE_CLASH_DETECTION */

/*-----------------------------------------------------------*/

eFrameProcessingResult_t eARPProcessPacket( ARPPacket_t * const pxARPFrame )
{
 80047e8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80047ea:	b083      	sub	sp, #12
 80047ec:	4603      	mov	r3, r0
uint32_t ulTargetProtocolAddress, ulSenderProtocolAddress;

	pxARPHeader = &( pxARPFrame->xARPHeader );

	/* The field ulSenderProtocolAddress is badly aligned, copy byte-by-byte. */
	( void ) memcpy( ( void * ) ( &( ulSenderProtocolAddress ) ), ( const void * ) ( pxARPHeader->ucSenderProtocolAddress ), sizeof( ulSenderProtocolAddress ) );
 80047ee:	69c0      	ldr	r0, [r0, #28]
 80047f0:	9001      	str	r0, [sp, #4]
	/* The field ulTargetProtocolAddress is well-aligned, a 32-bits copy. */
	ulTargetProtocolAddress = pxARPHeader->ulTargetProtocolAddress;
 80047f2:	f8d3 5026 	ldr.w	r5, [r3, #38]	; 0x26

	traceARP_PACKET_RECEIVED();

	/* Don't do anything if the local IP address is zero because
	that means a DHCP request has not completed. */
	if( *ipLOCAL_IP_ADDRESS_POINTER != 0UL )
 80047f6:	4a2b      	ldr	r2, [pc, #172]	; (80048a4 <eARPProcessPacket+0xbc>)
 80047f8:	6952      	ldr	r2, [r2, #20]
 80047fa:	2a00      	cmp	r2, #0
 80047fc:	d04a      	beq.n	8004894 <eARPProcessPacket+0xac>
 80047fe:	461c      	mov	r4, r3
	{
		switch( pxARPHeader->usOperation )
 8004800:	8a9b      	ldrh	r3, [r3, #20]
 8004802:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8004806:	d003      	beq.n	8004810 <eARPProcessPacket+0x28>
 8004808:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800480c:	d03b      	beq.n	8004886 <eARPProcessPacket+0x9e>
 800480e:	e043      	b.n	8004898 <eARPProcessPacket+0xb0>
		{
			case ipARP_REQUEST	:
				/* The packet contained an ARP request.  Was it for the IP
				address of the node running this code? */
				if( ulTargetProtocolAddress == *ipLOCAL_IP_ADDRESS_POINTER )
 8004810:	4295      	cmp	r5, r2
 8004812:	d143      	bne.n	800489c <eARPProcessPacket+0xb4>
					iptraceSENDING_ARP_REPLY( ulSenderProtocolAddress );

					/* The request is for the address of this node.  Add the
					entry into the ARP cache, or refresh the entry if it
					already exists. */
					vARPRefreshCacheEntry( &( pxARPHeader->xSenderHardwareAddress ), ulSenderProtocolAddress );
 8004814:	f104 0616 	add.w	r6, r4, #22
 8004818:	9f01      	ldr	r7, [sp, #4]
 800481a:	4630      	mov	r0, r6
 800481c:	4639      	mov	r1, r7
 800481e:	f7ff ff49 	bl	80046b4 <vARPRefreshCacheEntry>

					/* Generate a reply payload in the same buffer. */
					pxARPHeader->usOperation = ( uint16_t ) ipARP_REPLY;
 8004822:	2300      	movs	r3, #0
 8004824:	7523      	strb	r3, [r4, #20]
 8004826:	2302      	movs	r3, #2
 8004828:	7563      	strb	r3, [r4, #21]
					if( ulTargetProtocolAddress == ulSenderProtocolAddress )
 800482a:	42bd      	cmp	r5, r7
 800482c:	d11b      	bne.n	8004866 <eARPProcessPacket+0x7e>
					{
						/* A double IP address is detected! */
						/* Give the sources MAC address the value of the broadcast address, will be swapped later */
						( void ) memcpy( pxARPFrame->xEthernetHeader.xSourceAddress.ucBytes, xBroadcastMACAddress.ucBytes, sizeof( xBroadcastMACAddress ) );
 800482e:	4b1e      	ldr	r3, [pc, #120]	; (80048a8 <eARPProcessPacket+0xc0>)
 8004830:	681a      	ldr	r2, [r3, #0]
 8004832:	f8c4 2006 	str.w	r2, [r4, #6]
 8004836:	889b      	ldrh	r3, [r3, #4]
 8004838:	8163      	strh	r3, [r4, #10]
						( void ) memset( pxARPHeader->xTargetHardwareAddress.ucBytes, 0, sizeof( MACAddress_t ) );
 800483a:	2300      	movs	r3, #0
 800483c:	f884 3020 	strb.w	r3, [r4, #32]
 8004840:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
 8004844:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
 8004848:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
 800484c:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
 8004850:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
						pxARPHeader->ulTargetProtocolAddress = 0UL;
 8004854:	f884 3026 	strb.w	r3, [r4, #38]	; 0x26
 8004858:	f884 3027 	strb.w	r3, [r4, #39]	; 0x27
 800485c:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
 8004860:	f884 3029 	strb.w	r3, [r4, #41]	; 0x29
 8004864:	e005      	b.n	8004872 <eARPProcessPacket+0x8a>
					}
					else
					{
						( void ) memcpy( pxARPHeader->xTargetHardwareAddress.ucBytes, pxARPHeader->xSenderHardwareAddress.ucBytes, sizeof( MACAddress_t ) );
 8004866:	6833      	ldr	r3, [r6, #0]
 8004868:	6223      	str	r3, [r4, #32]
 800486a:	88b3      	ldrh	r3, [r6, #4]
 800486c:	84a3      	strh	r3, [r4, #36]	; 0x24
						pxARPHeader->ulTargetProtocolAddress = ulSenderProtocolAddress;
 800486e:	f8c4 7026 	str.w	r7, [r4, #38]	; 0x26
					}
					( void ) memcpy( ( void * ) ( pxARPHeader->xSenderHardwareAddress.ucBytes ), ( const void * ) ( ipLOCAL_MAC_ADDRESS ), sizeof( MACAddress_t ) );
 8004872:	4b0c      	ldr	r3, [pc, #48]	; (80048a4 <eARPProcessPacket+0xbc>)
 8004874:	6818      	ldr	r0, [r3, #0]
 8004876:	f8c4 0016 	str.w	r0, [r4, #22]
 800487a:	889a      	ldrh	r2, [r3, #4]
 800487c:	80b2      	strh	r2, [r6, #4]
					( void ) memcpy( ( void * ) ( pxARPHeader->ucSenderProtocolAddress ), ( const void * ) ( ipLOCAL_IP_ADDRESS_POINTER ), sizeof( pxARPHeader->ucSenderProtocolAddress ) );
 800487e:	6958      	ldr	r0, [r3, #20]
 8004880:	61e0      	str	r0, [r4, #28]

					eReturn = eReturnEthernetFrame;
 8004882:	2002      	movs	r0, #2
 8004884:	e00b      	b.n	800489e <eARPProcessPacket+0xb6>
				}
				break;

			case ipARP_REPLY :
				iptracePROCESSING_RECEIVED_ARP_REPLY( ulTargetProtocolAddress );
				vARPRefreshCacheEntry( &( pxARPHeader->xSenderHardwareAddress ), ulSenderProtocolAddress );
 8004886:	f104 0016 	add.w	r0, r4, #22
 800488a:	9901      	ldr	r1, [sp, #4]
 800488c:	f7ff ff12 	bl	80046b4 <vARPRefreshCacheEntry>

/*-----------------------------------------------------------*/

eFrameProcessingResult_t eARPProcessPacket( ARPPacket_t * const pxARPFrame )
{
eFrameProcessingResult_t eReturn = eReleaseBuffer;
 8004890:	2000      	movs	r0, #0
						/* Remember the MAC-address of the other device which has the same IP-address. */
						( void ) memcpy( xARPClashMacAddress.ucBytes, pxARPHeader->xSenderHardwareAddress.ucBytes, sizeof( xARPClashMacAddress.ucBytes ) );
					}
				}
				#endif /* ipconfigARP_USE_CLASH_DETECTION */
				break;
 8004892:	e004      	b.n	800489e <eARPProcessPacket+0xb6>

/*-----------------------------------------------------------*/

eFrameProcessingResult_t eARPProcessPacket( ARPPacket_t * const pxARPFrame )
{
eFrameProcessingResult_t eReturn = eReleaseBuffer;
 8004894:	2000      	movs	r0, #0
 8004896:	e002      	b.n	800489e <eARPProcessPacket+0xb6>
 8004898:	2000      	movs	r0, #0
 800489a:	e000      	b.n	800489e <eARPProcessPacket+0xb6>
 800489c:	2000      	movs	r0, #0
				break;
		}
	}

	return eReturn;
}
 800489e:	b003      	add	sp, #12
 80048a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80048a2:	bf00      	nop
 80048a4:	2000d5c0 	.word	0x2000d5c0
 80048a8:	0800abb0 	.word	0x0800abb0

080048ac <eARPGetCacheEntry>:
#endif /* ipconfigUSE_ARP_REVERSED_LOOKUP */

/*-----------------------------------------------------------*/

eARPLookupResult_t eARPGetCacheEntry( uint32_t *pulIPAddress, MACAddress_t * const pxMACAddress )
{
 80048ac:	b570      	push	{r4, r5, r6, lr}
 80048ae:	4604      	mov	r4, r0
 80048b0:	460e      	mov	r6, r1
eARPLookupResult_t eReturn;
uint32_t ulAddressToLookup;
ulAddressToLookup = *pulIPAddress;
 80048b2:	6805      	ldr	r5, [r0, #0]
		( void ) memcpy( pxMACAddress->ucBytes, xLLMNR_MacAdress.ucBytes, sizeof( MACAddress_t ) );
		eReturn = eARPCacheHit;
	}
	else
#endif
	if( xIsIPv4Multicast( ulAddressToLookup ) != 0 )
 80048b4:	4628      	mov	r0, r5
 80048b6:	f000 fd05 	bl	80052c4 <xIsIPv4Multicast>
 80048ba:	b128      	cbz	r0, 80048c8 <eARPGetCacheEntry+0x1c>
	{
		/* Get the lowest 23 bits of the IP-address. */
		vSetMultiCastIPv4MacAddress( ulAddressToLookup, pxMACAddress );
 80048bc:	4628      	mov	r0, r5
 80048be:	4631      	mov	r1, r6
 80048c0:	f000 fd14 	bl	80052ec <vSetMultiCastIPv4MacAddress>

		eReturn = eARPCacheHit;
 80048c4:	2001      	movs	r0, #1
 80048c6:	bd70      	pop	{r4, r5, r6, pc}
	}
	else if( ( *pulIPAddress == ipBROADCAST_IP_ADDRESS ) ||	/* Is it the general broadcast address 255.255.255.255? */
 80048c8:	6823      	ldr	r3, [r4, #0]
 80048ca:	f1b3 3fff 	cmp.w	r3, #4294967295
 80048ce:	d003      	beq.n	80048d8 <eARPGetCacheEntry+0x2c>
		( *pulIPAddress == xNetworkAddressing.ulBroadcastAddress ) )/* Or a local broadcast address, eg 192.168.1.255? */
 80048d0:	4a22      	ldr	r2, [pc, #136]	; (800495c <eARPGetCacheEntry+0xb0>)
		/* Get the lowest 23 bits of the IP-address. */
		vSetMultiCastIPv4MacAddress( ulAddressToLookup, pxMACAddress );

		eReturn = eARPCacheHit;
	}
	else if( ( *pulIPAddress == ipBROADCAST_IP_ADDRESS ) ||	/* Is it the general broadcast address 255.255.255.255? */
 80048d2:	6912      	ldr	r2, [r2, #16]
 80048d4:	4293      	cmp	r3, r2
 80048d6:	d106      	bne.n	80048e6 <eARPGetCacheEntry+0x3a>
		( *pulIPAddress == xNetworkAddressing.ulBroadcastAddress ) )/* Or a local broadcast address, eg 192.168.1.255? */
	{
		/* This is a broadcast so it uses the broadcast MAC address. */
		( void ) memcpy( pxMACAddress->ucBytes, xBroadcastMACAddress.ucBytes, sizeof( MACAddress_t ) );
 80048d8:	4b21      	ldr	r3, [pc, #132]	; (8004960 <eARPGetCacheEntry+0xb4>)
 80048da:	681a      	ldr	r2, [r3, #0]
 80048dc:	6032      	str	r2, [r6, #0]
 80048de:	889b      	ldrh	r3, [r3, #4]
 80048e0:	80b3      	strh	r3, [r6, #4]
		eReturn = eARPCacheHit;
 80048e2:	2001      	movs	r0, #1
 80048e4:	bd70      	pop	{r4, r5, r6, pc}
	}
	else if( *ipLOCAL_IP_ADDRESS_POINTER == 0UL )
 80048e6:	4a1f      	ldr	r2, [pc, #124]	; (8004964 <eARPGetCacheEntry+0xb8>)
 80048e8:	6952      	ldr	r2, [r2, #20]
 80048ea:	b34a      	cbz	r2, 8004940 <eARPGetCacheEntry+0x94>
	}
	else
	{
		eReturn = eARPCacheMiss;

		if( ( *pulIPAddress & xNetworkAddressing.ulNetMask ) != ( ( *ipLOCAL_IP_ADDRESS_POINTER ) & xNetworkAddressing.ulNetMask ) )
 80048ec:	405a      	eors	r2, r3
 80048ee:	491b      	ldr	r1, [pc, #108]	; (800495c <eARPGetCacheEntry+0xb0>)
 80048f0:	6849      	ldr	r1, [r1, #4]
 80048f2:	420a      	tst	r2, r1
 80048f4:	d028      	beq.n	8004948 <eARPGetCacheEntry+0x9c>
			else
#endif
			{
				/* The IP address is off the local network, so look up the
				hardware address of the router, if any. */
				if( xNetworkAddressing.ulGatewayAddress != ( uint32_t ) 0U )
 80048f6:	4a19      	ldr	r2, [pc, #100]	; (800495c <eARPGetCacheEntry+0xb0>)
 80048f8:	6891      	ldr	r1, [r2, #8]
 80048fa:	b329      	cbz	r1, 8004948 <eARPGetCacheEntry+0x9c>
	/* Loop through each entry in the ARP cache. */
	for( x = 0; x < ipconfigARP_CACHE_ENTRIES; x++ )
	{
		/* Does this row in the ARP cache table hold an entry for the IP address
		being queried? */
		if( xARPCache[ x ].ulIPAddress == ulAddressToLookup )
 80048fc:	4b1a      	ldr	r3, [pc, #104]	; (8004968 <eARPGetCacheEntry+0xbc>)
 80048fe:	681b      	ldr	r3, [r3, #0]
 8004900:	4299      	cmp	r1, r3
 8004902:	d005      	beq.n	8004910 <eARPGetCacheEntry+0x64>
 8004904:	4a18      	ldr	r2, [pc, #96]	; (8004968 <eARPGetCacheEntry+0xbc>)
{
BaseType_t x;
eARPLookupResult_t eReturn = eARPCacheMiss;

	/* Loop through each entry in the ARP cache. */
	for( x = 0; x < ipconfigARP_CACHE_ENTRIES; x++ )
 8004906:	2301      	movs	r3, #1
	{
		/* Does this row in the ARP cache table hold an entry for the IP address
		being queried? */
		if( xARPCache[ x ].ulIPAddress == ulAddressToLookup )
 8004908:	68d0      	ldr	r0, [r2, #12]
 800490a:	4281      	cmp	r1, r0
 800490c:	d113      	bne.n	8004936 <eARPGetCacheEntry+0x8a>
 800490e:	e000      	b.n	8004912 <eARPGetCacheEntry+0x66>
 8004910:	2300      	movs	r3, #0
		{
			/* A matching valid entry was found. */
			if( xARPCache[ x ].ucValid == ( uint8_t ) pdFALSE )
 8004912:	eb03 0243 	add.w	r2, r3, r3, lsl #1
 8004916:	4914      	ldr	r1, [pc, #80]	; (8004968 <eARPGetCacheEntry+0xbc>)
 8004918:	eb01 0282 	add.w	r2, r1, r2, lsl #2
 800491c:	7ad2      	ldrb	r2, [r2, #11]
 800491e:	b1d2      	cbz	r2, 8004956 <eARPGetCacheEntry+0xaa>
				eReturn = eCantSendPacket;
			}
			else
			{
				/* A valid entry was found. */
				( void ) memcpy( pxMACAddress->ucBytes, xARPCache[ x ].xMACAddress.ucBytes, sizeof( MACAddress_t ) );
 8004920:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8004924:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 8004928:	f853 0f04 	ldr.w	r0, [r3, #4]!
 800492c:	6030      	str	r0, [r6, #0]
 800492e:	889b      	ldrh	r3, [r3, #4]
 8004930:	80b3      	strh	r3, [r6, #4]
				eReturn = eARPCacheHit;
 8004932:	2001      	movs	r0, #1
 8004934:	bd70      	pop	{r4, r5, r6, pc}
{
BaseType_t x;
eARPLookupResult_t eReturn = eARPCacheMiss;

	/* Loop through each entry in the ARP cache. */
	for( x = 0; x < ipconfigARP_CACHE_ENTRIES; x++ )
 8004936:	3301      	adds	r3, #1
 8004938:	320c      	adds	r2, #12
 800493a:	2b06      	cmp	r3, #6
 800493c:	d1e4      	bne.n	8004908 <eARPGetCacheEntry+0x5c>
 800493e:	e007      	b.n	8004950 <eARPGetCacheEntry+0xa4>
	}
	else if( *ipLOCAL_IP_ADDRESS_POINTER == 0UL )
	{
		/* The IP address has not yet been assigned, so there is nothing that
		can be done. */
		eReturn = eCantSendPacket;
 8004940:	2002      	movs	r0, #2
 8004942:	bd70      	pop	{r4, r5, r6, pc}
		{
			if( ulAddressToLookup == 0UL )
			{
				/* The address is not on the local network, and there is not a
				router. */
				eReturn = eCantSendPacket;
 8004944:	2002      	movs	r0, #2
 8004946:	bd70      	pop	{r4, r5, r6, pc}
		if( eReturn == eARPCacheMiss )	/*lint !e774: (Info -- Boolean within 'if' always evaluates to True, depending on configuration. */
		#else
		/* No cache look-up was done, so the result is still 'eARPCacheMiss'. */
		#endif
		{
			if( ulAddressToLookup == 0UL )
 8004948:	2b00      	cmp	r3, #0
 800494a:	d0fb      	beq.n	8004944 <eARPGetCacheEntry+0x98>
 800494c:	4619      	mov	r1, r3
 800494e:	e7d5      	b.n	80048fc <eARPGetCacheEntry+0x50>
				eReturn = prvCacheLookup( ulAddressToLookup, pxMACAddress );

				if( eReturn == eARPCacheMiss )
				{
					/* It might be that the ARP has to go to the gateway. */
					*pulIPAddress = ulAddressToLookup;
 8004950:	6021      	str	r1, [r4, #0]
				router. */
				eReturn = eCantSendPacket;
			}
			else
			{
				eReturn = prvCacheLookup( ulAddressToLookup, pxMACAddress );
 8004952:	2000      	movs	r0, #0
 8004954:	bd70      	pop	{r4, r5, r6, pc}
		{
			/* A matching valid entry was found. */
			if( xARPCache[ x ].ucValid == ( uint8_t ) pdFALSE )
			{
				/* This entry is waiting an ARP reply, so is not valid. */
				eReturn = eCantSendPacket;
 8004956:	2002      	movs	r0, #2
			}
		}
	}

	return eReturn;
}
 8004958:	bd70      	pop	{r4, r5, r6, pc}
 800495a:	bf00      	nop
 800495c:	2000d36c 	.word	0x2000d36c
 8004960:	0800abb0 	.word	0x0800abb0
 8004964:	2000d5c0 	.word	0x2000d5c0
 8004968:	2000d270 	.word	0x2000d270

0800496c <vARPGenerateRequestPacket>:
ARPPacket_t *pxARPPacket;

	/* Buffer allocation ensures that buffers always have space
	for an ARP packet. See buffer allocation implementations 1
	and 2 under portable/BufferManagement. */
	configASSERT( pxNetworkBuffer != NULL );
 800496c:	b940      	cbnz	r0, 8004980 <vARPGenerateRequestPacket+0x14>
 800496e:	f04f 0314 	mov.w	r3, #20
 8004972:	f383 8811 	msr	BASEPRI, r3
 8004976:	f3bf 8f6f 	isb	sy
 800497a:	f3bf 8f4f 	dsb	sy
 800497e:	e7fe      	b.n	800497e <vARPGenerateRequestPacket+0x12>
		}
	}
}

void vARPGenerateRequestPacket( NetworkBufferDescriptor_t * const pxNetworkBuffer )
{
 8004980:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004982:	4686      	mov	lr, r0

	/* Buffer allocation ensures that buffers always have space
	for an ARP packet. See buffer allocation implementations 1
	and 2 under portable/BufferManagement. */
	configASSERT( pxNetworkBuffer != NULL );
	configASSERT( pxNetworkBuffer->xDataLength >= sizeof(ARPPacket_t) );
 8004984:	69c3      	ldr	r3, [r0, #28]
 8004986:	2b29      	cmp	r3, #41	; 0x29
 8004988:	d808      	bhi.n	800499c <vARPGenerateRequestPacket+0x30>
 800498a:	f04f 0314 	mov.w	r3, #20
 800498e:	f383 8811 	msr	BASEPRI, r3
 8004992:	f3bf 8f6f 	isb	sy
 8004996:	f3bf 8f4f 	dsb	sy
 800499a:	e7fe      	b.n	800499a <vARPGenerateRequestPacket+0x2e>

	pxARPPacket = ipCAST_PTR_TO_TYPE_PTR( ARPPacket_t, pxNetworkBuffer->pucEthernetBuffer );
 800499c:	6985      	ldr	r5, [r0, #24]
		xARPHeader.ucHardwareAddressLength;
		xARPHeader.ucProtocolAddressLength;
		xARPHeader.usOperation;
		xARPHeader.xTargetHardwareAddress;
	*/
	( void ) memcpy( ( void * ) pxARPPacket, ( const void * ) xDefaultPartARPPacketHeader, sizeof( xDefaultPartARPPacketHeader ) );
 800499e:	4e12      	ldr	r6, [pc, #72]	; (80049e8 <vARPGenerateRequestPacket+0x7c>)
 80049a0:	462c      	mov	r4, r5
 80049a2:	f106 0c20 	add.w	ip, r6, #32
 80049a6:	4637      	mov	r7, r6
 80049a8:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 80049aa:	6020      	str	r0, [r4, #0]
 80049ac:	6061      	str	r1, [r4, #4]
 80049ae:	60a2      	str	r2, [r4, #8]
 80049b0:	60e3      	str	r3, [r4, #12]
 80049b2:	463e      	mov	r6, r7
 80049b4:	3410      	adds	r4, #16
 80049b6:	4567      	cmp	r7, ip
 80049b8:	d1f5      	bne.n	80049a6 <vARPGenerateRequestPacket+0x3a>
 80049ba:	6838      	ldr	r0, [r7, #0]
 80049bc:	6020      	str	r0, [r4, #0]
 80049be:	88bb      	ldrh	r3, [r7, #4]
 80049c0:	80a3      	strh	r3, [r4, #4]
	( void ) memcpy( ( void * ) ( pxARPPacket->xEthernetHeader.xSourceAddress.ucBytes ) , ( const void * ) ipLOCAL_MAC_ADDRESS, ( size_t ) ipMAC_ADDRESS_LENGTH_BYTES );
 80049c2:	4b0a      	ldr	r3, [pc, #40]	; (80049ec <vARPGenerateRequestPacket+0x80>)
 80049c4:	6818      	ldr	r0, [r3, #0]
 80049c6:	f8c5 0006 	str.w	r0, [r5, #6]
 80049ca:	889a      	ldrh	r2, [r3, #4]
 80049cc:	816a      	strh	r2, [r5, #10]
	( void ) memcpy( ( void * ) ( pxARPPacket->xARPHeader.xSenderHardwareAddress.ucBytes ), ( const void * ) ipLOCAL_MAC_ADDRESS, ( size_t ) ipMAC_ADDRESS_LENGTH_BYTES );
 80049ce:	f8c5 0016 	str.w	r0, [r5, #22]
 80049d2:	836a      	strh	r2, [r5, #26]

	( void ) memcpy( ( void * ) ( pxARPPacket->xARPHeader.ucSenderProtocolAddress ), ( const void * ) ipLOCAL_IP_ADDRESS_POINTER, sizeof( pxARPPacket->xARPHeader.ucSenderProtocolAddress ) );
 80049d4:	6958      	ldr	r0, [r3, #20]
 80049d6:	61e8      	str	r0, [r5, #28]
	pxARPPacket->xARPHeader.ulTargetProtocolAddress = pxNetworkBuffer->ulIPAddress;
 80049d8:	f8de 3014 	ldr.w	r3, [lr, #20]
 80049dc:	f8c5 3026 	str.w	r3, [r5, #38]	; 0x26

	pxNetworkBuffer->xDataLength = sizeof( ARPPacket_t );
 80049e0:	232a      	movs	r3, #42	; 0x2a
 80049e2:	f8ce 301c 	str.w	r3, [lr, #28]
 80049e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80049e8:	0800ab88 	.word	0x0800ab88
 80049ec:	2000d5c0 	.word	0x2000d5c0

080049f0 <FreeRTOS_OutputARPRequest>:
	( void ) xSendEventToIPTask( eARPTimerEvent );
}

/*-----------------------------------------------------------*/
void FreeRTOS_OutputARPRequest( uint32_t ulIPAddress )
{
 80049f0:	b530      	push	{r4, r5, lr}
 80049f2:	b083      	sub	sp, #12
 80049f4:	4605      	mov	r5, r0
NetworkBufferDescriptor_t *pxNetworkBuffer;

	/* This is called from the context of the IP event task, so a block time
	must not be used. */
	pxNetworkBuffer = pxGetNetworkBufferWithDescriptor( sizeof( ARPPacket_t ), ( TickType_t ) 0U );
 80049f6:	202a      	movs	r0, #42	; 0x2a
 80049f8:	2100      	movs	r1, #0
 80049fa:	f7ff fe0b 	bl	8004614 <pxGetNetworkBufferWithDescriptor>

	if( pxNetworkBuffer != NULL )
 80049fe:	b1c0      	cbz	r0, 8004a32 <FreeRTOS_OutputARPRequest+0x42>
 8004a00:	4604      	mov	r4, r0
	{
		pxNetworkBuffer->ulIPAddress = ulIPAddress;
 8004a02:	6145      	str	r5, [r0, #20]
		vARPGenerateRequestPacket( pxNetworkBuffer );
 8004a04:	f7ff ffb2 	bl	800496c <vARPGenerateRequestPacket>
				pxNetworkBuffer->xDataLength = ( size_t ) ipconfigETHERNET_MINIMUM_PACKET_BYTES;
			}
		}
		#endif

		if( xIsCallingFromIPTask() != 0 )
 8004a08:	f000 faf0 	bl	8004fec <xIsCallingFromIPTask>
 8004a0c:	b120      	cbz	r0, 8004a18 <FreeRTOS_OutputARPRequest+0x28>
		{
			/* Only the IP-task is allowed to call this function directly. */
			( void ) xNetworkInterfaceOutput( pxNetworkBuffer, pdTRUE );
 8004a0e:	4620      	mov	r0, r4
 8004a10:	2101      	movs	r1, #1
 8004a12:	f7ff fc27 	bl	8004264 <xNetworkInterfaceOutput>
 8004a16:	e00c      	b.n	8004a32 <FreeRTOS_OutputARPRequest+0x42>
		else
		{
		IPStackEvent_t xSendEvent;

			/* Send a message to the IP-task to send this ARP packet. */
			xSendEvent.eEventType = eNetworkTxEvent;
 8004a18:	2302      	movs	r3, #2
 8004a1a:	f88d 3000 	strb.w	r3, [sp]
			xSendEvent.pvData = pxNetworkBuffer;
 8004a1e:	9401      	str	r4, [sp, #4]
			if( xSendEventStructToIPTask( &xSendEvent, ( TickType_t ) portMAX_DELAY ) == pdFAIL )
 8004a20:	4668      	mov	r0, sp
 8004a22:	f04f 31ff 	mov.w	r1, #4294967295
 8004a26:	f000 fbc1 	bl	80051ac <xSendEventStructToIPTask>
 8004a2a:	b910      	cbnz	r0, 8004a32 <FreeRTOS_OutputARPRequest+0x42>
			{
				/* Failed to send the message, so release the network buffer. */
				vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 8004a2c:	4620      	mov	r0, r4
 8004a2e:	f7ff fdcf 	bl	80045d0 <vReleaseNetworkBufferAndDescriptor>
			}
		}
	}
}
 8004a32:	b003      	add	sp, #12
 8004a34:	bd30      	pop	{r4, r5, pc}
 8004a36:	bf00      	nop

08004a38 <vARPAgeCache>:
	return eReturn;
}
/*-----------------------------------------------------------*/

void vARPAgeCache( void )
{
 8004a38:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004a3a:	4e1a      	ldr	r6, [pc, #104]	; (8004aa4 <vARPAgeCache+0x6c>)
 8004a3c:	f106 040b 	add.w	r4, r6, #11
 8004a40:	3653      	adds	r6, #83	; 0x53

			if( xARPCache[ x ].ucAge == 0U )
			{
				/* The entry is no longer valid.  Wipe it out. */
				iptraceARP_TABLE_ENTRY_EXPIRED( xARPCache[ x ].ulIPAddress );
				xARPCache[ x ].ulIPAddress = 0UL;
 8004a42:	2700      	movs	r7, #0
 8004a44:	4625      	mov	r5, r4

	/* Loop through each entry in the ARP cache. */
	for( x = 0; x < ipconfigARP_CACHE_ENTRIES; x++ )
	{
		/* If the entry is valid (its age is greater than zero). */
		if( xARPCache[ x ].ucAge > 0U )
 8004a46:	f814 3c01 	ldrb.w	r3, [r4, #-1]
 8004a4a:	b1ab      	cbz	r3, 8004a78 <vARPAgeCache+0x40>
		{
			/* Decrement the age value of the entry in this ARP cache table row.
			When the age reaches zero it is no longer considered valid. */
			( xARPCache[ x ].ucAge )--;
 8004a4c:	3b01      	subs	r3, #1
 8004a4e:	b2db      	uxtb	r3, r3
 8004a50:	f804 3c01 	strb.w	r3, [r4, #-1]

			/* If the entry is not yet valid, then it is waiting an ARP
			reply, and the ARP request should be retransmitted. */
			if( xARPCache[ x ].ucValid == ( uint8_t ) pdFALSE )
 8004a54:	7822      	ldrb	r2, [r4, #0]
 8004a56:	b922      	cbnz	r2, 8004a62 <vARPAgeCache+0x2a>
			{
				FreeRTOS_OutputARPRequest( xARPCache[ x ].ulIPAddress );
 8004a58:	f854 0c0b 	ldr.w	r0, [r4, #-11]
 8004a5c:	f7ff ffc8 	bl	80049f0 <FreeRTOS_OutputARPRequest>
 8004a60:	e005      	b.n	8004a6e <vARPAgeCache+0x36>
			}
			else if( xARPCache[ x ].ucAge <= ( uint8_t ) arpMAX_ARP_AGE_BEFORE_NEW_ARP_REQUEST )
 8004a62:	2b03      	cmp	r3, #3
 8004a64:	d803      	bhi.n	8004a6e <vARPAgeCache+0x36>
			{
				/* This entry will get removed soon.  See if the MAC address is
				still valid to prevent this happening. */
				iptraceARP_TABLE_ENTRY_WILL_EXPIRE( xARPCache[ x ].ulIPAddress );
				FreeRTOS_OutputARPRequest( xARPCache[ x ].ulIPAddress );
 8004a66:	f854 0c0b 	ldr.w	r0, [r4, #-11]
 8004a6a:	f7ff ffc1 	bl	80049f0 <FreeRTOS_OutputARPRequest>
			else
			{
				/* The age has just ticked down, with nothing to do. */
			}

			if( xARPCache[ x ].ucAge == 0U )
 8004a6e:	f815 3c01 	ldrb.w	r3, [r5, #-1]
 8004a72:	b90b      	cbnz	r3, 8004a78 <vARPAgeCache+0x40>
			{
				/* The entry is no longer valid.  Wipe it out. */
				iptraceARP_TABLE_ENTRY_EXPIRED( xARPCache[ x ].ulIPAddress );
				xARPCache[ x ].ulIPAddress = 0UL;
 8004a74:	f845 7c0b 	str.w	r7, [r5, #-11]
 8004a78:	340c      	adds	r4, #12
{
BaseType_t x;
TickType_t xTimeNow;

	/* Loop through each entry in the ARP cache. */
	for( x = 0; x < ipconfigARP_CACHE_ENTRIES; x++ )
 8004a7a:	42b4      	cmp	r4, r6
 8004a7c:	d1e2      	bne.n	8004a44 <vARPAgeCache+0xc>
				xARPCache[ x ].ulIPAddress = 0UL;
			}
		}
	}

	xTimeNow = xTaskGetTickCount ();
 8004a7e:	f7fe fb9d 	bl	80031bc <xTaskGetTickCount>
 8004a82:	4604      	mov	r4, r0

	if( ( xLastGratuitousARPTime == ( TickType_t ) 0 ) || ( ( xTimeNow - xLastGratuitousARPTime ) > ( TickType_t ) arpGRATUITOUS_ARP_PERIOD ) )
 8004a84:	4b08      	ldr	r3, [pc, #32]	; (8004aa8 <vARPAgeCache+0x70>)
 8004a86:	681b      	ldr	r3, [r3, #0]
 8004a88:	b123      	cbz	r3, 8004a94 <vARPAgeCache+0x5c>
 8004a8a:	1ac3      	subs	r3, r0, r3
 8004a8c:	f644 6220 	movw	r2, #20000	; 0x4e20
 8004a90:	4293      	cmp	r3, r2
 8004a92:	d905      	bls.n	8004aa0 <vARPAgeCache+0x68>
	{
		FreeRTOS_OutputARPRequest( *ipLOCAL_IP_ADDRESS_POINTER );
 8004a94:	4b05      	ldr	r3, [pc, #20]	; (8004aac <vARPAgeCache+0x74>)
 8004a96:	6958      	ldr	r0, [r3, #20]
 8004a98:	f7ff ffaa 	bl	80049f0 <FreeRTOS_OutputARPRequest>
		xLastGratuitousARPTime = xTimeNow;
 8004a9c:	4b02      	ldr	r3, [pc, #8]	; (8004aa8 <vARPAgeCache+0x70>)
 8004a9e:	601c      	str	r4, [r3, #0]
 8004aa0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004aa2:	bf00      	nop
 8004aa4:	2000d270 	.word	0x2000d270
 8004aa8:	2000d26c 	.word	0x2000d26c
 8004aac:	2000d5c0 	.word	0x2000d5c0

08004ab0 <FreeRTOS_ClearARP>:
	iptraceCREATING_ARP_REQUEST( pxNetworkBuffer->ulIPAddress );
}
/*-----------------------------------------------------------*/

void FreeRTOS_ClearARP( void )
{
 8004ab0:	b508      	push	{r3, lr}
	( void ) memset( xARPCache, 0, sizeof( xARPCache ) );
 8004ab2:	4803      	ldr	r0, [pc, #12]	; (8004ac0 <FreeRTOS_ClearARP+0x10>)
 8004ab4:	2100      	movs	r1, #0
 8004ab6:	2248      	movs	r2, #72	; 0x48
 8004ab8:	f005 fa40 	bl	8009f3c <memset>
 8004abc:	bd08      	pop	{r3, pc}
 8004abe:	bf00      	nop
 8004ac0:	2000d270 	.word	0x2000d270

08004ac4 <prvSkipNameField>:
{
size_t uxChunkLength;
size_t uxSourceLenCpy = uxLength;
size_t uxIndex = 0U;

	if( uxSourceLenCpy == 0U )
 8004ac4:	460a      	mov	r2, r1
 8004ac6:	b1f9      	cbz	r1, 8004b08 <prvSkipNameField+0x44>
	{
		uxIndex = 0U;
	}
	/* Determine if the name is the fully coded name, or an offset to the name
	elsewhere in the message. */
	else if( ( pucByte[ uxIndex ] & dnsNAME_IS_OFFSET ) == dnsNAME_IS_OFFSET )
 8004ac8:	7803      	ldrb	r3, [r0, #0]
 8004aca:	f003 01c0 	and.w	r1, r3, #192	; 0xc0
 8004ace:	29c0      	cmp	r1, #192	; 0xc0
 8004ad0:	d008      	beq.n	8004ae4 <prvSkipNameField+0x20>
		}
	}
	else
	{
		/* pucByte points to the full name. Walk over the string. */
		while( ( pucByte[ uxIndex ] != 0U ) && ( uxSourceLenCpy > 1U ) )
 8004ad2:	b1db      	cbz	r3, 8004b0c <prvSkipNameField+0x48>
 8004ad4:	2a01      	cmp	r2, #1
 8004ad6:	d91b      	bls.n	8004b10 <prvSkipNameField+0x4c>
		{
			/* Conversion to size_t causes addition to be done
			in size_t */
			uxChunkLength = ( ( size_t ) pucByte[ uxIndex ] ) + 1U;
 8004ad8:	3301      	adds	r3, #1

			if( uxSourceLenCpy > uxChunkLength )
 8004ada:	429a      	cmp	r2, r3
 8004adc:	bf98      	it	ls
 8004ade:	2100      	movls	r1, #0
 8004ae0:	d91e      	bls.n	8004b20 <prvSkipNameField+0x5c>
 8004ae2:	e008      	b.n	8004af6 <prvSkipNameField+0x32>
		{
			uxIndex += sizeof( uint16_t );
		}
		else
		{
			uxIndex = 0U;
 8004ae4:	2a02      	cmp	r2, #2
 8004ae6:	bf8c      	ite	hi
 8004ae8:	2102      	movhi	r1, #2
 8004aea:	2100      	movls	r1, #0
 8004aec:	e018      	b.n	8004b20 <prvSkipNameField+0x5c>
		/* pucByte points to the full name. Walk over the string. */
		while( ( pucByte[ uxIndex ] != 0U ) && ( uxSourceLenCpy > 1U ) )
		{
			/* Conversion to size_t causes addition to be done
			in size_t */
			uxChunkLength = ( ( size_t ) pucByte[ uxIndex ] ) + 1U;
 8004aee:	3301      	adds	r3, #1

			if( uxSourceLenCpy > uxChunkLength )
 8004af0:	4293      	cmp	r3, r2
 8004af2:	d301      	bcc.n	8004af8 <prvSkipNameField+0x34>
 8004af4:	e00e      	b.n	8004b14 <prvSkipNameField+0x50>
 8004af6:	2100      	movs	r1, #0
			{
				uxSourceLenCpy -= uxChunkLength;
 8004af8:	1ad2      	subs	r2, r2, r3
				uxIndex += uxChunkLength;
 8004afa:	4419      	add	r1, r3
		}
	}
	else
	{
		/* pucByte points to the full name. Walk over the string. */
		while( ( pucByte[ uxIndex ] != 0U ) && ( uxSourceLenCpy > 1U ) )
 8004afc:	5c43      	ldrb	r3, [r0, r1]
 8004afe:	b16b      	cbz	r3, 8004b1c <prvSkipNameField+0x58>
 8004b00:	2a01      	cmp	r2, #1
 8004b02:	d8f4      	bhi.n	8004aee <prvSkipNameField+0x2a>
 8004b04:	2100      	movs	r1, #0
 8004b06:	e00b      	b.n	8004b20 <prvSkipNameField+0x5c>
size_t uxSourceLenCpy = uxLength;
size_t uxIndex = 0U;

	if( uxSourceLenCpy == 0U )
	{
		uxIndex = 0U;
 8004b08:	2100      	movs	r1, #0
 8004b0a:	e009      	b.n	8004b20 <prvSkipNameField+0x5c>
		}
	}
	else
	{
		/* pucByte points to the full name. Walk over the string. */
		while( ( pucByte[ uxIndex ] != 0U ) && ( uxSourceLenCpy > 1U ) )
 8004b0c:	2100      	movs	r1, #0
 8004b0e:	e007      	b.n	8004b20 <prvSkipNameField+0x5c>
 8004b10:	2100      	movs	r1, #0
 8004b12:	e005      	b.n	8004b20 <prvSkipNameField+0x5c>
 8004b14:	2100      	movs	r1, #0
 8004b16:	e003      	b.n	8004b20 <prvSkipNameField+0x5c>
		/* Confirm that a fully formed name was found. */
		if( uxIndex > 0U )
		{
			if( pucByte[ uxIndex ] == 0U )
			{
				uxIndex++;
 8004b18:	3101      	adds	r1, #1
 8004b1a:	e001      	b.n	8004b20 <prvSkipNameField+0x5c>
				break;
			}
		}

		/* Confirm that a fully formed name was found. */
		if( uxIndex > 0U )
 8004b1c:	2900      	cmp	r1, #0
 8004b1e:	d1fb      	bne.n	8004b18 <prvSkipNameField+0x54>
			}
		}
	}

	return uxIndex;
}
 8004b20:	4608      	mov	r0, r1
 8004b22:	4770      	bx	lr

08004b24 <prvProcessDNSCache>:

	static BaseType_t prvProcessDNSCache( const char *pcName,
									uint32_t *pulIP,
									uint32_t ulTTL,
									BaseType_t xLookUp )
	{
 8004b24:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004b28:	b083      	sub	sp, #12
 8004b2a:	4605      	mov	r5, r0
 8004b2c:	9001      	str	r0, [sp, #4]
 8004b2e:	460e      	mov	r6, r1
 8004b30:	4691      	mov	r9, r2
 8004b32:	4698      	mov	r8, r3
	BaseType_t x;
	BaseType_t xFound = pdFALSE;
	uint32_t ulCurrentTimeSeconds = ( xTaskGetTickCount() / portTICK_PERIOD_MS ) / 1000UL;
 8004b34:	f7fe fb42 	bl	80031bc <xTaskGetTickCount>
 8004b38:	4c42      	ldr	r4, [pc, #264]	; (8004c44 <prvProcessDNSCache+0x120>)
 8004b3a:	fba4 3400 	umull	r3, r4, r4, r0
 8004b3e:	09a4      	lsrs	r4, r4, #6
	uint32_t ulIPAddressIndex = 0;
	static BaseType_t xFreeEntry = 0;

		configASSERT( ( pcName != NULL ) );
 8004b40:	b945      	cbnz	r5, 8004b54 <prvProcessDNSCache+0x30>
 8004b42:	f04f 0314 	mov.w	r3, #20
 8004b46:	f383 8811 	msr	BASEPRI, r3
 8004b4a:	f3bf 8f6f 	isb	sy
 8004b4e:	f3bf 8f4f 	dsb	sy
 8004b52:	e7fe      	b.n	8004b52 <prvProcessDNSCache+0x2e>
 8004b54:	4f3c      	ldr	r7, [pc, #240]	; (8004c48 <prvProcessDNSCache+0x124>)
 8004b56:	2500      	movs	r5, #0

		/* For each entry in the DNS cache table. */
		for( x = 0; x < ipconfigDNS_CACHE_ENTRIES; x++ )
		{
			if( xDNSCache[ x ].pcName[ 0 ] == ( char ) 0 )
 8004b58:	793b      	ldrb	r3, [r7, #4]
 8004b5a:	2b00      	cmp	r3, #0
 8004b5c:	d039      	beq.n	8004bd2 <prvProcessDNSCache+0xae>
			{
				continue;
			}

			if( strcmp( xDNSCache[ x ].pcName, pcName ) == 0 )
 8004b5e:	1d38      	adds	r0, r7, #4
 8004b60:	9901      	ldr	r1, [sp, #4]
 8004b62:	f005 f9f3 	bl	8009f4c <strcmp>
 8004b66:	bba0      	cbnz	r0, 8004bd2 <prvProcessDNSCache+0xae>
			{
				/* Is this function called for a lookup or to add/update an IP address? */
				if( xLookUp != pdFALSE )
 8004b68:	f1b8 0f00 	cmp.w	r8, #0
 8004b6c:	d023      	beq.n	8004bb6 <prvProcessDNSCache+0x92>
				{
					/* Confirm that the record is still fresh. */
					if( ulCurrentTimeSeconds < ( xDNSCache[ x ].ulTimeWhenAddedInSeconds + FreeRTOS_ntohl( xDNSCache[ x ].ulTTL ) ) )
 8004b6e:	ebc5 01c5 	rsb	r1, r5, r5, lsl #3
 8004b72:	4b35      	ldr	r3, [pc, #212]	; (8004c48 <prvProcessDNSCache+0x124>)
 8004b74:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 8004b78:	694a      	ldr	r2, [r1, #20]
 8004b7a:	0613      	lsls	r3, r2, #24
 8004b7c:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 8004b80:	f402 407f 	and.w	r0, r2, #65280	; 0xff00
 8004b84:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 8004b88:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
 8004b8c:	ea43 2312 	orr.w	r3, r3, r2, lsr #8
 8004b90:	698a      	ldr	r2, [r1, #24]
 8004b92:	4413      	add	r3, r2
 8004b94:	429c      	cmp	r4, r3
 8004b96:	d206      	bcs.n	8004ba6 <prvProcessDNSCache+0x82>
						ucIndex = ucIndex % ( uint8_t ) ipconfigDNS_CACHE_ADDRESSES_PER_ENTRY;
						ulIPAddressIndex = ucIndex;

						xDNSCache[ x ].ucCurrentIPAddress++;
#endif
						*pulIP = xDNSCache[ x ].ulIPAddresses[ ulIPAddressIndex ];
 8004b98:	ebc5 05c5 	rsb	r5, r5, r5, lsl #3
 8004b9c:	4b2a      	ldr	r3, [pc, #168]	; (8004c48 <prvProcessDNSCache+0x124>)
 8004b9e:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 8004ba2:	6033      	str	r3, [r6, #0]
 8004ba4:	e04a      	b.n	8004c3c <prvProcessDNSCache+0x118>
					}
					else
					{
						/* Age out the old cached record. */
						xDNSCache[ x ].pcName[ 0 ] = ( char ) 0;
 8004ba6:	ebc5 05c5 	rsb	r5, r5, r5, lsl #3
 8004baa:	4b27      	ldr	r3, [pc, #156]	; (8004c48 <prvProcessDNSCache+0x124>)
 8004bac:	eb03 0385 	add.w	r3, r3, r5, lsl #2
 8004bb0:	2200      	movs	r2, #0
 8004bb2:	711a      	strb	r2, [r3, #4]
 8004bb4:	e042      	b.n	8004c3c <prvProcessDNSCache+0x118>

						ulIPAddressIndex = xDNSCache[ x ].ucNumIPAddresses;
						xDNSCache[ x ].ucNumIPAddresses++;
					}
#endif
					xDNSCache[ x ].ulIPAddresses[ ulIPAddressIndex ] = *pulIP;
 8004bb6:	6836      	ldr	r6, [r6, #0]
 8004bb8:	4b23      	ldr	r3, [pc, #140]	; (8004c48 <prvProcessDNSCache+0x124>)
 8004bba:	00ea      	lsls	r2, r5, #3
 8004bbc:	1b51      	subs	r1, r2, r5
 8004bbe:	0089      	lsls	r1, r1, #2
 8004bc0:	1858      	adds	r0, r3, r1
 8004bc2:	505e      	str	r6, [r3, r1]
					xDNSCache[ x ].ulTTL = ulTTL;
 8004bc4:	f8c0 9014 	str.w	r9, [r0, #20]
					xDNSCache[ x ].ulTimeWhenAddedInSeconds = ulCurrentTimeSeconds;
 8004bc8:	1b52      	subs	r2, r2, r5
 8004bca:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8004bce:	619c      	str	r4, [r3, #24]
 8004bd0:	e034      	b.n	8004c3c <prvProcessDNSCache+0x118>
	static BaseType_t xFreeEntry = 0;

		configASSERT( ( pcName != NULL ) );

		/* For each entry in the DNS cache table. */
		for( x = 0; x < ipconfigDNS_CACHE_ENTRIES; x++ )
 8004bd2:	3501      	adds	r5, #1
 8004bd4:	371c      	adds	r7, #28
 8004bd6:	2d04      	cmp	r5, #4
 8004bd8:	d1be      	bne.n	8004b58 <prvProcessDNSCache+0x34>
 8004bda:	e02b      	b.n	8004c34 <prvProcessDNSCache+0x110>

		if( xFound == pdFALSE )
		{
			if( xLookUp != pdFALSE )
			{
				*pulIP = 0UL;
 8004bdc:	2000      	movs	r0, #0
 8004bde:	6030      	str	r0, [r6, #0]
 8004be0:	e02d      	b.n	8004c3e <prvProcessDNSCache+0x11a>
			}
			else
			{
				/* Add or update the item. */
				if( strlen( pcName ) < ( size_t ) ipconfigDNS_CACHE_NAME_LENGTH )
 8004be2:	9801      	ldr	r0, [sp, #4]
 8004be4:	f005 f9c6 	bl	8009f74 <strlen>
 8004be8:	280f      	cmp	r0, #15
 8004bea:	d81f      	bhi.n	8004c2c <prvProcessDNSCache+0x108>
				{
					( void ) strcpy( xDNSCache[ xFreeEntry ].pcName, pcName );
 8004bec:	f8df a05c 	ldr.w	sl, [pc, #92]	; 8004c4c <prvProcessDNSCache+0x128>
 8004bf0:	f8da 5000 	ldr.w	r5, [sl]
 8004bf4:	f8df b050 	ldr.w	fp, [pc, #80]	; 8004c48 <prvProcessDNSCache+0x124>
 8004bf8:	ebc5 07c5 	rsb	r7, r5, r5, lsl #3
 8004bfc:	00bf      	lsls	r7, r7, #2
 8004bfe:	eb0b 0807 	add.w	r8, fp, r7
 8004c02:	f108 0004 	add.w	r0, r8, #4
 8004c06:	9901      	ldr	r1, [sp, #4]
 8004c08:	f005 f9a6 	bl	8009f58 <strcpy>

					xDNSCache[ xFreeEntry ].ulIPAddresses[ 0 ] = *pulIP;
 8004c0c:	6833      	ldr	r3, [r6, #0]
 8004c0e:	f84b 3007 	str.w	r3, [fp, r7]
					xDNSCache[ xFreeEntry ].ulTTL = ulTTL;
 8004c12:	f8c8 9014 	str.w	r9, [r8, #20]
					xDNSCache[ xFreeEntry ].ulTimeWhenAddedInSeconds = ulCurrentTimeSeconds;
 8004c16:	f8c8 4018 	str.w	r4, [r8, #24]
							0,
							sizeof( xDNSCache[ xFreeEntry ].ulIPAddresses[ 1 ] ) *
								( ( uint32_t ) ipconfigDNS_CACHE_ADDRESSES_PER_ENTRY - 1U ) );
#endif

					xFreeEntry++;
 8004c1a:	3501      	adds	r5, #1
 8004c1c:	f8ca 5000 	str.w	r5, [sl]

					if( xFreeEntry == ipconfigDNS_CACHE_ENTRIES )
 8004c20:	2d04      	cmp	r5, #4
 8004c22:	d105      	bne.n	8004c30 <prvProcessDNSCache+0x10c>
					{
						xFreeEntry = 0;
 8004c24:	2000      	movs	r0, #0
 8004c26:	f8ca 0000 	str.w	r0, [sl]
 8004c2a:	e008      	b.n	8004c3e <prvProcessDNSCache+0x11a>
									uint32_t *pulIP,
									uint32_t ulTTL,
									BaseType_t xLookUp )
	{
	BaseType_t x;
	BaseType_t xFound = pdFALSE;
 8004c2c:	2000      	movs	r0, #0
 8004c2e:	e006      	b.n	8004c3e <prvProcessDNSCache+0x11a>
 8004c30:	2000      	movs	r0, #0
 8004c32:	e004      	b.n	8004c3e <prvProcessDNSCache+0x11a>
			}
		}

		if( xFound == pdFALSE )
		{
			if( xLookUp != pdFALSE )
 8004c34:	f1b8 0f00 	cmp.w	r8, #0
 8004c38:	d0d3      	beq.n	8004be2 <prvProcessDNSCache+0xbe>
 8004c3a:	e7cf      	b.n	8004bdc <prvProcessDNSCache+0xb8>
	BaseType_t xFound = pdFALSE;
	uint32_t ulCurrentTimeSeconds = ( xTaskGetTickCount() / portTICK_PERIOD_MS ) / 1000UL;
	uint32_t ulIPAddressIndex = 0;
	static BaseType_t xFreeEntry = 0;

		configASSERT( ( pcName != NULL ) );
 8004c3c:	2001      	movs	r0, #1
		if( ( xLookUp == 0 ) || ( *pulIP != 0UL ) )
		{
			FreeRTOS_debug_printf( ( "prvProcessDNSCache: %s: '%s' @ %lxip\n", ( xLookUp != 0 ) ? "look-up" : "add", pcName, FreeRTOS_ntohl( *pulIP ) ) );
		}
		return xFound;
	}
 8004c3e:	b003      	add	sp, #12
 8004c40:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004c44:	10624dd3 	.word	0x10624dd3
 8004c48:	2000d2d0 	.word	0x2000d2d0
 8004c4c:	2000d2cc 	.word	0x2000d2cc

08004c50 <prvParseDNSReply>:
/*-----------------------------------------------------------*/

_static uint32_t prvParseDNSReply( uint8_t *pucUDPPayloadBuffer,
								  size_t uxBufferLength,
								  BaseType_t xExpected )
{
 8004c50:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004c54:	b08d      	sub	sp, #52	; 0x34
DNSMessage_t *pxDNSMessageHeader;
/* This pointer is not used to modify anything */
const DNSAnswerRecord_t *pxDNSAnswerRecord; 
uint32_t ulIPAddress = 0UL;
 8004c56:	2300      	movs	r3, #0
 8004c58:	930b      	str	r3, [sp, #44]	; 0x2c
#if( ipconfigUSE_LLMNR == 1 )
	uint16_t usClass = 0U;
#endif
#if( ipconfigUSE_DNS_CACHE == 1 ) || ( ipconfigDNS_USE_CALLBACKS == 1 )
	BaseType_t xDoStore = xExpected;
	char pcName[ ipconfigDNS_CACHE_NAME_LENGTH ] = "";
 8004c5a:	9307      	str	r3, [sp, #28]
 8004c5c:	9308      	str	r3, [sp, #32]
 8004c5e:	9309      	str	r3, [sp, #36]	; 0x24
 8004c60:	930a      	str	r3, [sp, #40]	; 0x28
#endif

	/* Ensure that the buffer is of at least minimal DNS message length. */
	if( uxBufferLength < sizeof( DNSMessage_t ) )
 8004c62:	290b      	cmp	r1, #11
 8004c64:	f240 810d 	bls.w	8004e82 <prvParseDNSReply+0x232>
 8004c68:	9200      	str	r2, [sp, #0]
 8004c6a:	4606      	mov	r6, r0
		{
		size_t uxBytesRead = 0U;
		size_t uxResult;

			/* Start at the first byte after the header. */
			pucByte = &( pucUDPPayloadBuffer [ sizeof( DNSMessage_t ) ] );
 8004c6c:	f100 050c 	add.w	r5, r0, #12
			uxSourceBytesRemaining -= sizeof( DNSMessage_t );
 8004c70:	f1a1 040c 	sub.w	r4, r1, #12

			/* Skip any question records. */
			usQuestions = FreeRTOS_ntohs( pxDNSMessageHeader->usQuestions );
 8004c74:	f8b0 8004 	ldrh.w	r8, [r0, #4]
 8004c78:	ea4f 2318 	mov.w	r3, r8, lsr #8
 8004c7c:	ea43 2808 	orr.w	r8, r3, r8, lsl #8
 8004c80:	fa1f f888 	uxth.w	r8, r8

			for( x = 0U; x < usQuestions; x++ )
 8004c84:	f1b8 0f00 	cmp.w	r8, #0
 8004c88:	f000 8101 	beq.w	8004e8e <prvParseDNSReply+0x23e>
 8004c8c:	2700      	movs	r7, #0
		else if( ( pucByte[ uxIndex ] & dnsNAME_IS_OFFSET ) == dnsNAME_IS_OFFSET )
		{
			/* Jump over the two byte offset. */
			if( uxSourceLen > sizeof( uint16_t ) )
			{
				uxIndex += sizeof( uint16_t );
 8004c8e:	f04f 0b02 	mov.w	fp, #2
			}
		}
		else
		{
			/* 'uxIndex' points to the full name. Walk over the string. */
			while( ( uxIndex < uxSourceLen ) && ( pucByte[ uxIndex ] != ( uint8_t )0x00U ) )
 8004c92:	46b9      	mov	r9, r7
 8004c94:	9701      	str	r7, [sp, #4]
					}
				}
				#endif

#if( ipconfigUSE_DNS_CACHE == 1 ) || ( ipconfigDNS_USE_CALLBACKS == 1 )
				if( x == 0U )
 8004c96:	2f00      	cmp	r7, #0
 8004c98:	d162      	bne.n	8004d60 <prvParseDNSReply+0x110>

	/* uxCount gets the valus from pucByte and counts down to 0.
	No need to have a different type than that of pucByte */
	size_t uxCount;  

		if( uxSourceLen == ( size_t ) 0U )
 8004c9a:	2c00      	cmp	r4, #0
 8004c9c:	f000 80f1 	beq.w	8004e82 <prvParseDNSReply+0x232>
			/* Return 0 value in case of error. */
			uxIndex = 0U;
		}
		/* Determine if the name is the fully coded name, or an offset to the name
		elsewhere in the message. */
		else if( ( pucByte[ uxIndex ] & dnsNAME_IS_OFFSET ) == dnsNAME_IS_OFFSET )
 8004ca0:	7829      	ldrb	r1, [r5, #0]
 8004ca2:	f001 03c0 	and.w	r3, r1, #192	; 0xc0
 8004ca6:	2bc0      	cmp	r3, #192	; 0xc0
 8004ca8:	d001      	beq.n	8004cae <prvParseDNSReply+0x5e>
			}
		}
		else
		{
			/* 'uxIndex' points to the full name. Walk over the string. */
			while( ( uxIndex < uxSourceLen ) && ( pucByte[ uxIndex ] != ( uint8_t )0x00U ) )
 8004caa:	b969      	cbnz	r1, 8004cc8 <prvParseDNSReply+0x78>
 8004cac:	e0e9      	b.n	8004e82 <prvParseDNSReply+0x232>
		/* Determine if the name is the fully coded name, or an offset to the name
		elsewhere in the message. */
		else if( ( pucByte[ uxIndex ] & dnsNAME_IS_OFFSET ) == dnsNAME_IS_OFFSET )
		{
			/* Jump over the two byte offset. */
			if( uxSourceLen > sizeof( uint16_t ) )
 8004cae:	2c02      	cmp	r4, #2
 8004cb0:	d852      	bhi.n	8004d58 <prvParseDNSReply+0x108>
 8004cb2:	e0e6      	b.n	8004e82 <prvParseDNSReply+0x232>
			/* 'uxIndex' points to the full name. Walk over the string. */
			while( ( uxIndex < uxSourceLen ) && ( pucByte[ uxIndex ] != ( uint8_t )0x00U ) )
			{
				/* If this is not the first time through the loop, then add a
				separator in the output. */
				if( ( uxNameLen > 0U ) )
 8004cb4:	b162      	cbz	r2, 8004cd0 <prvParseDNSReply+0x80>
				{
					if( uxNameLen >= uxDestLen )
 8004cb6:	2a0f      	cmp	r2, #15
 8004cb8:	f200 80e3 	bhi.w	8004e82 <prvParseDNSReply+0x232>
					{
						uxIndex = 0U;
						/* coverity[break_stmt] : Break statement terminating the loop */
						break;
					}
					pcName[ uxNameLen ] = '.';
 8004cbc:	ab0c      	add	r3, sp, #48	; 0x30
 8004cbe:	4413      	add	r3, r2
 8004cc0:	f803 ac14 	strb.w	sl, [r3, #-20]
					uxNameLen++;
 8004cc4:	3201      	adds	r2, #1
 8004cc6:	e003      	b.n	8004cd0 <prvParseDNSReply+0x80>
			}
		}
		else
		{
			/* 'uxIndex' points to the full name. Walk over the string. */
			while( ( uxIndex < uxSourceLen ) && ( pucByte[ uxIndex ] != ( uint8_t )0x00U ) )
 8004cc8:	4648      	mov	r0, r9
 8004cca:	9a01      	ldr	r2, [sp, #4]
					{
						uxIndex = 0U;
						/* coverity[break_stmt] : Break statement terminating the loop */
						break;
					}
					pcName[ uxNameLen ] = '.';
 8004ccc:	f04f 0a2e 	mov.w	sl, #46	; 0x2e
					uxNameLen++;
				}

				/* Process the first/next sub-string. */
				uxCount = ( size_t ) pucByte[ uxIndex ];
 8004cd0:	468c      	mov	ip, r1
				uxIndex++;
 8004cd2:	1c43      	adds	r3, r0, #1
				if( ( uxIndex + uxCount ) > uxSourceLen )
 8004cd4:	eb03 0e01 	add.w	lr, r3, r1
 8004cd8:	45a6      	cmp	lr, r4
 8004cda:	f200 80d2 	bhi.w	8004e82 <prvParseDNSReply+0x232>
				{
					uxIndex = 0U;
					break;
				}

				while( ( uxCount-- != 0U ) && ( uxIndex < uxSourceLen ) )
 8004cde:	b1c1      	cbz	r1, 8004d12 <prvParseDNSReply+0xc2>
 8004ce0:	42a3      	cmp	r3, r4
 8004ce2:	d225      	bcs.n	8004d30 <prvParseDNSReply+0xe0>
				{
					if( uxNameLen >= uxDestLen )
 8004ce4:	2a0f      	cmp	r2, #15
 8004ce6:	d816      	bhi.n	8004d16 <prvParseDNSReply+0xc6>
 8004ce8:	4428      	add	r0, r5
 8004cea:	a907      	add	r1, sp, #28
 8004cec:	eb01 0e02 	add.w	lr, r1, r2
 8004cf0:	4494      	add	ip, r2
 8004cf2:	3201      	adds	r2, #1
 8004cf4:	e003      	b.n	8004cfe <prvParseDNSReply+0xae>
 8004cf6:	1c51      	adds	r1, r2, #1
 8004cf8:	2911      	cmp	r1, #17
 8004cfa:	d00e      	beq.n	8004d1a <prvParseDNSReply+0xca>
 8004cfc:	460a      	mov	r2, r1
						uxIndex = 0U;
						break;
						/* break out of inner loop here
						break out of outer loop at the test uxNameLen >= uxDestLen. */
					}
					pcName[ uxNameLen ] = ( char ) pucByte[ uxIndex ];
 8004cfe:	f810 1f01 	ldrb.w	r1, [r0, #1]!
 8004d02:	f80e 1b01 	strb.w	r1, [lr], #1
					uxNameLen++;
					uxIndex++;
 8004d06:	3301      	adds	r3, #1
				{
					uxIndex = 0U;
					break;
				}

				while( ( uxCount-- != 0U ) && ( uxIndex < uxSourceLen ) )
 8004d08:	4562      	cmp	r2, ip
 8004d0a:	d008      	beq.n	8004d1e <prvParseDNSReply+0xce>
 8004d0c:	42a3      	cmp	r3, r4
 8004d0e:	d3f2      	bcc.n	8004cf6 <prvParseDNSReply+0xa6>
 8004d10:	e00e      	b.n	8004d30 <prvParseDNSReply+0xe0>
					uxNameLen++;
				}

				/* Process the first/next sub-string. */
				uxCount = ( size_t ) pucByte[ uxIndex ];
				uxIndex++;
 8004d12:	4618      	mov	r0, r3
 8004d14:	e004      	b.n	8004d20 <prvParseDNSReply+0xd0>

				while( ( uxCount-- != 0U ) && ( uxIndex < uxSourceLen ) )
				{
					if( uxNameLen >= uxDestLen )
					{
						uxIndex = 0U;
 8004d16:	9801      	ldr	r0, [sp, #4]
 8004d18:	e002      	b.n	8004d20 <prvParseDNSReply+0xd0>
 8004d1a:	9801      	ldr	r0, [sp, #4]
 8004d1c:	e000      	b.n	8004d20 <prvParseDNSReply+0xd0>
						/* break out of inner loop here
						break out of outer loop at the test uxNameLen >= uxDestLen. */
					}
					pcName[ uxNameLen ] = ( char ) pucByte[ uxIndex ];
					uxNameLen++;
					uxIndex++;
 8004d1e:	4618      	mov	r0, r3
			}
		}
		else
		{
			/* 'uxIndex' points to the full name. Walk over the string. */
			while( ( uxIndex < uxSourceLen ) && ( pucByte[ uxIndex ] != ( uint8_t )0x00U ) )
 8004d20:	42a0      	cmp	r0, r4
 8004d22:	d204      	bcs.n	8004d2e <prvParseDNSReply+0xde>
 8004d24:	5c29      	ldrb	r1, [r5, r0]
 8004d26:	2900      	cmp	r1, #0
 8004d28:	d1c4      	bne.n	8004cb4 <prvParseDNSReply+0x64>
 8004d2a:	4603      	mov	r3, r0
 8004d2c:	e000      	b.n	8004d30 <prvParseDNSReply+0xe0>
 8004d2e:	4603      	mov	r3, r0
					uxIndex++;
				}
			}

			/* Confirm that a fully formed name was found. */
			if( uxIndex > 0U )
 8004d30:	2b00      	cmp	r3, #0
 8004d32:	f000 80a6 	beq.w	8004e82 <prvParseDNSReply+0x232>
			{
				if( ( uxNameLen < uxDestLen ) && ( uxIndex < uxSourceLen ) && ( pucByte[ uxIndex ] == 0U ) )
 8004d36:	2a0f      	cmp	r2, #15
 8004d38:	f200 80a3 	bhi.w	8004e82 <prvParseDNSReply+0x232>
 8004d3c:	42a3      	cmp	r3, r4
 8004d3e:	f080 80a0 	bcs.w	8004e82 <prvParseDNSReply+0x232>
 8004d42:	5ce9      	ldrb	r1, [r5, r3]
 8004d44:	2900      	cmp	r1, #0
 8004d46:	f040 809c 	bne.w	8004e82 <prvParseDNSReply+0x232>
				{
					pcName[ uxNameLen ] = '\0';
 8004d4a:	a90c      	add	r1, sp, #48	; 0x30
 8004d4c:	440a      	add	r2, r1
 8004d4e:	f802 9c14 	strb.w	r9, [r2, #-20]
												 uxSourceBytesRemaining,
												 pcName,
												 sizeof( pcName ) );

					/* Check for a malformed response. */
					if( uxResult == 0U )
 8004d52:	1c59      	adds	r1, r3, #1
 8004d54:	d101      	bne.n	8004d5a <prvParseDNSReply+0x10a>
 8004d56:	e094      	b.n	8004e82 <prvParseDNSReply+0x232>
		else if( ( pucByte[ uxIndex ] & dnsNAME_IS_OFFSET ) == dnsNAME_IS_OFFSET )
		{
			/* Jump over the two byte offset. */
			if( uxSourceLen > sizeof( uint16_t ) )
			{
				uxIndex += sizeof( uint16_t );
 8004d58:	4659      	mov	r1, fp
					{
						xReturn = pdFALSE;
						break;
					}
					uxBytesRead += uxResult;
					pucByte = &( pucByte[ uxResult ] );
 8004d5a:	440d      	add	r5, r1
					uxSourceBytesRemaining -= uxResult;
 8004d5c:	1a61      	subs	r1, r4, r1
 8004d5e:	e008      	b.n	8004d72 <prvParseDNSReply+0x122>
				}
				else
#endif /* ipconfigUSE_DNS_CACHE || ipconfigDNS_USE_CALLBACKS */
				{
					/* Skip the variable length pcName field. */
					uxResult = prvSkipNameField( pucByte,
 8004d60:	4628      	mov	r0, r5
 8004d62:	4621      	mov	r1, r4
 8004d64:	f7ff feae 	bl	8004ac4 <prvSkipNameField>
												 uxSourceBytesRemaining );

					/* Check for a malformed response. */
					if( uxResult == 0U )
 8004d68:	2800      	cmp	r0, #0
 8004d6a:	f000 808a 	beq.w	8004e82 <prvParseDNSReply+0x232>
					{
						xReturn = pdFALSE;
						break;
					}
					uxBytesRead += uxResult;
					pucByte = &( pucByte[ uxResult ] );
 8004d6e:	4405      	add	r5, r0
					uxSourceBytesRemaining -= uxResult;
 8004d70:	1a21      	subs	r1, r4, r0
				}

				/* Check the remaining buffer size. */
				if( uxSourceBytesRemaining >= sizeof( uint32_t ) )
 8004d72:	2903      	cmp	r1, #3
 8004d74:	f240 8085 	bls.w	8004e82 <prvParseDNSReply+0x232>
						usClass = usChar2u16( &( pucByte[ 2 ] ) );
					}
					#endif /* ipconfigUSE_LLMNR */

					/* Skip the type and class fields. */
					pucByte = &( pucByte[ sizeof( uint32_t ) ] );
 8004d78:	3504      	adds	r5, #4
					uxSourceBytesRemaining -= sizeof( uint32_t );
 8004d7a:	1f0c      	subs	r4, r1, #4
			uxSourceBytesRemaining -= sizeof( DNSMessage_t );

			/* Skip any question records. */
			usQuestions = FreeRTOS_ntohs( pxDNSMessageHeader->usQuestions );

			for( x = 0U; x < usQuestions; x++ )
 8004d7c:	3701      	adds	r7, #1
 8004d7e:	b2bf      	uxth	r7, r7
 8004d80:	45b8      	cmp	r8, r7
 8004d82:	d188      	bne.n	8004c96 <prvParseDNSReply+0x46>
 8004d84:	e083      	b.n	8004e8e <prvParseDNSReply+0x23e>
			if( ( pxDNSMessageHeader->usFlags & dnsRX_FLAGS_MASK ) == dnsEXPECTED_RX_FLAGS )
			{
			const uint16_t usCount = ( uint16_t ) ipconfigDNS_CACHE_ADDRESSES_PER_ENTRY;
			uint16_t usNumARecordsStored = 0;
	
				for( x = 0U; x < pxDNSMessageHeader->usAnswers; x++ )
 8004d86:	b923      	cbnz	r3, 8004d92 <prvParseDNSReply+0x142>
 8004d88:	e09a      	b.n	8004ec0 <prvParseDNSReply+0x270>
				{
				BaseType_t xDoAccept;
	
					if( usNumARecordsStored >= usCount )
 8004d8a:	f1b9 0f00 	cmp.w	r9, #0
 8004d8e:	d007      	beq.n	8004da0 <prvParseDNSReply+0x150>
 8004d90:	e096      	b.n	8004ec0 <prvParseDNSReply+0x270>
			if( ( pxDNSMessageHeader->usFlags & dnsRX_FLAGS_MASK ) == dnsEXPECTED_RX_FLAGS )
			{
			const uint16_t usCount = ( uint16_t ) ipconfigDNS_CACHE_ADDRESSES_PER_ENTRY;
			uint16_t usNumARecordsStored = 0;
	
				for( x = 0U; x < pxDNSMessageHeader->usAnswers; x++ )
 8004d92:	9b00      	ldr	r3, [sp, #0]
 8004d94:	9301      	str	r3, [sp, #4]
 8004d96:	2700      	movs	r7, #0
	const ListItem_t * pxIterator;
	const ListItem_t * xEnd = listGET_END_MARKER( &xCallbackList );

		vTaskSuspendAll();
		{
			for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( xEnd );
 8004d98:	f8df a144 	ldr.w	sl, [pc, #324]	; 8004ee0 <prvParseDNSReply+0x290>
 8004d9c:	f10a 0808 	add.w	r8, sl, #8
					{
						/* Only count ipconfigDNS_CACHE_ADDRESSES_PER_ENTRY number of records. */
						break;
					}

					uxResult = prvSkipNameField( pucByte,
 8004da0:	4628      	mov	r0, r5
 8004da2:	4621      	mov	r1, r4
 8004da4:	f7ff fe8e 	bl	8004ac4 <prvSkipNameField>
												 uxSourceBytesRemaining );
	
					/* Check for a malformed response. */
					if( uxResult == 0U )
 8004da8:	2800      	cmp	r0, #0
 8004daa:	d06a      	beq.n	8004e82 <prvParseDNSReply+0x232>
						xReturn = pdFALSE;
						break;
					}

					uxBytesRead += uxResult;
					pucByte = &( pucByte[ uxResult ] );
 8004dac:	4405      	add	r5, r0
					uxSourceBytesRemaining -= uxResult;
 8004dae:	1a24      	subs	r4, r4, r0

					/* Is there enough data for an IPv4 A record answer and, if so,
					is this an A record? */
					if( uxSourceBytesRemaining < sizeof( uint16_t ) )
 8004db0:	2c01      	cmp	r4, #1
 8004db2:	d966      	bls.n	8004e82 <prvParseDNSReply+0x232>
}

static portINLINE uint16_t usChar2u16 (const uint8_t *apChr);
static portINLINE uint16_t usChar2u16 (const uint8_t *apChr)
{
	return ( uint16_t )
 8004db4:	782a      	ldrb	r2, [r5, #0]
 8004db6:	786b      	ldrb	r3, [r5, #1]
						xReturn = pdFALSE;
						break;
					}
					usType = usChar2u16( pucByte );

					if( usType == ( uint16_t ) dnsTYPE_A_HOST )
 8004db8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8004dbc:	2b01      	cmp	r3, #1
 8004dbe:	d151      	bne.n	8004e64 <prvParseDNSReply+0x214>
					{
						/* Unknown host type. */
						xDoAccept = pdFALSE;
					}

					if( xDoAccept != pdFALSE )
 8004dc0:	2c0d      	cmp	r4, #13
 8004dc2:	d94f      	bls.n	8004e64 <prvParseDNSReply+0x214>
						/* Mapping pucByte to a DNSAnswerRecord allows easy access of the
						 * fields of the structure. */
						pxDNSAnswerRecord = ipCAST_PTR_TO_TYPE_PTR( DNSAnswerRecord_t, pucByte );

						/* Sanity check the data length of an IPv4 answer. */
						if( FreeRTOS_ntohs( pxDNSAnswerRecord->usDataLength ) == ( uint16_t ) sizeof( uint32_t ) )
 8004dc4:	892a      	ldrh	r2, [r5, #8]
 8004dc6:	0a13      	lsrs	r3, r2, #8
 8004dc8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8004dcc:	b21b      	sxth	r3, r3
 8004dce:	2b04      	cmp	r3, #4
 8004dd0:	d13e      	bne.n	8004e50 <prvParseDNSReply+0x200>
						{
							/* Copy the IP address out of the record. Using different pointers
							 * to copy only the portion we want is intentional here. */
							( void ) memcpy( ( void * ) ( &( ulIPAddress ) ),
 8004dd2:	f8d5 000a 	ldr.w	r0, [r5, #10]
 8004dd6:	900b      	str	r0, [sp, #44]	; 0x2c
											 sizeof( uint32_t ) );

							#if( ipconfigDNS_USE_CALLBACKS == 1 )
							{
								/* See if any asynchronous call was made to FreeRTOS_gethostbyname_a() */
								if( xDNSDoCallback( ( TickType_t ) pxDNSMessageHeader->usIdentifier, pcName, ulIPAddress ) != pdFALSE )
 8004dd8:	f8b6 9000 	ldrh.w	r9, [r6]
 8004ddc:	f8dd b02c 	ldr.w	fp, [sp, #44]	; 0x2c
	{
	BaseType_t xResult = pdFALSE;
	const ListItem_t * pxIterator;
	const ListItem_t * xEnd = listGET_END_MARKER( &xCallbackList );

		vTaskSuspendAll();
 8004de0:	f7fe f9e4 	bl	80031ac <vTaskSuspendAll>
		{
			for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( xEnd );
 8004de4:	f8da 300c 	ldr.w	r3, [sl, #12]
 8004de8:	4543      	cmp	r3, r8
 8004dea:	d05c      	beq.n	8004ea6 <prvParseDNSReply+0x256>
				 pxIterator != ( const ListItem_t * ) xEnd;
				 pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
			{
				if( listGET_LIST_ITEM_VALUE( pxIterator ) == uxIdentifier )
 8004dec:	681a      	ldr	r2, [r3, #0]
 8004dee:	4591      	cmp	r9, r2
 8004df0:	d003      	beq.n	8004dfa <prvParseDNSReply+0x1aa>
 8004df2:	e01a      	b.n	8004e2a <prvParseDNSReply+0x1da>
 8004df4:	681a      	ldr	r2, [r3, #0]
 8004df6:	4591      	cmp	r9, r2
 8004df8:	d117      	bne.n	8004e2a <prvParseDNSReply+0x1da>
				{
				DNSCallback_t *pxCallback = ipCAST_PTR_TO_TYPE_PTR( DNSCallback_t, listGET_LIST_ITEM_OWNER( pxIterator ) );
 8004dfa:	f8d3 900c 	ldr.w	r9, [r3, #12]

					pxCallback->pCallbackFunction( pcName, pxCallback->pvSearchID, ulIPAddress );
 8004dfe:	f8d9 3004 	ldr.w	r3, [r9, #4]
 8004e02:	a807      	add	r0, sp, #28
 8004e04:	f8d9 1010 	ldr.w	r1, [r9, #16]
 8004e08:	465a      	mov	r2, fp
 8004e0a:	4798      	blx	r3
					( void ) uxListRemove( &pxCallback->xListItem );
 8004e0c:	f109 0014 	add.w	r0, r9, #20
 8004e10:	f7fd faa2 	bl	8002358 <uxListRemove>
					vPortFree( pxCallback );
 8004e14:	4648      	mov	r0, r9
 8004e16:	f7ff f905 	bl	8004024 <vPortFree>

					if( listLIST_IS_EMPTY( &xCallbackList ) != pdFALSE )
 8004e1a:	f8da 3000 	ldr.w	r3, [sl]
 8004e1e:	2b00      	cmp	r3, #0
 8004e20:	d149      	bne.n	8004eb6 <prvParseDNSReply+0x266>
					{
						/* The list of outstanding requests is empty. No need for periodic polling. */
						vIPSetDnsTimerEnableState( pdFALSE );
 8004e22:	2000      	movs	r0, #0
 8004e24:	f000 fdf4 	bl	8005a10 <vIPSetDnsTimerEnableState>
 8004e28:	e045      	b.n	8004eb6 <prvParseDNSReply+0x266>

		vTaskSuspendAll();
		{
			for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( xEnd );
				 pxIterator != ( const ListItem_t * ) xEnd;
				 pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
 8004e2a:	685b      	ldr	r3, [r3, #4]
	const ListItem_t * pxIterator;
	const ListItem_t * xEnd = listGET_END_MARKER( &xCallbackList );

		vTaskSuspendAll();
		{
			for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( xEnd );
 8004e2c:	4543      	cmp	r3, r8
 8004e2e:	d1e1      	bne.n	8004df4 <prvParseDNSReply+0x1a4>
 8004e30:	e039      	b.n	8004ea6 <prvParseDNSReply+0x256>

								/* The reply will only be stored in the DNS cache when the
								request was issued by this device. */
								if( xDoStore != pdFALSE )
								{
									( void ) prvProcessDNSCache( pcName, &ulIPAddress, pxDNSAnswerRecord->ulTTL, pdFALSE );
 8004e32:	a807      	add	r0, sp, #28
 8004e34:	a90b      	add	r1, sp, #44	; 0x2c
 8004e36:	686a      	ldr	r2, [r5, #4]
 8004e38:	2300      	movs	r3, #0
 8004e3a:	f7ff fe73 	bl	8004b24 <prvProcessDNSCache>
									usNumARecordsStored++;    /* Track # of A records stored */
 8004e3e:	f04f 0901 	mov.w	r9, #1
								}

								( void ) FreeRTOS_inet_ntop( FREERTOS_AF_INET, ( const void * ) &( ulIPAddress ), cBuffer, sizeof( cBuffer ) );
 8004e42:	2002      	movs	r0, #2
 8004e44:	a90b      	add	r1, sp, #44	; 0x2c
 8004e46:	aa03      	add	r2, sp, #12
 8004e48:	2310      	movs	r3, #16
 8004e4a:	f001 fae5 	bl	8006418 <FreeRTOS_inet_ntop>
 8004e4e:	e001      	b.n	8004e54 <prvParseDNSReply+0x204>
 8004e50:	f04f 0900 	mov.w	r9, #0
												   ( xDoStore != 0 ) ? "" : " NOT" ) );
							}
							#endif /* ipconfigUSE_DNS_CACHE */
						}

						pucByte = &( pucByte[ sizeof( DNSAnswerRecord_t ) + sizeof( uint32_t ) ] );
 8004e54:	350e      	adds	r5, #14
						uxSourceBytesRemaining -= ( sizeof( DNSAnswerRecord_t ) + sizeof( uint32_t ) );
 8004e56:	3c0e      	subs	r4, #14
			if( ( pxDNSMessageHeader->usFlags & dnsRX_FLAGS_MASK ) == dnsEXPECTED_RX_FLAGS )
			{
			const uint16_t usCount = ( uint16_t ) ipconfigDNS_CACHE_ADDRESSES_PER_ENTRY;
			uint16_t usNumARecordsStored = 0;
	
				for( x = 0U; x < pxDNSMessageHeader->usAnswers; x++ )
 8004e58:	3701      	adds	r7, #1
 8004e5a:	b2bf      	uxth	r7, r7
 8004e5c:	88f3      	ldrh	r3, [r6, #6]
 8004e5e:	42bb      	cmp	r3, r7
 8004e60:	d893      	bhi.n	8004d8a <prvParseDNSReply+0x13a>
 8004e62:	e02d      	b.n	8004ec0 <prvParseDNSReply+0x270>
						}

						pucByte = &( pucByte[ sizeof( DNSAnswerRecord_t ) + sizeof( uint32_t ) ] );
						uxSourceBytesRemaining -= ( sizeof( DNSAnswerRecord_t ) + sizeof( uint32_t ) );
					}
					else if( uxSourceBytesRemaining >= sizeof( DNSAnswerRecord_t ) )
 8004e64:	2c09      	cmp	r4, #9
 8004e66:	d92f      	bls.n	8004ec8 <prvParseDNSReply+0x278>
						and then jump over the header. */
						/* Cast the response to DNSAnswerRecord for easy access to fields of the DNS response. */
						pxDNSAnswerRecord = ipCAST_PTR_TO_TYPE_PTR( DNSAnswerRecord_t, pucByte );

						pucByte = &( pucByte[ sizeof( DNSAnswerRecord_t ) ] );
						uxSourceBytesRemaining -= sizeof( DNSAnswerRecord_t );
 8004e68:	3c0a      	subs	r4, #10

						/* Determine the length of the answer data from the header. */
						usDataLength = FreeRTOS_ntohs( pxDNSAnswerRecord->usDataLength );
 8004e6a:	892a      	ldrh	r2, [r5, #8]
 8004e6c:	0a13      	lsrs	r3, r2, #8
 8004e6e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8

						/* Jump over the answer. */
						if( uxSourceBytesRemaining >= usDataLength )
 8004e72:	b29b      	uxth	r3, r3
 8004e74:	429c      	cmp	r4, r3
 8004e76:	d304      	bcc.n	8004e82 <prvParseDNSReply+0x232>
 8004e78:	f103 020a 	add.w	r2, r3, #10
						{
							pucByte = &( pucByte[ usDataLength ] );
 8004e7c:	4415      	add	r5, r2
							uxSourceBytesRemaining -= usDataLength;
 8004e7e:	1ae4      	subs	r4, r4, r3
 8004e80:	e022      	b.n	8004ec8 <prvParseDNSReply+0x278>
	}

	if( xReturn == pdFALSE )
	{
		/* There was an error while parsing the DNS response. Return error code. */
		ulIPAddress = dnsPARSE_ERROR;
 8004e82:	2300      	movs	r3, #0
 8004e84:	930b      	str	r3, [sp, #44]	; 0x2c
 8004e86:	e026      	b.n	8004ed6 <prvParseDNSReply+0x286>
	}
	else if( xExpected == pdFALSE )
	{
		/* Do not return a valid IP-address in case the reply was not expected. */
		ulIPAddress = 0UL;
 8004e88:	2300      	movs	r3, #0
 8004e8a:	930b      	str	r3, [sp, #44]	; 0x2c
 8004e8c:	e023      	b.n	8004ed6 <prvParseDNSReply+0x286>
				/* No need to proceed. Break out of the do-while loop. */
				break;
			}

			/* Search through the answer records. */
			pxDNSMessageHeader->usAnswers = FreeRTOS_ntohs( pxDNSMessageHeader->usAnswers );
 8004e8e:	88f2      	ldrh	r2, [r6, #6]
 8004e90:	0a13      	lsrs	r3, r2, #8
 8004e92:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8004e96:	b29b      	uxth	r3, r3
 8004e98:	80f3      	strh	r3, [r6, #6]

			if( ( pxDNSMessageHeader->usFlags & dnsRX_FLAGS_MASK ) == dnsEXPECTED_RX_FLAGS )
 8004e9a:	8872      	ldrh	r2, [r6, #2]
 8004e9c:	f402 6278 	and.w	r2, r2, #3968	; 0xf80
 8004ea0:	2a80      	cmp	r2, #128	; 0x80
 8004ea2:	d10d      	bne.n	8004ec0 <prvParseDNSReply+0x270>
 8004ea4:	e76f      	b.n	8004d86 <prvParseDNSReply+0x136>
					xResult = pdTRUE;
					break;
				}
			}
		}
		( void ) xTaskResumeAll();
 8004ea6:	f7fe fa21 	bl	80032ec <xTaskResumeAll>
							{
							char cBuffer[ 16 ];

								/* The reply will only be stored in the DNS cache when the
								request was issued by this device. */
								if( xDoStore != pdFALSE )
 8004eaa:	9b01      	ldr	r3, [sp, #4]
 8004eac:	2b00      	cmp	r3, #0
 8004eae:	d1c0      	bne.n	8004e32 <prvParseDNSReply+0x1e2>
 8004eb0:	f04f 0900 	mov.w	r9, #0
 8004eb4:	e7c5      	b.n	8004e42 <prvParseDNSReply+0x1f2>
					xResult = pdTRUE;
					break;
				}
			}
		}
		( void ) xTaskResumeAll();
 8004eb6:	f7fe fa19 	bl	80032ec <xTaskResumeAll>
								/* See if any asynchronous call was made to FreeRTOS_gethostbyname_a() */
								if( xDNSDoCallback( ( TickType_t ) pxDNSMessageHeader->usIdentifier, pcName, ulIPAddress ) != pdFALSE )
								{
									/* This device has requested this DNS look-up.
									The result may be stored in the DNS cache. */
									xDoStore = pdTRUE;
 8004eba:	2301      	movs	r3, #1
 8004ebc:	9301      	str	r3, [sp, #4]
 8004ebe:	e7b8      	b.n	8004e32 <prvParseDNSReply+0x1e2>
	if( xReturn == pdFALSE )
	{
		/* There was an error while parsing the DNS response. Return error code. */
		ulIPAddress = dnsPARSE_ERROR;
	}
	else if( xExpected == pdFALSE )
 8004ec0:	9b00      	ldr	r3, [sp, #0]
 8004ec2:	2b00      	cmp	r3, #0
 8004ec4:	d0e0      	beq.n	8004e88 <prvParseDNSReply+0x238>
 8004ec6:	e006      	b.n	8004ed6 <prvParseDNSReply+0x286>
			if( ( pxDNSMessageHeader->usFlags & dnsRX_FLAGS_MASK ) == dnsEXPECTED_RX_FLAGS )
			{
			const uint16_t usCount = ( uint16_t ) ipconfigDNS_CACHE_ADDRESSES_PER_ENTRY;
			uint16_t usNumARecordsStored = 0;
	
				for( x = 0U; x < pxDNSMessageHeader->usAnswers; x++ )
 8004ec8:	3701      	adds	r7, #1
 8004eca:	b2bf      	uxth	r7, r7
 8004ecc:	88f3      	ldrh	r3, [r6, #6]
 8004ece:	42bb      	cmp	r3, r7
 8004ed0:	f63f af66 	bhi.w	8004da0 <prvParseDNSReply+0x150>
 8004ed4:	e7f4      	b.n	8004ec0 <prvParseDNSReply+0x270>

	#if( ipconfigUSE_DNS_CACHE == 1 ) || ( ipconfigDNS_USE_CALLBACKS == 1 )
	( void ) xDoStore;
	#endif

	return ulIPAddress;
 8004ed6:	980b      	ldr	r0, [sp, #44]	; 0x2c
}
 8004ed8:	b00d      	add	sp, #52	; 0x34
 8004eda:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004ede:	bf00      	nop
 8004ee0:	2000d2b8 	.word	0x2000d2b8

08004ee4 <vDNSInitialise>:
	}
	/*-----------------------------------------------------------*/

	/* Initialise the list of call-back structures. */
	void vDNSInitialise( void )
	{
 8004ee4:	b508      	push	{r3, lr}
		vListInitialise( &xCallbackList );
 8004ee6:	4802      	ldr	r0, [pc, #8]	; (8004ef0 <vDNSInitialise+0xc>)
 8004ee8:	f7fd fa00 	bl	80022ec <vListInitialise>
 8004eec:	bd08      	pop	{r3, pc}
 8004eee:	bf00      	nop
 8004ef0:	2000d2b8 	.word	0x2000d2b8

08004ef4 <vDNSCheckCallBack>:
	old entries which have reached a timeout.
	As soon as the list hase become empty, the DNS timer will be stopped
	In case pvSearchID is supplied, the user wants to cancel a DNS request
	*/
	void vDNSCheckCallBack( void *pvSearchID )
	{
 8004ef4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004ef8:	4606      	mov	r6, r0
	const ListItem_t * pxIterator;
	const ListItem_t * xEnd = listGET_END_MARKER( &xCallbackList );

		vTaskSuspendAll();
 8004efa:	f7fe f957 	bl	80031ac <vTaskSuspendAll>
		{
			for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( xEnd );
 8004efe:	4b1a      	ldr	r3, [pc, #104]	; (8004f68 <vDNSCheckCallBack+0x74>)
 8004f00:	68dd      	ldr	r5, [r3, #12]
 8004f02:	3308      	adds	r3, #8
 8004f04:	429d      	cmp	r5, r3
 8004f06:	d025      	beq.n	8004f54 <vDNSCheckCallBack+0x60>
					( void ) uxListRemove( &( pxCallback->xListItem ) );
					vPortFree( pxCallback );
				}
				else if( xTaskCheckForTimeOut( &pxCallback->uxTimeoutState, &pxCallback->uxRemaningTime ) != pdFALSE )
				{
					pxCallback->pCallbackFunction( pxCallback->pcName, pxCallback->pvSearchID, 0 );
 8004f08:	f04f 0800 	mov.w	r8, #0
	const ListItem_t * pxIterator;
	const ListItem_t * xEnd = listGET_END_MARKER( &xCallbackList );

		vTaskSuspendAll();
		{
			for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( xEnd );
 8004f0c:	461f      	mov	r7, r3
				 pxIterator != xEnd;
				 )
			{
				DNSCallback_t *pxCallback = ipCAST_PTR_TO_TYPE_PTR( DNSCallback_t, listGET_LIST_ITEM_OWNER( pxIterator ) );
 8004f0e:	68ec      	ldr	r4, [r5, #12]
				/* Move to the next item because we might remove this item */
				pxIterator = ( const ListItem_t * ) listGET_NEXT( pxIterator );
 8004f10:	686d      	ldr	r5, [r5, #4]
				if( ( pvSearchID != NULL ) && ( pvSearchID == pxCallback->pvSearchID ) )
 8004f12:	b156      	cbz	r6, 8004f2a <vDNSCheckCallBack+0x36>
 8004f14:	6923      	ldr	r3, [r4, #16]
 8004f16:	42b3      	cmp	r3, r6
 8004f18:	d107      	bne.n	8004f2a <vDNSCheckCallBack+0x36>
				{
					( void ) uxListRemove( &( pxCallback->xListItem ) );
 8004f1a:	f104 0014 	add.w	r0, r4, #20
 8004f1e:	f7fd fa1b 	bl	8002358 <uxListRemove>
					vPortFree( pxCallback );
 8004f22:	4620      	mov	r0, r4
 8004f24:	f7ff f87e 	bl	8004024 <vPortFree>
 8004f28:	e012      	b.n	8004f50 <vDNSCheckCallBack+0x5c>
				}
				else if( xTaskCheckForTimeOut( &pxCallback->uxTimeoutState, &pxCallback->uxRemaningTime ) != pdFALSE )
 8004f2a:	f104 0008 	add.w	r0, r4, #8
 8004f2e:	4621      	mov	r1, r4
 8004f30:	f7fe fc3c 	bl	80037ac <xTaskCheckForTimeOut>
 8004f34:	b160      	cbz	r0, 8004f50 <vDNSCheckCallBack+0x5c>
				{
					pxCallback->pCallbackFunction( pxCallback->pcName, pxCallback->pvSearchID, 0 );
 8004f36:	6863      	ldr	r3, [r4, #4]
 8004f38:	f104 0028 	add.w	r0, r4, #40	; 0x28
 8004f3c:	6921      	ldr	r1, [r4, #16]
 8004f3e:	4642      	mov	r2, r8
 8004f40:	4798      	blx	r3
					( void ) uxListRemove( &( pxCallback->xListItem ) );
 8004f42:	f104 0014 	add.w	r0, r4, #20
 8004f46:	f7fd fa07 	bl	8002358 <uxListRemove>
					vPortFree( pxCallback );
 8004f4a:	4620      	mov	r0, r4
 8004f4c:	f7ff f86a 	bl	8004024 <vPortFree>
	const ListItem_t * pxIterator;
	const ListItem_t * xEnd = listGET_END_MARKER( &xCallbackList );

		vTaskSuspendAll();
		{
			for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( xEnd );
 8004f50:	42bd      	cmp	r5, r7
 8004f52:	d1dc      	bne.n	8004f0e <vDNSCheckCallBack+0x1a>
				{
					/* This call-back is still waiting for a reply or a time-out. */
				}
			}
		}
		( void ) xTaskResumeAll();
 8004f54:	f7fe f9ca 	bl	80032ec <xTaskResumeAll>

		if( listLIST_IS_EMPTY( &xCallbackList ) != pdFALSE )
 8004f58:	4b03      	ldr	r3, [pc, #12]	; (8004f68 <vDNSCheckCallBack+0x74>)
 8004f5a:	681b      	ldr	r3, [r3, #0]
 8004f5c:	b913      	cbnz	r3, 8004f64 <vDNSCheckCallBack+0x70>
		{
			vIPSetDnsTimerEnableState( pdFALSE );
 8004f5e:	2000      	movs	r0, #0
 8004f60:	f000 fd56 	bl	8005a10 <vIPSetDnsTimerEnableState>
 8004f64:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8004f68:	2000d2b8 	.word	0x2000d2b8

08004f6c <ulDNSHandlePacket>:
DNSMessage_t *pxDNSMessageHeader;
size_t uxPayloadSize;

	/* Only proceed if the payload length indicated in the header
	appears to be valid. */
	if( pxNetworkBuffer->xDataLength >= sizeof( UDPPacket_t ) )
 8004f6c:	69c1      	ldr	r1, [r0, #28]
 8004f6e:	2929      	cmp	r1, #41	; 0x29
 8004f70:	d909      	bls.n	8004f86 <ulDNSHandlePacket+0x1a>
	{
		uxPayloadSize = pxNetworkBuffer->xDataLength - sizeof( UDPPacket_t );
 8004f72:	392a      	subs	r1, #42	; 0x2a

		if( uxPayloadSize >= sizeof( DNSMessage_t ) )
 8004f74:	290b      	cmp	r1, #11
 8004f76:	d906      	bls.n	8004f86 <ulDNSHandlePacket+0x1a>
when ipconfigDNS_USE_CALLBACKS == 1
when ipconfigUSE_LLMNR == 1
for testing purposes, by the module iot_test_freertos_tcp.c
*/
uint32_t ulDNSHandlePacket( const NetworkBufferDescriptor_t *pxNetworkBuffer )
{
 8004f78:	b508      	push	{r3, lr}
		{
			pxDNSMessageHeader =
				ipCAST_PTR_TO_TYPE_PTR( DNSMessage_t, pxNetworkBuffer->pucEthernetBuffer );

			/* The parameter pdFALSE indicates that the reply was not expected. */
			( void ) prvParseDNSReply( ( uint8_t * ) pxDNSMessageHeader,
 8004f7a:	6980      	ldr	r0, [r0, #24]
 8004f7c:	2200      	movs	r2, #0
 8004f7e:	f7ff fe67 	bl	8004c50 <prvParseDNSReply>
		}
	}

	/* The packet was not consumed. */
	return pdFAIL;
}
 8004f82:	2000      	movs	r0, #0
 8004f84:	bd08      	pop	{r3, pc}
 8004f86:	2000      	movs	r0, #0
 8004f88:	4770      	bx	lr
 8004f8a:	bf00      	nop

08004f8c <prvIPTimerCheck>:
	prvIPTimerStart( pxTimer, xTime );
}
/*-----------------------------------------------------------*/

static BaseType_t prvIPTimerCheck( IPTimer_t *pxTimer )
{
 8004f8c:	b538      	push	{r3, r4, r5, lr}
BaseType_t xReturn;

	if( pxTimer->bActive == pdFALSE_UNSIGNED )
 8004f8e:	7803      	ldrb	r3, [r0, #0]
 8004f90:	f013 0f01 	tst.w	r3, #1
 8004f94:	d026      	beq.n	8004fe4 <prvIPTimerCheck+0x58>
 8004f96:	4604      	mov	r4, r0
	}
	else
	{
		/* The timer might have set the bExpired flag already, if not, check the
		value of xTimeOut against ulRemainingTime. */
		if( pxTimer->bExpired == pdFALSE_UNSIGNED )
 8004f98:	f013 0f02 	tst.w	r3, #2
 8004f9c:	d10d      	bne.n	8004fba <prvIPTimerCheck+0x2e>
		{
			if( xTaskCheckForTimeOut( &( pxTimer->xTimeOut ), &( pxTimer->ulRemainingTime ) ) != pdFALSE )
 8004f9e:	3004      	adds	r0, #4
 8004fa0:	f104 010c 	add.w	r1, r4, #12
 8004fa4:	f7fe fc02 	bl	80037ac <xTaskCheckForTimeOut>
 8004fa8:	b118      	cbz	r0, 8004fb2 <prvIPTimerCheck+0x26>
			{
				pxTimer->bExpired = pdTRUE_UNSIGNED;
 8004faa:	7823      	ldrb	r3, [r4, #0]
 8004fac:	f043 0302 	orr.w	r3, r3, #2
 8004fb0:	7023      	strb	r3, [r4, #0]
			}
		}
		if( pxTimer->bExpired != pdFALSE_UNSIGNED )
 8004fb2:	7823      	ldrb	r3, [r4, #0]
 8004fb4:	f013 0f02 	tst.w	r3, #2
 8004fb8:	d016      	beq.n	8004fe8 <prvIPTimerCheck+0x5c>
		{
			prvIPTimerStart( pxTimer, pxTimer->ulReloadTime );
 8004fba:	6925      	ldr	r5, [r4, #16]
}
/*-----------------------------------------------------------*/

static void prvIPTimerStart( IPTimer_t *pxTimer, TickType_t xTime )
{
	vTaskSetTimeOutState( &pxTimer->xTimeOut );
 8004fbc:	1d20      	adds	r0, r4, #4
 8004fbe:	f7fe fbcd 	bl	800375c <vTaskSetTimeOutState>
	pxTimer->ulRemainingTime = xTime;
 8004fc2:	60e5      	str	r5, [r4, #12]

	if( xTime == ( TickType_t ) 0 )
 8004fc4:	b925      	cbnz	r5, 8004fd0 <prvIPTimerCheck+0x44>
	{
		pxTimer->bExpired = pdTRUE_UNSIGNED;
 8004fc6:	7823      	ldrb	r3, [r4, #0]
 8004fc8:	f043 0302 	orr.w	r3, r3, #2
 8004fcc:	7023      	strb	r3, [r4, #0]
 8004fce:	e003      	b.n	8004fd8 <prvIPTimerCheck+0x4c>
	}
	else
	{
		pxTimer->bExpired = pdFALSE_UNSIGNED;
 8004fd0:	7823      	ldrb	r3, [r4, #0]
 8004fd2:	f36f 0341 	bfc	r3, #1, #1
 8004fd6:	7023      	strb	r3, [r4, #0]
	}

	pxTimer->bActive = pdTRUE_UNSIGNED;
 8004fd8:	7823      	ldrb	r3, [r4, #0]
 8004fda:	f043 0301 	orr.w	r3, r3, #1
 8004fde:	7023      	strb	r3, [r4, #0]
			}
		}
		if( pxTimer->bExpired != pdFALSE_UNSIGNED )
		{
			prvIPTimerStart( pxTimer, pxTimer->ulReloadTime );
			xReturn = pdTRUE;
 8004fe0:	2001      	movs	r0, #1
 8004fe2:	bd38      	pop	{r3, r4, r5, pc}
BaseType_t xReturn;

	if( pxTimer->bActive == pdFALSE_UNSIGNED )
	{
		/* The timer is not enabled. */
		xReturn = pdFALSE;
 8004fe4:	2000      	movs	r0, #0
 8004fe6:	bd38      	pop	{r3, r4, r5, pc}
			prvIPTimerStart( pxTimer, pxTimer->ulReloadTime );
			xReturn = pdTRUE;
		}
		else
		{
			xReturn = pdFALSE;
 8004fe8:	2000      	movs	r0, #0
		}
	}

	return xReturn;
}
 8004fea:	bd38      	pop	{r3, r4, r5, pc}

08004fec <xIsCallingFromIPTask>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xIsCallingFromIPTask( void )
{
 8004fec:	b508      	push	{r3, lr}
BaseType_t xReturn;

	if( xTaskGetCurrentTaskHandle() == xIPTaskHandle )
 8004fee:	f7fe fc25 	bl	800383c <xTaskGetCurrentTaskHandle>
 8004ff2:	4b03      	ldr	r3, [pc, #12]	; (8005000 <xIsCallingFromIPTask+0x14>)
 8004ff4:	681b      	ldr	r3, [r3, #0]
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
 8004ff6:	4283      	cmp	r3, r0
 8004ff8:	bf14      	ite	ne
 8004ffa:	2000      	movne	r0, #0
 8004ffc:	2001      	moveq	r0, #1
 8004ffe:	bd08      	pop	{r3, pc}
 8005000:	2000d3bc 	.word	0x2000d3bc

08005004 <pxUDPPayloadBuffer_to_NetworkBuffer>:
NetworkBufferDescriptor_t *pxUDPPayloadBuffer_to_NetworkBuffer( const void * pvBuffer )
{
const uint8_t *pucBuffer;
NetworkBufferDescriptor_t *pxResult;

	if( pvBuffer == NULL )
 8005004:	b128      	cbz	r0, 8005012 <pxUDPPayloadBuffer_to_NetworkBuffer+0xe>
		the network buffer, usually 8 + 2 bytes. */
		pucBuffer -= ( sizeof( UDPPacket_t ) + ( ( size_t ) ipBUFFER_PADDING ) );

		/* Here a pointer was placed to the network descriptor,
		As a pointer is dereferenced, make sure it is well aligned */
		if( ( ( ( size_t ) pucBuffer ) & ( sizeof( pucBuffer ) - 1U ) ) == 0U )
 8005006:	f010 0f03 	tst.w	r0, #3
 800500a:	d104      	bne.n	8005016 <pxUDPPayloadBuffer_to_NetworkBuffer+0x12>
		{
			/* The following statement may trigger a:
			warning: cast increases required alignment of target type [-Wcast-align].
			It has been confirmed though that the alignment is suitable. */
			pxResult = * ( ( const NetworkBufferDescriptor_t **) pucBuffer );
 800500c:	f850 0c34 	ldr.w	r0, [r0, #-52]
 8005010:	4770      	bx	lr
const uint8_t *pucBuffer;
NetworkBufferDescriptor_t *pxResult;

	if( pvBuffer == NULL )
	{
		pxResult = NULL;
 8005012:	2000      	movs	r0, #0
 8005014:	4770      	bx	lr
			It has been confirmed though that the alignment is suitable. */
			pxResult = * ( ( const NetworkBufferDescriptor_t **) pucBuffer );
		}
		else
		{
			pxResult = NULL;
 8005016:	2000      	movs	r0, #0
		}
	}

	return pxResult;
}
 8005018:	4770      	bx	lr
 800501a:	bf00      	nop

0800501c <FreeRTOS_IPInit>:
/*_RB_ Should we add an error or assert if the task priorities are set such that the servers won't function as expected? */
/*_HT_ There was a bug in FreeRTOS_TCP_IP.c that only occurred when the applications' priority was too high.
 As that bug has been repaired, there is not an urgent reason to warn.
 It is better though to use the advised priority scheme. */
BaseType_t FreeRTOS_IPInit( const uint8_t ucIPAddress[ ipIP_ADDRESS_LENGTH_BYTES ], const uint8_t ucNetMask[ ipIP_ADDRESS_LENGTH_BYTES ], const uint8_t ucGatewayAddress[ ipIP_ADDRESS_LENGTH_BYTES ], const uint8_t ucDNSServerAddress[ ipIP_ADDRESS_LENGTH_BYTES ], const uint8_t ucMACAddress[ ipMAC_ADDRESS_LENGTH_BYTES ] )
{
 800501c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005020:	b082      	sub	sp, #8
 8005022:	9f08      	ldr	r7, [sp, #32]
#endif /* ipconfigDNS_USE_CALLBACKS != 0 */
/*-----------------------------------------------------------*/

BaseType_t xIPIsNetworkTaskReady( void )
{
	return xIPTaskInitialised;
 8005024:	4c58      	ldr	r4, [pc, #352]	; (8005188 <FreeRTOS_IPInit+0x16c>)
BaseType_t FreeRTOS_IPInit( const uint8_t ucIPAddress[ ipIP_ADDRESS_LENGTH_BYTES ], const uint8_t ucNetMask[ ipIP_ADDRESS_LENGTH_BYTES ], const uint8_t ucGatewayAddress[ ipIP_ADDRESS_LENGTH_BYTES ], const uint8_t ucDNSServerAddress[ ipIP_ADDRESS_LENGTH_BYTES ], const uint8_t ucMACAddress[ ipMAC_ADDRESS_LENGTH_BYTES ] )
{
BaseType_t xReturn = pdFALSE;

	/* This function should only be called once. */
	configASSERT( xIPIsNetworkTaskReady() == pdFALSE );
 8005026:	6824      	ldr	r4, [r4, #0]
 8005028:	b144      	cbz	r4, 800503c <FreeRTOS_IPInit+0x20>
 800502a:	f04f 0314 	mov.w	r3, #20
 800502e:	f383 8811 	msr	BASEPRI, r3
 8005032:	f3bf 8f6f 	isb	sy
 8005036:	f3bf 8f4f 	dsb	sy
 800503a:	e7fe      	b.n	800503a <FreeRTOS_IPInit+0x1e>
	configASSERT( xNetworkEventQueue == NULL );
 800503c:	4c53      	ldr	r4, [pc, #332]	; (800518c <FreeRTOS_IPInit+0x170>)
 800503e:	6824      	ldr	r4, [r4, #0]
 8005040:	b144      	cbz	r4, 8005054 <FreeRTOS_IPInit+0x38>
 8005042:	f04f 0314 	mov.w	r3, #20
 8005046:	f383 8811 	msr	BASEPRI, r3
 800504a:	f3bf 8f6f 	isb	sy
 800504e:	f3bf 8f4f 	dsb	sy
 8005052:	e7fe      	b.n	8005052 <FreeRTOS_IPInit+0x36>
	configASSERT( xIPTaskHandle == NULL );
 8005054:	4c4e      	ldr	r4, [pc, #312]	; (8005190 <FreeRTOS_IPInit+0x174>)
 8005056:	6824      	ldr	r4, [r4, #0]
 8005058:	b144      	cbz	r4, 800506c <FreeRTOS_IPInit+0x50>
 800505a:	f04f 0314 	mov.w	r3, #20
 800505e:	f383 8811 	msr	BASEPRI, r3
 8005062:	f3bf 8f6f 	isb	sy
 8005066:	f3bf 8f4f 	dsb	sy
 800506a:	e7fe      	b.n	800506a <FreeRTOS_IPInit+0x4e>
 800506c:	4698      	mov	r8, r3
 800506e:	4616      	mov	r6, r2
 8005070:	460d      	mov	r5, r1
 8005072:	4604      	mov	r4, r0
		configASSERT( sizeof( ICMPHeader_t ) == ipEXPECTED_ICMPHeader_t_SIZE );
		configASSERT( sizeof( UDPHeader_t ) == ipEXPECTED_UDPHeader_t_SIZE );
	}
	#endif
	/* Attempt to create the queue used to communicate with the IP task. */
	xNetworkEventQueue = xQueueCreate( ( UBaseType_t ) ipconfigEVENT_QUEUE_LENGTH, ( UBaseType_t ) sizeof( IPStackEvent_t ) );
 8005074:	2041      	movs	r0, #65	; 0x41
 8005076:	2108      	movs	r1, #8
 8005078:	2200      	movs	r2, #0
 800507a:	f7fd fa5d 	bl	8002538 <xQueueGenericCreate>
 800507e:	4b43      	ldr	r3, [pc, #268]	; (800518c <FreeRTOS_IPInit+0x170>)
 8005080:	6018      	str	r0, [r3, #0]
	configASSERT( xNetworkEventQueue != NULL );
 8005082:	b940      	cbnz	r0, 8005096 <FreeRTOS_IPInit+0x7a>
 8005084:	f04f 0314 	mov.w	r3, #20
 8005088:	f383 8811 	msr	BASEPRI, r3
 800508c:	f3bf 8f6f 	isb	sy
 8005090:	f3bf 8f4f 	dsb	sy
 8005094:	e7fe      	b.n	8005094 <FreeRTOS_IPInit+0x78>
		#if ( configQUEUE_REGISTRY_SIZE > 0 )
		{
			/* A queue registry is normally used to assist a kernel aware
			debugger.  If one is in use then it will be helpful for the debugger
			to show information about the network event queue. */
			vQueueAddToRegistry( xNetworkEventQueue, "NetEvnt" );
 8005096:	493f      	ldr	r1, [pc, #252]	; (8005194 <FreeRTOS_IPInit+0x178>)
 8005098:	f7fd fde0 	bl	8002c5c <vQueueAddToRegistry>
		}
		#endif /* configQUEUE_REGISTRY_SIZE */

		if( xNetworkBuffersInitialise() == pdPASS )
 800509c:	f7ff fa52 	bl	8004544 <xNetworkBuffersInitialise>
 80050a0:	2801      	cmp	r0, #1
 80050a2:	d168      	bne.n	8005176 <FreeRTOS_IPInit+0x15a>
		{
			/* Store the local IP and MAC address. */
			xNetworkAddressing.ulDefaultIPAddress = FreeRTOS_inet_addr_quick( ucIPAddress[ 0 ], ucIPAddress[ 1 ], ucIPAddress[ 2 ], ucIPAddress[ 3 ] );
 80050a4:	78e2      	ldrb	r2, [r4, #3]
 80050a6:	78a3      	ldrb	r3, [r4, #2]
 80050a8:	041b      	lsls	r3, r3, #16
 80050aa:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80050ae:	f894 c000 	ldrb.w	ip, [r4]
 80050b2:	ea43 030c 	orr.w	r3, r3, ip
 80050b6:	f894 c001 	ldrb.w	ip, [r4, #1]
 80050ba:	ea43 2c0c 	orr.w	ip, r3, ip, lsl #8
 80050be:	4c36      	ldr	r4, [pc, #216]	; (8005198 <FreeRTOS_IPInit+0x17c>)
 80050c0:	f8c4 c000 	str.w	ip, [r4]
			xNetworkAddressing.ulNetMask = FreeRTOS_inet_addr_quick( ucNetMask[ 0 ], ucNetMask[ 1 ], ucNetMask[ 2 ], ucNetMask[ 3 ] );
 80050c4:	78ea      	ldrb	r2, [r5, #3]
 80050c6:	78ab      	ldrb	r3, [r5, #2]
 80050c8:	041b      	lsls	r3, r3, #16
 80050ca:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80050ce:	f895 e000 	ldrb.w	lr, [r5]
 80050d2:	ea43 030e 	orr.w	r3, r3, lr
 80050d6:	f895 e001 	ldrb.w	lr, [r5, #1]
 80050da:	ea43 2e0e 	orr.w	lr, r3, lr, lsl #8
 80050de:	f8c4 e004 	str.w	lr, [r4, #4]
			xNetworkAddressing.ulGatewayAddress = FreeRTOS_inet_addr_quick( ucGatewayAddress[ 0 ], ucGatewayAddress[ 1 ], ucGatewayAddress[ 2 ], ucGatewayAddress[ 3 ] );
 80050e2:	78f2      	ldrb	r2, [r6, #3]
 80050e4:	78b3      	ldrb	r3, [r6, #2]
 80050e6:	041b      	lsls	r3, r3, #16
 80050e8:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80050ec:	7835      	ldrb	r5, [r6, #0]
 80050ee:	432b      	orrs	r3, r5
 80050f0:	7875      	ldrb	r5, [r6, #1]
 80050f2:	ea43 2505 	orr.w	r5, r3, r5, lsl #8
 80050f6:	60a5      	str	r5, [r4, #8]
			xNetworkAddressing.ulDNSServerAddress = FreeRTOS_inet_addr_quick( ucDNSServerAddress[ 0 ], ucDNSServerAddress[ 1 ], ucDNSServerAddress[ 2 ], ucDNSServerAddress[ 3 ] );
 80050f8:	f898 2003 	ldrb.w	r2, [r8, #3]
 80050fc:	f898 3002 	ldrb.w	r3, [r8, #2]
 8005100:	041b      	lsls	r3, r3, #16
 8005102:	ea43 6202 	orr.w	r2, r3, r2, lsl #24
 8005106:	f898 3000 	ldrb.w	r3, [r8]
 800510a:	4313      	orrs	r3, r2
 800510c:	f898 2001 	ldrb.w	r2, [r8, #1]
 8005110:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8005114:	60e3      	str	r3, [r4, #12]
			xNetworkAddressing.ulBroadcastAddress = ( xNetworkAddressing.ulDefaultIPAddress & xNetworkAddressing.ulNetMask ) |  ~xNetworkAddressing.ulNetMask;
 8005116:	ea0c 080e 	and.w	r8, ip, lr
 800511a:	ea68 080e 	orn	r8, r8, lr
 800511e:	f8c4 8010 	str.w	r8, [r4, #16]

			( void ) memcpy( &xDefaultAddressing, &xNetworkAddressing, sizeof( xDefaultAddressing ) );
 8005122:	4e1e      	ldr	r6, [pc, #120]	; (800519c <FreeRTOS_IPInit+0x180>)
 8005124:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8005126:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8005128:	f8c6 8000 	str.w	r8, [r6]
				*ipLOCAL_IP_ADDRESS_POINTER = 0x00UL;
			}
			#else
			{
				/* The IP address is set from the value passed in. */
				*ipLOCAL_IP_ADDRESS_POINTER = xNetworkAddressing.ulDefaultIPAddress;
 800512c:	4b1c      	ldr	r3, [pc, #112]	; (80051a0 <FreeRTOS_IPInit+0x184>)
 800512e:	f8c3 c014 	str.w	ip, [r3, #20]

				/* Added to prevent ARP flood to gateway.  Ensure the
				gateway is on the same subnet as the IP	address. */
				if( xNetworkAddressing.ulGatewayAddress != 0UL )
 8005132:	b16d      	cbz	r5, 8005150 <FreeRTOS_IPInit+0x134>
				{
					configASSERT( ( ( *ipLOCAL_IP_ADDRESS_POINTER ) & xNetworkAddressing.ulNetMask ) == ( xNetworkAddressing.ulGatewayAddress & xNetworkAddressing.ulNetMask ) );
 8005134:	ea8c 0505 	eor.w	r5, ip, r5
 8005138:	ea15 0f0e 	tst.w	r5, lr
 800513c:	d008      	beq.n	8005150 <FreeRTOS_IPInit+0x134>
 800513e:	f04f 0314 	mov.w	r3, #20
 8005142:	f383 8811 	msr	BASEPRI, r3
 8005146:	f3bf 8f6f 	isb	sy
 800514a:	f3bf 8f4f 	dsb	sy
 800514e:	e7fe      	b.n	800514e <FreeRTOS_IPInit+0x132>
			}
			#endif /* ipconfigUSE_DHCP == 1 */

			/* The MAC address is stored in the start of the default packet
			header fragment, which is used when sending UDP packets. */
			( void ) memcpy( ipLOCAL_MAC_ADDRESS, ucMACAddress, ( size_t ) ipMAC_ADDRESS_LENGTH_BYTES );
 8005150:	4b13      	ldr	r3, [pc, #76]	; (80051a0 <FreeRTOS_IPInit+0x184>)
 8005152:	6838      	ldr	r0, [r7, #0]
 8005154:	6018      	str	r0, [r3, #0]
 8005156:	88ba      	ldrh	r2, [r7, #4]
 8005158:	809a      	strh	r2, [r3, #4]

			/* Prepare the sockets interface. */
			vNetworkSocketsInit();
 800515a:	f000 fd4f 	bl	8005bfc <vNetworkSocketsInit>

			/* Create the task that processes Ethernet and stack events. */
			xReturn = xTaskCreate( prvIPTask,
 800515e:	2303      	movs	r3, #3
 8005160:	9300      	str	r3, [sp, #0]
 8005162:	4b0b      	ldr	r3, [pc, #44]	; (8005190 <FreeRTOS_IPInit+0x174>)
 8005164:	9301      	str	r3, [sp, #4]
 8005166:	480f      	ldr	r0, [pc, #60]	; (80051a4 <FreeRTOS_IPInit+0x188>)
 8005168:	490f      	ldr	r1, [pc, #60]	; (80051a8 <FreeRTOS_IPInit+0x18c>)
 800516a:	f44f 7216 	mov.w	r2, #600	; 0x258
 800516e:	2300      	movs	r3, #0
 8005170:	f7fd fe78 	bl	8002e64 <xTaskCreate>
 8005174:	e005      	b.n	8005182 <FreeRTOS_IPInit+0x166>
		else
		{
			FreeRTOS_debug_printf( ( "FreeRTOS_IPInit: xNetworkBuffersInitialise() failed\n") );

			/* Clean up. */
			vQueueDelete( xNetworkEventQueue );
 8005176:	4c05      	ldr	r4, [pc, #20]	; (800518c <FreeRTOS_IPInit+0x170>)
 8005178:	6820      	ldr	r0, [r4, #0]
 800517a:	f7fd fda3 	bl	8002cc4 <vQueueDelete>
			xNetworkEventQueue = NULL;
 800517e:	2000      	movs	r0, #0
 8005180:	6020      	str	r0, [r4, #0]
	{
		FreeRTOS_debug_printf( ( "FreeRTOS_IPInit: Network event queue could not be created\n") );
	}

	return xReturn;
}
 8005182:	b002      	add	sp, #8
 8005184:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005188:	2000d39c 	.word	0x2000d39c
 800518c:	2000d368 	.word	0x2000d368
 8005190:	2000d3bc 	.word	0x2000d3bc
 8005194:	0800abc0 	.word	0x0800abc0
 8005198:	2000d36c 	.word	0x2000d36c
 800519c:	2000d354 	.word	0x2000d354
 80051a0:	2000d5c0 	.word	0x2000d5c0
 80051a4:	0800556d 	.word	0x0800556d
 80051a8:	0800abc8 	.word	0x0800abc8

080051ac <xSendEventStructToIPTask>:
	return xSendEventStructToIPTask( &xEventMessage, xDontBlock );
}
/*-----------------------------------------------------------*/

BaseType_t xSendEventStructToIPTask( const IPStackEvent_t *pxEvent, TickType_t uxTimeout )
{
 80051ac:	b538      	push	{r3, r4, r5, lr}
 80051ae:	4604      	mov	r4, r0
 80051b0:	460d      	mov	r5, r1
#endif /* ipconfigDNS_USE_CALLBACKS != 0 */
/*-----------------------------------------------------------*/

BaseType_t xIPIsNetworkTaskReady( void )
{
	return xIPTaskInitialised;
 80051b2:	4b13      	ldr	r3, [pc, #76]	; (8005200 <xSendEventStructToIPTask+0x54>)
BaseType_t xSendEventStructToIPTask( const IPStackEvent_t *pxEvent, TickType_t uxTimeout )
{
BaseType_t xReturn, xSendMessage;
TickType_t uxUseTimeout = uxTimeout;

	if( ( xIPIsNetworkTaskReady() == pdFALSE ) && ( pxEvent->eEventType != eNetworkDownEvent ) )
 80051b4:	681b      	ldr	r3, [r3, #0]
 80051b6:	b91b      	cbnz	r3, 80051c0 <xSendEventStructToIPTask+0x14>
 80051b8:	f990 3000 	ldrsb.w	r3, [r0]
 80051bc:	b173      	cbz	r3, 80051dc <xSendEventStructToIPTask+0x30>
 80051be:	e01a      	b.n	80051f6 <xSendEventStructToIPTask+0x4a>
	{
		xSendMessage = pdTRUE;

		#if( ipconfigUSE_TCP == 1 )
		{
			if( pxEvent->eEventType == eTCPTimerEvent )
 80051c0:	f990 3000 	ldrsb.w	r3, [r0]
 80051c4:	2b06      	cmp	r3, #6
 80051c6:	d109      	bne.n	80051dc <xSendEventStructToIPTask+0x30>
			{
				/* TCP timer events are sent to wake the timer task when
				xTCPTimer has expired, but there is no point sending them if the
				IP task is already awake processing other message. */
				xTCPTimer.bExpired = pdTRUE_UNSIGNED;
 80051c8:	4a0e      	ldr	r2, [pc, #56]	; (8005204 <xSendEventStructToIPTask+0x58>)
 80051ca:	7813      	ldrb	r3, [r2, #0]
 80051cc:	f043 0302 	orr.w	r3, r3, #2
 80051d0:	7013      	strb	r3, [r2, #0]

				if( uxQueueMessagesWaiting( xNetworkEventQueue ) != 0U )
 80051d2:	4b0d      	ldr	r3, [pc, #52]	; (8005208 <xSendEventStructToIPTask+0x5c>)
 80051d4:	6818      	ldr	r0, [r3, #0]
 80051d6:	f7fd fd2d 	bl	8002c34 <uxQueueMessagesWaiting>
				}
			}
		}
		#endif /* ipconfigUSE_TCP */

		if( xSendMessage != pdFALSE )
 80051da:	b970      	cbnz	r0, 80051fa <xSendEventStructToIPTask+0x4e>
		{
			/* The IP task cannot block itself while waiting for itself to
			respond. */
			if( ( xIsCallingFromIPTask() == pdTRUE ) && ( uxUseTimeout > ( TickType_t ) 0U ) )
 80051dc:	f7ff ff06 	bl	8004fec <xIsCallingFromIPTask>
/*-----------------------------------------------------------*/

BaseType_t xSendEventStructToIPTask( const IPStackEvent_t *pxEvent, TickType_t uxTimeout )
{
BaseType_t xReturn, xSendMessage;
TickType_t uxUseTimeout = uxTimeout;
 80051e0:	2801      	cmp	r0, #1
			if( ( xIsCallingFromIPTask() == pdTRUE ) && ( uxUseTimeout > ( TickType_t ) 0U ) )
			{
				uxUseTimeout = ( TickType_t ) 0;
			}

			xReturn = xQueueSendToBack( xNetworkEventQueue, pxEvent, uxUseTimeout );
 80051e2:	4b09      	ldr	r3, [pc, #36]	; (8005208 <xSendEventStructToIPTask+0x5c>)
 80051e4:	6818      	ldr	r0, [r3, #0]
 80051e6:	4621      	mov	r1, r4
 80051e8:	bf14      	ite	ne
 80051ea:	462a      	movne	r2, r5
 80051ec:	2200      	moveq	r2, #0
 80051ee:	2300      	movs	r3, #0
 80051f0:	f7fd f9fe 	bl	80025f0 <xQueueGenericSend>
 80051f4:	bd38      	pop	{r3, r4, r5, pc}

	if( ( xIPIsNetworkTaskReady() == pdFALSE ) && ( pxEvent->eEventType != eNetworkDownEvent ) )
	{
		/* Only allow eNetworkDownEvent events if the IP task is not ready
		yet.  Not going to attempt to send the message so the send failed. */
		xReturn = pdFAIL;
 80051f6:	2000      	movs	r0, #0
 80051f8:	bd38      	pop	{r3, r4, r5, pc}
		}
		else
		{
			/* It was not necessary to send the message to process the event so
			even though the message was not sent the call was successful. */
			xReturn = pdPASS;
 80051fa:	2001      	movs	r0, #1
		}
	}

	return xReturn;
}
 80051fc:	bd38      	pop	{r3, r4, r5, pc}
 80051fe:	bf00      	nop
 8005200:	2000d39c 	.word	0x2000d39c
 8005204:	2000d3a4 	.word	0x2000d3a4
 8005208:	2000d368 	.word	0x2000d368

0800520c <FreeRTOS_NetworkDown>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void FreeRTOS_NetworkDown( void )
{
 800520c:	b508      	push	{r3, lr}
static const IPStackEvent_t xNetworkDownEvent = { eNetworkDownEvent, NULL };
const TickType_t xDontBlock = ( TickType_t ) 0;

	/* Simply send the network task the appropriate event. */
	if( xSendEventStructToIPTask( &xNetworkDownEvent, xDontBlock ) != pdPASS )
 800520e:	4805      	ldr	r0, [pc, #20]	; (8005224 <FreeRTOS_NetworkDown+0x18>)
 8005210:	2100      	movs	r1, #0
 8005212:	f7ff ffcb 	bl	80051ac <xSendEventStructToIPTask>
 8005216:	2801      	cmp	r0, #1
	{
		/* Could not send the message, so it is still pending. */
		xNetworkDownEventPending = pdTRUE;
 8005218:	bf14      	ite	ne
 800521a:	2201      	movne	r2, #1
	}
	else
	{
		/* Message was sent so it is not pending. */
		xNetworkDownEventPending = pdFALSE;
 800521c:	2200      	moveq	r2, #0
 800521e:	4b02      	ldr	r3, [pc, #8]	; (8005228 <FreeRTOS_NetworkDown+0x1c>)
 8005220:	601a      	str	r2, [r3, #0]
 8005222:	bd08      	pop	{r3, pc}
 8005224:	0800abb8 	.word	0x0800abb8
 8005228:	2000d3a0 	.word	0x2000d3a0

0800522c <xSendEventToIPTask>:

#endif /* ipconfigSUPPORT_OUTGOING_PINGS == 1 */
/*-----------------------------------------------------------*/

BaseType_t xSendEventToIPTask( eIPEvent_t eEvent )
{
 800522c:	b500      	push	{lr}
 800522e:	b083      	sub	sp, #12
IPStackEvent_t xEventMessage;
const TickType_t xDontBlock = ( TickType_t ) 0;

	xEventMessage.eEventType = eEvent;
 8005230:	f88d 0000 	strb.w	r0, [sp]
	xEventMessage.pvData = ( void* )NULL;
 8005234:	2100      	movs	r1, #0
 8005236:	9101      	str	r1, [sp, #4]

	return xSendEventStructToIPTask( &xEventMessage, xDontBlock );
 8005238:	4668      	mov	r0, sp
 800523a:	f7ff ffb7 	bl	80051ac <xSendEventStructToIPTask>
}
 800523e:	b003      	add	sp, #12
 8005240:	f85d fb04 	ldr.w	pc, [sp], #4

08005244 <vIPNetworkUpCalls>:
	}
}
/*-----------------------------------------------------------*/

void vIPNetworkUpCalls( void )
{
 8005244:	b538      	push	{r3, r4, r5, lr}
	xNetworkUp = pdTRUE;
 8005246:	2201      	movs	r2, #1
 8005248:	4b0a      	ldr	r3, [pc, #40]	; (8005274 <vIPNetworkUpCalls+0x30>)
 800524a:	601a      	str	r2, [r3, #0]

	#if( ipconfigUSE_NETWORK_EVENT_HOOK == 1 )
	{
		vApplicationIPNetworkEventHook( eNetworkUp );
 800524c:	2000      	movs	r0, #0
 800524e:	f7ff f929 	bl	80044a4 <vApplicationIPNetworkEventHook>
	#if( ipconfigDNS_USE_CALLBACKS != 0 )
	{
		/* The following function is declared in FreeRTOS_DNS.c	and 'private' to
		this library */
		extern void vDNSInitialise( void );
		vDNSInitialise();
 8005252:	f7ff fe47 	bl	8004ee4 <vDNSInitialise>
}
/*-----------------------------------------------------------*/

static void prvIPTimerReload( IPTimer_t *pxTimer, TickType_t xTime )
{
	pxTimer->ulReloadTime = xTime;
 8005256:	4c08      	ldr	r4, [pc, #32]	; (8005278 <vIPNetworkUpCalls+0x34>)
 8005258:	f242 7510 	movw	r5, #10000	; 0x2710
 800525c:	6125      	str	r5, [r4, #16]
}
/*-----------------------------------------------------------*/

static void prvIPTimerStart( IPTimer_t *pxTimer, TickType_t xTime )
{
	vTaskSetTimeOutState( &pxTimer->xTimeOut );
 800525e:	1d20      	adds	r0, r4, #4
 8005260:	f7fe fa7c 	bl	800375c <vTaskSetTimeOutState>
	pxTimer->ulRemainingTime = xTime;
 8005264:	60e5      	str	r5, [r4, #12]
	{
		pxTimer->bExpired = pdTRUE_UNSIGNED;
	}
	else
	{
		pxTimer->bExpired = pdFALSE_UNSIGNED;
 8005266:	7823      	ldrb	r3, [r4, #0]
	}

	pxTimer->bActive = pdTRUE_UNSIGNED;
 8005268:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
 800526c:	f043 0301 	orr.w	r3, r3, #1
 8005270:	7023      	strb	r3, [r4, #0]
 8005272:	bd38      	pop	{r3, r4, r5, pc}
 8005274:	2000d384 	.word	0x2000d384
 8005278:	2000d388 	.word	0x2000d388

0800527c <prvProcessNetworkDownEvent>:
	return eReturn;
}
/*-----------------------------------------------------------*/

static void prvProcessNetworkDownEvent( void )
{
 800527c:	b508      	push	{r3, lr}
	/* Stop the ARP timer while there is no network. */
	xARPTimer.bActive = pdFALSE_UNSIGNED;
 800527e:	4b0f      	ldr	r3, [pc, #60]	; (80052bc <prvProcessNetworkDownEvent+0x40>)
 8005280:	781a      	ldrb	r2, [r3, #0]
 8005282:	f36f 0200 	bfc	r2, #0, #1
 8005286:	701a      	strb	r2, [r3, #0]
		static BaseType_t xCallEventHook = pdFALSE;

		/* The first network down event is generated by the IP stack itself to
		initialise the network hardware, so do not call the network down event
		the first time through. */
		if( xCallEventHook == pdTRUE )
 8005288:	4b0d      	ldr	r3, [pc, #52]	; (80052c0 <prvProcessNetworkDownEvent+0x44>)
 800528a:	681b      	ldr	r3, [r3, #0]
 800528c:	2b01      	cmp	r3, #1
 800528e:	d102      	bne.n	8005296 <prvProcessNetworkDownEvent+0x1a>
		{
			vApplicationIPNetworkEventHook( eNetworkDown );
 8005290:	2001      	movs	r0, #1
 8005292:	f7ff f907 	bl	80044a4 <vApplicationIPNetworkEventHook>
		}
		xCallEventHook = pdTRUE;
 8005296:	2201      	movs	r2, #1
 8005298:	4b09      	ldr	r3, [pc, #36]	; (80052c0 <prvProcessNetworkDownEvent+0x44>)
 800529a:	601a      	str	r2, [r3, #0]
	#endif

	/* Per the ARP Cache Validation section of https://tools.ietf.org/html/rfc1122, 
	treat network down as a "delivery problem" and flush the ARP cache for this
	interface. */
	FreeRTOS_ClearARP( );
 800529c:	f7ff fc08 	bl	8004ab0 <FreeRTOS_ClearARP>

	/* The network has been disconnected (or is being initialised for the first
	time).  Perform whatever hardware processing is necessary to bring it up
	again, or wait for it to be available again.  This is hardware dependent. */
	if( xNetworkInterfaceInitialise() != pdPASS )
 80052a0:	f7fe ff7a 	bl	8004198 <xNetworkInterfaceInitialise>
 80052a4:	2801      	cmp	r0, #1
 80052a6:	d006      	beq.n	80052b6 <prvProcessNetworkDownEvent+0x3a>
	{
		/* Ideally the network interface initialisation function will only
		return when the network is available.  In case this is not the case,
		wait a while before retrying the initialisation. */
		vTaskDelay( ipINITIALISATION_RETRY_DELAY );
 80052a8:	f640 30b8 	movw	r0, #3000	; 0xbb8
 80052ac:	f7fe f8ee 	bl	800348c <vTaskDelay>
		FreeRTOS_NetworkDown();
 80052b0:	f7ff ffac 	bl	800520c <FreeRTOS_NetworkDown>
 80052b4:	bd08      	pop	{r3, pc}
			( void ) xSendEventToIPTask( eDHCPEvent );
		}
		#else
		{
			/* Perform any necessary 'network up' processing. */
			vIPNetworkUpCalls();
 80052b6:	f7ff ffc5 	bl	8005244 <vIPNetworkUpCalls>
 80052ba:	bd08      	pop	{r3, pc}
 80052bc:	2000d388 	.word	0x2000d388
 80052c0:	2000d380 	.word	0x2000d380

080052c4 <xIsIPv4Multicast>:
/*-----------------------------------------------------------*/

BaseType_t xIsIPv4Multicast( uint32_t ulIPAddress )
{
BaseType_t xReturn;
uint32_t ulIP = FreeRTOS_ntohl( ulIPAddress );
 80052c4:	0603      	lsls	r3, r0, #24
 80052c6:	ea43 6310 	orr.w	r3, r3, r0, lsr #24
 80052ca:	f400 427f 	and.w	r2, r0, #65280	; 0xff00
 80052ce:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80052d2:	f400 007f 	and.w	r0, r0, #16711680	; 0xff0000
 80052d6:	ea43 2010 	orr.w	r0, r3, r0, lsr #8

	if( ( ulIP >= ipFIRST_MULTI_CAST_IPv4 ) && ( ulIP < ipLAST_MULTI_CAST_IPv4 ) )
 80052da:	f100 5000 	add.w	r0, r0, #536870912	; 0x20000000
	else
	{
		xReturn = pdFALSE;
	}
	return xReturn;
}
 80052de:	f1b0 5f80 	cmp.w	r0, #268435456	; 0x10000000
 80052e2:	bf2c      	ite	cs
 80052e4:	2000      	movcs	r0, #0
 80052e6:	2001      	movcc	r0, #1
 80052e8:	4770      	bx	lr
 80052ea:	bf00      	nop

080052ec <vSetMultiCastIPv4MacAddress>:
/*-----------------------------------------------------------*/

void vSetMultiCastIPv4MacAddress( uint32_t ulIPAddress, MACAddress_t *pxMACAddress )
{
uint32_t ulIP = FreeRTOS_ntohl( ulIPAddress );
 80052ec:	0603      	lsls	r3, r0, #24
 80052ee:	ea43 6310 	orr.w	r3, r3, r0, lsr #24
 80052f2:	f400 427f 	and.w	r2, r0, #65280	; 0xff00
 80052f6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80052fa:	f400 007f 	and.w	r0, r0, #16711680	; 0xff0000
 80052fe:	ea43 2010 	orr.w	r0, r3, r0, lsr #8

	pxMACAddress->ucBytes[ 0 ] = ( uint8_t ) 0x01U;
 8005302:	2301      	movs	r3, #1
 8005304:	700b      	strb	r3, [r1, #0]
	pxMACAddress->ucBytes[ 1 ] = ( uint8_t ) 0x00U;
 8005306:	2300      	movs	r3, #0
 8005308:	704b      	strb	r3, [r1, #1]
	pxMACAddress->ucBytes[ 2 ] = ( uint8_t ) 0x5EU;
 800530a:	235e      	movs	r3, #94	; 0x5e
 800530c:	708b      	strb	r3, [r1, #2]
	pxMACAddress->ucBytes[ 3 ] = ( uint8_t ) ( ( ulIP >> 16 ) & 0x7fU );	/* Use 7 bits. */
 800530e:	f3c0 4306 	ubfx	r3, r0, #16, #7
 8005312:	70cb      	strb	r3, [r1, #3]
	pxMACAddress->ucBytes[ 4 ] = ( uint8_t ) ( ( ulIP >>  8 ) & 0xffU );	/* Use 8 bits. */
 8005314:	0a03      	lsrs	r3, r0, #8
 8005316:	710b      	strb	r3, [r1, #4]
	pxMACAddress->ucBytes[ 5 ] = ( uint8_t ) ( ( ulIP       ) & 0xffU );	/* Use 8 bits. */
 8005318:	7148      	strb	r0, [r1, #5]
 800531a:	4770      	bx	lr

0800531c <usGenerateChecksum>:
 *	 method should process. The method's memory iterator is initialized to this value.
 *   uxDataLengthBytes: This argument contains the number of bytes that this method
 *	 should process.
 */
uint16_t usGenerateChecksum( uint16_t usSum, const uint8_t * pucNextData, size_t uxByteCount )
{
 800531c:	b5f0      	push	{r4, r5, r6, r7, lr}
	/* Small MCUs often spend up to 30% of the time doing checksum calculations
	This function is optimised for 32-bit CPUs; Each time it will try to fetch
	32-bits, sums it with an accumulator and counts the number of carries. */

	/* Swap the input (little endian platform only). */
	usTemp = FreeRTOS_ntohs( usSum );
 800531e:	0a03      	lsrs	r3, r0, #8
 8005320:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
	xSum.u32 = ( uint32_t ) usTemp;
 8005324:	b283      	uxth	r3, r0
 8005326:	4618      	mov	r0, r3
	xTerm.u32 = 0UL;
 8005328:	2700      	movs	r7, #0

	xSource.u8ptr = ipPOINTER_CAST( uint8_t *, pucNextData );
	/* coverity[misra_c_2012_rule_11_4_violation] */
	/* The object pointer expression "pucNextData" of type "uint8_t const *" is cast to an integer type "unsigned int". */
	ulAlignBits = ( ( ( uint32_t ) pucNextData ) & 0x03U ); /*lint !e9078 !e923*/	/* gives 0, 1, 2, or 3 */
 800532a:	f001 0403 	and.w	r4, r1, #3

	/* If byte (8-bit) aligned... */
	if( ( ( ulAlignBits & 1UL ) != 0UL ) && ( uxDataLengthBytes >= ( size_t ) 1 ) )
 800532e:	f011 0e01 	ands.w	lr, r1, #1
 8005332:	d005      	beq.n	8005340 <usGenerateChecksum+0x24>
 8005334:	b16a      	cbz	r2, 8005352 <usGenerateChecksum+0x36>
	{
		xTerm.u8[ 1 ] = *( xSource.u8ptr );
 8005336:	f811 5b01 	ldrb.w	r5, [r1], #1
 800533a:	f365 270f 	bfi	r7, r5, #8, #8
		xSource.u8ptr++;
		uxDataLengthBytes--;
 800533e:	3a01      	subs	r2, #1
		/* Now xSource is word (16-bit) aligned. */
	}

	/* If half-word (16-bit) aligned... */
	if( ( ( ulAlignBits == 1U ) || ( ulAlignBits == 2U ) ) && ( uxDataLengthBytes >= 2U ) )
 8005340:	3c01      	subs	r4, #1
 8005342:	2c01      	cmp	r4, #1
 8005344:	d805      	bhi.n	8005352 <usGenerateChecksum+0x36>
 8005346:	2a01      	cmp	r2, #1
 8005348:	d903      	bls.n	8005352 <usGenerateChecksum+0x36>
	{
		xSum.u32 += *(xSource.u16ptr);
 800534a:	f831 0b02 	ldrh.w	r0, [r1], #2
 800534e:	4418      	add	r0, r3
		xSource.u16ptr++;
		uxDataLengthBytes -= 2U;
 8005350:	3a02      	subs	r2, #2
		/* Now xSource is word (32-bit) aligned. */
	}

	/* Word (32-bit) aligned, do the most part. */
	xLastSource.u32ptr = ( xSource.u32ptr + ( uxDataLengthBytes / 4U ) ) - 3U;
 8005352:	f022 0603 	bic.w	r6, r2, #3
 8005356:	3e0c      	subs	r6, #12
 8005358:	440e      	add	r6, r1

	/* In this loop, four 32-bit additions will be done, in total 16 bytes.
	Indexing with constants (0,1,2,3) gives faster code than using
	post-increments. */
	while( xSource.u32ptr < xLastSource.u32ptr )
 800535a:	428e      	cmp	r6, r1
 800535c:	d91b      	bls.n	8005396 <usGenerateChecksum+0x7a>
 800535e:	460b      	mov	r3, r1
 8005360:	2400      	movs	r4, #0
	{
		/* Use a secondary Sum2, just to see if the addition produced an
		overflow. */
		xSum2.u32 = xSum.u32 + xSource.u32ptr[ 0 ];
 8005362:	681d      	ldr	r5, [r3, #0]
		if( xSum2.u32 < xSum.u32 )
 8005364:	1940      	adds	r0, r0, r5
		{
			ulCarry++;
 8005366:	bf28      	it	cs
 8005368:	3401      	addcs	r4, #1
		}

		/* Now add the secondary sum to the major sum, and remember if there was
		a carry. */
		xSum.u32 = xSum2.u32 + xSource.u32ptr[ 1 ];
 800536a:	685d      	ldr	r5, [r3, #4]
		if( xSum2.u32 > xSum.u32 )
 800536c:	1940      	adds	r0, r0, r5
		{
			ulCarry++;
 800536e:	bf28      	it	cs
 8005370:	3401      	addcs	r4, #1
		}

		/* And do the same trick once again for indexes 2 and 3 */
		xSum2.u32 = xSum.u32 + xSource.u32ptr[ 2 ];
 8005372:	689d      	ldr	r5, [r3, #8]
		if( xSum2.u32 < xSum.u32 )
 8005374:	1940      	adds	r0, r0, r5
		{
			ulCarry++;
 8005376:	bf28      	it	cs
 8005378:	3401      	addcs	r4, #1
		}

		xSum.u32 = xSum2.u32 + xSource.u32ptr[ 3 ];
 800537a:	68dd      	ldr	r5, [r3, #12]

		if( xSum2.u32 > xSum.u32 )
 800537c:	1940      	adds	r0, r0, r5
		{
			ulCarry++;
 800537e:	bf28      	it	cs
 8005380:	3401      	addcs	r4, #1
		}

		/* And finally advance the pointer 4 * 4 = 16 bytes. */
		xSource.u32ptr = &( xSource.u32ptr[ 4 ] );
 8005382:	3310      	adds	r3, #16
	xLastSource.u32ptr = ( xSource.u32ptr + ( uxDataLengthBytes / 4U ) ) - 3U;

	/* In this loop, four 32-bit additions will be done, in total 16 bytes.
	Indexing with constants (0,1,2,3) gives faster code than using
	post-increments. */
	while( xSource.u32ptr < xLastSource.u32ptr )
 8005384:	429e      	cmp	r6, r3
 8005386:	d8ec      	bhi.n	8005362 <usGenerateChecksum+0x46>
 8005388:	43cb      	mvns	r3, r1
 800538a:	441e      	add	r6, r3
 800538c:	f026 060f 	bic.w	r6, r6, #15
 8005390:	3610      	adds	r6, #16
 8005392:	4431      	add	r1, r6
 8005394:	e000      	b.n	8005398 <usGenerateChecksum+0x7c>
/* MISRA/PC-lint doesn't like the use of unions. Here, they are a great
aid though to optimise the calculations. */
xUnion32 xSum2, xSum, xTerm;
xUnionPtr xSource;
xUnionPtr xLastSource;
uint32_t ulAlignBits, ulCarry = 0UL;
 8005396:	2400      	movs	r4, #0
		/* And finally advance the pointer 4 * 4 = 16 bytes. */
		xSource.u32ptr = &( xSource.u32ptr[ 4 ] );
	}

	/* Now add all carries. */
	xSum.u32 = ( uint32_t )xSum.u16[ 0 ] + xSum.u16[ 1 ] + ulCarry;
 8005398:	b283      	uxth	r3, r0
 800539a:	eb03 4010 	add.w	r0, r3, r0, lsr #16
 800539e:	4420      	add	r0, r4
 80053a0:	4604      	mov	r4, r0

	uxDataLengthBytes %= 16U;
	xLastSource.u8ptr = ( uint8_t * ) ( xSource.u8ptr + ( uxDataLengthBytes & ~( ( size_t ) 1 ) ) );
 80053a2:	f002 050e 	and.w	r5, r2, #14
 80053a6:	440d      	add	r5, r1

	/* Half-word aligned. */
	/* Coverity does not like Unions. Warning issued here: "The operator "<"
	 * is being applied to the pointers "xSource.u16ptr" and "xLastSource.u16ptr",
	 * which do not point into the same object." */
	while( xSource.u16ptr < xLastSource.u16ptr )
 80053a8:	428d      	cmp	r5, r1
 80053aa:	d90c      	bls.n	80053c6 <usGenerateChecksum+0xaa>
 80053ac:	460b      	mov	r3, r1
	{
		/* At least one more short. */
		xSum.u32 += xSource.u16ptr[ 0 ];
 80053ae:	f833 0b02 	ldrh.w	r0, [r3], #2
 80053b2:	4404      	add	r4, r0

	/* Half-word aligned. */
	/* Coverity does not like Unions. Warning issued here: "The operator "<"
	 * is being applied to the pointers "xSource.u16ptr" and "xLastSource.u16ptr",
	 * which do not point into the same object." */
	while( xSource.u16ptr < xLastSource.u16ptr )
 80053b4:	429d      	cmp	r5, r3
 80053b6:	d8fa      	bhi.n	80053ae <usGenerateChecksum+0x92>
 80053b8:	43cb      	mvns	r3, r1
 80053ba:	441d      	add	r5, r3
 80053bc:	f025 0501 	bic.w	r5, r5, #1
 80053c0:	3502      	adds	r5, #2
 80053c2:	4429      	add	r1, r5
 80053c4:	4620      	mov	r0, r4
		/* At least one more short. */
		xSum.u32 += xSource.u16ptr[ 0 ];
		xSource.u16ptr++;
	}

	if( ( uxDataLengthBytes & ( size_t ) 1 ) != 0U )	/* Maybe one more ? */
 80053c6:	f012 0f01 	tst.w	r2, #1
	{
		xTerm.u8[ 0 ] = xSource.u8ptr[ 0 ];
 80053ca:	bf1c      	itt	ne
 80053cc:	780b      	ldrbne	r3, [r1, #0]
 80053ce:	f363 0707 	bfine	r7, r3, #0, #8
	}
	xSum.u32 += xTerm.u32;
 80053d2:	4438      	add	r0, r7

	/* Now add all carries again. */
	/* Assigning value from "xTerm.u32" to "xSum.u32" here, but that stored value is overwritten before it can be used.
	Coverity doesn't understand about union variables. */
	xSum.u32 = ( uint32_t ) xSum.u16[ 0 ] + xSum.u16[ 1 ];
 80053d4:	b283      	uxth	r3, r0
 80053d6:	eb03 4010 	add.w	r0, r3, r0, lsr #16

	/* coverity[value_overwrite] */
	xSum.u32 = ( uint32_t ) xSum.u16[ 0 ] + xSum.u16[ 1 ];
 80053da:	b283      	uxth	r3, r0
 80053dc:	eb03 4010 	add.w	r0, r3, r0, lsr #16

	if( ( ulAlignBits & 1U ) != 0U )
 80053e0:	f1be 0f00 	cmp.w	lr, #0
 80053e4:	d004      	beq.n	80053f0 <usGenerateChecksum+0xd4>
	{
		/* Quite unlikely, but pucNextData might be non-aligned, which would
		 mean that a checksum is calculated starting at an odd position. */
		xSum.u32 = ( ( xSum.u32 & 0xffU ) << 8 ) | ( ( xSum.u32 & 0xff00U ) >> 8 );
 80053e6:	f3c0 2307 	ubfx	r3, r0, #8, #8
 80053ea:	0200      	lsls	r0, r0, #8
 80053ec:	b280      	uxth	r0, r0
 80053ee:	4318      	orrs	r0, r3
 80053f0:	b280      	uxth	r0, r0
	}

	/* swap the output (little endian platform only). */
	return FreeRTOS_htons( ( (uint16_t) xSum.u32 ) );
 80053f2:	0a03      	lsrs	r3, r0, #8
 80053f4:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
}
 80053f8:	b280      	uxth	r0, r0
 80053fa:	bdf0      	pop	{r4, r5, r6, r7, pc}

080053fc <usGenerateProtocolChecksum>:
	/* Introduce a do-while loop to allow use of break statements.
	 * Note: MISRA prohibits use of 'goto', thus replaced with breaks. */
	do
	{
		/* Check for minimum packet size. */
		if( uxBufferLength < sizeof( IPPacket_t ) )
 80053fc:	2921      	cmp	r1, #33	; 0x21
 80053fe:	d971      	bls.n	80054e4 <usGenerateProtocolChecksum+0xe8>
	}
#endif /* ( ipconfigDRIVER_INCLUDED_RX_IP_CHECKSUM == 1 ) */
/*-----------------------------------------------------------*/

uint16_t usGenerateProtocolChecksum( const uint8_t * const pucEthernetBuffer, size_t uxBufferLength, BaseType_t xOutgoingPacket )
{
 8005400:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		pxIPPacket = ipCAST_CONST_PTR_TO_CONST_TYPE_PTR( IPPacket_t, pucEthernetBuffer );

		/* Per https://tools.ietf.org/html/rfc791, the four-bit Internet Header
		Length field contains the length of the internet header in 32-bit words. */
		ucVersionHeaderLength = pxIPPacket->xIPHeader.ucVersionHeaderLength;
		ucVersionHeaderLength = ( ucVersionHeaderLength & ( uint8_t ) 0x0FU ) << 2;
 8005404:	7b83      	ldrb	r3, [r0, #14]
 8005406:	f003 030f 	and.w	r3, r3, #15
		uxIPHeaderLength = ( UBaseType_t ) ucVersionHeaderLength;
 800540a:	009b      	lsls	r3, r3, #2

		/* Check for minimum packet size. */
		if( uxBufferLength < ( sizeof( IPPacket_t ) + ( uxIPHeaderLength - ipSIZE_OF_IPv4_HEADER ) ) )
 800540c:	f103 040e 	add.w	r4, r3, #14
 8005410:	42a1      	cmp	r1, r4
 8005412:	d36a      	bcc.n	80054ea <usGenerateProtocolChecksum+0xee>
		{
			usChecksum = ipINVALID_LENGTH;
			location = 2;
			break;
		}
		usLength = pxIPPacket->xIPHeader.usLength;
 8005414:	8a05      	ldrh	r5, [r0, #16]
		usLength = FreeRTOS_ntohs( usLength );
 8005416:	0a2c      	lsrs	r4, r5, #8
 8005418:	ea44 2405 	orr.w	r4, r4, r5, lsl #8
		if( uxBufferLength < ( size_t ) ( ipSIZE_OF_ETH_HEADER + ( size_t ) usLength ) )
 800541c:	b2a4      	uxth	r4, r4
 800541e:	340e      	adds	r4, #14
 8005420:	42a1      	cmp	r1, r4
 8005422:	d366      	bcc.n	80054f2 <usGenerateProtocolChecksum+0xf6>
			location = 3;
			break;
		}

		/* Identify the next protocol. */
		ucProtocol = pxIPPacket->xIPHeader.ucProtocol;
 8005424:	7dc5      	ldrb	r5, [r0, #23]
		/* N.B., if this IP packet header includes Options, then the following
		assignment results in a pointer into the protocol packet with the Ethernet
		and IP headers incorrectly aligned. However, either way, the "third"
		protocol (Layer 3 or 4) header will be aligned, which is the convenience
		of this calculation. */
		pxProtPack = ipCAST_CONST_PTR_TO_CONST_TYPE_PTR( ProtocolPacket_t, &( pucEthernetBuffer[ uxIPHeaderLength - ipSIZE_OF_IPv4_HEADER ] ) );
 8005426:	f1a3 0414 	sub.w	r4, r3, #20
 800542a:	1906      	adds	r6, r0, r4

		/* Switch on the Layer 3/4 protocol. */
		if( ucProtocol == ( uint8_t ) ipPROTOCOL_UDP )
 800542c:	2d11      	cmp	r5, #17
 800542e:	d106      	bne.n	800543e <usGenerateProtocolChecksum+0x42>
		{
			if( uxBufferLength < ( uxIPHeaderLength + ipSIZE_OF_ETH_HEADER + ipSIZE_OF_UDP_HEADER ) )
 8005430:	f103 0416 	add.w	r4, r3, #22
 8005434:	42a1      	cmp	r1, r4
 8005436:	d360      	bcc.n	80054fa <usGenerateProtocolChecksum+0xfe>
				usChecksum = ipINVALID_LENGTH;
				location = 4;
				break;
			}

			pusChecksum = ( uint16_t * ) ( &( pxProtPack->xUDPPacket.xUDPHeader.usChecksum ) );
 8005438:	f106 0428 	add.w	r4, r6, #40	; 0x28
 800543c:	e012      	b.n	8005464 <usGenerateProtocolChecksum+0x68>
			{
				pcType = "UDP";
			}
			#endif	/* ipconfigHAS_DEBUG_PRINTF != 0 */
		}
		else if( ucProtocol == ( uint8_t ) ipPROTOCOL_TCP )
 800543e:	2d06      	cmp	r5, #6
 8005440:	d106      	bne.n	8005450 <usGenerateProtocolChecksum+0x54>
		{
			if( uxBufferLength < ( uxIPHeaderLength + ipSIZE_OF_ETH_HEADER + ipSIZE_OF_TCP_HEADER ) )
 8005442:	f103 0422 	add.w	r4, r3, #34	; 0x22
 8005446:	42a1      	cmp	r1, r4
 8005448:	d35b      	bcc.n	8005502 <usGenerateProtocolChecksum+0x106>
				usChecksum = ipINVALID_LENGTH;
				location = 5;
				break;
			}

			pusChecksum = ( uint16_t * ) ( &( pxProtPack->xTCPPacket.xTCPHeader.usChecksum ) );
 800544a:	f106 0432 	add.w	r4, r6, #50	; 0x32
 800544e:	e009      	b.n	8005464 <usGenerateProtocolChecksum+0x68>
			{
				pcType = "TCP";
			}
			#endif	/* ipconfigHAS_DEBUG_PRINTF != 0 */
		}
		else if( ( ucProtocol == ( uint8_t ) ipPROTOCOL_ICMP ) ||
 8005450:	1e6c      	subs	r4, r5, #1
 8005452:	b2e4      	uxtb	r4, r4
 8005454:	2c01      	cmp	r4, #1
 8005456:	d858      	bhi.n	800550a <usGenerateProtocolChecksum+0x10e>
				( ucProtocol == ( uint8_t ) ipPROTOCOL_IGMP ) )
		{
			if( uxBufferLength < ( uxIPHeaderLength + ipSIZE_OF_ETH_HEADER + ipSIZE_OF_ICMP_HEADER ) )
 8005458:	f103 0416 	add.w	r4, r3, #22
 800545c:	42a1      	cmp	r1, r4
 800545e:	d358      	bcc.n	8005512 <usGenerateProtocolChecksum+0x116>
				usChecksum = ipINVALID_LENGTH;
				location = 6;
				break;
			}

			pusChecksum = ( uint16_t * ) ( &( pxProtPack->xICMPPacket.xICMPHeader.usChecksum ) );
 8005460:	f106 0424 	add.w	r4, r6, #36	; 0x24
			break;
		}

		/* The protocol and checksum field have been identified. Check the direction
		of the packet. */
		if( xOutgoingPacket != pdFALSE )
 8005464:	b112      	cbz	r2, 800546c <usGenerateProtocolChecksum+0x70>
		{
			/* This is an outgoing packet. Before calculating the checksum, set it
			to zero. */
			*( pusChecksum ) = 0U;
 8005466:	2100      	movs	r1, #0
 8005468:	8021      	strh	r1, [r4, #0]
 800546a:	e003      	b.n	8005474 <usGenerateProtocolChecksum+0x78>
		}
		else if( ( *pusChecksum == 0U ) && ( ucProtocol == ( uint8_t ) ipPROTOCOL_UDP ) )
 800546c:	8821      	ldrh	r1, [r4, #0]
 800546e:	b909      	cbnz	r1, 8005474 <usGenerateProtocolChecksum+0x78>
 8005470:	2d11      	cmp	r5, #17
 8005472:	d052      	beq.n	800551a <usGenerateProtocolChecksum+0x11e>
		else
		{
			/* Other incoming packet than UDP. */
		}

		usLength = pxIPPacket->xIPHeader.usLength;
 8005474:	8a07      	ldrh	r7, [r0, #16]
		usLength = FreeRTOS_ntohs( usLength );
 8005476:	0a39      	lsrs	r1, r7, #8
 8005478:	ea41 2707 	orr.w	r7, r1, r7, lsl #8
		ulLength = ( uint32_t ) usLength;
 800547c:	b2bf      	uxth	r7, r7
		ulLength -= ( ( uint16_t ) uxIPHeaderLength ); /* normally minus 20 */
 800547e:	1aff      	subs	r7, r7, r3

		if( ( ulLength < ( ( uint32_t ) sizeof( pxProtPack->xUDPPacket.xUDPHeader ) ) ) ||
 8005480:	2f07      	cmp	r7, #7
 8005482:	d94d      	bls.n	8005520 <usGenerateProtocolChecksum+0x124>
			( ulLength > ( ( uint32_t ) ipconfigNETWORK_MTU - ( uint32_t ) uxIPHeaderLength ) ) )
 8005484:	f5c3 6396 	rsb	r3, r3, #1200	; 0x4b0
		usLength = pxIPPacket->xIPHeader.usLength;
		usLength = FreeRTOS_ntohs( usLength );
		ulLength = ( uint32_t ) usLength;
		ulLength -= ( ( uint16_t ) uxIPHeaderLength ); /* normally minus 20 */

		if( ( ulLength < ( ( uint32_t ) sizeof( pxProtPack->xUDPPacket.xUDPHeader ) ) ) ||
 8005488:	429f      	cmp	r7, r3
 800548a:	d84d      	bhi.n	8005528 <usGenerateProtocolChecksum+0x12c>
 800548c:	4690      	mov	r8, r2
 800548e:	4601      	mov	r1, r0
			format/length */
			usChecksum = ipINVALID_LENGTH;
			location = 9;
			break;
		}
		if( ucProtocol <= ( uint8_t ) ipPROTOCOL_IGMP )
 8005490:	2d02      	cmp	r5, #2
 8005492:	d808      	bhi.n	80054a6 <usGenerateProtocolChecksum+0xaa>
		{
			/* ICMP/IGMP do not have a pseudo header for CRC-calculation. */
			usChecksum = ( uint16_t )
				( ~usGenerateChecksum( 0U,
 8005494:	2000      	movs	r0, #0
 8005496:	f106 0122 	add.w	r1, r6, #34	; 0x22
 800549a:	463a      	mov	r2, r7
 800549c:	f7ff ff3e 	bl	800531c <usGenerateChecksum>
			break;
		}
		if( ucProtocol <= ( uint8_t ) ipPROTOCOL_IGMP )
		{
			/* ICMP/IGMP do not have a pseudo header for CRC-calculation. */
			usChecksum = ( uint16_t )
 80054a0:	43c0      	mvns	r0, r0
 80054a2:	b280      	uxth	r0, r0
 80054a4:	e008      	b.n	80054b8 <usGenerateProtocolChecksum+0xbc>
		}
		else
		{
			/* For UDP and TCP, sum the pseudo header, i.e. IP protocol + length
			fields */
			usChecksum = ( uint16_t ) ( ulLength + ( ( uint16_t ) ucProtocol ) );
 80054a6:	1978      	adds	r0, r7, r5

			/* And then continue at the IPv4 source and destination addresses. */
			usChecksum = ( uint16_t )
					( ~usGenerateChecksum( usChecksum,
 80054a8:	b280      	uxth	r0, r0
 80054aa:	311a      	adds	r1, #26
 80054ac:	f107 0208 	add.w	r2, r7, #8
 80054b0:	f7ff ff34 	bl	800531c <usGenerateChecksum>
			/* For UDP and TCP, sum the pseudo header, i.e. IP protocol + length
			fields */
			usChecksum = ( uint16_t ) ( ulLength + ( ( uint16_t ) ucProtocol ) );

			/* And then continue at the IPv4 source and destination addresses. */
			usChecksum = ( uint16_t )
 80054b4:	43c0      	mvns	r0, r0
 80054b6:	b280      	uxth	r0, r0
										   ipPOINTER_CAST( const uint8_t *, &( pxIPPacket->xIPHeader.ulSourceIPAddress ) ),
										   ( size_t )( ( 2U * ipSIZE_OF_IPv4_ADDRESS ) + ulLength ) ) );
			/* Sum TCP header and data. */
		}

		if( xOutgoingPacket == pdFALSE )
 80054b8:	f1b8 0f00 	cmp.w	r8, #0
 80054bc:	d10a      	bne.n	80054d4 <usGenerateProtocolChecksum+0xd8>
		{
			/* This is in incoming packet. If the CRC is correct, it should be zero. */
			if( usChecksum == 0U )
			{
				usChecksum = ( uint16_t )ipCORRECT_CRC;
 80054be:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80054c2:	2800      	cmp	r0, #0
 80054c4:	bf08      	it	eq
 80054c6:	4618      	moveq	r0, r3
				#endif	/* ipconfigHAS_DEBUG_PRINTF != 0 */

				usChecksum = ( uint16_t )0xffffu;
			}
		}
		usChecksum = FreeRTOS_htons( usChecksum );
 80054c8:	0a03      	lsrs	r3, r0, #8
 80054ca:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 80054ce:	b280      	uxth	r0, r0
 80054d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				usChecksum = ( uint16_t )ipCORRECT_CRC;
			}
		}
		else
		{
			if( ( usChecksum == 0U ) && ( ucProtocol == ( uint8_t ) ipPROTOCOL_UDP ) )
 80054d4:	bb60      	cbnz	r0, 8005530 <usGenerateProtocolChecksum+0x134>
 80054d6:	2d11      	cmp	r5, #17
 80054d8:	f04f 35ff 	mov.w	r5, #4294967295
 80054dc:	bf18      	it	ne
 80054de:	2500      	movne	r5, #0
 80054e0:	b2a8      	uxth	r0, r5
 80054e2:	e025      	b.n	8005530 <usGenerateProtocolChecksum+0x134>
	do
	{
		/* Check for minimum packet size. */
		if( uxBufferLength < sizeof( IPPacket_t ) )
		{
			usChecksum = ipINVALID_LENGTH;
 80054e4:	f241 2034 	movw	r0, #4660	; 0x1234
		 * the variable without modifying the logic of the source. */
		( void ) location;
	}

	return usChecksum;
}
 80054e8:	4770      	bx	lr
		uxIPHeaderLength = ( UBaseType_t ) ucVersionHeaderLength;

		/* Check for minimum packet size. */
		if( uxBufferLength < ( sizeof( IPPacket_t ) + ( uxIPHeaderLength - ipSIZE_OF_IPv4_HEADER ) ) )
		{
			usChecksum = ipINVALID_LENGTH;
 80054ea:	f241 2034 	movw	r0, #4660	; 0x1234
 80054ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		}
		usLength = pxIPPacket->xIPHeader.usLength;
		usLength = FreeRTOS_ntohs( usLength );
		if( uxBufferLength < ( size_t ) ( ipSIZE_OF_ETH_HEADER + ( size_t ) usLength ) )
		{
			usChecksum = ipINVALID_LENGTH;
 80054f2:	f241 2034 	movw	r0, #4660	; 0x1234
 80054f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		/* Switch on the Layer 3/4 protocol. */
		if( ucProtocol == ( uint8_t ) ipPROTOCOL_UDP )
		{
			if( uxBufferLength < ( uxIPHeaderLength + ipSIZE_OF_ETH_HEADER + ipSIZE_OF_UDP_HEADER ) )
			{
				usChecksum = ipINVALID_LENGTH;
 80054fa:	f241 2034 	movw	r0, #4660	; 0x1234
 80054fe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		}
		else if( ucProtocol == ( uint8_t ) ipPROTOCOL_TCP )
		{
			if( uxBufferLength < ( uxIPHeaderLength + ipSIZE_OF_ETH_HEADER + ipSIZE_OF_TCP_HEADER ) )
			{
				usChecksum = ipINVALID_LENGTH;
 8005502:	f241 2034 	movw	r0, #4660	; 0x1234
 8005506:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			#endif	/* ipconfigHAS_DEBUG_PRINTF != 0 */
		}
		else
		{
			/* Unhandled protocol, other than ICMP, IGMP, UDP, or TCP. */
			usChecksum = ipUNHANDLED_PROTOCOL;
 800550a:	f244 3021 	movw	r0, #17185	; 0x4321
 800550e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		else if( ( ucProtocol == ( uint8_t ) ipPROTOCOL_ICMP ) ||
				( ucProtocol == ( uint8_t ) ipPROTOCOL_IGMP ) )
		{
			if( uxBufferLength < ( uxIPHeaderLength + ipSIZE_OF_ETH_HEADER + ipSIZE_OF_ICMP_HEADER ) )
			{
				usChecksum = ipINVALID_LENGTH;
 8005512:	f241 2034 	movw	r0, #4660	; 0x1234
 8005516:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		{
			#if( ipconfigUDP_PASS_ZERO_CHECKSUM_PACKETS == 0 )
			{
				/* Sender hasn't set the checksum, drop the packet because
				ipconfigUDP_PASS_ZERO_CHECKSUM_PACKETS is not set. */
				usChecksum = ipWRONG_CRC;
 800551a:	2000      	movs	r0, #0
 800551c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

			/* Again, in a 16-bit return value there is no space to indicate an
			error.  For incoming packets, 0x1234 will cause dropping of the packet.
			For outgoing packets, there is a serious problem with the
			format/length */
			usChecksum = ipINVALID_LENGTH;
 8005520:	f241 2034 	movw	r0, #4660	; 0x1234
 8005524:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005528:	f241 2034 	movw	r0, #4660	; 0x1234
 800552c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				#endif	/* ipconfigHAS_DEBUG_PRINTF != 0 */

				usChecksum = ( uint16_t )0xffffu;
			}
		}
		usChecksum = FreeRTOS_htons( usChecksum );
 8005530:	0a03      	lsrs	r3, r0, #8
 8005532:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 8005536:	b280      	uxth	r0, r0

		if( xOutgoingPacket != pdFALSE )
		{
			*( pusChecksum ) = usChecksum;
 8005538:	8020      	strh	r0, [r4, #0]
		 * the variable without modifying the logic of the source. */
		( void ) location;
	}

	return usChecksum;
}
 800553a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800553e:	bf00      	nop

08005540 <vReturnEthernetFrame>:
/*-----------------------------------------------------------*/

/* This function is used in other files, has external linkage e.g. in
 * FreeRTOS_DNS.c. Not to be made static. */
void vReturnEthernetFrame( NetworkBufferDescriptor_t * pxNetworkBuffer, BaseType_t xReleaseAfterSend )
{
 8005540:	b538      	push	{r3, r4, r5, lr}
 8005542:	4604      	mov	r4, r0

	if( pxNetworkBuffer != NULL )
#endif
	{
		/* Map the Buffer to Ethernet Header struct for easy access to fields. */
		pxEthernetHeader = ipCAST_PTR_TO_TYPE_PTR( EthernetHeader_t, pxNetworkBuffer->pucEthernetBuffer );
 8005544:	6982      	ldr	r2, [r0, #24]

		/* Swap source and destination MAC addresses. */
		( void ) memcpy( ( void * ) &( pxEthernetHeader->xDestinationAddress ), ( const void * ) ( &( pxEthernetHeader->xSourceAddress ) ), sizeof( pxEthernetHeader->xDestinationAddress ) );
 8005546:	4613      	mov	r3, r2
 8005548:	f853 0f06 	ldr.w	r0, [r3, #6]!
 800554c:	6010      	str	r0, [r2, #0]
 800554e:	8898      	ldrh	r0, [r3, #4]
 8005550:	8090      	strh	r0, [r2, #4]
		( void ) memcpy( ( void * ) &( pxEthernetHeader->xSourceAddress) , ( const void * ) ipLOCAL_MAC_ADDRESS, ( size_t ) ipMAC_ADDRESS_LENGTH_BYTES );
 8005552:	4d05      	ldr	r5, [pc, #20]	; (8005568 <vReturnEthernetFrame+0x28>)
 8005554:	6828      	ldr	r0, [r5, #0]
 8005556:	f8c2 0006 	str.w	r0, [r2, #6]
 800555a:	88aa      	ldrh	r2, [r5, #4]
 800555c:	809a      	strh	r2, [r3, #4]

		/* Send! */
		( void ) xNetworkInterfaceOutput( pxNetworkBuffer, xReleaseAfterSend );
 800555e:	4620      	mov	r0, r4
 8005560:	f7fe fe80 	bl	8004264 <xNetworkInterfaceOutput>
 8005564:	bd38      	pop	{r3, r4, r5, pc}
 8005566:	bf00      	nop
 8005568:	2000d5c0 	.word	0x2000d5c0

0800556c <prvIPTask>:
/*-----------------------------------------------------------*/

/* Coverity want to make pvParameters const, which would make it incompatible. */
/* coverity[misra_c_2012_rule_8_13_violation] */
static void prvIPTask( void *pvParameters )
{
 800556c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005570:	b087      	sub	sp, #28

	/* Generate a dummy message to say that the network connection has gone
	down.  This will cause this task to initialise the network interface.  After
	this it is the responsibility of the network interface hardware driver to
	send this message if a previously connected network is disconnected. */
	FreeRTOS_NetworkDown();
 8005572:	f7ff fe4b 	bl	800520c <FreeRTOS_NetworkDown>
}
/*-----------------------------------------------------------*/

static void prvIPTimerReload( IPTimer_t *pxTimer, TickType_t xTime )
{
	pxTimer->ulReloadTime = xTime;
 8005576:	4cba      	ldr	r4, [pc, #744]	; (8005860 <prvIPTask+0x2f4>)
 8005578:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 800557c:	6125      	str	r5, [r4, #16]
}
/*-----------------------------------------------------------*/

static void prvIPTimerStart( IPTimer_t *pxTimer, TickType_t xTime )
{
	vTaskSetTimeOutState( &pxTimer->xTimeOut );
 800557e:	1d20      	adds	r0, r4, #4
 8005580:	f7fe f8ec 	bl	800375c <vTaskSetTimeOutState>
	pxTimer->ulRemainingTime = xTime;
 8005584:	60e5      	str	r5, [r4, #12]
	{
		pxTimer->bExpired = pdTRUE_UNSIGNED;
	}
	else
	{
		pxTimer->bExpired = pdFALSE_UNSIGNED;
 8005586:	7823      	ldrb	r3, [r4, #0]
	}

	pxTimer->bActive = pdTRUE_UNSIGNED;
 8005588:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
 800558c:	f043 0301 	orr.w	r3, r3, #1
 8005590:	7023      	strb	r3, [r4, #0]
		prvIPTimerReload( &xTCPTimer, pdMS_TO_TICKS( ipTCP_TIMER_PERIOD_MS ) );
	}
	#endif

	/* Initialisation is complete and events can now be processed. */
	xIPTaskInitialised = pdTRUE;
 8005592:	2201      	movs	r2, #1
 8005594:	4bb3      	ldr	r3, [pc, #716]	; (8005864 <prvIPTask+0x2f8>)
 8005596:	601a      	str	r2, [r3, #0]
/*-----------------------------------------------------------*/

static void prvCheckNetworkTimers( void )
{
	/* Is it time for ARP processing? */
	if( prvIPTimerCheck( &xARPTimer ) != pdFALSE )
 8005598:	4fb3      	ldr	r7, [pc, #716]	; (8005868 <prvIPTask+0x2fc>)
 800559a:	9701      	str	r7, [sp, #4]
	#endif /* ipconfigUSE_DHCP */

	#if( ipconfigDNS_USE_CALLBACKS != 0 )
	{
		/* Is it time for DNS processing? */
		if( prvIPTimerCheck( &xDNSTimer ) != pdFALSE )
 800559c:	4db3      	ldr	r5, [pc, #716]	; (800586c <prvIPTask+0x300>)
}
/*-----------------------------------------------------------*/

static void prvIPTimerStart( IPTimer_t *pxTimer, TickType_t xTime )
{
	vTaskSetTimeOutState( &pxTimer->xTimeOut );
 800559e:	f104 0a04 	add.w	sl, r4, #4
/*-----------------------------------------------------------*/

static void prvCheckNetworkTimers( void )
{
	/* Is it time for ARP processing? */
	if( prvIPTimerCheck( &xARPTimer ) != pdFALSE )
 80055a2:	9801      	ldr	r0, [sp, #4]
 80055a4:	f7ff fcf2 	bl	8004f8c <prvIPTimerCheck>
 80055a8:	b110      	cbz	r0, 80055b0 <prvIPTask+0x44>
	{
		( void ) xSendEventToIPTask( eARPTimerEvent );
 80055aa:	2003      	movs	r0, #3
 80055ac:	f7ff fe3e 	bl	800522c <xSendEventToIPTask>
	#endif /* ipconfigUSE_DHCP */

	#if( ipconfigDNS_USE_CALLBACKS != 0 )
	{
		/* Is it time for DNS processing? */
		if( prvIPTimerCheck( &xDNSTimer ) != pdFALSE )
 80055b0:	4628      	mov	r0, r5
 80055b2:	f7ff fceb 	bl	8004f8c <prvIPTimerCheck>
 80055b6:	b110      	cbz	r0, 80055be <prvIPTask+0x52>
		{
			vDNSCheckCallBack( NULL );
 80055b8:	2000      	movs	r0, #0
 80055ba:	f7ff fc9b 	bl	8004ef4 <vDNSCheckCallBack>
	TickType_t xNextTime;
	BaseType_t xCheckTCPSockets;

		/* If the IP task has messages waiting to be processed then
		it will not sleep in any case. */
		if( uxQueueMessagesWaiting( xNetworkEventQueue ) == 0U )
 80055be:	4bac      	ldr	r3, [pc, #688]	; (8005870 <prvIPTask+0x304>)
 80055c0:	6818      	ldr	r0, [r3, #0]
 80055c2:	f7fd fb37 	bl	8002c34 <uxQueueMessagesWaiting>
 80055c6:	fab0 f680 	clz	r6, r0
 80055ca:	0976      	lsrs	r6, r6, #5
		{
			xWillSleep = pdFALSE;
		}

		/* Sockets need to be checked if the TCP timer has expired. */
		xCheckTCPSockets = prvIPTimerCheck( &xTCPTimer );
 80055cc:	4620      	mov	r0, r4
 80055ce:	f7ff fcdd 	bl	8004f8c <prvIPTimerCheck>

		/* Sockets will also be checked if there are TCP messages but the
		message queue is empty (indicated by xWillSleep being true). */
		if( ( xProcessedTCPMessage != pdFALSE ) && ( xWillSleep != pdFALSE ) )
 80055d2:	4ba8      	ldr	r3, [pc, #672]	; (8005874 <prvIPTask+0x308>)
 80055d4:	681b      	ldr	r3, [r3, #0]
 80055d6:	b103      	cbz	r3, 80055da <prvIPTask+0x6e>
 80055d8:	b906      	cbnz	r6, 80055dc <prvIPTask+0x70>
		{
			xCheckTCPSockets = pdTRUE;
		}

		if( xCheckTCPSockets != pdFALSE )
 80055da:	b1c0      	cbz	r0, 800560e <prvIPTask+0xa2>
		{
			/* Attend to the sockets, returning the period after which the
			check must be repeated. */
			xNextTime = xTCPTimerCheck( xWillSleep );
 80055dc:	4630      	mov	r0, r6
 80055de:	f001 fa65 	bl	8006aac <xTCPTimerCheck>
 80055e2:	4606      	mov	r6, r0
}
/*-----------------------------------------------------------*/

static void prvIPTimerStart( IPTimer_t *pxTimer, TickType_t xTime )
{
	vTaskSetTimeOutState( &pxTimer->xTimeOut );
 80055e4:	4650      	mov	r0, sl
 80055e6:	f7fe f8b9 	bl	800375c <vTaskSetTimeOutState>
	pxTimer->ulRemainingTime = xTime;
 80055ea:	60e6      	str	r6, [r4, #12]

	if( xTime == ( TickType_t ) 0 )
 80055ec:	b926      	cbnz	r6, 80055f8 <prvIPTask+0x8c>
	{
		pxTimer->bExpired = pdTRUE_UNSIGNED;
 80055ee:	7823      	ldrb	r3, [r4, #0]
 80055f0:	f043 0302 	orr.w	r3, r3, #2
 80055f4:	7023      	strb	r3, [r4, #0]
 80055f6:	e003      	b.n	8005600 <prvIPTask+0x94>
	}
	else
	{
		pxTimer->bExpired = pdFALSE_UNSIGNED;
 80055f8:	7823      	ldrb	r3, [r4, #0]
 80055fa:	f36f 0341 	bfc	r3, #1, #1
 80055fe:	7023      	strb	r3, [r4, #0]
	}

	pxTimer->bActive = pdTRUE_UNSIGNED;
 8005600:	7823      	ldrb	r3, [r4, #0]
 8005602:	f043 0301 	orr.w	r3, r3, #1
 8005606:	7023      	strb	r3, [r4, #0]
		{
			/* Attend to the sockets, returning the period after which the
			check must be repeated. */
			xNextTime = xTCPTimerCheck( xWillSleep );
			prvIPTimerStart( &xTCPTimer, xNextTime );
			xProcessedTCPMessage = 0;
 8005608:	2200      	movs	r2, #0
 800560a:	4b9a      	ldr	r3, [pc, #616]	; (8005874 <prvIPTask+0x308>)
 800560c:	601a      	str	r2, [r3, #0]

	/* Start with the maximum sleep time, then check this against the remaining
	time in any other timers that are active. */
	xMaximumSleepTime = ipconfigMAX_IP_TASK_SLEEP_TIME;

	if( xARPTimer.bActive != pdFALSE_UNSIGNED )
 800560e:	783b      	ldrb	r3, [r7, #0]
 8005610:	f013 0f01 	tst.w	r3, #1
 8005614:	d006      	beq.n	8005624 <prvIPTask+0xb8>
	{
		if( xARPTimer.ulRemainingTime < xMaximumSleepTime )
 8005616:	68fa      	ldr	r2, [r7, #12]
 8005618:	f242 730f 	movw	r3, #9999	; 0x270f
 800561c:	429a      	cmp	r2, r3
 800561e:	d804      	bhi.n	800562a <prvIPTask+0xbe>
		{
			xMaximumSleepTime = xARPTimer.ulReloadTime;
 8005620:	693a      	ldr	r2, [r7, #16]
 8005622:	e004      	b.n	800562e <prvIPTask+0xc2>
{
TickType_t xMaximumSleepTime;

	/* Start with the maximum sleep time, then check this against the remaining
	time in any other timers that are active. */
	xMaximumSleepTime = ipconfigMAX_IP_TASK_SLEEP_TIME;
 8005624:	f242 7210 	movw	r2, #10000	; 0x2710
 8005628:	e001      	b.n	800562e <prvIPTask+0xc2>
 800562a:	f242 7210 	movw	r2, #10000	; 0x2710
	}
	#endif /* ipconfigUSE_DHCP */

	#if( ipconfigUSE_TCP == 1 )
	{
		if( xTCPTimer.ulRemainingTime < xMaximumSleepTime )
 800562e:	68e3      	ldr	r3, [r4, #12]
 8005630:	429a      	cmp	r2, r3
 8005632:	bf28      	it	cs
 8005634:	461a      	movcs	r2, r3
	}
	#endif

	#if( ipconfigDNS_USE_CALLBACKS != 0 )
	{
		if( xDNSTimer.bActive != pdFALSE_UNSIGNED )
 8005636:	782b      	ldrb	r3, [r5, #0]
 8005638:	f013 0f01 	tst.w	r3, #1
 800563c:	d003      	beq.n	8005646 <prvIPTask+0xda>
		{
			if( xDNSTimer.ulRemainingTime < xMaximumSleepTime )
 800563e:	68eb      	ldr	r3, [r5, #12]
 8005640:	429a      	cmp	r2, r3
 8005642:	bf28      	it	cs
 8005644:	461a      	movcs	r2, r3
		xNextIPSleep = prvCalculateSleepTime();

		/* Wait until there is something to do. If the following call exits
		 * due to a time out rather than a message being received, set a
		 * 'NoEvent' value. */
		if ( xQueueReceive( xNetworkEventQueue, ( void *) &xReceivedEvent, xNextIPSleep ) == pdFALSE ) 
 8005646:	4b8a      	ldr	r3, [pc, #552]	; (8005870 <prvIPTask+0x304>)
 8005648:	6818      	ldr	r0, [r3, #0]
 800564a:	a904      	add	r1, sp, #16
 800564c:	f7fd f97c 	bl	8002948 <xQueueReceive>
 8005650:	b918      	cbnz	r0, 800565a <prvIPTask+0xee>
		{
			xReceivedEvent.eEventType = eNoEvent;
 8005652:	23ff      	movs	r3, #255	; 0xff
 8005654:	f88d 3010 	strb.w	r3, [sp, #16]
 8005658:	e1b6      	b.n	80059c8 <prvIPTask+0x45c>
		}
		#endif /* ipconfigCHECK_IP_QUEUE_SPACE */

		iptraceNETWORK_EVENT_RECEIVED( xReceivedEvent.eEventType );

		switch( xReceivedEvent.eEventType )
 800565a:	f99d 3010 	ldrsb.w	r3, [sp, #16]
 800565e:	2b0d      	cmp	r3, #13
 8005660:	f200 81b2 	bhi.w	80059c8 <prvIPTask+0x45c>
 8005664:	e8df f013 	tbh	[pc, r3, lsl #1]
 8005668:	0014000e 	.word	0x0014000e
 800566c:	0171016c 	.word	0x0171016c
 8005670:	01b0018f 	.word	0x01b0018f
 8005674:	01a4019f 	.word	0x01a4019f
 8005678:	017401b0 	.word	0x017401b0
 800567c:	0197018b 	.word	0x0197018b
 8005680:	0193019b 	.word	0x0193019b
		{
			case eNetworkDownEvent :
				/* Attempt to establish a connection. */
				xNetworkUp = pdFALSE;
 8005684:	2200      	movs	r2, #0
 8005686:	4b7c      	ldr	r3, [pc, #496]	; (8005878 <prvIPTask+0x30c>)
 8005688:	601a      	str	r2, [r3, #0]
				prvProcessNetworkDownEvent();
 800568a:	f7ff fdf7 	bl	800527c <prvProcessNetworkDownEvent>
				break;
 800568e:	e19b      	b.n	80059c8 <prvIPTask+0x45c>

			case eNetworkRxEvent:
				/* The network hardware driver has received a new packet.  A
				pointer to the received buffer is located in the pvData member
				of the received event structure. */				
				prvHandleEthernetPacket( ipCAST_PTR_TO_TYPE_PTR( NetworkBufferDescriptor_t, xReceivedEvent.pvData ) );
 8005690:	9e05      	ldr	r6, [sp, #20]
static void prvProcessEthernetPacket( NetworkBufferDescriptor_t * const pxNetworkBuffer )
{
const EthernetHeader_t *pxEthernetHeader;
eFrameProcessingResult_t eReturned = eReleaseBuffer;

	configASSERT( pxNetworkBuffer != NULL );
 8005692:	b946      	cbnz	r6, 80056a6 <prvIPTask+0x13a>
 8005694:	f04f 0314 	mov.w	r3, #20
 8005698:	f383 8811 	msr	BASEPRI, r3
 800569c:	f3bf 8f6f 	isb	sy
 80056a0:	f3bf 8f4f 	dsb	sy
 80056a4:	e7fe      	b.n	80056a4 <prvIPTask+0x138>

	/* Interpret the Ethernet frame. */
	if( pxNetworkBuffer->xDataLength >= sizeof( EthernetHeader_t ) )
 80056a6:	69f2      	ldr	r2, [r6, #28]
 80056a8:	2a0d      	cmp	r2, #13
 80056aa:	f240 8145 	bls.w	8005938 <prvIPTask+0x3cc>
	{
		eReturned = ipCONSIDER_FRAME_FOR_PROCESSING( pxNetworkBuffer->pucEthernetBuffer );

		/* Map the buffer onto the Ethernet Header struct for easy access to the fields. */
		pxEthernetHeader = ipCAST_CONST_PTR_TO_CONST_TYPE_PTR( EthernetHeader_t, pxNetworkBuffer->pucEthernetBuffer );
 80056ae:	f8d6 8018 	ldr.w	r8, [r6, #24]
		#if( ipconfigETHERNET_DRIVER_FILTERS_FRAME_TYPES == 0 )
		if( eReturned == eProcessBuffer )
		#endif
		{
			/* Interpret the received Ethernet packet. */
			switch( pxEthernetHeader->usFrameType )
 80056b2:	f8b8 300c 	ldrh.w	r3, [r8, #12]
 80056b6:	2b08      	cmp	r3, #8
 80056b8:	d00a      	beq.n	80056d0 <prvIPTask+0x164>
 80056ba:	f5b3 6fc1 	cmp.w	r3, #1544	; 0x608
 80056be:	f040 812e 	bne.w	800591e <prvIPTask+0x3b2>
			{
			case ipARP_FRAME_TYPE:
				/* The Ethernet frame contains an ARP packet. */
				if( pxNetworkBuffer->xDataLength >= sizeof( ARPPacket_t ) )
 80056c2:	2a29      	cmp	r2, #41	; 0x29
 80056c4:	f240 8138 	bls.w	8005938 <prvIPTask+0x3cc>
				{
					eReturned = eARPProcessPacket( ipCAST_PTR_TO_TYPE_PTR( ARPPacket_t, pxNetworkBuffer->pucEthernetBuffer ) );
 80056c8:	4640      	mov	r0, r8
 80056ca:	f7ff f88d 	bl	80047e8 <eARPProcessPacket>
 80056ce:	e129      	b.n	8005924 <prvIPTask+0x3b8>
				}
				break;

			case ipIPv4_FRAME_TYPE:
				/* The Ethernet frame contains an IP packet. */
				if( pxNetworkBuffer->xDataLength >= sizeof( IPPacket_t ) )
 80056d0:	2a21      	cmp	r2, #33	; 0x21
 80056d2:	f240 8131 	bls.w	8005938 <prvIPTask+0x3cc>

static eFrameProcessingResult_t prvProcessIPPacket( IPPacket_t * pxIPPacket, NetworkBufferDescriptor_t * const pxNetworkBuffer )
{
eFrameProcessingResult_t eReturn;
IPHeader_t * pxIPHeader = &( pxIPPacket->xIPHeader );
size_t uxLength = ( size_t ) pxIPHeader->ucVersionHeaderLength;
 80056d6:	f898 300e 	ldrb.w	r3, [r8, #14]
UBaseType_t uxHeaderLength = ( UBaseType_t ) ( ( uxLength & 0x0FU ) << 2 );
 80056da:	f003 0e0f 	and.w	lr, r3, #15
 80056de:	ea4f 018e 	mov.w	r1, lr, lsl #2
uint8_t ucProtocol;

	/* Bound the calculated header length: take away the Ethernet header size,
	then check if the IP header is claiming to be longer than the remaining
	total packet size. Also check for minimal header field length. */
	if( ( uxHeaderLength > ( pxNetworkBuffer->xDataLength - ipSIZE_OF_ETH_HEADER ) ) ||
 80056e2:	f1a2 000e 	sub.w	r0, r2, #14
 80056e6:	4281      	cmp	r1, r0
 80056e8:	f200 8126 	bhi.w	8005938 <prvIPTask+0x3cc>
 80056ec:	2913      	cmp	r1, #19
 80056ee:	f240 8123 	bls.w	8005938 <prvIPTask+0x3cc>
	{
		eReturn = eReleaseBuffer;
	}
	else
	{
		ucProtocol = pxIPPacket->xIPHeader.ucProtocol;
 80056f2:	f898 9017 	ldrb.w	r9, [r8, #23]
	#if( ipconfigETHERNET_DRIVER_FILTERS_PACKETS == 0 )
	{
		/* In systems with a very small amount of RAM, it might be advantageous
		to have incoming messages checked earlier, by the network card driver.
		This method may decrease the usage of sparse network buffers. */
		uint32_t ulDestinationIPAddress = pxIPHeader->ulDestinationIPAddress;
 80056f6:	f8d8 c01e 	ldr.w	ip, [r8, #30]

			/* Ensure that the incoming packet is not fragmented (only outgoing
			packets can be fragmented) as these are the only handled IP frames
			currently. */
			if( ( pxIPHeader->usFragmentOffset & ipFRAGMENT_OFFSET_BIT_MASK ) != 0U )
 80056fa:	f8b8 0014 	ldrh.w	r0, [r8, #20]
 80056fe:	f020 00f0 	bic.w	r0, r0, #240	; 0xf0
 8005702:	b280      	uxth	r0, r0
 8005704:	2800      	cmp	r0, #0
 8005706:	f040 816e 	bne.w	80059e6 <prvIPTask+0x47a>
				/* Can not handle, fragmented packet. */
				eReturn = eReleaseBuffer;
			}
			/* Test if the length of the IP-header is between 20 and 60 bytes,
			and if the IP-version is 4. */
			else if( ( pxIPHeader->ucVersionHeaderLength < ipIPV4_VERSION_HEADER_LENGTH_MIN ) ||
 800570a:	f1a3 0045 	sub.w	r0, r3, #69	; 0x45
 800570e:	b2c0      	uxtb	r0, r0
 8005710:	280a      	cmp	r0, #10
 8005712:	f200 816a 	bhi.w	80059ea <prvIPTask+0x47e>
			{
				/* Can not handle, unknown or invalid header version. */
				eReturn = eReleaseBuffer;
			}
				/* Is the packet for this IP address? */
			else if( ( ulDestinationIPAddress != *ipLOCAL_IP_ADDRESS_POINTER ) &&
 8005716:	4859      	ldr	r0, [pc, #356]	; (800587c <prvIPTask+0x310>)
 8005718:	6940      	ldr	r0, [r0, #20]
 800571a:	4584      	cmp	ip, r0
 800571c:	d00e      	beq.n	800573c <prvIPTask+0x1d0>
 800571e:	f1bc 3fff 	cmp.w	ip, #4294967295
 8005722:	d00b      	beq.n	800573c <prvIPTask+0x1d0>
				/* Is it the global broadcast address 255.255.255.255 ? */
				( ulDestinationIPAddress != ipBROADCAST_IP_ADDRESS ) &&
				/* Is it a specific broadcast address 192.168.1.255 ? */
				( ulDestinationIPAddress != xNetworkAddressing.ulBroadcastAddress ) &&
 8005724:	f8df b158 	ldr.w	fp, [pc, #344]	; 8005880 <prvIPTask+0x314>
				eReturn = eReleaseBuffer;
			}
				/* Is the packet for this IP address? */
			else if( ( ulDestinationIPAddress != *ipLOCAL_IP_ADDRESS_POINTER ) &&
				/* Is it the global broadcast address 255.255.255.255 ? */
				( ulDestinationIPAddress != ipBROADCAST_IP_ADDRESS ) &&
 8005728:	f8db b010 	ldr.w	fp, [fp, #16]
 800572c:	45dc      	cmp	ip, fp
 800572e:	d005      	beq.n	800573c <prvIPTask+0x1d0>
			packets can be fragmented) as these are the only handled IP frames
			currently. */
			if( ( pxIPHeader->usFragmentOffset & ipFRAGMENT_OFFSET_BIT_MASK ) != 0U )
			{
				/* Can not handle, fragmented packet. */
				eReturn = eReleaseBuffer;
 8005730:	fab0 f080 	clz	r0, r0
 8005734:	0940      	lsrs	r0, r0, #5
		}
	}
	#else
	{

		if (eReturn == eProcessBuffer )
 8005736:	2800      	cmp	r0, #0
 8005738:	f000 80f4 	beq.w	8005924 <prvIPTask+0x3b8>
			pxIPPacket = ipCAST_CONST_PTR_TO_CONST_TYPE_PTR( IPPacket_t, pucEthernetBuffer );

			ucVersionHeaderLength = pxIPPacket->xIPHeader.ucVersionHeaderLength;
			/* Test if the length of the IP-header is between 20 and 60 bytes,
			and if the IP-version is 4. */
			if( ( ucVersionHeaderLength < ipIPV4_VERSION_HEADER_LENGTH_MIN ) ||
 800573c:	3b45      	subs	r3, #69	; 0x45
 800573e:	b29b      	uxth	r3, r3
 8005740:	2b0a      	cmp	r3, #10
 8005742:	f200 8154 	bhi.w	80059ee <prvIPTask+0x482>
			{
				xLocation = 2;
				break;
			}
			ucVersionHeaderLength = ( ucVersionHeaderLength & ( uint8_t ) 0x0FU ) << 2;
			uxIPHeaderLength = ( UBaseType_t ) ucVersionHeaderLength;
 8005746:	ea4f 038e 	mov.w	r3, lr, lsl #2

			/* Check if the complete IP-header is transferred. */
			if( uxBufferLength < ( ipSIZE_OF_ETH_HEADER + uxIPHeaderLength ) )
 800574a:	f103 000e 	add.w	r0, r3, #14
 800574e:	4282      	cmp	r2, r0
 8005750:	f0c0 814f 	bcc.w	80059f2 <prvIPTask+0x486>
			{
				xLocation = 3;
				break;
			}
			/* Check if the complete IP-header plus protocol data have been transferred: */
			usLength = pxIPPacket->xIPHeader.usLength;
 8005754:	f8b8 e010 	ldrh.w	lr, [r8, #16]
			usLength = FreeRTOS_ntohs( usLength );
 8005758:	ea4f 201e 	mov.w	r0, lr, lsr #8
 800575c:	ea40 200e 	orr.w	r0, r0, lr, lsl #8
			if( uxBufferLength < ( size_t ) ( ipSIZE_OF_ETH_HEADER + ( size_t ) usLength ) )
 8005760:	b280      	uxth	r0, r0
 8005762:	f100 0e0e 	add.w	lr, r0, #14
 8005766:	4572      	cmp	r2, lr
 8005768:	f0c0 8145 	bcc.w	80059f6 <prvIPTask+0x48a>
			/* Map the Buffer onto the Protocol Packet struct for easy access to the
			 * struct fields. */
			pxProtPack = ipCAST_CONST_PTR_TO_CONST_TYPE_PTR( ProtocolPacket_t, &( pucEthernetBuffer[ uxIPHeaderLength - ipSIZE_OF_IPv4_HEADER ] ) );

			/* Switch on the Layer 3/4 protocol. */
			if( ucProtocol == ( uint8_t ) ipPROTOCOL_UDP )
 800576c:	f1b9 0f11 	cmp.w	r9, #17
 8005770:	d102      	bne.n	8005778 <prvIPTask+0x20c>
			{
				/* Expect at least a complete UDP header. */
				uxMinimumLength = uxIPHeaderLength + ipSIZE_OF_ETH_HEADER + ipSIZE_OF_UDP_HEADER;
 8005772:	f103 0e16 	add.w	lr, r3, #22
 8005776:	e00f      	b.n	8005798 <prvIPTask+0x22c>
			}
			else if( ucProtocol == ( uint8_t ) ipPROTOCOL_TCP )
 8005778:	f1b9 0f06 	cmp.w	r9, #6
 800577c:	d102      	bne.n	8005784 <prvIPTask+0x218>
			{
				uxMinimumLength = uxIPHeaderLength + ipSIZE_OF_ETH_HEADER + ipSIZE_OF_TCP_HEADER;
 800577e:	f103 0e22 	add.w	lr, r3, #34	; 0x22
 8005782:	e009      	b.n	8005798 <prvIPTask+0x22c>
			}
			else if( ( ucProtocol == ( uint8_t ) ipPROTOCOL_ICMP ) ||
 8005784:	f109 3eff 	add.w	lr, r9, #4294967295
 8005788:	fa5f fe8e 	uxtb.w	lr, lr
 800578c:	f1be 0f01 	cmp.w	lr, #1
 8005790:	f200 8133 	bhi.w	80059fa <prvIPTask+0x48e>
					 ( ucProtocol == ( uint8_t ) ipPROTOCOL_IGMP ) )
			{
				uxMinimumLength = uxIPHeaderLength + ipSIZE_OF_ETH_HEADER + ipSIZE_OF_ICMP_HEADER;
 8005794:	f103 0e16 	add.w	lr, r3, #22
			{
				/* Unhandled protocol, other than ICMP, IGMP, UDP, or TCP. */
				xLocation = 5;
				break;
			}
			if( uxBufferLength < uxMinimumLength )
 8005798:	4572      	cmp	r2, lr
 800579a:	f0c0 8130 	bcc.w	80059fe <prvIPTask+0x492>
				xLocation = 6;
				break;
			}

			uxLength = ( size_t ) usLength;
			uxLength -= ( ( uint16_t ) uxIPHeaderLength ); /* normally, minus 20. */
 800579e:	1ac0      	subs	r0, r0, r3

			if( ( uxLength < ( ( size_t ) sizeof( pxProtPack->xUDPPacket.xUDPHeader ) ) ) ||
 80057a0:	2807      	cmp	r0, #7
 80057a2:	f240 812e 	bls.w	8005a02 <prvIPTask+0x496>
				( uxLength > ( ( size_t ) ipconfigNETWORK_MTU - ( size_t ) uxIPHeaderLength ) ) )
 80057a6:	f5c3 6396 	rsb	r3, r3, #1200	; 0x4b0
	#else
	{

		if (eReturn == eProcessBuffer )
		{
			if( xCheckSizeFields( ( uint8_t * )( pxNetworkBuffer->pucEthernetBuffer ), pxNetworkBuffer->xDataLength ) != pdPASS )
 80057aa:	4298      	cmp	r0, r3
 80057ac:	f200 80c4 	bhi.w	8005938 <prvIPTask+0x3cc>
				/* ipconfigUDP_PASS_ZERO_CHECKSUM_PACKETS is defined as 0,
				and so UDP packets carrying a protocol checksum of 0, will
				be dropped. */

				/* Identify the next protocol. */
				if( pxIPPacket->xIPHeader.ucProtocol == ( uint8_t ) ipPROTOCOL_UDP )
 80057b0:	f1b9 0f11 	cmp.w	r9, #17
 80057b4:	d105      	bne.n	80057c2 <prvIPTask+0x256>
				const uint16_t *pusChecksum;

					/* pxProtPack will point to the offset were the protocols begin. */
					pxProtPack = ipCAST_PTR_TO_TYPE_PTR( ProtocolPacket_t, &( pxNetworkBuffer->pucEthernetBuffer[ uxHeaderLength - ipSIZE_OF_IPv4_HEADER ] ) );
					pusChecksum = ( const uint16_t * ) ( &( pxProtPack->xUDPPacket.xUDPHeader.usChecksum ) );
					if( *pusChecksum == ( uint16_t ) 0U )
 80057b6:	eb08 0301 	add.w	r3, r8, r1
 80057ba:	8a9b      	ldrh	r3, [r3, #20]
 80057bc:	2b00      	cmp	r3, #0
 80057be:	f000 810b 	beq.w	80059d8 <prvIPTask+0x46c>
		eReturn = prvAllowIPPacket( pxIPPacket, pxNetworkBuffer, uxHeaderLength );

		if( eReturn == eProcessBuffer )
		{
			/* Are there IP-options. */
			if( uxHeaderLength > ipSIZE_OF_IPv4_HEADER )
 80057c2:	2914      	cmp	r1, #20
 80057c4:	f240 810a 	bls.w	80059dc <prvIPTask+0x470>
				The extra space is used for IP-options. */
				#if( ipconfigIP_PASS_PACKETS_WITH_IP_OPTIONS != 0 )
				{
					/* All structs of headers expect a IP header size of 20 bytes
					 * IP header options were included, we'll ignore them and cut them out. */
					const size_t optlen = ( ( size_t ) uxHeaderLength ) - ipSIZE_OF_IPv4_HEADER;
 80057c8:	f1a1 0b14 	sub.w	fp, r1, #20
					/* From: the previous start of UDP/ICMP/TCP data. */
					const uint8_t *pucSource = ( const uint8_t * ) &( pxNetworkBuffer->pucEthernetBuffer[ sizeof( EthernetHeader_t ) + uxHeaderLength ] );
 80057cc:	310e      	adds	r1, #14
 80057ce:	3a22      	subs	r2, #34	; 0x22
					/* To: the usual start of UDP/ICMP/TCP data at offset 20 (decimal ) from IP header. */
					uint8_t *pucTarget = ( uint8_t * ) &( pxNetworkBuffer->pucEthernetBuffer[ sizeof( EthernetHeader_t ) + ipSIZE_OF_IPv4_HEADER ] );
					/* How many: total length minus the options and the lower headers. */
					const size_t  xMoveLen = pxNetworkBuffer->xDataLength - ( optlen + ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_ETH_HEADER );

					( void ) memmove( pucTarget, pucSource, xMoveLen );
 80057d0:	f108 0022 	add.w	r0, r8, #34	; 0x22
 80057d4:	4441      	add	r1, r8
 80057d6:	ebcb 0202 	rsb	r2, fp, r2
 80057da:	f004 fb91 	bl	8009f00 <memmove>
					pxNetworkBuffer->xDataLength -= optlen;
 80057de:	69f3      	ldr	r3, [r6, #28]
 80057e0:	ebcb 0303 	rsb	r3, fp, r3
 80057e4:	61f3      	str	r3, [r6, #28]

					/* Rewrite the Version/IHL byte to indicate that this packet has no IP options. */
					pxIPHeader->ucVersionHeaderLength = ( pxIPHeader->ucVersionHeaderLength & 0xF0U ) | /* High nibble is the version. */
 80057e6:	f898 300e 	ldrb.w	r3, [r8, #14]
 80057ea:	f023 030f 	bic.w	r3, r3, #15
 80057ee:	f043 0305 	orr.w	r3, r3, #5
 80057f2:	f888 300e 	strb.w	r3, [r8, #14]
 80057f6:	e0f1      	b.n	80059dc <prvIPTask+0x470>
					/* Refresh the ARP cache with the IP/MAC-address of the received
					packet. For UDP packets, this will be done later in
					xProcessReceivedUDPPacket(), as soon as it's know that the message
					will be handled.  This will prevent the ARP cache getting
					overwritten with the IP address of useless broadcast packets. */
					vARPRefreshCacheEntry( &( pxIPPacket->xEthernetHeader.xSourceAddress ), pxIPHeader->ulSourceIPAddress );
 80057f8:	f108 0006 	add.w	r0, r8, #6
 80057fc:	f8d8 101a 	ldr.w	r1, [r8, #26]
 8005800:	f7fe ff58 	bl	80046b4 <vARPRefreshCacheEntry>
				}
				switch( ucProtocol )
 8005804:	f1b9 0f06 	cmp.w	r9, #6
 8005808:	d07d      	beq.n	8005906 <prvIPTask+0x39a>
 800580a:	f1b9 0f11 	cmp.w	r9, #17
 800580e:	d05c      	beq.n	80058ca <prvIPTask+0x35e>
 8005810:	f1b9 0f01 	cmp.w	r9, #1
 8005814:	f040 8090 	bne.w	8005938 <prvIPTask+0x3cc>
						also be returned, and the source of the ping will know something
						went wrong because it will not be able to validate what it
						receives. */
						#if ( ipconfigREPLY_TO_INCOMING_PINGS == 1 ) || ( ipconfigSUPPORT_OUTGOING_PINGS == 1 )
						{
							if( pxNetworkBuffer->xDataLength >= sizeof( ICMPPacket_t ) )
 8005818:	69f3      	ldr	r3, [r6, #28]
 800581a:	2b29      	cmp	r3, #41	; 0x29
 800581c:	f240 808c 	bls.w	8005938 <prvIPTask+0x3cc>
							{
								/* Map the buffer onto a ICMP-Packet struct to easily access the
								 * fields of ICMP packet. */
								ICMPPacket_t *pxICMPPacket = ipCAST_PTR_TO_TYPE_PTR( ICMPPacket_t, pxNetworkBuffer->pucEthernetBuffer );
 8005820:	69b2      	ldr	r2, [r6, #24]
								if( pxIPHeader->ulDestinationIPAddress == *ipLOCAL_IP_ADDRESS_POINTER )
 8005822:	f8d8 301e 	ldr.w	r3, [r8, #30]
 8005826:	4915      	ldr	r1, [pc, #84]	; (800587c <prvIPTask+0x310>)
 8005828:	6949      	ldr	r1, [r1, #20]
 800582a:	428b      	cmp	r3, r1
 800582c:	f040 8084 	bne.w	8005938 <prvIPTask+0x3cc>
	static eFrameProcessingResult_t prvProcessICMPPacket( ICMPPacket_t * const pxICMPPacket )
	{
	eFrameProcessingResult_t eReturn = eReleaseBuffer;

		iptraceICMP_PACKET_RECEIVED();
		switch( pxICMPPacket->xICMPHeader.ucTypeOfMessage )
 8005830:	f892 1022 	ldrb.w	r1, [r2, #34]	; 0x22
 8005834:	b331      	cbz	r1, 8005884 <prvIPTask+0x318>
 8005836:	2908      	cmp	r1, #8
 8005838:	d173      	bne.n	8005922 <prvIPTask+0x3b6>

		/* The checksum can be checked here - but a ping reply should be
		returned even if the checksum is incorrect so the other end can
		tell that the ping was received - even if the ping reply contains
		invalid data. */
		pxICMPHeader->ucTypeOfMessage = ( uint8_t ) ipICMP_ECHO_REPLY;
 800583a:	2100      	movs	r1, #0
 800583c:	f882 1022 	strb.w	r1, [r2, #34]	; 0x22
		pxIPHeader->ulDestinationIPAddress = pxIPHeader->ulSourceIPAddress;
 8005840:	f8d2 101a 	ldr.w	r1, [r2, #26]
 8005844:	f8c2 101e 	str.w	r1, [r2, #30]
		pxIPHeader->ulSourceIPAddress = *ipLOCAL_IP_ADDRESS_POINTER;
 8005848:	f8c2 301a 	str.w	r3, [r2, #26]

		/* due to compiler warning "integer operation result is out of range" */

		usRequest = ( uint16_t ) ( ( uint16_t )ipICMP_ECHO_REQUEST << 8 );

		if( pxICMPHeader->usChecksum >= FreeRTOS_htons( 0xFFFFU - usRequest ) )
 800584c:	8c93      	ldrh	r3, [r2, #36]	; 0x24
 800584e:	f64f 71f6 	movw	r1, #65526	; 0xfff6
 8005852:	428b      	cmp	r3, r1
		{
			pxICMPHeader->usChecksum = pxICMPHeader->usChecksum + FreeRTOS_htons( usRequest + 1U );
 8005854:	bf8c      	ite	hi
 8005856:	f503 7384 	addhi.w	r3, r3, #264	; 0x108
		}
		else
		{
			pxICMPHeader->usChecksum = pxICMPHeader->usChecksum + FreeRTOS_htons( usRequest );
 800585a:	3308      	addls	r3, #8
 800585c:	8493      	strh	r3, [r2, #36]	; 0x24
 800585e:	e066      	b.n	800592e <prvIPTask+0x3c2>
 8005860:	2000d3a4 	.word	0x2000d3a4
 8005864:	2000d39c 	.word	0x2000d39c
 8005868:	2000d388 	.word	0x2000d388
 800586c:	2000d340 	.word	0x2000d340
 8005870:	2000d368 	.word	0x2000d368
 8005874:	2000d3c0 	.word	0x2000d3c0
 8005878:	2000d384 	.word	0x2000d384
 800587c:	2000d5c0 	.word	0x2000d5c0
 8005880:	2000d36c 	.word	0x2000d36c
	ePingReplyStatus_t eStatus = eSuccess;
	uint16_t usDataLength, usCount;
	uint8_t *pucByte;

		/* Find the total length of the IP packet. */
		usDataLength = pxICMPPacket->xIPHeader.usLength;
 8005884:	8a11      	ldrh	r1, [r2, #16]
		usDataLength = FreeRTOS_ntohs( usDataLength );
 8005886:	0a0b      	lsrs	r3, r1, #8
 8005888:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 800588c:	b29b      	uxth	r3, r3

		/* Checksum has already been checked before in prvProcessIPPacket */

		/* Find the first byte of the data within the ICMP packet. */
		pucByte = ( uint8_t * ) pxICMPPacket;
		pucByte = &( pucByte[ sizeof( ICMPPacket_t ) ] );
 800588e:	f102 012a 	add.w	r1, r2, #42	; 0x2a

		/* Check each byte. */
		for( usCount = 0; usCount < usDataLength; usCount++ )
 8005892:	2b1c      	cmp	r3, #28
 8005894:	d010      	beq.n	80058b8 <prvIPTask+0x34c>
		{
			if( *pucByte != ( uint8_t ) ipECHO_DATA_FILL_BYTE )
 8005896:	f892 002a 	ldrb.w	r0, [r2, #42]	; 0x2a
 800589a:	2878      	cmp	r0, #120	; 0x78
 800589c:	d10e      	bne.n	80058bc <prvIPTask+0x350>
 800589e:	3b1d      	subs	r3, #29
 80058a0:	b29b      	uxth	r3, r3
 80058a2:	332a      	adds	r3, #42	; 0x2a
 80058a4:	4413      	add	r3, r2
 80058a6:	e003      	b.n	80058b0 <prvIPTask+0x344>
 80058a8:	f811 0f01 	ldrb.w	r0, [r1, #1]!
 80058ac:	2878      	cmp	r0, #120	; 0x78
 80058ae:	d107      	bne.n	80058c0 <prvIPTask+0x354>
		/* Find the first byte of the data within the ICMP packet. */
		pucByte = ( uint8_t * ) pxICMPPacket;
		pucByte = &( pucByte[ sizeof( ICMPPacket_t ) ] );

		/* Check each byte. */
		for( usCount = 0; usCount < usDataLength; usCount++ )
 80058b0:	4299      	cmp	r1, r3
 80058b2:	d1f9      	bne.n	80058a8 <prvIPTask+0x33c>

#if ( ipconfigSUPPORT_OUTGOING_PINGS == 1 )

	static void prvProcessICMPEchoReply( ICMPPacket_t * const pxICMPPacket )
	{
	ePingReplyStatus_t eStatus = eSuccess;
 80058b4:	2000      	movs	r0, #0
 80058b6:	e004      	b.n	80058c2 <prvIPTask+0x356>
 80058b8:	2000      	movs	r0, #0
 80058ba:	e002      	b.n	80058c2 <prvIPTask+0x356>
		/* Check each byte. */
		for( usCount = 0; usCount < usDataLength; usCount++ )
		{
			if( *pucByte != ( uint8_t ) ipECHO_DATA_FILL_BYTE )
			{
				eStatus = eInvalidData;
 80058bc:	2002      	movs	r0, #2
 80058be:	e000      	b.n	80058c2 <prvIPTask+0x356>
 80058c0:	2002      	movs	r0, #2

			pucByte++;
		}

		/* Call back into the application to pass it the result. */
		vApplicationPingReplyHook( eStatus, pxICMPPacket->xICMPHeader.usIdentifier );
 80058c2:	8cd1      	ldrh	r1, [r2, #38]	; 0x26
 80058c4:	f7fe fe0c 	bl	80044e0 <vApplicationPingReplyHook>
 80058c8:	e036      	b.n	8005938 <prvIPTask+0x3cc>
						{
						/* The IP packet contained a UDP frame. */

						/* Map the buffer onto a UDP-Packet struct to easily access the
						 * fields of UDP packet. */
						const UDPPacket_t *pxUDPPacket = ipCAST_CONST_PTR_TO_CONST_TYPE_PTR( UDPPacket_t, pxNetworkBuffer->pucEthernetBuffer );
 80058ca:	69b1      	ldr	r1, [r6, #24]
						uint16_t usLength;

							/* Note the header values required prior to the checksum
							generation as the checksum pseudo header may clobber some of
							these values. */
							usLength = FreeRTOS_ntohs( pxUDPPacket->xUDPHeader.usLength  );
 80058cc:	8cca      	ldrh	r2, [r1, #38]	; 0x26
 80058ce:	0a13      	lsrs	r3, r2, #8
 80058d0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80058d4:	b29b      	uxth	r3, r3
							if ( ( pxNetworkBuffer->xDataLength >= sizeof( UDPPacket_t ) ) &&
 80058d6:	69f2      	ldr	r2, [r6, #28]
 80058d8:	2a29      	cmp	r2, #41	; 0x29
 80058da:	d92d      	bls.n	8005938 <prvIPTask+0x3cc>
 80058dc:	2b07      	cmp	r3, #7
 80058de:	d92b      	bls.n	8005938 <prvIPTask+0x3cc>
								size of the UDP header.

								The size of the UDP packet structure in this implementation
								includes the size of the Ethernet header, the size of
								the IP header, and the size of the UDP header. */
								uxPayloadSize_1 = pxNetworkBuffer->xDataLength - sizeof( UDPPacket_t );
 80058e0:	3a2a      	subs	r2, #42	; 0x2a
								uxPayloadSize_2 = ( ( size_t ) usLength ) - sizeof( UDPHeader_t );
 80058e2:	f1a3 0008 	sub.w	r0, r3, #8
								if( uxPayloadSize_1 > uxPayloadSize_2 )
 80058e6:	4282      	cmp	r2, r0
								{
									pxNetworkBuffer->xDataLength = uxPayloadSize_2 + sizeof( UDPPacket_t );
 80058e8:	bf84      	itt	hi
 80058ea:	3322      	addhi	r3, #34	; 0x22
 80058ec:	61f3      	strhi	r3, [r6, #28]
								}

								/* Fields in pxNetworkBuffer (usPort, ulIPAddress) are network order. */
								pxNetworkBuffer->usPort = pxUDPPacket->xUDPHeader.usSourcePort;
 80058ee:	8c4b      	ldrh	r3, [r1, #34]	; 0x22
 80058f0:	8433      	strh	r3, [r6, #32]
								pxNetworkBuffer->ulIPAddress = pxUDPPacket->xIPHeader.ulSourceIPAddress;
 80058f2:	f8d1 301a 	ldr.w	r3, [r1, #26]
 80058f6:	6173      	str	r3, [r6, #20]
								In some cases, the upper-layer checksum has been calculated
								by the NIC driver. */

								/* Pass the packet payload to the UDP sockets
								implementation. */
								if( xProcessReceivedUDPPacket( pxNetworkBuffer,
 80058f8:	4630      	mov	r0, r6
 80058fa:	8c89      	ldrh	r1, [r1, #36]	; 0x24
 80058fc:	f003 fd84 	bl	8009408 <xProcessReceivedUDPPacket>
 8005900:	2801      	cmp	r0, #1
 8005902:	d119      	bne.n	8005938 <prvIPTask+0x3cc>
 8005904:	e060      	b.n	80059c8 <prvIPTask+0x45c>

#if ipconfigUSE_TCP == 1
					case ipPROTOCOL_TCP :
						{

							if( xProcessReceivedTCPPacket( pxNetworkBuffer ) == pdPASS )
 8005906:	4630      	mov	r0, r6
 8005908:	f002 fb00 	bl	8007f0c <xProcessReceivedTCPPacket>
							{
								eReturn = eFrameConsumed;
 800590c:	2801      	cmp	r0, #1
 800590e:	bf14      	ite	ne
 8005910:	2001      	movne	r0, #1
 8005912:	2003      	moveq	r0, #3
							}

							/* Setting this variable will cause xTCPTimerCheck()
							to be called just before the IP-task blocks. */
							xProcessedTCPMessage++;
 8005914:	4a3c      	ldr	r2, [pc, #240]	; (8005a08 <prvIPTask+0x49c>)
 8005916:	6813      	ldr	r3, [r2, #0]
 8005918:	3301      	adds	r3, #1
 800591a:	6013      	str	r3, [r2, #0]
 800591c:	e002      	b.n	8005924 <prvIPTask+0x3b8>
				}
				break;

			default:
				/* No other packet types are handled.  Nothing to do. */
				eReturned = eReleaseBuffer;
 800591e:	2000      	movs	r0, #0
 8005920:	e000      	b.n	8005924 <prvIPTask+0x3b8>

#if ( ipconfigREPLY_TO_INCOMING_PINGS == 1 ) || ( ipconfigSUPPORT_OUTGOING_PINGS == 1 )

	static eFrameProcessingResult_t prvProcessICMPPacket( ICMPPacket_t * const pxICMPPacket )
	{
	eFrameProcessingResult_t eReturn = eReleaseBuffer;
 8005922:	2000      	movs	r0, #0
			}
		}
	}

	/* Perform any actions that resulted from processing the Ethernet frame. */
	switch( eReturned )
 8005924:	2802      	cmp	r0, #2
 8005926:	d002      	beq.n	800592e <prvIPTask+0x3c2>
 8005928:	2803      	cmp	r0, #3
 800592a:	d04d      	beq.n	80059c8 <prvIPTask+0x45c>
 800592c:	e004      	b.n	8005938 <prvIPTask+0x3cc>
	{
		case eReturnEthernetFrame :
			/* The Ethernet frame will have been updated (maybe it was
			an ARP request or a PING request?) and should be sent back to
			its source. */
			vReturnEthernetFrame( pxNetworkBuffer, pdTRUE );
 800592e:	4630      	mov	r0, r6
 8005930:	2101      	movs	r1, #1
 8005932:	f7ff fe05 	bl	8005540 <vReturnEthernetFrame>
 8005936:	e047      	b.n	80059c8 <prvIPTask+0x45c>
		case eProcessBuffer :
		default :
			/* The frame is not being used anywhere, and the
			NetworkBufferDescriptor_t structure containing the frame should
			just be	released back to the list of free buffers. */
			vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 8005938:	4630      	mov	r0, r6
 800593a:	f7fe fe49 	bl	80045d0 <vReleaseNetworkBufferAndDescriptor>
 800593e:	e043      	b.n	80059c8 <prvIPTask+0x45c>
				break;

			case eNetworkTxEvent:
				/* Send a network packet. The ownership will  be transferred to
				the driver, which will release it after delivery. */
				( void ) xNetworkInterfaceOutput( ipCAST_PTR_TO_TYPE_PTR( NetworkBufferDescriptor_t, xReceivedEvent.pvData ), pdTRUE );
 8005940:	9805      	ldr	r0, [sp, #20]
 8005942:	2101      	movs	r1, #1
 8005944:	f7fe fc8e 	bl	8004264 <xNetworkInterfaceOutput>
				break;
 8005948:	e03e      	b.n	80059c8 <prvIPTask+0x45c>

			case eARPTimerEvent :
				/* The ARP timer has expired, process the ARP cache. */
				vARPAgeCache();
 800594a:	f7ff f875 	bl	8004a38 <vARPAgeCache>
				break;
 800594e:	e03b      	b.n	80059c8 <prvIPTask+0x45c>
				/* FreeRTOS_bind (a user API) wants the IP-task to bind a socket
				to a port. The port number is communicated in the socket field
				usLocalPort. vSocketBind() will actually bind the socket and the
				API will unblock as soon as the eSOCKET_BOUND event is
				triggered. */
				pxSocket = ipCAST_PTR_TO_TYPE_PTR( FreeRTOS_Socket_t, xReceivedEvent.pvData );
 8005950:	9e05      	ldr	r6, [sp, #20]
				xAddress.sin_addr = 0U;	/* For the moment. */
 8005952:	2300      	movs	r3, #0
 8005954:	9303      	str	r3, [sp, #12]
				xAddress.sin_port = FreeRTOS_ntohs( pxSocket->usLocalPort );
 8005956:	8cb1      	ldrh	r1, [r6, #36]	; 0x24
 8005958:	0a0a      	lsrs	r2, r1, #8
 800595a:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 800595e:	f8ad 200a 	strh.w	r2, [sp, #10]
				pxSocket->usLocalPort = 0U;
 8005962:	84b3      	strh	r3, [r6, #36]	; 0x24
				( void ) vSocketBind( pxSocket, &xAddress, sizeof( xAddress ), pdFALSE );
 8005964:	4630      	mov	r0, r6
 8005966:	a902      	add	r1, sp, #8
 8005968:	2208      	movs	r2, #8
 800596a:	f000 fbc9 	bl	8006100 <vSocketBind>

				/* Before 'eSocketBindEvent' was sent it was tested that
				( xEventGroup != NULL ) so it can be used now to wake up the
				user. */
				pxSocket->xEventBits |= ( EventBits_t ) eSOCKET_BOUND;
 800596e:	6833      	ldr	r3, [r6, #0]
 8005970:	f043 0310 	orr.w	r3, r3, #16
 8005974:	6033      	str	r3, [r6, #0]
				vSocketWakeUpUser( pxSocket );
 8005976:	4630      	mov	r0, r6
 8005978:	f000 fdca 	bl	8006510 <vSocketWakeUpUser>
				break;
 800597c:	e024      	b.n	80059c8 <prvIPTask+0x45c>
			case eSocketCloseEvent :
				/* The user API FreeRTOS_closesocket() has sent a message to the
				IP-task to actually close a socket. This is handled in
				vSocketClose().  As the socket gets closed, there is no way to
				report back to the API, so the API won't wait for the result */
				( void ) vSocketClose( ipCAST_PTR_TO_TYPE_PTR( FreeRTOS_Socket_t, xReceivedEvent.pvData ) );
 800597e:	9805      	ldr	r0, [sp, #20]
 8005980:	f000 fc76 	bl	8006270 <vSocketClose>
				break;
 8005984:	e020      	b.n	80059c8 <prvIPTask+0x45c>

			case eStackTxEvent :
				/* The network stack has generated a packet to send.  A
				pointer to the generated buffer is located in the pvData
				member of the received event structure. */
				vProcessGeneratedUDPPacket( ipCAST_PTR_TO_TYPE_PTR( NetworkBufferDescriptor_t, xReceivedEvent.pvData ) );
 8005986:	9805      	ldr	r0, [sp, #20]
 8005988:	f003 fcc2 	bl	8009310 <vProcessGeneratedUDPPacket>
				break;
 800598c:	e01c      	b.n	80059c8 <prvIPTask+0x45c>

			case eStackRAWTxEvent:
				/* The network stack for raw packets has generated a packet to send.
				A pointer to the generated buffer is located in the pvData
				member of the received event structure. */
				vProcessGeneratedRAWPacket( ipCAST_PTR_TO_TYPE_PTR( NetworkBufferDescriptor_t, xReceivedEvent.pvData ) );
 800598e:	9805      	ldr	r0, [sp, #20]
 8005990:	f000 f85a 	bl	8005a48 <vProcessGeneratedRAWPacket>
				break;
 8005994:	e018      	b.n	80059c8 <prvIPTask+0x45c>
						vSocketSelect( pxMessage->pxSocketSet );
						( void ) xTaskNotifyGive( pxMessage->xTaskhandle );
					}
					#else
					{						
						vSocketSelect( ipCAST_PTR_TO_TYPE_PTR( SocketSelect_t, xReceivedEvent.pvData ) );
 8005996:	9805      	ldr	r0, [sp, #20]
 8005998:	f001 fb18 	bl	8006fcc <vSocketSelect>
					}
					#endif	/* ( ipconfigSELECT_USES_NOTIFY != 0 ) */
				}
				#endif /* ipconfigSUPPORT_SELECT_FUNCTION == 1 */
				break;
 800599c:	e014      	b.n	80059c8 <prvIPTask+0x45c>
			case eSocketSignalEvent :
				#if( ipconfigSUPPORT_SIGNALS != 0 )
				{
					/* Some task wants to signal the user of this socket in
					order to interrupt a call to recv() or a call to select(). */
					( void ) FreeRTOS_SignalSocket( ipPOINTER_CAST( Socket_t, xReceivedEvent.pvData ) );
 800599e:	9805      	ldr	r0, [sp, #20]
 80059a0:	f001 fbe4 	bl	800716c <FreeRTOS_SignalSocket>
				}
				#endif /* ipconfigSUPPORT_SIGNALS */
				break;
 80059a4:	e010      	b.n	80059c8 <prvIPTask+0x45c>
			case eTCPTimerEvent :
				#if( ipconfigUSE_TCP == 1 )
				{
					/* Simply mark the TCP timer as expired so it gets processed
					the next time prvCheckNetworkTimers() is called. */
					xTCPTimer.bExpired = pdTRUE_UNSIGNED;
 80059a6:	7823      	ldrb	r3, [r4, #0]
 80059a8:	f043 0302 	orr.w	r3, r3, #2
 80059ac:	7023      	strb	r3, [r4, #0]
				}
				#endif /* ipconfigUSE_TCP */
				break;
 80059ae:	e00b      	b.n	80059c8 <prvIPTask+0x45c>
				/* The API FreeRTOS_accept() was called, the IP-task will now
				check if the listening socket (communicated in pvData) actually
				received a new connection. */
				#if( ipconfigUSE_TCP == 1 )
				{
					pxSocket = ipCAST_PTR_TO_TYPE_PTR( FreeRTOS_Socket_t, xReceivedEvent.pvData );
 80059b0:	9e05      	ldr	r6, [sp, #20]

					if( xTCPCheckNewClient( pxSocket ) != pdFALSE )
 80059b2:	4630      	mov	r0, r6
 80059b4:	f003 f874 	bl	8008aa0 <xTCPCheckNewClient>
 80059b8:	b130      	cbz	r0, 80059c8 <prvIPTask+0x45c>
					{
						pxSocket->xEventBits |= ( EventBits_t ) eSOCKET_ACCEPT;
 80059ba:	6833      	ldr	r3, [r6, #0]
 80059bc:	f043 0304 	orr.w	r3, r3, #4
 80059c0:	6033      	str	r3, [r6, #0]
						vSocketWakeUpUser( pxSocket );
 80059c2:	4630      	mov	r0, r6
 80059c4:	f000 fda4 	bl	8006510 <vSocketWakeUpUser>
			default :
				/* Should not get here. */
				break;
		}

		if( xNetworkDownEventPending != pdFALSE )
 80059c8:	4b10      	ldr	r3, [pc, #64]	; (8005a0c <prvIPTask+0x4a0>)
 80059ca:	681b      	ldr	r3, [r3, #0]
 80059cc:	2b00      	cmp	r3, #0
 80059ce:	f43f ade8 	beq.w	80055a2 <prvIPTask+0x36>
		{
			/* A network down event could not be posted to the network event
			queue because the queue was full.
			As this code runs in the IP-task, it can be done directly by
			calling prvProcessNetworkDownEvent(). */
			prvProcessNetworkDownEvent();
 80059d2:	f7ff fc53 	bl	800527c <prvProcessNetworkDownEvent>
 80059d6:	e5e4      	b.n	80055a2 <prvIPTask+0x36>
							}
						}
						#endif	/* ( ipconfigHAS_PRINTF != 0 ) */

						/* Protocol checksum not accepted. */
						eReturn = eReleaseBuffer;
 80059d8:	2000      	movs	r0, #0
 80059da:	e7a3      	b.n	8005924 <prvIPTask+0x3b8>
			if( eReturn != eReleaseBuffer )
			{
				/* Add the IP and MAC addresses to the ARP table if they are not
				already there - otherwise refresh the age of the existing
				entry. */
				if( ucProtocol != ( uint8_t ) ipPROTOCOL_UDP )
 80059dc:	f1b9 0f11 	cmp.w	r9, #17
 80059e0:	f47f af0a 	bne.w	80057f8 <prvIPTask+0x28c>
 80059e4:	e771      	b.n	80058ca <prvIPTask+0x35e>
		uint32_t ulDestinationIPAddress = pxIPHeader->ulDestinationIPAddress;

			/* Ensure that the incoming packet is not fragmented (only outgoing
			packets can be fragmented) as these are the only handled IP frames
			currently. */
			if( ( pxIPHeader->usFragmentOffset & ipFRAGMENT_OFFSET_BIT_MASK ) != 0U )
 80059e6:	2000      	movs	r0, #0
 80059e8:	e79c      	b.n	8005924 <prvIPTask+0x3b8>
				/* Can not handle, fragmented packet. */
				eReturn = eReleaseBuffer;
			}
			/* Test if the length of the IP-header is between 20 and 60 bytes,
			and if the IP-version is 4. */
			else if( ( pxIPHeader->ucVersionHeaderLength < ipIPV4_VERSION_HEADER_LENGTH_MIN ) ||
 80059ea:	2000      	movs	r0, #0
 80059ec:	e79a      	b.n	8005924 <prvIPTask+0x3b8>
		if (eReturn == eProcessBuffer )
		{
			if( xCheckSizeFields( ( uint8_t * )( pxNetworkBuffer->pucEthernetBuffer ), pxNetworkBuffer->xDataLength ) != pdPASS )
			{
				/* Some of the length checks were not successful. */
				eReturn = eReleaseBuffer;
 80059ee:	2000      	movs	r0, #0
 80059f0:	e798      	b.n	8005924 <prvIPTask+0x3b8>
 80059f2:	2000      	movs	r0, #0
 80059f4:	e796      	b.n	8005924 <prvIPTask+0x3b8>
 80059f6:	2000      	movs	r0, #0
 80059f8:	e794      	b.n	8005924 <prvIPTask+0x3b8>
 80059fa:	2000      	movs	r0, #0
 80059fc:	e792      	b.n	8005924 <prvIPTask+0x3b8>
 80059fe:	2000      	movs	r0, #0
 8005a00:	e790      	b.n	8005924 <prvIPTask+0x3b8>
 8005a02:	2000      	movs	r0, #0
 8005a04:	e78e      	b.n	8005924 <prvIPTask+0x3b8>
 8005a06:	bf00      	nop
 8005a08:	2000d3c0 	.word	0x2000d3c0
 8005a0c:	2000d3a0 	.word	0x2000d3a0

08005a10 <vIPSetDnsTimerEnableState>:
/*-----------------------------------------------------------*/

#if( ipconfigDNS_USE_CALLBACKS == 1 )
	void vIPSetDnsTimerEnableState( BaseType_t xEnableState )
	{
		if( xEnableState != 0 )
 8005a10:	b128      	cbz	r0, 8005a1e <vIPSetDnsTimerEnableState+0xe>
		{
			xDNSTimer.bActive = pdTRUE;
 8005a12:	4a06      	ldr	r2, [pc, #24]	; (8005a2c <vIPSetDnsTimerEnableState+0x1c>)
 8005a14:	7813      	ldrb	r3, [r2, #0]
 8005a16:	f043 0301 	orr.w	r3, r3, #1
 8005a1a:	7013      	strb	r3, [r2, #0]
 8005a1c:	4770      	bx	lr
		}
		else
		{
			xDNSTimer.bActive = pdFALSE;
 8005a1e:	4b03      	ldr	r3, [pc, #12]	; (8005a2c <vIPSetDnsTimerEnableState+0x1c>)
 8005a20:	781a      	ldrb	r2, [r3, #0]
 8005a22:	f36f 0200 	bfc	r2, #0, #1
 8005a26:	701a      	strb	r2, [r3, #0]
 8005a28:	4770      	bx	lr
 8005a2a:	bf00      	nop
 8005a2c:	2000d340 	.word	0x2000d340

08005a30 <xIPIsNetworkTaskReady>:
/*-----------------------------------------------------------*/

BaseType_t xIPIsNetworkTaskReady( void )
{
	return xIPTaskInitialised;
}
 8005a30:	4b01      	ldr	r3, [pc, #4]	; (8005a38 <xIPIsNetworkTaskReady+0x8>)
 8005a32:	6818      	ldr	r0, [r3, #0]
 8005a34:	4770      	bx	lr
 8005a36:	bf00      	nop
 8005a38:	2000d39c 	.word	0x2000d39c

08005a3c <FreeRTOS_IsNetworkUp>:
/*-----------------------------------------------------------*/

BaseType_t FreeRTOS_IsNetworkUp( void )
{
	return xNetworkUp;
}
 8005a3c:	4b01      	ldr	r3, [pc, #4]	; (8005a44 <FreeRTOS_IsNetworkUp+0x8>)
 8005a3e:	6818      	ldr	r0, [r3, #0]
 8005a40:	4770      	bx	lr
 8005a42:	bf00      	nop
 8005a44:	2000d384 	.word	0x2000d384

08005a48 <vProcessGeneratedRAWPacket>:
/******************************************************************************
* Function Definitions
*******************************************************************************/

void vProcessGeneratedRAWPacket( NetworkBufferDescriptor_t * const pxNetworkBuffer )
{
 8005a48:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005a4a:	b083      	sub	sp, #12
 8005a4c:	4604      	mov	r4, r0
const char *pxSrcAddrOffset = ( char *) ( &( pxNetworkBuffer->pucEthernetBuffer[ sizeof( MACAddress_t ) ] ) );
 8005a4e:	6985      	ldr	r5, [r0, #24]

	/* Check protocol being used for RAW Sockets */
	switch( pxSrcAddrOffset[17] )
 8005a50:	7deb      	ldrb	r3, [r5, #23]
 8005a52:	2b11      	cmp	r3, #17
 8005a54:	d031      	beq.n	8005aba <vProcessGeneratedRAWPacket+0x72>
 8005a56:	2bff      	cmp	r3, #255	; 0xff
 8005a58:	f040 809b 	bne.w	8005b92 <vProcessGeneratedRAWPacket+0x14a>
void prvProcessRAWPacket( NetworkBufferDescriptor_t * const pxNetworkBuffer )
{
IPPacket_t *pxIPPacket = NULL;
IPHeader_t *pxIPHeader = NULL;
eARPLookupResult_t eReturned;
uint32_t ulIPAddress = pxNetworkBuffer->ulIPAddress;
 8005a5c:	6943      	ldr	r3, [r0, #20]
 8005a5e:	a802      	add	r0, sp, #8
 8005a60:	f840 3d04 	str.w	r3, [r0, #-4]!
size_t uxPayloadSize;

	/* Map the IP Packet on start of frame */
	pxIPPacket = ipCAST_PTR_TO_TYPE_PTR(IPPacket_t, pxNetworkBuffer->pucEthernetBuffer);
	uxPayloadSize = pxNetworkBuffer->xDataLength - sizeof( IPPacket_t );
 8005a64:	69e6      	ldr	r6, [r4, #28]

	/* Determine the ARP cache status for the requested IP address. */
	eReturned = eARPGetCacheEntry( &( ulIPAddress ), &( pxIPPacket->xEthernetHeader.xDestinationAddress ) );
 8005a66:	4629      	mov	r1, r5
 8005a68:	f7fe ff20 	bl	80048ac <eARPGetCacheEntry>

	if( eReturned != eCantSendPacket )
 8005a6c:	2802      	cmp	r0, #2
 8005a6e:	f000 8081 	beq.w	8005b74 <vProcessGeneratedRAWPacket+0x12c>
	{
		if( eReturned == eARPCacheHit )
 8005a72:	2801      	cmp	r0, #1
 8005a74:	d116      	bne.n	8005aa4 <vProcessGeneratedRAWPacket+0x5c>
			/* Note: Overwrite the existing data including protocol as set in UDP structure,
			 * reusing the existing one for now */
//			char *pxIpSrcAddrOffset = ( char *) ( &( pxNetworkBuffer->pucEthernetBuffer[ sizeof( MACAddress_t ) ] ) );
//			( void ) memcpy( ( void * ) pxIpSrcAddrOffset, ( const void * ) ( xDefaultPartRAWPacketHeader.ucBytes ), sizeof( xDefaultPartRAWPacketHeader ) );

			pxIPHeader->usLength = ( uint16_t ) ( uxPayloadSize + sizeof( IPHeader_t ) );
 8005a76:	3e0e      	subs	r6, #14
 8005a78:	b2b6      	uxth	r6, r6

			pxIPHeader->usLength = FreeRTOS_htons( pxIPHeader->usLength );
 8005a7a:	0a33      	lsrs	r3, r6, #8
 8005a7c:	ea43 2606 	orr.w	r6, r3, r6, lsl #8
 8005a80:	822e      	strh	r6, [r5, #16]
			pxIPHeader->ulDestinationIPAddress = pxNetworkBuffer->ulIPAddress;
 8005a82:	6963      	ldr	r3, [r4, #20]
 8005a84:	f8c5 301e 	str.w	r3, [r5, #30]

			#if( ipconfigDRIVER_INCLUDED_TX_IP_CHECKSUM == 0 )
			{
				pxIPHeader->usHeaderChecksum = 0U;
 8005a88:	2000      	movs	r0, #0
 8005a8a:	7628      	strb	r0, [r5, #24]
 8005a8c:	7668      	strb	r0, [r5, #25]
				pxIPHeader->usHeaderChecksum = usGenerateChecksum( 0U, ( uint8_t * ) &( pxIPHeader->ucVersionHeaderLength ), ipSIZE_OF_IPv4_HEADER );
 8005a8e:	f105 010e 	add.w	r1, r5, #14
 8005a92:	2214      	movs	r2, #20
 8005a94:	f7ff fc42 	bl	800531c <usGenerateChecksum>
				pxIPHeader->usHeaderChecksum = ~FreeRTOS_htons( pxIPHeader->usHeaderChecksum );
 8005a98:	0a03      	lsrs	r3, r0, #8
 8005a9a:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 8005a9e:	43c3      	mvns	r3, r0
 8005aa0:	832b      	strh	r3, [r5, #24]
 8005aa2:	e062      	b.n	8005b6a <vProcessGeneratedRAWPacket+0x122>
			}
			#endif
		}
		else if( eReturned == eARPCacheMiss )
 8005aa4:	2800      	cmp	r0, #0
 8005aa6:	d165      	bne.n	8005b74 <vProcessGeneratedRAWPacket+0x12c>
		{
			/* Add an entry to the ARP table with a null hardware address.
				This allows the ARP timer to know that an ARP reply is
				outstanding, and perform retransmissions if necessary. */
			vARPRefreshCacheEntry( NULL, ulIPAddress );
 8005aa8:	9901      	ldr	r1, [sp, #4]
 8005aaa:	f7fe fe03 	bl	80046b4 <vARPRefreshCacheEntry>

			/* Generate an ARP for the required IP address. */
			iptracePACKET_DROPPED_TO_GENERATE_ARP( pxNetworkBuffer->ulIPAddress );
			pxNetworkBuffer->ulIPAddress = ulIPAddress;
 8005aae:	9b01      	ldr	r3, [sp, #4]
 8005ab0:	6163      	str	r3, [r4, #20]
			vARPGenerateRequestPacket( pxNetworkBuffer );
 8005ab2:	4620      	mov	r0, r4
 8005ab4:	f7fe ff5a 	bl	800496c <vARPGenerateRequestPacket>
 8005ab8:	e057      	b.n	8005b6a <vProcessGeneratedRAWPacket+0x122>
void prvProcessUDPPacket( NetworkBufferDescriptor_t * const pxNetworkBuffer )
{
UDPPacket_t *pxUDPPacket;
IPHeader_t *pxIPHeader;
eARPLookupResult_t eReturned;
uint32_t ulIPAddress = pxNetworkBuffer->ulIPAddress;
 8005aba:	6943      	ldr	r3, [r0, #20]
 8005abc:	9301      	str	r3, [sp, #4]
		uxPayloadSize = pxNetworkBuffer->xDataLength - sizeof( ICMPPacket_t );
	}
	else
#endif
	{
		uxPayloadSize = pxNetworkBuffer->xDataLength - sizeof( UDPPacket_t );
 8005abe:	69c6      	ldr	r6, [r0, #28]
 8005ac0:	3e2a      	subs	r6, #42	; 0x2a
	}

	/* Determine the ARP cache status for the requested IP address. */
	eReturned = eARPGetCacheEntry( &( ulIPAddress ), &( pxUDPPacket->xEthernetHeader.xDestinationAddress ) );
 8005ac2:	a801      	add	r0, sp, #4
 8005ac4:	4629      	mov	r1, r5
 8005ac6:	f7fe fef1 	bl	80048ac <eARPGetCacheEntry>

	if( eReturned != eCantSendPacket )
 8005aca:	2802      	cmp	r0, #2
 8005acc:	d05e      	beq.n	8005b8c <vProcessGeneratedRAWPacket+0x144>
	{
		if( eReturned == eARPCacheHit )
 8005ace:	2801      	cmp	r0, #1
 8005ad0:	d141      	bne.n	8005b56 <vProcessGeneratedRAWPacket+0x10e>
			pxIPHeader = &( pxUDPPacket->xIPHeader );

			#if ( ipconfigSUPPORT_OUTGOING_PINGS == 1 )
			/* Is it possible that the packet is not actually a UDP packet
				after all, but an ICMP packet. */
			if( pxNetworkBuffer->usPort != ( uint16_t ) ipPACKET_CONTAINS_ICMP_DATA )
 8005ad2:	8c23      	ldrh	r3, [r4, #32]
 8005ad4:	2b00      	cmp	r3, #0
 8005ad6:	d051      	beq.n	8005b7c <vProcessGeneratedRAWPacket+0x134>
			{
				UDPHeader_t *pxUDPHeader;

				pxUDPHeader = &( pxUDPPacket->xUDPHeader );

				pxUDPHeader->usDestinationPort = pxNetworkBuffer->usPort;
 8005ad8:	84ab      	strh	r3, [r5, #36]	; 0x24
				pxUDPHeader->usSourcePort = pxNetworkBuffer->usBoundPort;
 8005ada:	8c63      	ldrh	r3, [r4, #34]	; 0x22
 8005adc:	846b      	strh	r3, [r5, #34]	; 0x22
				pxUDPHeader->usLength = ( uint16_t ) ( uxPayloadSize + sizeof( UDPHeader_t ) );
 8005ade:	b2b3      	uxth	r3, r6
 8005ae0:	f103 0208 	add.w	r2, r3, #8
 8005ae4:	b292      	uxth	r2, r2
				pxUDPHeader->usLength = FreeRTOS_htons( pxUDPHeader->usLength );
 8005ae6:	0a11      	lsrs	r1, r2, #8
 8005ae8:	ea41 2202 	orr.w	r2, r1, r2, lsl #8
 8005aec:	84ea      	strh	r2, [r5, #38]	; 0x26
				pxUDPHeader->usChecksum = 0U;
 8005aee:	2200      	movs	r2, #0
 8005af0:	f885 2028 	strb.w	r2, [r5, #40]	; 0x28
 8005af4:	f885 2029 	strb.w	r2, [r5, #41]	; 0x29
			}
			/* Save options now, as they will be overwritten by memcpy */
			#if( ipconfigDRIVER_INCLUDED_TX_IP_CHECKSUM == 0 )
			{
				ucSocketOptions = pxNetworkBuffer->pucEthernetBuffer[ ipSOCKET_OPTIONS_OFFSET ];
 8005af8:	69a2      	ldr	r2, [r4, #24]
 8005afa:	7997      	ldrb	r7, [r2, #6]
			 * reusing the existing one for now */
//			char *pxUdpSrcAddrOffset = ( char *) ( &( pxNetworkBuffer->pucEthernetBuffer[ sizeof( MACAddress_t ) ] ) );
//			( void ) memcpy( ( void * ) pxUdpSrcAddrOffset, ( const void * ) ( xDefaultPartUDPPacketHeader.ucBytes ), sizeof( xDefaultPartUDPPacketHeader ) );

			#if ipconfigSUPPORT_OUTGOING_PINGS == 1
			if( pxNetworkBuffer->usPort == ( uint16_t ) ipPACKET_CONTAINS_ICMP_DATA )
 8005afc:	8c22      	ldrh	r2, [r4, #32]
 8005afe:	b922      	cbnz	r2, 8005b0a <vProcessGeneratedRAWPacket+0xc2>
			{
				pxIPHeader->ucProtocol = ipPROTOCOL_ICMP;
 8005b00:	2301      	movs	r3, #1
 8005b02:	75eb      	strb	r3, [r5, #23]
				pxIPHeader->usLength = ( uint16_t ) ( uxPayloadSize + sizeof( IPHeader_t ) + sizeof( ICMPHeader_t ) );
 8005b04:	361c      	adds	r6, #28
 8005b06:	822e      	strh	r6, [r5, #16]
 8005b08:	e001      	b.n	8005b0e <vProcessGeneratedRAWPacket+0xc6>
			}
			else
			#endif /* ipconfigSUPPORT_OUTGOING_PINGS */
			{
				pxIPHeader->usLength = ( uint16_t ) ( uxPayloadSize + sizeof( IPHeader_t ) + sizeof( UDPHeader_t ) );
 8005b0a:	331c      	adds	r3, #28
 8005b0c:	822b      	strh	r3, [r5, #16]
			}

			pxIPHeader->usLength = FreeRTOS_htons( pxIPHeader->usLength );
 8005b0e:	8a2a      	ldrh	r2, [r5, #16]
 8005b10:	0a13      	lsrs	r3, r2, #8
 8005b12:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8005b16:	822b      	strh	r3, [r5, #16]
			pxIPHeader->ulDestinationIPAddress = pxNetworkBuffer->ulIPAddress;
 8005b18:	6963      	ldr	r3, [r4, #20]
 8005b1a:	f8c5 301e 	str.w	r3, [r5, #30]
			}
			#endif

			#if( ipconfigDRIVER_INCLUDED_TX_IP_CHECKSUM == 0 )
			{
				pxIPHeader->usHeaderChecksum = 0U;
 8005b1e:	2000      	movs	r0, #0
 8005b20:	7628      	strb	r0, [r5, #24]
 8005b22:	7668      	strb	r0, [r5, #25]
				pxIPHeader->usHeaderChecksum = usGenerateChecksum( 0U, ( uint8_t * ) &( pxIPHeader->ucVersionHeaderLength ), ipSIZE_OF_IPv4_HEADER );
 8005b24:	f105 010e 	add.w	r1, r5, #14
 8005b28:	2214      	movs	r2, #20
 8005b2a:	f7ff fbf7 	bl	800531c <usGenerateChecksum>
				pxIPHeader->usHeaderChecksum = ~FreeRTOS_htons( pxIPHeader->usHeaderChecksum );
 8005b2e:	0a03      	lsrs	r3, r0, #8
 8005b30:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 8005b34:	43c0      	mvns	r0, r0
 8005b36:	8328      	strh	r0, [r5, #24]

				if( ( ucSocketOptions & ( uint8_t ) FREERTOS_SO_UDPCKSUM_OUT ) != 0U )
 8005b38:	f017 0f02 	tst.w	r7, #2
 8005b3c:	d005      	beq.n	8005b4a <vProcessGeneratedRAWPacket+0x102>
				{
					( void ) usGenerateProtocolChecksum( ( uint8_t * ) pxUDPPacket, pxNetworkBuffer->xDataLength, pdTRUE );
 8005b3e:	4628      	mov	r0, r5
 8005b40:	69e1      	ldr	r1, [r4, #28]
 8005b42:	2201      	movs	r2, #1
 8005b44:	f7ff fc5a 	bl	80053fc <usGenerateProtocolChecksum>
 8005b48:	e01b      	b.n	8005b82 <vProcessGeneratedRAWPacket+0x13a>
				}
				else
				{
					pxUDPPacket->xUDPHeader.usChecksum = 0U;
 8005b4a:	2300      	movs	r3, #0
 8005b4c:	f885 3028 	strb.w	r3, [r5, #40]	; 0x28
 8005b50:	f885 3029 	strb.w	r3, [r5, #41]	; 0x29
 8005b54:	e015      	b.n	8005b82 <vProcessGeneratedRAWPacket+0x13a>
				}
			}
		#endif
		}
		else if( eReturned == eARPCacheMiss )
 8005b56:	b9c8      	cbnz	r0, 8005b8c <vProcessGeneratedRAWPacket+0x144>
		{
			/* Add an entry to the ARP table with a null hardware address.
				This allows the ARP timer to know that an ARP reply is
				outstanding, and perform retransmissions if necessary. */
			vARPRefreshCacheEntry( NULL, ulIPAddress );
 8005b58:	9901      	ldr	r1, [sp, #4]
 8005b5a:	f7fe fdab 	bl	80046b4 <vARPRefreshCacheEntry>

			/* Generate an ARP for the required IP address. */
			iptracePACKET_DROPPED_TO_GENERATE_ARP( pxNetworkBuffer->ulIPAddress );
			pxNetworkBuffer->ulIPAddress = ulIPAddress;
 8005b5e:	9b01      	ldr	r3, [sp, #4]
 8005b60:	6163      	str	r3, [r4, #20]
			vARPGenerateRequestPacket( pxNetworkBuffer );
 8005b62:	4620      	mov	r0, r4
 8005b64:	f7fe ff02 	bl	800496c <vARPGenerateRequestPacket>
 8005b68:	e00b      	b.n	8005b82 <vProcessGeneratedRAWPacket+0x13a>

	if( eReturned != eCantSendPacket )
	{
		/* The network driver is responsible for freeing the network buffer
			after the packet has been sent. */
		( void ) xNetworkInterfaceOutput( pxNetworkBuffer, pdTRUE );
 8005b6a:	4620      	mov	r0, r4
 8005b6c:	2101      	movs	r1, #1
 8005b6e:	f7fe fb79 	bl	8004264 <xNetworkInterfaceOutput>
 8005b72:	e00e      	b.n	8005b92 <vProcessGeneratedRAWPacket+0x14a>
	}
	else
	{
		/* The packet can't be sent (DHCP not completed?).  Just drop the
			packet. */
		vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 8005b74:	4620      	mov	r0, r4
 8005b76:	f7fe fd2b 	bl	80045d0 <vReleaseNetworkBufferAndDescriptor>
 8005b7a:	e00a      	b.n	8005b92 <vProcessGeneratedRAWPacket+0x14a>
				pxUDPHeader->usChecksum = 0U;
			}
			/* Save options now, as they will be overwritten by memcpy */
			#if( ipconfigDRIVER_INCLUDED_TX_IP_CHECKSUM == 0 )
			{
				ucSocketOptions = pxNetworkBuffer->pucEthernetBuffer[ ipSOCKET_OPTIONS_OFFSET ];
 8005b7c:	69a3      	ldr	r3, [r4, #24]
 8005b7e:	799f      	ldrb	r7, [r3, #6]
 8005b80:	e7be      	b.n	8005b00 <vProcessGeneratedRAWPacket+0xb8>
				pxNetworkBuffer->xDataLength = ( size_t ) ipconfigETHERNET_MINIMUM_PACKET_BYTES;
			}
		}
		#endif

		( void ) xNetworkInterfaceOutput( pxNetworkBuffer, pdTRUE );
 8005b82:	4620      	mov	r0, r4
 8005b84:	2101      	movs	r1, #1
 8005b86:	f7fe fb6d 	bl	8004264 <xNetworkInterfaceOutput>
 8005b8a:	e002      	b.n	8005b92 <vProcessGeneratedRAWPacket+0x14a>
	}
	else
	{
		/* The packet can't be sent (DHCP not completed?).  Just drop the
			packet. */
		vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 8005b8c:	4620      	mov	r0, r4
 8005b8e:	f7fe fd1f 	bl	80045d0 <vReleaseNetworkBufferAndDescriptor>

	default:
		/* TODO: Handle Error */
		break;
	}
}
 8005b92:	b003      	add	sp, #12
 8005b94:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005b96:	bf00      	nop

08005b98 <prvValidSocket>:

static BaseType_t prvValidSocket( const FreeRTOS_Socket_t *pxSocket, BaseType_t xProtocol, BaseType_t xIsBound )
{
BaseType_t xReturn;

	if( ( pxSocket == NULL ) || ( pxSocket == FREERTOS_INVALID_SOCKET ) )
 8005b98:	1e43      	subs	r3, r0, #1
 8005b9a:	f113 0f03 	cmn.w	r3, #3
 8005b9e:	d80a      	bhi.n	8005bb6 <prvValidSocket+0x1e>
	{
		xReturn = pdFALSE;
	}
	else if( ( xIsBound != pdFALSE ) && !socketSOCKET_IS_BOUND( pxSocket ) )
 8005ba0:	b10a      	cbz	r2, 8005ba6 <prvValidSocket+0xe>
 8005ba2:	6983      	ldr	r3, [r0, #24]
 8005ba4:	b14b      	cbz	r3, 8005bba <prvValidSocket+0x22>
	{
		/* The caller expects the socket to be bound, but it isn't. */
		xReturn = pdFALSE;
	}
	else if( pxSocket->ucProtocol != ( uint8_t ) xProtocol )
 8005ba6:	f890 3027 	ldrb.w	r3, [r0, #39]	; 0x27
 8005baa:	b2c8      	uxtb	r0, r1
 8005bac:	4283      	cmp	r3, r0
 8005bae:	bf14      	ite	ne
 8005bb0:	2000      	movne	r0, #0
 8005bb2:	2001      	moveq	r0, #1
 8005bb4:	4770      	bx	lr
{
BaseType_t xReturn;

	if( ( pxSocket == NULL ) || ( pxSocket == FREERTOS_INVALID_SOCKET ) )
	{
		xReturn = pdFALSE;
 8005bb6:	2000      	movs	r0, #0
 8005bb8:	4770      	bx	lr
	}
	else if( ( xIsBound != pdFALSE ) && !socketSOCKET_IS_BOUND( pxSocket ) )
	{
		/* The caller expects the socket to be bound, but it isn't. */
		xReturn = pdFALSE;
 8005bba:	2000      	movs	r0, #0
	{
		xReturn = pdTRUE;
	}

	return xReturn;
}
 8005bbc:	4770      	bx	lr
 8005bbe:	bf00      	nop

08005bc0 <pxListFindListItemWithValue>:
/*-----------------------------------------------------------*/

/* pxListFindListItemWithValue: find a list item in a bound socket list
'xWantedItemValue' refers to a port number */
static const ListItem_t * pxListFindListItemWithValue( const List_t *pxList, TickType_t xWantedItemValue )
{
 8005bc0:	b538      	push	{r3, r4, r5, lr}
 8005bc2:	4605      	mov	r5, r0
 8005bc4:	460c      	mov	r4, r1
const ListItem_t * pxResult = NULL;

	if( ( xIPIsNetworkTaskReady() != pdFALSE ) && ( pxList != NULL ) )
 8005bc6:	f7ff ff33 	bl	8005a30 <xIPIsNetworkTaskReady>
 8005bca:	b188      	cbz	r0, 8005bf0 <pxListFindListItemWithValue+0x30>
 8005bcc:	b195      	cbz	r5, 8005bf4 <pxListFindListItemWithValue+0x34>
	{
		const ListItem_t *pxIterator;
		const ListItem_t *pxEnd = listGET_END_MARKER( pxList );
 8005bce:	f105 0208 	add.w	r2, r5, #8
		for( pxIterator  = listGET_NEXT( pxEnd );
 8005bd2:	68e8      	ldr	r0, [r5, #12]
 8005bd4:	4282      	cmp	r2, r0
 8005bd6:	d00f      	beq.n	8005bf8 <pxListFindListItemWithValue+0x38>
			 pxIterator != pxEnd;
			 pxIterator  = listGET_NEXT( pxIterator ) )
		{
			if( listGET_LIST_ITEM_VALUE( pxIterator ) == xWantedItemValue )
 8005bd8:	6803      	ldr	r3, [r0, #0]
 8005bda:	42a3      	cmp	r3, r4
 8005bdc:	d103      	bne.n	8005be6 <pxListFindListItemWithValue+0x26>
 8005bde:	bd38      	pop	{r3, r4, r5, pc}
 8005be0:	6803      	ldr	r3, [r0, #0]
 8005be2:	42a3      	cmp	r3, r4
 8005be4:	d009      	beq.n	8005bfa <pxListFindListItemWithValue+0x3a>
	{
		const ListItem_t *pxIterator;
		const ListItem_t *pxEnd = listGET_END_MARKER( pxList );
		for( pxIterator  = listGET_NEXT( pxEnd );
			 pxIterator != pxEnd;
			 pxIterator  = listGET_NEXT( pxIterator ) )
 8005be6:	6840      	ldr	r0, [r0, #4]

	if( ( xIPIsNetworkTaskReady() != pdFALSE ) && ( pxList != NULL ) )
	{
		const ListItem_t *pxIterator;
		const ListItem_t *pxEnd = listGET_END_MARKER( pxList );
		for( pxIterator  = listGET_NEXT( pxEnd );
 8005be8:	4282      	cmp	r2, r0
 8005bea:	d1f9      	bne.n	8005be0 <pxListFindListItemWithValue+0x20>

/* pxListFindListItemWithValue: find a list item in a bound socket list
'xWantedItemValue' refers to a port number */
static const ListItem_t * pxListFindListItemWithValue( const List_t *pxList, TickType_t xWantedItemValue )
{
const ListItem_t * pxResult = NULL;
 8005bec:	2000      	movs	r0, #0
 8005bee:	bd38      	pop	{r3, r4, r5, pc}
 8005bf0:	2000      	movs	r0, #0
 8005bf2:	bd38      	pop	{r3, r4, r5, pc}
 8005bf4:	2000      	movs	r0, #0
 8005bf6:	bd38      	pop	{r3, r4, r5, pc}
 8005bf8:	2000      	movs	r0, #0
			}
		}
	}

	return pxResult;
} /* Tested */
 8005bfa:	bd38      	pop	{r3, r4, r5, pc}

08005bfc <vNetworkSocketsInit>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vNetworkSocketsInit( void )
{
 8005bfc:	b508      	push	{r3, lr}
	vListInitialise( &xBoundUDPSocketsList );
 8005bfe:	4805      	ldr	r0, [pc, #20]	; (8005c14 <vNetworkSocketsInit+0x18>)
 8005c00:	f7fc fb74 	bl	80022ec <vListInitialise>
	vListInitialise( &xBoundRAWSocketsList );
 8005c04:	4804      	ldr	r0, [pc, #16]	; (8005c18 <vNetworkSocketsInit+0x1c>)
 8005c06:	f7fc fb71 	bl	80022ec <vListInitialise>

	#if( ipconfigUSE_TCP == 1 )
	{
		vListInitialise( &xBoundTCPSocketsList );
 8005c0a:	4804      	ldr	r0, [pc, #16]	; (8005c1c <vNetworkSocketsInit+0x20>)
 8005c0c:	f7fc fb6e 	bl	80022ec <vListInitialise>
 8005c10:	bd08      	pop	{r3, pc}
 8005c12:	bf00      	nop
 8005c14:	2000d3c8 	.word	0x2000d3c8
 8005c18:	2000d3dc 	.word	0x2000d3dc
 8005c1c:	2000d4f8 	.word	0x2000d4f8

08005c20 <FreeRTOS_socket>:
}
/*-----------------------------------------------------------*/

/* FreeRTOS_socket() allocates and initiates a socket */
Socket_t FreeRTOS_socket( BaseType_t xDomain, BaseType_t xType, BaseType_t xProtocol )
{
 8005c20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005c24:	4604      	mov	r4, r0
 8005c26:	460d      	mov	r5, r1
 8005c28:	4616      	mov	r6, r2
BaseType_t xReturn = pdPASS;
FreeRTOS_Socket_t const *pxSocket ;

	/* Asserts must not appear before it has been determined that the network
	task is ready - otherwise the asserts will fail. */
	if( xIPIsNetworkTaskReady() == pdFALSE )
 8005c2a:	f7ff ff01 	bl	8005a30 <xIPIsNetworkTaskReady>
 8005c2e:	2800      	cmp	r0, #0
 8005c30:	f000 80af 	beq.w	8005d92 <FreeRTOS_socket+0x172>
		xReturn = pdFAIL;
	}
	else
	{
		/* Only Ethernet is currently supported. */
		configASSERT( xDomain == FREERTOS_AF_INET );
 8005c34:	2c02      	cmp	r4, #2
 8005c36:	d008      	beq.n	8005c4a <FreeRTOS_socket+0x2a>
 8005c38:	f04f 0314 	mov.w	r3, #20
 8005c3c:	f383 8811 	msr	BASEPRI, r3
 8005c40:	f3bf 8f6f 	isb	sy
 8005c44:	f3bf 8f4f 	dsb	sy
 8005c48:	e7fe      	b.n	8005c48 <FreeRTOS_socket+0x28>

		/* Check if the UDP socket-list has been initialised. */
		configASSERT( listLIST_IS_INITIALISED( &xBoundUDPSocketsList ) );
 8005c4a:	4b64      	ldr	r3, [pc, #400]	; (8005ddc <FreeRTOS_socket+0x1bc>)
 8005c4c:	689b      	ldr	r3, [r3, #8]
 8005c4e:	f1b3 3fff 	cmp.w	r3, #4294967295
 8005c52:	d008      	beq.n	8005c66 <FreeRTOS_socket+0x46>
 8005c54:	f04f 0314 	mov.w	r3, #20
 8005c58:	f383 8811 	msr	BASEPRI, r3
 8005c5c:	f3bf 8f6f 	isb	sy
 8005c60:	f3bf 8f4f 	dsb	sy
 8005c64:	e7fe      	b.n	8005c64 <FreeRTOS_socket+0x44>
		configASSERT( listLIST_IS_INITIALISED( &xBoundRAWSocketsList ) );
 8005c66:	4b5e      	ldr	r3, [pc, #376]	; (8005de0 <FreeRTOS_socket+0x1c0>)
 8005c68:	689b      	ldr	r3, [r3, #8]
 8005c6a:	f1b3 3fff 	cmp.w	r3, #4294967295
 8005c6e:	d008      	beq.n	8005c82 <FreeRTOS_socket+0x62>
 8005c70:	f04f 0314 	mov.w	r3, #20
 8005c74:	f383 8811 	msr	BASEPRI, r3
 8005c78:	f3bf 8f6f 	isb	sy
 8005c7c:	f3bf 8f4f 	dsb	sy
 8005c80:	e7fe      	b.n	8005c80 <FreeRTOS_socket+0x60>
		#if( ipconfigUSE_TCP == 1 )
		{
			/* Check if the TCP socket-list has been initialised. */
			configASSERT( listLIST_IS_INITIALISED( &xBoundTCPSocketsList ) );
 8005c82:	4b58      	ldr	r3, [pc, #352]	; (8005de4 <FreeRTOS_socket+0x1c4>)
 8005c84:	689b      	ldr	r3, [r3, #8]
 8005c86:	f1b3 3fff 	cmp.w	r3, #4294967295
 8005c8a:	d008      	beq.n	8005c9e <FreeRTOS_socket+0x7e>
 8005c8c:	f04f 0314 	mov.w	r3, #20
 8005c90:	f383 8811 	msr	BASEPRI, r3
 8005c94:	f3bf 8f6f 	isb	sy
 8005c98:	f3bf 8f4f 	dsb	sy
 8005c9c:	e7fe      	b.n	8005c9c <FreeRTOS_socket+0x7c>
		}
		#endif  /* ipconfigUSE_TCP == 1 */

		if( xProtocol == FREERTOS_IPPROTO_UDP )
 8005c9e:	2e11      	cmp	r6, #17
 8005ca0:	d10b      	bne.n	8005cba <FreeRTOS_socket+0x9a>
		{
			if( (xType != FREERTOS_SOCK_DGRAM) && ( xType != FREERTOS_SOCK_RAW ) )
 8005ca2:	1eab      	subs	r3, r5, #2
 8005ca4:	2b01      	cmp	r3, #1
 8005ca6:	d97a      	bls.n	8005d9e <FreeRTOS_socket+0x17e>
 8005ca8:	f04f 0314 	mov.w	r3, #20
 8005cac:	f383 8811 	msr	BASEPRI, r3
 8005cb0:	f3bf 8f6f 	isb	sy
 8005cb4:	f3bf 8f4f 	dsb	sy
 8005cb8:	e7fe      	b.n	8005cb8 <FreeRTOS_socket+0x98>
			else
			{
				*pxSocketSize = ( sizeof( *pxSocket ) - sizeof( pxSocket->u ) ) + sizeof( pxSocket->u.xRAW );
			}
		}
		else if( xProtocol == FREERTOS_IPPROTO_RAW )
 8005cba:	2eff      	cmp	r6, #255	; 0xff
 8005cbc:	d110      	bne.n	8005ce0 <FreeRTOS_socket+0xc0>
		{
			if( (xType != FREERTOS_SOCK_RAW) && (xType != FREERTOS_CAN_RAW) )
 8005cbe:	1eeb      	subs	r3, r5, #3
 8005cc0:	2b01      	cmp	r3, #1
 8005cc2:	d908      	bls.n	8005cd6 <FreeRTOS_socket+0xb6>
 8005cc4:	f04f 0314 	mov.w	r3, #20
 8005cc8:	f383 8811 	msr	BASEPRI, r3
 8005ccc:	f3bf 8f6f 	isb	sy
 8005cd0:	f3bf 8f4f 	dsb	sy
 8005cd4:	e7fe      	b.n	8005cd4 <FreeRTOS_socket+0xb4>
			}
			else
			{
				if( FREERTOS_SOCK_RAW == xType )
				{
					*pxSocketSize = ( sizeof( *pxSocket ) - sizeof( pxSocket->u ) );
 8005cd6:	2d03      	cmp	r5, #3
 8005cd8:	bf14      	ite	ne
 8005cda:	2700      	movne	r7, #0
 8005cdc:	2738      	moveq	r7, #56	; 0x38
 8005cde:	e062      	b.n	8005da6 <FreeRTOS_socket+0x186>
					/* CAN RAW Socket */
				}
			}
		}
#if( ipconfigUSE_TCP == 1 )
		else if( xProtocol == FREERTOS_IPPROTO_TCP )
 8005ce0:	2e06      	cmp	r6, #6
 8005ce2:	d10a      	bne.n	8005cfa <FreeRTOS_socket+0xda>
		{
			if( (xType != FREERTOS_SOCK_STREAM) )
 8005ce4:	2d01      	cmp	r5, #1
 8005ce6:	d05c      	beq.n	8005da2 <FreeRTOS_socket+0x182>
 8005ce8:	f04f 0314 	mov.w	r3, #20
 8005cec:	f383 8811 	msr	BASEPRI, r3
 8005cf0:	f3bf 8f6f 	isb	sy
 8005cf4:	f3bf 8f4f 	dsb	sy
 8005cf8:	e7fe      	b.n	8005cf8 <FreeRTOS_socket+0xd8>
 8005cfa:	f04f 0314 	mov.w	r3, #20
 8005cfe:	f383 8811 	msr	BASEPRI, r3
 8005d02:	f3bf 8f6f 	isb	sy
 8005d06:	f3bf 8f4f 	dsb	sy
 8005d0a:	e7fe      	b.n	8005d0a <FreeRTOS_socket+0xea>
			xReturn = FREERTOS_INVALID_SOCKET;
			iptraceFAILED_TO_CREATE_SOCKET();
		}
		else
		{
			xEventGroup = xEventGroupCreate();
 8005d0c:	f7fc f9b4 	bl	8002078 <xEventGroupCreate>
			if( xEventGroup == NULL )
 8005d10:	4680      	mov	r8, r0
 8005d12:	b928      	cbnz	r0, 8005d20 <FreeRTOS_socket+0x100>
			{
				vPortFreeSocket( pxSocket );
 8005d14:	4620      	mov	r0, r4
 8005d16:	f7fe f985 	bl	8004024 <vPortFree>
				xReturn = FREERTOS_INVALID_SOCKET;
 8005d1a:	f04f 34ff 	mov.w	r4, #4294967295
 8005d1e:	e05a      	b.n	8005dd6 <FreeRTOS_socket+0x1b6>
					/* Lint wants at least a comment, in case the macro is empty. */
					iptraceMEM_STATS_CREATE( tcpSOCKET_TCP, pxSocket, uxSocketSize + sizeof( StaticEventGroup_t ) );
				}

				/* Clear the entire space to avoid nulling individual entries. */
				( void ) memset( pxSocket, 0, uxSocketSize );
 8005d20:	4620      	mov	r0, r4
 8005d22:	2100      	movs	r1, #0
 8005d24:	463a      	mov	r2, r7
 8005d26:	f004 f909 	bl	8009f3c <memset>

				pxSocket->xEventGroup = xEventGroup;
 8005d2a:	f8c4 8004 	str.w	r8, [r4, #4]

				/* Initialise the socket's members.  The semaphore will be created
				if the socket is bound to an address, for now the pointer to the
				semaphore is just set to NULL to show it has not been created. */
				if( xProtocol == FREERTOS_IPPROTO_UDP )
 8005d2e:	2e11      	cmp	r6, #17
 8005d30:	d10d      	bne.n	8005d4e <FreeRTOS_socket+0x12e>
				{
					if( FREERTOS_SOCK_DGRAM == xType )
 8005d32:	2d02      	cmp	r5, #2
 8005d34:	d104      	bne.n	8005d40 <FreeRTOS_socket+0x120>
					{
						vListInitialise( &( pxSocket->u.xUDP.xWaitingPacketsList ) );
 8005d36:	f104 0038 	add.w	r0, r4, #56	; 0x38
 8005d3a:	f7fc fad7 	bl	80022ec <vListInitialise>
 8005d3e:	e039      	b.n	8005db4 <FreeRTOS_socket+0x194>
						{
							pxSocket->u.xUDP.uxMaxPackets = ( UBaseType_t ) ipconfigUDP_MAX_RX_PACKETS;
						}
						#endif /* ipconfigUDP_MAX_RX_PACKETS > 0 */
					}
					else if( FREERTOS_SOCK_RAW == xType )
 8005d40:	2d03      	cmp	r5, #3
 8005d42:	d137      	bne.n	8005db4 <FreeRTOS_socket+0x194>
					{
						vListInitialise( &( pxSocket->u.xRAW.xWaitingPacketsList ) );
 8005d44:	f104 0038 	add.w	r0, r4, #56	; 0x38
 8005d48:	f7fc fad0 	bl	80022ec <vListInitialise>
 8005d4c:	e032      	b.n	8005db4 <FreeRTOS_socket+0x194>
				else if( xProtocol == FREERTOS_IPPROTO_RAW )
				{
					/* RAW protocol does not contain waiting list, Do Nothing */
				} else{ /* Do Nothing */ }

				vListInitialiseItem( &( pxSocket->xBoundSocketListItem ) );
 8005d4e:	f104 0008 	add.w	r0, r4, #8
 8005d52:	f7fc fad7 	bl	8002304 <vListInitialiseItem>
				listSET_LIST_ITEM_OWNER( &( pxSocket->xBoundSocketListItem ), ipPOINTER_CAST( void *, pxSocket ) );
 8005d56:	6164      	str	r4, [r4, #20]

				pxSocket->xReceiveBlockTime = ipconfigSOCK_DEFAULT_RECEIVE_BLOCK_TIME;
 8005d58:	f241 3388 	movw	r3, #5000	; 0x1388
 8005d5c:	61e3      	str	r3, [r4, #28]
				pxSocket->xSendBlockTime	= ipconfigSOCK_DEFAULT_SEND_BLOCK_TIME;
 8005d5e:	6223      	str	r3, [r4, #32]
				pxSocket->ucSocketOptions   = ( uint8_t ) FREERTOS_SO_UDPCKSUM_OUT;
 8005d60:	2302      	movs	r3, #2
 8005d62:	f884 3026 	strb.w	r3, [r4, #38]	; 0x26
				pxSocket->ucProtocol		= ( uint8_t ) xProtocol; /* protocol: UDP or TCP or RAW */
 8005d66:	f884 6027 	strb.w	r6, [r4, #39]	; 0x27
				pxSocket->ucSocketType		= ( uint8_t ) xType;
 8005d6a:	f884 5028 	strb.w	r5, [r4, #40]	; 0x28

				#if( ipconfigUSE_TCP == 1 )
				{
					if( xProtocol == FREERTOS_IPPROTO_TCP )
 8005d6e:	2e06      	cmp	r6, #6
 8005d70:	d131      	bne.n	8005dd6 <FreeRTOS_socket+0x1b6>
					{
						/* StreamSize is expressed in number of bytes */
						/* Round up buffer sizes to nearest multiple of MSS */
						pxSocket->u.xTCP.usCurMSS     = ( uint16_t ) ipconfigTCP_MSS;
 8005d72:	f44f 6391 	mov.w	r3, #1160	; 0x488
 8005d76:	f8a4 304a 	strh.w	r3, [r4, #74]	; 0x4a
						pxSocket->u.xTCP.usInitMSS    = ( uint16_t ) ipconfigTCP_MSS;
 8005d7a:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
						pxSocket->u.xTCP.uxRxStreamSize = ( size_t ) ipconfigTCP_RX_BUFFER_LENGTH;
 8005d7e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8005d82:	66e2      	str	r2, [r4, #108]	; 0x6c
						pxSocket->u.xTCP.uxTxStreamSize = ( size_t ) FreeRTOS_round_up( ipconfigTCP_TX_BUFFER_LENGTH, ipconfigTCP_MSS );
 8005d84:	6723      	str	r3, [r4, #112]	; 0x70
						/* Use half of the buffer size of the TCP windows */
						#if ( ipconfigUSE_TCP_WIN == 1 )
						{
							pxSocket->u.xTCP.uxRxWinSize  = FreeRTOS_max_uint32( 1UL, ( uint32_t ) ( pxSocket->u.xTCP.uxRxStreamSize / 2U ) / ipconfigTCP_MSS );
 8005d86:	2301      	movs	r3, #1
 8005d88:	f8c4 30d0 	str.w	r3, [r4, #208]	; 0xd0
							pxSocket->u.xTCP.uxTxWinSize  = FreeRTOS_max_uint32( 1UL, ( uint32_t ) ( pxSocket->u.xTCP.uxTxStreamSize / 2U ) / ipconfigTCP_MSS );
 8005d8c:	f8c4 30d4 	str.w	r3, [r4, #212]	; 0xd4
 8005d90:	e021      	b.n	8005dd6 <FreeRTOS_socket+0x1b6>
EventGroupHandle_t xEventGroup;
Socket_t xReturn;

	if( prvDetermineSocketSize( xDomain, xType, xProtocol, &uxSocketSize ) == pdFAIL )
	{
		xReturn = FREERTOS_INVALID_SOCKET;
 8005d92:	f04f 34ff 	mov.w	r4, #4294967295
 8005d96:	e01e      	b.n	8005dd6 <FreeRTOS_socket+0x1b6>
		By default it points to the FreeRTOS function 'pvPortMalloc()'. */
		pxSocket = ipCAST_PTR_TO_TYPE_PTR( FreeRTOS_Socket_t, pvPortMallocSocket( uxSocketSize ) );

		if( pxSocket == NULL )
		{
			xReturn = FREERTOS_INVALID_SOCKET;
 8005d98:	f04f 34ff 	mov.w	r4, #4294967295
 8005d9c:	e01b      	b.n	8005dd6 <FreeRTOS_socket+0x1b6>
				configASSERT( xReturn == pdPASS );
			}
			/* In case a UDP socket is created, do not allocate space for TCP data */
			if( FREERTOS_SOCK_DGRAM == xType )
			{
				*pxSocketSize = ( sizeof( *pxSocket ) - sizeof( pxSocket->u ) ) + sizeof( pxSocket->u.xUDP );
 8005d9e:	274c      	movs	r7, #76	; 0x4c
 8005da0:	e001      	b.n	8005da6 <FreeRTOS_socket+0x186>
			{
				xReturn = pdFAIL;
				configASSERT( xReturn == pdPASS );
			}

			*pxSocketSize = ( sizeof( *pxSocket ) - sizeof( pxSocket->u ) ) + sizeof( pxSocket->u.xTCP );
 8005da2:	f44f 77cc 	mov.w	r7, #408	; 0x198
	{
		/* Allocate the structure that will hold the socket information. The
		size depends on the type of socket: UDP sockets need less space. A
		define 'pvPortMallocSocket' will used to allocate the necessary space.
		By default it points to the FreeRTOS function 'pvPortMalloc()'. */
		pxSocket = ipCAST_PTR_TO_TYPE_PTR( FreeRTOS_Socket_t, pvPortMallocSocket( uxSocketSize ) );
 8005da6:	4638      	mov	r0, r7
 8005da8:	f7fe f898 	bl	8003edc <pvPortMalloc>

		if( pxSocket == NULL )
 8005dac:	4604      	mov	r4, r0
 8005dae:	2800      	cmp	r0, #0
 8005db0:	d1ac      	bne.n	8005d0c <FreeRTOS_socket+0xec>
 8005db2:	e7f1      	b.n	8005d98 <FreeRTOS_socket+0x178>
				else if( xProtocol == FREERTOS_IPPROTO_RAW )
				{
					/* RAW protocol does not contain waiting list, Do Nothing */
				} else{ /* Do Nothing */ }

				vListInitialiseItem( &( pxSocket->xBoundSocketListItem ) );
 8005db4:	f104 0008 	add.w	r0, r4, #8
 8005db8:	f7fc faa4 	bl	8002304 <vListInitialiseItem>
				listSET_LIST_ITEM_OWNER( &( pxSocket->xBoundSocketListItem ), ipPOINTER_CAST( void *, pxSocket ) );
 8005dbc:	6164      	str	r4, [r4, #20]

				pxSocket->xReceiveBlockTime = ipconfigSOCK_DEFAULT_RECEIVE_BLOCK_TIME;
 8005dbe:	f241 3388 	movw	r3, #5000	; 0x1388
 8005dc2:	61e3      	str	r3, [r4, #28]
				pxSocket->xSendBlockTime	= ipconfigSOCK_DEFAULT_SEND_BLOCK_TIME;
 8005dc4:	6223      	str	r3, [r4, #32]
				pxSocket->ucSocketOptions   = ( uint8_t ) FREERTOS_SO_UDPCKSUM_OUT;
 8005dc6:	2302      	movs	r3, #2
 8005dc8:	f884 3026 	strb.w	r3, [r4, #38]	; 0x26
				pxSocket->ucProtocol		= ( uint8_t ) xProtocol; /* protocol: UDP or TCP or RAW */
 8005dcc:	2311      	movs	r3, #17
 8005dce:	f884 3027 	strb.w	r3, [r4, #39]	; 0x27
				pxSocket->ucSocketType		= ( uint8_t ) xType;
 8005dd2:	f884 5028 	strb.w	r5, [r4, #40]	; 0x28
	}
	/* Remove compiler warnings in the case the configASSERT() is not defined. */
	( void ) xDomain;

	return xReturn;
}
 8005dd6:	4620      	mov	r0, r4
 8005dd8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005ddc:	2000d3c8 	.word	0x2000d3c8
 8005de0:	2000d3dc 	.word	0x2000d3dc
 8005de4:	2000d4f8 	.word	0x2000d4f8

08005de8 <FreeRTOS_recvfrom>:
 * FreeRTOS_recvfrom: receive data from a bound socket
 * In this library, the function can only be used with connectionsless sockets
 * (UDP)
 */
int32_t FreeRTOS_recvfrom( Socket_t xSocket, void *pvBuffer, size_t uxBufferLength, BaseType_t xFlags, struct freertos_sockaddr *pxSourceAddress, socklen_t *pxSourceAddressLength )
{
 8005de8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005dec:	b089      	sub	sp, #36	; 0x24
 8005dee:	4604      	mov	r4, r0
 8005df0:	9103      	str	r1, [sp, #12]
 8005df2:	4693      	mov	fp, r2
 8005df4:	4699      	mov	r9, r3
BaseType_t lPacketCount;
NetworkBufferDescriptor_t *pxNetworkBuffer;
const void *pvCopySource;
FreeRTOS_Socket_t const * pxSocket = xSocket;
TickType_t xRemainingTime = ( TickType_t ) 0; /* Obsolete assignment, but some compilers output a warning if its not done. */
 8005df6:	2300      	movs	r3, #0
 8005df8:	9307      	str	r3, [sp, #28]
int32_t lReturn;
EventBits_t xEventBits = ( EventBits_t ) 0;
size_t uxPayloadLength;

	/* RAW socket are send only (prvValidSocket( pxSocket, FREERTOS_IPPROTO_RAW, pdTRUE ) == pdFALSE) */
	if( (prvValidSocket( pxSocket, FREERTOS_IPPROTO_UDP, pdTRUE ) == pdFALSE) )
 8005dfa:	2111      	movs	r1, #17
 8005dfc:	2201      	movs	r2, #1
 8005dfe:	f7ff fecb 	bl	8005b98 <prvValidSocket>
 8005e02:	2800      	cmp	r0, #0
 8005e04:	f000 8089 	beq.w	8005f1a <FreeRTOS_recvfrom+0x132>
	{
		lReturn = -pdFREERTOS_ERRNO_EINVAL;
	}
	else
	{
		if( FREERTOS_SOCK_DGRAM == pxSocket->ucSocketType )
 8005e08:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 8005e0c:	2b02      	cmp	r3, #2
 8005e0e:	d101      	bne.n	8005e14 <FreeRTOS_recvfrom+0x2c>
		{
			lPacketCount = ( BaseType_t ) listCURRENT_LIST_LENGTH( &( pxSocket->u.xUDP.xWaitingPacketsList ) );
 8005e10:	6ba5      	ldr	r5, [r4, #56]	; 0x38
 8005e12:	e041      	b.n	8005e98 <FreeRTOS_recvfrom+0xb0>
		}
		else if( FREERTOS_SOCK_RAW == pxSocket->ucSocketType )
 8005e14:	2b03      	cmp	r3, #3
 8005e16:	d13f      	bne.n	8005e98 <FreeRTOS_recvfrom+0xb0>
		{
			lPacketCount = ( BaseType_t ) listCURRENT_LIST_LENGTH( &( pxSocket->u.xRAW.xWaitingPacketsList ) );
 8005e18:	6ba5      	ldr	r5, [r4, #56]	; 0x38
 8005e1a:	e03d      	b.n	8005e98 <FreeRTOS_recvfrom+0xb0>

		/* The function prototype is designed to maintain the expected Berkeley
		sockets standard, but this implementation does not use all the parameters. */
		( void ) pxSourceAddressLength;

		while( lPacketCount == 0 )
 8005e1c:	2500      	movs	r5, #0
 8005e1e:	462e      	mov	r6, r5
					}
					#endif /* ipconfigSUPPORT_SIGNALS */
					break;
				}

				if( ( ( ( UBaseType_t ) xFlags ) & ( ( UBaseType_t ) FREERTOS_MSG_DONTWAIT ) ) != 0U )
 8005e20:	f009 0810 	and.w	r8, r9, #16
				{
					break;
				}

				/* To ensure this part only executes once. */
				xTimed = pdTRUE;
 8005e24:	2701      	movs	r7, #1
		sockets standard, but this implementation does not use all the parameters. */
		( void ) pxSourceAddressLength;

		while( lPacketCount == 0 )
		{
			if( xTimed == pdFALSE )
 8005e26:	b98e      	cbnz	r6, 8005e4c <FreeRTOS_recvfrom+0x64>
			{
				/* Check to see if the socket is non blocking on the first
				iteration.  */
				xRemainingTime = pxSocket->xReceiveBlockTime;
 8005e28:	69e3      	ldr	r3, [r4, #28]
 8005e2a:	9307      	str	r3, [sp, #28]

				if( xRemainingTime == ( TickType_t ) 0 )
 8005e2c:	b93b      	cbnz	r3, 8005e3e <FreeRTOS_recvfrom+0x56>
				{
					#if( ipconfigSUPPORT_SIGNALS != 0 )
					{
						/* Just check for the interrupt flag. */
						xEventBits = xEventGroupWaitBits( pxSocket->xEventGroup, ( EventBits_t ) eSOCKET_INTR,
 8005e2e:	6860      	ldr	r0, [r4, #4]
 8005e30:	9300      	str	r3, [sp, #0]
 8005e32:	2140      	movs	r1, #64	; 0x40
 8005e34:	2201      	movs	r2, #1
 8005e36:	f7fc f92d 	bl	8002094 <xEventGroupWaitBits>
 8005e3a:	4605      	mov	r5, r0
							pdTRUE /*xClearOnExit*/, pdFALSE /*xWaitAllBits*/, socketDONT_BLOCK );
					}
					#endif /* ipconfigSUPPORT_SIGNALS */
					break;
 8005e3c:	e02f      	b.n	8005e9e <FreeRTOS_recvfrom+0xb6>
				}

				if( ( ( ( UBaseType_t ) xFlags ) & ( ( UBaseType_t ) FREERTOS_MSG_DONTWAIT ) ) != 0U )
 8005e3e:	f1b8 0f00 	cmp.w	r8, #0
 8005e42:	d12c      	bne.n	8005e9e <FreeRTOS_recvfrom+0xb6>

				/* To ensure this part only executes once. */
				xTimed = pdTRUE;

				/* Fetch the current time. */
				vTaskSetTimeOutState( &xTimeOut );
 8005e44:	a805      	add	r0, sp, #20
 8005e46:	f7fd fc89 	bl	800375c <vTaskSetTimeOutState>
				{
					break;
				}

				/* To ensure this part only executes once. */
				xTimed = pdTRUE;
 8005e4a:	463e      	mov	r6, r7
			}

			/* Wait for arrival of data.  While waiting, the IP-task may set the
			'eSOCKET_RECEIVE' bit in 'xEventGroup', if it receives data for this
			socket, thus unblocking this API call. */
			xEventBits = xEventGroupWaitBits( pxSocket->xEventGroup, ( ( EventBits_t ) eSOCKET_RECEIVE ) | ( ( EventBits_t ) eSOCKET_INTR ),
 8005e4c:	9b07      	ldr	r3, [sp, #28]
 8005e4e:	9300      	str	r3, [sp, #0]
 8005e50:	6860      	ldr	r0, [r4, #4]
 8005e52:	2141      	movs	r1, #65	; 0x41
 8005e54:	463a      	mov	r2, r7
 8005e56:	2300      	movs	r3, #0
 8005e58:	f7fc f91c 	bl	8002094 <xEventGroupWaitBits>
 8005e5c:	4605      	mov	r5, r0
				pdTRUE /*xClearOnExit*/, pdFALSE /*xWaitAllBits*/, xRemainingTime );

			#if( ipconfigSUPPORT_SIGNALS != 0 )
			{
				if( ( xEventBits & ( EventBits_t ) eSOCKET_INTR ) != 0U )
 8005e5e:	f010 0f40 	tst.w	r0, #64	; 0x40
 8005e62:	d007      	beq.n	8005e74 <FreeRTOS_recvfrom+0x8c>
				{
					if( ( xEventBits & ( EventBits_t ) eSOCKET_RECEIVE ) != 0U )
 8005e64:	f010 0f01 	tst.w	r0, #1
 8005e68:	d064      	beq.n	8005f34 <FreeRTOS_recvfrom+0x14c>
					{
						/* Shouldn't have cleared the eSOCKET_RECEIVE flag. */
						( void ) xEventGroupSetBits( pxSocket->xEventGroup, ( EventBits_t ) eSOCKET_RECEIVE );
 8005e6a:	6860      	ldr	r0, [r4, #4]
 8005e6c:	2101      	movs	r1, #1
 8005e6e:	f7fc f9c9 	bl	8002204 <xEventGroupSetBits>
 8005e72:	e05f      	b.n	8005f34 <FreeRTOS_recvfrom+0x14c>
			{
				( void ) xEventBits;
			}
			#endif /* ipconfigSUPPORT_SIGNALS */

			if( FREERTOS_SOCK_DGRAM == pxSocket->ucSocketType )
 8005e74:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 8005e78:	2b02      	cmp	r3, #2
 8005e7a:	d101      	bne.n	8005e80 <FreeRTOS_recvfrom+0x98>
			{
				lPacketCount = ( BaseType_t ) listCURRENT_LIST_LENGTH( &( pxSocket->u.xUDP.xWaitingPacketsList ) );
 8005e7c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005e7e:	e002      	b.n	8005e86 <FreeRTOS_recvfrom+0x9e>
			}
			else if( FREERTOS_SOCK_RAW == pxSocket->ucSocketType )
 8005e80:	2b03      	cmp	r3, #3
 8005e82:	d102      	bne.n	8005e8a <FreeRTOS_recvfrom+0xa2>
			{
				lPacketCount = ( BaseType_t ) listCURRENT_LIST_LENGTH( &( pxSocket->u.xRAW.xWaitingPacketsList ) );
 8005e84:	6ba3      	ldr	r3, [r4, #56]	; 0x38
			}
			else{ /* Do Nothing */ }

			if( lPacketCount != 0 )
 8005e86:	2b00      	cmp	r3, #0
 8005e88:	d14d      	bne.n	8005f26 <FreeRTOS_recvfrom+0x13e>
			{
				break;
			}

			/* Has the timeout been reached ? */
			if( xTaskCheckForTimeOut( &xTimeOut, &xRemainingTime ) != pdFALSE )
 8005e8a:	a805      	add	r0, sp, #20
 8005e8c:	a907      	add	r1, sp, #28
 8005e8e:	f7fd fc8d 	bl	80037ac <xTaskCheckForTimeOut>
 8005e92:	2800      	cmp	r0, #0
 8005e94:	d0c7      	beq.n	8005e26 <FreeRTOS_recvfrom+0x3e>
 8005e96:	e043      	b.n	8005f20 <FreeRTOS_recvfrom+0x138>

		/* The function prototype is designed to maintain the expected Berkeley
		sockets standard, but this implementation does not use all the parameters. */
		( void ) pxSourceAddressLength;

		while( lPacketCount == 0 )
 8005e98:	2d00      	cmp	r5, #0
 8005e9a:	d0bf      	beq.n	8005e1c <FreeRTOS_recvfrom+0x34>
 8005e9c:	e043      	b.n	8005f26 <FreeRTOS_recvfrom+0x13e>
				*( ( void** ) pvBuffer ) = ipPOINTER_CAST( void *, &( pxNetworkBuffer->pucEthernetBuffer[ ipUDP_PAYLOAD_OFFSET_IPv4 ] ) );
			}

		}
	#if( ipconfigSUPPORT_SIGNALS != 0 )
		else if( ( xEventBits & ( EventBits_t ) eSOCKET_INTR ) != 0U )
 8005e9e:	f005 0540 	and.w	r5, r5, #64	; 0x40
			iptraceRECVFROM_INTERRUPTED();
		}
	#endif /* ipconfigSUPPORT_SIGNALS */
		else
		{
			lReturn = -pdFREERTOS_ERRNO_EWOULDBLOCK;
 8005ea2:	2d00      	cmp	r5, #0
 8005ea4:	bf14      	ite	ne
 8005ea6:	f06f 0403 	mvnne.w	r4, #3
 8005eaa:	f06f 040a 	mvneq.w	r4, #10
 8005eae:	e043      	b.n	8005f38 <FreeRTOS_recvfrom+0x150>
			taskENTER_CRITICAL();
			{
				/* The owner of the list item is the network buffer. */
				if( FREERTOS_SOCK_DGRAM == pxSocket->ucSocketType )
				{
					pxNetworkBuffer = ipCAST_PTR_TO_TYPE_PTR( NetworkBufferDescriptor_t, listGET_OWNER_OF_HEAD_ENTRY( &( pxSocket->u.xUDP.xWaitingPacketsList ) ) );
 8005eb0:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8005eb2:	f8d3 a00c 	ldr.w	sl, [r3, #12]
 8005eb6:	e004      	b.n	8005ec2 <FreeRTOS_recvfrom+0xda>
				}
				else if( FREERTOS_SOCK_RAW == pxSocket->ucSocketType )
 8005eb8:	2b03      	cmp	r3, #3
				{
					pxNetworkBuffer = ipCAST_PTR_TO_TYPE_PTR( NetworkBufferDescriptor_t, listGET_OWNER_OF_HEAD_ENTRY( &( pxSocket->u.xRAW.xWaitingPacketsList ) ) );
 8005eba:	bf04      	itt	eq
 8005ebc:	6c63      	ldreq	r3, [r4, #68]	; 0x44
 8005ebe:	f8d3 a00c 	ldreq.w	sl, [r3, #12]
				}
				else{ /* Do Nothing */ }

				if( ( ( UBaseType_t ) xFlags & ( UBaseType_t ) FREERTOS_MSG_PEEK ) == 0U )
 8005ec2:	f019 0504 	ands.w	r5, r9, #4
 8005ec6:	d102      	bne.n	8005ece <FreeRTOS_recvfrom+0xe6>
				{
					/* Remove the network buffer from the list of buffers waiting to
					be processed by the socket. */
					( void ) uxListRemove( &( pxNetworkBuffer->xBufferListItem ) );
 8005ec8:	4650      	mov	r0, sl
 8005eca:	f7fc fa45 	bl	8002358 <uxListRemove>
				}
			}
			taskEXIT_CRITICAL();
 8005ece:	f7fb ff99 	bl	8001e04 <vPortExitCritical>

			/* The returned value is the length of the payload data, which is
			calculated at the total packet size minus the headers.
			The validity of `xDataLength` prvProcessIPPacket has been confirmed
			in 'prvProcessIPPacket()'. */
			uxPayloadLength = pxNetworkBuffer->xDataLength - sizeof( UDPPacket_t );
 8005ed2:	f8da 401c 	ldr.w	r4, [sl, #28]
 8005ed6:	3c2a      	subs	r4, #42	; 0x2a
			lReturn = ( int32_t ) uxPayloadLength;

			if( pxSourceAddress != NULL )
 8005ed8:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8005eda:	b133      	cbz	r3, 8005eea <FreeRTOS_recvfrom+0x102>
			{
				pxSourceAddress->sin_port = pxNetworkBuffer->usPort;
 8005edc:	f8ba 3020 	ldrh.w	r3, [sl, #32]
 8005ee0:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8005ee2:	8053      	strh	r3, [r2, #2]
				pxSourceAddress->sin_addr = pxNetworkBuffer->ulIPAddress;
 8005ee4:	f8da 3014 	ldr.w	r3, [sl, #20]
 8005ee8:	6053      	str	r3, [r2, #4]
			}

			if( ( ( UBaseType_t ) xFlags & ( UBaseType_t ) FREERTOS_ZERO_COPY ) == 0U )
 8005eea:	f019 0f01 	tst.w	r9, #1
 8005eee:	d10e      	bne.n	8005f0e <FreeRTOS_recvfrom+0x126>
 8005ef0:	455c      	cmp	r4, fp
 8005ef2:	bfa8      	it	ge
 8005ef4:	465c      	movge	r4, fp
					lReturn = ( int32_t ) uxBufferLength;
				}

				/* Copy the received data into the provided buffer, then release the
				network buffer. */
				pvCopySource = ( const void *) &pxNetworkBuffer->pucEthernetBuffer[ ipUDP_PAYLOAD_OFFSET_IPv4 ];
 8005ef6:	f8da 1018 	ldr.w	r1, [sl, #24]
				( void ) memcpy( pvBuffer, pvCopySource, ( size_t )lReturn );
 8005efa:	9803      	ldr	r0, [sp, #12]
 8005efc:	312a      	adds	r1, #42	; 0x2a
 8005efe:	4622      	mov	r2, r4
 8005f00:	f003 fff0 	bl	8009ee4 <memcpy>

				if( ( ( UBaseType_t ) xFlags & ( UBaseType_t ) FREERTOS_MSG_PEEK ) == 0U )
 8005f04:	b9c5      	cbnz	r5, 8005f38 <FreeRTOS_recvfrom+0x150>
				{
					vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 8005f06:	4650      	mov	r0, sl
 8005f08:	f7fe fb62 	bl	80045d0 <vReleaseNetworkBufferAndDescriptor>
 8005f0c:	e014      	b.n	8005f38 <FreeRTOS_recvfrom+0x150>
			{
				/* The zero copy flag was set.  pvBuffer is not a buffer into which
				the received data can be copied, but a pointer that must be set to
				point to the buffer in which the received data has already been
				placed. */
				*( ( void** ) pvBuffer ) = ipPOINTER_CAST( void *, &( pxNetworkBuffer->pucEthernetBuffer[ ipUDP_PAYLOAD_OFFSET_IPv4 ] ) );
 8005f0e:	f8da 3018 	ldr.w	r3, [sl, #24]
 8005f12:	332a      	adds	r3, #42	; 0x2a
 8005f14:	9a03      	ldr	r2, [sp, #12]
 8005f16:	6013      	str	r3, [r2, #0]
 8005f18:	e00e      	b.n	8005f38 <FreeRTOS_recvfrom+0x150>
size_t uxPayloadLength;

	/* RAW socket are send only (prvValidSocket( pxSocket, FREERTOS_IPPROTO_RAW, pdTRUE ) == pdFALSE) */
	if( (prvValidSocket( pxSocket, FREERTOS_IPPROTO_UDP, pdTRUE ) == pdFALSE) )
	{
		lReturn = -pdFREERTOS_ERRNO_EINVAL;
 8005f1a:	f06f 0415 	mvn.w	r4, #21
 8005f1e:	e00b      	b.n	8005f38 <FreeRTOS_recvfrom+0x150>
			iptraceRECVFROM_INTERRUPTED();
		}
	#endif /* ipconfigSUPPORT_SIGNALS */
		else
		{
			lReturn = -pdFREERTOS_ERRNO_EWOULDBLOCK;
 8005f20:	f06f 040a 	mvn.w	r4, #10
 8005f24:	e008      	b.n	8005f38 <FreeRTOS_recvfrom+0x150>
			}
		} /* while( lPacketCount == 0 ) */

		if( lPacketCount != 0 )
		{
			taskENTER_CRITICAL();
 8005f26:	f7fb ff4b 	bl	8001dc0 <vPortEnterCritical>
			{
				/* The owner of the list item is the network buffer. */
				if( FREERTOS_SOCK_DGRAM == pxSocket->ucSocketType )
 8005f2a:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 8005f2e:	2b02      	cmp	r3, #2
 8005f30:	d1c2      	bne.n	8005eb8 <FreeRTOS_recvfrom+0xd0>
 8005f32:	e7bd      	b.n	8005eb0 <FreeRTOS_recvfrom+0xc8>

		}
	#if( ipconfigSUPPORT_SIGNALS != 0 )
		else if( ( xEventBits & ( EventBits_t ) eSOCKET_INTR ) != 0U )
		{
			lReturn = -pdFREERTOS_ERRNO_EINTR;
 8005f34:	f06f 0403 	mvn.w	r4, #3
			iptraceRECVFROM_TIMEOUT();
		}
	}

	return lReturn;
}
 8005f38:	4620      	mov	r0, r4
 8005f3a:	b009      	add	sp, #36	; 0x24
 8005f3c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08005f40 <FreeRTOS_bind>:
 * be used for both UDP and TCP sockets.  The actual binding will be performed
 * by the IP-task to avoid mutual access to the bound-socket-lists
 * (xBoundUDPSocketsList / xBoundRAWSocketsList / xBoundTCPSocketsList).
 */
BaseType_t FreeRTOS_bind( Socket_t xSocket, struct freertos_sockaddr const * pxAddress, socklen_t xAddressLength )
{
 8005f40:	b530      	push	{r4, r5, lr}
 8005f42:	b085      	sub	sp, #20
 8005f44:	4604      	mov	r4, r0
 8005f46:	460d      	mov	r5, r1
FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
BaseType_t xReturn = 0;

	( void ) xAddressLength;

	configASSERT( xIsCallingFromIPTask() == pdFALSE );
 8005f48:	f7ff f850 	bl	8004fec <xIsCallingFromIPTask>
 8005f4c:	b140      	cbz	r0, 8005f60 <FreeRTOS_bind+0x20>
 8005f4e:	f04f 0314 	mov.w	r3, #20
 8005f52:	f383 8811 	msr	BASEPRI, r3
 8005f56:	f3bf 8f6f 	isb	sy
 8005f5a:	f3bf 8f4f 	dsb	sy
 8005f5e:	e7fe      	b.n	8005f5e <FreeRTOS_bind+0x1e>

	if( ( pxSocket == NULL ) || ( pxSocket == FREERTOS_INVALID_SOCKET ) )
 8005f60:	1e63      	subs	r3, r4, #1
 8005f62:	f113 0f03 	cmn.w	r3, #3
 8005f66:	d824      	bhi.n	8005fb2 <FreeRTOS_bind+0x72>
	{
		xReturn = -pdFREERTOS_ERRNO_EINVAL;
	}
	/* Once a socket is bound to a port, it can not be bound to a different
	port number */
	else if( socketSOCKET_IS_BOUND( pxSocket) )
 8005f68:	69a3      	ldr	r3, [r4, #24]
 8005f6a:	bb2b      	cbnz	r3, 8005fb8 <FreeRTOS_bind+0x78>
	}
	else
	{
		/* Prepare a messages to the IP-task in order to perform the binding.
		The desired port number will be passed in usLocalPort. */
		xBindEvent.eEventType = eSocketBindEvent;
 8005f6c:	2309      	movs	r3, #9
 8005f6e:	f88d 3008 	strb.w	r3, [sp, #8]
		xBindEvent.pvData = xSocket;
 8005f72:	9403      	str	r4, [sp, #12]
		if( pxAddress != NULL )
 8005f74:	b12d      	cbz	r5, 8005f82 <FreeRTOS_bind+0x42>
		{
			pxSocket->usLocalPort = FreeRTOS_ntohs( pxAddress->sin_port );
 8005f76:	886a      	ldrh	r2, [r5, #2]
 8005f78:	0a13      	lsrs	r3, r2, #8
 8005f7a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8005f7e:	84a3      	strh	r3, [r4, #36]	; 0x24
 8005f80:	e001      	b.n	8005f86 <FreeRTOS_bind+0x46>
		}
		else
		{
			/* Caller wants to bind to a random port number. */
			pxSocket->usLocalPort = 0U;
 8005f82:	2300      	movs	r3, #0
 8005f84:	84a3      	strh	r3, [r4, #36]	; 0x24
		}

		/* portMAX_DELAY is used as a the time-out parameter, as binding *must*
		succeed before the socket can be used.  _RB_ The use of an infinite
		block time needs be changed as it could result in the task hanging. */
		if( xSendEventStructToIPTask( &xBindEvent, ( TickType_t ) 0xFFFF/*portMAX_DELAY*/ ) == pdFAIL )
 8005f86:	a802      	add	r0, sp, #8
 8005f88:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8005f8c:	f7ff f90e 	bl	80051ac <xSendEventStructToIPTask>
 8005f90:	b1a8      	cbz	r0, 8005fbe <FreeRTOS_bind+0x7e>
		}
		else
		{
			/* The IP-task will set the 'eSOCKET_BOUND' bit when it has done its
			job. */
			( void ) xEventGroupWaitBits( pxSocket->xEventGroup, ( EventBits_t ) eSOCKET_BOUND, pdTRUE /*xClearOnExit*/, pdFALSE /*xWaitAllBits*/, portMAX_DELAY );
 8005f92:	f04f 33ff 	mov.w	r3, #4294967295
 8005f96:	9300      	str	r3, [sp, #0]
 8005f98:	6860      	ldr	r0, [r4, #4]
 8005f9a:	2110      	movs	r1, #16
 8005f9c:	2201      	movs	r2, #1
 8005f9e:	2300      	movs	r3, #0
 8005fa0:	f7fc f878 	bl	8002094 <xEventGroupWaitBits>
			if( !socketSOCKET_IS_BOUND( pxSocket ) )
 8005fa4:	69a3      	ldr	r3, [r4, #24]
			{
				xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8005fa6:	2b00      	cmp	r3, #0
 8005fa8:	bf14      	ite	ne
 8005faa:	2000      	movne	r0, #0
 8005fac:	f06f 0015 	mvneq.w	r0, #21
 8005fb0:	e007      	b.n	8005fc2 <FreeRTOS_bind+0x82>

	configASSERT( xIsCallingFromIPTask() == pdFALSE );

	if( ( pxSocket == NULL ) || ( pxSocket == FREERTOS_INVALID_SOCKET ) )
	{
		xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8005fb2:	f06f 0015 	mvn.w	r0, #21
 8005fb6:	e004      	b.n	8005fc2 <FreeRTOS_bind+0x82>
	port number */
	else if( socketSOCKET_IS_BOUND( pxSocket) )
	{
		/* The socket is already bound. */
		FreeRTOS_debug_printf( ( "vSocketBind: Socket already bound to %d\n", pxSocket->usLocalPort ) );
		xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8005fb8:	f06f 0015 	mvn.w	r0, #21
 8005fbc:	e001      	b.n	8005fc2 <FreeRTOS_bind+0x82>
		block time needs be changed as it could result in the task hanging. */
		if( xSendEventStructToIPTask( &xBindEvent, ( TickType_t ) 0xFFFF/*portMAX_DELAY*/ ) == pdFAIL )
		{
			/* Failed to wake-up the IP-task, no use to wait for it */
			FreeRTOS_debug_printf( ( "FreeRTOS_bind: send event failed\n" ) );
			xReturn = -pdFREERTOS_ERRNO_ECANCELED;
 8005fbe:	f06f 008b 	mvn.w	r0, #139	; 0x8b
			}
		}
	}

	return xReturn;
}
 8005fc2:	b005      	add	sp, #20
 8005fc4:	bd30      	pop	{r4, r5, pc}
 8005fc6:	bf00      	nop

08005fc8 <FreeRTOS_sendto>:
	return lReturn;
}
/*-----------------------------------------------------------*/

int32_t FreeRTOS_sendto( Socket_t xSocket, const void *pvBuffer, size_t uxTotalDataLength, BaseType_t xFlags, const struct freertos_sockaddr *pxDestinationAddress, socklen_t xDestinationAddressLength )
{
 8005fc8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8005fcc:	b086      	sub	sp, #24
 8005fce:	f8dd a038 	ldr.w	sl, [sp, #56]	; 0x38
NetworkBufferDescriptor_t *pxNetworkBuffer;
void *pvCopyDest;
IPStackEvent_t xStackTxEvent = { eStackTxEvent, NULL };
 8005fd2:	2404      	movs	r4, #4
 8005fd4:	f88d 4010 	strb.w	r4, [sp, #16]
 8005fd8:	2400      	movs	r4, #0
 8005fda:	9405      	str	r4, [sp, #20]

	/* The function prototype is designed to maintain the expected Berkeley
	sockets standard, but this implementation does not use all the
	parameters. */
	( void ) xDestinationAddressLength;
	configASSERT( pvBuffer != NULL );
 8005fdc:	b941      	cbnz	r1, 8005ff0 <FreeRTOS_sendto+0x28>
 8005fde:	f04f 0314 	mov.w	r3, #20
 8005fe2:	f383 8811 	msr	BASEPRI, r3
 8005fe6:	f3bf 8f6f 	isb	sy
 8005fea:	f3bf 8f4f 	dsb	sy
 8005fee:	e7fe      	b.n	8005fee <FreeRTOS_sendto+0x26>
 8005ff0:	4688      	mov	r8, r1
	configASSERT( xSocket != NULL );
 8005ff2:	b940      	cbnz	r0, 8006006 <FreeRTOS_sendto+0x3e>
 8005ff4:	f04f 0314 	mov.w	r3, #20
 8005ff8:	f383 8811 	msr	BASEPRI, r3
 8005ffc:	f3bf 8f6f 	isb	sy
 8006000:	f3bf 8f4f 	dsb	sy
 8006004:	e7fe      	b.n	8006004 <FreeRTOS_sendto+0x3c>

	pxSocket = ( FreeRTOS_Socket_t * ) xSocket;

	/* Check for RAW Sockets with RAW Protocol */
	if( FREERTOS_SOCK_RAW == pxSocket->ucSocketType )
 8006006:	f890 1028 	ldrb.w	r1, [r0, #40]	; 0x28
 800600a:	2903      	cmp	r1, #3
 800600c:	d107      	bne.n	800601e <FreeRTOS_sendto+0x56>
	{
		xStackTxEvent.eEventType = eStackRAWTxEvent;
 800600e:	210d      	movs	r1, #13
 8006010:	f88d 1010 	strb.w	r1, [sp, #16]
		uxPayloadOffset = ( size_t ) 0;
 8006014:	f04f 0900 	mov.w	r9, #0
		uxMaxPayloadLength = ( size_t ) ipMAX_RAW_PAYLOAD_LENGTH;
 8006018:	f44f 6196 	mov.w	r1, #1200	; 0x4b0
 800601c:	e003      	b.n	8006026 <FreeRTOS_sendto+0x5e>
TimeOut_t xTimeOut;
TickType_t xTicksToWait;
int32_t lReturn = 0;
FreeRTOS_Socket_t const * pxSocket;
size_t uxMaxPayloadLength = ( size_t ) ipMAX_UDP_PAYLOAD_LENGTH;
size_t uxPayloadOffset = ( size_t ) ipUDP_PAYLOAD_OFFSET_IPv4;
 800601e:	f04f 092a 	mov.w	r9, #42	; 0x2a
IPStackEvent_t xStackTxEvent = { eStackTxEvent, NULL };
TimeOut_t xTimeOut;
TickType_t xTicksToWait;
int32_t lReturn = 0;
FreeRTOS_Socket_t const * pxSocket;
size_t uxMaxPayloadLength = ( size_t ) ipMAX_UDP_PAYLOAD_LENGTH;
 8006022:	f240 4194 	movw	r1, #1172	; 0x494

		/* TODO: Check validity of RAW packet before proceeding */
	}


	if( uxTotalDataLength <= ( size_t ) uxMaxPayloadLength )
 8006026:	4291      	cmp	r1, r2
 8006028:	d35e      	bcc.n	80060e8 <FreeRTOS_sendto+0x120>
 800602a:	461f      	mov	r7, r3
 800602c:	4614      	mov	r4, r2
 800602e:	4606      	mov	r6, r0
	{
		/* If the socket is not already bound to an address, bind it now.
		Passing NULL as the address parameter tells FreeRTOS_bind() to select
		the address to bind to. */
		if( socketSOCKET_IS_BOUND( pxSocket ) ||
 8006030:	6983      	ldr	r3, [r0, #24]
 8006032:	b92b      	cbnz	r3, 8006040 <FreeRTOS_sendto+0x78>
			( FreeRTOS_bind( xSocket, NULL, 0U ) == 0 ) )
 8006034:	2100      	movs	r1, #0
 8006036:	460a      	mov	r2, r1
 8006038:	f7ff ff82 	bl	8005f40 <FreeRTOS_bind>
	if( uxTotalDataLength <= ( size_t ) uxMaxPayloadLength )
	{
		/* If the socket is not already bound to an address, bind it now.
		Passing NULL as the address parameter tells FreeRTOS_bind() to select
		the address to bind to. */
		if( socketSOCKET_IS_BOUND( pxSocket ) ||
 800603c:	2800      	cmp	r0, #0
 800603e:	d155      	bne.n	80060ec <FreeRTOS_sendto+0x124>
			( FreeRTOS_bind( xSocket, NULL, 0U ) == 0 ) )
		{
			xTicksToWait = pxSocket->xSendBlockTime;
 8006040:	6a33      	ldr	r3, [r6, #32]
					xTicksToWait = ( TickType_t )0;
				}
			}
			#endif /* ipconfigUSE_CALLBACKS */

			if( ( ( UBaseType_t ) xFlags & ( UBaseType_t ) FREERTOS_MSG_DONTWAIT ) != 0U )
 8006042:	f017 0f10 	tst.w	r7, #16
			{
				xTicksToWait = ( TickType_t ) 0;
 8006046:	bf18      	it	ne
 8006048:	2300      	movne	r3, #0
 800604a:	9301      	str	r3, [sp, #4]
			}

			if( ( ( UBaseType_t ) xFlags & ( UBaseType_t ) FREERTOS_ZERO_COPY ) == 0U )
 800604c:	f017 0701 	ands.w	r7, r7, #1
 8006050:	d119      	bne.n	8006086 <FreeRTOS_sendto+0xbe>
			{
				/* Zero copy is not set, so obtain a network buffer into
				which the payload will be copied. */
				vTaskSetTimeOutState( &xTimeOut );
 8006052:	a802      	add	r0, sp, #8
 8006054:	f7fd fb82 	bl	800375c <vTaskSetTimeOutState>

				/* Block until a buffer becomes available, or until a
				timeout has been reached */
				pxNetworkBuffer = pxGetNetworkBufferWithDescriptor( uxPayloadOffset + uxTotalDataLength, xTicksToWait );
 8006058:	eb09 0004 	add.w	r0, r9, r4
 800605c:	9901      	ldr	r1, [sp, #4]
 800605e:	f7fe fad9 	bl	8004614 <pxGetNetworkBufferWithDescriptor>

				if( pxNetworkBuffer != NULL )
 8006062:	4605      	mov	r5, r0
 8006064:	2800      	cmp	r0, #0
 8006066:	d043      	beq.n	80060f0 <FreeRTOS_sendto+0x128>
				{
					pvCopyDest = ( void * ) &pxNetworkBuffer->pucEthernetBuffer[ uxPayloadOffset ];
 8006068:	6980      	ldr	r0, [r0, #24]
					( void ) memcpy( pvCopyDest, pvBuffer, uxTotalDataLength );
 800606a:	4448      	add	r0, r9
 800606c:	4641      	mov	r1, r8
 800606e:	4622      	mov	r2, r4
 8006070:	f003 ff38 	bl	8009ee4 <memcpy>

					if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdTRUE )
 8006074:	a802      	add	r0, sp, #8
 8006076:	a901      	add	r1, sp, #4
 8006078:	f7fd fb98 	bl	80037ac <xTaskCheckForTimeOut>
 800607c:	2801      	cmp	r0, #1
 800607e:	d10b      	bne.n	8006098 <FreeRTOS_sendto+0xd0>
					{
						/* The entire block time has been used up. */
						xTicksToWait = ( TickType_t ) 0;
 8006080:	2300      	movs	r3, #0
 8006082:	9301      	str	r3, [sp, #4]
 8006084:	e008      	b.n	8006098 <FreeRTOS_sendto+0xd0>
					}
				}
			}
			else
			{
				if( eStackRAWTxEvent == xStackTxEvent.eEventType )
 8006086:	f99d 3010 	ldrsb.w	r3, [sp, #16]
 800608a:	2b0d      	cmp	r3, #13
 800608c:	d003      	beq.n	8006096 <FreeRTOS_sendto+0xce>
				else
				{
					/* When zero copy is used, pvBuffer is a pointer to the
					payload of a buffer that has already been obtained from the
					stack.  Obtain the network buffer pointer from the buffer. */
					pxNetworkBuffer = pxUDPPayloadBuffer_to_NetworkBuffer( pvBuffer );
 800608e:	4640      	mov	r0, r8
 8006090:	f7fe ffb8 	bl	8005004 <pxUDPPayloadBuffer_to_NetworkBuffer>
 8006094:	4605      	mov	r5, r0
				}
			}

			if( pxNetworkBuffer != NULL )
 8006096:	b36d      	cbz	r5, 80060f4 <FreeRTOS_sendto+0x12c>
			{
				if(  FREERTOS_SOCK_RAW == pxSocket->ucSocketType )
 8006098:	f896 3028 	ldrb.w	r3, [r6, #40]	; 0x28
 800609c:	2b03      	cmp	r3, #3
 800609e:	d101      	bne.n	80060a4 <FreeRTOS_sendto+0xdc>
				{
					/* Input buffer contains the 'IP Packet[Ethernet + IP Headers] + Payload' or
					 * 'UDP Packet[Ethernet + IP + UDP Headers] + Payload' */
					pxNetworkBuffer->xDataLength = uxTotalDataLength;
 80060a0:	61ec      	str	r4, [r5, #28]
 80060a2:	e006      	b.n	80060b2 <FreeRTOS_sendto+0xea>
				}
				else
				{
					/* xDataLength is the size of the total packet, including the Ethernet header. */
					if( FREERTOS_IPPROTO_UDP == pxSocket->ucProtocol )
 80060a4:	f896 3027 	ldrb.w	r3, [r6, #39]	; 0x27
 80060a8:	2b11      	cmp	r3, #17
					{
						pxNetworkBuffer->xDataLength = uxTotalDataLength + sizeof( UDPPacket_t );
 80060aa:	bf04      	itt	eq
 80060ac:	f104 032a 	addeq.w	r3, r4, #42	; 0x2a
 80060b0:	61eb      	streq	r3, [r5, #28]
					}
				}

				pxNetworkBuffer->usPort = pxDestinationAddress->sin_port;
 80060b2:	f8ba 3002 	ldrh.w	r3, [sl, #2]
 80060b6:	842b      	strh	r3, [r5, #32]
				pxNetworkBuffer->usBoundPort = ( uint16_t ) socketGET_SOCKET_PORT( pxSocket );
 80060b8:	68b3      	ldr	r3, [r6, #8]
 80060ba:	846b      	strh	r3, [r5, #34]	; 0x22
				pxNetworkBuffer->ulIPAddress = pxDestinationAddress->sin_addr;
 80060bc:	f8da 3004 	ldr.w	r3, [sl, #4]
 80060c0:	616b      	str	r3, [r5, #20]

				/* The socket options are passed to the IP layer in the
				space that will eventually get used by the Ethernet header. */
				pxNetworkBuffer->pucEthernetBuffer[ ipSOCKET_OPTIONS_OFFSET ] = pxSocket->ucSocketOptions;
 80060c2:	69ab      	ldr	r3, [r5, #24]
 80060c4:	f896 2026 	ldrb.w	r2, [r6, #38]	; 0x26
 80060c8:	719a      	strb	r2, [r3, #6]

				/* Tell the networking task that the packet needs sending. */
				xStackTxEvent.pvData = pxNetworkBuffer;
 80060ca:	9505      	str	r5, [sp, #20]

				/* Ask the IP-task to send this packet */
				if( xSendEventStructToIPTask( &xStackTxEvent, xTicksToWait ) == pdPASS )
 80060cc:	a804      	add	r0, sp, #16
 80060ce:	9901      	ldr	r1, [sp, #4]
 80060d0:	f7ff f86c 	bl	80051ac <xSendEventStructToIPTask>
 80060d4:	2801      	cmp	r0, #1
 80060d6:	d101      	bne.n	80060dc <FreeRTOS_sendto+0x114>
				{
					/* The packet was successfully sent to the IP task. */
					lReturn = ( int32_t ) uxTotalDataLength;
 80060d8:	4620      	mov	r0, r4
 80060da:	e00e      	b.n	80060fa <FreeRTOS_sendto+0x132>
				}
				else
				{
					/* If the buffer was allocated in this function, release
					it. */
					if( ( ( UBaseType_t ) xFlags & ( UBaseType_t ) FREERTOS_ZERO_COPY ) == 0U )
 80060dc:	b967      	cbnz	r7, 80060f8 <FreeRTOS_sendto+0x130>
					{
						vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 80060de:	4628      	mov	r0, r5
 80060e0:	f7fe fa76 	bl	80045d0 <vReleaseNetworkBufferAndDescriptor>
NetworkBufferDescriptor_t *pxNetworkBuffer;
void *pvCopyDest;
IPStackEvent_t xStackTxEvent = { eStackTxEvent, NULL };
TimeOut_t xTimeOut;
TickType_t xTicksToWait;
int32_t lReturn = 0;
 80060e4:	2000      	movs	r0, #0
 80060e6:	e008      	b.n	80060fa <FreeRTOS_sendto+0x132>
 80060e8:	2000      	movs	r0, #0
 80060ea:	e006      	b.n	80060fa <FreeRTOS_sendto+0x132>
 80060ec:	2000      	movs	r0, #0
 80060ee:	e004      	b.n	80060fa <FreeRTOS_sendto+0x132>
 80060f0:	2000      	movs	r0, #0
 80060f2:	e002      	b.n	80060fa <FreeRTOS_sendto+0x132>
 80060f4:	2000      	movs	r0, #0
 80060f6:	e000      	b.n	80060fa <FreeRTOS_sendto+0x132>
 80060f8:	2000      	movs	r0, #0
		/* The data is longer than the available buffer space. */
		iptraceSENDTO_DATA_TOO_LONG();
	}

	return lReturn;
} /* Tested */
 80060fa:	b006      	add	sp, #24
 80060fc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

08006100 <vSocketBind>:
 * vSocketBind(): internal version of bind() that should not be called directly.
 * 'xInternal' is used for TCP sockets only: it allows to have several
 * (connected) child sockets bound to the same server port.
 */
BaseType_t vSocketBind( FreeRTOS_Socket_t *pxSocket, struct freertos_sockaddr * pxBindAddress, size_t uxAddressLength, BaseType_t xInternal )
{
 8006100:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006104:	b085      	sub	sp, #20
 8006106:	4606      	mov	r6, r0
 8006108:	460d      	mov	r5, r1
 800610a:	4699      	mov	r9, r3
#if( ipconfigALLOW_SOCKET_SEND_WITHOUT_BIND == 1 )
	struct freertos_sockaddr xAddress;
#endif /* ipconfigALLOW_SOCKET_SEND_WITHOUT_BIND */

#if( ipconfigUSE_TCP == 1 )
	if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_TCP )
 800610c:	f890 3027 	ldrb.w	r3, [r0, #39]	; 0x27
 8006110:	2b06      	cmp	r3, #6
 8006112:	d006      	beq.n	8006122 <vSocketBind+0x22>
		pxSocketList = &xBoundTCPSocketsList;
	}
	else
#endif  /* ipconfigUSE_TCP == 1 */
	{
		if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_UDP )
 8006114:	2b11      	cmp	r3, #17
 8006116:	d006      	beq.n	8006126 <vSocketBind+0x26>
		{
			pxSocketList = &xBoundUDPSocketsList;
		}
		else if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_RAW )
		{
			pxSocketList = &xBoundRAWSocketsList;
 8006118:	4f45      	ldr	r7, [pc, #276]	; (8006230 <vSocketBind+0x130>)
 800611a:	2bff      	cmp	r3, #255	; 0xff
 800611c:	bf18      	it	ne
 800611e:	2700      	movne	r7, #0
 8006120:	e002      	b.n	8006128 <vSocketBind+0x28>
#endif /* ipconfigALLOW_SOCKET_SEND_WITHOUT_BIND */

#if( ipconfigUSE_TCP == 1 )
	if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_TCP )
	{
		pxSocketList = &xBoundTCPSocketsList;
 8006122:	4f44      	ldr	r7, [pc, #272]	; (8006234 <vSocketBind+0x134>)
 8006124:	e000      	b.n	8006128 <vSocketBind+0x28>
	else
#endif  /* ipconfigUSE_TCP == 1 */
	{
		if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_UDP )
		{
			pxSocketList = &xBoundUDPSocketsList;
 8006126:	4f44      	ldr	r7, [pc, #272]	; (8006238 <vSocketBind+0x138>)

	/* The function prototype is designed to maintain the expected Berkeley
	sockets standard, but this implementation does not use all the parameters. */
	( void ) uxAddressLength;

	configASSERT( pxSocket != NULL );
 8006128:	b946      	cbnz	r6, 800613c <vSocketBind+0x3c>
 800612a:	f04f 0314 	mov.w	r3, #20
 800612e:	f383 8811 	msr	BASEPRI, r3
 8006132:	f3bf 8f6f 	isb	sy
 8006136:	f3bf 8f4f 	dsb	sy
 800613a:	e7fe      	b.n	800613a <vSocketBind+0x3a>
	configASSERT( pxSocket != FREERTOS_INVALID_SOCKET );
 800613c:	f1b6 3fff 	cmp.w	r6, #4294967295
 8006140:	d108      	bne.n	8006154 <vSocketBind+0x54>
 8006142:	f04f 0314 	mov.w	r3, #20
 8006146:	f383 8811 	msr	BASEPRI, r3
 800614a:	f3bf 8f6f 	isb	sy
 800614e:	f3bf 8f4f 	dsb	sy
 8006152:	e7fe      	b.n	8006152 <vSocketBind+0x52>
		/* pxAddress will be NULL if sendto() was called on a socket without the
		socket being bound to an address. In this case, automatically allocate
		an address to the socket.  There is a small chance that the allocated
		port will already be in use - if that is the case, then the check below
		[pxListFindListItemWithValue()] will result in an error being returned. */
		if( pxAddress == NULL )
 8006154:	2d00      	cmp	r5, #0
 8006156:	d160      	bne.n	800621a <vSocketBind+0x11a>
		{
			pxAddress = &xAddress;
			/* Put the port to zero to be assigned later. */
			pxAddress->sin_port = 0U;
 8006158:	2200      	movs	r2, #0
 800615a:	f8ad 200a 	strh.w	r2, [sp, #10]
		an address to the socket.  There is a small chance that the allocated
		port will already be in use - if that is the case, then the check below
		[pxListFindListItemWithValue()] will result in an error being returned. */
		if( pxAddress == NULL )
		{
			pxAddress = &xAddress;
 800615e:	ad02      	add	r5, sp, #8
 8006160:	e05b      	b.n	800621a <vSocketBind+0x11a>
static uint16_t prvGetPrivatePortNumber( BaseType_t xProtocol )
{
const uint16_t usEphemeralPortCount =
	socketAUTO_PORT_ALLOCATION_MAX_NUMBER - ( socketAUTO_PORT_ALLOCATION_START_NUMBER - 1U );
uint16_t usIterations = usEphemeralPortCount;
uint32_t ulRandomSeed = 0;
 8006162:	2200      	movs	r2, #0
 8006164:	9201      	str	r2, [sp, #4]
uint16_t usResult = 0;
const List_t *pxList;

	if( xProtocol == ( BaseType_t ) FREERTOS_IPPROTO_UDP )
 8006166:	2b11      	cmp	r3, #17
 8006168:	d006      	beq.n	8006178 <vSocketBind+0x78>
	{
		pxList = &xBoundUDPSocketsList;
	}
#if ipconfigUSE_TCP == 1
	else if( xProtocol == ( BaseType_t ) FREERTOS_IPPROTO_TCP )
 800616a:	2b06      	cmp	r3, #6
 800616c:	d006      	beq.n	800617c <vSocketBind+0x7c>
		pxList = &xBoundTCPSocketsList;
	}
#endif
	else if( xProtocol == ( BaseType_t ) FREERTOS_IPPROTO_RAW )
	{
		pxList = &xBoundRAWSocketsList;
 800616e:	4c30      	ldr	r4, [pc, #192]	; (8006230 <vSocketBind+0x130>)
 8006170:	2bff      	cmp	r3, #255	; 0xff
 8006172:	bf18      	it	ne
 8006174:	4614      	movne	r4, r2
 8006176:	e002      	b.n	800617e <vSocketBind+0x7e>
uint16_t usResult = 0;
const List_t *pxList;

	if( xProtocol == ( BaseType_t ) FREERTOS_IPPROTO_UDP )
	{
		pxList = &xBoundUDPSocketsList;
 8006178:	4c2f      	ldr	r4, [pc, #188]	; (8006238 <vSocketBind+0x138>)
 800617a:	e000      	b.n	800617e <vSocketBind+0x7e>
	}
#if ipconfigUSE_TCP == 1
	else if( xProtocol == ( BaseType_t ) FREERTOS_IPPROTO_TCP )
	{
		pxList = &xBoundTCPSocketsList;
 800617c:	4c2d      	ldr	r4, [pc, #180]	; (8006234 <vSocketBind+0x134>)
	}
#endif
	else if( xProtocol == ( BaseType_t ) FREERTOS_IPPROTO_RAW )
	{
		pxList = &xBoundRAWSocketsList;
 800617e:	f44f 487c 	mov.w	r8, #64512	; 0xfc00
		{
			break;
		}

		/* Map the random to a candidate port. */
		usResult =
 8006182:	f8df a0b8 	ldr.w	sl, [pc, #184]	; 800623c <vSocketBind+0x13c>
	/* Find the next available port using the random seed as a starting
	point. */
	do
	{
		/* Only proceed if the random number generator succeeded. */
		if( xApplicationGetRandomNumber( &( ulRandomSeed ) ) == pdFALSE )
 8006186:	a801      	add	r0, sp, #4
 8006188:	f004 fcce 	bl	800ab28 <xApplicationGetRandomNumber>
 800618c:	2800      	cmp	r0, #0
 800618e:	d048      	beq.n	8006222 <vSocketBind+0x122>
		{
			break;
		}

		/* Map the random to a candidate port. */
		usResult =
 8006190:	f8bd 3004 	ldrh.w	r3, [sp, #4]
 8006194:	0a9a      	lsrs	r2, r3, #10
 8006196:	fbaa 1202 	umull	r1, r2, sl, r2
 800619a:	0191      	lsls	r1, r2, #6
 800619c:	1a8a      	subs	r2, r1, r2
 800619e:	eba3 2382 	sub.w	r3, r3, r2, lsl #10
 80061a2:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80061a6:	b29b      	uxth	r3, r3

		/* Check if there's already an open socket with the same protocol
		and port. */
		if( NULL == pxListFindListItemWithValue(
			pxList,
			( TickType_t )FreeRTOS_htons( usResult ) ) )
 80061a8:	ea4f 2b13 	mov.w	fp, r3, lsr #8
 80061ac:	ea4b 2303 	orr.w	r3, fp, r3, lsl #8
 80061b0:	fa1f fb83 	uxth.w	fp, r3
			socketAUTO_PORT_ALLOCATION_START_NUMBER +
			( ( ( uint16_t )ulRandomSeed ) % usEphemeralPortCount );

		/* Check if there's already an open socket with the same protocol
		and port. */
		if( NULL == pxListFindListItemWithValue(
 80061b4:	4620      	mov	r0, r4
 80061b6:	4659      	mov	r1, fp
 80061b8:	f7ff fd02 	bl	8005bc0 <pxListFindListItemWithValue>
 80061bc:	b928      	cbnz	r0, 80061ca <vSocketBind+0xca>
		/* Add a do-while loop to facilitate use of 'break' statements. */
		do
		{
			if( pxAddress->sin_port == 0U )
			{
				pxAddress->sin_port = prvGetPrivatePortNumber( ( BaseType_t ) pxSocket->ucProtocol );
 80061be:	f8a5 b002 	strh.w	fp, [r5, #2]
				if( pxAddress->sin_port == ( uint16_t ) 0U )
 80061c2:	f1bb 0f00 	cmp.w	fp, #0
 80061c6:	d108      	bne.n	80061da <vSocketBind+0xda>
 80061c8:	e021      	b.n	800620e <vSocketBind+0x10e>
 80061ca:	f108 38ff 	add.w	r8, r8, #4294967295
 80061ce:	fa1f f888 	uxth.w	r8, r8
			usResult = 0;
		}

		usIterations--;
	}
	while( usIterations > 0U );
 80061d2:	f1b8 0f00 	cmp.w	r8, #0
 80061d6:	d1d6      	bne.n	8006186 <vSocketBind+0x86>
 80061d8:	e023      	b.n	8006222 <vSocketBind+0x122>
			confirmed that the socket was not yet bound to a port.  If it is called
			from the IP-task, no such check is necessary. */

			/* Check to ensure the port is not already in use.  If the bind is
			called internally, a port MAY be used by more than one socket. */
			if( ( ( xInternal == pdFALSE ) || ( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP ) ) &&
 80061da:	f1b9 0f00 	cmp.w	r9, #0
 80061de:	d003      	beq.n	80061e8 <vSocketBind+0xe8>
 80061e0:	f896 3027 	ldrb.w	r3, [r6, #39]	; 0x27
 80061e4:	2b06      	cmp	r3, #6
 80061e6:	d004      	beq.n	80061f2 <vSocketBind+0xf2>
				( pxListFindListItemWithValue( pxSocketList, ( TickType_t ) pxAddress->sin_port ) != NULL ) )
 80061e8:	4638      	mov	r0, r7
 80061ea:	8869      	ldrh	r1, [r5, #2]
 80061ec:	f7ff fce8 	bl	8005bc0 <pxListFindListItemWithValue>
			confirmed that the socket was not yet bound to a port.  If it is called
			from the IP-task, no such check is necessary. */

			/* Check to ensure the port is not already in use.  If the bind is
			called internally, a port MAY be used by more than one socket. */
			if( ( ( xInternal == pdFALSE ) || ( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP ) ) &&
 80061f0:	b980      	cbnz	r0, 8006214 <vSocketBind+0x114>
			}
			else
			{
				/* Allocate the port number to the socket.
				This macro will set 'xBoundSocketListItem->xItemValue' */
				socketSET_SOCKET_PORT( pxSocket, pxAddress->sin_port );
 80061f2:	886b      	ldrh	r3, [r5, #2]
 80061f4:	60b3      	str	r3, [r6, #8]

				/* And also store it in a socket field 'usLocalPort' in host-byte-order,
				mostly used for logging and debugging purposes */
				pxSocket->usLocalPort = FreeRTOS_ntohs( pxAddress->sin_port );
 80061f6:	886a      	ldrh	r2, [r5, #2]
 80061f8:	0a13      	lsrs	r3, r2, #8
 80061fa:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80061fe:	84b3      	strh	r3, [r6, #36]	; 0x24
					}
					#endif /* ipconfigETHERNET_DRIVER_FILTERS_PACKETS */

					/* Add the socket to 'xBoundUDPSocketsList' or 'xBoundRAWSocketsList
					 * 'or 'xBoundTCPSocketsList' */
					vListInsertEnd( pxSocketList, &( pxSocket->xBoundSocketListItem ) );
 8006200:	4638      	mov	r0, r7
 8006202:	f106 0108 	add.w	r1, r6, #8
 8006206:	f7fc f881 	bl	800230c <vListInsertEnd>
 * 'xInternal' is used for TCP sockets only: it allows to have several
 * (connected) child sockets bound to the same server port.
 */
BaseType_t vSocketBind( FreeRTOS_Socket_t *pxSocket, struct freertos_sockaddr * pxBindAddress, size_t uxAddressLength, BaseType_t xInternal )
{
BaseType_t xReturn = 0; /* In Berkeley sockets, 0 means pass for bind(). */
 800620a:	2000      	movs	r0, #0
 800620c:	e00d      	b.n	800622a <vSocketBind+0x12a>
			if( pxAddress->sin_port == 0U )
			{
				pxAddress->sin_port = prvGetPrivatePortNumber( ( BaseType_t ) pxSocket->ucProtocol );
				if( pxAddress->sin_port == ( uint16_t ) 0U )
				{
					xReturn = -pdFREERTOS_ERRNO_EADDRNOTAVAIL;
 800620e:	f06f 007c 	mvn.w	r0, #124	; 0x7c
 8006212:	e00a      	b.n	800622a <vSocketBind+0x12a>
				( pxListFindListItemWithValue( pxSocketList, ( TickType_t ) pxAddress->sin_port ) != NULL ) )
			{
				FreeRTOS_debug_printf( ( "vSocketBind: %sP port %d in use\n",
					( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_TCP ) ? "TC" : "UD",
					FreeRTOS_ntohs( pxAddress->sin_port ) ) );
				xReturn = -pdFREERTOS_ERRNO_EADDRINUSE;
 8006214:	f06f 006f 	mvn.w	r0, #111	; 0x6f
 8006218:	e007      	b.n	800622a <vSocketBind+0x12a>
	#endif
	{
		/* Add a do-while loop to facilitate use of 'break' statements. */
		do
		{
			if( pxAddress->sin_port == 0U )
 800621a:	886a      	ldrh	r2, [r5, #2]
 800621c:	2a00      	cmp	r2, #0
 800621e:	d1dc      	bne.n	80061da <vSocketBind+0xda>
 8006220:	e79f      	b.n	8006162 <vSocketBind+0x62>
			{
				pxAddress->sin_port = prvGetPrivatePortNumber( ( BaseType_t ) pxSocket->ucProtocol );
 8006222:	2300      	movs	r3, #0
 8006224:	806b      	strh	r3, [r5, #2]
				if( pxAddress->sin_port == ( uint16_t ) 0U )
				{
					xReturn = -pdFREERTOS_ERRNO_EADDRNOTAVAIL;
 8006226:	f06f 007c 	mvn.w	r0, #124	; 0x7c
	{
		iptraceBIND_FAILED( xSocket, ( FreeRTOS_ntohs( pxAddress->sin_port ) ) );
	}

	return xReturn;
} /* Tested */
 800622a:	b005      	add	sp, #20
 800622c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006230:	2000d3dc 	.word	0x2000d3dc
 8006234:	2000d4f8 	.word	0x2000d4f8
 8006238:	2000d3c8 	.word	0x2000d3c8
 800623c:	04104114 	.word	0x04104114

08006240 <FreeRTOS_closesocket>:
 * In case of a TCP socket: the connection will not be closed automatically
 * Subsequent messages for the closed socket will be responded to with a RST
 * The IP-task will actually close the socket, after receiving a 'eSocketCloseEvent' message
 */
BaseType_t FreeRTOS_closesocket( Socket_t xSocket )
{
 8006240:	b500      	push	{lr}
 8006242:	b083      	sub	sp, #12
BaseType_t xResult;
#if( ipconfigUSE_TCP == 1 ) && ( ipconfigUSE_CALLBACKS == 1 )
	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * )xSocket;
#endif
IPStackEvent_t xCloseEvent;
xCloseEvent.eEventType = eSocketCloseEvent;
 8006244:	230a      	movs	r3, #10
 8006246:	f88d 3000 	strb.w	r3, [sp]
xCloseEvent.pvData = xSocket;
 800624a:	9001      	str	r0, [sp, #4]

	if( ( xSocket == NULL ) || ( xSocket == FREERTOS_INVALID_SOCKET ) )
 800624c:	3801      	subs	r0, #1
 800624e:	f110 0f03 	cmn.w	r0, #3
 8006252:	d809      	bhi.n	8006268 <FreeRTOS_closesocket+0x28>
		packet handling. */

		/* Note when changing the time-out value below, it must be checked who is calling
		this function. If it is called by the IP-task, a deadlock could occur.
		The IP-task would only call it in case of a user call-back */
		if( xSendEventStructToIPTask( &xCloseEvent, ( TickType_t ) 0 ) == pdFAIL )
 8006254:	4668      	mov	r0, sp
 8006256:	2100      	movs	r1, #0
 8006258:	f7fe ffa8 	bl	80051ac <xSendEventStructToIPTask>
 800625c:	2800      	cmp	r0, #0
			FreeRTOS_debug_printf( ( "FreeRTOS_closesocket: failed\n" ) );
			xResult = -1;
		}
		else
		{
			xResult = 1;
 800625e:	bf0c      	ite	eq
 8006260:	f04f 30ff 	moveq.w	r0, #4294967295
 8006264:	2001      	movne	r0, #1
 8006266:	e000      	b.n	800626a <FreeRTOS_closesocket+0x2a>
xCloseEvent.eEventType = eSocketCloseEvent;
xCloseEvent.pvData = xSocket;

	if( ( xSocket == NULL ) || ( xSocket == FREERTOS_INVALID_SOCKET ) )
	{
		xResult = 0;
 8006268:	2000      	movs	r0, #0
			xResult = 1;
		}
	}

	return xResult;
}
 800626a:	b003      	add	sp, #12
 800626c:	f85d fb04 	ldr.w	pc, [sp], #4

08006270 <vSocketClose>:

/* This is the internal version of FreeRTOS_closesocket()
 * It will be called by the IPtask only to avoid problems with synchronicity
 */
void *vSocketClose( FreeRTOS_Socket_t *pxSocket )
{
 8006270:	b538      	push	{r3, r4, r5, lr}
 8006272:	4604      	mov	r4, r0
NetworkBufferDescriptor_t *pxNetworkBuffer;

	#if( ipconfigUSE_TCP == 1 )
	{
		/* For TCP: clean up a little more. */
		if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_TCP )
 8006274:	f890 3027 	ldrb.w	r3, [r0, #39]	; 0x27
 8006278:	2b06      	cmp	r3, #6
 800627a:	d128      	bne.n	80062ce <vSocketClose+0x5e>
		{
			#if( ipconfigUSE_TCP_WIN == 1 )
			{
				if( pxSocket->u.xTCP.pxAckMessage != NULL )
 800627c:	6fc0      	ldr	r0, [r0, #124]	; 0x7c
 800627e:	b108      	cbz	r0, 8006284 <vSocketClose+0x14>
				{
					vReleaseNetworkBufferAndDescriptor( pxSocket->u.xTCP.pxAckMessage );
 8006280:	f7fe f9a6 	bl	80045d0 <vReleaseNetworkBufferAndDescriptor>
				}
				/* Free the resources which were claimed by the tcpWin member */
				vTCPWindowDestroy( &pxSocket->u.xTCP.xTCPWindow );
 8006284:	f104 00d8 	add.w	r0, r4, #216	; 0xd8
 8006288:	f002 fd76 	bl	8008d78 <vTCPWindowDestroy>
			}
			#endif /* ipconfigUSE_TCP_WIN */

			/* Free the input and output streams */
			if( pxSocket->u.xTCP.rxStream != NULL )
 800628c:	6f60      	ldr	r0, [r4, #116]	; 0x74
 800628e:	b108      	cbz	r0, 8006294 <vSocketClose+0x24>
			{
				iptraceMEM_STATS_DELETE( pxSocket->u.xTCP.rxStream );
				vPortFreeLarge( pxSocket->u.xTCP.rxStream );
 8006290:	f7fd fec8 	bl	8004024 <vPortFree>
			}

			if( pxSocket->u.xTCP.txStream != NULL )
 8006294:	6fa0      	ldr	r0, [r4, #120]	; 0x78
 8006296:	b108      	cbz	r0, 800629c <vSocketClose+0x2c>
			{
				iptraceMEM_STATS_DELETE( pxSocket->u.xTCP.txStream );
				vPortFreeLarge( pxSocket->u.xTCP.txStream );
 8006298:	f7fd fec4 	bl	8004024 <vPortFree>
	static void prvTCPSetSocketCount( FreeRTOS_Socket_t const * pxSocketToDelete )
	{
	const ListItem_t *pxIterator;
	const ListItem_t *pxEnd = listGET_END_MARKER( &xBoundTCPSocketsList );
	FreeRTOS_Socket_t *pxOtherSocket;
	uint16_t usLocalPort = pxSocketToDelete->usLocalPort;
 800629c:	8ca5      	ldrh	r5, [r4, #36]	; 0x24

		for( pxIterator  = listGET_NEXT( pxEnd );
 800629e:	4a1c      	ldr	r2, [pc, #112]	; (8006310 <vSocketClose+0xa0>)
 80062a0:	68d3      	ldr	r3, [r2, #12]
 80062a2:	3208      	adds	r2, #8
 80062a4:	4293      	cmp	r3, r2
 80062a6:	d012      	beq.n	80062ce <vSocketClose+0x5e>
 80062a8:	4610      	mov	r0, r2
			 pxIterator != pxEnd;
			 pxIterator  = listGET_NEXT( pxIterator ) )
		{
			pxOtherSocket = ipCAST_PTR_TO_TYPE_PTR( FreeRTOS_Socket_t, listGET_LIST_ITEM_OWNER( pxIterator ) );
 80062aa:	68da      	ldr	r2, [r3, #12]
			if( ( pxOtherSocket->u.xTCP.ucTCPState == ( uint8_t ) eTCP_LISTEN ) &&
 80062ac:	f892 1053 	ldrb.w	r1, [r2, #83]	; 0x53
 80062b0:	2901      	cmp	r1, #1
 80062b2:	d109      	bne.n	80062c8 <vSocketClose+0x58>
 80062b4:	8c91      	ldrh	r1, [r2, #36]	; 0x24
 80062b6:	42a9      	cmp	r1, r5
 80062b8:	d106      	bne.n	80062c8 <vSocketClose+0x58>
				( pxOtherSocket->usLocalPort == usLocalPort ) &&
				( pxOtherSocket->u.xTCP.usChildCount != 0U ) )
 80062ba:	f8b2 104e 	ldrh.w	r1, [r2, #78]	; 0x4e
			 pxIterator != pxEnd;
			 pxIterator  = listGET_NEXT( pxIterator ) )
		{
			pxOtherSocket = ipCAST_PTR_TO_TYPE_PTR( FreeRTOS_Socket_t, listGET_LIST_ITEM_OWNER( pxIterator ) );
			if( ( pxOtherSocket->u.xTCP.ucTCPState == ( uint8_t ) eTCP_LISTEN ) &&
				( pxOtherSocket->usLocalPort == usLocalPort ) &&
 80062be:	b119      	cbz	r1, 80062c8 <vSocketClose+0x58>
				( pxOtherSocket->u.xTCP.usChildCount != 0U ) )
			{
				pxOtherSocket->u.xTCP.usChildCount--;
 80062c0:	3901      	subs	r1, #1
 80062c2:	f8a2 104e 	strh.w	r1, [r2, #78]	; 0x4e
 80062c6:	e002      	b.n	80062ce <vSocketClose+0x5e>
	FreeRTOS_Socket_t *pxOtherSocket;
	uint16_t usLocalPort = pxSocketToDelete->usLocalPort;

		for( pxIterator  = listGET_NEXT( pxEnd );
			 pxIterator != pxEnd;
			 pxIterator  = listGET_NEXT( pxIterator ) )
 80062c8:	685b      	ldr	r3, [r3, #4]
	const ListItem_t *pxIterator;
	const ListItem_t *pxEnd = listGET_END_MARKER( &xBoundTCPSocketsList );
	FreeRTOS_Socket_t *pxOtherSocket;
	uint16_t usLocalPort = pxSocketToDelete->usLocalPort;

		for( pxIterator  = listGET_NEXT( pxEnd );
 80062ca:	4283      	cmp	r3, r0
 80062cc:	d1ed      	bne.n	80062aa <vSocketClose+0x3a>
	}
	#endif  /* ipconfigUSE_TCP == 1 */

	/* Socket must be unbound first, to ensure no more packets are queued on
	it. */
	if( socketSOCKET_IS_BOUND( pxSocket ) )
 80062ce:	69a3      	ldr	r3, [r4, #24]
 80062d0:	b11b      	cbz	r3, 80062da <vSocketClose+0x6a>
		{
			vTaskSuspendAll();
		}
		#endif /* ipconfigETHERNET_DRIVER_FILTERS_PACKETS */

		( void ) uxListRemove( &( pxSocket->xBoundSocketListItem ) );
 80062d2:	f104 0008 	add.w	r0, r4, #8
 80062d6:	f7fc f83f 	bl	8002358 <uxListRemove>
		#endif /* ipconfigETHERNET_DRIVER_FILTERS_PACKETS */
	}

	/* Now the socket is not bound the list of waiting packets can be
	drained. */
	if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_UDP )
 80062da:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
 80062de:	2b11      	cmp	r3, #17
 80062e0:	d10c      	bne.n	80062fc <vSocketClose+0x8c>
	{
		while( listCURRENT_LIST_LENGTH( &( pxSocket->u.xUDP.xWaitingPacketsList ) ) > 0U )
 80062e2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80062e4:	b153      	cbz	r3, 80062fc <vSocketClose+0x8c>
		{
			pxNetworkBuffer = ipCAST_PTR_TO_TYPE_PTR( NetworkBufferDescriptor_t, listGET_OWNER_OF_HEAD_ENTRY( &( pxSocket->u.xUDP.xWaitingPacketsList ) ) );
 80062e6:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80062e8:	68dd      	ldr	r5, [r3, #12]
			( void ) uxListRemove( &( pxNetworkBuffer->xBufferListItem ) );
 80062ea:	4628      	mov	r0, r5
 80062ec:	f7fc f834 	bl	8002358 <uxListRemove>
			vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 80062f0:	4628      	mov	r0, r5
 80062f2:	f7fe f96d 	bl	80045d0 <vReleaseNetworkBufferAndDescriptor>

	/* Now the socket is not bound the list of waiting packets can be
	drained. */
	if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_UDP )
	{
		while( listCURRENT_LIST_LENGTH( &( pxSocket->u.xUDP.xWaitingPacketsList ) ) > 0U )
 80062f6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80062f8:	2b00      	cmp	r3, #0
 80062fa:	d1f4      	bne.n	80062e6 <vSocketClose+0x76>
			( void ) uxListRemove( &( pxNetworkBuffer->xBufferListItem ) );
			vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
		}
	}

	if( pxSocket->xEventGroup != NULL )
 80062fc:	6860      	ldr	r0, [r4, #4]
 80062fe:	b108      	cbz	r0, 8006304 <vSocketClose+0x94>
	{
		vEventGroupDelete( pxSocket->xEventGroup );
 8006300:	f7fb ffce 	bl	80022a0 <vEventGroupDelete>
	}
	#endif /* ( ipconfigUSE_TCP == 1 ) && ( ipconfigHAS_DEBUG_PRINTF != 0 ) */

	/* Anf finally, after all resources have been freed, free the socket space */
	iptraceMEM_STATS_DELETE( pxSocket );
	vPortFreeSocket( pxSocket );
 8006304:	4620      	mov	r0, r4
 8006306:	f7fd fe8d 	bl	8004024 <vPortFree>

	return NULL;
} /* Tested */
 800630a:	2000      	movs	r0, #0
 800630c:	bd38      	pop	{r3, r4, r5, pc}
 800630e:	bf00      	nop
 8006310:	2000d4f8 	.word	0x2000d4f8

08006314 <pxUDPSocketLookup>:
} /* Tested */

/*-----------------------------------------------------------*/

FreeRTOS_Socket_t *pxUDPSocketLookup( UBaseType_t uxLocalPort )
{
 8006314:	b508      	push	{r3, lr}
 8006316:	4601      	mov	r1, r0

	/* Looking up a socket is quite simple, find a match with the local port.

	See if there is a list item associated with the port number on the
	list of bound sockets. */
	pxListItem = pxListFindListItemWithValue( &xBoundUDPSocketsList, ( TickType_t ) uxLocalPort );
 8006318:	4808      	ldr	r0, [pc, #32]	; (800633c <pxUDPSocketLookup+0x28>)
 800631a:	f7ff fc51 	bl	8005bc0 <pxListFindListItemWithValue>

	if( pxListItem != NULL )
 800631e:	b150      	cbz	r0, 8006336 <pxUDPSocketLookup+0x22>
	{
		/* The owner of the list item is the socket itself. */
		pxSocket = ipCAST_PTR_TO_TYPE_PTR( FreeRTOS_Socket_t, listGET_LIST_ITEM_OWNER( pxListItem ) );
 8006320:	68c0      	ldr	r0, [r0, #12]
		configASSERT( pxSocket != NULL );
 8006322:	b948      	cbnz	r0, 8006338 <pxUDPSocketLookup+0x24>
 8006324:	f04f 0314 	mov.w	r3, #20
 8006328:	f383 8811 	msr	BASEPRI, r3
 800632c:	f3bf 8f6f 	isb	sy
 8006330:	f3bf 8f4f 	dsb	sy
 8006334:	e7fe      	b.n	8006334 <pxUDPSocketLookup+0x20>
/*-----------------------------------------------------------*/

FreeRTOS_Socket_t *pxUDPSocketLookup( UBaseType_t uxLocalPort )
{
const ListItem_t *pxListItem;
FreeRTOS_Socket_t *pxSocket = NULL;
 8006336:	2000      	movs	r0, #0
		/* The owner of the list item is the socket itself. */
		pxSocket = ipCAST_PTR_TO_TYPE_PTR( FreeRTOS_Socket_t, listGET_LIST_ITEM_OWNER( pxListItem ) );
		configASSERT( pxSocket != NULL );
	}
	return pxSocket;
}
 8006338:	bd08      	pop	{r3, pc}
 800633a:	bf00      	nop
 800633c:	2000d3c8 	.word	0x2000d3c8

08006340 <FreeRTOS_inet_ntoa>:

/*-----------------------------------------------------------*/

const char *FreeRTOS_inet_ntoa( uint32_t ulIPAddress, char *pcBuffer )
{
 8006340:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8006344:	b084      	sub	sp, #16
 8006346:	f10d 0c10 	add.w	ip, sp, #16
 800634a:	f84c 0d0c 	str.w	r0, [ip, #-12]!
socklen_t uxNibble;
socklen_t uxIndex = 0;
 800634e:	2200      	movs	r2, #0
const socklen_t uxSize = 16;

/* Each nibble is expressed in at most 3 digits, like e.g. "192". */
#define sockDIGIT_COUNT		( 3U )

	for( uxNibble = 0; uxNibble < ipSIZE_OF_IPv4_ADDRESS; uxNibble++ )
 8006350:	4696      	mov	lr, r2
	socklen_t uxSource = ( socklen_t ) sockDIGIT_COUNT - ( socklen_t ) 1U;
	socklen_t uxNeeded;

		for( ;; )
		{
			pucDigits[ uxSource ] = ucValue % ( uint8_t ) 10U;
 8006352:	4828      	ldr	r0, [pc, #160]	; (80063f4 <FreeRTOS_inet_ntoa+0xb4>)
			uxSource--;
		}
		pucDigits[ 0 ] = ucValue;

		/* Skip leading zeros. */
		for( uxSource = 0; uxSource < ( ( socklen_t ) sockDIGIT_COUNT - ( socklen_t ) 1U ); uxSource++ )
 8006354:	4691      	mov	r9, r2
			pcBuffer[ uxIndex ] = ( char ) ( pucDigits[ uxSource ] + ( char ) '0' );
			uxIndex++;
		}
		if( uxNibble < ( ipSIZE_OF_IPv4_ADDRESS - 1U ) )
		{
			pcBuffer[ uxIndex ] = '.';
 8006356:	f04f 082e 	mov.w	r8, #46	; 0x2e
#define sockDIGIT_COUNT		( 3U )

	for( uxNibble = 0; uxNibble < ipSIZE_OF_IPv4_ADDRESS; uxNibble++ )
	{
	uint8_t pucDigits[ sockDIGIT_COUNT ];
	uint8_t ucValue = pucAddress[ uxNibble ];
 800635a:	f81c 4b01 	ldrb.w	r4, [ip], #1
	socklen_t uxSource = ( socklen_t ) sockDIGIT_COUNT - ( socklen_t ) 1U;
	socklen_t uxNeeded;

		for( ;; )
		{
			pucDigits[ uxSource ] = ucValue % ( uint8_t ) 10U;
 800635e:	fba0 5304 	umull	r5, r3, r0, r4
 8006362:	08db      	lsrs	r3, r3, #3
 8006364:	eb03 0583 	add.w	r5, r3, r3, lsl #2
 8006368:	eba4 0445 	sub.w	r4, r4, r5, lsl #1
 800636c:	f88d 400e 	strb.w	r4, [sp, #14]
			ucValue /= ( uint8_t ) 10U;
 8006370:	b2db      	uxtb	r3, r3
	socklen_t uxSource = ( socklen_t ) sockDIGIT_COUNT - ( socklen_t ) 1U;
	socklen_t uxNeeded;

		for( ;; )
		{
			pucDigits[ uxSource ] = ucValue % ( uint8_t ) 10U;
 8006372:	fba0 5403 	umull	r5, r4, r0, r3
 8006376:	08e4      	lsrs	r4, r4, #3
 8006378:	eb04 0584 	add.w	r5, r4, r4, lsl #2
 800637c:	eba3 0345 	sub.w	r3, r3, r5, lsl #1
 8006380:	f88d 300d 	strb.w	r3, [sp, #13]
			ucValue /= ( uint8_t ) 10U;
 8006384:	b2e4      	uxtb	r4, r4
			{
				break;
			}
			uxSource--;
		}
		pucDigits[ 0 ] = ucValue;
 8006386:	f88d 400c 	strb.w	r4, [sp, #12]

		/* Skip leading zeros. */
		for( uxSource = 0; uxSource < ( ( socklen_t ) sockDIGIT_COUNT - ( socklen_t ) 1U ); uxSource++ )
		{
			if( pucDigits[ uxSource ] != 0U )
 800638a:	bb54      	cbnz	r4, 80063e2 <FreeRTOS_inet_ntoa+0xa2>
 800638c:	b2db      	uxtb	r3, r3
			uxSource--;
		}
		pucDigits[ 0 ] = ucValue;

		/* Skip leading zeros. */
		for( uxSource = 0; uxSource < ( ( socklen_t ) sockDIGIT_COUNT - ( socklen_t ) 1U ); uxSource++ )
 800638e:	2b00      	cmp	r3, #0
 8006390:	bf14      	ite	ne
 8006392:	2701      	movne	r7, #1
 8006394:	2702      	moveq	r7, #2
 8006396:	1d13      	adds	r3, r2, #4
				break;
			}
		}
		/* Write e.g. "192.", which is 3 digits and a dot. */
		uxNeeded = ( ( socklen_t ) sockDIGIT_COUNT - uxSource ) + 1U;
		if( ( uxIndex + uxNeeded ) > uxSize )
 8006398:	1bdb      	subs	r3, r3, r7
 800639a:	2b10      	cmp	r3, #16
 800639c:	d901      	bls.n	80063a2 <FreeRTOS_inet_ntoa+0x62>
		{
			/* The result won't fit. */
			pcResult = NULL;
 800639e:	2100      	movs	r1, #0
 80063a0:	e024      	b.n	80063ec <FreeRTOS_inet_ntoa+0xac>
 80063a2:	ab03      	add	r3, sp, #12
 80063a4:	19de      	adds	r6, r3, r7
 80063a6:	188d      	adds	r5, r1, r2
			uxSource--;
		}
		pucDigits[ 0 ] = ucValue;

		/* Skip leading zeros. */
		for( uxSource = 0; uxSource < ( ( socklen_t ) sockDIGIT_COUNT - ( socklen_t ) 1U ); uxSource++ )
 80063a8:	4614      	mov	r4, r2
 80063aa:	e000      	b.n	80063ae <FreeRTOS_inet_ntoa+0x6e>
		}
	
		for( ; uxSource < ( socklen_t ) sockDIGIT_COUNT; uxSource++ )
		{
			pcBuffer[ uxIndex ] = ( char ) ( pucDigits[ uxSource ] + ( char ) '0' );
			uxIndex++;
 80063ac:	4654      	mov	r4, sl
			break;
		}
	
		for( ; uxSource < ( socklen_t ) sockDIGIT_COUNT; uxSource++ )
		{
			pcBuffer[ uxIndex ] = ( char ) ( pucDigits[ uxSource ] + ( char ) '0' );
 80063ae:	f816 3b01 	ldrb.w	r3, [r6], #1
 80063b2:	3330      	adds	r3, #48	; 0x30
 80063b4:	f805 3b01 	strb.w	r3, [r5], #1
			uxIndex++;
 80063b8:	f104 0a01 	add.w	sl, r4, #1
 80063bc:	ebc2 030a 	rsb	r3, r2, sl
 80063c0:	443b      	add	r3, r7
			/* The result won't fit. */
			pcResult = NULL;
			break;
		}
	
		for( ; uxSource < ( socklen_t ) sockDIGIT_COUNT; uxSource++ )
 80063c2:	2b02      	cmp	r3, #2
 80063c4:	d9f2      	bls.n	80063ac <FreeRTOS_inet_ntoa+0x6c>
		{
			pcBuffer[ uxIndex ] = ( char ) ( pucDigits[ uxSource ] + ( char ) '0' );
			uxIndex++;
		}
		if( uxNibble < ( ipSIZE_OF_IPv4_ADDRESS - 1U ) )
 80063c6:	f1be 0f02 	cmp.w	lr, #2
		{
			pcBuffer[ uxIndex ] = '.';
 80063ca:	bf94      	ite	ls
 80063cc:	f801 800a 	strbls.w	r8, [r1, sl]
		}
		else
		{
			pcBuffer[ uxIndex ] = '\0';
 80063d0:	f801 900a 	strbhi.w	r9, [r1, sl]
		}
		uxIndex++;
 80063d4:	1ca2      	adds	r2, r4, #2
const socklen_t uxSize = 16;

/* Each nibble is expressed in at most 3 digits, like e.g. "192". */
#define sockDIGIT_COUNT		( 3U )

	for( uxNibble = 0; uxNibble < ipSIZE_OF_IPv4_ADDRESS; uxNibble++ )
 80063d6:	f10e 0e01 	add.w	lr, lr, #1
 80063da:	f1be 0f04 	cmp.w	lr, #4
 80063de:	d1bc      	bne.n	800635a <FreeRTOS_inet_ntoa+0x1a>
 80063e0:	e004      	b.n	80063ec <FreeRTOS_inet_ntoa+0xac>
				break;
			}
		}
		/* Write e.g. "192.", which is 3 digits and a dot. */
		uxNeeded = ( ( socklen_t ) sockDIGIT_COUNT - uxSource ) + 1U;
		if( ( uxIndex + uxNeeded ) > uxSize )
 80063e2:	1d13      	adds	r3, r2, #4
 80063e4:	2b10      	cmp	r3, #16
 80063e6:	d8da      	bhi.n	800639e <FreeRTOS_inet_ntoa+0x5e>
			uxSource--;
		}
		pucDigits[ 0 ] = ucValue;

		/* Skip leading zeros. */
		for( uxSource = 0; uxSource < ( ( socklen_t ) sockDIGIT_COUNT - ( socklen_t ) 1U ); uxSource++ )
 80063e8:	464f      	mov	r7, r9
 80063ea:	e7da      	b.n	80063a2 <FreeRTOS_inet_ntoa+0x62>
		}
		uxIndex++;
	}

	return pcResult;
}
 80063ec:	4608      	mov	r0, r1
 80063ee:	b004      	add	sp, #16
 80063f0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80063f4:	cccccccd 	.word	0xcccccccd

080063f8 <FreeRTOS_inet_ntop4>:
	return pcResult;
}
/*-----------------------------------------------------------*/

const char *FreeRTOS_inet_ntop4( const void *pvSource, char *pcDestination, socklen_t uxSize )
{
 80063f8:	b510      	push	{r4, lr}
 80063fa:	b082      	sub	sp, #8
uint32_t ulIPAddress;
void *pvCopyDest;
const char *pcReturn;

	if( uxSize < 16U )
 80063fc:	2a0f      	cmp	r2, #15
 80063fe:	d906      	bls.n	800640e <FreeRTOS_inet_ntop4+0x16>
 8006400:	460c      	mov	r4, r1
		pcReturn = NULL;
	}
	else
	{
		pvCopyDest = ( void * ) &ulIPAddress;
		( void ) memcpy( pvCopyDest, pvSource, sizeof( ulIPAddress ) );
 8006402:	6800      	ldr	r0, [r0, #0]
 8006404:	9001      	str	r0, [sp, #4]
		( void ) FreeRTOS_inet_ntoa( ulIPAddress, pcDestination );
 8006406:	9801      	ldr	r0, [sp, #4]
 8006408:	f7ff ff9a 	bl	8006340 <FreeRTOS_inet_ntoa>
 800640c:	e000      	b.n	8006410 <FreeRTOS_inet_ntop4+0x18>
const char *pcReturn;

	if( uxSize < 16U )
	{
		/* There must be space for "255.255.255.255". */
		pcReturn = NULL;
 800640e:	2400      	movs	r4, #0
		( void ) memcpy( pvCopyDest, pvSource, sizeof( ulIPAddress ) );
		( void ) FreeRTOS_inet_ntoa( ulIPAddress, pcDestination );
		pcReturn = pcDestination;
	}
	return pcReturn;
}
 8006410:	4620      	mov	r0, r4
 8006412:	b002      	add	sp, #8
 8006414:	bd10      	pop	{r4, pc}
 8006416:	bf00      	nop

08006418 <FreeRTOS_inet_ntop>:
const char *FreeRTOS_inet_ntop( BaseType_t xAddressFamily, const void *pvSource, char *pcDestination, socklen_t uxSize )
{
const char *pcResult;

	/* Printable struct sockaddr to string. */
	switch( xAddressFamily )
 8006418:	2802      	cmp	r0, #2
 800641a:	d106      	bne.n	800642a <FreeRTOS_inet_ntop+0x12>
	return xResult;
}
/*-----------------------------------------------------------*/

const char *FreeRTOS_inet_ntop( BaseType_t xAddressFamily, const void *pvSource, char *pcDestination, socklen_t uxSize )
{
 800641c:	b508      	push	{r3, lr}
 800641e:	4608      	mov	r0, r1

	/* Printable struct sockaddr to string. */
	switch( xAddressFamily )
	{
		case FREERTOS_AF_INET:
			pcResult = FreeRTOS_inet_ntop4( pvSource, pcDestination, uxSize );
 8006420:	4611      	mov	r1, r2
 8006422:	461a      	mov	r2, r3
 8006424:	f7ff ffe8 	bl	80063f8 <FreeRTOS_inet_ntop4>
			break;
 8006428:	bd08      	pop	{r3, pc}
		default:
			/* errno should be set to pdFREERTOS_ERRNO_EAFNOSUPPORT. */
			pcResult = NULL;
 800642a:	2000      	movs	r0, #0
 800642c:	4770      	bx	lr
 800642e:	bf00      	nop

08006430 <FreeRTOS_inet_pton4>:
	return pcReturn;
}
/*-----------------------------------------------------------*/

BaseType_t FreeRTOS_inet_pton4( const char *pcSource, void *pvDestination )
{
 8006430:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8006434:	b082      	sub	sp, #8
const uint32_t ulDecimalBase = 10U;
uint8_t ucOctet[ socketMAX_IP_ADDRESS_OCTETS ];
uint32_t ulReturn = 0UL, ulValue;
 8006436:	2600      	movs	r6, #0
 8006438:	9600      	str	r6, [sp, #0]
 800643a:	f10d 0e04 	add.w	lr, sp, #4
UBaseType_t uxOctetNumber;
BaseType_t xResult = pdPASS;
const char *pcIPAddress = pcSource;
 800643e:	4605      	mov	r5, r0
{
const uint32_t ulDecimalBase = 10U;
uint8_t ucOctet[ socketMAX_IP_ADDRESS_OCTETS ];
uint32_t ulReturn = 0UL, ulValue;
UBaseType_t uxOctetNumber;
BaseType_t xResult = pdPASS;
 8006440:	2701      	movs	r7, #1
		{
			xResult = pdFAIL;
		}
		else
		{
			ucOctet[ uxOctetNumber ] = ( uint8_t ) ulValue;
 8006442:	46b4      	mov	ip, r6
			xChar = ( BaseType_t ) pcIPAddress[ 0 ];
			xChar = xChar - ( BaseType_t ) '0';
			ulValue += ( uint32_t ) xChar;

			/* Move to next character in the string. */
			pcIPAddress++;
 8006444:	4680      	mov	r8, r0
 8006446:	e01e      	b.n	8006486 <FreeRTOS_inet_pton4+0x56>
		while( ( *pcIPAddress >= '0' ) && ( *pcIPAddress <= '9' ) )
		{
		BaseType_t xChar;
			/* Move previous read characters into the next decimal
			position. */
			ulValue *= ulDecimalBase;
 8006448:	eb03 0383 	add.w	r3, r3, r3, lsl #2

			/* Add the binary value of the ascii character. */
			xChar = ( BaseType_t ) pcIPAddress[ 0 ];
			xChar = xChar - ( BaseType_t ) '0';
 800644c:	3a30      	subs	r2, #48	; 0x30
			ulValue += ( uint32_t ) xChar;
 800644e:	eb02 0343 	add.w	r3, r2, r3, lsl #1
	/* Translate "192.168.2.100" to a 32-bit number, network-endian. */
	for( uxOctetNumber = 0U; uxOctetNumber < socketMAX_IP_ADDRESS_OCTETS; uxOctetNumber++ )
	{
		ulValue = 0UL;

		while( ( *pcIPAddress >= '0' ) && ( *pcIPAddress <= '9' ) )
 8006452:	f815 2f01 	ldrb.w	r2, [r5, #1]!
 8006456:	f1a2 0430 	sub.w	r4, r2, #48	; 0x30
 800645a:	b2e4      	uxtb	r4, r4
 800645c:	2c09      	cmp	r4, #9
 800645e:	d9f3      	bls.n	8006448 <FreeRTOS_inet_pton4+0x18>
			/* Move to next character in the string. */
			pcIPAddress++;
		}

		/* Check characters were read. */
		if( pcIPAddress == pcSource )
 8006460:	4285      	cmp	r5, r0
			xChar = ( BaseType_t ) pcIPAddress[ 0 ];
			xChar = xChar - ( BaseType_t ) '0';
			ulValue += ( uint32_t ) xChar;

			/* Move to next character in the string. */
			pcIPAddress++;
 8006462:	bf04      	itt	eq
 8006464:	4645      	moveq	r5, r8
		}

		/* Check characters were read. */
		if( pcIPAddress == pcSource )
		{
			xResult = pdFAIL;
 8006466:	4667      	moveq	r7, ip
		}

		/* Check the value fits in an 8-bit number. */
		if( ulValue > 0xffUL )
 8006468:	2bff      	cmp	r3, #255	; 0xff
 800646a:	d815      	bhi.n	8006498 <FreeRTOS_inet_pton4+0x68>
		{
			xResult = pdFAIL;
		}
		else
		{
			ucOctet[ uxOctetNumber ] = ( uint8_t ) ulValue;
 800646c:	f80e 3b01 	strb.w	r3, [lr], #1

			/* Check the next character is as expected. */
			if( uxOctetNumber < ( socketMAX_IP_ADDRESS_OCTETS - 1U ) )
 8006470:	2e02      	cmp	r6, #2
 8006472:	d901      	bls.n	8006478 <FreeRTOS_inet_pton4+0x48>
 8006474:	e003      	b.n	800647e <FreeRTOS_inet_pton4+0x4e>
		}

		/* Check characters were read. */
		if( pcIPAddress == pcSource )
		{
			xResult = pdFAIL;
 8006476:	4667      	mov	r7, ip
			ucOctet[ uxOctetNumber ] = ( uint8_t ) ulValue;

			/* Check the next character is as expected. */
			if( uxOctetNumber < ( socketMAX_IP_ADDRESS_OCTETS - 1U ) )
			{
				if( *pcIPAddress != '.' )
 8006478:	2a2e      	cmp	r2, #46	; 0x2e
 800647a:	d10d      	bne.n	8006498 <FreeRTOS_inet_pton4+0x68>
					xResult = pdFAIL;
				}
				else
				{
					/* Move past the dot. */
					pcIPAddress++;
 800647c:	3501      	adds	r5, #1
				}
			}
		}

		if( xResult == pdFAIL )
 800647e:	b15f      	cbz	r7, 8006498 <FreeRTOS_inet_pton4+0x68>
BaseType_t xResult = pdPASS;
const char *pcIPAddress = pcSource;
const void *pvCopySource;

	/* Translate "192.168.2.100" to a 32-bit number, network-endian. */
	for( uxOctetNumber = 0U; uxOctetNumber < socketMAX_IP_ADDRESS_OCTETS; uxOctetNumber++ )
 8006480:	3601      	adds	r6, #1
 8006482:	2e04      	cmp	r6, #4
 8006484:	d02d      	beq.n	80064e2 <FreeRTOS_inet_pton4+0xb2>
	{
		ulValue = 0UL;

		while( ( *pcIPAddress >= '0' ) && ( *pcIPAddress <= '9' ) )
 8006486:	782a      	ldrb	r2, [r5, #0]
 8006488:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 800648c:	b2db      	uxtb	r3, r3
 800648e:	2b09      	cmp	r3, #9
 8006490:	bf98      	it	ls
 8006492:	4663      	movls	r3, ip
 8006494:	d9d8      	bls.n	8006448 <FreeRTOS_inet_pton4+0x18>
 8006496:	e01b      	b.n	80064d0 <FreeRTOS_inet_pton4+0xa0>
			/* No point going on. */
			break;
		}
	}

	if( *pcIPAddress != ( char ) 0 )
 8006498:	782b      	ldrb	r3, [r5, #0]
 800649a:	b99b      	cbnz	r3, 80064c4 <FreeRTOS_inet_pton4+0x94>
	{
		/* Expected the end of the string. */
		xResult = pdFAIL;
	}

	if( uxOctetNumber != socketMAX_IP_ADDRESS_OCTETS )
 800649c:	2e04      	cmp	r6, #4
 800649e:	d113      	bne.n	80064c8 <FreeRTOS_inet_pton4+0x98>
 80064a0:	2700      	movs	r7, #0
	{
		/* Didn't read enough octets. */
		xResult = pdFAIL;
	}

	if( xResult == pdPASS )
 80064a2:	b317      	cbz	r7, 80064ea <FreeRTOS_inet_pton4+0xba>
	{
		/* lint: ucOctet has been set because xResult == pdPASS. */
		ulReturn = FreeRTOS_inet_addr_quick( ucOctet[ 0 ], ucOctet[ 1 ], ucOctet[ 2 ], ucOctet[ 3 ] );
 80064a4:	f89d 2007 	ldrb.w	r2, [sp, #7]
 80064a8:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80064ac:	041b      	lsls	r3, r3, #16
 80064ae:	ea43 6202 	orr.w	r2, r3, r2, lsl #24
 80064b2:	f89d 3004 	ldrb.w	r3, [sp, #4]
 80064b6:	4313      	orrs	r3, r2
 80064b8:	f89d 2005 	ldrb.w	r2, [sp, #5]
 80064bc:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80064c0:	9300      	str	r3, [sp, #0]
 80064c2:	e012      	b.n	80064ea <FreeRTOS_inet_pton4+0xba>
	}

	if( *pcIPAddress != ( char ) 0 )
	{
		/* Expected the end of the string. */
		xResult = pdFAIL;
 80064c4:	2700      	movs	r7, #0
 80064c6:	e010      	b.n	80064ea <FreeRTOS_inet_pton4+0xba>
 80064c8:	2700      	movs	r7, #0
 80064ca:	e00e      	b.n	80064ea <FreeRTOS_inet_pton4+0xba>
 80064cc:	2700      	movs	r7, #0
 80064ce:	e00c      	b.n	80064ea <FreeRTOS_inet_pton4+0xba>
			/* Move to next character in the string. */
			pcIPAddress++;
		}

		/* Check characters were read. */
		if( pcIPAddress == pcSource )
 80064d0:	42a8      	cmp	r0, r5
 80064d2:	d001      	beq.n	80064d8 <FreeRTOS_inet_pton4+0xa8>
 80064d4:	4663      	mov	r3, ip
 80064d6:	e7c9      	b.n	800646c <FreeRTOS_inet_pton4+0x3c>
		{
			xResult = pdFAIL;
		}
		else
		{
			ucOctet[ uxOctetNumber ] = ( uint8_t ) ulValue;
 80064d8:	f80e cb01 	strb.w	ip, [lr], #1

			/* Check the next character is as expected. */
			if( uxOctetNumber < ( socketMAX_IP_ADDRESS_OCTETS - 1U ) )
 80064dc:	2e02      	cmp	r6, #2
 80064de:	d9ca      	bls.n	8006476 <FreeRTOS_inet_pton4+0x46>
 80064e0:	e7da      	b.n	8006498 <FreeRTOS_inet_pton4+0x68>
			/* No point going on. */
			break;
		}
	}

	if( *pcIPAddress != ( char ) 0 )
 80064e2:	782b      	ldrb	r3, [r5, #0]
 80064e4:	2b00      	cmp	r3, #0
 80064e6:	d1f1      	bne.n	80064cc <FreeRTOS_inet_pton4+0x9c>
 80064e8:	e7db      	b.n	80064a2 <FreeRTOS_inet_pton4+0x72>
	else
	{
		ulReturn = 0UL;
	}
	pvCopySource = ( const void * ) &ulReturn;
	( void ) memcpy( pvDestination, pvCopySource, sizeof( ulReturn ) );
 80064ea:	9800      	ldr	r0, [sp, #0]
 80064ec:	6008      	str	r0, [r1, #0]

	return xResult;
}
 80064ee:	4638      	mov	r0, r7
 80064f0:	b002      	add	sp, #8
 80064f2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80064f6:	bf00      	nop

080064f8 <FreeRTOS_inet_addr>:
/*-----------------------------------------------------------*/

uint32_t FreeRTOS_inet_addr( const char * pcIPAddress )
{
 80064f8:	b500      	push	{lr}
 80064fa:	b083      	sub	sp, #12
uint32_t ulReturn = 0UL;
 80064fc:	a902      	add	r1, sp, #8
 80064fe:	2300      	movs	r3, #0
 8006500:	f841 3d04 	str.w	r3, [r1, #-4]!

	/* inet_pton AF_INET target is a 4-byte 'struct in_addr'. */
	( void ) FreeRTOS_inet_pton4( pcIPAddress, &( ulReturn ) );
 8006504:	f7ff ff94 	bl	8006430 <FreeRTOS_inet_pton4>

	return ulReturn;
}
 8006508:	9801      	ldr	r0, [sp, #4]
 800650a:	b003      	add	sp, #12
 800650c:	f85d fb04 	ldr.w	pc, [sp], #4

08006510 <vSocketWakeUpUser>:
}

/*-----------------------------------------------------------*/

void vSocketWakeUpUser( FreeRTOS_Socket_t *pxSocket )
{
 8006510:	b510      	push	{r4, lr}
 8006512:	4604      	mov	r4, r0
	}
	#endif /* ipconfigSOCKET_HAS_USER_WAKE_CALLBACK */

	#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
	{
		if( pxSocket->pxSocketSet != NULL )
 8006514:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8006516:	b14b      	cbz	r3, 800652c <vSocketWakeUpUser+0x1c>
		{
			EventBits_t xSelectBits = ( pxSocket->xEventBits >> SOCKET_EVENT_BIT_COUNT ) & ( ( EventBits_t ) eSELECT_ALL );
 8006518:	6801      	ldr	r1, [r0, #0]
 800651a:	f3c1 2103 	ubfx	r1, r1, #8, #4
			if( xSelectBits != 0UL )
 800651e:	b129      	cbz	r1, 800652c <vSocketWakeUpUser+0x1c>
			{
				pxSocket->xSocketBits |= xSelectBits;
 8006520:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8006522:	430a      	orrs	r2, r1
 8006524:	6342      	str	r2, [r0, #52]	; 0x34
				( void ) xEventGroupSetBits( pxSocket->pxSocketSet->xSelectGroup, xSelectBits );
 8006526:	6818      	ldr	r0, [r3, #0]
 8006528:	f7fb fe6c 	bl	8002204 <xEventGroupSetBits>
			}
		}

		pxSocket->xEventBits &= ( EventBits_t ) eSOCKET_ALL;
 800652c:	6821      	ldr	r1, [r4, #0]
 800652e:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 8006532:	6021      	str	r1, [r4, #0]
	}
	#endif /* ipconfigSUPPORT_SELECT_FUNCTION */

	if( ( pxSocket->xEventGroup != NULL ) && ( pxSocket->xEventBits != 0U ) )
 8006534:	6860      	ldr	r0, [r4, #4]
 8006536:	b110      	cbz	r0, 800653e <vSocketWakeUpUser+0x2e>
 8006538:	b109      	cbz	r1, 800653e <vSocketWakeUpUser+0x2e>
	{
		( void ) xEventGroupSetBits( pxSocket->xEventGroup, pxSocket->xEventBits );
 800653a:	f7fb fe63 	bl	8002204 <xEventGroupSetBits>
	}

	pxSocket->xEventBits = 0UL;
 800653e:	2300      	movs	r3, #0
 8006540:	6023      	str	r3, [r4, #0]
 8006542:	bd10      	pop	{r4, pc}

08006544 <FreeRTOS_accept>:
	 * if the server socket is in listen mode and receives a connection request
	 * The new socket will be bound already to the same port number as the listing
	 * socket.
	 */
	Socket_t FreeRTOS_accept( Socket_t xServerSocket, struct freertos_sockaddr *pxAddress, socklen_t *pxAddressLength )
	{
 8006544:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006548:	b08b      	sub	sp, #44	; 0x2c
 800654a:	4605      	mov	r5, r0
 800654c:	460e      	mov	r6, r1
 800654e:	4690      	mov	r8, r2
	TickType_t xRemainingTime;
	BaseType_t xTimed = pdFALSE, xAsk = pdFALSE;
	TimeOut_t xTimeOut;
	IPStackEvent_t xAskEvent;

		if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_TCP, pdTRUE ) == pdFALSE )
 8006550:	2106      	movs	r1, #6
 8006552:	2201      	movs	r2, #1
 8006554:	f7ff fb20 	bl	8005b98 <prvValidSocket>
 8006558:	2800      	cmp	r0, #0
 800655a:	d071      	beq.n	8006640 <FreeRTOS_accept+0xfc>
		{
			/* Not a valid socket or wrong type */
			pxClientSocket = FREERTOS_INVALID_SOCKET;
		}
		else if( ( pxSocket->u.xTCP.bits.bReuseSocket == pdFALSE_UNSIGNED ) &&
 800655c:	f895 3040 	ldrb.w	r3, [r5, #64]	; 0x40
 8006560:	f013 0f08 	tst.w	r3, #8
 8006564:	d107      	bne.n	8006576 <FreeRTOS_accept+0x32>
 8006566:	f895 3053 	ldrb.w	r3, [r5, #83]	; 0x53
 800656a:	2b01      	cmp	r3, #1
 800656c:	d16b      	bne.n	8006646 <FreeRTOS_accept+0x102>
 800656e:	f04f 0a00 	mov.w	sl, #0
 8006572:	46d1      	mov	r9, sl
 8006574:	e002      	b.n	800657c <FreeRTOS_accept+0x38>
 8006576:	f04f 0a00 	mov.w	sl, #0
 800657a:	46d1      	mov	r9, sl
					{
						pxClientSocket = pxSocket->u.xTCP.pxPeerSocket;
					}
					else
					{
						pxClientSocket = pxSocket;
 800657c:	9503      	str	r5, [sp, #12]
 800657e:	2700      	movs	r7, #0

				if( xAsk != pdFALSE )
				{
					/* Ask to set an event in 'xEventGroup' as soon as a new
					client gets connected for this listening socket. */
					xAskEvent.eEventType = eTCPAcceptEvent;
 8006580:	f04f 0b07 	mov.w	fp, #7
		{
			/* Loop will stop with breaks. */
			for( ; ; )
			{
				/* Is there a new client? */
				vTaskSuspendAll();
 8006584:	f7fc fe12 	bl	80031ac <vTaskSuspendAll>
				{
					if( pxSocket->u.xTCP.bits.bReuseSocket == pdFALSE_UNSIGNED )
 8006588:	f895 3040 	ldrb.w	r3, [r5, #64]	; 0x40
 800658c:	f013 0f08 	tst.w	r3, #8
					{
						pxClientSocket = pxSocket->u.xTCP.pxPeerSocket;
 8006590:	bf0c      	ite	eq
 8006592:	6d6c      	ldreq	r4, [r5, #84]	; 0x54
					}
					else
					{
						pxClientSocket = pxSocket;
 8006594:	9c03      	ldrne	r4, [sp, #12]
					}
					if( pxClientSocket != NULL )
 8006596:	2c00      	cmp	r4, #0
 8006598:	d05c      	beq.n	8006654 <FreeRTOS_accept+0x110>
					{
						pxSocket->u.xTCP.pxPeerSocket = NULL;
 800659a:	656f      	str	r7, [r5, #84]	; 0x54

						/* Is it still not taken ? */
						if( pxClientSocket->u.xTCP.bits.bPassAccept != pdFALSE_UNSIGNED )
 800659c:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 80065a0:	f013 0f02 	tst.w	r3, #2
 80065a4:	d056      	beq.n	8006654 <FreeRTOS_accept+0x110>
						{
							pxClientSocket->u.xTCP.bits.bPassAccept = pdFALSE;
 80065a6:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 80065aa:	f36f 0341 	bfc	r3, #1, #1
 80065ae:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
						{
							pxClientSocket = NULL;
						}
					}
				}
				( void ) xTaskResumeAll();
 80065b2:	f7fc fe9b 	bl	80032ec <xTaskResumeAll>

				if( pxClientSocket != NULL )
				{
					if( pxAddress != NULL )
 80065b6:	b18e      	cbz	r6, 80065dc <FreeRTOS_accept+0x98>
					{
						/* IP address of remote machine. */
						pxAddress->sin_addr = FreeRTOS_ntohl( pxClientSocket->u.xTCP.ulRemoteIP );
 80065b8:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 80065ba:	060a      	lsls	r2, r1, #24
 80065bc:	ea42 6211 	orr.w	r2, r2, r1, lsr #24
 80065c0:	f401 437f 	and.w	r3, r1, #65280	; 0xff00
 80065c4:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
 80065c8:	f401 037f 	and.w	r3, r1, #16711680	; 0xff0000
 80065cc:	ea42 2313 	orr.w	r3, r2, r3, lsr #8
 80065d0:	6073      	str	r3, [r6, #4]

						/* Port on remote machine. */
						pxAddress->sin_port = FreeRTOS_ntohs( pxClientSocket->u.xTCP.usRemotePort );
 80065d2:	8fa2      	ldrh	r2, [r4, #60]	; 0x3c
 80065d4:	0a13      	lsrs	r3, r2, #8
 80065d6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80065da:	8073      	strh	r3, [r6, #2]
					}
					if( pxAddressLength != NULL )
 80065dc:	f1b8 0f00 	cmp.w	r8, #0
 80065e0:	d002      	beq.n	80065e8 <FreeRTOS_accept+0xa4>
					{
						*pxAddressLength = sizeof( *pxAddress );
 80065e2:	2308      	movs	r3, #8
 80065e4:	f8c8 3000 	str.w	r3, [r8]
					}

					if( pxSocket->u.xTCP.bits.bReuseSocket == pdFALSE_UNSIGNED )
 80065e8:	f895 3040 	ldrb.w	r3, [r5, #64]	; 0x40
 80065ec:	f013 0f08 	tst.w	r3, #8
 80065f0:	d136      	bne.n	8006660 <FreeRTOS_accept+0x11c>
					{
						xAsk = pdTRUE;
 80065f2:	f04f 0a01 	mov.w	sl, #1
 80065f6:	e000      	b.n	80065fa <FreeRTOS_accept+0xb6>
 80065f8:	463c      	mov	r4, r7

				if( xAsk != pdFALSE )
				{
					/* Ask to set an event in 'xEventGroup' as soon as a new
					client gets connected for this listening socket. */
					xAskEvent.eEventType = eTCPAcceptEvent;
 80065fa:	f88d b014 	strb.w	fp, [sp, #20]
					xAskEvent.pvData = pxSocket;
 80065fe:	9b03      	ldr	r3, [sp, #12]
 8006600:	9306      	str	r3, [sp, #24]
					( void ) xSendEventStructToIPTask( &xAskEvent, portMAX_DELAY );
 8006602:	a805      	add	r0, sp, #20
 8006604:	f04f 31ff 	mov.w	r1, #4294967295
 8006608:	f7fe fdd0 	bl	80051ac <xSendEventStructToIPTask>
				}

				if( pxClientSocket != NULL )
 800660c:	bb5c      	cbnz	r4, 8006666 <FreeRTOS_accept+0x122>
				{
					break;
				}

				if( xTimed == pdFALSE )
 800660e:	f1b9 0f00 	cmp.w	r9, #0
 8006612:	d107      	bne.n	8006624 <FreeRTOS_accept+0xe0>
				{
					/* Only in the first round, check for non-blocking */
					xRemainingTime = pxSocket->xReceiveBlockTime;
 8006614:	69eb      	ldr	r3, [r5, #28]
 8006616:	9309      	str	r3, [sp, #36]	; 0x24
					if( xRemainingTime == ( TickType_t ) 0 )
 8006618:	b1c3      	cbz	r3, 800664c <FreeRTOS_accept+0x108>

					/* Don't get here a second time */
					xTimed = pdTRUE;

					/* Fetch the current time */
					vTaskSetTimeOutState( &xTimeOut );
 800661a:	a807      	add	r0, sp, #28
 800661c:	f7fd f89e 	bl	800375c <vTaskSetTimeOutState>
					{
						break;
					}

					/* Don't get here a second time */
					xTimed = pdTRUE;
 8006620:	f04f 0901 	mov.w	r9, #1
					/* Fetch the current time */
					vTaskSetTimeOutState( &xTimeOut );
				}

				/* Has the timeout been reached? */
				if( xTaskCheckForTimeOut( &xTimeOut, &xRemainingTime ) != pdFALSE )
 8006624:	a807      	add	r0, sp, #28
 8006626:	a909      	add	r1, sp, #36	; 0x24
 8006628:	f7fd f8c0 	bl	80037ac <xTaskCheckForTimeOut>
 800662c:	b980      	cbnz	r0, 8006650 <FreeRTOS_accept+0x10c>
				{
					break;
				}

				/* Go sleeping until we get any down-stream event */
				( void ) xEventGroupWaitBits( pxSocket->xEventGroup, ( EventBits_t ) eSOCKET_ACCEPT, pdTRUE /*xClearOnExit*/, pdFALSE /*xWaitAllBits*/, xRemainingTime );
 800662e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8006630:	9300      	str	r3, [sp, #0]
 8006632:	6868      	ldr	r0, [r5, #4]
 8006634:	2104      	movs	r1, #4
 8006636:	2201      	movs	r2, #1
 8006638:	463b      	mov	r3, r7
 800663a:	f7fb fd2b 	bl	8002094 <xEventGroupWaitBits>
			}
 800663e:	e7a1      	b.n	8006584 <FreeRTOS_accept+0x40>
	IPStackEvent_t xAskEvent;

		if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_TCP, pdTRUE ) == pdFALSE )
		{
			/* Not a valid socket or wrong type */
			pxClientSocket = FREERTOS_INVALID_SOCKET;
 8006640:	f04f 34ff 	mov.w	r4, #4294967295
 8006644:	e00f      	b.n	8006666 <FreeRTOS_accept+0x122>
		}
		else if( ( pxSocket->u.xTCP.bits.bReuseSocket == pdFALSE_UNSIGNED ) &&
				 ( pxSocket->u.xTCP.ucTCPState != ( uint8_t ) eTCP_LISTEN ) )
		{
			/* Parent socket is not in listening mode */
			pxClientSocket = FREERTOS_INVALID_SOCKET;
 8006646:	f04f 34ff 	mov.w	r4, #4294967295
 800664a:	e00c      	b.n	8006666 <FreeRTOS_accept+0x122>
 800664c:	2400      	movs	r4, #0
 800664e:	e00a      	b.n	8006666 <FreeRTOS_accept+0x122>
 8006650:	2400      	movs	r4, #0
 8006652:	e008      	b.n	8006666 <FreeRTOS_accept+0x122>
						{
							pxClientSocket = NULL;
						}
					}
				}
				( void ) xTaskResumeAll();
 8006654:	f7fc fe4a 	bl	80032ec <xTaskResumeAll>
					{
						xAsk = pdTRUE;
					}
				}

				if( xAsk != pdFALSE )
 8006658:	f1ba 0f00 	cmp.w	sl, #0
 800665c:	d0d7      	beq.n	800660e <FreeRTOS_accept+0xca>
 800665e:	e7cb      	b.n	80065f8 <FreeRTOS_accept+0xb4>
 8006660:	f1ba 0f00 	cmp.w	sl, #0
 8006664:	d1c9      	bne.n	80065fa <FreeRTOS_accept+0xb6>
				( void ) xEventGroupWaitBits( pxSocket->xEventGroup, ( EventBits_t ) eSOCKET_ACCEPT, pdTRUE /*xClearOnExit*/, pdFALSE /*xWaitAllBits*/, xRemainingTime );
			}
		}

		return pxClientSocket;
	}
 8006666:	4620      	mov	r0, r4
 8006668:	b00b      	add	sp, #44	; 0x2c
 800666a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800666e:	bf00      	nop

08006670 <FreeRTOS_recv>:
	/*
	 * Read incoming data from a TCP socket
	 * Only after the last byte has been read, a close error might be returned
	 */
	BaseType_t FreeRTOS_recv( Socket_t xSocket, void *pvBuffer, size_t uxBufferLength, BaseType_t xFlags )
	{
 8006670:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006674:	b089      	sub	sp, #36	; 0x24
 8006676:	4604      	mov	r4, r0
 8006678:	9102      	str	r1, [sp, #8]
 800667a:	9203      	str	r2, [sp, #12]
 800667c:	469a      	mov	sl, r3
	TimeOut_t xTimeOut;
	EventBits_t xEventBits = ( EventBits_t ) 0;

		/* Check if the socket is valid, has type TCP and if it is bound to a
		port. */
		if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_TCP, pdTRUE ) == pdFALSE )
 800667e:	2106      	movs	r1, #6
 8006680:	2201      	movs	r2, #1
 8006682:	f7ff fa89 	bl	8005b98 <prvValidSocket>
 8006686:	2800      	cmp	r0, #0
 8006688:	f000 80bb 	beq.w	8006802 <FreeRTOS_recv+0x192>
		{
			xByteCount = -pdFREERTOS_ERRNO_EINVAL;
		}
		else if( ( ( ( uint32_t ) xFlags & ( uint32_t ) FREERTOS_ZERO_COPY ) != 0U ) &&
 800668c:	46d1      	mov	r9, sl
 800668e:	f01a 0b01 	ands.w	fp, sl, #1
 8006692:	d003      	beq.n	800669c <FreeRTOS_recv+0x2c>
 8006694:	9b02      	ldr	r3, [sp, #8]
 8006696:	2b00      	cmp	r3, #0
 8006698:	f000 80b6 	beq.w	8006808 <FreeRTOS_recv+0x198>
			/* In zero-copy mode, pvBuffer is a pointer to a pointer ( not NULL ). */
			xByteCount = -pdFREERTOS_ERRNO_EINVAL;
		}
		else
		{
			if( pxSocket->u.xTCP.rxStream != NULL )
 800669c:	6f62      	ldr	r2, [r4, #116]	; 0x74
 800669e:	b16a      	cbz	r2, 80066bc <FreeRTOS_recv+0x4c>
static portINLINE size_t uxStreamBufferGetSize( const StreamBuffer_t *pxBuffer );
static portINLINE size_t uxStreamBufferGetSize( const StreamBuffer_t *pxBuffer )
{
/* Returns the number of items which can be read from uxTail
before reaching uxHead */
size_t uxHead = pxBuffer->uxHead;
 80066a0:	6893      	ldr	r3, [r2, #8]
size_t uxTail = pxBuffer->uxTail;
 80066a2:	6811      	ldr	r1, [r2, #0]
static portINLINE size_t uxStreamBufferDistance( const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper )
{
/* Returns the distance between uxLower and uxUpper */
size_t uxCount;

	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
 80066a4:	6912      	ldr	r2, [r2, #16]
 80066a6:	4413      	add	r3, r2
 80066a8:	1a5b      	subs	r3, r3, r1
	if ( uxCount >= pxBuffer->LENGTH )
 80066aa:	429a      	cmp	r2, r3
	{
		uxCount -= pxBuffer->LENGTH;
 80066ac:	bf98      	it	ls
 80066ae:	1a9b      	subls	r3, r3, r2
			{
				xByteCount = ( BaseType_t )uxStreamBufferGetSize ( pxSocket->u.xTCP.rxStream );
 80066b0:	461f      	mov	r7, r3
			else
			{
				xByteCount = 0;
			}

			while( xByteCount == 0 )
 80066b2:	2b00      	cmp	r3, #0
 80066b4:	d15d      	bne.n	8006772 <FreeRTOS_recv+0x102>
 80066b6:	2500      	movs	r5, #0
 80066b8:	462e      	mov	r6, r5
 80066ba:	e001      	b.n	80066c0 <FreeRTOS_recv+0x50>
 80066bc:	2500      	movs	r5, #0
 80066be:	462e      	mov	r6, r5
						}
						#endif /* ipconfigSUPPORT_SIGNALS */
						break;
					}

					if( ( ( uint32_t ) xFlags & ( uint32_t ) FREERTOS_MSG_DONTWAIT ) != 0U )
 80066c0:	f009 0910 	and.w	r9, r9, #16
					{
						break;
					}

					/* Don't get here a second time. */
					xTimed = pdTRUE;
 80066c4:	f04f 0801 	mov.w	r8, #1
				xByteCount = 0;
			}

			while( xByteCount == 0 )
			{
				switch( ipNUMERIC_CAST( eIPTCPState_t, pxSocket->u.xTCP.ucTCPState ) )
 80066c8:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 80066cc:	b113      	cbz	r3, 80066d4 <FreeRTOS_recv+0x64>
 80066ce:	3b08      	subs	r3, #8
 80066d0:	2b01      	cmp	r3, #1
 80066d2:	d80e      	bhi.n	80066f2 <FreeRTOS_recv+0x82>
				{
				case eCLOSED:
				case eCLOSE_WAIT:	/* (server + client) waiting for a connection termination request from the local user. */
				case eCLOSING:		/* (server + client) waiting for a connection termination request acknowledgement from the remote TCP. */
					if( pxSocket->u.xTCP.bits.bMallocError != pdFALSE_UNSIGNED )
 80066d4:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 80066d8:	f003 0308 	and.w	r3, r3, #8
 80066dc:	b2db      	uxtb	r3, r3
						Both are fatal and will elad to closing the socket. */
						xByteCount = -pdFREERTOS_ERRNO_ENOMEM;
					}
					else
					{
						xByteCount = -pdFREERTOS_ERRNO_ENOTCONN;
 80066de:	2b00      	cmp	r3, #0
 80066e0:	bf14      	ite	ne
 80066e2:	f06f 070b 	mvnne.w	r7, #11
 80066e6:	f06f 077f 	mvneq.w	r7, #127	; 0x7f
					xByteCount = 0;
				}
			}

		#if( ipconfigSUPPORT_SIGNALS != 0 )
			if( ( xEventBits & ( EventBits_t ) eSOCKET_INTR ) != 0U )
 80066ea:	f015 0f40 	tst.w	r5, #64	; 0x40
 80066ee:	d135      	bne.n	800675c <FreeRTOS_recv+0xec>
 80066f0:	e03f      	b.n	8006772 <FreeRTOS_recv+0x102>
				if( xByteCount < 0 )
				{
					break;
				}

				if( xTimed == pdFALSE )
 80066f2:	b996      	cbnz	r6, 800671a <FreeRTOS_recv+0xaa>
				{
					/* Only in the first round, check for non-blocking. */
					xRemainingTime = pxSocket->xReceiveBlockTime;
 80066f4:	69e3      	ldr	r3, [r4, #28]
 80066f6:	9307      	str	r3, [sp, #28]

					if( xRemainingTime == ( TickType_t ) 0 )
 80066f8:	b93b      	cbnz	r3, 800670a <FreeRTOS_recv+0x9a>
					{
						#if( ipconfigSUPPORT_SIGNALS != 0 )
						{
							/* Just check for the interrupt flag. */
							xEventBits = xEventGroupWaitBits( pxSocket->xEventGroup, ( EventBits_t ) eSOCKET_INTR,
 80066fa:	9300      	str	r3, [sp, #0]
 80066fc:	6860      	ldr	r0, [r4, #4]
 80066fe:	2140      	movs	r1, #64	; 0x40
 8006700:	2201      	movs	r2, #1
 8006702:	f7fb fcc7 	bl	8002094 <xEventGroupWaitBits>
 8006706:	4605      	mov	r5, r0
								pdTRUE /*xClearOnExit*/, pdFALSE /*xWaitAllBits*/, socketDONT_BLOCK );
						}
						#endif /* ipconfigSUPPORT_SIGNALS */
						break;
 8006708:	e084      	b.n	8006814 <FreeRTOS_recv+0x1a4>
					}

					if( ( ( uint32_t ) xFlags & ( uint32_t ) FREERTOS_MSG_DONTWAIT ) != 0U )
 800670a:	f1b9 0f00 	cmp.w	r9, #0
 800670e:	f040 8081 	bne.w	8006814 <FreeRTOS_recv+0x1a4>

					/* Don't get here a second time. */
					xTimed = pdTRUE;

					/* Fetch the current time. */
					vTaskSetTimeOutState( &xTimeOut );
 8006712:	a805      	add	r0, sp, #20
 8006714:	f7fd f822 	bl	800375c <vTaskSetTimeOutState>
					{
						break;
					}

					/* Don't get here a second time. */
					xTimed = pdTRUE;
 8006718:	4646      	mov	r6, r8
					/* Fetch the current time. */
					vTaskSetTimeOutState( &xTimeOut );
				}

				/* Has the timeout been reached? */
				if( xTaskCheckForTimeOut( &xTimeOut, &xRemainingTime ) != pdFALSE )
 800671a:	a805      	add	r0, sp, #20
 800671c:	a907      	add	r1, sp, #28
 800671e:	f7fd f845 	bl	80037ac <xTaskCheckForTimeOut>
 8006722:	2800      	cmp	r0, #0
 8006724:	d176      	bne.n	8006814 <FreeRTOS_recv+0x1a4>
				{
					break;
				}

				/* Block until there is a down-stream event. */
				xEventBits = xEventGroupWaitBits( pxSocket->xEventGroup,
 8006726:	9b07      	ldr	r3, [sp, #28]
 8006728:	9300      	str	r3, [sp, #0]
 800672a:	6860      	ldr	r0, [r4, #4]
 800672c:	2161      	movs	r1, #97	; 0x61
 800672e:	4642      	mov	r2, r8
 8006730:	2300      	movs	r3, #0
 8006732:	f7fb fcaf 	bl	8002094 <xEventGroupWaitBits>
 8006736:	4605      	mov	r5, r0
					( EventBits_t ) eSOCKET_RECEIVE | ( EventBits_t ) eSOCKET_CLOSED | ( EventBits_t ) eSOCKET_INTR,
					pdTRUE /*xClearOnExit*/, pdFALSE /*xWaitAllBits*/, xRemainingTime );
				#if( ipconfigSUPPORT_SIGNALS != 0 )
				{
					if( ( xEventBits & ( EventBits_t ) eSOCKET_INTR ) != 0U )
 8006738:	f010 0f40 	tst.w	r0, #64	; 0x40
 800673c:	d10e      	bne.n	800675c <FreeRTOS_recv+0xec>
				{
					( void ) xEventBits;
				}
				#endif /* ipconfigSUPPORT_SIGNALS */

				if( pxSocket->u.xTCP.rxStream != NULL )
 800673e:	6f62      	ldr	r2, [r4, #116]	; 0x74
 8006740:	2a00      	cmp	r2, #0
 8006742:	d0c1      	beq.n	80066c8 <FreeRTOS_recv+0x58>
static portINLINE size_t uxStreamBufferGetSize( const StreamBuffer_t *pxBuffer );
static portINLINE size_t uxStreamBufferGetSize( const StreamBuffer_t *pxBuffer )
{
/* Returns the number of items which can be read from uxTail
before reaching uxHead */
size_t uxHead = pxBuffer->uxHead;
 8006744:	6893      	ldr	r3, [r2, #8]
size_t uxTail = pxBuffer->uxTail;
 8006746:	6811      	ldr	r1, [r2, #0]
static portINLINE size_t uxStreamBufferDistance( const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper )
{
/* Returns the distance between uxLower and uxUpper */
size_t uxCount;

	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
 8006748:	6912      	ldr	r2, [r2, #16]
 800674a:	4413      	add	r3, r2
 800674c:	1a5b      	subs	r3, r3, r1
	if ( uxCount >= pxBuffer->LENGTH )
 800674e:	429a      	cmp	r2, r3
	{
		uxCount -= pxBuffer->LENGTH;
 8006750:	bf98      	it	ls
 8006752:	1a9b      	subls	r3, r3, r2
				{
					xByteCount = ( BaseType_t ) uxStreamBufferGetSize ( pxSocket->u.xTCP.rxStream );
 8006754:	461f      	mov	r7, r3
			else
			{
				xByteCount = 0;
			}

			while( xByteCount == 0 )
 8006756:	2b00      	cmp	r3, #0
 8006758:	d0b6      	beq.n	80066c8 <FreeRTOS_recv+0x58>
 800675a:	e00a      	b.n	8006772 <FreeRTOS_recv+0x102>
			}

		#if( ipconfigSUPPORT_SIGNALS != 0 )
			if( ( xEventBits & ( EventBits_t ) eSOCKET_INTR ) != 0U )
			{
				if( ( xEventBits & ( ( EventBits_t ) eSOCKET_RECEIVE | ( EventBits_t ) eSOCKET_CLOSED ) ) != 0U )
 800675c:	f015 0f21 	tst.w	r5, #33	; 0x21
 8006760:	d055      	beq.n	800680e <FreeRTOS_recv+0x19e>
				{
					/* Shouldn't have cleared other flags. */
					xEventBits &= ~( ( EventBits_t ) eSOCKET_INTR );
					( void ) xEventGroupSetBits( pxSocket->xEventGroup, xEventBits );
 8006762:	6860      	ldr	r0, [r4, #4]
 8006764:	f025 0140 	bic.w	r1, r5, #64	; 0x40
 8006768:	f7fb fd4c 	bl	8002204 <xEventGroupSetBits>
				}
				xByteCount = -pdFREERTOS_ERRNO_EINTR;
 800676c:	f06f 0703 	mvn.w	r7, #3
 8006770:	e054      	b.n	800681c <FreeRTOS_recv+0x1ac>
			}
			else
		#endif /* ipconfigSUPPORT_SIGNALS */
			if( xByteCount > 0 )
 8006772:	2f00      	cmp	r7, #0
 8006774:	dd52      	ble.n	800681c <FreeRTOS_recv+0x1ac>
			{
				if( ( ( uint32_t ) xFlags & ( uint32_t ) FREERTOS_ZERO_COPY ) == 0U )
 8006776:	f1bb 0f00 	cmp.w	fp, #0
 800677a:	d12e      	bne.n	80067da <FreeRTOS_recv+0x16a>
				{
				BaseType_t xIsPeek = ( ( ( uint32_t ) xFlags & ( uint32_t ) FREERTOS_MSG_PEEK ) != 0U ) ? 1L : 0L;
 800677c:	f3ca 0380 	ubfx	r3, sl, #2, #1

					xByteCount = ( BaseType_t )
						uxStreamBufferGet( pxSocket->u.xTCP.rxStream,
 8006780:	9300      	str	r3, [sp, #0]
 8006782:	6f60      	ldr	r0, [r4, #116]	; 0x74
 8006784:	2100      	movs	r1, #0
 8006786:	9a02      	ldr	r2, [sp, #8]
 8006788:	9b03      	ldr	r3, [sp, #12]
 800678a:	f000 fd6d 	bl	8007268 <uxStreamBufferGet>
 800678e:	4607      	mov	r7, r0
										   0UL,
										   ipPOINTER_CAST( uint8_t *, pvBuffer ),
										   ( size_t ) uxBufferLength,
										   xIsPeek );
					if( pxSocket->u.xTCP.bits.bLowWater != pdFALSE_UNSIGNED )
 8006790:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8006794:	f013 0f80 	tst.w	r3, #128	; 0x80
 8006798:	d040      	beq.n	800681c <FreeRTOS_recv+0x1ac>
					{
						/* We had reached the low-water mark, now see if the flag
						can be cleared */
						size_t uxFrontSpace = uxStreamBufferFrontSpace( pxSocket->u.xTCP.rxStream );
 800679a:	6f62      	ldr	r2, [r4, #116]	; 0x74
{
/* Distance between uxFront and uxTail
or the number of items which can still be added to uxFront,
before hitting on uxTail */

size_t uxFront = pxBuffer->uxFront;
 800679c:	68d1      	ldr	r1, [r2, #12]
size_t uxTail = pxBuffer->uxTail;
 800679e:	6813      	ldr	r3, [r2, #0]
static portINLINE size_t uxStreamBufferSpace( const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper )
{
/* Returns the space between uxLower and uxUpper, which equals to the distance minus 1 */
size_t uxCount;

	uxCount = pxBuffer->LENGTH + uxUpper - uxLower - 1U;
 80067a0:	6912      	ldr	r2, [r2, #16]
 80067a2:	4413      	add	r3, r2
 80067a4:	3b01      	subs	r3, #1
 80067a6:	1a5b      	subs	r3, r3, r1
	if( uxCount >= pxBuffer->LENGTH )
 80067a8:	429a      	cmp	r2, r3
	{
		uxCount -= pxBuffer->LENGTH;
 80067aa:	bf98      	it	ls
 80067ac:	1a9b      	subls	r3, r3, r2

						if( uxFrontSpace >= pxSocket->u.xTCP.uxEnoughSpace )
 80067ae:	6ea2      	ldr	r2, [r4, #104]	; 0x68
 80067b0:	429a      	cmp	r2, r3
 80067b2:	d833      	bhi.n	800681c <FreeRTOS_recv+0x1ac>
						{
							pxSocket->u.xTCP.bits.bLowWater = pdFALSE;
 80067b4:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 80067b8:	f36f 13c7 	bfc	r3, #7, #1
 80067bc:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
							pxSocket->u.xTCP.bits.bWinChange = pdTRUE;
 80067c0:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 80067c4:	f043 0301 	orr.w	r3, r3, #1
 80067c8:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
							pxSocket->u.xTCP.usTimeout = 1U; /* because bLowWater is cleared. */
 80067cc:	2301      	movs	r3, #1
 80067ce:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
							( void ) xSendEventToIPTask( eTCPTimerEvent );
 80067d2:	2006      	movs	r0, #6
 80067d4:	f7fe fd2a 	bl	800522c <xSendEventToIPTask>
 80067d8:	e020      	b.n	800681c <FreeRTOS_recv+0x1ac>
					}
				}
				else
				{
					/* Zero-copy reception of data: pvBuffer is a pointer to a pointer. */
					xByteCount = ( BaseType_t ) uxStreamBufferGetPtr( pxSocket->u.xTCP.rxStream, ipPOINTER_CAST( uint8_t **, pvBuffer ) );
 80067da:	6f62      	ldr	r2, [r4, #116]	; 0x74
/*-----------------------------------------------------------*/

static portINLINE size_t uxStreamBufferGetPtr( StreamBuffer_t *pxBuffer, uint8_t **ppucData );
static portINLINE size_t uxStreamBufferGetPtr( StreamBuffer_t *pxBuffer, uint8_t **ppucData )
{
size_t uxNextTail = pxBuffer->uxTail;
 80067dc:	6817      	ldr	r7, [r2, #0]
static portINLINE size_t uxStreamBufferGetSize( const StreamBuffer_t *pxBuffer );
static portINLINE size_t uxStreamBufferGetSize( const StreamBuffer_t *pxBuffer )
{
/* Returns the number of items which can be read from uxTail
before reaching uxHead */
size_t uxHead = pxBuffer->uxHead;
 80067de:	6893      	ldr	r3, [r2, #8]
size_t uxTail = pxBuffer->uxTail;
 80067e0:	6810      	ldr	r0, [r2, #0]
static portINLINE size_t uxStreamBufferDistance( const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper )
{
/* Returns the distance between uxLower and uxUpper */
size_t uxCount;

	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
 80067e2:	6911      	ldr	r1, [r2, #16]
 80067e4:	440b      	add	r3, r1
 80067e6:	1a1b      	subs	r3, r3, r0
	if ( uxCount >= pxBuffer->LENGTH )
 80067e8:	4299      	cmp	r1, r3
	{
		uxCount -= pxBuffer->LENGTH;
 80067ea:	bf98      	it	ls
 80067ec:	1a5b      	subls	r3, r3, r1
static portINLINE size_t uxStreamBufferGetPtr( StreamBuffer_t *pxBuffer, uint8_t **ppucData )
{
size_t uxNextTail = pxBuffer->uxTail;
size_t uxSize = uxStreamBufferGetSize( pxBuffer );

	*ppucData = pxBuffer->ucArray + uxNextTail;
 80067ee:	19d1      	adds	r1, r2, r7
 80067f0:	3114      	adds	r1, #20
 80067f2:	9802      	ldr	r0, [sp, #8]
 80067f4:	6001      	str	r1, [r0, #0]

	return FreeRTOS_min_uint32( uxSize, pxBuffer->LENGTH - uxNextTail );
 80067f6:	6912      	ldr	r2, [r2, #16]
 80067f8:	1bd7      	subs	r7, r2, r7
	static portINLINE BaseType_t  FreeRTOS_min_BaseType  (BaseType_t  a, BaseType_t  b);

	static portINLINE int32_t  FreeRTOS_max_int32  (int32_t  a, int32_t  b) { return ( a >= b ) ? a : b; }
	static portINLINE uint32_t FreeRTOS_max_uint32 (uint32_t a, uint32_t b) { return ( a >= b ) ? a : b; }
	static portINLINE int32_t  FreeRTOS_min_int32  (int32_t  a, int32_t  b) { return ( a <= b ) ? a : b; }
	static portINLINE uint32_t FreeRTOS_min_uint32 (uint32_t a, uint32_t b) { return ( a <= b ) ? a : b; }
 80067fa:	429f      	cmp	r7, r3
 80067fc:	bf28      	it	cs
 80067fe:	461f      	movcs	r7, r3
 8006800:	e00c      	b.n	800681c <FreeRTOS_recv+0x1ac>

		/* Check if the socket is valid, has type TCP and if it is bound to a
		port. */
		if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_TCP, pdTRUE ) == pdFALSE )
		{
			xByteCount = -pdFREERTOS_ERRNO_EINVAL;
 8006802:	f06f 0715 	mvn.w	r7, #21
 8006806:	e009      	b.n	800681c <FreeRTOS_recv+0x1ac>
		}
		else if( ( ( ( uint32_t ) xFlags & ( uint32_t ) FREERTOS_ZERO_COPY ) != 0U ) &&
			 ( pvBuffer == NULL ) )
		{
			/* In zero-copy mode, pvBuffer is a pointer to a pointer ( not NULL ). */
			xByteCount = -pdFREERTOS_ERRNO_EINVAL;
 8006808:	f06f 0715 	mvn.w	r7, #21
 800680c:	e006      	b.n	800681c <FreeRTOS_recv+0x1ac>
				{
					/* Shouldn't have cleared other flags. */
					xEventBits &= ~( ( EventBits_t ) eSOCKET_INTR );
					( void ) xEventGroupSetBits( pxSocket->xEventGroup, xEventBits );
				}
				xByteCount = -pdFREERTOS_ERRNO_EINTR;
 800680e:	f06f 0703 	mvn.w	r7, #3
 8006812:	e003      	b.n	800681c <FreeRTOS_recv+0x1ac>
					xByteCount = 0;
				}
			}

		#if( ipconfigSUPPORT_SIGNALS != 0 )
			if( ( xEventBits & ( EventBits_t ) eSOCKET_INTR ) != 0U )
 8006814:	f015 0f40 	tst.w	r5, #64	; 0x40
 8006818:	d1a0      	bne.n	800675c <FreeRTOS_recv+0xec>
 800681a:	2700      	movs	r7, #0
				/* Nothing. */
			}
		} /* prvValidSocket() */

		return xByteCount;
	}
 800681c:	4638      	mov	r0, r7
 800681e:	b009      	add	sp, #36	; 0x24
 8006820:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08006824 <FreeRTOS_send>:
	 * Send data using a TCP socket.  It is not necessary to have the socket
	 * connected already.  Outgoing data will be stored and delivered as soon as
	 * the socket gets connected.
	 */
	BaseType_t FreeRTOS_send( Socket_t xSocket, const void *pvBuffer, size_t uxDataLength, BaseType_t xFlags )
	{
 8006824:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006828:	b089      	sub	sp, #36	; 0x24
 800682a:	4615      	mov	r5, r2
 800682c:	9203      	str	r2, [sp, #12]

		/* Prevent compiler warnings about unused parameters.  The parameter
		may be used in future versions. */
		( void ) xFlags;
		
		if( pvBuffer != NULL )
 800682e:	2900      	cmp	r1, #0
 8006830:	f000 80a5 	beq.w	800697e <FreeRTOS_send+0x15a>
 8006834:	4604      	mov	r4, r0
 8006836:	469b      	mov	fp, r3
 8006838:	460f      	mov	r7, r1
	static int32_t prvTCPSendCheck( FreeRTOS_Socket_t *pxSocket, size_t uxDataLength )
	{
	int32_t xResult = 1;

		/* Is this a socket of type TCP and is it already bound to a port number ? */
		if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_TCP, pdTRUE ) == pdFALSE )
 800683a:	2106      	movs	r1, #6
 800683c:	2201      	movs	r2, #1
 800683e:	f7ff f9ab 	bl	8005b98 <prvValidSocket>
 8006842:	2800      	cmp	r0, #0
 8006844:	f000 809e 	beq.w	8006984 <FreeRTOS_send+0x160>
		{
			xResult = -pdFREERTOS_ERRNO_EINVAL;
		}
		else if( pxSocket->u.xTCP.bits.bMallocError != pdFALSE_UNSIGNED )
 8006848:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 800684c:	f013 0f08 	tst.w	r3, #8
 8006850:	f040 809b 	bne.w	800698a <FreeRTOS_send+0x166>
		{
			xResult = -pdFREERTOS_ERRNO_ENOMEM;
		}
		else if( ( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eCLOSED ) ||
 8006854:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 8006858:	2b00      	cmp	r3, #0
 800685a:	f000 8099 	beq.w	8006990 <FreeRTOS_send+0x16c>
 800685e:	3b08      	subs	r3, #8
 8006860:	b2db      	uxtb	r3, r3
 8006862:	2b01      	cmp	r3, #1
 8006864:	f240 8097 	bls.w	8006996 <FreeRTOS_send+0x172>
				 ( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eCLOSE_WAIT ) ||
				 ( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eCLOSING ) )
		{
			xResult = -pdFREERTOS_ERRNO_ENOTCONN;
		}
		else if( pxSocket->u.xTCP.bits.bFinSent != pdFALSE_UNSIGNED )
 8006868:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 800686c:	f013 0f40 	tst.w	r3, #64	; 0x40
 8006870:	f040 8094 	bne.w	800699c <FreeRTOS_send+0x178>
			/* This TCP connection is closing already, the FIN flag has been sent.
			Maybe it is still delivering or receiving data.
			Return OK in order not to get closed/deleted too quickly */
			xResult = 0;
		}
		else if( uxDataLength == 0UL )
 8006874:	2d00      	cmp	r5, #0
 8006876:	f000 8093 	beq.w	80069a0 <FreeRTOS_send+0x17c>
		{
			/* send() is being called to send zero bytes */
			xResult = 0;
		}
		else if( pxSocket->u.xTCP.txStream == NULL )
 800687a:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 800687c:	b9e3      	cbnz	r3, 80068b8 <FreeRTOS_send+0x94>
				pxSocket->u.xTCP.uxEnoughSpace = ( sock80_PERCENT * pxSocket->u.xTCP.uxRxStreamSize ) / sock100_PERCENT;
			}
		}
		else
		{
			uxLength = pxSocket->u.xTCP.uxTxStreamSize;
 800687e:	6f23      	ldr	r3, [r4, #112]	; 0x70
		}

		/* Add an extra 4 (or 8) bytes. */
		uxLength += sizeof( size_t );
 8006880:	3304      	adds	r3, #4

		/* And make the length a multiple of sizeof( size_t ). */
		uxLength &= ~( sizeof( size_t ) - 1U );
 8006882:	f023 0503 	bic.w	r5, r3, #3

		uxSize = ( sizeof( *pxBuffer )  + uxLength ) - sizeof( pxBuffer->ucArray );

		pxBuffer = ipCAST_PTR_TO_TYPE_PTR( StreamBuffer_t, pvPortMallocLarge( uxSize ) );
 8006886:	f105 0014 	add.w	r0, r5, #20
 800688a:	f7fd fb27 	bl	8003edc <pvPortMalloc>

		if( pxBuffer == NULL )
 800688e:	4606      	mov	r6, r0
 8006890:	b960      	cbnz	r0, 80068ac <FreeRTOS_send+0x88>
		{
			FreeRTOS_debug_printf( ( "prvTCPCreateStream: malloc failed\n" ) );
			pxSocket->u.xTCP.bits.bMallocError = pdTRUE;
 8006892:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 8006896:	f043 0308 	orr.w	r3, r3, #8
 800689a:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
			vTCPStateChange( pxSocket, eCLOSE_WAIT );
 800689e:	4620      	mov	r0, r4
 80068a0:	2108      	movs	r1, #8
 80068a2:	f000 fee3 	bl	800766c <vTCPStateChange>
		else if( pxSocket->u.xTCP.txStream == NULL )
		{
			/* Create the outgoing stream only when it is needed */
			( void ) prvTCPCreateStream( pxSocket, pdFALSE );

			if( pxSocket->u.xTCP.txStream == NULL )
 80068a6:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 80068a8:	b933      	cbnz	r3, 80068b8 <FreeRTOS_send+0x94>
 80068aa:	e07b      	b.n	80069a4 <FreeRTOS_send+0x180>
			vTCPStateChange( pxSocket, eCLOSE_WAIT );
		}
		else
		{
			/* Clear the markers of the stream */
			( void ) memset( pxBuffer, 0, sizeof( *pxBuffer ) - sizeof( pxBuffer->ucArray ) );
 80068ac:	2100      	movs	r1, #0
 80068ae:	2214      	movs	r2, #20
 80068b0:	f003 fb44 	bl	8009f3c <memset>
			pxBuffer->LENGTH = ( size_t ) uxLength ;
 80068b4:	6135      	str	r5, [r6, #16]
				pxSocket->u.xTCP.rxStream = pxBuffer;
			}
			else
			{
				iptraceMEM_STATS_CREATE( tcpTX_STREAM_BUFFER, pxBuffer, uxSize );
				pxSocket->u.xTCP.txStream = pxBuffer;
 80068b6:	67a6      	str	r6, [r4, #120]	; 0x78
		{
			/* xBytesLeft is number of bytes to send, will count to zero. */
			xBytesLeft = ( BaseType_t ) uxDataLength;

			/* xByteCount is number of bytes that can be sent now. */
			xByteCount = ( BaseType_t ) uxStreamBufferGetSpace( pxSocket->u.xTCP.txStream );
 80068b8:	6fa2      	ldr	r2, [r4, #120]	; 0x78
static portINLINE size_t uxStreamBufferGetSpace( const StreamBuffer_t *pxBuffer );
static portINLINE size_t uxStreamBufferGetSpace( const StreamBuffer_t *pxBuffer )
{
/* Returns the number of items which can still be added to uxHead
before hitting on uxTail */
size_t uxHead = pxBuffer->uxHead;
 80068ba:	6891      	ldr	r1, [r2, #8]
size_t uxTail = pxBuffer->uxTail;
 80068bc:	6813      	ldr	r3, [r2, #0]
static portINLINE size_t uxStreamBufferSpace( const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper )
{
/* Returns the space between uxLower and uxUpper, which equals to the distance minus 1 */
size_t uxCount;

	uxCount = pxBuffer->LENGTH + uxUpper - uxLower - 1U;
 80068be:	6912      	ldr	r2, [r2, #16]
 80068c0:	4413      	add	r3, r2
 80068c2:	3b01      	subs	r3, #1
 80068c4:	1a5b      	subs	r3, r3, r1
	if( uxCount >= pxBuffer->LENGTH )
 80068c6:	429a      	cmp	r2, r3
	{
		uxCount -= pxBuffer->LENGTH;
 80068c8:	bf98      	it	ls
 80068ca:	1a9b      	subls	r3, r3, r2

			/* While there are still bytes to be sent. */
			while( xBytesLeft > 0 )
 80068cc:	9a03      	ldr	r2, [sp, #12]
 80068ce:	2a00      	cmp	r2, #0
 80068d0:	dd4c      	ble.n	800696c <FreeRTOS_send+0x148>
 80068d2:	4615      	mov	r5, r2
 80068d4:	f04f 0a00 	mov.w	sl, #0
						( void ) xTaskResumeAll();
					}

					/* Send a message to the IP-task so it can work on this
					socket.  Data is sent, let the IP-task work on it. */
					pxSocket->u.xTCP.usTimeout = 1U;
 80068d8:	2601      	movs	r6, #1

			/* While there are still bytes to be sent. */
			while( xBytesLeft > 0 )
			{
				/* If txStream has space. */
				if( xByteCount > 0 )
 80068da:	2b00      	cmp	r3, #0
 80068dc:	dd1c      	ble.n	8006918 <FreeRTOS_send+0xf4>
 80068de:	42ab      	cmp	r3, r5
 80068e0:	bfa8      	it	ge
 80068e2:	462b      	movge	r3, r5
						xByteCount = xBytesLeft;
					}

					/* Is the close-after-send flag set and is this really the
					last transmission? */
					if( ( pxSocket->u.xTCP.bits.bCloseAfterSend != pdFALSE_UNSIGNED ) && ( xByteCount == xBytesLeft ) )
 80068e4:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
 80068e8:	f012 0f10 	tst.w	r2, #16
 80068ec:	d001      	beq.n	80068f2 <FreeRTOS_send+0xce>
 80068ee:	429d      	cmp	r5, r3
 80068f0:	d05b      	beq.n	80069aa <FreeRTOS_send+0x186>
						setting bCloseRequested must be done together */
						vTaskSuspendAll();
						pxSocket->u.xTCP.bits.bCloseRequested = pdTRUE;
					}

					xByteCount = ( BaseType_t ) uxStreamBufferAdd( pxSocket->u.xTCP.txStream, 0UL, pucSource, ( size_t ) xByteCount );
 80068f2:	6fa0      	ldr	r0, [r4, #120]	; 0x78
 80068f4:	2100      	movs	r1, #0
 80068f6:	463a      	mov	r2, r7
 80068f8:	f000 fc52 	bl	80071a0 <uxStreamBufferAdd>
 80068fc:	4681      	mov	r9, r0
 80068fe:	4680      	mov	r8, r0
						( void ) xTaskResumeAll();
					}

					/* Send a message to the IP-task so it can work on this
					socket.  Data is sent, let the IP-task work on it. */
					pxSocket->u.xTCP.usTimeout = 1U;
 8006900:	f8a4 6048 	strh.w	r6, [r4, #72]	; 0x48

					if( xIsCallingFromIPTask() == pdFALSE )
 8006904:	f7fe fb72 	bl	8004fec <xIsCallingFromIPTask>
 8006908:	b910      	cbnz	r0, 8006910 <FreeRTOS_send+0xec>
					{
						/* Only send a TCP timer event when not called from the
						IP-task. */
						( void ) xSendEventToIPTask( eTCPTimerEvent );
 800690a:	2006      	movs	r0, #6
 800690c:	f7fe fc8e 	bl	800522c <xSendEventToIPTask>
					}

					xBytesLeft -= xByteCount;

					if( xBytesLeft == 0 )
 8006910:	ebb5 0508 	subs.w	r5, r5, r8
 8006914:	d027      	beq.n	8006966 <FreeRTOS_send+0x142>
						break;
					}

					/* As there are still bytes left to be sent, increase the
					data pointer. */
					pucSource = &( pucSource [ xByteCount ] );
 8006916:	444f      	add	r7, r9
				}

				/* Not all bytes have been sent. In case the socket is marked as
				blocking sleep for a while. */
				if( xTimed == pdFALSE )
 8006918:	f1ba 0f00 	cmp.w	sl, #0
 800691c:	d10a      	bne.n	8006934 <FreeRTOS_send+0x110>
				{
					/* Only in the first round, check for non-blocking. */
					xRemainingTime = pxSocket->xSendBlockTime;
 800691e:	6a23      	ldr	r3, [r4, #32]
 8006920:	9307      	str	r3, [sp, #28]
							xRemainingTime = ( TickType_t ) 0;
						}
					}
					#endif /* ipconfigUSE_CALLBACKS */

					if( xRemainingTime == ( TickType_t ) 0 )
 8006922:	b303      	cbz	r3, 8006966 <FreeRTOS_send+0x142>
					{
						break;
					}

					if( ( ( uint32_t ) xFlags & ( uint32_t ) FREERTOS_MSG_DONTWAIT ) != 0U )
 8006924:	f01b 0f10 	tst.w	fp, #16
 8006928:	d11d      	bne.n	8006966 <FreeRTOS_send+0x142>

					/* Don't get here a second time. */
					xTimed = pdTRUE;

					/* Fetch the current time. */
					vTaskSetTimeOutState( &xTimeOut );
 800692a:	a805      	add	r0, sp, #20
 800692c:	f7fc ff16 	bl	800375c <vTaskSetTimeOutState>
					{
						break;
					}

					/* Don't get here a second time. */
					xTimed = pdTRUE;
 8006930:	46b2      	mov	sl, r6
 8006932:	e004      	b.n	800693e <FreeRTOS_send+0x11a>
					vTaskSetTimeOutState( &xTimeOut );
				}
				else
				{
					/* Has the timeout been reached? */
					if( xTaskCheckForTimeOut( &xTimeOut, &xRemainingTime ) != pdFALSE )
 8006934:	a805      	add	r0, sp, #20
 8006936:	a907      	add	r1, sp, #28
 8006938:	f7fc ff38 	bl	80037ac <xTaskCheckForTimeOut>
 800693c:	b998      	cbnz	r0, 8006966 <FreeRTOS_send+0x142>
						break;
					}
				}

				/* Go sleeping until down-stream events are received. */
				( void ) xEventGroupWaitBits( pxSocket->xEventGroup, ( EventBits_t ) eSOCKET_SEND | ( EventBits_t ) eSOCKET_CLOSED,
 800693e:	9b07      	ldr	r3, [sp, #28]
 8006940:	9300      	str	r3, [sp, #0]
 8006942:	6860      	ldr	r0, [r4, #4]
 8006944:	2122      	movs	r1, #34	; 0x22
 8006946:	4632      	mov	r2, r6
 8006948:	2300      	movs	r3, #0
 800694a:	f7fb fba3 	bl	8002094 <xEventGroupWaitBits>
					pdTRUE /*xClearOnExit*/, pdFALSE /*xWaitAllBits*/, xRemainingTime );

				xByteCount = ( BaseType_t ) uxStreamBufferGetSpace( pxSocket->u.xTCP.txStream );
 800694e:	6fa2      	ldr	r2, [r4, #120]	; 0x78
static portINLINE size_t uxStreamBufferGetSpace( const StreamBuffer_t *pxBuffer );
static portINLINE size_t uxStreamBufferGetSpace( const StreamBuffer_t *pxBuffer )
{
/* Returns the number of items which can still be added to uxHead
before hitting on uxTail */
size_t uxHead = pxBuffer->uxHead;
 8006950:	6891      	ldr	r1, [r2, #8]
size_t uxTail = pxBuffer->uxTail;
 8006952:	6813      	ldr	r3, [r2, #0]
static portINLINE size_t uxStreamBufferSpace( const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper )
{
/* Returns the space between uxLower and uxUpper, which equals to the distance minus 1 */
size_t uxCount;

	uxCount = pxBuffer->LENGTH + uxUpper - uxLower - 1U;
 8006954:	6912      	ldr	r2, [r2, #16]
 8006956:	4413      	add	r3, r2
 8006958:	3b01      	subs	r3, #1
 800695a:	1a5b      	subs	r3, r3, r1
	if( uxCount >= pxBuffer->LENGTH )
 800695c:	429a      	cmp	r2, r3
	{
		uxCount -= pxBuffer->LENGTH;
 800695e:	bf98      	it	ls
 8006960:	1a9b      	subls	r3, r3, r2

			/* xByteCount is number of bytes that can be sent now. */
			xByteCount = ( BaseType_t ) uxStreamBufferGetSpace( pxSocket->u.xTCP.txStream );

			/* While there are still bytes to be sent. */
			while( xBytesLeft > 0 )
 8006962:	2d00      	cmp	r5, #0
 8006964:	dcb9      	bgt.n	80068da <FreeRTOS_send+0xb6>
			}

			/* How much was actually sent? */
			xByteCount = ( ( BaseType_t ) uxDataLength ) - xBytesLeft;

			if( xByteCount == 0 )
 8006966:	9b03      	ldr	r3, [sp, #12]
 8006968:	1b58      	subs	r0, r3, r5
 800696a:	d131      	bne.n	80069d0 <FreeRTOS_send+0x1ac>
			{
				if( pxSocket->u.xTCP.ucTCPState > ( uint8_t ) eESTABLISHED )
 800696c:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
							pxSocket->usLocalPort,
							pxSocket->u.xTCP.ulRemoteIP,
							pxSocket->u.xTCP.usRemotePort ) );
					}

					xByteCount = ( BaseType_t ) -pdFREERTOS_ERRNO_ENOSPC;
 8006970:	2b05      	cmp	r3, #5
 8006972:	bf8c      	ite	hi
 8006974:	f06f 007f 	mvnhi.w	r0, #127	; 0x7f
 8006978:	f06f 001b 	mvnls.w	r0, #27
 800697c:	e028      	b.n	80069d0 <FreeRTOS_send+0x1ac>
	 * connected already.  Outgoing data will be stored and delivered as soon as
	 * the socket gets connected.
	 */
	BaseType_t FreeRTOS_send( Socket_t xSocket, const void *pvBuffer, size_t uxDataLength, BaseType_t xFlags )
	{
	BaseType_t xByteCount = -pdFREERTOS_ERRNO_EINVAL;
 800697e:	f06f 0015 	mvn.w	r0, #21
 8006982:	e025      	b.n	80069d0 <FreeRTOS_send+0x1ac>
	int32_t xResult = 1;

		/* Is this a socket of type TCP and is it already bound to a port number ? */
		if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_TCP, pdTRUE ) == pdFALSE )
		{
			xResult = -pdFREERTOS_ERRNO_EINVAL;
 8006984:	f06f 0015 	mvn.w	r0, #21
 8006988:	e022      	b.n	80069d0 <FreeRTOS_send+0x1ac>
		}
		else if( pxSocket->u.xTCP.bits.bMallocError != pdFALSE_UNSIGNED )
		{
			xResult = -pdFREERTOS_ERRNO_ENOMEM;
 800698a:	f06f 000b 	mvn.w	r0, #11
 800698e:	e01f      	b.n	80069d0 <FreeRTOS_send+0x1ac>
		}
		else if( ( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eCLOSED ) ||
				 ( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eCLOSE_WAIT ) ||
				 ( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eCLOSING ) )
		{
			xResult = -pdFREERTOS_ERRNO_ENOTCONN;
 8006990:	f06f 007f 	mvn.w	r0, #127	; 0x7f
 8006994:	e01c      	b.n	80069d0 <FreeRTOS_send+0x1ac>
 8006996:	f06f 007f 	mvn.w	r0, #127	; 0x7f
 800699a:	e019      	b.n	80069d0 <FreeRTOS_send+0x1ac>
		else if( pxSocket->u.xTCP.bits.bFinSent != pdFALSE_UNSIGNED )
		{
			/* This TCP connection is closing already, the FIN flag has been sent.
			Maybe it is still delivering or receiving data.
			Return OK in order not to get closed/deleted too quickly */
			xResult = 0;
 800699c:	2000      	movs	r0, #0
 800699e:	e017      	b.n	80069d0 <FreeRTOS_send+0x1ac>
		}
		else if( uxDataLength == 0UL )
		{
			/* send() is being called to send zero bytes */
			xResult = 0;
 80069a0:	2000      	movs	r0, #0
 80069a2:	e015      	b.n	80069d0 <FreeRTOS_send+0x1ac>
			/* Create the outgoing stream only when it is needed */
			( void ) prvTCPCreateStream( pxSocket, pdFALSE );

			if( pxSocket->u.xTCP.txStream == NULL )
			{
				xResult = -pdFREERTOS_ERRNO_ENOMEM;
 80069a4:	f06f 000b 	mvn.w	r0, #11
 80069a8:	e012      	b.n	80069d0 <FreeRTOS_send+0x1ac>
					FTP). */
					if( xCloseAfterSend != pdFALSE )
					{
						/* Now suspend the scheduler: sending the last data	and
						setting bCloseRequested must be done together */
						vTaskSuspendAll();
 80069aa:	f7fc fbff 	bl	80031ac <vTaskSuspendAll>
						pxSocket->u.xTCP.bits.bCloseRequested = pdTRUE;
 80069ae:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 80069b2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80069b6:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
					}

					xByteCount = ( BaseType_t ) uxStreamBufferAdd( pxSocket->u.xTCP.txStream, 0UL, pucSource, ( size_t ) xByteCount );
 80069ba:	6fa0      	ldr	r0, [r4, #120]	; 0x78
 80069bc:	2100      	movs	r1, #0
 80069be:	463a      	mov	r2, r7
 80069c0:	462b      	mov	r3, r5
 80069c2:	f000 fbed 	bl	80071a0 <uxStreamBufferAdd>
 80069c6:	4681      	mov	r9, r0
 80069c8:	4680      	mov	r8, r0
					if( xCloseAfterSend != pdFALSE )
					{
						/* Now when the IP-task transmits the data, it will also
						see	that bCloseRequested is true and include the FIN
						flag to start closure of the connection. */
						( void ) xTaskResumeAll();
 80069ca:	f7fc fc8f 	bl	80032ec <xTaskResumeAll>
 80069ce:	e797      	b.n	8006900 <FreeRTOS_send+0xdc>
				}
			}
		}

		return xByteCount;
	}
 80069d0:	b009      	add	sp, #36	; 0x24
 80069d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80069d6:	bf00      	nop

080069d8 <FreeRTOS_listen>:

	/*
	 * Request to put a socket in listen mode
	 */
	BaseType_t FreeRTOS_listen( Socket_t xSocket, BaseType_t xBacklog )
	{
 80069d8:	b538      	push	{r3, r4, r5, lr}
 80069da:	4604      	mov	r4, r0
 80069dc:	460d      	mov	r5, r1

		pxSocket = ( FreeRTOS_Socket_t * ) xSocket;

		/* listen() is allowed for a valid TCP socket in Closed state and already
		bound. */
		if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_TCP, pdTRUE ) == pdFALSE )
 80069de:	2106      	movs	r1, #6
 80069e0:	2201      	movs	r2, #1
 80069e2:	f7ff f8d9 	bl	8005b98 <prvValidSocket>
 80069e6:	2800      	cmp	r0, #0
 80069e8:	d03a      	beq.n	8006a60 <FreeRTOS_listen+0x88>
		{
			xResult = -pdFREERTOS_ERRNO_EOPNOTSUPP;
		}
		else if( ( pxSocket->u.xTCP.ucTCPState != ( uint8_t ) eCLOSED ) && ( pxSocket->u.xTCP.ucTCPState != ( uint8_t ) eCLOSE_WAIT ) )
 80069ea:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 80069ee:	f013 0ff7 	tst.w	r3, #247	; 0xf7
 80069f2:	d138      	bne.n	8006a66 <FreeRTOS_listen+0x8e>
	static portINLINE uint32_t FreeRTOS_round_down (uint32_t a, uint32_t d);
	static portINLINE BaseType_t  FreeRTOS_min_BaseType  (BaseType_t  a, BaseType_t  b);

	static portINLINE int32_t  FreeRTOS_max_int32  (int32_t  a, int32_t  b) { return ( a >= b ) ? a : b; }
	static portINLINE uint32_t FreeRTOS_max_uint32 (uint32_t a, uint32_t b) { return ( a >= b ) ? a : b; }
	static portINLINE int32_t  FreeRTOS_min_int32  (int32_t  a, int32_t  b) { return ( a <= b ) ? a : b; }
 80069f4:	f64f 71ff 	movw	r1, #65535	; 0xffff
 80069f8:	42a9      	cmp	r1, r5
 80069fa:	bfa8      	it	ge
 80069fc:	4629      	movge	r1, r5
		}
		else
		{
			/* Backlog is interpreted here as "the maximum number of child
			sockets. */
			pxSocket->u.xTCP.usBacklog = ( uint16_t )FreeRTOS_min_int32( ( int32_t ) 0xffff, ( int32_t ) xBacklog );
 80069fe:	f8a4 1050 	strh.w	r1, [r4, #80]	; 0x50

			/* This cleaning is necessary only if a listening socket is being
			reused as it might have had a previous connection. */
			if( pxSocket->u.xTCP.bits.bReuseSocket != pdFALSE_UNSIGNED )
 8006a02:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8006a06:	f013 0f08 	tst.w	r3, #8
 8006a0a:	d023      	beq.n	8006a54 <FreeRTOS_listen+0x7c>
			{
				if( pxSocket->u.xTCP.rxStream != NULL )
 8006a0c:	6f63      	ldr	r3, [r4, #116]	; 0x74
 8006a0e:	b123      	cbz	r3, 8006a1a <FreeRTOS_listen+0x42>

static portINLINE void vStreamBufferClear( StreamBuffer_t *pxBuffer );
static portINLINE void vStreamBufferClear( StreamBuffer_t *pxBuffer )
{
	/* Make the circular buffer empty */
	pxBuffer->uxHead = 0U;
 8006a10:	2200      	movs	r2, #0
 8006a12:	609a      	str	r2, [r3, #8]
	pxBuffer->uxTail = 0U;
 8006a14:	601a      	str	r2, [r3, #0]
	pxBuffer->uxFront = 0U;
 8006a16:	60da      	str	r2, [r3, #12]
	pxBuffer->uxMid = 0U;
 8006a18:	605a      	str	r2, [r3, #4]
				{
					vStreamBufferClear( pxSocket->u.xTCP.rxStream );
				}

				if( pxSocket->u.xTCP.txStream != NULL )
 8006a1a:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 8006a1c:	b123      	cbz	r3, 8006a28 <FreeRTOS_listen+0x50>

static portINLINE void vStreamBufferClear( StreamBuffer_t *pxBuffer );
static portINLINE void vStreamBufferClear( StreamBuffer_t *pxBuffer )
{
	/* Make the circular buffer empty */
	pxBuffer->uxHead = 0U;
 8006a1e:	2200      	movs	r2, #0
 8006a20:	609a      	str	r2, [r3, #8]
	pxBuffer->uxTail = 0U;
 8006a22:	601a      	str	r2, [r3, #0]
	pxBuffer->uxFront = 0U;
 8006a24:	60da      	str	r2, [r3, #12]
	pxBuffer->uxMid = 0U;
 8006a26:	605a      	str	r2, [r3, #4]
				{
					vStreamBufferClear( pxSocket->u.xTCP.txStream );
				}

				( void ) memset( pxSocket->u.xTCP.xPacket.u.ucLastPacket, 0, sizeof( pxSocket->u.xTCP.xPacket.u.ucLastPacket ) );
 8006a28:	f104 0082 	add.w	r0, r4, #130	; 0x82
 8006a2c:	2100      	movs	r1, #0
 8006a2e:	2246      	movs	r2, #70	; 0x46
 8006a30:	f003 fa84 	bl	8009f3c <memset>
				( void ) memset( &pxSocket->u.xTCP.xTCPWindow, 0, sizeof( pxSocket->u.xTCP.xTCPWindow ) );
 8006a34:	f104 00d8 	add.w	r0, r4, #216	; 0xd8
 8006a38:	2100      	movs	r1, #0
 8006a3a:	22c0      	movs	r2, #192	; 0xc0
 8006a3c:	f003 fa7e 	bl	8009f3c <memset>
				( void ) memset( &pxSocket->u.xTCP.bits, 0, sizeof( pxSocket->u.xTCP.bits ) );
 8006a40:	2300      	movs	r3, #0
 8006a42:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
 8006a46:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8006a4a:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43

				/* Now set the bReuseSocket flag again, because the bits have
				just been cleared. */
				pxSocket->u.xTCP.bits.bReuseSocket = pdTRUE;
 8006a4e:	2308      	movs	r3, #8
 8006a50:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
			}

			vTCPStateChange( pxSocket, eTCP_LISTEN );
 8006a54:	4620      	mov	r0, r4
 8006a56:	2101      	movs	r1, #1
 8006a58:	f000 fe08 	bl	800766c <vTCPStateChange>
	 * Request to put a socket in listen mode
	 */
	BaseType_t FreeRTOS_listen( Socket_t xSocket, BaseType_t xBacklog )
	{
	FreeRTOS_Socket_t *pxSocket;
	BaseType_t xResult = 0;
 8006a5c:	2000      	movs	r0, #0
 8006a5e:	bd38      	pop	{r3, r4, r5, pc}

		/* listen() is allowed for a valid TCP socket in Closed state and already
		bound. */
		if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_TCP, pdTRUE ) == pdFALSE )
		{
			xResult = -pdFREERTOS_ERRNO_EOPNOTSUPP;
 8006a60:	f06f 005e 	mvn.w	r0, #94	; 0x5e
 8006a64:	bd38      	pop	{r3, r4, r5, pc}
		}
		else if( ( pxSocket->u.xTCP.ucTCPState != ( uint8_t ) eCLOSED ) && ( pxSocket->u.xTCP.ucTCPState != ( uint8_t ) eCLOSE_WAIT ) )
		{
			/* Socket is in a wrong state. */
			xResult = -pdFREERTOS_ERRNO_EOPNOTSUPP;
 8006a66:	f06f 005e 	mvn.w	r0, #94	; 0x5e

			vTCPStateChange( pxSocket, eTCP_LISTEN );
		}

		return xResult;
	}
 8006a6a:	bd38      	pop	{r3, r4, r5, pc}

08006a6c <FreeRTOS_shutdown>:

#if( ipconfigUSE_TCP == 1 )

	/* shutdown - shut down part of a full-duplex connection */
	BaseType_t FreeRTOS_shutdown( Socket_t xSocket, BaseType_t xHow )
	{
 8006a6c:	b510      	push	{r4, lr}
 8006a6e:	4604      	mov	r4, r0
	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
	BaseType_t xResult;

		if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_TCP, pdTRUE ) == pdFALSE )
 8006a70:	2106      	movs	r1, #6
 8006a72:	2201      	movs	r2, #1
 8006a74:	f7ff f890 	bl	8005b98 <prvValidSocket>
 8006a78:	b188      	cbz	r0, 8006a9e <FreeRTOS_shutdown+0x32>
		{
			/*_RB_ Is this comment correct?  The socket is not of a type that
			supports the listen() operation. */
			xResult = -pdFREERTOS_ERRNO_EOPNOTSUPP;
		}
		else if ( pxSocket->u.xTCP.ucTCPState != ( uint8_t ) eESTABLISHED )
 8006a7a:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 8006a7e:	2b05      	cmp	r3, #5
 8006a80:	d110      	bne.n	8006aa4 <FreeRTOS_shutdown+0x38>
			supports the listen() operation. */
			xResult = -pdFREERTOS_ERRNO_EOPNOTSUPP;
		}
		else
		{
			pxSocket->u.xTCP.bits.bUserShutdown = pdTRUE_UNSIGNED;
 8006a82:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8006a86:	f043 0320 	orr.w	r3, r3, #32
 8006a8a:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40

			/* Let the IP-task perform the shutdown of the connection. */
			pxSocket->u.xTCP.usTimeout = 1U;
 8006a8e:	2301      	movs	r3, #1
 8006a90:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
			( void ) xSendEventToIPTask( eTCPTimerEvent );
 8006a94:	2006      	movs	r0, #6
 8006a96:	f7fe fbc9 	bl	800522c <xSendEventToIPTask>
			xResult = 0;
 8006a9a:	2000      	movs	r0, #0
 8006a9c:	bd10      	pop	{r4, pc}

		if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_TCP, pdTRUE ) == pdFALSE )
		{
			/*_RB_ Is this comment correct?  The socket is not of a type that
			supports the listen() operation. */
			xResult = -pdFREERTOS_ERRNO_EOPNOTSUPP;
 8006a9e:	f06f 005e 	mvn.w	r0, #94	; 0x5e
 8006aa2:	bd10      	pop	{r4, pc}
		}
		else if ( pxSocket->u.xTCP.ucTCPState != ( uint8_t ) eESTABLISHED )
		{
			/*_RB_ Is this comment correct?  The socket is not of a type that
			supports the listen() operation. */
			xResult = -pdFREERTOS_ERRNO_EOPNOTSUPP;
 8006aa4:	f06f 005e 	mvn.w	r0, #94	; 0x5e
			xResult = 0;
		}
		(void) xHow;

		return xResult;
	}
 8006aa8:	bd10      	pop	{r4, pc}
 8006aaa:	bf00      	nop

08006aac <xTCPTimerCheck>:
	 * - Send new data
	 * - Send a keep-alive packet
	 * - Check for timeout (in non-connected states only)
	 */
	TickType_t xTCPTimerCheck( BaseType_t xWillSleep )
	{
 8006aac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8006ab0:	4682      	mov	sl, r0
	FreeRTOS_Socket_t *pxSocket;
	TickType_t xShortest = pdMS_TO_TICKS( ( TickType_t ) ipTCP_TIMER_PERIOD_MS );
	TickType_t xNow = xTaskGetTickCount();
 8006ab2:	f7fc fb83 	bl	80031bc <xTaskGetTickCount>
	static TickType_t xLastTime = 0U;
	TickType_t xDelta = xNow - xLastTime;
 8006ab6:	4b1e      	ldr	r3, [pc, #120]	; (8006b30 <xTCPTimerCheck+0x84>)
 8006ab8:	681e      	ldr	r6, [r3, #0]
 8006aba:	1b86      	subs	r6, r0, r6
	const ListItem_t* pxEnd = listGET_END_MARKER( &xBoundTCPSocketsList );
	const ListItem_t *pxIterator = ( const ListItem_t * ) listGET_HEAD_ENTRY( &xBoundTCPSocketsList );
 8006abc:	4a1d      	ldr	r2, [pc, #116]	; (8006b34 <xTCPTimerCheck+0x88>)
 8006abe:	68d4      	ldr	r4, [r2, #12]

		xLastTime = xNow;
 8006ac0:	6018      	str	r0, [r3, #0]

		if( xDelta == 0U )
		{
			xDelta = 1U;
 8006ac2:	2e00      	cmp	r6, #0
 8006ac4:	bf08      	it	eq
 8006ac6:	2601      	moveq	r6, #1
		}

		while( pxIterator != pxEnd )
 8006ac8:	f102 0308 	add.w	r3, r2, #8
 8006acc:	429c      	cmp	r4, r3
 8006ace:	d029      	beq.n	8006b24 <xTCPTimerCheck+0x78>
 8006ad0:	f44f 787a 	mov.w	r8, #1000	; 0x3e8
				}
				else
				{
					/* Or else make sure this will be called again to wake-up
					the sockets' owner. */
					xShortest = ( TickType_t ) 0;
 8006ad4:	f04f 0900 	mov.w	r9, #0
		if( xDelta == 0U )
		{
			xDelta = 1U;
		}

		while( pxIterator != pxEnd )
 8006ad8:	461f      	mov	r7, r3
		{
			pxSocket = ipCAST_PTR_TO_TYPE_PTR( FreeRTOS_Socket_t, listGET_LIST_ITEM_OWNER( pxIterator ) );
 8006ada:	68e5      	ldr	r5, [r4, #12]
			pxIterator = ( ListItem_t * ) listGET_NEXT( pxIterator );
 8006adc:	6864      	ldr	r4, [r4, #4]

			/* Sockets with 'tmout == 0' do not need any regular attention. */
			if( pxSocket->u.xTCP.usTimeout == 0U )
 8006ade:	f8b5 3048 	ldrh.w	r3, [r5, #72]	; 0x48
 8006ae2:	b1e3      	cbz	r3, 8006b1e <xTCPTimerCheck+0x72>
			{
				continue;
			}

			if( xDelta < ( TickType_t ) pxSocket->u.xTCP.usTimeout )
 8006ae4:	42b3      	cmp	r3, r6
 8006ae6:	d903      	bls.n	8006af0 <xTCPTimerCheck+0x44>
			{
				pxSocket->u.xTCP.usTimeout = ( uint16_t ) ( ( ( TickType_t ) pxSocket->u.xTCP.usTimeout ) - xDelta );
 8006ae8:	1b9b      	subs	r3, r3, r6
 8006aea:	f8a5 3048 	strh.w	r3, [r5, #72]	; 0x48
 8006aee:	e006      	b.n	8006afe <xTCPTimerCheck+0x52>
			}
			else
			{
			BaseType_t xRc;

				pxSocket->u.xTCP.usTimeout = 0U;
 8006af0:	f8a5 9048 	strh.w	r9, [r5, #72]	; 0x48
				xRc = xTCPSocketCheck( pxSocket );
 8006af4:	4628      	mov	r0, r5
 8006af6:	f001 f821 	bl	8007b3c <xTCPSocketCheck>

				/* Within this function, the socket might want to send a delayed
				ack or send out data or whatever it needs to do. */
				if( xRc < 0 )
 8006afa:	2800      	cmp	r0, #0
 8006afc:	db0f      	blt.n	8006b1e <xTCPTimerCheck+0x72>
			}

			/* In xEventBits the driver may indicate that the socket has
			important events for the user.  These are only done just before the
			IP-task goes to sleep. */
			if( pxSocket->xEventBits != 0U )
 8006afe:	682b      	ldr	r3, [r5, #0]
 8006b00:	b13b      	cbz	r3, 8006b12 <xTCPTimerCheck+0x66>
			{
				if( xWillSleep != pdFALSE )
 8006b02:	f1ba 0f00 	cmp.w	sl, #0
 8006b06:	d003      	beq.n	8006b10 <xTCPTimerCheck+0x64>
				{
					/* The IP-task is about to go to sleep, so messages can be
					sent to the socket owners. */
					vSocketWakeUpUser( pxSocket );
 8006b08:	4628      	mov	r0, r5
 8006b0a:	f7ff fd01 	bl	8006510 <vSocketWakeUpUser>
 8006b0e:	e000      	b.n	8006b12 <xTCPTimerCheck+0x66>
				}
				else
				{
					/* Or else make sure this will be called again to wake-up
					the sockets' owner. */
					xShortest = ( TickType_t ) 0;
 8006b10:	46c8      	mov	r8, r9
				}
			}

			if( ( pxSocket->u.xTCP.usTimeout != 0U ) && ( xShortest > ( TickType_t ) pxSocket->u.xTCP.usTimeout ) )
 8006b12:	f8b5 3048 	ldrh.w	r3, [r5, #72]	; 0x48
 8006b16:	b113      	cbz	r3, 8006b1e <xTCPTimerCheck+0x72>
 8006b18:	4598      	cmp	r8, r3
 8006b1a:	bf28      	it	cs
 8006b1c:	4698      	movcs	r8, r3
		if( xDelta == 0U )
		{
			xDelta = 1U;
		}

		while( pxIterator != pxEnd )
 8006b1e:	42bc      	cmp	r4, r7
 8006b20:	d1db      	bne.n	8006ada <xTCPTimerCheck+0x2e>
 8006b22:	e001      	b.n	8006b28 <xTCPTimerCheck+0x7c>
 8006b24:	f44f 787a 	mov.w	r8, #1000	; 0x3e8
				xShortest = ( TickType_t ) pxSocket->u.xTCP.usTimeout;
			}
		}

		return xShortest;
	}
 8006b28:	4640      	mov	r0, r8
 8006b2a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8006b2e:	bf00      	nop
 8006b30:	2000d3c4 	.word	0x2000d3c4
 8006b34:	2000d4f8 	.word	0x2000d4f8

08006b38 <pxTCPSocketLookup>:
	 * looking up a socket is a little more complex:
	 * Both a local port, and a remote port and IP address are being used
	 * For a socket in listening mode, the remote port and IP address are both 0
	 */
	FreeRTOS_Socket_t *pxTCPSocketLookup( uint32_t ulLocalIP, UBaseType_t uxLocalPort, uint32_t ulRemoteIP, UBaseType_t uxRemotePort )
	{
 8006b38:	b4f0      	push	{r4, r5, r6, r7}
	const ListItem_t *pxEnd = listGET_END_MARKER( &xBoundTCPSocketsList );

		/* Parameter not yet supported. */
		( void ) ulLocalIP;

		for( pxIterator  = listGET_NEXT( pxEnd );
 8006b3a:	4811      	ldr	r0, [pc, #68]	; (8006b80 <pxTCPSocketLookup+0x48>)
 8006b3c:	68c4      	ldr	r4, [r0, #12]
 8006b3e:	3008      	adds	r0, #8
 8006b40:	4284      	cmp	r4, r0
 8006b42:	d01a      	beq.n	8006b7a <pxTCPSocketLookup+0x42>
 8006b44:	2000      	movs	r0, #0
			 pxIterator != pxEnd;
			 pxIterator  = listGET_NEXT( pxIterator ) )
		{
			FreeRTOS_Socket_t *pxSocket = ipCAST_PTR_TO_TYPE_PTR( FreeRTOS_Socket_t, listGET_LIST_ITEM_OWNER( pxIterator ) );

			if( pxSocket->usLocalPort == ( uint16_t ) uxLocalPort )
 8006b46:	b289      	uxth	r1, r1
				{
					/* If this is a socket listening to uxLocalPort, remember it
					in case there is no perfect match. */
					pxListenSocket = pxSocket;
				}
				else if( ( pxSocket->u.xTCP.usRemotePort == ( uint16_t ) uxRemotePort ) && ( pxSocket->u.xTCP.ulRemoteIP == ulRemoteIP ) )
 8006b48:	b29b      	uxth	r3, r3
	const ListItem_t *pxEnd = listGET_END_MARKER( &xBoundTCPSocketsList );

		/* Parameter not yet supported. */
		( void ) ulLocalIP;

		for( pxIterator  = listGET_NEXT( pxEnd );
 8006b4a:	4f0e      	ldr	r7, [pc, #56]	; (8006b84 <pxTCPSocketLookup+0x4c>)
			 pxIterator != pxEnd;
			 pxIterator  = listGET_NEXT( pxIterator ) )
		{
			FreeRTOS_Socket_t *pxSocket = ipCAST_PTR_TO_TYPE_PTR( FreeRTOS_Socket_t, listGET_LIST_ITEM_OWNER( pxIterator ) );
 8006b4c:	68e5      	ldr	r5, [r4, #12]

			if( pxSocket->usLocalPort == ( uint16_t ) uxLocalPort )
 8006b4e:	8cae      	ldrh	r6, [r5, #36]	; 0x24
 8006b50:	428e      	cmp	r6, r1
 8006b52:	d10e      	bne.n	8006b72 <pxTCPSocketLookup+0x3a>
			{
				if( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eTCP_LISTEN )
 8006b54:	f895 6053 	ldrb.w	r6, [r5, #83]	; 0x53
 8006b58:	2e01      	cmp	r6, #1
 8006b5a:	d009      	beq.n	8006b70 <pxTCPSocketLookup+0x38>
				{
					/* If this is a socket listening to uxLocalPort, remember it
					in case there is no perfect match. */
					pxListenSocket = pxSocket;
				}
				else if( ( pxSocket->u.xTCP.usRemotePort == ( uint16_t ) uxRemotePort ) && ( pxSocket->u.xTCP.ulRemoteIP == ulRemoteIP ) )
 8006b5c:	8fae      	ldrh	r6, [r5, #60]	; 0x3c
 8006b5e:	429e      	cmp	r6, r3
 8006b60:	d107      	bne.n	8006b72 <pxTCPSocketLookup+0x3a>
 8006b62:	6bae      	ldr	r6, [r5, #56]	; 0x38
 8006b64:	4296      	cmp	r6, r2
 8006b66:	d104      	bne.n	8006b72 <pxTCPSocketLookup+0x3a>

		for( pxIterator  = listGET_NEXT( pxEnd );
			 pxIterator != pxEnd;
			 pxIterator  = listGET_NEXT( pxIterator ) )
		{
			FreeRTOS_Socket_t *pxSocket = ipCAST_PTR_TO_TYPE_PTR( FreeRTOS_Socket_t, listGET_LIST_ITEM_OWNER( pxIterator ) );
 8006b68:	2d00      	cmp	r5, #0
 8006b6a:	bf18      	it	ne
 8006b6c:	4628      	movne	r0, r5
 8006b6e:	e005      	b.n	8006b7c <pxTCPSocketLookup+0x44>
 8006b70:	4628      	mov	r0, r5
		/* Parameter not yet supported. */
		( void ) ulLocalIP;

		for( pxIterator  = listGET_NEXT( pxEnd );
			 pxIterator != pxEnd;
			 pxIterator  = listGET_NEXT( pxIterator ) )
 8006b72:	6864      	ldr	r4, [r4, #4]
	const ListItem_t *pxEnd = listGET_END_MARKER( &xBoundTCPSocketsList );

		/* Parameter not yet supported. */
		( void ) ulLocalIP;

		for( pxIterator  = listGET_NEXT( pxEnd );
 8006b74:	42bc      	cmp	r4, r7
 8006b76:	d1e9      	bne.n	8006b4c <pxTCPSocketLookup+0x14>
 8006b78:	e000      	b.n	8006b7c <pxTCPSocketLookup+0x44>
	 * For a socket in listening mode, the remote port and IP address are both 0
	 */
	FreeRTOS_Socket_t *pxTCPSocketLookup( uint32_t ulLocalIP, UBaseType_t uxLocalPort, uint32_t ulRemoteIP, UBaseType_t uxRemotePort )
	{
	const ListItem_t *pxIterator;
	FreeRTOS_Socket_t *pxResult = NULL, *pxListenSocket = NULL;
 8006b7a:	2000      	movs	r0, #0
			found. */
			pxResult = pxListenSocket;
		}

		return pxResult;
	}
 8006b7c:	bcf0      	pop	{r4, r5, r6, r7}
 8006b7e:	4770      	bx	lr
 8006b80:	2000d4f8 	.word	0x2000d4f8
 8006b84:	2000d500 	.word	0x2000d500

08006b88 <lTCPAddRxdata>:
	/*
	 * Add data to the RxStream.  When uxOffset > 0, data has come in out-of-order
	 * and will be put in front of the head so it can not be popped by the user.
	 */
	int32_t lTCPAddRxdata( FreeRTOS_Socket_t *pxSocket, size_t uxOffset, const uint8_t *pcData, uint32_t ulByteCount )
	{
 8006b88:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8006b8c:	4604      	mov	r4, r0
 8006b8e:	460e      	mov	r6, r1
 8006b90:	4690      	mov	r8, r2
 8006b92:	461f      	mov	r7, r3
	StreamBuffer_t *pxStream = pxSocket->u.xTCP.rxStream;
 8006b94:	6f45      	ldr	r5, [r0, #116]	; 0x74
		/* int32_t uxStreamBufferAdd( pxBuffer, uxOffset, pucData, aCount )
		if( pucData != NULL ) copy data the the buffer
		if( pucData == NULL ) no copying, just advance rxHead
		if( uxOffset != 0 ) Just store data which has come out-of-order
		if( uxOffset == 0 ) Also advance rxHead */
		if( pxStream == NULL )
 8006b96:	bb9d      	cbnz	r5, 8006c00 <lTCPAddRxdata+0x78>

		/* Now that a stream is created, the maximum size is fixed before
		creation, it could still be changed with setsockopt(). */
		if( xIsInputStream != pdFALSE )
		{
			uxLength = pxSocket->u.xTCP.uxRxStreamSize;
 8006b98:	6ec3      	ldr	r3, [r0, #108]	; 0x6c

			if( pxSocket->u.xTCP.uxLittleSpace == 0UL )
 8006b9a:	6e42      	ldr	r2, [r0, #100]	; 0x64
 8006b9c:	b93a      	cbnz	r2, 8006bae <lTCPAddRxdata+0x26>
			{
				pxSocket->u.xTCP.uxLittleSpace  = ( sock20_PERCENT * pxSocket->u.xTCP.uxRxStreamSize ) / sock100_PERCENT;
 8006b9e:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 8006ba2:	0092      	lsls	r2, r2, #2
 8006ba4:	4934      	ldr	r1, [pc, #208]	; (8006c78 <lTCPAddRxdata+0xf0>)
 8006ba6:	fba1 1202 	umull	r1, r2, r1, r2
 8006baa:	0952      	lsrs	r2, r2, #5
 8006bac:	6642      	str	r2, [r0, #100]	; 0x64
			}

			if( pxSocket->u.xTCP.uxEnoughSpace == 0UL )
 8006bae:	6ea2      	ldr	r2, [r4, #104]	; 0x68
 8006bb0:	b93a      	cbnz	r2, 8006bc2 <lTCPAddRxdata+0x3a>
			{
				pxSocket->u.xTCP.uxEnoughSpace = ( sock80_PERCENT * pxSocket->u.xTCP.uxRxStreamSize ) / sock100_PERCENT;
 8006bb2:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 8006bb6:	0112      	lsls	r2, r2, #4
 8006bb8:	492f      	ldr	r1, [pc, #188]	; (8006c78 <lTCPAddRxdata+0xf0>)
 8006bba:	fba1 1202 	umull	r1, r2, r1, r2
 8006bbe:	0952      	lsrs	r2, r2, #5
 8006bc0:	66a2      	str	r2, [r4, #104]	; 0x68
		{
			uxLength = pxSocket->u.xTCP.uxTxStreamSize;
		}

		/* Add an extra 4 (or 8) bytes. */
		uxLength += sizeof( size_t );
 8006bc2:	3304      	adds	r3, #4

		/* And make the length a multiple of sizeof( size_t ). */
		uxLength &= ~( sizeof( size_t ) - 1U );
 8006bc4:	f023 0903 	bic.w	r9, r3, #3

		uxSize = ( sizeof( *pxBuffer )  + uxLength ) - sizeof( pxBuffer->ucArray );

		pxBuffer = ipCAST_PTR_TO_TYPE_PTR( StreamBuffer_t, pvPortMallocLarge( uxSize ) );
 8006bc8:	f109 0014 	add.w	r0, r9, #20
 8006bcc:	f7fd f986 	bl	8003edc <pvPortMalloc>

		if( pxBuffer == NULL )
 8006bd0:	4605      	mov	r5, r0
 8006bd2:	b970      	cbnz	r0, 8006bf2 <lTCPAddRxdata+0x6a>
		{
			FreeRTOS_debug_printf( ( "prvTCPCreateStream: malloc failed\n" ) );
			pxSocket->u.xTCP.bits.bMallocError = pdTRUE;
 8006bd4:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 8006bd8:	f043 0308 	orr.w	r3, r3, #8
 8006bdc:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
			vTCPStateChange( pxSocket, eCLOSE_WAIT );
 8006be0:	4620      	mov	r0, r4
 8006be2:	2108      	movs	r1, #8
 8006be4:	f000 fd42 	bl	800766c <vTCPStateChange>
		if( uxOffset != 0 ) Just store data which has come out-of-order
		if( uxOffset == 0 ) Also advance rxHead */
		if( pxStream == NULL )
		{
			pxStream = prvTCPCreateStream( pxSocket, pdTRUE );
			if( pxStream == NULL )
 8006be8:	fab5 f585 	clz	r5, r5
 8006bec:	096d      	lsrs	r5, r5, #5
 8006bee:	426d      	negs	r5, r5
 8006bf0:	e03f      	b.n	8006c72 <lTCPAddRxdata+0xea>
			vTCPStateChange( pxSocket, eCLOSE_WAIT );
		}
		else
		{
			/* Clear the markers of the stream */
			( void ) memset( pxBuffer, 0, sizeof( *pxBuffer ) - sizeof( pxBuffer->ucArray ) );
 8006bf2:	2100      	movs	r1, #0
 8006bf4:	2214      	movs	r2, #20
 8006bf6:	f003 f9a1 	bl	8009f3c <memset>
			pxBuffer->LENGTH = ( size_t ) uxLength ;
 8006bfa:	f8c5 9010 	str.w	r9, [r5, #16]
			}

			if( xIsInputStream != 0 )
			{
				iptraceMEM_STATS_CREATE( tcpRX_STREAM_BUFFER, pxBuffer, uxSize );
				pxSocket->u.xTCP.rxStream = pxBuffer;
 8006bfe:	6765      	str	r5, [r4, #116]	; 0x74
					pcData = NULL;
				}
			}
			#endif /* ipconfigUSE_CALLBACKS */

			xResult = ( int32_t ) uxStreamBufferAdd( pxStream, uxOffset, pcData, ( size_t ) ulByteCount );
 8006c00:	4628      	mov	r0, r5
 8006c02:	4631      	mov	r1, r6
 8006c04:	4642      	mov	r2, r8
 8006c06:	463b      	mov	r3, r7
 8006c08:	f000 faca 	bl	80071a0 <uxStreamBufferAdd>
 8006c0c:	4605      	mov	r5, r0
						( UBaseType_t ) pxStream->uxFront ) );
				}
			}
			#endif /* ipconfigHAS_DEBUG_PRINTF */

			if( uxOffset == 0U )
 8006c0e:	bb86      	cbnz	r6, 8006c72 <lTCPAddRxdata+0xea>
					}
				} else
				#endif /* ipconfigUSE_CALLBACKS */
				{
					/* See if running out of space. */
					if( pxSocket->u.xTCP.bits.bLowWater == pdFALSE_UNSIGNED )
 8006c10:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8006c14:	f013 0f80 	tst.w	r3, #128	; 0x80
 8006c18:	d11e      	bne.n	8006c58 <lTCPAddRxdata+0xd0>
					{
						size_t uxFrontSpace = uxStreamBufferFrontSpace( pxSocket->u.xTCP.rxStream );
 8006c1a:	6f62      	ldr	r2, [r4, #116]	; 0x74
{
/* Distance between uxFront and uxTail
or the number of items which can still be added to uxFront,
before hitting on uxTail */

size_t uxFront = pxBuffer->uxFront;
 8006c1c:	68d1      	ldr	r1, [r2, #12]
size_t uxTail = pxBuffer->uxTail;
 8006c1e:	6813      	ldr	r3, [r2, #0]
static portINLINE size_t uxStreamBufferSpace( const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper )
{
/* Returns the space between uxLower and uxUpper, which equals to the distance minus 1 */
size_t uxCount;

	uxCount = pxBuffer->LENGTH + uxUpper - uxLower - 1U;
 8006c20:	6912      	ldr	r2, [r2, #16]
 8006c22:	4413      	add	r3, r2
 8006c24:	3b01      	subs	r3, #1
 8006c26:	1a5b      	subs	r3, r3, r1
	if( uxCount >= pxBuffer->LENGTH )
 8006c28:	429a      	cmp	r2, r3
	{
		uxCount -= pxBuffer->LENGTH;
 8006c2a:	bf98      	it	ls
 8006c2c:	1a9b      	subls	r3, r3, r2
						if( uxFrontSpace <= pxSocket->u.xTCP.uxLittleSpace  )
 8006c2e:	6e62      	ldr	r2, [r4, #100]	; 0x64
 8006c30:	429a      	cmp	r2, r3
 8006c32:	d311      	bcc.n	8006c58 <lTCPAddRxdata+0xd0>
						{
							pxSocket->u.xTCP.bits.bLowWater = pdTRUE;
 8006c34:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8006c38:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8006c3c:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
							pxSocket->u.xTCP.bits.bWinChange = pdTRUE;
 8006c40:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8006c44:	f043 0301 	orr.w	r3, r3, #1
 8006c48:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41

							/* bLowWater was reached, send the changed window size. */
							pxSocket->u.xTCP.usTimeout = 1U;
 8006c4c:	2301      	movs	r3, #1
 8006c4e:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
							( void ) xSendEventToIPTask( eTCPTimerEvent );
 8006c52:	2006      	movs	r0, #6
 8006c54:	f7fe faea 	bl	800522c <xSendEventToIPTask>
						}
					}

					/* New incoming data is available, wake up the user.   User's
					semaphores will be set just before the IP-task goes asleep. */
					pxSocket->xEventBits |= ( EventBits_t ) eSOCKET_RECEIVE;
 8006c58:	6823      	ldr	r3, [r4, #0]
 8006c5a:	f043 0201 	orr.w	r2, r3, #1
 8006c5e:	6022      	str	r2, [r4, #0]

					#if ipconfigSUPPORT_SELECT_FUNCTION == 1
					{
						if( ( pxSocket->xSelectBits & ( EventBits_t ) eSELECT_READ ) != 0U )
 8006c60:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8006c62:	f012 0f01 	tst.w	r2, #1
 8006c66:	d004      	beq.n	8006c72 <lTCPAddRxdata+0xea>
						{
							pxSocket->xEventBits |= ( ( ( EventBits_t ) eSELECT_READ ) << SOCKET_EVENT_BIT_COUNT );
 8006c68:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8006c6c:	f043 0301 	orr.w	r3, r3, #1
 8006c70:	6023      	str	r3, [r4, #0]
				}
			}
		}

		return xResult;
	}
 8006c72:	4628      	mov	r0, r5
 8006c74:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8006c78:	51eb851f 	.word	0x51eb851f

08006c7c <FreeRTOS_tx_space>:
	BaseType_t FreeRTOS_tx_space( ConstSocket_t xSocket )
	{
	const FreeRTOS_Socket_t *pxSocket = ( const FreeRTOS_Socket_t * ) xSocket;
	BaseType_t xReturn;

		if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 8006c7c:	f890 3027 	ldrb.w	r3, [r0, #39]	; 0x27
 8006c80:	2b06      	cmp	r3, #6
 8006c82:	d10d      	bne.n	8006ca0 <FreeRTOS_tx_space+0x24>
		{
			xReturn = -pdFREERTOS_ERRNO_EINVAL;
		}
		else
		{
			if( pxSocket->u.xTCP.txStream != NULL )
 8006c84:	6f82      	ldr	r2, [r0, #120]	; 0x78
 8006c86:	b14a      	cbz	r2, 8006c9c <FreeRTOS_tx_space+0x20>
static portINLINE size_t uxStreamBufferGetSpace( const StreamBuffer_t *pxBuffer );
static portINLINE size_t uxStreamBufferGetSpace( const StreamBuffer_t *pxBuffer )
{
/* Returns the number of items which can still be added to uxHead
before hitting on uxTail */
size_t uxHead = pxBuffer->uxHead;
 8006c88:	6890      	ldr	r0, [r2, #8]
size_t uxTail = pxBuffer->uxTail;
 8006c8a:	6813      	ldr	r3, [r2, #0]
static portINLINE size_t uxStreamBufferSpace( const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper )
{
/* Returns the space between uxLower and uxUpper, which equals to the distance minus 1 */
size_t uxCount;

	uxCount = pxBuffer->LENGTH + uxUpper - uxLower - 1U;
 8006c8c:	6912      	ldr	r2, [r2, #16]
 8006c8e:	4413      	add	r3, r2
 8006c90:	3b01      	subs	r3, #1
 8006c92:	1a18      	subs	r0, r3, r0
	if( uxCount >= pxBuffer->LENGTH )
 8006c94:	4282      	cmp	r2, r0
 8006c96:	d805      	bhi.n	8006ca4 <FreeRTOS_tx_space+0x28>
	{
		uxCount -= pxBuffer->LENGTH;
 8006c98:	1a80      	subs	r0, r0, r2
 8006c9a:	4770      	bx	lr
			{
				xReturn = ( BaseType_t ) uxStreamBufferGetSpace ( pxSocket->u.xTCP.txStream );
			}
			else
			{
				xReturn = ( BaseType_t ) pxSocket->u.xTCP.uxTxStreamSize;
 8006c9c:	6f00      	ldr	r0, [r0, #112]	; 0x70
 8006c9e:	4770      	bx	lr
	const FreeRTOS_Socket_t *pxSocket = ( const FreeRTOS_Socket_t * ) xSocket;
	BaseType_t xReturn;

		if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
		{
			xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8006ca0:	f06f 0015 	mvn.w	r0, #21
				xReturn = ( BaseType_t ) pxSocket->u.xTCP.uxTxStreamSize;
			}
		}

		return xReturn;
	}
 8006ca4:	4770      	bx	lr
 8006ca6:	bf00      	nop

08006ca8 <FreeRTOS_tx_size>:
	BaseType_t FreeRTOS_tx_size( ConstSocket_t xSocket )
	{
	const FreeRTOS_Socket_t *pxSocket = ( const FreeRTOS_Socket_t * ) xSocket;
	BaseType_t xReturn;

		if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 8006ca8:	f890 3027 	ldrb.w	r3, [r0, #39]	; 0x27
 8006cac:	2b06      	cmp	r3, #6
 8006cae:	d10a      	bne.n	8006cc6 <FreeRTOS_tx_size+0x1e>
		{
			xReturn = -pdFREERTOS_ERRNO_EINVAL;
		}
		else
		{
			if( pxSocket->u.xTCP.txStream != NULL )
 8006cb0:	6f83      	ldr	r3, [r0, #120]	; 0x78
 8006cb2:	b15b      	cbz	r3, 8006ccc <FreeRTOS_tx_size+0x24>
static portINLINE size_t uxStreamBufferGetSize( const StreamBuffer_t *pxBuffer );
static portINLINE size_t uxStreamBufferGetSize( const StreamBuffer_t *pxBuffer )
{
/* Returns the number of items which can be read from uxTail
before reaching uxHead */
size_t uxHead = pxBuffer->uxHead;
 8006cb4:	6898      	ldr	r0, [r3, #8]
size_t uxTail = pxBuffer->uxTail;
 8006cb6:	681a      	ldr	r2, [r3, #0]
static portINLINE size_t uxStreamBufferDistance( const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper )
{
/* Returns the distance between uxLower and uxUpper */
size_t uxCount;

	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
 8006cb8:	691b      	ldr	r3, [r3, #16]
 8006cba:	4418      	add	r0, r3
 8006cbc:	1a80      	subs	r0, r0, r2
	if ( uxCount >= pxBuffer->LENGTH )
 8006cbe:	4283      	cmp	r3, r0
 8006cc0:	d805      	bhi.n	8006cce <FreeRTOS_tx_size+0x26>
	{
		uxCount -= pxBuffer->LENGTH;
 8006cc2:	1ac0      	subs	r0, r0, r3
 8006cc4:	4770      	bx	lr
	const FreeRTOS_Socket_t *pxSocket = ( const FreeRTOS_Socket_t * ) xSocket;
	BaseType_t xReturn;

		if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
		{
			xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8006cc6:	f06f 0015 	mvn.w	r0, #21
 8006cca:	4770      	bx	lr
			{
				xReturn = ( BaseType_t ) uxStreamBufferGetSize ( pxSocket->u.xTCP.txStream );
			}
			else
			{
				xReturn = 0;
 8006ccc:	2000      	movs	r0, #0
			}
		}

		return xReturn;
	}
 8006cce:	4770      	bx	lr

08006cd0 <FreeRTOS_setsockopt>:
	/* The function prototype is designed to maintain the expected Berkeley
	sockets standard, but this implementation does not use all the parameters. */
	( void ) lLevel;
	( void ) uxOptionLength;
	
	if( ( pxSocket == NULL ) || ( pxSocket == FREERTOS_INVALID_SOCKET ) )
 8006cd0:	1e41      	subs	r1, r0, #1
 8006cd2:	f111 0f03 	cmn.w	r1, #3
 8006cd6:	f200 8122 	bhi.w	8006f1e <FreeRTOS_setsockopt+0x24e>
/*-----------------------------------------------------------*/

/* FreeRTOS_setsockopt calls itself, but in a very limited way,
only when FREERTOS_SO_WIN_PROPERTIES is being set. */
BaseType_t FreeRTOS_setsockopt( Socket_t xSocket, int32_t lLevel, int32_t lOptionName, const void *pvOptionValue, size_t uxOptionLength )
{
 8006cda:	b510      	push	{r4, lr}
 8006cdc:	4604      	mov	r4, r0
	{
		xReturn = -pdFREERTOS_ERRNO_EINVAL;
		return xReturn;
	}

	switch( lOptionName )
 8006cde:	2a12      	cmp	r2, #18
 8006ce0:	f200 8121 	bhi.w	8006f26 <FreeRTOS_setsockopt+0x256>
 8006ce4:	e8df f012 	tbh	[pc, r2, lsl #1]
 8006ce8:	00170013 	.word	0x00170013
 8006cec:	011f0030 	.word	0x011f0030
 8006cf0:	00540054 	.word	0x00540054
 8006cf4:	011f011f 	.word	0x011f011f
 8006cf8:	011f011f 	.word	0x011f011f
 8006cfc:	00a4011f 	.word	0x00a4011f
 8006d00:	007300ba 	.word	0x007300ba
 8006d04:	00fa00d0 	.word	0x00fa00d0
 8006d08:	011f011f 	.word	0x011f011f
 8006d0c:	0041      	.short	0x0041
	{
		case FREERTOS_SO_RCVTIMEO	:
			/* Receive time out. */
			pxSocket->xReceiveBlockTime = *( ( const TickType_t *) pvOptionValue );
 8006d0e:	681b      	ldr	r3, [r3, #0]
 8006d10:	61c3      	str	r3, [r0, #28]
			xReturn = 0;
 8006d12:	2300      	movs	r3, #0
			break;
 8006d14:	e144      	b.n	8006fa0 <FreeRTOS_setsockopt+0x2d0>

		case FREERTOS_SO_SNDTIMEO	:
			pxSocket->xSendBlockTime = *( ( const TickType_t *) pvOptionValue );
 8006d16:	681a      	ldr	r2, [r3, #0]
 8006d18:	6202      	str	r2, [r0, #32]
			if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_UDP )
 8006d1a:	f890 3027 	ldrb.w	r3, [r0, #39]	; 0x27
 8006d1e:	2b11      	cmp	r3, #17
 8006d20:	d107      	bne.n	8006d32 <FreeRTOS_setsockopt+0x62>
			{
				/* The send time out is capped for the reason stated in the
				comments where ipconfigUDP_MAX_SEND_BLOCK_TIME_TICKS is defined
				in FreeRTOSIPConfig.h (assuming an official configuration file
				is being used. */
				if( pxSocket->xSendBlockTime > ( ( TickType_t ) ipconfigUDP_MAX_SEND_BLOCK_TIME_TICKS ) )
 8006d22:	f241 3388 	movw	r3, #5000	; 0x1388
 8006d26:	429a      	cmp	r2, r3
 8006d28:	f240 8100 	bls.w	8006f2c <FreeRTOS_setsockopt+0x25c>
				{
					pxSocket->xSendBlockTime = ( ( TickType_t ) ipconfigUDP_MAX_SEND_BLOCK_TIME_TICKS );
 8006d2c:	6203      	str	r3, [r0, #32]
			{
				/* For TCP socket, it isn't necessary to limit the blocking time
				because	the FreeRTOS_send() function does not wait for a network
				buffer to become available. */
			}
			xReturn = 0;
 8006d2e:	2300      	movs	r3, #0
 8006d30:	e136      	b.n	8006fa0 <FreeRTOS_setsockopt+0x2d0>
				if( pxSocket->xSendBlockTime > ( ( TickType_t ) ipconfigUDP_MAX_SEND_BLOCK_TIME_TICKS ) )
				{
					pxSocket->xSendBlockTime = ( ( TickType_t ) ipconfigUDP_MAX_SEND_BLOCK_TIME_TICKS );
				}
			}
			else if( ( uint8_t ) FREERTOS_IPPROTO_RAW == pxSocket->ucProtocol )
 8006d32:	2bff      	cmp	r3, #255	; 0xff
 8006d34:	f040 80fc 	bne.w	8006f30 <FreeRTOS_setsockopt+0x260>
			{
				if( pxSocket->xSendBlockTime > ( ( TickType_t ) ipconfigRAW_MAX_SEND_BLOCK_TIME_TICKS ) )
 8006d38:	f241 3388 	movw	r3, #5000	; 0x1388
 8006d3c:	429a      	cmp	r2, r3
 8006d3e:	f240 80f9 	bls.w	8006f34 <FreeRTOS_setsockopt+0x264>
				{
					pxSocket->xSendBlockTime = ( ( TickType_t ) ipconfigRAW_MAX_SEND_BLOCK_TIME_TICKS );
 8006d42:	6203      	str	r3, [r0, #32]
			{
				/* For TCP socket, it isn't necessary to limit the blocking time
				because	the FreeRTOS_send() function does not wait for a network
				buffer to become available. */
			}
			xReturn = 0;
 8006d44:	2300      	movs	r3, #0
 8006d46:	e12b      	b.n	8006fa0 <FreeRTOS_setsockopt+0x2d0>

		case FREERTOS_SO_UDPCKSUM_OUT :/* Doing for all types of sockets */
			/* Turn calculating of the UDP checksum on/off for this socket. If pvOptionValue
			 * is anything else than NULL, the checksum generation will be turned on. */

			if( pvOptionValue == NULL )
 8006d48:	b93b      	cbnz	r3, 8006d5a <FreeRTOS_setsockopt+0x8a>
			{
				pxSocket->ucSocketOptions &= ~( ( uint8_t ) FREERTOS_SO_UDPCKSUM_OUT );
 8006d4a:	f890 3026 	ldrb.w	r3, [r0, #38]	; 0x26
 8006d4e:	f023 0302 	bic.w	r3, r3, #2
 8006d52:	f880 3026 	strb.w	r3, [r0, #38]	; 0x26
			}
			else
			{
				pxSocket->ucSocketOptions |= ( uint8_t ) FREERTOS_SO_UDPCKSUM_OUT;
			}
			xReturn = 0;
 8006d56:	2300      	movs	r3, #0
 8006d58:	e122      	b.n	8006fa0 <FreeRTOS_setsockopt+0x2d0>
			{
				pxSocket->ucSocketOptions &= ~( ( uint8_t ) FREERTOS_SO_UDPCKSUM_OUT );
			}
			else
			{
				pxSocket->ucSocketOptions |= ( uint8_t ) FREERTOS_SO_UDPCKSUM_OUT;
 8006d5a:	f890 3026 	ldrb.w	r3, [r0, #38]	; 0x26
 8006d5e:	f043 0302 	orr.w	r3, r3, #2
 8006d62:	f880 3026 	strb.w	r3, [r0, #38]	; 0x26
			}
			xReturn = 0;
 8006d66:	2300      	movs	r3, #0
 8006d68:	e11a      	b.n	8006fa0 <FreeRTOS_setsockopt+0x2d0>

			case FREERTOS_SO_SET_LOW_HIGH_WATER:
				{
				const LowHighWater_t *pxLowHighWater = ipPOINTER_CAST( const LowHighWater_t *, pvOptionValue );

					if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 8006d6a:	f890 2027 	ldrb.w	r2, [r0, #39]	; 0x27
 8006d6e:	2a06      	cmp	r2, #6
 8006d70:	f040 80e2 	bne.w	8006f38 <FreeRTOS_setsockopt+0x268>
					{
						/* It is not allowed to access 'pxSocket->u.xTCP'. */
						FreeRTOS_debug_printf( ( "FREERTOS_SO_SET_LOW_HIGH_WATER: wrong socket type\n" ) );
						break;	/* will return -pdFREERTOS_ERRNO_EINVAL */
					}
					if( ( pxLowHighWater->uxLittleSpace >= pxLowHighWater->uxEnoughSpace ) ||
 8006d74:	6819      	ldr	r1, [r3, #0]
 8006d76:	685a      	ldr	r2, [r3, #4]
 8006d78:	4291      	cmp	r1, r2
 8006d7a:	f080 80e0 	bcs.w	8006f3e <FreeRTOS_setsockopt+0x26e>
 8006d7e:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
 8006d80:	4282      	cmp	r2, r0
 8006d82:	f200 80df 	bhi.w	8006f44 <FreeRTOS_setsockopt+0x274>
						/* Impossible values. */
						FreeRTOS_debug_printf( ( "FREERTOS_SO_SET_LOW_HIGH_WATER: bad values\n" ) );
						break;	/* will return -pdFREERTOS_ERRNO_EINVAL */
					}
					/* Send a STOP when buffer space drops below 'uxLittleSpace' bytes. */
					pxSocket->u.xTCP.uxLittleSpace = pxLowHighWater->uxLittleSpace;
 8006d86:	6661      	str	r1, [r4, #100]	; 0x64
					/* Send a GO when buffer space grows above 'uxEnoughSpace' bytes. */
					pxSocket->u.xTCP.uxEnoughSpace = pxLowHighWater->uxEnoughSpace;
 8006d88:	685b      	ldr	r3, [r3, #4]
 8006d8a:	66a3      	str	r3, [r4, #104]	; 0x68
					xReturn = 0;
 8006d8c:	2300      	movs	r3, #0
				}
				break;
 8006d8e:	e107      	b.n	8006fa0 <FreeRTOS_setsockopt+0x2d0>
static BaseType_t prvSockopt_so_buffer( FreeRTOS_Socket_t *pxSocket, int32_t lOptionName, const void *pvOptionValue )
{
uint32_t ulNewValue;
BaseType_t xReturn;

	if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 8006d90:	f890 1027 	ldrb.w	r1, [r0, #39]	; 0x27
 8006d94:	2906      	cmp	r1, #6
 8006d96:	f040 80d8 	bne.w	8006f4a <FreeRTOS_setsockopt+0x27a>
	{
		FreeRTOS_debug_printf( ( "Set SO_%sBUF: wrong socket type\n",
			( lOptionName == FREERTOS_SO_SNDBUF ) ? "SND" : "RCV" ) );
		xReturn = -pdFREERTOS_ERRNO_EINVAL;
	}
	else if( ( ( lOptionName == FREERTOS_SO_SNDBUF ) && ( pxSocket->u.xTCP.txStream != NULL ) ) ||
 8006d9a:	2a04      	cmp	r2, #4
 8006d9c:	f040 80fb 	bne.w	8006f96 <FreeRTOS_setsockopt+0x2c6>
 8006da0:	6f82      	ldr	r2, [r0, #120]	; 0x78
 8006da2:	b12a      	cbz	r2, 8006db0 <FreeRTOS_setsockopt+0xe0>
 8006da4:	e0d4      	b.n	8006f50 <FreeRTOS_setsockopt+0x280>
			( ( lOptionName == FREERTOS_SO_RCVBUF ) && ( pxSocket->u.xTCP.rxStream != NULL ) ) )
 8006da6:	6f62      	ldr	r2, [r4, #116]	; 0x74
 8006da8:	2a00      	cmp	r2, #0
 8006daa:	f000 80f7 	beq.w	8006f9c <FreeRTOS_setsockopt+0x2cc>
 8006dae:	e0d2      	b.n	8006f56 <FreeRTOS_setsockopt+0x286>
		ulNewValue = *( ipPOINTER_CAST( const uint32_t *, pvOptionValue ) );

		if( lOptionName == FREERTOS_SO_SNDBUF )
		{
			/* Round up to nearest MSS size */
			ulNewValue = FreeRTOS_round_up( ulNewValue, ( uint32_t ) pxSocket->u.xTCP.usInitMSS );
 8006db0:	f8b0 204c 	ldrh.w	r2, [r0, #76]	; 0x4c
 8006db4:	1e51      	subs	r1, r2, #1
	static portINLINE uint32_t FreeRTOS_min_uint32 (uint32_t a, uint32_t b) { return ( a <= b ) ? a : b; }
	static portINLINE uint32_t FreeRTOS_round_up   (uint32_t a, uint32_t d) { return d * ( ( a + d - 1U ) / d ); }
 8006db6:	681b      	ldr	r3, [r3, #0]
 8006db8:	440b      	add	r3, r1
 8006dba:	fbb3 f3f2 	udiv	r3, r3, r2
 8006dbe:	fb02 f203 	mul.w	r2, r2, r3
			pxSocket->u.xTCP.uxTxStreamSize = ulNewValue;
 8006dc2:	6702      	str	r2, [r0, #112]	; 0x70
		}
		else
		{
			pxSocket->u.xTCP.uxRxStreamSize = ulNewValue;
		}
		xReturn = 0;
 8006dc4:	2300      	movs	r3, #0
 8006dc6:	e0eb      	b.n	8006fa0 <FreeRTOS_setsockopt+0x2d0>
			ulNewValue = FreeRTOS_round_up( ulNewValue, ( uint32_t ) pxSocket->u.xTCP.usInitMSS );
			pxSocket->u.xTCP.uxTxStreamSize = ulNewValue;
		}
		else
		{
			pxSocket->u.xTCP.uxRxStreamSize = ulNewValue;
 8006dc8:	66e3      	str	r3, [r4, #108]	; 0x6c
		}
		xReturn = 0;
 8006dca:	2300      	movs	r3, #0
 8006dcc:	e0e8      	b.n	8006fa0 <FreeRTOS_setsockopt+0x2d0>

			case FREERTOS_SO_WIN_PROPERTIES:	/* Set all buffer and window properties in one call, parameter is pointer to WinProperties_t */
				{
					const WinProperties_t* pxProps;

					if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 8006dce:	f890 2027 	ldrb.w	r2, [r0, #39]	; 0x27
 8006dd2:	2a06      	cmp	r2, #6
 8006dd4:	f040 80c2 	bne.w	8006f5c <FreeRTOS_setsockopt+0x28c>
					{
						FreeRTOS_debug_printf( ( "Set SO_WIN_PROP: wrong socket type\n" ) );
						break;	/* will return -pdFREERTOS_ERRNO_EINVAL */
					}

					if( ( pxSocket->u.xTCP.txStream != NULL ) || ( pxSocket->u.xTCP.rxStream != NULL ) )
 8006dd8:	6f82      	ldr	r2, [r0, #120]	; 0x78
 8006dda:	2a00      	cmp	r2, #0
 8006ddc:	f040 80c1 	bne.w	8006f62 <FreeRTOS_setsockopt+0x292>
 8006de0:	6f42      	ldr	r2, [r0, #116]	; 0x74
 8006de2:	2a00      	cmp	r2, #0
 8006de4:	f040 80c0 	bne.w	8006f68 <FreeRTOS_setsockopt+0x298>
		ulNewValue = *( ipPOINTER_CAST( const uint32_t *, pvOptionValue ) );

		if( lOptionName == FREERTOS_SO_SNDBUF )
		{
			/* Round up to nearest MSS size */
			ulNewValue = FreeRTOS_round_up( ulNewValue, ( uint32_t ) pxSocket->u.xTCP.usInitMSS );
 8006de8:	f8b0 204c 	ldrh.w	r2, [r0, #76]	; 0x4c
 8006dec:	1e50      	subs	r0, r2, #1
 8006dee:	6819      	ldr	r1, [r3, #0]
 8006df0:	4401      	add	r1, r0
 8006df2:	fbb1 f1f2 	udiv	r1, r1, r2
 8006df6:	fb02 f201 	mul.w	r2, r2, r1
			pxSocket->u.xTCP.uxTxStreamSize = ulNewValue;
 8006dfa:	6722      	str	r2, [r4, #112]	; 0x70
			( lOptionName == FREERTOS_SO_SNDBUF ) ? "SND" : "RCV" ) );
		xReturn = -pdFREERTOS_ERRNO_EINVAL;
	}
	else
	{
		ulNewValue = *( ipPOINTER_CAST( const uint32_t *, pvOptionValue ) );
 8006dfc:	689a      	ldr	r2, [r3, #8]
			ulNewValue = FreeRTOS_round_up( ulNewValue, ( uint32_t ) pxSocket->u.xTCP.usInitMSS );
			pxSocket->u.xTCP.uxTxStreamSize = ulNewValue;
		}
		else
		{
			pxSocket->u.xTCP.uxRxStreamSize = ulNewValue;
 8006dfe:	66e2      	str	r2, [r4, #108]	; 0x6c
						break;	/* will return an error. */
					}

					#if( ipconfigUSE_TCP_WIN == 1 )
					{
						pxSocket->u.xTCP.uxRxWinSize = ( uint32_t )pxProps->lRxWinSize;	/* Fixed value: size of the TCP reception window */
 8006e00:	68da      	ldr	r2, [r3, #12]
 8006e02:	f8c4 20d0 	str.w	r2, [r4, #208]	; 0xd0
						pxSocket->u.xTCP.uxTxWinSize = ( uint32_t )pxProps->lTxWinSize;	/* Fixed value: size of the TCP transmit window */
 8006e06:	685b      	ldr	r3, [r3, #4]
 8006e08:	f8c4 30d4 	str.w	r3, [r4, #212]	; 0xd4
					}
					#endif

					/* In case the socket has already initialised its tcpWin,
					adapt the window size parameters */
					if( pxSocket->u.xTCP.xTCPWindow.u.bits.bHasInit != pdFALSE_UNSIGNED )
 8006e0c:	f894 10d8 	ldrb.w	r1, [r4, #216]	; 0xd8
 8006e10:	f011 0f01 	tst.w	r1, #1
 8006e14:	f000 80ab 	beq.w	8006f6e <FreeRTOS_setsockopt+0x29e>
					{
						pxSocket->u.xTCP.xTCPWindow.xSize.ulRxWindowLength = pxSocket->u.xTCP.uxRxWinSize * pxSocket->u.xTCP.usInitMSS;
 8006e18:	f8b4 104c 	ldrh.w	r1, [r4, #76]	; 0x4c
 8006e1c:	fb02 f201 	mul.w	r2, r2, r1
 8006e20:	f8c4 20dc 	str.w	r2, [r4, #220]	; 0xdc
						pxSocket->u.xTCP.xTCPWindow.xSize.ulTxWindowLength = pxSocket->u.xTCP.uxTxWinSize * pxSocket->u.xTCP.usInitMSS;
 8006e24:	fb03 f301 	mul.w	r3, r3, r1
 8006e28:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
					}
				}

				xReturn = 0;
 8006e2c:	2300      	movs	r3, #0
 8006e2e:	e0b7      	b.n	8006fa0 <FreeRTOS_setsockopt+0x2d0>
				break;

			case FREERTOS_SO_REUSE_LISTEN_SOCKET:	/* If true, the server-socket will turn into a connected socket */
				{
					if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 8006e30:	f890 2027 	ldrb.w	r2, [r0, #39]	; 0x27
 8006e34:	2a06      	cmp	r2, #6
 8006e36:	f040 809c 	bne.w	8006f72 <FreeRTOS_setsockopt+0x2a2>
					{
						break;	/* will return -pdFREERTOS_ERRNO_EINVAL */
					}
					if( *( ( const BaseType_t * ) pvOptionValue ) != 0 )
 8006e3a:	681b      	ldr	r3, [r3, #0]
 8006e3c:	b13b      	cbz	r3, 8006e4e <FreeRTOS_setsockopt+0x17e>
					{
						pxSocket->u.xTCP.bits.bReuseSocket = pdTRUE;
 8006e3e:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 8006e42:	f043 0308 	orr.w	r3, r3, #8
 8006e46:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
					else
					{
						pxSocket->u.xTCP.bits.bReuseSocket = pdFALSE;
					}
				}
				xReturn = 0;
 8006e4a:	2300      	movs	r3, #0
 8006e4c:	e0a8      	b.n	8006fa0 <FreeRTOS_setsockopt+0x2d0>
					{
						pxSocket->u.xTCP.bits.bReuseSocket = pdTRUE;
					}
					else
					{
						pxSocket->u.xTCP.bits.bReuseSocket = pdFALSE;
 8006e4e:	f890 2040 	ldrb.w	r2, [r0, #64]	; 0x40
 8006e52:	f36f 02c3 	bfc	r2, #3, #1
 8006e56:	f880 2040 	strb.w	r2, [r0, #64]	; 0x40
 8006e5a:	e0a1      	b.n	8006fa0 <FreeRTOS_setsockopt+0x2d0>
				xReturn = 0;
				break;

			case FREERTOS_SO_CLOSE_AFTER_SEND:		/* As soon as the last byte has been transmitted, finalise the connection */
				{
					if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 8006e5c:	f890 2027 	ldrb.w	r2, [r0, #39]	; 0x27
 8006e60:	2a06      	cmp	r2, #6
 8006e62:	f040 8089 	bne.w	8006f78 <FreeRTOS_setsockopt+0x2a8>
					{
						break;	/* will return -pdFREERTOS_ERRNO_EINVAL */
					}

					if( *( ( const BaseType_t * ) pvOptionValue ) != 0 )
 8006e66:	681b      	ldr	r3, [r3, #0]
 8006e68:	b13b      	cbz	r3, 8006e7a <FreeRTOS_setsockopt+0x1aa>
					{
						pxSocket->u.xTCP.bits.bCloseAfterSend = pdTRUE;
 8006e6a:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 8006e6e:	f043 0310 	orr.w	r3, r3, #16
 8006e72:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
					else
					{
						pxSocket->u.xTCP.bits.bCloseAfterSend = pdFALSE;
					}
				}
				xReturn = 0;
 8006e76:	2300      	movs	r3, #0
 8006e78:	e092      	b.n	8006fa0 <FreeRTOS_setsockopt+0x2d0>
					{
						pxSocket->u.xTCP.bits.bCloseAfterSend = pdTRUE;
					}
					else
					{
						pxSocket->u.xTCP.bits.bCloseAfterSend = pdFALSE;
 8006e7a:	f890 2040 	ldrb.w	r2, [r0, #64]	; 0x40
 8006e7e:	f36f 1204 	bfc	r2, #4, #1
 8006e82:	f880 2040 	strb.w	r2, [r0, #64]	; 0x40
 8006e86:	e08b      	b.n	8006fa0 <FreeRTOS_setsockopt+0x2d0>
				xReturn = 0;
				break;

			case FREERTOS_SO_SET_FULL_SIZE:		/* Refuse to send packets smaller than MSS  */
				{
					if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 8006e88:	f890 2027 	ldrb.w	r2, [r0, #39]	; 0x27
 8006e8c:	2a06      	cmp	r2, #6
 8006e8e:	d176      	bne.n	8006f7e <FreeRTOS_setsockopt+0x2ae>
					{
						break;	/* will return -pdFREERTOS_ERRNO_EINVAL */
					}

					if( *( ( const BaseType_t *) pvOptionValue ) != 0 )
 8006e90:	681b      	ldr	r3, [r3, #0]
 8006e92:	b133      	cbz	r3, 8006ea2 <FreeRTOS_setsockopt+0x1d2>
					{
						pxSocket->u.xTCP.xTCPWindow.u.bits.bSendFullSize = pdTRUE;
 8006e94:	f890 30d8 	ldrb.w	r3, [r0, #216]	; 0xd8
 8006e98:	f043 0302 	orr.w	r3, r3, #2
 8006e9c:	f880 30d8 	strb.w	r3, [r0, #216]	; 0xd8
 8006ea0:	e005      	b.n	8006eae <FreeRTOS_setsockopt+0x1de>
					}
					else
					{
						pxSocket->u.xTCP.xTCPWindow.u.bits.bSendFullSize = pdFALSE;
 8006ea2:	f890 30d8 	ldrb.w	r3, [r0, #216]	; 0xd8
 8006ea6:	f36f 0341 	bfc	r3, #1, #1
 8006eaa:	f880 30d8 	strb.w	r3, [r0, #216]	; 0xd8
					}

					if( ( pxSocket->u.xTCP.xTCPWindow.u.bits.bSendFullSize == pdFALSE_UNSIGNED ) &&
 8006eae:	f894 30d8 	ldrb.w	r3, [r4, #216]	; 0xd8
 8006eb2:	f013 0f02 	tst.w	r3, #2
 8006eb6:	d165      	bne.n	8006f84 <FreeRTOS_setsockopt+0x2b4>
 8006eb8:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 8006ebc:	2b04      	cmp	r3, #4
 8006ebe:	d963      	bls.n	8006f88 <FreeRTOS_setsockopt+0x2b8>
						( pxSocket->u.xTCP.ucTCPState >= ( uint8_t ) eESTABLISHED ) &&
						( FreeRTOS_outstanding( pxSocket ) != 0 ) )
 8006ec0:	4620      	mov	r0, r4
 8006ec2:	f7ff fef1 	bl	8006ca8 <FreeRTOS_tx_size>
					{
						pxSocket->u.xTCP.xTCPWindow.u.bits.bSendFullSize = pdFALSE;
					}

					if( ( pxSocket->u.xTCP.xTCPWindow.u.bits.bSendFullSize == pdFALSE_UNSIGNED ) &&
						( pxSocket->u.xTCP.ucTCPState >= ( uint8_t ) eESTABLISHED ) &&
 8006ec6:	4603      	mov	r3, r0
 8006ec8:	2800      	cmp	r0, #0
 8006eca:	d069      	beq.n	8006fa0 <FreeRTOS_setsockopt+0x2d0>
						( FreeRTOS_outstanding( pxSocket ) != 0 ) )
					{
						pxSocket->u.xTCP.usTimeout = 1U; /* to set/clear bSendFullSize */
 8006ecc:	2301      	movs	r3, #1
 8006ece:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
						( void ) xSendEventToIPTask( eTCPTimerEvent );
 8006ed2:	2006      	movs	r0, #6
 8006ed4:	f7fe f9aa 	bl	800522c <xSendEventToIPTask>
					}
				}
				xReturn = 0;
 8006ed8:	2300      	movs	r3, #0
 8006eda:	e061      	b.n	8006fa0 <FreeRTOS_setsockopt+0x2d0>
				break;

			case FREERTOS_SO_STOP_RX:		/* Refuse to receive more packts */
				{
					if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 8006edc:	f890 2027 	ldrb.w	r2, [r0, #39]	; 0x27
 8006ee0:	2a06      	cmp	r2, #6
 8006ee2:	d153      	bne.n	8006f8c <FreeRTOS_setsockopt+0x2bc>
					{
						break;	/* will return -pdFREERTOS_ERRNO_EINVAL */
					}
					if( *( ( const BaseType_t * ) pvOptionValue ) != 0 )
 8006ee4:	681b      	ldr	r3, [r3, #0]
 8006ee6:	b133      	cbz	r3, 8006ef6 <FreeRTOS_setsockopt+0x226>
					{
						pxSocket->u.xTCP.bits.bRxStopped = pdTRUE;
 8006ee8:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
 8006eec:	f043 0304 	orr.w	r3, r3, #4
 8006ef0:	f880 3042 	strb.w	r3, [r0, #66]	; 0x42
 8006ef4:	e005      	b.n	8006f02 <FreeRTOS_setsockopt+0x232>
					}
					else
					{
						pxSocket->u.xTCP.bits.bRxStopped = pdFALSE;
 8006ef6:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
 8006efa:	f36f 0382 	bfc	r3, #2, #1
 8006efe:	f880 3042 	strb.w	r3, [r0, #66]	; 0x42
					}

					pxSocket->u.xTCP.bits.bWinChange = pdTRUE;
 8006f02:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8006f06:	f043 0301 	orr.w	r3, r3, #1
 8006f0a:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
					pxSocket->u.xTCP.usTimeout = 1U; /* to set/clear bRxStopped */
 8006f0e:	2301      	movs	r3, #1
 8006f10:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
					( void ) xSendEventToIPTask( eTCPTimerEvent );
 8006f14:	2006      	movs	r0, #6
 8006f16:	f7fe f989 	bl	800522c <xSendEventToIPTask>
				}
				xReturn = 0;
 8006f1a:	2300      	movs	r3, #0
				break;
 8006f1c:	e040      	b.n	8006fa0 <FreeRTOS_setsockopt+0x2d0>
	( void ) uxOptionLength;
	
	if( ( pxSocket == NULL ) || ( pxSocket == FREERTOS_INVALID_SOCKET ) )
	{
		xReturn = -pdFREERTOS_ERRNO_EINVAL;
		return xReturn;
 8006f1e:	f06f 0315 	mvn.w	r3, #21
			xReturn = -pdFREERTOS_ERRNO_ENOPROTOOPT;
			break;
	}

	return xReturn;
} /* Tested */
 8006f22:	4618      	mov	r0, r3
 8006f24:	4770      	bx	lr

		#endif  /* ipconfigUSE_TCP == 1 */

		default :
			/* No other options are handled. */
			xReturn = -pdFREERTOS_ERRNO_ENOPROTOOPT;
 8006f26:	f06f 036c 	mvn.w	r3, #108	; 0x6c
 8006f2a:	e039      	b.n	8006fa0 <FreeRTOS_setsockopt+0x2d0>
			{
				/* For TCP socket, it isn't necessary to limit the blocking time
				because	the FreeRTOS_send() function does not wait for a network
				buffer to become available. */
			}
			xReturn = 0;
 8006f2c:	2300      	movs	r3, #0
 8006f2e:	e037      	b.n	8006fa0 <FreeRTOS_setsockopt+0x2d0>
 8006f30:	2300      	movs	r3, #0
 8006f32:	e035      	b.n	8006fa0 <FreeRTOS_setsockopt+0x2d0>
 8006f34:	2300      	movs	r3, #0
 8006f36:	e033      	b.n	8006fa0 <FreeRTOS_setsockopt+0x2d0>
/* FreeRTOS_setsockopt calls itself, but in a very limited way,
only when FREERTOS_SO_WIN_PROPERTIES is being set. */
BaseType_t FreeRTOS_setsockopt( Socket_t xSocket, int32_t lLevel, int32_t lOptionName, const void *pvOptionValue, size_t uxOptionLength )
{
/* The standard Berkeley function returns 0 for success. */
BaseType_t xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8006f38:	f06f 0315 	mvn.w	r3, #21
 8006f3c:	e030      	b.n	8006fa0 <FreeRTOS_setsockopt+0x2d0>
 8006f3e:	f06f 0315 	mvn.w	r3, #21
 8006f42:	e02d      	b.n	8006fa0 <FreeRTOS_setsockopt+0x2d0>
 8006f44:	f06f 0315 	mvn.w	r3, #21
 8006f48:	e02a      	b.n	8006fa0 <FreeRTOS_setsockopt+0x2d0>

	if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
	{
		FreeRTOS_debug_printf( ( "Set SO_%sBUF: wrong socket type\n",
			( lOptionName == FREERTOS_SO_SNDBUF ) ? "SND" : "RCV" ) );
		xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8006f4a:	f06f 0315 	mvn.w	r3, #21
 8006f4e:	e027      	b.n	8006fa0 <FreeRTOS_setsockopt+0x2d0>
	else if( ( ( lOptionName == FREERTOS_SO_SNDBUF ) && ( pxSocket->u.xTCP.txStream != NULL ) ) ||
			( ( lOptionName == FREERTOS_SO_RCVBUF ) && ( pxSocket->u.xTCP.rxStream != NULL ) ) )
	{
		FreeRTOS_debug_printf( ( "Set SO_%sBUF: buffer already created\n",
			( lOptionName == FREERTOS_SO_SNDBUF ) ? "SND" : "RCV" ) );
		xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8006f50:	f06f 0315 	mvn.w	r3, #21
 8006f54:	e024      	b.n	8006fa0 <FreeRTOS_setsockopt+0x2d0>
 8006f56:	f06f 0315 	mvn.w	r3, #21
 8006f5a:	e021      	b.n	8006fa0 <FreeRTOS_setsockopt+0x2d0>
/* FreeRTOS_setsockopt calls itself, but in a very limited way,
only when FREERTOS_SO_WIN_PROPERTIES is being set. */
BaseType_t FreeRTOS_setsockopt( Socket_t xSocket, int32_t lLevel, int32_t lOptionName, const void *pvOptionValue, size_t uxOptionLength )
{
/* The standard Berkeley function returns 0 for success. */
BaseType_t xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8006f5c:	f06f 0315 	mvn.w	r3, #21
 8006f60:	e01e      	b.n	8006fa0 <FreeRTOS_setsockopt+0x2d0>
 8006f62:	f06f 0315 	mvn.w	r3, #21
 8006f66:	e01b      	b.n	8006fa0 <FreeRTOS_setsockopt+0x2d0>
 8006f68:	f06f 0315 	mvn.w	r3, #21
 8006f6c:	e018      	b.n	8006fa0 <FreeRTOS_setsockopt+0x2d0>
						pxSocket->u.xTCP.xTCPWindow.xSize.ulRxWindowLength = pxSocket->u.xTCP.uxRxWinSize * pxSocket->u.xTCP.usInitMSS;
						pxSocket->u.xTCP.xTCPWindow.xSize.ulTxWindowLength = pxSocket->u.xTCP.uxTxWinSize * pxSocket->u.xTCP.usInitMSS;
					}
				}

				xReturn = 0;
 8006f6e:	2300      	movs	r3, #0
 8006f70:	e016      	b.n	8006fa0 <FreeRTOS_setsockopt+0x2d0>
/* FreeRTOS_setsockopt calls itself, but in a very limited way,
only when FREERTOS_SO_WIN_PROPERTIES is being set. */
BaseType_t FreeRTOS_setsockopt( Socket_t xSocket, int32_t lLevel, int32_t lOptionName, const void *pvOptionValue, size_t uxOptionLength )
{
/* The standard Berkeley function returns 0 for success. */
BaseType_t xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8006f72:	f06f 0315 	mvn.w	r3, #21
 8006f76:	e013      	b.n	8006fa0 <FreeRTOS_setsockopt+0x2d0>
 8006f78:	f06f 0315 	mvn.w	r3, #21
 8006f7c:	e010      	b.n	8006fa0 <FreeRTOS_setsockopt+0x2d0>
 8006f7e:	f06f 0315 	mvn.w	r3, #21
 8006f82:	e00d      	b.n	8006fa0 <FreeRTOS_setsockopt+0x2d0>
					{
						pxSocket->u.xTCP.usTimeout = 1U; /* to set/clear bSendFullSize */
						( void ) xSendEventToIPTask( eTCPTimerEvent );
					}
				}
				xReturn = 0;
 8006f84:	2300      	movs	r3, #0
 8006f86:	e00b      	b.n	8006fa0 <FreeRTOS_setsockopt+0x2d0>
 8006f88:	2300      	movs	r3, #0
 8006f8a:	e009      	b.n	8006fa0 <FreeRTOS_setsockopt+0x2d0>
/* FreeRTOS_setsockopt calls itself, but in a very limited way,
only when FREERTOS_SO_WIN_PROPERTIES is being set. */
BaseType_t FreeRTOS_setsockopt( Socket_t xSocket, int32_t lLevel, int32_t lOptionName, const void *pvOptionValue, size_t uxOptionLength )
{
/* The standard Berkeley function returns 0 for success. */
BaseType_t xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8006f8c:	f06f 0315 	mvn.w	r3, #21
 8006f90:	e006      	b.n	8006fa0 <FreeRTOS_setsockopt+0x2d0>
			( lOptionName == FREERTOS_SO_SNDBUF ) ? "SND" : "RCV" ) );
		xReturn = -pdFREERTOS_ERRNO_EINVAL;
	}
	else
	{
		ulNewValue = *( ipPOINTER_CAST( const uint32_t *, pvOptionValue ) );
 8006f92:	681b      	ldr	r3, [r3, #0]
 8006f94:	e718      	b.n	8006dc8 <FreeRTOS_setsockopt+0xf8>
	{
		FreeRTOS_debug_printf( ( "Set SO_%sBUF: wrong socket type\n",
			( lOptionName == FREERTOS_SO_SNDBUF ) ? "SND" : "RCV" ) );
		xReturn = -pdFREERTOS_ERRNO_EINVAL;
	}
	else if( ( ( lOptionName == FREERTOS_SO_SNDBUF ) && ( pxSocket->u.xTCP.txStream != NULL ) ) ||
 8006f96:	2a05      	cmp	r2, #5
 8006f98:	d1fb      	bne.n	8006f92 <FreeRTOS_setsockopt+0x2c2>
 8006f9a:	e704      	b.n	8006da6 <FreeRTOS_setsockopt+0xd6>
			( lOptionName == FREERTOS_SO_SNDBUF ) ? "SND" : "RCV" ) );
		xReturn = -pdFREERTOS_ERRNO_EINVAL;
	}
	else
	{
		ulNewValue = *( ipPOINTER_CAST( const uint32_t *, pvOptionValue ) );
 8006f9c:	681b      	ldr	r3, [r3, #0]
 8006f9e:	e713      	b.n	8006dc8 <FreeRTOS_setsockopt+0xf8>
			xReturn = -pdFREERTOS_ERRNO_ENOPROTOOPT;
			break;
	}

	return xReturn;
} /* Tested */
 8006fa0:	4618      	mov	r0, r3
 8006fa2:	bd10      	pop	{r4, pc}

08006fa4 <FreeRTOS_rx_size>:
	BaseType_t FreeRTOS_rx_size( ConstSocket_t xSocket )
	{
	const FreeRTOS_Socket_t *pxSocket = ( const FreeRTOS_Socket_t * ) xSocket;
	BaseType_t xReturn;

		if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 8006fa4:	f890 3027 	ldrb.w	r3, [r0, #39]	; 0x27
 8006fa8:	2b06      	cmp	r3, #6
 8006faa:	d10a      	bne.n	8006fc2 <FreeRTOS_rx_size+0x1e>
		{
			xReturn = -pdFREERTOS_ERRNO_EINVAL;
		}
		else if( pxSocket->u.xTCP.rxStream != NULL )
 8006fac:	6f43      	ldr	r3, [r0, #116]	; 0x74
 8006fae:	b15b      	cbz	r3, 8006fc8 <FreeRTOS_rx_size+0x24>
static portINLINE size_t uxStreamBufferGetSize( const StreamBuffer_t *pxBuffer );
static portINLINE size_t uxStreamBufferGetSize( const StreamBuffer_t *pxBuffer )
{
/* Returns the number of items which can be read from uxTail
before reaching uxHead */
size_t uxHead = pxBuffer->uxHead;
 8006fb0:	6898      	ldr	r0, [r3, #8]
size_t uxTail = pxBuffer->uxTail;
 8006fb2:	681a      	ldr	r2, [r3, #0]
static portINLINE size_t uxStreamBufferDistance( const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper )
{
/* Returns the distance between uxLower and uxUpper */
size_t uxCount;

	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
 8006fb4:	691b      	ldr	r3, [r3, #16]
 8006fb6:	4418      	add	r0, r3
 8006fb8:	1a80      	subs	r0, r0, r2
	if ( uxCount >= pxBuffer->LENGTH )
 8006fba:	4283      	cmp	r3, r0
 8006fbc:	d805      	bhi.n	8006fca <FreeRTOS_rx_size+0x26>
	{
		uxCount -= pxBuffer->LENGTH;
 8006fbe:	1ac0      	subs	r0, r0, r3
 8006fc0:	4770      	bx	lr
	const FreeRTOS_Socket_t *pxSocket = ( const FreeRTOS_Socket_t * ) xSocket;
	BaseType_t xReturn;

		if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
		{
			xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8006fc2:	f06f 0015 	mvn.w	r0, #21
 8006fc6:	4770      	bx	lr
		{
			xReturn = ( BaseType_t ) uxStreamBufferGetSize( pxSocket->u.xTCP.rxStream );
		}
		else
		{
			xReturn = 0;
 8006fc8:	2000      	movs	r0, #0
		}

		return xReturn;
	}
 8006fca:	4770      	bx	lr

08006fcc <vSocketSelect>:
/*-----------------------------------------------------------*/

#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )

	void vSocketSelect( SocketSelect_t *pxSocketSet )
	{
 8006fcc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006fd0:	b085      	sub	sp, #20
 8006fd2:	4606      	mov	r6, r0
 8006fd4:	f04f 0b01 	mov.w	fp, #1
 8006fd8:	f04f 0900 	mov.w	r9, #0
	#else
		BaseType_t xLastRound = 1;
	#endif

		/* These flags will be switched on after checking the socket status. */
		EventBits_t xGroupBits = 0;
 8006fdc:	46ca      	mov	sl, r9
			else
			{
				pxEnd = listGET_END_MARKER( &xBoundTCPSocketsList );
			}
		#endif /* ipconfigUSE_TCP == 1 */
			for( pxIterator = listGET_NEXT( pxEnd );
 8006fde:	4b5f      	ldr	r3, [pc, #380]	; (800715c <vSocketSelect+0x190>)
 8006fe0:	3308      	adds	r3, #8
 8006fe2:	9303      	str	r3, [sp, #12]
 8006fe4:	4b5e      	ldr	r3, [pc, #376]	; (8007160 <vSocketSelect+0x194>)
 8006fe6:	3308      	adds	r3, #8
 8006fe8:	9301      	str	r3, [sp, #4]
 8006fea:	e003      	b.n	8006ff4 <vSocketSelect+0x28>
 8006fec:	f109 0901 	add.w	r9, r9, #1
 8006ff0:	f10b 0b01 	add.w	fp, fp, #1

		for( xRound = 0; xRound <= xLastRound; xRound++ )
		{
			const ListItem_t *pxIterator;
			const ListItem_t *pxEnd;
			if( xRound == 0 )
 8006ff4:	f1b9 0f00 	cmp.w	r9, #0
 8006ff8:	f000 809f 	beq.w	800713a <vSocketSelect+0x16e>
			{
				pxEnd = listGET_END_MARKER( &xBoundUDPSocketsList );
			}
			else if( 1 == xRound )
 8006ffc:	f1b9 0f01 	cmp.w	r9, #1
 8007000:	f000 8094 	beq.w	800712c <vSocketSelect+0x160>
			else
			{
				pxEnd = listGET_END_MARKER( &xBoundTCPSocketsList );
			}
		#endif /* ipconfigUSE_TCP == 1 */
			for( pxIterator = listGET_NEXT( pxEnd );
 8007004:	4b56      	ldr	r3, [pc, #344]	; (8007160 <vSocketSelect+0x194>)
 8007006:	68dc      	ldr	r4, [r3, #12]
 8007008:	9b01      	ldr	r3, [sp, #4]
 800700a:	429c      	cmp	r4, r3
 800700c:	d078      	beq.n	8007100 <vSocketSelect+0x134>
				pxEnd = listGET_END_MARKER( &xBoundRAWSocketsList );
			}
		#if ipconfigUSE_TCP == 1
			else
			{
				pxEnd = listGET_END_MARKER( &xBoundTCPSocketsList );
 800700e:	4f55      	ldr	r7, [pc, #340]	; (8007164 <vSocketSelect+0x198>)
 8007010:	e004      	b.n	800701c <vSocketSelect+0x50>
			{
				pxEnd = listGET_END_MARKER( &xBoundUDPSocketsList );
			}
			else if( 1 == xRound )
			{
				pxEnd = listGET_END_MARKER( &xBoundRAWSocketsList );
 8007012:	4b55      	ldr	r3, [pc, #340]	; (8007168 <vSocketSelect+0x19c>)
 8007014:	f103 0708 	add.w	r7, r3, #8
 8007018:	e000      	b.n	800701c <vSocketSelect+0x50>
		{
			const ListItem_t *pxIterator;
			const ListItem_t *pxEnd;
			if( xRound == 0 )
			{
				pxEnd = listGET_END_MARKER( &xBoundUDPSocketsList );
 800701a:	9f03      	ldr	r7, [sp, #12]
		#endif /* ipconfigUSE_TCP == 1 */
			for( pxIterator = listGET_NEXT( pxEnd );
				 pxIterator != pxEnd;
				 pxIterator = listGET_NEXT( pxIterator ) )
			{
				FreeRTOS_Socket_t *pxSocket =  ipCAST_PTR_TO_TYPE_PTR( FreeRTOS_Socket_t, listGET_LIST_ITEM_OWNER( pxIterator ) );
 800701c:	68e5      	ldr	r5, [r4, #12]
				if( pxSocket->pxSocketSet != pxSocketSet )
 800701e:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8007020:	42b3      	cmp	r3, r6
 8007022:	d16a      	bne.n	80070fa <vSocketSelect+0x12e>
					continue;
				}
				xSocketBits = 0;

			#if( ipconfigUSE_TCP == 1 )
				if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_TCP )
 8007024:	f895 3027 	ldrb.w	r3, [r5, #39]	; 0x27
 8007028:	2b06      	cmp	r3, #6
 800702a:	d155      	bne.n	80070d8 <vSocketSelect+0x10c>
					/* Check if the socket has already been accepted by the
					owner.  If not, it is useless to return it from a
					select(). */
					BaseType_t bAccepted = pdFALSE;

					if( pxSocket->u.xTCP.bits.bPassQueued == pdFALSE_UNSIGNED )
 800702c:	f895 2040 	ldrb.w	r2, [r5, #64]	; 0x40
					{
						if( pxSocket->u.xTCP.bits.bPassAccept == pdFALSE_UNSIGNED )
 8007030:	f012 0f06 	tst.w	r2, #6
 8007034:	bf0c      	ite	eq
 8007036:	2301      	moveq	r3, #1
 8007038:	2300      	movne	r3, #0
 800703a:	9302      	str	r3, [sp, #8]
							bAccepted = pdTRUE;
						}
					}

					/* Is the set owner interested in READ events? */
					if( ( pxSocket->xSelectBits & ( EventBits_t ) eSELECT_READ ) != ( EventBits_t ) 0U )
 800703c:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800703e:	f013 0f01 	tst.w	r3, #1
 8007042:	d01b      	beq.n	800707c <vSocketSelect+0xb0>
					{
						if( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eTCP_LISTEN )
 8007044:	f895 1053 	ldrb.w	r1, [r5, #83]	; 0x53
 8007048:	2901      	cmp	r1, #1
 800704a:	d107      	bne.n	800705c <vSocketSelect+0x90>
						{
							if( ( pxSocket->u.xTCP.pxPeerSocket != NULL ) && ( pxSocket->u.xTCP.pxPeerSocket->u.xTCP.bits.bPassAccept != pdFALSE_UNSIGNED ) )
 800704c:	6d6a      	ldr	r2, [r5, #84]	; 0x54
 800704e:	2a00      	cmp	r2, #0
 8007050:	d07a      	beq.n	8007148 <vSocketSelect+0x17c>
 8007052:	f892 8040 	ldrb.w	r8, [r2, #64]	; 0x40
 8007056:	f3c8 0840 	ubfx	r8, r8, #1, #1
 800705a:	e022      	b.n	80070a2 <vSocketSelect+0xd6>
							{
								xSocketBits |= ( EventBits_t ) eSELECT_READ;
							}
						}
						else if( ( pxSocket->u.xTCP.bits.bReuseSocket != pdFALSE_UNSIGNED ) && ( pxSocket->u.xTCP.bits.bPassAccept != pdFALSE_UNSIGNED ) )
 800705c:	f002 020a 	and.w	r2, r2, #10
 8007060:	2a0a      	cmp	r2, #10
 8007062:	d00e      	beq.n	8007082 <vSocketSelect+0xb6>
						{
							/* This socket has the re-use flag. After connecting it turns into
							aconnected socket. Set the READ event, so that accept() will be called. */
							xSocketBits |= ( EventBits_t ) eSELECT_READ;
						}
						else if( ( bAccepted != 0 ) && ( FreeRTOS_recvcount( pxSocket ) > 0 ) )
 8007064:	9b02      	ldr	r3, [sp, #8]
 8007066:	b17b      	cbz	r3, 8007088 <vSocketSelect+0xbc>
 8007068:	4628      	mov	r0, r5
 800706a:	f7ff ff9b 	bl	8006fa4 <FreeRTOS_rx_size>
 800706e:	2800      	cmp	r0, #0
 8007070:	bfd4      	ite	le
 8007072:	f04f 0800 	movle.w	r8, #0
 8007076:	f04f 0801 	movgt.w	r8, #1
 800707a:	e007      	b.n	800708c <vSocketSelect+0xc0>
				if( pxSocket->pxSocketSet != pxSocketSet )
				{
					/* Socket does not belong to this select group. */
					continue;
				}
				xSocketBits = 0;
 800707c:	f04f 0800 	mov.w	r8, #0
 8007080:	e004      	b.n	800708c <vSocketSelect+0xc0>
						}
						else if( ( pxSocket->u.xTCP.bits.bReuseSocket != pdFALSE_UNSIGNED ) && ( pxSocket->u.xTCP.bits.bPassAccept != pdFALSE_UNSIGNED ) )
						{
							/* This socket has the re-use flag. After connecting it turns into
							aconnected socket. Set the READ event, so that accept() will be called. */
							xSocketBits |= ( EventBits_t ) eSELECT_READ;
 8007082:	f04f 0801 	mov.w	r8, #1
 8007086:	e001      	b.n	800708c <vSocketSelect+0xc0>
				if( pxSocket->pxSocketSet != pxSocketSet )
				{
					/* Socket does not belong to this select group. */
					continue;
				}
				xSocketBits = 0;
 8007088:	f04f 0800 	mov.w	r8, #0
						{
							/* Nothing. */
						}
					}
					/* Is the set owner interested in EXCEPTION events? */
					if( ( pxSocket->xSelectBits & ( EventBits_t ) eSELECT_EXCEPT ) != 0U )
 800708c:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800708e:	f013 0f04 	tst.w	r3, #4
 8007092:	d006      	beq.n	80070a2 <vSocketSelect+0xd6>
					{
						if( ( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eCLOSE_WAIT ) || ( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eCLOSED ) )
 8007094:	f895 2053 	ldrb.w	r2, [r5, #83]	; 0x53
 8007098:	f012 0ff7 	tst.w	r2, #247	; 0xf7
						{
							xSocketBits |= ( EventBits_t ) eSELECT_EXCEPT;
 800709c:	bf08      	it	eq
 800709e:	f048 0804 	orreq.w	r8, r8, #4
						}
					}

					/* Is the set owner interested in WRITE events? */
					if( ( pxSocket->xSelectBits & ( EventBits_t ) eSELECT_WRITE ) != 0U )
 80070a2:	f013 0f02 	tst.w	r3, #2
 80070a6:	d024      	beq.n	80070f2 <vSocketSelect+0x126>
					{
						BaseType_t bMatch = pdFALSE;

						if( bAccepted != 0 )
 80070a8:	9b02      	ldr	r3, [sp, #8]
 80070aa:	b123      	cbz	r3, 80070b6 <vSocketSelect+0xea>
						{
							if( FreeRTOS_tx_space( pxSocket ) > 0 )
 80070ac:	4628      	mov	r0, r5
 80070ae:	f7ff fde5 	bl	8006c7c <FreeRTOS_tx_space>
							{
								bMatch = pdTRUE;
							}
						}

						if( bMatch == pdFALSE )
 80070b2:	2800      	cmp	r0, #0
 80070b4:	dc4b      	bgt.n	800714e <vSocketSelect+0x182>
						{
							if( ( pxSocket->u.xTCP.bits.bConnPrepared != pdFALSE_UNSIGNED ) &&
 80070b6:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
 80070ba:	f013 0f08 	tst.w	r3, #8
 80070be:	d018      	beq.n	80070f2 <vSocketSelect+0x126>
 80070c0:	f895 2053 	ldrb.w	r2, [r5, #83]	; 0x53
 80070c4:	2a04      	cmp	r2, #4
 80070c6:	d914      	bls.n	80070f2 <vSocketSelect+0x126>
								( pxSocket->u.xTCP.ucTCPState >= ( uint8_t ) eESTABLISHED ) &&
 80070c8:	f013 0f10 	tst.w	r3, #16
 80070cc:	d111      	bne.n	80070f2 <vSocketSelect+0x126>
								( pxSocket->u.xTCP.bits.bConnPassed == pdFALSE_UNSIGNED ) )
							{
								pxSocket->u.xTCP.bits.bConnPassed = pdTRUE;
 80070ce:	f043 0310 	orr.w	r3, r3, #16
 80070d2:	f885 3041 	strb.w	r3, [r5, #65]	; 0x41
 80070d6:	e03a      	b.n	800714e <vSocketSelect+0x182>
				}
				else
			#endif /* ipconfigUSE_TCP == 1 */
				{
					/* Select events for UDP are simpler. */
					if( ( ( pxSocket->xSelectBits & ( EventBits_t ) eSELECT_READ ) != 0U ) &&
 80070d8:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 80070da:	f013 0f01 	tst.w	r3, #1
 80070de:	d006      	beq.n	80070ee <vSocketSelect+0x122>
						( listCURRENT_LIST_LENGTH( &( pxSocket->u.xUDP.xWaitingPacketsList ) ) > 0U ) )
 80070e0:	6bab      	ldr	r3, [r5, #56]	; 0x38
				}
				else
			#endif /* ipconfigUSE_TCP == 1 */
				{
					/* Select events for UDP are simpler. */
					if( ( ( pxSocket->xSelectBits & ( EventBits_t ) eSELECT_READ ) != 0U ) &&
 80070e2:	f113 0800 	adds.w	r8, r3, #0
 80070e6:	bf18      	it	ne
 80070e8:	f04f 0801 	movne.w	r8, #1
 80070ec:	e001      	b.n	80070f2 <vSocketSelect+0x126>
				if( pxSocket->pxSocketSet != pxSocketSet )
				{
					/* Socket does not belong to this select group. */
					continue;
				}
				xSocketBits = 0;
 80070ee:	f04f 0800 	mov.w	r8, #0
					/* The WRITE and EXCEPT bits are not used for UDP */
				}	/* if( pxSocket->ucProtocol == FREERTOS_IPPROTO_TCP ) */

				/* Each socket keeps its own event flags, which are looked-up
				by FreeRTOS_FD_ISSSET() */
				pxSocket->xSocketBits = xSocketBits;
 80070f2:	f8c5 8034 	str.w	r8, [r5, #52]	; 0x34

				/* The ORed value will be used to set the bits in the event
				group. */
				xGroupBits |= xSocketBits;
 80070f6:	ea4a 0a08 	orr.w	sl, sl, r8
				pxEnd = listGET_END_MARKER( &xBoundTCPSocketsList );
			}
		#endif /* ipconfigUSE_TCP == 1 */
			for( pxIterator = listGET_NEXT( pxEnd );
				 pxIterator != pxEnd;
				 pxIterator = listGET_NEXT( pxIterator ) )
 80070fa:	6864      	ldr	r4, [r4, #4]
			else
			{
				pxEnd = listGET_END_MARKER( &xBoundTCPSocketsList );
			}
		#endif /* ipconfigUSE_TCP == 1 */
			for( pxIterator = listGET_NEXT( pxEnd );
 80070fc:	42a7      	cmp	r7, r4
 80070fe:	d18d      	bne.n	800701c <vSocketSelect+0x50>
	#endif

		/* These flags will be switched on after checking the socket status. */
		EventBits_t xGroupBits = 0;

		for( xRound = 0; xRound <= xLastRound; xRound++ )
 8007100:	f1bb 0f02 	cmp.w	fp, #2
 8007104:	f77f af72 	ble.w	8006fec <vSocketSelect+0x20>
				xGroupBits |= xSocketBits;

			}	/* for( pxIterator ... ) */
		}	/* for( xRound = 0; xRound <= xLastRound; xRound++ ) */

		xBitsToClear = xEventGroupGetBits( pxSocketSet->xSelectGroup );
 8007108:	6830      	ldr	r0, [r6, #0]
 800710a:	2100      	movs	r1, #0
 800710c:	f7fb f856 	bl	80021bc <xEventGroupClearBits>
 8007110:	f000 0007 	and.w	r0, r0, #7
			and cleared in FreeRTOS_select(). */
			xBitsToClear &= ~( ( EventBits_t ) eSELECT_INTR );
		}
		#endif /* ipconfigSUPPORT_SIGNALS */

		if( xBitsToClear != 0U )
 8007114:	ea30 010a 	bics.w	r1, r0, sl
 8007118:	d002      	beq.n	8007120 <vSocketSelect+0x154>
		{
			( void ) xEventGroupClearBits( pxSocketSet->xSelectGroup, xBitsToClear );
 800711a:	6830      	ldr	r0, [r6, #0]
 800711c:	f7fb f84e 	bl	80021bc <xEventGroupClearBits>
		}

		/* Now include eSELECT_CALL_IP to wakeup the caller. */
		( void ) xEventGroupSetBits( pxSocketSet->xSelectGroup, xGroupBits | ( EventBits_t ) eSELECT_CALL_IP );
 8007120:	6830      	ldr	r0, [r6, #0]
 8007122:	f04a 0110 	orr.w	r1, sl, #16
 8007126:	f7fb f86d 	bl	8002204 <xEventGroupSetBits>
 800712a:	e013      	b.n	8007154 <vSocketSelect+0x188>
			else
			{
				pxEnd = listGET_END_MARKER( &xBoundTCPSocketsList );
			}
		#endif /* ipconfigUSE_TCP == 1 */
			for( pxIterator = listGET_NEXT( pxEnd );
 800712c:	4b0e      	ldr	r3, [pc, #56]	; (8007168 <vSocketSelect+0x19c>)
 800712e:	68dc      	ldr	r4, [r3, #12]
 8007130:	3308      	adds	r3, #8
 8007132:	429c      	cmp	r4, r3
 8007134:	f47f af6d 	bne.w	8007012 <vSocketSelect+0x46>
 8007138:	e758      	b.n	8006fec <vSocketSelect+0x20>
 800713a:	4b08      	ldr	r3, [pc, #32]	; (800715c <vSocketSelect+0x190>)
 800713c:	68dc      	ldr	r4, [r3, #12]
 800713e:	9b03      	ldr	r3, [sp, #12]
 8007140:	429c      	cmp	r4, r3
 8007142:	f47f af6a 	bne.w	800701a <vSocketSelect+0x4e>
 8007146:	e751      	b.n	8006fec <vSocketSelect+0x20>
				if( pxSocket->pxSocketSet != pxSocketSet )
				{
					/* Socket does not belong to this select group. */
					continue;
				}
				xSocketBits = 0;
 8007148:	f04f 0800 	mov.w	r8, #0
 800714c:	e7a9      	b.n	80070a2 <vSocketSelect+0xd6>
							}
						}

						if( bMatch != pdFALSE )
						{
							xSocketBits |= ( EventBits_t ) eSELECT_WRITE;
 800714e:	f048 0802 	orr.w	r8, r8, #2
 8007152:	e7ce      	b.n	80070f2 <vSocketSelect+0x126>
			( void ) xEventGroupClearBits( pxSocketSet->xSelectGroup, xBitsToClear );
		}

		/* Now include eSELECT_CALL_IP to wakeup the caller. */
		( void ) xEventGroupSetBits( pxSocketSet->xSelectGroup, xGroupBits | ( EventBits_t ) eSELECT_CALL_IP );
	}
 8007154:	b005      	add	sp, #20
 8007156:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800715a:	bf00      	nop
 800715c:	2000d3c8 	.word	0x2000d3c8
 8007160:	2000d4f8 	.word	0x2000d4f8
 8007164:	2000d500 	.word	0x2000d500
 8007168:	2000d3dc 	.word	0x2000d3dc

0800716c <FreeRTOS_SignalSocket>:
	BaseType_t FreeRTOS_SignalSocket( Socket_t xSocket )
	{
	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
	BaseType_t xReturn;

		if( pxSocket == NULL )
 800716c:	b188      	cbz	r0, 8007192 <FreeRTOS_SignalSocket+0x26>

#if( ipconfigSUPPORT_SIGNALS != 0 )

	/* Send a signal to the task which reads from this socket. */
	BaseType_t FreeRTOS_SignalSocket( Socket_t xSocket )
	{
 800716e:	b508      	push	{r3, lr}
 8007170:	4603      	mov	r3, r0
		{
			xReturn = -pdFREERTOS_ERRNO_EINVAL;
		}
		else
	#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
		if( ( pxSocket->pxSocketSet != NULL ) && ( pxSocket->pxSocketSet->xSelectGroup != NULL ) )
 8007172:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8007174:	b132      	cbz	r2, 8007184 <FreeRTOS_SignalSocket+0x18>
 8007176:	6810      	ldr	r0, [r2, #0]
 8007178:	b120      	cbz	r0, 8007184 <FreeRTOS_SignalSocket+0x18>
		{
			( void ) xEventGroupSetBits( pxSocket->pxSocketSet->xSelectGroup, ( EventBits_t ) eSELECT_INTR );
 800717a:	2108      	movs	r1, #8
 800717c:	f7fb f842 	bl	8002204 <xEventGroupSetBits>
			xReturn = 0;
 8007180:	2000      	movs	r0, #0
 8007182:	bd08      	pop	{r3, pc}
		}
		else
	#endif /* ipconfigSUPPORT_SELECT_FUNCTION */
		if( pxSocket->xEventGroup != NULL )
 8007184:	6858      	ldr	r0, [r3, #4]
 8007186:	b138      	cbz	r0, 8007198 <FreeRTOS_SignalSocket+0x2c>
		{
			( void ) xEventGroupSetBits( pxSocket->xEventGroup, ( EventBits_t ) eSOCKET_INTR );
 8007188:	2140      	movs	r1, #64	; 0x40
 800718a:	f7fb f83b 	bl	8002204 <xEventGroupSetBits>
			xReturn = 0;
 800718e:	2000      	movs	r0, #0
 8007190:	bd08      	pop	{r3, pc}
	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
	BaseType_t xReturn;

		if( pxSocket == NULL )
		{
			xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8007192:	f06f 0015 	mvn.w	r0, #21
		{
			xReturn = -pdFREERTOS_ERRNO_EINVAL;
		}

		return xReturn;
	}
 8007196:	4770      	bx	lr
			( void ) xEventGroupSetBits( pxSocket->xEventGroup, ( EventBits_t ) eSOCKET_INTR );
			xReturn = 0;
		}
		else
		{
			xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8007198:	f06f 0015 	mvn.w	r0, #21
		}

		return xReturn;
	}
 800719c:	bd08      	pop	{r3, pc}
 800719e:	bf00      	nop

080071a0 <uxStreamBufferAdd>:
 * an offset from uxHead while uxHead will not be moved yet.  This possibility
 * will be used when TCP data is received while earlier data is still missing.
 * If 'pucData' equals NULL, the function is called to advance 'uxHead' only.
 */
size_t uxStreamBufferAdd( StreamBuffer_t *pxBuffer, size_t uxOffset, const uint8_t *pucData, size_t uxByteCount )
{
 80071a0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
static portINLINE size_t uxStreamBufferGetSpace( const StreamBuffer_t *pxBuffer );
static portINLINE size_t uxStreamBufferGetSpace( const StreamBuffer_t *pxBuffer )
{
/* Returns the number of items which can still be added to uxHead
before hitting on uxTail */
size_t uxHead = pxBuffer->uxHead;
 80071a4:	6887      	ldr	r7, [r0, #8]
size_t uxTail = pxBuffer->uxTail;
 80071a6:	6805      	ldr	r5, [r0, #0]
static portINLINE size_t uxStreamBufferSpace( const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper )
{
/* Returns the space between uxLower and uxUpper, which equals to the distance minus 1 */
size_t uxCount;

	uxCount = pxBuffer->LENGTH + uxUpper - uxLower - 1U;
 80071a8:	6906      	ldr	r6, [r0, #16]
 80071aa:	4435      	add	r5, r6
 80071ac:	3d01      	subs	r5, #1
 80071ae:	1bec      	subs	r4, r5, r7
	if( uxCount >= pxBuffer->LENGTH )
 80071b0:	42a6      	cmp	r6, r4
	{
		uxCount -= pxBuffer->LENGTH;
 80071b2:	bf98      	it	ls
 80071b4:	1ba4      	subls	r4, r4, r6
size_t uxCount = uxByteCount;

	uxSpace = uxStreamBufferGetSpace( pxBuffer );

	/* If uxOffset > 0, items can be placed in front of uxHead */
	if( uxSpace > uxOffset )
 80071b6:	42a1      	cmp	r1, r4
 80071b8:	d232      	bcs.n	8007220 <uxStreamBufferAdd+0x80>
	{
		uxSpace -= uxOffset;
 80071ba:	1a64      	subs	r4, r4, r1
	static portINLINE BaseType_t  FreeRTOS_min_BaseType  (BaseType_t  a, BaseType_t  b);

	static portINLINE int32_t  FreeRTOS_max_int32  (int32_t  a, int32_t  b) { return ( a >= b ) ? a : b; }
	static portINLINE uint32_t FreeRTOS_max_uint32 (uint32_t a, uint32_t b) { return ( a >= b ) ? a : b; }
	static portINLINE int32_t  FreeRTOS_min_int32  (int32_t  a, int32_t  b) { return ( a <= b ) ? a : b; }
	static portINLINE uint32_t FreeRTOS_min_uint32 (uint32_t a, uint32_t b) { return ( a <= b ) ? a : b; }
 80071bc:	429c      	cmp	r4, r3
 80071be:	bf28      	it	cs
 80071c0:	461c      	movcs	r4, r3

	/* The number of bytes that can be written is the minimum of the number of
	bytes requested and the number available. */
	uxCount = FreeRTOS_min_uint32( uxSpace, uxCount );

	if( uxCount != 0U )
 80071c2:	2c00      	cmp	r4, #0
 80071c4:	d04d      	beq.n	8007262 <uxStreamBufferAdd+0xc2>
 80071c6:	4691      	mov	r9, r2
 80071c8:	4688      	mov	r8, r1
 80071ca:	4605      	mov	r5, r0
	{
		uxNextHead = pxBuffer->uxHead;
 80071cc:	6887      	ldr	r7, [r0, #8]

		if( uxOffset != 0U )
 80071ce:	b349      	cbz	r1, 8007224 <uxStreamBufferAdd+0x84>
		{
			/* ( uxOffset > 0 ) means: write in front if the uxHead marker */
			uxNextHead += uxOffset;
 80071d0:	440f      	add	r7, r1
			if( uxNextHead >= pxBuffer->LENGTH )
 80071d2:	42b7      	cmp	r7, r6
 80071d4:	d328      	bcc.n	8007228 <uxStreamBufferAdd+0x88>
			{
				uxNextHead -= pxBuffer->LENGTH;
 80071d6:	1bbf      	subs	r7, r7, r6
 80071d8:	e026      	b.n	8007228 <uxStreamBufferAdd+0x88>
			could be written in the first write... */
			if( uxCount > uxFirst )
			{
				/* ...then write the remaining bytes to the start of the
				buffer. */
				( void ) memcpy( pxBuffer->ucArray, &( pucData[ uxFirst ] ), uxCount - uxFirst );
 80071da:	f105 0014 	add.w	r0, r5, #20
 80071de:	eb09 0106 	add.w	r1, r9, r6
 80071e2:	1ba2      	subs	r2, r4, r6
 80071e4:	f002 fe7e 	bl	8009ee4 <memcpy>
			}
		}

		if( uxOffset == 0U )
 80071e8:	f1b8 0f00 	cmp.w	r8, #0
 80071ec:	d105      	bne.n	80071fa <uxStreamBufferAdd+0x5a>
		{
			/* ( uxOffset == 0 ) means: write at uxHead position */
			uxNextHead += uxCount;
 80071ee:	4427      	add	r7, r4
			if( uxNextHead >= pxBuffer->LENGTH )
 80071f0:	692b      	ldr	r3, [r5, #16]
 80071f2:	429f      	cmp	r7, r3
			{
				uxNextHead -= pxBuffer->LENGTH;
 80071f4:	bf28      	it	cs
 80071f6:	1aff      	subcs	r7, r7, r3
			}
			pxBuffer->uxHead = uxNextHead;
 80071f8:	60af      	str	r7, [r5, #8]
		}

		if( xStreamBufferLessThenEqual( pxBuffer, pxBuffer->uxFront, uxNextHead ) != pdFALSE )
 80071fa:	68e9      	ldr	r1, [r5, #12]

static portINLINE BaseType_t xStreamBufferLessThenEqual( const StreamBuffer_t *pxBuffer, const size_t uxLeft, const size_t uxRight );
static portINLINE BaseType_t xStreamBufferLessThenEqual( const StreamBuffer_t *pxBuffer, const size_t uxLeft, const size_t uxRight )
{
BaseType_t xReturn;
size_t uxTail = pxBuffer->uxTail;
 80071fc:	682b      	ldr	r3, [r5, #0]

	/* Returns true if ( uxLeft < uxRight ) */
	if( ( ( ( uxLeft < uxTail ) ? 1U : 0U ) ^ ( ( uxRight < uxTail ) ? 1U : 0U )  ) != 0U )
 80071fe:	429f      	cmp	r7, r3
 8007200:	bf2c      	ite	cs
 8007202:	2200      	movcs	r2, #0
 8007204:	2201      	movcc	r2, #1
 8007206:	4299      	cmp	r1, r3
 8007208:	bf2c      	ite	cs
 800720a:	2300      	movcs	r3, #0
 800720c:	2301      	movcc	r3, #1
 800720e:	4293      	cmp	r3, r2
 8007210:	d103      	bne.n	800721a <uxStreamBufferAdd+0x7a>
			xReturn = pdFALSE;
		}
	}
	else
	{
		if( uxLeft <= uxRight )
 8007212:	428f      	cmp	r7, r1
 8007214:	bf34      	ite	cc
 8007216:	2200      	movcc	r2, #0
 8007218:	2201      	movcs	r2, #1
 800721a:	b312      	cbz	r2, 8007262 <uxStreamBufferAdd+0xc2>
		{
			/* Advance the front pointer */
			pxBuffer->uxFront = uxNextHead;
 800721c:	60ef      	str	r7, [r5, #12]
 800721e:	e020      	b.n	8007262 <uxStreamBufferAdd+0xc2>
 8007220:	2400      	movs	r4, #0
 8007222:	e01e      	b.n	8007262 <uxStreamBufferAdd+0xc2>
			{
				uxNextHead -= pxBuffer->LENGTH;
			}
		}

		if( pucData != NULL )
 8007224:	b982      	cbnz	r2, 8007248 <uxStreamBufferAdd+0xa8>
 8007226:	e7e2      	b.n	80071ee <uxStreamBufferAdd+0x4e>
 8007228:	f1b9 0f00 	cmp.w	r9, #0
 800722c:	d0e5      	beq.n	80071fa <uxStreamBufferAdd+0x5a>
		{
			/* Calculate the number of bytes that can be added in the first
			write - which may be less than the total number of bytes that need
			to be added if the buffer will wrap back to the beginning. */
			uxFirst = FreeRTOS_min_uint32( pxBuffer->LENGTH - uxNextHead, uxCount );
 800722e:	1bf6      	subs	r6, r6, r7
 8007230:	42a6      	cmp	r6, r4
 8007232:	bf28      	it	cs
 8007234:	4626      	movcs	r6, r4

			/* Write as many bytes as can be written in the first write. */
			( void ) memcpy( &( pxBuffer->ucArray[ uxNextHead ] ), pucData, uxFirst );
 8007236:	19e8      	adds	r0, r5, r7
 8007238:	3014      	adds	r0, #20
 800723a:	4649      	mov	r1, r9
 800723c:	4632      	mov	r2, r6
 800723e:	f002 fe51 	bl	8009ee4 <memcpy>

			/* If the number of bytes written was less than the number that
			could be written in the first write... */
			if( uxCount > uxFirst )
 8007242:	42b4      	cmp	r4, r6
 8007244:	d9d9      	bls.n	80071fa <uxStreamBufferAdd+0x5a>
 8007246:	e7c8      	b.n	80071da <uxStreamBufferAdd+0x3a>
		if( pucData != NULL )
		{
			/* Calculate the number of bytes that can be added in the first
			write - which may be less than the total number of bytes that need
			to be added if the buffer will wrap back to the beginning. */
			uxFirst = FreeRTOS_min_uint32( pxBuffer->LENGTH - uxNextHead, uxCount );
 8007248:	1bf6      	subs	r6, r6, r7
 800724a:	42a6      	cmp	r6, r4
 800724c:	bf28      	it	cs
 800724e:	4626      	movcs	r6, r4

			/* Write as many bytes as can be written in the first write. */
			( void ) memcpy( &( pxBuffer->ucArray[ uxNextHead ] ), pucData, uxFirst );
 8007250:	4438      	add	r0, r7
 8007252:	3014      	adds	r0, #20
 8007254:	4611      	mov	r1, r2
 8007256:	4632      	mov	r2, r6
 8007258:	f002 fe44 	bl	8009ee4 <memcpy>

			/* If the number of bytes written was less than the number that
			could be written in the first write... */
			if( uxCount > uxFirst )
 800725c:	42b4      	cmp	r4, r6
 800725e:	d9c6      	bls.n	80071ee <uxStreamBufferAdd+0x4e>
 8007260:	e7bb      	b.n	80071da <uxStreamBufferAdd+0x3a>
			pxBuffer->uxFront = uxNextHead;
		}
	}

	return uxCount;
}
 8007262:	4620      	mov	r0, r4
 8007264:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

08007268 <uxStreamBufferGet>:
 * If 'pucData' equals NULL, the function is called to advance 'lTail' only.
 * if 'xPeek' is pdTRUE, or if 'uxOffset' is non-zero, the 'lTail' pointer will
 * not be advanced.
 */
size_t uxStreamBufferGet( StreamBuffer_t *pxBuffer, size_t uxOffset, uint8_t *pucData, size_t uxMaxCount, BaseType_t xPeek )
{
 8007268:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
static portINLINE size_t uxStreamBufferGetSize( const StreamBuffer_t *pxBuffer );
static portINLINE size_t uxStreamBufferGetSize( const StreamBuffer_t *pxBuffer )
{
/* Returns the number of items which can be read from uxTail
before reaching uxHead */
size_t uxHead = pxBuffer->uxHead;
 800726c:	6885      	ldr	r5, [r0, #8]
size_t uxTail = pxBuffer->uxTail;
 800726e:	6807      	ldr	r7, [r0, #0]
static portINLINE size_t uxStreamBufferDistance( const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper )
{
/* Returns the distance between uxLower and uxUpper */
size_t uxCount;

	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
 8007270:	6906      	ldr	r6, [r0, #16]
 8007272:	4435      	add	r5, r6
 8007274:	1bec      	subs	r4, r5, r7
	if ( uxCount >= pxBuffer->LENGTH )
 8007276:	42a6      	cmp	r6, r4
	{
		uxCount -= pxBuffer->LENGTH;
 8007278:	bf98      	it	ls
 800727a:	1ba4      	subls	r4, r4, r6
size_t uxSize, uxCount, uxFirst, uxNextTail;

	/* How much data is available? */
	uxSize = uxStreamBufferGetSize( pxBuffer );

	if( uxSize > uxOffset )
 800727c:	42a1      	cmp	r1, r4
 800727e:	d22d      	bcs.n	80072dc <uxStreamBufferGet+0x74>
	{
		uxSize -= uxOffset;
 8007280:	1a64      	subs	r4, r4, r1
 8007282:	429c      	cmp	r4, r3
 8007284:	bf28      	it	cs
 8007286:	461c      	movcs	r4, r3
	}

	/* Use the minimum of the wanted bytes and the available bytes. */
	uxCount = FreeRTOS_min_uint32( uxSize, uxMaxCount );

	if( uxCount > 0U )
 8007288:	b34c      	cbz	r4, 80072de <uxStreamBufferGet+0x76>
	{
		uxNextTail = pxBuffer->uxTail;
 800728a:	6807      	ldr	r7, [r0, #0]

		if( uxOffset != 0U )
 800728c:	b119      	cbz	r1, 8007296 <uxStreamBufferGet+0x2e>
		{
			uxNextTail += uxOffset;
 800728e:	440f      	add	r7, r1
			if( uxNextTail >= pxBuffer->LENGTH )
 8007290:	42b7      	cmp	r7, r6
			{
				uxNextTail -= pxBuffer->LENGTH;
 8007292:	bf28      	it	cs
 8007294:	1bbf      	subcs	r7, r7, r6
 8007296:	4690      	mov	r8, r2
 8007298:	460d      	mov	r5, r1
 800729a:	4681      	mov	r9, r0
			}
		}

		if( pucData != NULL )
 800729c:	b192      	cbz	r2, 80072c4 <uxStreamBufferGet+0x5c>
		{
			/* Calculate the number of bytes that can be read - which may be
			less than the number wanted if the data wraps around to the start of
			the buffer. */
			uxFirst = FreeRTOS_min_uint32( pxBuffer->LENGTH - uxNextTail, uxCount );
 800729e:	1bf6      	subs	r6, r6, r7
 80072a0:	42a6      	cmp	r6, r4
 80072a2:	bf28      	it	cs
 80072a4:	4626      	movcs	r6, r4

			/* Obtain the number of bytes it is possible to obtain in the first
			read. */
			( void ) memcpy( pucData, &( pxBuffer->ucArray[ uxNextTail ] ), uxFirst );
 80072a6:	19c1      	adds	r1, r0, r7
 80072a8:	4610      	mov	r0, r2
 80072aa:	3114      	adds	r1, #20
 80072ac:	4632      	mov	r2, r6
 80072ae:	f002 fe19 	bl	8009ee4 <memcpy>

			/* If the total number of wanted bytes is greater than the number
			that could be read in the first read... */
			if( uxCount > uxFirst )
 80072b2:	42b4      	cmp	r4, r6
 80072b4:	d906      	bls.n	80072c4 <uxStreamBufferGet+0x5c>
			{
				/*...then read the remaining bytes from the start of the buffer. */
				( void ) memcpy( &( pucData[ uxFirst ] ), pxBuffer->ucArray, uxCount - uxFirst );
 80072b6:	eb08 0006 	add.w	r0, r8, r6
 80072ba:	f109 0114 	add.w	r1, r9, #20
 80072be:	1ba2      	subs	r2, r4, r6
 80072c0:	f002 fe10 	bl	8009ee4 <memcpy>
			}
		}

		if( ( xPeek == pdFALSE ) && ( uxOffset == 0UL ) )
 80072c4:	9b08      	ldr	r3, [sp, #32]
 80072c6:	b953      	cbnz	r3, 80072de <uxStreamBufferGet+0x76>
 80072c8:	b94d      	cbnz	r5, 80072de <uxStreamBufferGet+0x76>
		{
			/* Move the tail pointer to effecively remove the data read from
			the buffer. */
			uxNextTail += uxCount;
 80072ca:	4427      	add	r7, r4

			if( uxNextTail >= pxBuffer->LENGTH )
 80072cc:	f8d9 3010 	ldr.w	r3, [r9, #16]
 80072d0:	429f      	cmp	r7, r3
			{
				uxNextTail -= pxBuffer->LENGTH;
 80072d2:	bf28      	it	cs
 80072d4:	1aff      	subcs	r7, r7, r3
			}

			pxBuffer->uxTail = uxNextTail;
 80072d6:	f8c9 7000 	str.w	r7, [r9]
 80072da:	e000      	b.n	80072de <uxStreamBufferGet+0x76>
 80072dc:	2400      	movs	r4, #0
		}
	}

	return uxCount;
}
 80072de:	4620      	mov	r0, r4
 80072e0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

080072e4 <prvTCPAddTxData>:
	return ( TickType_t ) pxSocket->u.xTCP.usTimeout;
}
/*-----------------------------------------------------------*/

static void prvTCPAddTxData( FreeRTOS_Socket_t *pxSocket )
{
 80072e4:	b510      	push	{r4, lr}
	the sliding window.

	uxStreamBufferMidSpace() returns the distance between rxHead and rxMid.  It
	contains new Tx data which has not been passed to the sliding window yet.
	The oldest data not-yet-confirmed can be found at rxTail. */
	lLength = ( int32_t ) uxStreamBufferMidSpace( pxSocket->u.xTCP.txStream );
 80072e6:	6f82      	ldr	r2, [r0, #120]	; 0x78

static portINLINE size_t uxStreamBufferMidSpace( const StreamBuffer_t *pxBuffer );
static portINLINE size_t uxStreamBufferMidSpace( const StreamBuffer_t *pxBuffer )
{
/* Returns the distance between uxHead and uxMid */
size_t uxHead = pxBuffer->uxHead;
 80072e8:	6891      	ldr	r1, [r2, #8]
size_t uxMid = pxBuffer->uxMid;
 80072ea:	6854      	ldr	r4, [r2, #4]
static portINLINE size_t uxStreamBufferDistance( const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper )
{
/* Returns the distance between uxLower and uxUpper */
size_t uxCount;

	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
 80072ec:	6913      	ldr	r3, [r2, #16]
 80072ee:	4419      	add	r1, r3
 80072f0:	1b09      	subs	r1, r1, r4
	if ( uxCount >= pxBuffer->LENGTH )
 80072f2:	428b      	cmp	r3, r1
	{
		uxCount -= pxBuffer->LENGTH;
 80072f4:	bf98      	it	ls
 80072f6:	1ac9      	subls	r1, r1, r3

	if( lLength > 0 )
 80072f8:	2900      	cmp	r1, #0
 80072fa:	dd1b      	ble.n	8007334 <prvTCPAddTxData+0x50>
 80072fc:	4604      	mov	r4, r0
		Hand over the new data to the sliding window handler.  It will be
		split-up in chunks of 1460 bytes each (or less, depending on
		ipconfigTCP_MSS). */
		lCount = lTCPWindowTxAdd(	&pxSocket->u.xTCP.xTCPWindow,
								( uint32_t ) lLength,
								( int32_t ) pxSocket->u.xTCP.txStream->uxMid,
 80072fe:	6852      	ldr	r2, [r2, #4]
		window manager, so it can start transmitting them.

		Hand over the new data to the sliding window handler.  It will be
		split-up in chunks of 1460 bytes each (or less, depending on
		ipconfigTCP_MSS). */
		lCount = lTCPWindowTxAdd(	&pxSocket->u.xTCP.xTCPWindow,
 8007300:	30d8      	adds	r0, #216	; 0xd8
 8007302:	f001 fe81 	bl	8009008 <lTCPWindowTxAdd>
								( uint32_t ) lLength,
								( int32_t ) pxSocket->u.xTCP.txStream->uxMid,
								( int32_t ) pxSocket->u.xTCP.txStream->LENGTH );

		/* Move the rxMid pointer forward up to rxHead. */
		if( lCount > 0 )
 8007306:	2800      	cmp	r0, #0
 8007308:	dd14      	ble.n	8007334 <prvTCPAddTxData+0x50>
		{
			vStreamBufferMoveMid( pxSocket->u.xTCP.txStream, ( size_t ) lCount );
 800730a:	6fa3      	ldr	r3, [r4, #120]	; 0x78

static portINLINE size_t uxStreamBufferMidSpace( const StreamBuffer_t *pxBuffer );
static portINLINE size_t uxStreamBufferMidSpace( const StreamBuffer_t *pxBuffer )
{
/* Returns the distance between uxHead and uxMid */
size_t uxHead = pxBuffer->uxHead;
 800730c:	6899      	ldr	r1, [r3, #8]
size_t uxMid = pxBuffer->uxMid;
 800730e:	685a      	ldr	r2, [r3, #4]
static portINLINE size_t uxStreamBufferDistance( const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper )
{
/* Returns the distance between uxLower and uxUpper */
size_t uxCount;

	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
 8007310:	691c      	ldr	r4, [r3, #16]
 8007312:	4421      	add	r1, r4
 8007314:	1a8a      	subs	r2, r1, r2
	if ( uxCount >= pxBuffer->LENGTH )
 8007316:	4294      	cmp	r4, r2
	{
		uxCount -= pxBuffer->LENGTH;
 8007318:	bf98      	it	ls
 800731a:	1b12      	subls	r2, r2, r4

	if( uxMoveCount > uxSize )
	{
		uxMoveCount = uxSize;
	}
	pxBuffer->uxMid += uxMoveCount;
 800731c:	6859      	ldr	r1, [r3, #4]
 800731e:	4282      	cmp	r2, r0
 8007320:	bf94      	ite	ls
 8007322:	188a      	addls	r2, r1, r2
 8007324:	180a      	addhi	r2, r1, r0
 8007326:	605a      	str	r2, [r3, #4]
	if( pxBuffer->uxMid >= pxBuffer->LENGTH )
 8007328:	685a      	ldr	r2, [r3, #4]
 800732a:	4294      	cmp	r4, r2
 800732c:	d802      	bhi.n	8007334 <prvTCPAddTxData+0x50>
	{
		pxBuffer->uxMid -= pxBuffer->LENGTH;
 800732e:	685a      	ldr	r2, [r3, #4]
 8007330:	1b14      	subs	r4, r2, r4
 8007332:	605c      	str	r4, [r3, #4]
 8007334:	bd10      	pop	{r4, pc}
 8007336:	bf00      	nop

08007338 <prvTCPReturnPacket>:
 * which may either point to a real network buffer or to a TCP socket field
 * called 'xTCP.xPacket'.   A temporary xNetworkBuffer will be used to pass
 * the data to the NIC.
 */
static void prvTCPReturnPacket( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t *pxDescriptor, uint32_t ulLen, BaseType_t xReleaseAfterSend )
{
 8007338:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800733c:	b08a      	sub	sp, #40	; 0x28
 800733e:	461e      	mov	r6, r3
const TCPWindow_t *pxTCPWindow;
NetworkBufferDescriptor_t *pxNetworkBuffer = pxDescriptor;
NetworkBufferDescriptor_t xTempBuffer;
/* For sending, a pseudo network buffer will be used, as explained above. */

	if( pxNetworkBuffer == NULL )
 8007340:	460d      	mov	r5, r1
 8007342:	2900      	cmp	r1, #0
 8007344:	f040 80f3 	bne.w	800752e <prvTCPReturnPacket+0x1f6>
		#if( ipconfigUSE_LINKED_RX_MESSAGES != 0 )
		{
			pxNetworkBuffer->pxNextBuffer = NULL;
		}
		#endif
		pxNetworkBuffer->pucEthernetBuffer = pxSocket->u.xTCP.xPacket.u.ucLastPacket;
 8007348:	f100 0382 	add.w	r3, r0, #130	; 0x82
 800734c:	9307      	str	r3, [sp, #28]
		pxNetworkBuffer->xDataLength = sizeof( pxSocket->u.xTCP.xPacket.u.ucLastPacket );
 800734e:	2346      	movs	r3, #70	; 0x46
 8007350:	9308      	str	r3, [sp, #32]
NetworkBufferDescriptor_t xTempBuffer;
/* For sending, a pseudo network buffer will be used, as explained above. */

	if( pxNetworkBuffer == NULL )
	{
		pxNetworkBuffer = &xTempBuffer;
 8007352:	ad01      	add	r5, sp, #4
			pxNetworkBuffer->pxNextBuffer = NULL;
		}
		#endif
		pxNetworkBuffer->pucEthernetBuffer = pxSocket->u.xTCP.xPacket.u.ucLastPacket;
		pxNetworkBuffer->xDataLength = sizeof( pxSocket->u.xTCP.xPacket.u.ucLastPacket );
		xDoRelease = pdFALSE;
 8007354:	2600      	movs	r6, #0
 8007356:	e0ea      	b.n	800752e <prvTCPReturnPacket+0x1f6>
		{
			/* Calculate the space in the RX buffer in order to advertise the
			size of this socket's reception window. */
			pxTCPWindow = &( pxSocket->u.xTCP.xTCPWindow );

			if( pxSocket->u.xTCP.rxStream != NULL )
 8007358:	6f41      	ldr	r1, [r0, #116]	; 0x74
 800735a:	b149      	cbz	r1, 8007370 <prvTCPReturnPacket+0x38>
{
/* Distance between uxFront and uxTail
or the number of items which can still be added to uxFront,
before hitting on uxTail */

size_t uxFront = pxBuffer->uxFront;
 800735c:	68cf      	ldr	r7, [r1, #12]
size_t uxTail = pxBuffer->uxTail;
 800735e:	680b      	ldr	r3, [r1, #0]
static portINLINE size_t uxStreamBufferSpace( const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper )
{
/* Returns the space between uxLower and uxUpper, which equals to the distance minus 1 */
size_t uxCount;

	uxCount = pxBuffer->LENGTH + uxUpper - uxLower - 1U;
 8007360:	6909      	ldr	r1, [r1, #16]
 8007362:	440b      	add	r3, r1
 8007364:	3b01      	subs	r3, #1
 8007366:	1bdb      	subs	r3, r3, r7
	if( uxCount >= pxBuffer->LENGTH )
 8007368:	4299      	cmp	r1, r3
 800736a:	d802      	bhi.n	8007372 <prvTCPReturnPacket+0x3a>
	{
		uxCount -= pxBuffer->LENGTH;
 800736c:	1a5b      	subs	r3, r3, r1
 800736e:	e000      	b.n	8007372 <prvTCPReturnPacket+0x3a>
			}
			else
			{
				/* No RX stream has been created, the full stream size is
				available. */
				ulFrontSpace = ( uint32_t ) pxSocket->u.xTCP.uxRxStreamSize;
 8007370:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
			}

			/* Take the minimum of the RX buffer space and the RX window size. */
			ulSpace = FreeRTOS_min_uint32( pxTCPWindow->xSize.ulRxWindowLength, ulFrontSpace );
 8007372:	f8d0 e0dc 	ldr.w	lr, [r0, #220]	; 0xdc

			if( ( pxSocket->u.xTCP.bits.bLowWater != pdFALSE_UNSIGNED ) || ( pxSocket->u.xTCP.bits.bRxStopped != pdFALSE_UNSIGNED ) )
 8007376:	4f72      	ldr	r7, [pc, #456]	; (8007540 <prvTCPReturnPacket+0x208>)
 8007378:	6c01      	ldr	r1, [r0, #64]	; 0x40
 800737a:	400f      	ands	r7, r1
 800737c:	b927      	cbnz	r7, 8007388 <prvTCPReturnPacket+0x50>
 800737e:	4671      	mov	r1, lr
 8007380:	459e      	cmp	lr, r3
 8007382:	bf28      	it	cs
 8007384:	4619      	movcs	r1, r3
 8007386:	e000      	b.n	800738a <prvTCPReturnPacket+0x52>
			{
				/* The low-water mark was reached, meaning there was little
				space left.  The socket will wait until the application has read
				or flushed the incoming data, and 'zero-window' will be
				advertised. */
				ulSpace = 0U;
 8007388:	2100      	movs	r1, #0
			}

			/* If possible, advertise an RX window size of at least 1 MSS, otherwise
			the peer might start 'zero window probing', i.e. sending small packets
			(1, 2, 4, 8... bytes). */
			if( ( ulSpace < pxSocket->u.xTCP.usCurMSS ) && ( ulFrontSpace >= pxSocket->u.xTCP.usCurMSS ) )
 800738a:	f8b0 704a 	ldrh.w	r7, [r0, #74]	; 0x4a
 800738e:	42b9      	cmp	r1, r7
 8007390:	d202      	bcs.n	8007398 <prvTCPReturnPacket+0x60>
			{
				ulSpace = pxSocket->u.xTCP.usCurMSS;
 8007392:	42bb      	cmp	r3, r7
 8007394:	bf28      	it	cs
 8007396:	4639      	movcs	r1, r7
			}

			/* Avoid overflow of the 16-bit win field. */
			#if( ipconfigUSE_TCP_WIN != 0 )
			{
				ulWinSize = ( ulSpace >> pxSocket->u.xTCP.ucMyWinScaleFactor );
 8007398:	f890 30c9 	ldrb.w	r3, [r0, #201]	; 0xc9
 800739c:	fa21 f703 	lsr.w	r7, r1, r3
 80073a0:	f64f 73fc 	movw	r3, #65532	; 0xfffc
 80073a4:	42bb      	cmp	r3, r7
 80073a6:	bf28      	it	cs
 80073a8:	463b      	movcs	r3, r7
 80073aa:	b29b      	uxth	r3, r3
			if( ulWinSize > 0xfffcUL )
			{
				ulWinSize = 0xfffcUL;
			}

			pxTCPPacket->xTCPHeader.usWindow = FreeRTOS_htons( ( uint16_t ) ulWinSize );
 80073ac:	0a1f      	lsrs	r7, r3, #8
 80073ae:	ea47 2303 	orr.w	r3, r7, r3, lsl #8
 80073b2:	8623      	strh	r3, [r4, #48]	; 0x30

			/* The new window size has been advertised, switch off the flag. */
			pxSocket->u.xTCP.bits.bWinChange = pdFALSE_UNSIGNED;
 80073b4:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 80073b8:	f36f 0300 	bfc	r3, #0, #1
 80073bc:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41

			/* Later on, when deciding to delay an ACK, a precise estimate is needed
			of the free RX space.  At this moment, 'ulHighestRxAllowed' would be the
			highest sequence number minus 1 that the socket will accept. */
			pxSocket->u.xTCP.ulHighestRxAllowed = pxTCPWindow->rx.ulCurrentSequenceNumber + ulSpace;
 80073c0:	f8d0 70e8 	ldr.w	r7, [r0, #232]	; 0xe8
 80073c4:	4439      	add	r1, r7
 80073c6:	6441      	str	r1, [r0, #68]	; 0x44

		#if( ipconfigTCP_KEEP_ALIVE == 1 )
			if( pxSocket->u.xTCP.bits.bSendKeepAlive != pdFALSE_UNSIGNED )
 80073c8:	f013 0f02 	tst.w	r3, #2
 80073cc:	d017      	beq.n	80073fe <prvTCPReturnPacket+0xc6>
			{
				/* Sending a keep-alive packet, send the current sequence number
				minus 1, which will	be recognised as a keep-alive packet an
				responded to by acknowledging the last byte. */
				pxSocket->u.xTCP.bits.bSendKeepAlive = pdFALSE_UNSIGNED;
 80073ce:	b2db      	uxtb	r3, r3
				pxSocket->u.xTCP.bits.bWaitKeepAlive = pdTRUE_UNSIGNED;
 80073d0:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
 80073d4:	f043 0304 	orr.w	r3, r3, #4
 80073d8:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41

				pxTCPPacket->xTCPHeader.ulSequenceNumber = pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber - 1UL;
 80073dc:	f8d0 3104 	ldr.w	r3, [r0, #260]	; 0x104
 80073e0:	3b01      	subs	r3, #1
				pxTCPPacket->xTCPHeader.ulSequenceNumber = FreeRTOS_htonl( pxTCPPacket->xTCPHeader.ulSequenceNumber );
 80073e2:	0619      	lsls	r1, r3, #24
 80073e4:	ea41 6113 	orr.w	r1, r1, r3, lsr #24
 80073e8:	f403 477f 	and.w	r7, r3, #65280	; 0xff00
 80073ec:	ea41 2107 	orr.w	r1, r1, r7, lsl #8
 80073f0:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 80073f4:	ea41 2313 	orr.w	r3, r1, r3, lsr #8
 80073f8:	f8c4 3026 	str.w	r3, [r4, #38]	; 0x26
 80073fc:	e01f      	b.n	800743e <prvTCPReturnPacket+0x106>
			}
			else
		#endif
			{
				pxTCPPacket->xTCPHeader.ulSequenceNumber = FreeRTOS_htonl( pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber );
 80073fe:	f8d0 7104 	ldr.w	r7, [r0, #260]	; 0x104
 8007402:	0639      	lsls	r1, r7, #24
 8007404:	ea41 6117 	orr.w	r1, r1, r7, lsr #24
 8007408:	f407 437f 	and.w	r3, r7, #65280	; 0xff00
 800740c:	ea41 2103 	orr.w	r1, r1, r3, lsl #8
 8007410:	f407 037f 	and.w	r3, r7, #16711680	; 0xff0000
 8007414:	ea41 2313 	orr.w	r3, r1, r3, lsr #8
 8007418:	f8c4 3026 	str.w	r3, [r4, #38]	; 0x26

				if( ( pxTCPPacket->xTCPHeader.ucTCPFlags & ( uint8_t ) tcpTCP_FLAG_FIN ) != 0U )
 800741c:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
 8007420:	f013 0f01 	tst.w	r3, #1
 8007424:	d00b      	beq.n	800743e <prvTCPReturnPacket+0x106>
 8007426:	f8d0 1104 	ldr.w	r1, [r0, #260]	; 0x104
 800742a:	3928      	subs	r1, #40	; 0x28
				{
					/* Suppress FIN in case this packet carries earlier data to be
					retransmitted. */
					uint32_t ulDataLen = ( uint32_t ) ( ulLen - ( ipSIZE_OF_TCP_HEADER + ipSIZE_OF_IPv4_HEADER ) );
					if( ( pxTCPWindow->ulOurSequenceNumber + ulDataLen ) != pxTCPWindow->tx.ulFINSequenceNumber )
 800742c:	4411      	add	r1, r2
 800742e:	f8d0 70fc 	ldr.w	r7, [r0, #252]	; 0xfc
 8007432:	42b9      	cmp	r1, r7
					{
						pxTCPPacket->xTCPHeader.ucTCPFlags &= ( ( uint8_t ) ~tcpTCP_FLAG_FIN );
 8007434:	bf1c      	itt	ne
 8007436:	f023 0301 	bicne.w	r3, r3, #1
 800743a:	f884 302f 	strbne.w	r3, [r4, #47]	; 0x2f
					}
				}
			}

			/* Tell which sequence number is expected next time */
			pxTCPPacket->xTCPHeader.ulAckNr = FreeRTOS_htonl( pxTCPWindow->rx.ulCurrentSequenceNumber );
 800743e:	f8d0 00e8 	ldr.w	r0, [r0, #232]	; 0xe8
 8007442:	0601      	lsls	r1, r0, #24
 8007444:	ea41 6110 	orr.w	r1, r1, r0, lsr #24
 8007448:	f400 437f 	and.w	r3, r0, #65280	; 0xff00
 800744c:	ea41 2103 	orr.w	r1, r1, r3, lsl #8
 8007450:	f400 037f 	and.w	r3, r0, #16711680	; 0xff0000
 8007454:	ea41 2313 	orr.w	r3, r1, r3, lsr #8
 8007458:	f8c4 302a 	str.w	r3, [r4, #42]	; 0x2a
			/* Sending data without a socket, probably replying with a RST flag
			Just swap the two sequence numbers. */
			vFlip_32( pxTCPPacket->xTCPHeader.ulSequenceNumber, pxTCPPacket->xTCPHeader.ulAckNr );
		}

		pxIPHeader->ucTimeToLive		   = ( uint8_t ) ipconfigTCP_TIME_TO_LIVE;
 800745c:	2380      	movs	r3, #128	; 0x80
 800745e:	75a3      	strb	r3, [r4, #22]
		pxIPHeader->usLength			   = FreeRTOS_htons( ulLen );
 8007460:	0213      	lsls	r3, r2, #8
 8007462:	ea43 2312 	orr.w	r3, r3, r2, lsr #8
 8007466:	8223      	strh	r3, [r4, #16]
		if( ( pxSocket == NULL ) || ( *ipLOCAL_IP_ADDRESS_POINTER == 0UL ) )
 8007468:	4b36      	ldr	r3, [pc, #216]	; (8007544 <prvTCPReturnPacket+0x20c>)
 800746a:	695b      	ldr	r3, [r3, #20]
 800746c:	b173      	cbz	r3, 800748c <prvTCPReturnPacket+0x154>
 800746e:	e00f      	b.n	8007490 <prvTCPReturnPacket+0x158>
		}
		else
		{
			/* Sending data without a socket, probably replying with a RST flag
			Just swap the two sequence numbers. */
			vFlip_32( pxTCPPacket->xTCPHeader.ulSequenceNumber, pxTCPPacket->xTCPHeader.ulAckNr );
 8007470:	f8d4 3026 	ldr.w	r3, [r4, #38]	; 0x26
 8007474:	f8d4 102a 	ldr.w	r1, [r4, #42]	; 0x2a
 8007478:	f8c4 1026 	str.w	r1, [r4, #38]	; 0x26
 800747c:	f8c4 302a 	str.w	r3, [r4, #42]	; 0x2a
		}

		pxIPHeader->ucTimeToLive		   = ( uint8_t ) ipconfigTCP_TIME_TO_LIVE;
 8007480:	2380      	movs	r3, #128	; 0x80
 8007482:	75a3      	strb	r3, [r4, #22]
		pxIPHeader->usLength			   = FreeRTOS_htons( ulLen );
 8007484:	0213      	lsls	r3, r2, #8
 8007486:	ea43 2312 	orr.w	r3, r3, r2, lsr #8
 800748a:	8223      	strh	r3, [r4, #16]
		{
			/* When pxSocket is NULL, this function is called by prvTCPSendReset()
			and the IP-addresses must be swapped.
			Also swap the IP-addresses in case the IP-tack doesn't have an
			IP-address yet, i.e. when ( *ipLOCAL_IP_ADDRESS_POINTER == 0UL ). */
			ulSourceAddress = pxIPHeader->ulDestinationIPAddress;
 800748c:	f8d4 301e 	ldr.w	r3, [r4, #30]
		}
		else
		{
			ulSourceAddress = *ipLOCAL_IP_ADDRESS_POINTER;
		}
		pxIPHeader->ulDestinationIPAddress = pxIPHeader->ulSourceIPAddress;
 8007490:	f8d4 101a 	ldr.w	r1, [r4, #26]
 8007494:	f8c4 101e 	str.w	r1, [r4, #30]
		pxIPHeader->ulSourceIPAddress = ulSourceAddress;
 8007498:	f8c4 301a 	str.w	r3, [r4, #26]
		vFlip_16( pxTCPPacket->xTCPHeader.usSourcePort, pxTCPPacket->xTCPHeader.usDestinationPort );
 800749c:	8c63      	ldrh	r3, [r4, #34]	; 0x22
 800749e:	8ca1      	ldrh	r1, [r4, #36]	; 0x24
 80074a0:	8461      	strh	r1, [r4, #34]	; 0x22
 80074a2:	84a3      	strh	r3, [r4, #36]	; 0x24

		/* Just an increasing number. */
		pxIPHeader->usIdentification = FreeRTOS_htons( usPacketIdentifier );
 80074a4:	4828      	ldr	r0, [pc, #160]	; (8007548 <prvTCPReturnPacket+0x210>)
 80074a6:	8803      	ldrh	r3, [r0, #0]
 80074a8:	0a19      	lsrs	r1, r3, #8
 80074aa:	ea41 2103 	orr.w	r1, r1, r3, lsl #8
 80074ae:	8261      	strh	r1, [r4, #18]
		usPacketIdentifier++;
 80074b0:	3301      	adds	r3, #1
 80074b2:	8003      	strh	r3, [r0, #0]
		pxIPHeader->usFragmentOffset = 0U;
 80074b4:	2000      	movs	r0, #0
 80074b6:	7520      	strb	r0, [r4, #20]
 80074b8:	7560      	strb	r0, [r4, #21]

		/* Important: tell NIC driver how many bytes must be sent. */
		pxNetworkBuffer->xDataLength = ulLen + ipSIZE_OF_ETH_HEADER;
 80074ba:	320e      	adds	r2, #14
 80074bc:	61ea      	str	r2, [r5, #28]

		#if( ipconfigDRIVER_INCLUDED_TX_IP_CHECKSUM == 0 )
		{
			/* calculate the IP header checksum, in case the driver won't do that. */
			pxIPHeader->usHeaderChecksum = 0x00U;
 80074be:	7620      	strb	r0, [r4, #24]
 80074c0:	7660      	strb	r0, [r4, #25]
			pxIPHeader->usHeaderChecksum = usGenerateChecksum( 0U, ( uint8_t * ) &( pxIPHeader->ucVersionHeaderLength ), ipSIZE_OF_IPv4_HEADER );
 80074c2:	f104 010e 	add.w	r1, r4, #14
 80074c6:	2214      	movs	r2, #20
 80074c8:	f7fd ff28 	bl	800531c <usGenerateChecksum>
			pxIPHeader->usHeaderChecksum = ~FreeRTOS_htons( pxIPHeader->usHeaderChecksum );
 80074cc:	0a03      	lsrs	r3, r0, #8
 80074ce:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 80074d2:	43c0      	mvns	r0, r0
 80074d4:	8320      	strh	r0, [r4, #24]

			/* calculate the TCP checksum for an outgoing packet. */
			( void ) usGenerateProtocolChecksum( ( uint8_t * ) pxTCPPacket, pxNetworkBuffer->xDataLength, pdTRUE );
 80074d6:	4620      	mov	r0, r4
 80074d8:	69e9      	ldr	r1, [r5, #28]
 80074da:	2201      	movs	r2, #1
 80074dc:	f7fd ff8e 	bl	80053fc <usGenerateProtocolChecksum>

			/* A calculated checksum of 0 must be inverted as 0 means the checksum
			is disabled. */
			if( pxTCPPacket->xTCPHeader.usChecksum == 0U )
 80074e0:	8e63      	ldrh	r3, [r4, #50]	; 0x32
 80074e2:	b92b      	cbnz	r3, 80074f0 <prvTCPReturnPacket+0x1b8>
			{
				pxTCPPacket->xTCPHeader.usChecksum = 0xffffU;
 80074e4:	f04f 33ff 	mov.w	r3, #4294967295
 80074e8:	f884 3032 	strb.w	r3, [r4, #50]	; 0x32
 80074ec:	f884 3033 	strb.w	r3, [r4, #51]	; 0x33
		}
		#endif

		/* Fill in the destination MAC addresses. */
		( void ) memcpy( ( void * ) ( &( pxEthernetHeader->xDestinationAddress ) ),
						 ( const void * ) ( &( pxEthernetHeader->xSourceAddress ) ),
 80074f0:	4627      	mov	r7, r4
			pxNetworkBuffer->pxNextBuffer = NULL;
		}
		#endif

		/* Fill in the destination MAC addresses. */
		( void ) memcpy( ( void * ) ( &( pxEthernetHeader->xDestinationAddress ) ),
 80074f2:	f857 3f06 	ldr.w	r3, [r7, #6]!
 80074f6:	6023      	str	r3, [r4, #0]
 80074f8:	88bb      	ldrh	r3, [r7, #4]
 80074fa:	80a3      	strh	r3, [r4, #4]
						 ( const void * ) ( &( pxEthernetHeader->xSourceAddress ) ),
						 sizeof( pxEthernetHeader->xDestinationAddress ) );

		/* The source MAC addresses is fixed to 'ipLOCAL_MAC_ADDRESS'. */
		( void ) memcpy( ( void * ) ( &( pxEthernetHeader->xSourceAddress ) ), ( const void * ) ipLOCAL_MAC_ADDRESS, ( size_t ) ipMAC_ADDRESS_LENGTH_BYTES );
 80074fc:	4b11      	ldr	r3, [pc, #68]	; (8007544 <prvTCPReturnPacket+0x20c>)
 80074fe:	6818      	ldr	r0, [r3, #0]
 8007500:	f8c4 0006 	str.w	r0, [r4, #6]
 8007504:	889b      	ldrh	r3, [r3, #4]
 8007506:	80bb      	strh	r3, [r7, #4]
			}
		}
		#endif

		/* Send! */
		( void ) xNetworkInterfaceOutput( pxNetworkBuffer, xDoRelease );
 8007508:	4628      	mov	r0, r5
 800750a:	4631      	mov	r1, r6
 800750c:	f7fc feaa 	bl	8004264 <xNetworkInterfaceOutput>

		if( xDoRelease == pdFALSE )
 8007510:	b996      	cbnz	r6, 8007538 <prvTCPReturnPacket+0x200>
		{
			/* Swap-back some fields, as pxBuffer probably points to a socket field
			containing the packet header. */
			vFlip_16( pxTCPPacket->xTCPHeader.usSourcePort, pxTCPPacket->xTCPHeader.usDestinationPort);
 8007512:	8c63      	ldrh	r3, [r4, #34]	; 0x22
 8007514:	8ca2      	ldrh	r2, [r4, #36]	; 0x24
 8007516:	8462      	strh	r2, [r4, #34]	; 0x22
 8007518:	84a3      	strh	r3, [r4, #36]	; 0x24
			pxTCPPacket->xIPHeader.ulSourceIPAddress = pxTCPPacket->xIPHeader.ulDestinationIPAddress;
 800751a:	f8d4 301e 	ldr.w	r3, [r4, #30]
 800751e:	f8c4 301a 	str.w	r3, [r4, #26]
			( void ) memcpy( ( void * ) ( pxEthernetHeader->xSourceAddress.ucBytes ), ( const void * ) ( pxEthernetHeader->xDestinationAddress.ucBytes ), ( size_t ) ipMAC_ADDRESS_LENGTH_BYTES );
 8007522:	6823      	ldr	r3, [r4, #0]
 8007524:	f8c4 3006 	str.w	r3, [r4, #6]
 8007528:	88a3      	ldrh	r3, [r4, #4]
 800752a:	80bb      	strh	r3, [r7, #4]
 800752c:	e004      	b.n	8007538 <prvTCPReturnPacket+0x200>
	#ifndef __COVERITY__
	if( pxNetworkBuffer != NULL )
	#endif
	{
		/* Map the ethernet buffer onto a TCPPacket_t struct for easy access to the fields. */
		pxTCPPacket = ipCAST_PTR_TO_TYPE_PTR( TCPPacket_t, pxNetworkBuffer->pucEthernetBuffer );
 800752e:	69ac      	ldr	r4, [r5, #24]
		pxIPHeader = &pxTCPPacket->xIPHeader;
		pxEthernetHeader = &pxTCPPacket->xEthernetHeader;

		/* Fill the packet, using hton translations. */
		if( pxSocket != NULL )
 8007530:	2800      	cmp	r0, #0
 8007532:	f47f af11 	bne.w	8007358 <prvTCPReturnPacket+0x20>
 8007536:	e79b      	b.n	8007470 <prvTCPReturnPacket+0x138>
		else
		{
			/* Nothing to do: the buffer has been passed to DMA and will be released after use */
		}
	} /* if( pxNetworkBuffer != NULL ) */
}
 8007538:	b00a      	add	sp, #40	; 0x28
 800753a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800753e:	bf00      	nop
 8007540:	00040080 	.word	0x00040080
 8007544:	2000d5c0 	.word	0x2000d5c0
 8007548:	2000d3b8 	.word	0x2000d3b8

0800754c <prvTCPSendReset>:
	return prvTCPSendSpecialPacketHelper( pxNetworkBuffer, tcpTCP_FLAG_ACK );
}
/*-----------------------------------------------------------*/

static BaseType_t prvTCPSendReset( NetworkBufferDescriptor_t *pxNetworkBuffer )
{
 800754c:	b508      	push	{r3, lr}
 800754e:	4601      	mov	r1, r0
	( void ) pxNetworkBuffer;
	( void ) ucTCPFlags;
#else
	{
		/* Map the ethernet buffer onto the TCPPacket_t struct for easy access to the fields. */
		TCPPacket_t *pxTCPPacket = ipCAST_PTR_TO_TYPE_PTR( TCPPacket_t, pxNetworkBuffer->pucEthernetBuffer );
 8007550:	6983      	ldr	r3, [r0, #24]
		const uint32_t ulSendLength = ( uint32_t )
			( ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER ); /* Plus 0 options. */

		pxTCPPacket->xTCPHeader.ucTCPFlags = ucTCPFlags;
 8007552:	2214      	movs	r2, #20
 8007554:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f
		pxTCPPacket->xTCPHeader.ucTCPOffset = ( ipSIZE_OF_TCP_HEADER ) << 2;
 8007558:	2250      	movs	r2, #80	; 0x50
 800755a:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e

		prvTCPReturnPacket( NULL, pxNetworkBuffer, ulSendLength, pdFALSE );
 800755e:	2000      	movs	r0, #0
 8007560:	2228      	movs	r2, #40	; 0x28
 8007562:	4603      	mov	r3, r0
 8007564:	f7ff fee8 	bl	8007338 <prvTCPReturnPacket>

static BaseType_t prvTCPSendReset( NetworkBufferDescriptor_t *pxNetworkBuffer )
{
	return prvTCPSendSpecialPacketHelper( pxNetworkBuffer,
										  ( uint8_t ) tcpTCP_FLAG_ACK | ( uint8_t ) tcpTCP_FLAG_RST );
}
 8007568:	2000      	movs	r0, #0
 800756a:	bd08      	pop	{r3, pc}

0800756c <prvTCPCreateWindow>:
 * random starting value, are being synchronised.  The sliding window manager
 * (in FreeRTOS_TCP_WIN.c) needs to know them, along with the Maximum Segment
 * Size (MSS) in use.
 */
static void prvTCPCreateWindow( FreeRTOS_Socket_t *pxSocket )
{
 800756c:	b530      	push	{r4, r5, lr}
 800756e:	b083      	sub	sp, #12
			( unsigned ) pxSocket->u.xTCP.uxEnoughSpace,
			( unsigned ) pxSocket->u.xTCP.uxRxStreamSize ) );
	}
	vTCPWindowCreate(
		&pxSocket->u.xTCP.xTCPWindow,
		( ( size_t ) ipconfigTCP_MSS ) * pxSocket->u.xTCP.uxRxWinSize,
 8007570:	f8d0 10d0 	ldr.w	r1, [r0, #208]	; 0xd0
 8007574:	f44f 6291 	mov.w	r2, #1160	; 0x488
		( ( size_t ) ipconfigTCP_MSS ) * pxSocket->u.xTCP.uxTxWinSize,
 8007578:	f8d0 40d4 	ldr.w	r4, [r0, #212]	; 0xd4
			( unsigned ) pxSocket->u.xTCP.uxRxWinSize * ipconfigTCP_MSS,
			( unsigned ) pxSocket->u.xTCP.uxLittleSpace ,
			( unsigned ) pxSocket->u.xTCP.uxEnoughSpace,
			( unsigned ) pxSocket->u.xTCP.uxRxStreamSize ) );
	}
	vTCPWindowCreate(
 800757c:	f8d0 30e8 	ldr.w	r3, [r0, #232]	; 0xe8
 8007580:	f8d0 5104 	ldr.w	r5, [r0, #260]	; 0x104
 8007584:	9500      	str	r5, [sp, #0]
 8007586:	f8b0 504c 	ldrh.w	r5, [r0, #76]	; 0x4c
 800758a:	9501      	str	r5, [sp, #4]
 800758c:	30d8      	adds	r0, #216	; 0xd8
 800758e:	fb02 f101 	mul.w	r1, r2, r1
 8007592:	fb02 f204 	mul.w	r2, r2, r4
 8007596:	f001 fc39 	bl	8008e0c <vTCPWindowCreate>
		( ( size_t ) ipconfigTCP_MSS ) * pxSocket->u.xTCP.uxRxWinSize,
		( ( size_t ) ipconfigTCP_MSS ) * pxSocket->u.xTCP.uxTxWinSize,
		pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber,
		pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber,
		( uint32_t ) pxSocket->u.xTCP.usInitMSS );
}
 800759a:	b003      	add	sp, #12
 800759c:	bd30      	pop	{r4, r5, pc}
 800759e:	bf00      	nop

080075a0 <prvTCPNextTimeout>:

/*
 * Calculate after how much time this socket needs to be checked again.
 */
static TickType_t prvTCPNextTimeout ( FreeRTOS_Socket_t *pxSocket )
{
 80075a0:	b510      	push	{r4, lr}
 80075a2:	b082      	sub	sp, #8
 80075a4:	4604      	mov	r4, r0
TickType_t ulDelayMs = ( TickType_t ) tcpMAXIMUM_TCP_WAKEUP_TIME_MS;
 80075a6:	f644 6320 	movw	r3, #20000	; 0x4e20
 80075aa:	9301      	str	r3, [sp, #4]

	if( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eCONNECT_SYN )
 80075ac:	f890 3053 	ldrb.w	r3, [r0, #83]	; 0x53
 80075b0:	2b02      	cmp	r3, #2
 80075b2:	d124      	bne.n	80075fe <prvTCPNextTimeout+0x5e>
	{
		/* The socket is actively connecting to a peer. */
		if( pxSocket->u.xTCP.bits.bConnPrepared != pdFALSE_UNSIGNED )
 80075b4:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 80075b8:	f013 0f08 	tst.w	r3, #8
 80075bc:	d013      	beq.n	80075e6 <prvTCPNextTimeout+0x46>
		{
			/* Ethernet address has been found, use progressive timeout for
			active connect(). */
			if( pxSocket->u.xTCP.ucRepCount < 3U )
 80075be:	f890 3052 	ldrb.w	r3, [r0, #82]	; 0x52
 80075c2:	2b02      	cmp	r3, #2
 80075c4:	d80b      	bhi.n	80075de <prvTCPNextTimeout+0x3e>
			{
				ulDelayMs = ( 3000UL << ( pxSocket->u.xTCP.ucRepCount - 1U ) );
 80075c6:	1e5a      	subs	r2, r3, #1
 80075c8:	f640 33b8 	movw	r3, #3000	; 0xbb8
 80075cc:	4093      	lsls	r3, r2
		}

		FreeRTOS_debug_printf( ( "Connect[%lxip:%u]: next timeout %u: %lu ms\n",
			pxSocket->u.xTCP.ulRemoteIP, pxSocket->u.xTCP.usRemotePort,
			pxSocket->u.xTCP.ucRepCount, ulDelayMs ) );
		pxSocket->u.xTCP.usTimeout = ( uint16_t )ipMS_TO_MIN_TICKS( ulDelayMs );
 80075ce:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80075d2:	fb02 f303 	mul.w	r3, r2, r3
 80075d6:	4293      	cmp	r3, r2
 80075d8:	d209      	bcs.n	80075ee <prvTCPNextTimeout+0x4e>
 80075da:	2301      	movs	r3, #1
 80075dc:	e00c      	b.n	80075f8 <prvTCPNextTimeout+0x58>
			{
				ulDelayMs = ( 3000UL << ( pxSocket->u.xTCP.ucRepCount - 1U ) );
			}
			else
			{
				ulDelayMs = 11000UL;
 80075de:	f642 23f8 	movw	r3, #11000	; 0x2af8
 80075e2:	9301      	str	r3, [sp, #4]
 80075e4:	e030      	b.n	8007648 <prvTCPNextTimeout+0xa8>
			}
		}
		else
		{
			/* Still in the ARP phase: check every half second. */
			ulDelayMs = 500UL;
 80075e6:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
 80075ea:	9301      	str	r3, [sp, #4]
 80075ec:	e02c      	b.n	8007648 <prvTCPNextTimeout+0xa8>
		}

		FreeRTOS_debug_printf( ( "Connect[%lxip:%u]: next timeout %u: %lu ms\n",
			pxSocket->u.xTCP.ulRemoteIP, pxSocket->u.xTCP.usRemotePort,
			pxSocket->u.xTCP.ucRepCount, ulDelayMs ) );
		pxSocket->u.xTCP.usTimeout = ( uint16_t )ipMS_TO_MIN_TICKS( ulDelayMs );
 80075ee:	4a1e      	ldr	r2, [pc, #120]	; (8007668 <prvTCPNextTimeout+0xc8>)
 80075f0:	fba2 2303 	umull	r2, r3, r2, r3
 80075f4:	f3c3 138f 	ubfx	r3, r3, #6, #16
 80075f8:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
 80075fc:	e030      	b.n	8007660 <prvTCPNextTimeout+0xc0>
	}
	else if( pxSocket->u.xTCP.usTimeout == 0U )
 80075fe:	f8b0 3048 	ldrh.w	r3, [r0, #72]	; 0x48
 8007602:	bb6b      	cbnz	r3, 8007660 <prvTCPNextTimeout+0xc0>
	{
		/* Let the sliding window mechanism decide what time-out is appropriate. */
		BaseType_t xResult = xTCPWindowTxHasData( &pxSocket->u.xTCP.xTCPWindow, pxSocket->u.xTCP.ulWindowSize, &ulDelayMs );
 8007604:	30d8      	adds	r0, #216	; 0xd8
 8007606:	f8d4 10cc 	ldr.w	r1, [r4, #204]	; 0xcc
 800760a:	aa01      	add	r2, sp, #4
 800760c:	f001 fd6a 	bl	80090e4 <xTCPWindowTxHasData>
		if( ulDelayMs == 0U )
 8007610:	9a01      	ldr	r2, [sp, #4]
 8007612:	b93a      	cbnz	r2, 8007624 <prvTCPNextTimeout+0x84>
		{
			if( xResult != ( BaseType_t )0 )
 8007614:	b110      	cbz	r0, 800761c <prvTCPNextTimeout+0x7c>
			{
				ulDelayMs = 1UL;
 8007616:	2301      	movs	r3, #1
 8007618:	9301      	str	r3, [sp, #4]
 800761a:	e01b      	b.n	8007654 <prvTCPNextTimeout+0xb4>
			}
			else
			{
				ulDelayMs = tcpMAXIMUM_TCP_WAKEUP_TIME_MS;
 800761c:	f644 6320 	movw	r3, #20000	; 0x4e20
 8007620:	9301      	str	r3, [sp, #4]
 8007622:	e017      	b.n	8007654 <prvTCPNextTimeout+0xb4>
		}
		else
		{
			/* ulDelayMs contains the time to wait before a re-transmission. */
		}
		pxSocket->u.xTCP.usTimeout = ( uint16_t ) ipMS_TO_MIN_TICKS( ulDelayMs );
 8007624:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8007628:	fb03 f302 	mul.w	r3, r3, r2
 800762c:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8007630:	bf38      	it	cc
 8007632:	2301      	movcc	r3, #1
 8007634:	d305      	bcc.n	8007642 <prvTCPNextTimeout+0xa2>
 8007636:	4a0c      	ldr	r2, [pc, #48]	; (8007668 <prvTCPNextTimeout+0xc8>)
 8007638:	fba2 2303 	umull	r2, r3, r2, r3
 800763c:	f3c3 138f 	ubfx	r3, r3, #6, #16
 8007640:	e7ff      	b.n	8007642 <prvTCPNextTimeout+0xa2>
 8007642:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
 8007646:	e00b      	b.n	8007660 <prvTCPNextTimeout+0xc0>
		}

		FreeRTOS_debug_printf( ( "Connect[%lxip:%u]: next timeout %u: %lu ms\n",
			pxSocket->u.xTCP.ulRemoteIP, pxSocket->u.xTCP.usRemotePort,
			pxSocket->u.xTCP.ucRepCount, ulDelayMs ) );
		pxSocket->u.xTCP.usTimeout = ( uint16_t )ipMS_TO_MIN_TICKS( ulDelayMs );
 8007648:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800764c:	9a01      	ldr	r2, [sp, #4]
 800764e:	fb03 f302 	mul.w	r3, r3, r2
 8007652:	e7cc      	b.n	80075ee <prvTCPNextTimeout+0x4e>
		}
		else
		{
			/* ulDelayMs contains the time to wait before a re-transmission. */
		}
		pxSocket->u.xTCP.usTimeout = ( uint16_t ) ipMS_TO_MIN_TICKS( ulDelayMs );
 8007654:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8007658:	9a01      	ldr	r2, [sp, #4]
 800765a:	fb03 f302 	mul.w	r3, r3, r2
 800765e:	e7ea      	b.n	8007636 <prvTCPNextTimeout+0x96>
		/* field '.usTimeout' has already been set (by the
		keep-alive/delayed-ACK mechanism). */
	}

	/* Return the number of clock ticks before the timer expires. */
	return ( TickType_t ) pxSocket->u.xTCP.usTimeout;
 8007660:	f8b4 0048 	ldrh.w	r0, [r4, #72]	; 0x48
}
 8007664:	b002      	add	sp, #8
 8007666:	bd10      	pop	{r4, pc}
 8007668:	10624dd3 	.word	0x10624dd3

0800766c <vTCPStateChange>:
 * resetting the alive timer, calling the user's OnConnect handler to notify
 * that a socket has got (dis)connected, and setting bit to unblock a call to
 * FreeRTOS_select()
 */
void vTCPStateChange( FreeRTOS_Socket_t *pxSocket, enum eTCP_STATE eTCPState )
{
 800766c:	b570      	push	{r4, r5, r6, lr}
 800766e:	4604      	mov	r4, r0
 8007670:	460d      	mov	r5, r1
FreeRTOS_Socket_t *xParent = NULL;
BaseType_t bBefore = ipNUMERIC_CAST( BaseType_t, tcpNOW_CONNECTED( ( BaseType_t ) pxSocket->u.xTCP.ucTCPState ) );	/* Was it connected ? */
 8007672:	f890 3053 	ldrb.w	r3, [r0, #83]	; 0x53
 8007676:	2b04      	cmp	r3, #4
 8007678:	d97b      	bls.n	8007772 <vTCPStateChange+0x106>
 800767a:	2b08      	cmp	r3, #8
 800767c:	d17c      	bne.n	8007778 <vTCPStateChange+0x10c>
 800767e:	e078      	b.n	8007772 <vTCPStateChange+0x106>
	{
		/* Is the socket connected now ? */
		if( bAfter != pdFALSE )
		{
			/* if bPassQueued is true, this socket is an orphan until it gets connected. */
			if( pxSocket->u.xTCP.bits.bPassQueued != pdFALSE_UNSIGNED )
 8007680:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8007684:	f013 0f04 	tst.w	r3, #4
 8007688:	d035      	beq.n	80076f6 <vTCPStateChange+0x8a>
			{
				/* Now that it is connected, find it's parent. */
				if( pxSocket->u.xTCP.bits.bReuseSocket != pdFALSE_UNSIGNED )
 800768a:	f013 0f08 	tst.w	r3, #8
 800768e:	d10a      	bne.n	80076a6 <vTCPStateChange+0x3a>
				{
					xParent = pxSocket;
				}
				else
				{
					xParent = pxSocket->u.xTCP.pxPeerSocket;
 8007690:	6d66      	ldr	r6, [r4, #84]	; 0x54
					configASSERT( xParent != NULL );
 8007692:	b956      	cbnz	r6, 80076aa <vTCPStateChange+0x3e>
 8007694:	f04f 0314 	mov.w	r3, #20
 8007698:	f383 8811 	msr	BASEPRI, r3
 800769c:	f3bf 8f6f 	isb	sy
 80076a0:	f3bf 8f4f 	dsb	sy
 80076a4:	e7fe      	b.n	80076a4 <vTCPStateChange+0x38>
				}
				if( xParent != NULL )
 80076a6:	b17c      	cbz	r4, 80076c8 <vTCPStateChange+0x5c>
			if( pxSocket->u.xTCP.bits.bPassQueued != pdFALSE_UNSIGNED )
			{
				/* Now that it is connected, find it's parent. */
				if( pxSocket->u.xTCP.bits.bReuseSocket != pdFALSE_UNSIGNED )
				{
					xParent = pxSocket;
 80076a8:	4626      	mov	r6, r4
					xParent = pxSocket->u.xTCP.pxPeerSocket;
					configASSERT( xParent != NULL );
				}
				if( xParent != NULL )
				{
					if( xParent->u.xTCP.pxPeerSocket == NULL )
 80076aa:	6d73      	ldr	r3, [r6, #84]	; 0x54
 80076ac:	b903      	cbnz	r3, 80076b0 <vTCPStateChange+0x44>
					{
						xParent->u.xTCP.pxPeerSocket = pxSocket;
 80076ae:	6574      	str	r4, [r6, #84]	; 0x54
					}

					xParent->xEventBits |= ( EventBits_t ) eSOCKET_ACCEPT;
 80076b0:	6833      	ldr	r3, [r6, #0]
 80076b2:	f043 0204 	orr.w	r2, r3, #4
 80076b6:	6032      	str	r2, [r6, #0]

					#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
					{
						/* Library support FreeRTOS_select().  Receiving a new
						connection is being translated as a READ event. */
						if( ( xParent->xSelectBits & ( ( EventBits_t ) eSELECT_READ ) ) != 0U )
 80076b8:	6b32      	ldr	r2, [r6, #48]	; 0x30
 80076ba:	f012 0f01 	tst.w	r2, #1
 80076be:	d004      	beq.n	80076ca <vTCPStateChange+0x5e>
						{
							xParent->xEventBits |= ( ( EventBits_t ) eSELECT_READ ) << SOCKET_EVENT_BIT_COUNT;
 80076c0:	f443 7382 	orr.w	r3, r3, #260	; 0x104
 80076c4:	6033      	str	r3, [r6, #0]
 80076c6:	e000      	b.n	80076ca <vTCPStateChange+0x5e>
			if( pxSocket->u.xTCP.bits.bPassQueued != pdFALSE_UNSIGNED )
			{
				/* Now that it is connected, find it's parent. */
				if( pxSocket->u.xTCP.bits.bReuseSocket != pdFALSE_UNSIGNED )
				{
					xParent = pxSocket;
 80076c8:	4626      	mov	r6, r4
					#endif
				}

				/* Don't need to access the parent socket anymore, so the
				reference 'pxPeerSocket' may be cleared. */
				pxSocket->u.xTCP.pxPeerSocket = NULL;
 80076ca:	2300      	movs	r3, #0
 80076cc:	6563      	str	r3, [r4, #84]	; 0x54
				pxSocket->u.xTCP.bits.bPassQueued = pdFALSE_UNSIGNED;
 80076ce:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40

				/* When true, this socket may be returned in a call to accept(). */
				pxSocket->u.xTCP.bits.bPassAccept = pdTRUE_UNSIGNED;
 80076d2:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
 80076d6:	f043 0302 	orr.w	r3, r3, #2
 80076da:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 * Non-active sockets are waiting for user action, either connect()
 * or close(). */
static BaseType_t prvTCPSocketIsActive( eIPTCPState_t xStatus )
{
BaseType_t xResult;
	switch( xStatus )
 80076de:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 80076e2:	2b0b      	cmp	r3, #11
 80076e4:	d82c      	bhi.n	8007740 <vTCPStateChange+0xd4>
 80076e6:	e8df f003 	tbb	[pc, r3]
 80076ea:	2b4e      	.short	0x2b4e
 80076ec:	2b2b2b2b 	.word	0x2b2b2b2b
 80076f0:	4e4e4e2b 	.word	0x4e4e4e2b
 80076f4:	4e2b      	.short	0x4e2b
				/* When true, this socket may be returned in a call to accept(). */
				pxSocket->u.xTCP.bits.bPassAccept = pdTRUE_UNSIGNED;
			}
			else
			{
				pxSocket->xEventBits |= ( EventBits_t ) eSOCKET_CONNECT;
 80076f6:	6823      	ldr	r3, [r4, #0]
 80076f8:	f043 0208 	orr.w	r2, r3, #8
 80076fc:	6022      	str	r2, [r4, #0]

				#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
				{
					if( ( pxSocket->xSelectBits & ( ( EventBits_t ) eSELECT_WRITE ) ) != 0U )
 80076fe:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8007700:	f012 0f02 	tst.w	r2, #2
 8007704:	d074      	beq.n	80077f0 <vTCPStateChange+0x184>
					{
						pxSocket->xEventBits |= ( ( EventBits_t ) eSELECT_WRITE ) << SOCKET_EVENT_BIT_COUNT;
 8007706:	f443 7302 	orr.w	r3, r3, #520	; 0x208
 800770a:	6023      	str	r3, [r4, #0]
 800770c:	e070      	b.n	80077f0 <vTCPStateChange+0x184>
			}
		}
		else  /* bAfter == pdFALSE, connection is closed. */
		{
			/* Notify/wake-up the socket-owner by setting a semaphore. */
			pxSocket->xEventBits |= ( EventBits_t ) eSOCKET_CLOSED;
 800770e:	6823      	ldr	r3, [r4, #0]
 8007710:	f043 0220 	orr.w	r2, r3, #32
 8007714:	6022      	str	r2, [r4, #0]

			#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
			{
				if( ( pxSocket->xSelectBits & ( EventBits_t ) eSELECT_EXCEPT ) != 0U )
 8007716:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8007718:	f012 0f04 	tst.w	r2, #4
 800771c:	d068      	beq.n	80077f0 <vTCPStateChange+0x184>
				{
					pxSocket->xEventBits |= ( ( EventBits_t ) eSELECT_EXCEPT ) << SOCKET_EVENT_BIT_COUNT;
 800771e:	f443 6384 	orr.w	r3, r3, #1056	; 0x420
 8007722:	6023      	str	r3, [r4, #0]
 8007724:	e064      	b.n	80077f0 <vTCPStateChange+0x184>
			pxSocket->u.xTCP.usTimeout = 0U;
		}
	}
	else
	{
		if( ( ( BaseType_t ) eTCPState ) ==  ( ( BaseType_t ) eCLOSED ) )
 8007726:	bb95      	cbnz	r5, 800778e <vTCPStateChange+0x122>
		{
			/* Socket goes to status eCLOSED because of a RST.
			When nobody owns the socket yet, delete it. */
			if( ( pxSocket->u.xTCP.bits.bPassQueued != pdFALSE_UNSIGNED ) ||
 8007728:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 800772c:	f013 0f06 	tst.w	r3, #6
 8007730:	d02d      	beq.n	800778e <vTCPStateChange+0x122>
				( pxSocket->u.xTCP.bits.bPassAccept != pdFALSE_UNSIGNED ) )
			{
				FreeRTOS_debug_printf( ( "vTCPStateChange: Closing socket\n" ) );
				if( pxSocket->u.xTCP.bits.bReuseSocket == pdFALSE_UNSIGNED )
 8007732:	f013 0f08 	tst.w	r3, #8
 8007736:	d12a      	bne.n	800778e <vTCPStateChange+0x122>
				{
					( void ) FreeRTOS_closesocket( pxSocket );
 8007738:	4620      	mov	r0, r4
 800773a:	f7fe fd81 	bl	8006240 <FreeRTOS_closesocket>
 800773e:	e026      	b.n	800778e <vTCPStateChange+0x122>
			}
		}
	}

	/* Fill in the new state. */
	pxSocket->u.xTCP.ucTCPState = ( uint8_t ) eTCPState;
 8007740:	f884 5053 	strb.w	r5, [r4, #83]	; 0x53
 */
static void prvTCPTouchSocket( FreeRTOS_Socket_t *pxSocket )
{
	#if( ipconfigTCP_HANG_PROTECTION == 1 )
	{
		pxSocket->u.xTCP.xLastActTime = xTaskGetTickCount( );
 8007744:	f7fb fd3a 	bl	80031bc <xTaskGetTickCount>
 8007748:	6620      	str	r0, [r4, #96]	; 0x60
	}
	#endif

	#if( ipconfigTCP_KEEP_ALIVE == 1 )
	{
		pxSocket->u.xTCP.bits.bWaitKeepAlive = pdFALSE_UNSIGNED;
 800774a:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
		pxSocket->u.xTCP.bits.bSendKeepAlive = pdFALSE_UNSIGNED;
 800774e:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
 8007752:	f36f 0341 	bfc	r3, #1, #1
 8007756:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
		pxSocket->u.xTCP.ucKeepRepCount = 0U;
 800775a:	2300      	movs	r3, #0
 800775c:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
		pxSocket->u.xTCP.xLastAliveTime = xTaskGetTickCount();
 8007760:	f7fb fd2c 	bl	80031bc <xTaskGetTickCount>
 8007764:	65e0      	str	r0, [r4, #92]	; 0x5c
			/* The 'connected' state has changed, call the OnConnect handler of the parent. */
			xConnected->u.xTCP.pxHandleConnected( ( Socket_t ) xConnected, bAfter );
		}
	}
	#endif
	if( xParent != NULL )
 8007766:	2e00      	cmp	r6, #0
 8007768:	d062      	beq.n	8007830 <vTCPStateChange+0x1c4>
	{
		vSocketWakeUpUser( xParent );
 800776a:	4630      	mov	r0, r6
 800776c:	f7fe fed0 	bl	8006510 <vSocketWakeUpUser>
 8007770:	bd70      	pop	{r4, r5, r6, pc}
 */
void vTCPStateChange( FreeRTOS_Socket_t *pxSocket, enum eTCP_STATE eTCPState )
{
FreeRTOS_Socket_t *xParent = NULL;
BaseType_t bBefore = ipNUMERIC_CAST( BaseType_t, tcpNOW_CONNECTED( ( BaseType_t ) pxSocket->u.xTCP.ucTCPState ) );	/* Was it connected ? */
BaseType_t bAfter  = ipNUMERIC_CAST( BaseType_t, tcpNOW_CONNECTED( ( BaseType_t ) eTCPState ) );					/* Is it connected now ? */
 8007772:	2d04      	cmp	r5, #4
 8007774:	d81f      	bhi.n	80077b6 <vTCPStateChange+0x14a>
 8007776:	e7d6      	b.n	8007726 <vTCPStateChange+0xba>
 8007778:	2904      	cmp	r1, #4
 800777a:	d821      	bhi.n	80077c0 <vTCPStateChange+0x154>
 800777c:	e7c7      	b.n	800770e <vTCPStateChange+0xa2>
#if( ipconfigUSE_CALLBACKS == 1 )
	FreeRTOS_Socket_t *xConnected = NULL;
#endif

	/* Has the connected status changed? */
	if( bBefore != bAfter )
 800777e:	2b00      	cmp	r3, #0
 8007780:	d1c5      	bne.n	800770e <vTCPStateChange+0xa2>
 8007782:	e004      	b.n	800778e <vTCPStateChange+0x122>
 * Non-active sockets are waiting for user action, either connect()
 * or close(). */
static BaseType_t prvTCPSocketIsActive( eIPTCPState_t xStatus )
{
BaseType_t xResult;
	switch( xStatus )
 8007784:	2600      	movs	r6, #0
		{
			/* Now the socket isn't in an active state anymore so it
			won't need further attention of the IP-task.
			Setting time-out to zero means that the socket won't get checked during
			timer events. */
			pxSocket->u.xTCP.usTimeout = 0U;
 8007786:	2300      	movs	r3, #0
 8007788:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
 800778c:	e7d8      	b.n	8007740 <vTCPStateChange+0xd4>
			}
		}
	}

	/* Fill in the new state. */
	pxSocket->u.xTCP.ucTCPState = ( uint8_t ) eTCPState;
 800778e:	f884 5053 	strb.w	r5, [r4, #83]	; 0x53
 */
static void prvTCPTouchSocket( FreeRTOS_Socket_t *pxSocket )
{
	#if( ipconfigTCP_HANG_PROTECTION == 1 )
	{
		pxSocket->u.xTCP.xLastActTime = xTaskGetTickCount( );
 8007792:	f7fb fd13 	bl	80031bc <xTaskGetTickCount>
 8007796:	6620      	str	r0, [r4, #96]	; 0x60
	}
	#endif

	#if( ipconfigTCP_KEEP_ALIVE == 1 )
	{
		pxSocket->u.xTCP.bits.bWaitKeepAlive = pdFALSE_UNSIGNED;
 8007798:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
		pxSocket->u.xTCP.bits.bSendKeepAlive = pdFALSE_UNSIGNED;
 800779c:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
 80077a0:	f36f 0341 	bfc	r3, #1, #1
 80077a4:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
		pxSocket->u.xTCP.ucKeepRepCount = 0U;
 80077a8:	2300      	movs	r3, #0
 80077aa:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
		pxSocket->u.xTCP.xLastAliveTime = xTaskGetTickCount();
 80077ae:	f7fb fd05 	bl	80031bc <xTaskGetTickCount>
 80077b2:	65e0      	str	r0, [r4, #92]	; 0x5c
 80077b4:	bd70      	pop	{r4, r5, r6, pc}
 */
void vTCPStateChange( FreeRTOS_Socket_t *pxSocket, enum eTCP_STATE eTCPState )
{
FreeRTOS_Socket_t *xParent = NULL;
BaseType_t bBefore = ipNUMERIC_CAST( BaseType_t, tcpNOW_CONNECTED( ( BaseType_t ) pxSocket->u.xTCP.ucTCPState ) );	/* Was it connected ? */
BaseType_t bAfter  = ipNUMERIC_CAST( BaseType_t, tcpNOW_CONNECTED( ( BaseType_t ) eTCPState ) );					/* Is it connected now ? */
 80077b6:	2d08      	cmp	r5, #8
 80077b8:	f47f af62 	bne.w	8007680 <vTCPStateChange+0x14>
 80077bc:	2300      	movs	r3, #0
 80077be:	e7de      	b.n	800777e <vTCPStateChange+0x112>
 80077c0:	2908      	cmp	r1, #8
 80077c2:	d1b0      	bne.n	8007726 <vTCPStateChange+0xba>
 * FreeRTOS_select()
 */
void vTCPStateChange( FreeRTOS_Socket_t *pxSocket, enum eTCP_STATE eTCPState )
{
FreeRTOS_Socket_t *xParent = NULL;
BaseType_t bBefore = ipNUMERIC_CAST( BaseType_t, tcpNOW_CONNECTED( ( BaseType_t ) pxSocket->u.xTCP.ucTCPState ) );	/* Was it connected ? */
 80077c4:	2301      	movs	r3, #1
 80077c6:	e7da      	b.n	800777e <vTCPStateChange+0x112>
			}
		}
	}

	/* Fill in the new state. */
	pxSocket->u.xTCP.ucTCPState = ( uint8_t ) eTCPState;
 80077c8:	f884 5053 	strb.w	r5, [r4, #83]	; 0x53
 */
static void prvTCPTouchSocket( FreeRTOS_Socket_t *pxSocket )
{
	#if( ipconfigTCP_HANG_PROTECTION == 1 )
	{
		pxSocket->u.xTCP.xLastActTime = xTaskGetTickCount( );
 80077cc:	f7fb fcf6 	bl	80031bc <xTaskGetTickCount>
 80077d0:	6620      	str	r0, [r4, #96]	; 0x60
	}
	#endif

	#if( ipconfigTCP_KEEP_ALIVE == 1 )
	{
		pxSocket->u.xTCP.bits.bWaitKeepAlive = pdFALSE_UNSIGNED;
 80077d2:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
		pxSocket->u.xTCP.bits.bSendKeepAlive = pdFALSE_UNSIGNED;
 80077d6:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
 80077da:	f36f 0341 	bfc	r3, #1, #1
 80077de:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
		pxSocket->u.xTCP.ucKeepRepCount = 0U;
 80077e2:	2300      	movs	r3, #0
 80077e4:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
		pxSocket->u.xTCP.xLastAliveTime = xTaskGetTickCount();
 80077e8:	f7fb fce8 	bl	80031bc <xTaskGetTickCount>
 80077ec:	65e0      	str	r0, [r4, #92]	; 0x5c
 80077ee:	bd70      	pop	{r4, r5, r6, pc}
 * Non-active sockets are waiting for user action, either connect()
 * or close(). */
static BaseType_t prvTCPSocketIsActive( eIPTCPState_t xStatus )
{
BaseType_t xResult;
	switch( xStatus )
 80077f0:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 80077f4:	2b0b      	cmp	r3, #11
 80077f6:	d8e7      	bhi.n	80077c8 <vTCPStateChange+0x15c>
 80077f8:	a201      	add	r2, pc, #4	; (adr r2, 8007800 <vTCPStateChange+0x194>)
 80077fa:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80077fe:	bf00      	nop
 8007800:	08007785 	.word	0x08007785
 8007804:	080077c9 	.word	0x080077c9
 8007808:	080077c9 	.word	0x080077c9
 800780c:	080077c9 	.word	0x080077c9
 8007810:	080077c9 	.word	0x080077c9
 8007814:	080077c9 	.word	0x080077c9
 8007818:	080077c9 	.word	0x080077c9
 800781c:	08007785 	.word	0x08007785
 8007820:	08007785 	.word	0x08007785
 8007824:	08007785 	.word	0x08007785
 8007828:	080077c9 	.word	0x080077c9
 800782c:	08007785 	.word	0x08007785
 8007830:	bd70      	pop	{r4, r5, r6, pc}
 8007832:	bf00      	nop

08007834 <prvTCPPrepareSend>:

/*
 * Prepare an outgoing message, in case anything has to be sent.
 */
static int32_t prvTCPPrepareSend( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **ppxNetworkBuffer, UBaseType_t uxOptionsLength )
{
 8007834:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007838:	b087      	sub	sp, #28
 800783a:	4604      	mov	r4, r0
 800783c:	468b      	mov	fp, r1
 800783e:	4690      	mov	r8, r2
TCPWindow_t *pxTCPWindow;
NetworkBufferDescriptor_t *pxNewBuffer;
int32_t lStreamPos;
UBaseType_t uxIntermediateResult = 0;

	if( ( *ppxNetworkBuffer ) != NULL )
 8007840:	680b      	ldr	r3, [r1, #0]
 8007842:	b10b      	cbz	r3, 8007848 <prvTCPPrepareSend+0x14>
	{
		/* A network buffer descriptor was already supplied */
		pucEthernetBuffer = ( *ppxNetworkBuffer )->pucEthernetBuffer;
 8007844:	699e      	ldr	r6, [r3, #24]
 8007846:	e001      	b.n	800784c <prvTCPPrepareSend+0x18>
	}
	else
	{
		/* For now let it point to the last packet header */
		pucEthernetBuffer = pxSocket->u.xTCP.xPacket.u.ucLastPacket;
 8007848:	f100 0682 	add.w	r6, r0, #130	; 0x82
	}

	/* Map the ethernet buffer onto the ProtocolHeader_t struct for easy access to the fields. */
	pxProtocolHeaders = ipCAST_PTR_TO_TYPE_PTR( ProtocolHeaders_t, &( pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + uxIPHeaderSizeSocket( pxSocket ) ] ) );
 800784c:	f106 0522 	add.w	r5, r6, #34	; 0x22
	pxTCPWindow = &( pxSocket->u.xTCP.xTCPWindow );
 8007850:	f104 03d8 	add.w	r3, r4, #216	; 0xd8
 8007854:	4618      	mov	r0, r3
 8007856:	9303      	str	r3, [sp, #12]
	lDataLen = 0;
	lStreamPos = 0;
 8007858:	2300      	movs	r3, #0
 800785a:	9305      	str	r3, [sp, #20]
	pxProtocolHeaders->xTCPHeader.ucTCPFlags |= tcpTCP_FLAG_ACK;
 800785c:	f896 302f 	ldrb.w	r3, [r6, #47]	; 0x2f
 8007860:	f043 0310 	orr.w	r3, r3, #16
 8007864:	f886 302f 	strb.w	r3, [r6, #47]	; 0x2f

	if( pxSocket->u.xTCP.txStream != NULL )
 8007868:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 800786a:	2b00      	cmp	r3, #0
 800786c:	f000 80df 	beq.w	8007a2e <prvTCPPrepareSend+0x1fa>
	{
		/* ulTCPWindowTxGet will return the amount of data which may be sent
		along with the position in the txStream.
		Why check for MSS > 1 ?
		Because some TCP-stacks (like uIP) use it for flow-control. */
		if( pxSocket->u.xTCP.usCurMSS > 1U )
 8007870:	f8b4 304a 	ldrh.w	r3, [r4, #74]	; 0x4a
 8007874:	2b01      	cmp	r3, #1
 8007876:	d944      	bls.n	8007902 <prvTCPPrepareSend+0xce>
		{
			lDataLen = ( int32_t ) ulTCPWindowTxGet( pxTCPWindow, pxSocket->u.xTCP.ulWindowSize, &lStreamPos );
 8007878:	f8d4 10cc 	ldr.w	r1, [r4, #204]	; 0xcc
 800787c:	aa05      	add	r2, sp, #20
 800787e:	f001 fc6b 	bl	8009158 <ulTCPWindowTxGet>
 8007882:	4682      	mov	sl, r0
 8007884:	4607      	mov	r7, r0
		}

		if( lDataLen > 0 )
 8007886:	2800      	cmp	r0, #0
 8007888:	f340 80d3 	ble.w	8007a32 <prvTCPPrepareSend+0x1fe>
		{
			/* Check if the current network buffer is big enough, if not,
			resize it. */
			pxNewBuffer = prvTCPBufferResize( pxSocket, *ppxNetworkBuffer, lDataLen, uxOptionsLength );
 800788c:	f8db 6000 	ldr.w	r6, [fp]
{
NetworkBufferDescriptor_t *pxReturn;
size_t uxNeeded;
BaseType_t xResize;

	if( xBufferAllocFixedSize != pdFALSE )
 8007890:	4b9a      	ldr	r3, [pc, #616]	; (8007afc <prvTCPPrepareSend+0x2c8>)
 8007892:	681b      	ldr	r3, [r3, #0]
 8007894:	b10b      	cbz	r3, 800789a <prvTCPPrepareSend+0x66>
		{
			xResize = pdFALSE;
		}
	}

	if( xResize != pdFALSE )
 8007896:	b97e      	cbnz	r6, 80078b8 <prvTCPPrepareSend+0x84>
 8007898:	e0fd      	b.n	8007a96 <prvTCPPrepareSend+0x262>
 800789a:	f108 0936 	add.w	r9, r8, #54	; 0x36
	}
	else
	{
		/* Network buffers are created with a variable size. See if it must
		grow. */
		uxNeeded = ipNUMERIC_CAST( size_t, ipSIZE_OF_ETH_HEADER + uxIPHeaderSizeSocket( pxSocket ) + ipSIZE_OF_TCP_HEADER + uxOptionsLength ) + lDataLen;
 800789e:	4481      	add	r9, r0

		if( uxNeeded < sizeof( pxSocket->u.xTCP.xPacket.u.ucLastPacket ) )
		{
			uxNeeded = sizeof( pxSocket->u.xTCP.xPacket.u.ucLastPacket );
 80078a0:	f1b9 0f45 	cmp.w	r9, #69	; 0x45
 80078a4:	bf98      	it	ls
 80078a6:	f04f 0946 	movls.w	r9, #70	; 0x46
		}

		/* In case we were called from a TCP timer event, a buffer must be
		created.  Otherwise, test 'xDataLength' of the provided buffer. */
		if( ( pxNetworkBuffer == NULL ) || ( pxNetworkBuffer->xDataLength < uxNeeded ) )
 80078aa:	2e00      	cmp	r6, #0
 80078ac:	f000 80f5 	beq.w	8007a9a <prvTCPPrepareSend+0x266>
		{
			xResize = pdFALSE;
		}
	}

	if( xResize != pdFALSE )
 80078b0:	69f3      	ldr	r3, [r6, #28]
 80078b2:	454b      	cmp	r3, r9
 80078b4:	f0c0 80de 	bcc.w	8007a74 <prvTCPPrepareSend+0x240>
 80078b8:	f108 0336 	add.w	r3, r8, #54	; 0x36
		configASSERT( pxNetworkBuffer != NULL );	/* to tell lint: when xResize is false, pxNetworkBuffer is not NULL. */
		pxReturn = pxNetworkBuffer;

		/* Thanks to Andrey Ivanov from swissEmbedded for reporting that the
		xDataLength member must get the correct length too! */
		pxNetworkBuffer->xDataLength = ( size_t ) ( ipSIZE_OF_ETH_HEADER + uxIPHeaderSizeSocket( pxSocket ) + ipSIZE_OF_TCP_HEADER + uxOptionsLength ) + ( size_t ) lDataLen;
 80078bc:	4453      	add	r3, sl
 80078be:	61f3      	str	r3, [r6, #28]
 80078c0:	e091      	b.n	80079e6 <prvTCPPrepareSend+0x1b2>

				/* If the owner of the socket requests a closure, add the FIN
				flag to the last packet. */
				if( ( pxSocket->u.xTCP.bits.bCloseRequested != pdFALSE_UNSIGNED ) && ( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED ) )
				{
					ulDistance = ( uint32_t ) uxStreamBufferDistance( pxSocket->u.xTCP.txStream, ( size_t ) lStreamPos, pxSocket->u.xTCP.txStream->uxHead );
 80078c2:	6fa2      	ldr	r2, [r4, #120]	; 0x78
 80078c4:	6893      	ldr	r3, [r2, #8]
static portINLINE size_t uxStreamBufferDistance( const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper )
{
/* Returns the distance between uxLower and uxUpper */
size_t uxCount;

	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
 80078c6:	6912      	ldr	r2, [r2, #16]
 80078c8:	4413      	add	r3, r2
 80078ca:	9905      	ldr	r1, [sp, #20]
 80078cc:	1a5b      	subs	r3, r3, r1
	if ( uxCount >= pxBuffer->LENGTH )
 80078ce:	429a      	cmp	r2, r3
	{
		uxCount -= pxBuffer->LENGTH;
 80078d0:	bf98      	it	ls
 80078d2:	1a9b      	subls	r3, r3, r2

					if( ulDistance == ulDataGot )
 80078d4:	4298      	cmp	r0, r3
 80078d6:	d115      	bne.n	8007904 <prvTCPPrepareSend+0xd0>
						}
						#endif
						/* Although the socket sends a FIN, it will stay in
						ESTABLISHED until all current data has been received or
						delivered. */
						pxProtocolHeaders->xTCPHeader.ucTCPFlags |= tcpTCP_FLAG_FIN;
 80078d8:	f896 302f 	ldrb.w	r3, [r6, #47]	; 0x2f
 80078dc:	f043 0301 	orr.w	r3, r3, #1
 80078e0:	f886 302f 	strb.w	r3, [r6, #47]	; 0x2f
						pxTCPWindow->tx.ulFINSequenceNumber = pxTCPWindow->ulOurSequenceNumber + ( uint32_t ) lDataLen;
 80078e4:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
 80078e8:	4453      	add	r3, sl
 80078ea:	f8c4 30fc 	str.w	r3, [r4, #252]	; 0xfc
						pxSocket->u.xTCP.bits.bFinSent = pdTRUE_UNSIGNED;
 80078ee:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 80078f2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80078f6:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
 80078fa:	e003      	b.n	8007904 <prvTCPPrepareSend+0xd0>
 80078fc:	f04f 37ff 	mov.w	r7, #4294967295
 8007900:	e057      	b.n	80079b2 <prvTCPPrepareSend+0x17e>
	}

	/* Map the ethernet buffer onto the ProtocolHeader_t struct for easy access to the fields. */
	pxProtocolHeaders = ipCAST_PTR_TO_TYPE_PTR( ProtocolHeaders_t, &( pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + uxIPHeaderSizeSocket( pxSocket ) ] ) );
	pxTCPWindow = &( pxSocket->u.xTCP.xTCPWindow );
	lDataLen = 0;
 8007902:	2700      	movs	r7, #0
				lDataLen = -1;
			}
		}
	}

	if( ( lDataLen >= 0 ) && ( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eESTABLISHED ) )
 8007904:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 8007908:	2b05      	cmp	r3, #5
 800790a:	d152      	bne.n	80079b2 <prvTCPPrepareSend+0x17e>
	{
		/* See if the socket owner wants to shutdown this connection. */
		if( ( pxSocket->u.xTCP.bits.bUserShutdown != pdFALSE_UNSIGNED ) &&
 800790c:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8007910:	f013 0f20 	tst.w	r3, #32
 8007914:	d01b      	beq.n	800794e <prvTCPPrepareSend+0x11a>
			( xTCPWindowTxDone( pxTCPWindow ) != pdFALSE ) )
 8007916:	9803      	ldr	r0, [sp, #12]
 8007918:	f001 fbde 	bl	80090d8 <xTCPWindowTxDone>
	}

	if( ( lDataLen >= 0 ) && ( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eESTABLISHED ) )
	{
		/* See if the socket owner wants to shutdown this connection. */
		if( ( pxSocket->u.xTCP.bits.bUserShutdown != pdFALSE_UNSIGNED ) &&
 800791c:	b1b8      	cbz	r0, 800794e <prvTCPPrepareSend+0x11a>
			( xTCPWindowTxDone( pxTCPWindow ) != pdFALSE ) )
		{
			pxSocket->u.xTCP.bits.bUserShutdown = pdFALSE_UNSIGNED;
 800791e:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8007922:	f36f 1345 	bfc	r3, #5, #1
 8007926:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
			pxProtocolHeaders->xTCPHeader.ucTCPFlags |= tcpTCP_FLAG_FIN;
 800792a:	7b6b      	ldrb	r3, [r5, #13]
 800792c:	f043 0301 	orr.w	r3, r3, #1
 8007930:	736b      	strb	r3, [r5, #13]
			pxSocket->u.xTCP.bits.bFinSent = pdTRUE_UNSIGNED;
 8007932:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
			pxSocket->u.xTCP.bits.bWinChange = pdTRUE_UNSIGNED;
 8007936:	f043 0341 	orr.w	r3, r3, #65	; 0x41
 800793a:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
			pxTCPWindow->tx.ulFINSequenceNumber = pxTCPWindow->tx.ulCurrentSequenceNumber;
 800793e:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
 8007942:	f8c4 30fc 	str.w	r3, [r4, #252]	; 0xfc
			vTCPStateChange( pxSocket, eFIN_WAIT_1 );
 8007946:	4620      	mov	r0, r4
 8007948:	2106      	movs	r1, #6
 800794a:	f7ff fe8f 	bl	800766c <vTCPStateChange>
		}

		#if( ipconfigTCP_KEEP_ALIVE != 0 )
		{
			if( pxSocket->u.xTCP.ucKeepRepCount > 3U ) /*_RB_ Magic number. */
 800794e:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
 8007952:	2b03      	cmp	r3, #3
 8007954:	d906      	bls.n	8007964 <prvTCPPrepareSend+0x130>
			{
				FreeRTOS_debug_printf( ( "keep-alive: giving up %lxip:%u\n",
					pxSocket->u.xTCP.ulRemoteIP,			/* IP address of remote machine. */
					pxSocket->u.xTCP.usRemotePort ) );	/* Port on remote machine. */
				vTCPStateChange( pxSocket, eCLOSE_WAIT );
 8007956:	4620      	mov	r0, r4
 8007958:	2108      	movs	r1, #8
 800795a:	f7ff fe87 	bl	800766c <vTCPStateChange>
				lDataLen = -1;
 800795e:	f04f 37ff 	mov.w	r7, #4294967295
 8007962:	e028      	b.n	80079b6 <prvTCPPrepareSend+0x182>
			}
			if( ( lDataLen == 0 ) && ( pxSocket->u.xTCP.bits.bWinChange == pdFALSE_UNSIGNED ) )
 8007964:	bb2f      	cbnz	r7, 80079b2 <prvTCPPrepareSend+0x17e>
 8007966:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 800796a:	f013 0f01 	tst.w	r3, #1
 800796e:	d163      	bne.n	8007a38 <prvTCPPrepareSend+0x204>
			{
				/* If there is no data to be sent, and no window-update message,
				we might want to send a keep-alive message. */
				TickType_t xAge = xTaskGetTickCount( ) - pxSocket->u.xTCP.xLastAliveTime;
 8007970:	f7fb fc24 	bl	80031bc <xTaskGetTickCount>
 8007974:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8007976:	1ac3      	subs	r3, r0, r3
				TickType_t xMax;
				xMax = ( ( TickType_t ) ipconfigTCP_KEEP_ALIVE_INTERVAL * ( TickType_t ) configTICK_RATE_HZ );
				if( pxSocket->u.xTCP.ucKeepRepCount != ( uint8_t ) 0U )
 8007978:	f894 0058 	ldrb.w	r0, [r4, #88]	; 0x58
				{
					xMax = ( TickType_t ) ( 3U * configTICK_RATE_HZ );
 800797c:	f640 32b8 	movw	r2, #3000	; 0xbb8
 8007980:	495f      	ldr	r1, [pc, #380]	; (8007b00 <prvTCPPrepareSend+0x2cc>)
 8007982:	2800      	cmp	r0, #0
 8007984:	bf08      	it	eq
 8007986:	460a      	moveq	r2, r1
				}
				if( xAge > xMax )
 8007988:	429a      	cmp	r2, r3
 800798a:	d255      	bcs.n	8007a38 <prvTCPPrepareSend+0x204>
				{
					pxSocket->u.xTCP.xLastAliveTime = xTaskGetTickCount( );
 800798c:	f7fb fc16 	bl	80031bc <xTaskGetTickCount>
 8007990:	65e0      	str	r0, [r4, #92]	; 0x5c
						FreeRTOS_debug_printf( ( "keep-alive: %lxip:%u count %u\n",
							pxSocket->u.xTCP.ulRemoteIP,
							pxSocket->u.xTCP.usRemotePort,
							pxSocket->u.xTCP.ucKeepRepCount ) );
					}
					pxSocket->u.xTCP.bits.bSendKeepAlive = pdTRUE_UNSIGNED;
 8007992:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8007996:	f043 0302 	orr.w	r3, r3, #2
 800799a:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
					pxSocket->u.xTCP.usTimeout = ( ( uint16_t ) pdMS_TO_TICKS( 2500U ) );
 800799e:	f640 13c4 	movw	r3, #2500	; 0x9c4
 80079a2:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
					pxSocket->u.xTCP.ucKeepRepCount++;
 80079a6:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
 80079aa:	3301      	adds	r3, #1
 80079ac:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
 80079b0:	e042      	b.n	8007a38 <prvTCPPrepareSend+0x204>
		#endif /* ipconfigTCP_KEEP_ALIVE */
	}

	/* Anything to send, a change of the advertised window size, or maybe send a
	keep-alive message? */
	if( ( lDataLen > 0 ) ||
 80079b2:	2f00      	cmp	r7, #0
 80079b4:	dc46      	bgt.n	8007a44 <prvTCPPrepareSend+0x210>
		( pxSocket->u.xTCP.bits.bWinChange != pdFALSE_UNSIGNED ) ||
 80079b6:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 80079ba:	f013 0f03 	tst.w	r3, #3
 80079be:	f000 8098 	beq.w	8007af2 <prvTCPPrepareSend+0x2be>
		( pxSocket->u.xTCP.bits.bSendKeepAlive != pdFALSE_UNSIGNED ) )
	{
		pxProtocolHeaders->xTCPHeader.ucTCPFlags &= ( ( uint8_t ) ~tcpTCP_FLAG_PSH );
 80079c2:	7b6b      	ldrb	r3, [r5, #13]
 80079c4:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		pxProtocolHeaders->xTCPHeader.ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 ); /*_RB_ "2" needs comment. */
 80079c8:	f108 0214 	add.w	r2, r8, #20
 80079cc:	0092      	lsls	r2, r2, #2
 80079ce:	732a      	strb	r2, [r5, #12]

		pxProtocolHeaders->xTCPHeader.ucTCPFlags |= ( uint8_t ) tcpTCP_FLAG_ACK;
 80079d0:	f043 0210 	orr.w	r2, r3, #16
 80079d4:	736a      	strb	r2, [r5, #13]

		if( lDataLen != 0L )
 80079d6:	b117      	cbz	r7, 80079de <prvTCPPrepareSend+0x1aa>
		{
			pxProtocolHeaders->xTCPHeader.ucTCPFlags |= ( uint8_t ) tcpTCP_FLAG_PSH;
 80079d8:	f043 0318 	orr.w	r3, r3, #24
 80079dc:	736b      	strb	r3, [r5, #13]
		}

		uxIntermediateResult = uxIPHeaderSizeSocket( pxSocket ) + ipSIZE_OF_TCP_HEADER + uxOptionsLength;
 80079de:	f108 0828 	add.w	r8, r8, #40	; 0x28
		lDataLen += ( int32_t ) uxIntermediateResult;
 80079e2:	4447      	add	r7, r8
 80079e4:	e085      	b.n	8007af2 <prvTCPPrepareSend+0x2be>
			resize it. */
			pxNewBuffer = prvTCPBufferResize( pxSocket, *ppxNetworkBuffer, lDataLen, uxOptionsLength );

			if( pxNewBuffer != NULL )
			{
				*ppxNetworkBuffer = pxNewBuffer;
 80079e6:	f8cb 6000 	str.w	r6, [fp]
				pucEthernetBuffer = pxNewBuffer->pucEthernetBuffer;
 80079ea:	69b6      	ldr	r6, [r6, #24]

				/* Map the byte stream onto ProtocolHeaders_t struct for easy
				 * access to the fields. */
				pxProtocolHeaders = ipCAST_PTR_TO_TYPE_PTR( ProtocolHeaders_t, &( pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + uxIPHeaderSizeSocket( pxSocket ) ] ) );
 80079ec:	f106 0522 	add.w	r5, r6, #34	; 0x22

				pucSendData = &( pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + uxIPHeaderSizeSocket( pxSocket ) + ipSIZE_OF_TCP_HEADER + uxOptionsLength ] );
 80079f0:	f108 0e36 	add.w	lr, r8, #54	; 0x36

				/* Translate the position in txStream to an offset from the tail
				marker. */
				uxOffset = uxStreamBufferDistance( pxSocket->u.xTCP.txStream, pxSocket->u.xTCP.txStream->uxTail, ( size_t ) lStreamPos );
 80079f4:	6fa0      	ldr	r0, [r4, #120]	; 0x78
 80079f6:	6801      	ldr	r1, [r0, #0]
static portINLINE size_t uxStreamBufferDistance( const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper )
{
/* Returns the distance between uxLower and uxUpper */
size_t uxCount;

	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
 80079f8:	6902      	ldr	r2, [r0, #16]
 80079fa:	9b05      	ldr	r3, [sp, #20]
 80079fc:	1a5b      	subs	r3, r3, r1
 80079fe:	189a      	adds	r2, r3, r2

				/* Here data is copied from the txStream in 'peek' mode.  Only
				when the packets are acked, the tail marker will be updated. */
				ulDataGot = ( uint32_t ) uxStreamBufferGet( pxSocket->u.xTCP.txStream, uxOffset, pucSendData, ( size_t ) lDataLen, pdTRUE );
 8007a00:	f04f 0101 	mov.w	r1, #1
 8007a04:	9100      	str	r1, [sp, #0]
 8007a06:	bf34      	ite	cc
 8007a08:	4619      	movcc	r1, r3
 8007a0a:	4611      	movcs	r1, r2
 8007a0c:	4672      	mov	r2, lr
 8007a0e:	4432      	add	r2, r6
 8007a10:	4653      	mov	r3, sl
 8007a12:	f7ff fc29 	bl	8007268 <uxStreamBufferGet>
				}
				#endif

				/* If the owner of the socket requests a closure, add the FIN
				flag to the last packet. */
				if( ( pxSocket->u.xTCP.bits.bCloseRequested != pdFALSE_UNSIGNED ) && ( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED ) )
 8007a16:	f8b4 3040 	ldrh.w	r3, [r4, #64]	; 0x40
 8007a1a:	f423 537e 	bic.w	r3, r3, #16256	; 0x3f80
 8007a1e:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8007a22:	045b      	lsls	r3, r3, #17
 8007a24:	0c5b      	lsrs	r3, r3, #17
 8007a26:	2b40      	cmp	r3, #64	; 0x40
 8007a28:	f47f af6c 	bne.w	8007904 <prvTCPPrepareSend+0xd0>
 8007a2c:	e749      	b.n	80078c2 <prvTCPPrepareSend+0x8e>
	}

	/* Map the ethernet buffer onto the ProtocolHeader_t struct for easy access to the fields. */
	pxProtocolHeaders = ipCAST_PTR_TO_TYPE_PTR( ProtocolHeaders_t, &( pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + uxIPHeaderSizeSocket( pxSocket ) ] ) );
	pxTCPWindow = &( pxSocket->u.xTCP.xTCPWindow );
	lDataLen = 0;
 8007a2e:	2700      	movs	r7, #0
 8007a30:	e768      	b.n	8007904 <prvTCPPrepareSend+0xd0>
				lDataLen = -1;
			}
		}
	}

	if( ( lDataLen >= 0 ) && ( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eESTABLISHED ) )
 8007a32:	2800      	cmp	r0, #0
 8007a34:	db4c      	blt.n	8007ad0 <prvTCPPrepareSend+0x29c>
 8007a36:	e038      	b.n	8007aaa <prvTCPPrepareSend+0x276>
	}

	/* Anything to send, a change of the advertised window size, or maybe send a
	keep-alive message? */
	if( ( lDataLen > 0 ) ||
		( pxSocket->u.xTCP.bits.bWinChange != pdFALSE_UNSIGNED ) ||
 8007a38:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8007a3c:	f013 0f03 	tst.w	r3, #3
 8007a40:	d14c      	bne.n	8007adc <prvTCPPrepareSend+0x2a8>
 8007a42:	e056      	b.n	8007af2 <prvTCPPrepareSend+0x2be>
		( pxSocket->u.xTCP.bits.bSendKeepAlive != pdFALSE_UNSIGNED ) )
	{
		pxProtocolHeaders->xTCPHeader.ucTCPFlags &= ( ( uint8_t ) ~tcpTCP_FLAG_PSH );
 8007a44:	7b6b      	ldrb	r3, [r5, #13]
 8007a46:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		pxProtocolHeaders->xTCPHeader.ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 ); /*_RB_ "2" needs comment. */
 8007a4a:	f108 0214 	add.w	r2, r8, #20
 8007a4e:	0092      	lsls	r2, r2, #2
 8007a50:	732a      	strb	r2, [r5, #12]

		pxProtocolHeaders->xTCPHeader.ucTCPFlags |= ( uint8_t ) tcpTCP_FLAG_ACK;
 8007a52:	f043 0210 	orr.w	r2, r3, #16
 8007a56:	736a      	strb	r2, [r5, #13]
 8007a58:	e7be      	b.n	80079d8 <prvTCPPrepareSend+0x1a4>
		pxReturn = pxGetNetworkBufferWithDescriptor( uxNeeded, 0U );

		if( pxReturn != NULL )
		{
			/* Set the actual packet size, in case the returned buffer is larger. */
			pxReturn->xDataLength = uxNeeded;
 8007a5a:	461d      	mov	r5, r3
 8007a5c:	f8c3 901c 	str.w	r9, [r3, #28]

			/* Copy the existing data to the new created buffer. */
			if( pxNetworkBuffer != NULL )
			{
				/* Either from the previous buffer... */
				( void ) memcpy( pxReturn->pucEthernetBuffer, pxNetworkBuffer->pucEthernetBuffer, pxNetworkBuffer->xDataLength );
 8007a60:	6998      	ldr	r0, [r3, #24]
 8007a62:	69b1      	ldr	r1, [r6, #24]
 8007a64:	69f2      	ldr	r2, [r6, #28]
 8007a66:	f002 fa3d 	bl	8009ee4 <memcpy>

				/* ...and release it. */
				vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 8007a6a:	4630      	mov	r0, r6
 8007a6c:	f7fc fdb0 	bl	80045d0 <vReleaseNetworkBufferAndDescriptor>
	if( xResize != pdFALSE )
	{
		/* The caller didn't provide a network buffer or the provided buffer is
		too small.  As we must send-out a data packet, a buffer will be created
		here. */
		pxReturn = pxGetNetworkBufferWithDescriptor( uxNeeded, 0U );
 8007a70:	462e      	mov	r6, r5
 8007a72:	e7b8      	b.n	80079e6 <prvTCPPrepareSend+0x1b2>
 8007a74:	4648      	mov	r0, r9
 8007a76:	2100      	movs	r1, #0
 8007a78:	f7fc fdcc 	bl	8004614 <pxGetNetworkBufferWithDescriptor>

		if( pxReturn != NULL )
 8007a7c:	4603      	mov	r3, r0
 8007a7e:	2800      	cmp	r0, #0
 8007a80:	d1eb      	bne.n	8007a5a <prvTCPPrepareSend+0x226>
 8007a82:	e73b      	b.n	80078fc <prvTCPPrepareSend+0xc8>
		{
			/* Set the actual packet size, in case the returned buffer is larger. */
			pxReturn->xDataLength = uxNeeded;
 8007a84:	f8c6 901c 	str.w	r9, [r6, #28]
				vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
			}
			else
			{
				/* Or from the socket field 'xTCP.xPacket'. */
				( void ) memcpy( pxReturn->pucEthernetBuffer, pxSocket->u.xTCP.xPacket.u.ucLastPacket, sizeof( pxSocket->u.xTCP.xPacket.u.ucLastPacket ) );
 8007a88:	69b0      	ldr	r0, [r6, #24]
 8007a8a:	f104 0182 	add.w	r1, r4, #130	; 0x82
 8007a8e:	2246      	movs	r2, #70	; 0x46
 8007a90:	f002 fa28 	bl	8009ee4 <memcpy>
 8007a94:	e7a7      	b.n	80079e6 <prvTCPPrepareSend+0x1b2>

	if( xBufferAllocFixedSize != pdFALSE )
	{
		/* Network buffers are created with a fixed size and can hold the largest
		MTU. */
		uxNeeded = ( size_t ) ipTOTAL_ETHERNET_FRAME_SIZE;
 8007a96:	f240 49c6 	movw	r9, #1222	; 0x4c6
	if( xResize != pdFALSE )
	{
		/* The caller didn't provide a network buffer or the provided buffer is
		too small.  As we must send-out a data packet, a buffer will be created
		here. */
		pxReturn = pxGetNetworkBufferWithDescriptor( uxNeeded, 0U );
 8007a9a:	4648      	mov	r0, r9
 8007a9c:	2100      	movs	r1, #0
 8007a9e:	f7fc fdb9 	bl	8004614 <pxGetNetworkBufferWithDescriptor>

		if( pxReturn != NULL )
 8007aa2:	4606      	mov	r6, r0
 8007aa4:	2800      	cmp	r0, #0
 8007aa6:	d1ed      	bne.n	8007a84 <prvTCPPrepareSend+0x250>
 8007aa8:	e728      	b.n	80078fc <prvTCPPrepareSend+0xc8>
				lDataLen = -1;
			}
		}
	}

	if( ( lDataLen >= 0 ) && ( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eESTABLISHED ) )
 8007aaa:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 8007aae:	2b05      	cmp	r3, #5
 8007ab0:	d181      	bne.n	80079b6 <prvTCPPrepareSend+0x182>
 8007ab2:	e72b      	b.n	800790c <prvTCPPrepareSend+0xd8>
	keep-alive message? */
	if( ( lDataLen > 0 ) ||
		( pxSocket->u.xTCP.bits.bWinChange != pdFALSE_UNSIGNED ) ||
		( pxSocket->u.xTCP.bits.bSendKeepAlive != pdFALSE_UNSIGNED ) )
	{
		pxProtocolHeaders->xTCPHeader.ucTCPFlags &= ( ( uint8_t ) ~tcpTCP_FLAG_PSH );
 8007ab4:	f896 302f 	ldrb.w	r3, [r6, #47]	; 0x2f
 8007ab8:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		pxProtocolHeaders->xTCPHeader.ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 ); /*_RB_ "2" needs comment. */
 8007abc:	f108 0214 	add.w	r2, r8, #20
 8007ac0:	0092      	lsls	r2, r2, #2
 8007ac2:	f886 202e 	strb.w	r2, [r6, #46]	; 0x2e

		pxProtocolHeaders->xTCPHeader.ucTCPFlags |= ( uint8_t ) tcpTCP_FLAG_ACK;
 8007ac6:	f043 0210 	orr.w	r2, r3, #16
 8007aca:	f886 202f 	strb.w	r2, [r6, #47]	; 0x2f
 8007ace:	e783      	b.n	80079d8 <prvTCPPrepareSend+0x1a4>
	}

	/* Anything to send, a change of the advertised window size, or maybe send a
	keep-alive message? */
	if( ( lDataLen > 0 ) ||
		( pxSocket->u.xTCP.bits.bWinChange != pdFALSE_UNSIGNED ) ||
 8007ad0:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8007ad4:	f013 0f03 	tst.w	r3, #3
 8007ad8:	d1ec      	bne.n	8007ab4 <prvTCPPrepareSend+0x280>
 8007ada:	e00a      	b.n	8007af2 <prvTCPPrepareSend+0x2be>
		( pxSocket->u.xTCP.bits.bSendKeepAlive != pdFALSE_UNSIGNED ) )
	{
		pxProtocolHeaders->xTCPHeader.ucTCPFlags &= ( ( uint8_t ) ~tcpTCP_FLAG_PSH );
 8007adc:	7b6b      	ldrb	r3, [r5, #13]
 8007ade:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		pxProtocolHeaders->xTCPHeader.ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 ); /*_RB_ "2" needs comment. */
 8007ae2:	f108 0214 	add.w	r2, r8, #20
 8007ae6:	0092      	lsls	r2, r2, #2
 8007ae8:	732a      	strb	r2, [r5, #12]

		pxProtocolHeaders->xTCPHeader.ucTCPFlags |= ( uint8_t ) tcpTCP_FLAG_ACK;
 8007aea:	f043 0310 	orr.w	r3, r3, #16
 8007aee:	736b      	strb	r3, [r5, #13]
 8007af0:	e775      	b.n	80079de <prvTCPPrepareSend+0x1aa>
		uxIntermediateResult = uxIPHeaderSizeSocket( pxSocket ) + ipSIZE_OF_TCP_HEADER + uxOptionsLength;
		lDataLen += ( int32_t ) uxIntermediateResult;
	}

	return lDataLen;
}
 8007af2:	4638      	mov	r0, r7
 8007af4:	b007      	add	sp, #28
 8007af6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8007afa:	bf00      	nop
 8007afc:	0800ab84 	.word	0x0800ab84
 8007b00:	0001d4c0 	.word	0x0001d4c0

08007b04 <prvTCPSendRepeated>:
/*
 * prvTCPSendRepeated will try to send a series of messages, as long as there is
 * data to be sent and as long as the transmit window isn't full.
 */
static int32_t prvTCPSendRepeated( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **ppxNetworkBuffer )
{
 8007b04:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8007b08:	4681      	mov	r9, r0
 8007b0a:	4688      	mov	r8, r1
 8007b0c:	2408      	movs	r4, #8
UBaseType_t uxIndex;
int32_t lResult = 0;
 8007b0e:	2600      	movs	r6, #0

	for( uxIndex = 0U; uxIndex < ( UBaseType_t ) SEND_REPEATED_COUNT; uxIndex++ )
	{
		/* prvTCPPrepareSend() might allocate a network buffer if there is data
		to be sent. */
		xSendLength = prvTCPPrepareSend( pxSocket, ppxNetworkBuffer, uxOptionsLength );
 8007b10:	4637      	mov	r7, r6
 8007b12:	4648      	mov	r0, r9
 8007b14:	4641      	mov	r1, r8
 8007b16:	463a      	mov	r2, r7
 8007b18:	f7ff fe8c 	bl	8007834 <prvTCPPrepareSend>
		if( xSendLength <= 0 )
 8007b1c:	1e05      	subs	r5, r0, #0
 8007b1e:	dd09      	ble.n	8007b34 <prvTCPSendRepeated+0x30>
		{
			break;
		}

		/* And return the packet to the peer. */
		prvTCPReturnPacket( pxSocket, *ppxNetworkBuffer, ( uint32_t ) xSendLength, ipconfigZERO_COPY_TX_DRIVER );
 8007b20:	4648      	mov	r0, r9
 8007b22:	f8d8 1000 	ldr.w	r1, [r8]
 8007b26:	462a      	mov	r2, r5
 8007b28:	463b      	mov	r3, r7
 8007b2a:	f7ff fc05 	bl	8007338 <prvTCPReturnPacket>
		{
			*ppxNetworkBuffer = NULL;
		}
		#endif /* ipconfigZERO_COPY_TX_DRIVER */

		lResult += xSendLength;
 8007b2e:	442e      	add	r6, r5
UBaseType_t uxIndex;
int32_t lResult = 0;
UBaseType_t uxOptionsLength = 0U;
int32_t xSendLength;

	for( uxIndex = 0U; uxIndex < ( UBaseType_t ) SEND_REPEATED_COUNT; uxIndex++ )
 8007b30:	3c01      	subs	r4, #1
 8007b32:	d1ee      	bne.n	8007b12 <prvTCPSendRepeated+0xe>
		lResult += xSendLength;
	}

	/* Return the total number of bytes sent. */
	return lResult;
}
 8007b34:	4630      	mov	r0, r6
 8007b36:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8007b3a:	bf00      	nop

08007b3c <xTCPSocketCheck>:
 *		prvTCPSendRepeated()			// Send at most 8 messages on a row
 *			prvTCPReturnPacket()		// Prepare for returning
 *			xNetworkInterfaceOutput()	// Sends data to the NIC ( declared in portable/NetworkInterface/xxx )
 */
BaseType_t xTCPSocketCheck( FreeRTOS_Socket_t *pxSocket )
{
 8007b3c:	b570      	push	{r4, r5, r6, lr}
 8007b3e:	b084      	sub	sp, #16
 8007b40:	4604      	mov	r4, r0
BaseType_t xResult = 0;
BaseType_t xReady = pdFALSE;

	if( ( pxSocket->u.xTCP.ucTCPState >= ( uint8_t ) eESTABLISHED ) && ( pxSocket->u.xTCP.txStream != NULL ) )
 8007b42:	f890 3053 	ldrb.w	r3, [r0, #83]	; 0x53
 8007b46:	2b04      	cmp	r3, #4
 8007b48:	f240 8160 	bls.w	8007e0c <xTCPSocketCheck+0x2d0>
 8007b4c:	6f83      	ldr	r3, [r0, #120]	; 0x78
 8007b4e:	2b00      	cmp	r3, #0
 8007b50:	f000 8154 	beq.w	8007dfc <xTCPSocketCheck+0x2c0>
	{
		/* The API FreeRTOS_send() might have added data to the TX stream.  Add
		this data to the windowing system so it can be transmitted. */
		prvTCPAddTxData( pxSocket );
 8007b54:	f7ff fbc6 	bl	80072e4 <prvTCPAddTxData>
	}

	#if( ipconfigUSE_TCP_WIN == 1 )
	{
		if( pxSocket->u.xTCP.pxAckMessage != NULL )
 8007b58:	6fe1      	ldr	r1, [r4, #124]	; 0x7c
 8007b5a:	b1f9      	cbz	r1, 8007b9c <xTCPSocketCheck+0x60>
		{
			/* The first task of this regular socket check is to send-out delayed
			ACK's. */
			if( pxSocket->u.xTCP.bits.bUserShutdown == pdFALSE_UNSIGNED )
 8007b5c:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8007b60:	f013 0f20 	tst.w	r3, #32
 8007b64:	d111      	bne.n	8007b8a <xTCPSocketCheck+0x4e>
			{
				/* Earlier data was received but not yet acknowledged.  This
				function is called when the TCP timer for the socket expires, the
				ACK may be sent now. */
				if( pxSocket->u.xTCP.ucTCPState != ( uint8_t ) eCLOSED )
 8007b66:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 8007b6a:	b123      	cbz	r3, 8007b76 <xTCPSocketCheck+0x3a>
							pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber - pxSocket->u.xTCP.xTCPWindow.rx.ulFirstSequenceNumber,
							pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber   - pxSocket->u.xTCP.xTCPWindow.tx.ulFirstSequenceNumber,
							( unsigned ) ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER ) );
					}

					prvTCPReturnPacket( pxSocket, pxSocket->u.xTCP.pxAckMessage, ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER, ipconfigZERO_COPY_TX_DRIVER );
 8007b6c:	4620      	mov	r0, r4
 8007b6e:	2228      	movs	r2, #40	; 0x28
 8007b70:	2300      	movs	r3, #0
 8007b72:	f7ff fbe1 	bl	8007338 <prvTCPReturnPacket>
						clear the pointer to it. */
						pxSocket->u.xTCP.pxAckMessage = NULL;
					}
					#endif /* ipconfigZERO_COPY_TX_DRIVER */
				}
				if( prvTCPNextTimeout( pxSocket ) > 1U )
 8007b76:	4620      	mov	r0, r4
 8007b78:	f7ff fd12 	bl	80075a0 <prvTCPNextTimeout>
 8007b7c:	2801      	cmp	r0, #1
 8007b7e:	bf94      	ite	ls
 8007b80:	2500      	movls	r5, #0
 8007b82:	2501      	movhi	r5, #1
				/* The user wants to perform an active shutdown(), skip sending
				the	delayed	ACK.  The function prvTCPSendPacket() will send the
				FIN	along with the ACK's. */
			}

			if( pxSocket->u.xTCP.pxAckMessage != NULL )
 8007b84:	6fe1      	ldr	r1, [r4, #124]	; 0x7c
 8007b86:	b131      	cbz	r1, 8007b96 <xTCPSocketCheck+0x5a>
 8007b88:	e000      	b.n	8007b8c <xTCPSocketCheck+0x50>
 *			xNetworkInterfaceOutput()	// Sends data to the NIC ( declared in portable/NetworkInterface/xxx )
 */
BaseType_t xTCPSocketCheck( FreeRTOS_Socket_t *pxSocket )
{
BaseType_t xResult = 0;
BaseType_t xReady = pdFALSE;
 8007b8a:	2500      	movs	r5, #0
				FIN	along with the ACK's. */
			}

			if( pxSocket->u.xTCP.pxAckMessage != NULL )
			{
				vReleaseNetworkBufferAndDescriptor( pxSocket->u.xTCP.pxAckMessage );
 8007b8c:	4608      	mov	r0, r1
 8007b8e:	f7fc fd1f 	bl	80045d0 <vReleaseNetworkBufferAndDescriptor>
				pxSocket->u.xTCP.pxAckMessage = NULL;
 8007b92:	2300      	movs	r3, #0
 8007b94:	67e3      	str	r3, [r4, #124]	; 0x7c
			}
		}
	}
	#endif /* ipconfigUSE_TCP_WIN */

	if( xReady == pdFALSE )
 8007b96:	2d00      	cmp	r5, #0
 8007b98:	f040 80fe 	bne.w	8007d98 <xTCPSocketCheck+0x25c>
	{
		/* The second task of this regular socket check is sending out data. */
		if( ( pxSocket->u.xTCP.ucTCPState >= ( uint8_t ) eESTABLISHED ) ||
 8007b9c:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 8007ba0:	2b04      	cmp	r3, #4
 8007ba2:	d803      	bhi.n	8007bac <xTCPSocketCheck+0x70>
 8007ba4:	2b02      	cmp	r3, #2
 8007ba6:	f040 8100 	bne.w	8007daa <xTCPSocketCheck+0x26e>
 8007baa:	e00f      	b.n	8007bcc <xTCPSocketCheck+0x90>
{
int32_t lResult = 0;
UBaseType_t uxOptionsLength, uxIntermediateResult = 0;
NetworkBufferDescriptor_t *pxNetworkBuffer;

	if( pxSocket->u.xTCP.ucTCPState != ( uint8_t ) eCONNECT_SYN )
 8007bac:	2b02      	cmp	r3, #2
 8007bae:	d00d      	beq.n	8007bcc <xTCPSocketCheck+0x90>
	{
		/* The connection is in a state other than SYN. */
		pxNetworkBuffer = NULL;
 8007bb0:	a904      	add	r1, sp, #16
 8007bb2:	2300      	movs	r3, #0
 8007bb4:	f841 3d08 	str.w	r3, [r1, #-8]!

		/* prvTCPSendRepeated() will only create a network buffer if necessary,
		i.e. when data must be sent to the peer. */
		lResult = prvTCPSendRepeated( pxSocket, &pxNetworkBuffer );
 8007bb8:	4620      	mov	r0, r4
 8007bba:	f7ff ffa3 	bl	8007b04 <prvTCPSendRepeated>

		if( pxNetworkBuffer != NULL )
 8007bbe:	9802      	ldr	r0, [sp, #8]
 8007bc0:	2800      	cmp	r0, #0
 8007bc2:	f000 80f2 	beq.w	8007daa <xTCPSocketCheck+0x26e>
		{
			vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 8007bc6:	f7fc fd03 	bl	80045d0 <vReleaseNetworkBufferAndDescriptor>
 8007bca:	e0ee      	b.n	8007daa <xTCPSocketCheck+0x26e>
		}
	}
	else
	{
		if( pxSocket->u.xTCP.ucRepCount >= 3U )
 8007bcc:	f894 3052 	ldrb.w	r3, [r4, #82]	; 0x52
 8007bd0:	2b02      	cmp	r3, #2
 8007bd2:	d904      	bls.n	8007bde <xTCPSocketCheck+0xa2>
			to most 3 times.  When there is no response, the socket get the
			status 'eCLOSE_WAIT'. */
			FreeRTOS_debug_printf( ( "Connect: giving up %lxip:%u\n",
				pxSocket->u.xTCP.ulRemoteIP,		/* IP address of remote machine. */
				pxSocket->u.xTCP.usRemotePort ) );	/* Port on remote machine. */
			vTCPStateChange( pxSocket, eCLOSE_WAIT );
 8007bd4:	4620      	mov	r0, r4
 8007bd6:	2108      	movs	r1, #8
 8007bd8:	f7ff fd48 	bl	800766c <vTCPStateChange>
 8007bdc:	e0e5      	b.n	8007daa <xTCPSocketCheck+0x26e>
		}
		else if( ( pxSocket->u.xTCP.bits.bConnPrepared != pdFALSE_UNSIGNED ) || ( prvTCPPrepareConnect( pxSocket ) == pdTRUE ) )
 8007bde:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8007be2:	f013 0f08 	tst.w	r3, #8
 8007be6:	f040 8083 	bne.w	8007cf0 <xTCPSocketCheck+0x1b4>
		/* Only necessary for nicer logging. */
		( void ) memset( xEthAddress.ucBytes, 0, sizeof( xEthAddress.ucBytes ) );
	}
	#endif /* ipconfigHAS_PRINTF != 0 */

	ulRemoteIP = FreeRTOS_htonl( pxSocket->u.xTCP.ulRemoteIP );
 8007bea:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 8007bec:	060a      	lsls	r2, r1, #24
 8007bee:	ea42 6211 	orr.w	r2, r2, r1, lsr #24
 8007bf2:	f401 437f 	and.w	r3, r1, #65280	; 0xff00
 8007bf6:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
 8007bfa:	f401 037f 	and.w	r3, r1, #16711680	; 0xff0000
 8007bfe:	ea42 2313 	orr.w	r3, r2, r3, lsr #8
 8007c02:	a804      	add	r0, sp, #16
 8007c04:	f840 3d0c 	str.w	r3, [r0, #-12]!

	/* Determine the ARP cache status for the requested IP address. */
	eReturned = eARPGetCacheEntry( &( ulRemoteIP ), &( xEthAddress ) );
 8007c08:	a902      	add	r1, sp, #8
 8007c0a:	f7fc fe4f 	bl	80048ac <eARPGetCacheEntry>

	switch( eReturned )
 8007c0e:	2801      	cmp	r0, #1
 8007c10:	d008      	beq.n	8007c24 <xTCPSocketCheck+0xe8>
		break;				/* We can now prepare the SYN packet. */
	case eARPCacheMiss:		/* An ARP table lookup did not find a valid entry. */
	case eCantSendPacket:	/* There is no IP address, or an ARP is still in progress. */
	default:
		/* Count the number of times it couldn't find the ARP address. */
		pxSocket->u.xTCP.ucRepCount++;
 8007c12:	f894 3052 	ldrb.w	r3, [r4, #82]	; 0x52
 8007c16:	3301      	adds	r3, #1
 8007c18:	f884 3052 	strb.w	r3, [r4, #82]	; 0x52
			xEthAddress.ucBytes[ 3 ],
			xEthAddress.ucBytes[ 4 ],
			xEthAddress.ucBytes[ 5 ] ) );

		/* And issue a (new) ARP request */
		FreeRTOS_OutputARPRequest( ulRemoteIP );
 8007c1c:	9801      	ldr	r0, [sp, #4]
 8007c1e:	f7fc fee7 	bl	80049f0 <FreeRTOS_OutputARPRequest>
 8007c22:	e0c2      	b.n	8007daa <xTCPSocketCheck+0x26e>
	}

	if( xReturn != pdFALSE )
	{
		/* Get a difficult-to-predict initial sequence number for this 4-tuple. */
		ulInitialSequenceNumber = ulApplicationGetNextSequenceNumber( *ipLOCAL_IP_ADDRESS_POINTER,
 8007c24:	4b7d      	ldr	r3, [pc, #500]	; (8007e1c <xTCPSocketCheck+0x2e0>)
 8007c26:	6958      	ldr	r0, [r3, #20]
 8007c28:	8ca1      	ldrh	r1, [r4, #36]	; 0x24
 8007c2a:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8007c2c:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 8007c2e:	f002 ff77 	bl	800ab20 <ulApplicationGetNextSequenceNumber>
																	  pxSocket->usLocalPort,
																	  pxSocket->u.xTCP.ulRemoteIP,
																	  pxSocket->u.xTCP.usRemotePort );

		/* Check for a random number generation error. */
		if( ulInitialSequenceNumber == 0UL )
 8007c32:	4606      	mov	r6, r0
 8007c34:	2800      	cmp	r0, #0
 8007c36:	f000 80b8 	beq.w	8007daa <xTCPSocketCheck+0x26e>
		 * the buffer onto the TCPPacket_t struct to easily access it's field. */
		pxTCPPacket = ipCAST_PTR_TO_TYPE_PTR( TCPPacket_t, pxSocket->u.xTCP.xPacket.u.ucLastPacket );
		pxIPHeader = &pxTCPPacket->xIPHeader;

		/* reset the retry counter to zero. */
		pxSocket->u.xTCP.ucRepCount = 0U;
 8007c3a:	2500      	movs	r5, #0
 8007c3c:	f884 5052 	strb.w	r5, [r4, #82]	; 0x52

		/* And remember that the connect/SYN data are prepared. */
		pxSocket->u.xTCP.bits.bConnPrepared = pdTRUE_UNSIGNED;
 8007c40:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8007c44:	f043 0308 	orr.w	r3, r3, #8
 8007c48:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41

		/* Now that the Ethernet address is known, the initial packet can be
		prepared. */
		( void ) memset( pxSocket->u.xTCP.xPacket.u.ucLastPacket, 0, sizeof( pxSocket->u.xTCP.xPacket.u.ucLastPacket ) );
 8007c4c:	f104 0082 	add.w	r0, r4, #130	; 0x82
 8007c50:	4629      	mov	r1, r5
 8007c52:	2246      	movs	r2, #70	; 0x46
 8007c54:	f002 f972 	bl	8009f3c <memset>

		/* Write the Ethernet address in Source, because it will be swapped by
		prvTCPReturnPacket(). */
		( void ) memcpy( ( void * ) ( &pxTCPPacket->xEthernetHeader.xSourceAddress ), ( const void * ) ( &xEthAddress ), sizeof( xEthAddress ) );
 8007c58:	ab04      	add	r3, sp, #16
 8007c5a:	f853 0d08 	ldr.w	r0, [r3, #-8]!
 8007c5e:	f8c4 0088 	str.w	r0, [r4, #136]	; 0x88
 8007c62:	889b      	ldrh	r3, [r3, #4]
 8007c64:	f8a4 308c 	strh.w	r3, [r4, #140]	; 0x8c

		/* 'ipIPv4_FRAME_TYPE' is already in network-byte-order. */
		pxTCPPacket->xEthernetHeader.usFrameType = ipIPv4_FRAME_TYPE;
 8007c68:	2308      	movs	r3, #8
 8007c6a:	f884 308e 	strb.w	r3, [r4, #142]	; 0x8e
 8007c6e:	f884 508f 	strb.w	r5, [r4, #143]	; 0x8f

		pxIPHeader->ucVersionHeaderLength = 0x45U;
 8007c72:	2345      	movs	r3, #69	; 0x45
 8007c74:	f884 3090 	strb.w	r3, [r4, #144]	; 0x90
		usLength = ( uint16_t ) ( sizeof( TCPPacket_t ) - sizeof( pxTCPPacket->xEthernetHeader ) );
		pxIPHeader->usLength = FreeRTOS_htons( usLength );
 8007c78:	f884 5092 	strb.w	r5, [r4, #146]	; 0x92
 8007c7c:	2338      	movs	r3, #56	; 0x38
 8007c7e:	f884 3093 	strb.w	r3, [r4, #147]	; 0x93
		pxIPHeader->ucTimeToLive = ( uint8_t ) ipconfigTCP_TIME_TO_LIVE;
 8007c82:	2380      	movs	r3, #128	; 0x80
 8007c84:	f884 3098 	strb.w	r3, [r4, #152]	; 0x98

		pxIPHeader->ucProtocol = ( uint8_t ) ipPROTOCOL_TCP;
 8007c88:	2306      	movs	r3, #6
 8007c8a:	f884 3099 	strb.w	r3, [r4, #153]	; 0x99

		/* Addresses and ports will be stored swapped because prvTCPReturnPacket
		will swap them back while replying. */
		pxIPHeader->ulDestinationIPAddress = *ipLOCAL_IP_ADDRESS_POINTER;
 8007c8e:	4b63      	ldr	r3, [pc, #396]	; (8007e1c <xTCPSocketCheck+0x2e0>)
 8007c90:	695b      	ldr	r3, [r3, #20]
 8007c92:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
		pxIPHeader->ulSourceIPAddress = FreeRTOS_htonl( pxSocket->u.xTCP.ulRemoteIP );
 8007c96:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 8007c98:	060a      	lsls	r2, r1, #24
 8007c9a:	ea42 6211 	orr.w	r2, r2, r1, lsr #24
 8007c9e:	f401 437f 	and.w	r3, r1, #65280	; 0xff00
 8007ca2:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
 8007ca6:	f401 037f 	and.w	r3, r1, #16711680	; 0xff0000
 8007caa:	ea42 2313 	orr.w	r3, r2, r3, lsr #8
 8007cae:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c

		pxTCPPacket->xTCPHeader.usSourcePort = FreeRTOS_htons( pxSocket->u.xTCP.usRemotePort );
 8007cb2:	8fa2      	ldrh	r2, [r4, #60]	; 0x3c
 8007cb4:	0a13      	lsrs	r3, r2, #8
 8007cb6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8007cba:	f8a4 30a4 	strh.w	r3, [r4, #164]	; 0xa4
		pxTCPPacket->xTCPHeader.usDestinationPort = FreeRTOS_htons( pxSocket->usLocalPort );
 8007cbe:	8ca2      	ldrh	r2, [r4, #36]	; 0x24
 8007cc0:	0a13      	lsrs	r3, r2, #8
 8007cc2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8007cc6:	f8a4 30a6 	strh.w	r3, [r4, #166]	; 0xa6

		/* We are actively connecting, so the peer's Initial Sequence Number (ISN)
		isn't known yet. */
		pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber = 0UL;
 8007cca:	f8c4 50e8 	str.w	r5, [r4, #232]	; 0xe8

		/* Start with ISN (Initial Sequence Number). */
		pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber = ulInitialSequenceNumber;
 8007cce:	f8c4 6104 	str.w	r6, [r4, #260]	; 0x104

		/* The TCP header size is 20 bytes, divided by 4 equals 5, which is put in
		the high nibble of the TCP offset field. */
		pxTCPPacket->xTCPHeader.ucTCPOffset = 0x50U;
 8007cd2:	2350      	movs	r3, #80	; 0x50
 8007cd4:	f884 30b0 	strb.w	r3, [r4, #176]	; 0xb0

		/* Only set the SYN flag. */
		pxTCPPacket->xTCPHeader.ucTCPFlags = tcpTCP_FLAG_SYN;
 8007cd8:	2302      	movs	r3, #2
 8007cda:	f884 30b1 	strb.w	r3, [r4, #177]	; 0xb1
		ulMSS = FreeRTOS_min_uint32( ( uint32_t ) tcpREDUCED_MSS_THROUGH_INTERNET, ulMSS );
	}

	FreeRTOS_debug_printf( ( "prvSocketSetMSS: %lu bytes for %lxip:%u\n", ulMSS, pxSocket->u.xTCP.ulRemoteIP, pxSocket->u.xTCP.usRemotePort ) );

	pxSocket->u.xTCP.usInitMSS = ( uint16_t ) ulMSS;
 8007cde:	f44f 6391 	mov.w	r3, #1160	; 0x488
 8007ce2:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
	pxSocket->u.xTCP.usCurMSS  = ( uint16_t ) ulMSS;
 8007ce6:	f8a4 304a 	strh.w	r3, [r4, #74]	; 0x4a
		prvSocketSetMSS( pxSocket );

		/* The initial sequence numbers at our side are known.  Later
		vTCPWindowInit() will be called to fill in the peer's sequence numbers, but
		first wait for a SYN+ACK reply. */
		prvTCPCreateWindow( pxSocket );
 8007cea:	4620      	mov	r0, r4
 8007cec:	f7ff fc3e 	bl	800756c <prvTCPCreateWindow>
 * communicate what MSS (Maximum Segment Size) they intend to use.   MSS is the
 * nett size of the payload, always smaller than MTU.
*/
static UBaseType_t prvSetSynAckOptions( FreeRTOS_Socket_t *pxSocket, TCPHeader_t * pxTCPHeader )
{
uint16_t usMSS = pxSocket->u.xTCP.usInitMSS;
 8007cf0:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
UBaseType_t uxOptionsLength;

	/* We send out the TCP Maximum Segment Size option with our SYN[+ACK]. */

	pxTCPHeader->ucOptdata[ 0 ] = ( uint8_t ) tcpTCP_OPT_MSS;
 8007cf4:	2302      	movs	r3, #2
 8007cf6:	f884 30b8 	strb.w	r3, [r4, #184]	; 0xb8
	pxTCPHeader->ucOptdata[ 1 ] = ( uint8_t ) tcpTCP_OPT_MSS_LEN;
 8007cfa:	2304      	movs	r3, #4
 8007cfc:	f884 30b9 	strb.w	r3, [r4, #185]	; 0xb9
	pxTCPHeader->ucOptdata[ 2 ] = ( uint8_t ) ( usMSS >> 8 );
 8007d00:	0a13      	lsrs	r3, r2, #8
 8007d02:	f884 30ba 	strb.w	r3, [r4, #186]	; 0xba
	pxTCPHeader->ucOptdata[ 3 ] = ( uint8_t ) ( usMSS & 0xffU );
 8007d06:	f884 20bb 	strb.w	r2, [r4, #187]	; 0xbb
	{
	size_t uxWinSize;
	uint8_t ucFactor;

		/* 'xTCP.uxRxWinSize' is the size of the reception window in units of MSS. */
		uxWinSize = pxSocket->u.xTCP.uxRxWinSize * ( size_t ) pxSocket->u.xTCP.usInitMSS;
 8007d0a:	f8d4 30d0 	ldr.w	r3, [r4, #208]	; 0xd0
 8007d0e:	fb03 f202 	mul.w	r2, r3, r2
		ucFactor = 0U;
		while( uxWinSize > 0xffffUL )
 8007d12:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 8007d16:	d307      	bcc.n	8007d28 <xTCPSocketCheck+0x1ec>
 8007d18:	2300      	movs	r3, #0
		{
			/* Divide by two and increase the binary factor by 1. */
			uxWinSize >>= 1;
 8007d1a:	0852      	lsrs	r2, r2, #1
			ucFactor++;
 8007d1c:	3301      	adds	r3, #1
 8007d1e:	b2db      	uxtb	r3, r3
	uint8_t ucFactor;

		/* 'xTCP.uxRxWinSize' is the size of the reception window in units of MSS. */
		uxWinSize = pxSocket->u.xTCP.uxRxWinSize * ( size_t ) pxSocket->u.xTCP.usInitMSS;
		ucFactor = 0U;
		while( uxWinSize > 0xffffUL )
 8007d20:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 8007d24:	d2f9      	bcs.n	8007d1a <xTCPSocketCheck+0x1de>
 8007d26:	e000      	b.n	8007d2a <xTCPSocketCheck+0x1ee>
	size_t uxWinSize;
	uint8_t ucFactor;

		/* 'xTCP.uxRxWinSize' is the size of the reception window in units of MSS. */
		uxWinSize = pxSocket->u.xTCP.uxRxWinSize * ( size_t ) pxSocket->u.xTCP.usInitMSS;
		ucFactor = 0U;
 8007d28:	2300      	movs	r3, #0
	pxTCPHeader->ucOptdata[ 2 ] = ( uint8_t ) ( usMSS >> 8 );
	pxTCPHeader->ucOptdata[ 3 ] = ( uint8_t ) ( usMSS & 0xffU );

	#if( ipconfigUSE_TCP_WIN != 0 )
	{
		pxSocket->u.xTCP.ucMyWinScaleFactor = prvWinScaleFactor( pxSocket );
 8007d2a:	f884 30c9 	strb.w	r3, [r4, #201]	; 0xc9

		pxTCPHeader->ucOptdata[ 4 ] = tcpTCP_OPT_NOOP;
 8007d2e:	2201      	movs	r2, #1
 8007d30:	f884 20bc 	strb.w	r2, [r4, #188]	; 0xbc
		pxTCPHeader->ucOptdata[ 5 ] = ( uint8_t ) ( tcpTCP_OPT_WSOPT );
 8007d34:	2103      	movs	r1, #3
 8007d36:	f884 10bd 	strb.w	r1, [r4, #189]	; 0xbd
		pxTCPHeader->ucOptdata[ 6 ] = ( uint8_t ) ( tcpTCP_OPT_WSOPT_LEN );
 8007d3a:	f884 10be 	strb.w	r1, [r4, #190]	; 0xbe
		pxTCPHeader->ucOptdata[ 7 ] = ( uint8_t ) pxSocket->u.xTCP.ucMyWinScaleFactor;
 8007d3e:	f884 30bf 	strb.w	r3, [r4, #191]	; 0xbf
	}
	#endif

	#if( ipconfigUSE_TCP_WIN != 0 )
	{
		pxTCPHeader->ucOptdata[ uxOptionsLength      ] = tcpTCP_OPT_NOOP;
 8007d42:	f884 20c0 	strb.w	r2, [r4, #192]	; 0xc0
		pxTCPHeader->ucOptdata[ uxOptionsLength + 1U ] = tcpTCP_OPT_NOOP;
 8007d46:	f884 20c1 	strb.w	r2, [r4, #193]	; 0xc1
		pxTCPHeader->ucOptdata[ uxOptionsLength + 2U ] = tcpTCP_OPT_SACK_P;	/* 4: Sack-Permitted Option. */
 8007d4a:	2304      	movs	r3, #4
 8007d4c:	f884 30c2 	strb.w	r3, [r4, #194]	; 0xc2
		pxTCPHeader->ucOptdata[ uxOptionsLength + 3U ] = 2U;	/* 2: length of this option. */
 8007d50:	2302      	movs	r3, #2
 8007d52:	f884 30c3 	strb.w	r3, [r4, #195]	; 0xc3

			/* Set the TCP offset field:  ipSIZE_OF_TCP_HEADER equals 20 and
			uxOptionsLength is always a multiple of 4.  The complete expression
			would be:
			ucTCPOffset = ( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) / 4 ) << 4 */
			pxProtocolHeaders->xTCPHeader.ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 8007d56:	2380      	movs	r3, #128	; 0x80
 8007d58:	f884 30b0 	strb.w	r3, [r4, #176]	; 0xb0

			/* Repeat Count is used for a connecting socket, to limit the number
			of tries. */
			pxSocket->u.xTCP.ucRepCount++;
 8007d5c:	f894 3052 	ldrb.w	r3, [r4, #82]	; 0x52
 8007d60:	4413      	add	r3, r2
 8007d62:	f884 3052 	strb.w	r3, [r4, #82]	; 0x52

			/* Send the SYN message to make a connection.  The messages is
			stored in the socket field 'xPacket'.  It will be wrapped in a
			pseudo network buffer descriptor before it will be sent. */
			prvTCPReturnPacket( pxSocket, NULL, ( uint32_t ) lResult, pdFALSE );
 8007d66:	4620      	mov	r0, r4
 8007d68:	2100      	movs	r1, #0
 8007d6a:	2234      	movs	r2, #52	; 0x34
 8007d6c:	460b      	mov	r3, r1
 8007d6e:	f7ff fae3 	bl	8007338 <prvTCPReturnPacket>
 8007d72:	e01a      	b.n	8007daa <xTCPSocketCheck+0x26e>
						FreeRTOS_GetTCPStateName( ( UBaseType_t ) pxSocket->u.xTCP.ucTCPState ) ) );
				}
				#endif /* ipconfigHAS_DEBUG_PRINTF */

				/* Move to eCLOSE_WAIT, user may close the socket. */
				vTCPStateChange( pxSocket, eCLOSE_WAIT );
 8007d74:	4620      	mov	r0, r4
 8007d76:	2108      	movs	r1, #8
 8007d78:	f7ff fc78 	bl	800766c <vTCPStateChange>

				/* When 'bPassQueued' true, this socket is an orphan until it
				gets connected. */
				if( pxSocket->u.xTCP.bits.bPassQueued != pdFALSE_UNSIGNED )
 8007d7c:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8007d80:	f013 0f04 	tst.w	r3, #4
 8007d84:	d00a      	beq.n	8007d9c <xTCPSocketCheck+0x260>
				{
					if( pxSocket->u.xTCP.bits.bReuseSocket == pdFALSE_UNSIGNED )
 8007d86:	f013 0f08 	tst.w	r3, #8
 8007d8a:	d109      	bne.n	8007da0 <xTCPSocketCheck+0x264>
					{
						/* As it did not get connected, and the user can never
						accept() it anymore, it will be deleted now.  Called from
						the IP-task, so it's safe to call the internal Close
						function: vSocketClose(). */
						( void ) vSocketClose( pxSocket );
 8007d8c:	4620      	mov	r0, r4
 8007d8e:	f7fe fa6f 	bl	8006270 <vSocketClose>
					}
					/* Return a negative value to tell to inform the caller
					xTCPTimerCheck()
					that the socket got closed and may not be accessed anymore. */
					xResult = -1;
 8007d92:	f04f 30ff 	mov.w	r0, #4294967295
 8007d96:	e03e      	b.n	8007e16 <xTCPSocketCheck+0x2da>
 *			prvTCPReturnPacket()		// Prepare for returning
 *			xNetworkInterfaceOutput()	// Sends data to the NIC ( declared in portable/NetworkInterface/xxx )
 */
BaseType_t xTCPSocketCheck( FreeRTOS_Socket_t *pxSocket )
{
BaseType_t xResult = 0;
 8007d98:	2000      	movs	r0, #0
 8007d9a:	e03c      	b.n	8007e16 <xTCPSocketCheck+0x2da>
		case eLAST_ACK:
		case eTIME_WAIT:
		default:
			/* All other (non-connected) states will get anti-hanging
			protection. */
			xResult = pdTRUE;
 8007d9c:	2001      	movs	r0, #1
 8007d9e:	e03a      	b.n	8007e16 <xTCPSocketCheck+0x2da>
						( void ) vSocketClose( pxSocket );
					}
					/* Return a negative value to tell to inform the caller
					xTCPTimerCheck()
					that the socket got closed and may not be accessed anymore. */
					xResult = -1;
 8007da0:	f04f 30ff 	mov.w	r0, #4294967295
 8007da4:	e037      	b.n	8007e16 <xTCPSocketCheck+0x2da>
	static BaseType_t prvTCPStatusAgeCheck( FreeRTOS_Socket_t *pxSocket )
	{
	BaseType_t xResult;
	eIPTCPState_t eState = ipNUMERIC_CAST( eIPTCPState_t, pxSocket->u.xTCP.ucTCPState );

		switch( eState )
 8007da6:	2000      	movs	r0, #0
 8007da8:	e035      	b.n	8007e16 <xTCPSocketCheck+0x2da>
		{
			( void ) prvTCPSendPacket( pxSocket );
		}

		/* Set the time-out for the next wakeup for this socket. */
		( void ) prvTCPNextTimeout( pxSocket );
 8007daa:	4620      	mov	r0, r4
 8007dac:	f7ff fbf8 	bl	80075a0 <prvTCPNextTimeout>
	static BaseType_t prvTCPStatusAgeCheck( FreeRTOS_Socket_t *pxSocket )
	{
	BaseType_t xResult;
	eIPTCPState_t eState = ipNUMERIC_CAST( eIPTCPState_t, pxSocket->u.xTCP.ucTCPState );

		switch( eState )
 8007db0:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 8007db4:	2b08      	cmp	r3, #8
 8007db6:	d815      	bhi.n	8007de4 <xTCPSocketCheck+0x2a8>
 8007db8:	a201      	add	r2, pc, #4	; (adr r2, 8007dc0 <xTCPSocketCheck+0x284>)
 8007dba:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8007dbe:	bf00      	nop
 8007dc0:	08007da7 	.word	0x08007da7
 8007dc4:	08007da7 	.word	0x08007da7
 8007dc8:	08007de5 	.word	0x08007de5
 8007dcc:	08007de5 	.word	0x08007de5
 8007dd0:	08007de5 	.word	0x08007de5
 8007dd4:	08007da7 	.word	0x08007da7
 8007dd8:	08007de5 	.word	0x08007de5
 8007ddc:	08007de5 	.word	0x08007de5
 8007de0:	08007da7 	.word	0x08007da7
		}
		if( xResult != pdFALSE )
		{
			/* How much time has past since the last active moment which is
			defined as A) a state change or B) a packet has arrived. */
			TickType_t xAge = xTaskGetTickCount( ) - pxSocket->u.xTCP.xLastActTime;
 8007de4:	f7fb f9ea 	bl	80031bc <xTaskGetTickCount>
 8007de8:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8007dea:	1ac0      	subs	r0, r0, r3

			/* ipconfigTCP_HANG_PROTECTION_TIME is in units of seconds. */
			if( xAge > ( ( TickType_t ) ipconfigTCP_HANG_PROTECTION_TIME * ( TickType_t ) configTICK_RATE_HZ ) )
 8007dec:	4b0c      	ldr	r3, [pc, #48]	; (8007e20 <xTCPSocketCheck+0x2e4>)
 8007dee:	4298      	cmp	r0, r3
 8007df0:	d8c0      	bhi.n	8007d74 <xTCPSocketCheck+0x238>
		case eLAST_ACK:
		case eTIME_WAIT:
		default:
			/* All other (non-connected) states will get anti-hanging
			protection. */
			xResult = pdTRUE;
 8007df2:	2001      	movs	r0, #1
 8007df4:	e00f      	b.n	8007e16 <xTCPSocketCheck+0x2da>
	#endif /* ipconfigUSE_TCP_WIN */

	if( xReady == pdFALSE )
	{
		/* The second task of this regular socket check is sending out data. */
		if( ( pxSocket->u.xTCP.ucTCPState >= ( uint8_t ) eESTABLISHED ) ||
 8007df6:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 8007dfa:	e6d7      	b.n	8007bac <xTCPSocketCheck+0x70>
		prvTCPAddTxData( pxSocket );
	}

	#if( ipconfigUSE_TCP_WIN == 1 )
	{
		if( pxSocket->u.xTCP.pxAckMessage != NULL )
 8007dfc:	6fc1      	ldr	r1, [r0, #124]	; 0x7c
 8007dfe:	2900      	cmp	r1, #0
 8007e00:	f47f aeac 	bne.w	8007b5c <xTCPSocketCheck+0x20>
 8007e04:	e7f7      	b.n	8007df6 <xTCPSocketCheck+0x2ba>
	#endif /* ipconfigUSE_TCP_WIN */

	if( xReady == pdFALSE )
	{
		/* The second task of this regular socket check is sending out data. */
		if( ( pxSocket->u.xTCP.ucTCPState >= ( uint8_t ) eESTABLISHED ) ||
 8007e06:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 8007e0a:	e6cb      	b.n	8007ba4 <xTCPSocketCheck+0x68>
		prvTCPAddTxData( pxSocket );
	}

	#if( ipconfigUSE_TCP_WIN == 1 )
	{
		if( pxSocket->u.xTCP.pxAckMessage != NULL )
 8007e0c:	6fc1      	ldr	r1, [r0, #124]	; 0x7c
 8007e0e:	2900      	cmp	r1, #0
 8007e10:	f47f aea4 	bne.w	8007b5c <xTCPSocketCheck+0x20>
 8007e14:	e7f7      	b.n	8007e06 <xTCPSocketCheck+0x2ca>
		}
		#endif
	}

	return xResult;
}
 8007e16:	b004      	add	sp, #16
 8007e18:	bd70      	pop	{r4, r5, r6, pc}
 8007e1a:	bf00      	nop
 8007e1c:	2000d5c0 	.word	0x2000d5c0
 8007e20:	0001d4c0 	.word	0x0001d4c0

08007e24 <prvTCPHandleFin>:
 * Or when the socket has sent a FIN flag to the peer
 * Before being called, it has been checked that both reception and transmission
 * are complete.
 */
static BaseType_t prvTCPHandleFin( FreeRTOS_Socket_t *pxSocket, const NetworkBufferDescriptor_t *pxNetworkBuffer )
{
 8007e24:	b538      	push	{r3, r4, r5, lr}
 8007e26:	4604      	mov	r4, r0
/* Map the ethernet buffer onto the ProtocolHeader_t struct for easy access to the fields. */
ProtocolHeaders_t *pxProtocolHeaders = ipCAST_PTR_TO_TYPE_PTR( ProtocolHeaders_t,
 8007e28:	698d      	ldr	r5, [r1, #24]
	&( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + xIPHeaderSize( pxNetworkBuffer ) ] ) );
TCPHeader_t *pxTCPHeader = &( pxProtocolHeaders->xTCPHeader );
uint8_t ucIntermediateResult = 0, ucTCPFlags = pxTCPHeader->ucTCPFlags;
TCPWindow_t *pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
BaseType_t xSendLength = 0;
uint32_t ulAckNr = FreeRTOS_ntohl( pxTCPHeader->ulAckNr );
 8007e2a:	f8d5 102a 	ldr.w	r1, [r5, #42]	; 0x2a

	if( ( ucTCPFlags & tcpTCP_FLAG_FIN ) != 0U )
 8007e2e:	f895 302f 	ldrb.w	r3, [r5, #47]	; 0x2f
 8007e32:	f013 0f01 	tst.w	r3, #1
 8007e36:	d004      	beq.n	8007e42 <prvTCPHandleFin+0x1e>
	{
		pxTCPWindow->rx.ulCurrentSequenceNumber = pxTCPWindow->rx.ulFINSequenceNumber + 1U;
 8007e38:	f8d0 30ec 	ldr.w	r3, [r0, #236]	; 0xec
 8007e3c:	3301      	adds	r3, #1
 8007e3e:	f8c0 30e8 	str.w	r3, [r0, #232]	; 0xe8
	}
	if( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED )
 8007e42:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8007e46:	f013 0f40 	tst.w	r3, #64	; 0x40
 8007e4a:	d10a      	bne.n	8007e62 <prvTCPHandleFin+0x3e>
	{
		/* We haven't yet replied with a FIN, do so now. */
		pxTCPWindow->tx.ulFINSequenceNumber = pxTCPWindow->tx.ulCurrentSequenceNumber;
 8007e4c:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
 8007e50:	f8c4 30fc 	str.w	r3, [r4, #252]	; 0xfc
		pxSocket->u.xTCP.bits.bFinSent = pdTRUE_UNSIGNED;
 8007e54:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8007e58:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8007e5c:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
 8007e60:	e015      	b.n	8007e8e <prvTCPHandleFin+0x6a>
	}
	else
	{
		/* We did send a FIN already, see if it's ACK'd. */
		if( ulAckNr == ( pxTCPWindow->tx.ulFINSequenceNumber + 1UL ) )
 8007e62:	f8d4 30fc 	ldr.w	r3, [r4, #252]	; 0xfc
 8007e66:	1c58      	adds	r0, r3, #1
	&( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + xIPHeaderSize( pxNetworkBuffer ) ] ) );
TCPHeader_t *pxTCPHeader = &( pxProtocolHeaders->xTCPHeader );
uint8_t ucIntermediateResult = 0, ucTCPFlags = pxTCPHeader->ucTCPFlags;
TCPWindow_t *pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
BaseType_t xSendLength = 0;
uint32_t ulAckNr = FreeRTOS_ntohl( pxTCPHeader->ulAckNr );
 8007e68:	0e0a      	lsrs	r2, r1, #24
 8007e6a:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 8007e6e:	f401 437f 	and.w	r3, r1, #65280	; 0xff00
 8007e72:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
 8007e76:	f401 037f 	and.w	r3, r1, #16711680	; 0xff0000
 8007e7a:	ea42 2313 	orr.w	r3, r2, r3, lsr #8
		pxSocket->u.xTCP.bits.bFinSent = pdTRUE_UNSIGNED;
	}
	else
	{
		/* We did send a FIN already, see if it's ACK'd. */
		if( ulAckNr == ( pxTCPWindow->tx.ulFINSequenceNumber + 1UL ) )
 8007e7e:	4298      	cmp	r0, r3
 8007e80:	d105      	bne.n	8007e8e <prvTCPHandleFin+0x6a>
		{
			pxSocket->u.xTCP.bits.bFinAcked = pdTRUE_UNSIGNED;
 8007e82:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 8007e86:	f043 0301 	orr.w	r3, r3, #1
 8007e8a:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
		}
	}

	if( pxSocket->u.xTCP.bits.bFinAcked == pdFALSE_UNSIGNED )
 8007e8e:	f894 2042 	ldrb.w	r2, [r4, #66]	; 0x42
 8007e92:	f012 0f01 	tst.w	r2, #1
 8007e96:	d10b      	bne.n	8007eb0 <prvTCPHandleFin+0x8c>
	{
		pxTCPWindow->tx.ulCurrentSequenceNumber = pxTCPWindow->tx.ulFINSequenceNumber;
 8007e98:	f8d4 30fc 	ldr.w	r3, [r4, #252]	; 0xfc
 8007e9c:	f8c4 30f8 	str.w	r3, [r4, #248]	; 0xf8
		pxTCPHeader->ucTCPFlags = ( uint8_t ) tcpTCP_FLAG_ACK | ( uint8_t ) tcpTCP_FLAG_FIN;
 8007ea0:	2311      	movs	r3, #17
 8007ea2:	f885 302f 	strb.w	r3, [r5, #47]	; 0x2f

		/* And wait for the final ACK. */
		vTCPStateChange( pxSocket, eLAST_ACK );
 8007ea6:	4620      	mov	r0, r4
 8007ea8:	210a      	movs	r1, #10
 8007eaa:	f7ff fbdf 	bl	800766c <vTCPStateChange>
 8007eae:	e018      	b.n	8007ee2 <prvTCPHandleFin+0xbe>
	}
	else
	{
		/* Our FIN has been ACK'd, the outgoing sequence number is now fixed. */
		pxTCPWindow->tx.ulCurrentSequenceNumber = pxTCPWindow->tx.ulFINSequenceNumber + 1U;
 8007eb0:	f8d4 30fc 	ldr.w	r3, [r4, #252]	; 0xfc
 8007eb4:	3301      	adds	r3, #1
 8007eb6:	f8c4 30f8 	str.w	r3, [r4, #248]	; 0xf8
		if( pxSocket->u.xTCP.bits.bFinRecv == pdFALSE_UNSIGNED )
 8007eba:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8007ebe:	f013 0f80 	tst.w	r3, #128	; 0x80
 8007ec2:	d103      	bne.n	8007ecc <prvTCPHandleFin+0xa8>
		{
			/* We have sent out a FIN but the peer hasn't replied with a FIN
			yet. Do nothing for the moment. */
			pxTCPHeader->ucTCPFlags = 0U;
 8007ec4:	2300      	movs	r3, #0
 8007ec6:	f885 302f 	strb.w	r3, [r5, #47]	; 0x2f
 8007eca:	e00a      	b.n	8007ee2 <prvTCPHandleFin+0xbe>
		}
		else
		{
			if( pxSocket->u.xTCP.bits.bFinLast == pdFALSE_UNSIGNED )
 8007ecc:	f012 0f02 	tst.w	r2, #2
			{
				/* This is the third of the three-way hand shake: the last
				ACK. */
				pxTCPHeader->ucTCPFlags = tcpTCP_FLAG_ACK;
 8007ed0:	bf0c      	ite	eq
 8007ed2:	2310      	moveq	r3, #16
			}
			else
			{
				/* The other party started the closure, so we just wait for the
				last ACK. */
				pxTCPHeader->ucTCPFlags = 0U;
 8007ed4:	2300      	movne	r3, #0
 8007ed6:	f885 302f 	strb.w	r3, [r5, #47]	; 0x2f
			}

			/* And wait for the user to close this socket. */
			vTCPStateChange( pxSocket, eCLOSE_WAIT );
 8007eda:	4620      	mov	r0, r4
 8007edc:	2108      	movs	r1, #8
 8007ede:	f7ff fbc5 	bl	800766c <vTCPStateChange>
		}
	}

	pxTCPWindow->ulOurSequenceNumber = pxTCPWindow->tx.ulCurrentSequenceNumber;
 8007ee2:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
 8007ee6:	f8c4 3104 	str.w	r3, [r4, #260]	; 0x104

	if( pxTCPHeader->ucTCPFlags != 0U )
 8007eea:	f895 302f 	ldrb.w	r3, [r5, #47]	; 0x2f
 8007eee:	b123      	cbz	r3, 8007efa <prvTCPHandleFin+0xd6>
	{
		ucIntermediateResult = uxIPHeaderSizeSocket( pxSocket ) + ipSIZE_OF_TCP_HEADER + pxTCPWindow->ucOptionLength;
 8007ef0:	f894 0114 	ldrb.w	r0, [r4, #276]	; 0x114
 8007ef4:	3028      	adds	r0, #40	; 0x28
		xSendLength = ( BaseType_t ) ucIntermediateResult;
 8007ef6:	b2c0      	uxtb	r0, r0
 8007ef8:	e000      	b.n	8007efc <prvTCPHandleFin+0xd8>
ProtocolHeaders_t *pxProtocolHeaders = ipCAST_PTR_TO_TYPE_PTR( ProtocolHeaders_t,
	&( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + xIPHeaderSize( pxNetworkBuffer ) ] ) );
TCPHeader_t *pxTCPHeader = &( pxProtocolHeaders->xTCPHeader );
uint8_t ucIntermediateResult = 0, ucTCPFlags = pxTCPHeader->ucTCPFlags;
TCPWindow_t *pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
BaseType_t xSendLength = 0;
 8007efa:	2000      	movs	r0, #0
	{
		ucIntermediateResult = uxIPHeaderSizeSocket( pxSocket ) + ipSIZE_OF_TCP_HEADER + pxTCPWindow->ucOptionLength;
		xSendLength = ( BaseType_t ) ucIntermediateResult;
	}

	pxTCPHeader->ucTCPOffset = ( uint8_t ) ( ( ipSIZE_OF_TCP_HEADER + pxTCPWindow->ucOptionLength ) << 2 );
 8007efc:	f894 3114 	ldrb.w	r3, [r4, #276]	; 0x114
 8007f00:	3314      	adds	r3, #20
 8007f02:	009b      	lsls	r3, r3, #2
 8007f04:	f885 302e 	strb.w	r3, [r5, #46]	; 0x2e
			pxTCPWindow->ulOurSequenceNumber - pxTCPWindow->tx.ulFirstSequenceNumber,
			pxTCPWindow->rx.ulCurrentSequenceNumber - pxTCPWindow->rx.ulFirstSequenceNumber ) );
	}

	return xSendLength;
}
 8007f08:	bd38      	pop	{r3, r4, r5, pc}
 8007f0a:	bf00      	nop

08007f0c <xProcessReceivedTCPPacket>:
 *		prvTCPSendRepeated()
 *			prvTCPReturnPacket()		// Prepare for returning
 *			xNetworkInterfaceOutput()	// Sends data to the NIC
*/
BaseType_t xProcessReceivedTCPPacket( NetworkBufferDescriptor_t *pxDescriptor )
{
 8007f0c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007f10:	b08b      	sub	sp, #44	; 0x2c
/* Function might modify the parameter. */
NetworkBufferDescriptor_t *pxNetworkBuffer = pxDescriptor;
 8007f12:	9009      	str	r0, [sp, #36]	; 0x24

/* Map the buffer onto a ProtocolHeaders_t struct for easy access to the fields. */
const ProtocolHeaders_t *pxProtocolHeaders = ipCAST_CONST_PTR_TO_CONST_TYPE_PTR( ProtocolHeaders_t,
 8007f14:	f8d0 9018 	ldr.w	r9, [r0, #24]
	&( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + xIPHeaderSize( pxNetworkBuffer ) ] ) );
FreeRTOS_Socket_t *pxSocket;
uint16_t ucTCPFlags = pxProtocolHeaders->xTCPHeader.ucTCPFlags;
 8007f18:	f899 b02f 	ldrb.w	fp, [r9, #47]	; 0x2f
uint32_t ulLocalIP;
uint16_t xLocalPort = FreeRTOS_htons( pxProtocolHeaders->xTCPHeader.usDestinationPort );
 8007f1c:	f8b9 1024 	ldrh.w	r1, [r9, #36]	; 0x24
uint16_t xRemotePort = FreeRTOS_htons( pxProtocolHeaders->xTCPHeader.usSourcePort );
 8007f20:	f8b9 e022 	ldrh.w	lr, [r9, #34]	; 0x22
uint32_t ulRemoteIP;
uint32_t ulSequenceNumber = FreeRTOS_ntohl( pxProtocolHeaders->xTCPHeader.ulSequenceNumber );
 8007f24:	f8d9 5026 	ldr.w	r5, [r9, #38]	; 0x26
uint32_t ulAckNumber = FreeRTOS_ntohl( pxProtocolHeaders->xTCPHeader.ulAckNr );;
 8007f28:	f8d9 602a 	ldr.w	r6, [r9, #42]	; 0x2a
BaseType_t xResult = pdPASS;
configASSERT( pxNetworkBuffer != NULL );
 8007f2c:	b940      	cbnz	r0, 8007f40 <xProcessReceivedTCPPacket+0x34>
 8007f2e:	f04f 0314 	mov.w	r3, #20
 8007f32:	f383 8811 	msr	BASEPRI, r3
 8007f36:	f3bf 8f6f 	isb	sy
 8007f3a:	f3bf 8f4f 	dsb	sy
 8007f3e:	e7fe      	b.n	8007f3e <xProcessReceivedTCPPacket+0x32>
configASSERT( pxNetworkBuffer->pucEthernetBuffer != NULL );
 8007f40:	f1b9 0f00 	cmp.w	r9, #0
 8007f44:	d108      	bne.n	8007f58 <xProcessReceivedTCPPacket+0x4c>
 8007f46:	f04f 0314 	mov.w	r3, #20
 8007f4a:	f383 8811 	msr	BASEPRI, r3
 8007f4e:	f3bf 8f6f 	isb	sy
 8007f52:	f3bf 8f4f 	dsb	sy
 8007f56:	e7fe      	b.n	8007f56 <xProcessReceivedTCPPacket+0x4a>
const IPHeader_t *pxIPHeader;

	/* Check for a minimum packet size. */
	if( pxNetworkBuffer->xDataLength < ( ipSIZE_OF_ETH_HEADER + xIPHeaderSize( pxNetworkBuffer ) + ipSIZE_OF_TCP_HEADER ) )
 8007f58:	69c3      	ldr	r3, [r0, #28]
 8007f5a:	2b35      	cmp	r3, #53	; 0x35
 8007f5c:	f240 8547 	bls.w	80089ee <xProcessReceivedTCPPacket+0xae2>
	}
	else
	{
		/* Map the ethernet buffer onto the IPHeader_t struct for easy access to the fields. */
		pxIPHeader = ipCAST_CONST_PTR_TO_CONST_TYPE_PTR( IPHeader_t, &( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER ] ) );
		ulLocalIP = FreeRTOS_htonl( pxIPHeader->ulDestinationIPAddress );
 8007f60:	f8d9 301e 	ldr.w	r3, [r9, #30]
		ulRemoteIP = FreeRTOS_htonl( pxIPHeader->ulSourceIPAddress );
 8007f64:	f8d9 201a 	ldr.w	r2, [r9, #26]
	}
	else
	{
		/* Map the ethernet buffer onto the IPHeader_t struct for easy access to the fields. */
		pxIPHeader = ipCAST_CONST_PTR_TO_CONST_TYPE_PTR( IPHeader_t, &( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER ] ) );
		ulLocalIP = FreeRTOS_htonl( pxIPHeader->ulDestinationIPAddress );
 8007f68:	0618      	lsls	r0, r3, #24
 8007f6a:	ea40 6013 	orr.w	r0, r0, r3, lsr #24
 8007f6e:	f403 447f 	and.w	r4, r3, #65280	; 0xff00
 8007f72:	ea40 2004 	orr.w	r0, r0, r4, lsl #8
 8007f76:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
const ProtocolHeaders_t *pxProtocolHeaders = ipCAST_CONST_PTR_TO_CONST_TYPE_PTR( ProtocolHeaders_t,
	&( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + xIPHeaderSize( pxNetworkBuffer ) ] ) );
FreeRTOS_Socket_t *pxSocket;
uint16_t ucTCPFlags = pxProtocolHeaders->xTCPHeader.ucTCPFlags;
uint32_t ulLocalIP;
uint16_t xLocalPort = FreeRTOS_htons( pxProtocolHeaders->xTCPHeader.usDestinationPort );
 8007f7a:	0a0c      	lsrs	r4, r1, #8
 8007f7c:	ea44 2101 	orr.w	r1, r4, r1, lsl #8
	else
	{
		/* Map the ethernet buffer onto the IPHeader_t struct for easy access to the fields. */
		pxIPHeader = ipCAST_CONST_PTR_TO_CONST_TYPE_PTR( IPHeader_t, &( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER ] ) );
		ulLocalIP = FreeRTOS_htonl( pxIPHeader->ulDestinationIPAddress );
		ulRemoteIP = FreeRTOS_htonl( pxIPHeader->ulSourceIPAddress );
 8007f80:	0614      	lsls	r4, r2, #24
 8007f82:	ea44 6412 	orr.w	r4, r4, r2, lsr #24
 8007f86:	f402 477f 	and.w	r7, r2, #65280	; 0xff00
 8007f8a:	ea44 2407 	orr.w	r4, r4, r7, lsl #8
 8007f8e:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
	&( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + xIPHeaderSize( pxNetworkBuffer ) ] ) );
FreeRTOS_Socket_t *pxSocket;
uint16_t ucTCPFlags = pxProtocolHeaders->xTCPHeader.ucTCPFlags;
uint32_t ulLocalIP;
uint16_t xLocalPort = FreeRTOS_htons( pxProtocolHeaders->xTCPHeader.usDestinationPort );
uint16_t xRemotePort = FreeRTOS_htons( pxProtocolHeaders->xTCPHeader.usSourcePort );
 8007f92:	ea4f 271e 	mov.w	r7, lr, lsr #8
 8007f96:	ea47 270e 	orr.w	r7, r7, lr, lsl #8
		ulLocalIP = FreeRTOS_htonl( pxIPHeader->ulDestinationIPAddress );
		ulRemoteIP = FreeRTOS_htonl( pxIPHeader->ulSourceIPAddress );

		/* Find the destination socket, and if not found: return a socket listing to
		the destination PORT. */
		pxSocket = ( FreeRTOS_Socket_t * ) pxTCPSocketLookup( ulLocalIP, xLocalPort, ulRemoteIP, xRemotePort );
 8007f9a:	ea40 2013 	orr.w	r0, r0, r3, lsr #8
 8007f9e:	b289      	uxth	r1, r1
 8007fa0:	ea44 2212 	orr.w	r2, r4, r2, lsr #8
 8007fa4:	b2bb      	uxth	r3, r7
 8007fa6:	f7fe fdc7 	bl	8006b38 <pxTCPSocketLookup>

		if( ( pxSocket == NULL ) || ( prvTCPSocketIsActive( ipNUMERIC_CAST( eIPTCPState_t, pxSocket->u.xTCP.ucTCPState ) ) == pdFALSE ) )
 8007faa:	4604      	mov	r4, r0
 8007fac:	b158      	cbz	r0, 8007fc6 <xProcessReceivedTCPPacket+0xba>
 8007fae:	f890 3053 	ldrb.w	r3, [r0, #83]	; 0x53
 * Non-active sockets are waiting for user action, either connect()
 * or close(). */
static BaseType_t prvTCPSocketIsActive( eIPTCPState_t xStatus )
{
BaseType_t xResult;
	switch( xStatus )
 8007fb2:	2b0b      	cmp	r3, #11
 8007fb4:	d815      	bhi.n	8007fe2 <xProcessReceivedTCPPacket+0xd6>
 8007fb6:	e8df f003 	tbb	[pc, r3]
 8007fba:	1406      	.short	0x1406
 8007fbc:	14141414 	.word	0x14141414
 8007fc0:	06060614 	.word	0x06060614
 8007fc4:	0614      	.short	0x0614
			the other party will get a ECONN error.  There are two exceptions:
			1) A packet that already has the RST flag set.
			2) A packet that only has the ACK flag set.
			A packet with only the ACK flag set might be the last ACK in
			a three-way hand-shake that closes a connection. */
			if( ( ( ucTCPFlags & tcpTCP_FLAG_CTRL ) != tcpTCP_FLAG_ACK ) &&
 8007fc6:	f00b 031f 	and.w	r3, fp, #31
 8007fca:	2b10      	cmp	r3, #16
 8007fcc:	f000 8515 	beq.w	80089fa <xProcessReceivedTCPPacket+0xaee>
 8007fd0:	f01b 0f04 	tst.w	fp, #4
 8007fd4:	f040 8511 	bne.w	80089fa <xProcessReceivedTCPPacket+0xaee>
				( ( ucTCPFlags & tcpTCP_FLAG_RST ) == 0U ) )
			{
				( void ) prvTCPSendReset( pxNetworkBuffer );
 8007fd8:	9809      	ldr	r0, [sp, #36]	; 0x24
 8007fda:	f7ff fab7 	bl	800754c <prvTCPSendReset>
 8007fde:	f000 bd0c 	b.w	80089fa <xProcessReceivedTCPPacket+0xaee>
			/* The packet can't be handled. */
			xResult = pdFAIL;
		}
		else
		{
			pxSocket->u.xTCP.ucRepCount = 0U;
 8007fe2:	2200      	movs	r2, #0
 8007fe4:	f880 2052 	strb.w	r2, [r0, #82]	; 0x52

			if( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eTCP_LISTEN )
 8007fe8:	2b01      	cmp	r3, #1
 8007fea:	f040 80c4 	bne.w	8008176 <xProcessReceivedTCPPacket+0x26a>
			{
				/* The matching socket is in a listening state.  Test if the peer
				has set the SYN flag. */
				if( ( ucTCPFlags & tcpTCP_FLAG_CTRL ) != tcpTCP_FLAG_SYN )
 8007fee:	f00b 031f 	and.w	r3, fp, #31
 8007ff2:	2b02      	cmp	r3, #2
 8007ff4:	d008      	beq.n	8008008 <xProcessReceivedTCPPacket+0xfc>
					FreeRTOS_debug_printf( ( "TCP: Server can't handle flags: %s from %lxip:%u to port %u\n",
						prvTCPFlagMeaning( ( UBaseType_t ) ucTCPFlags ), ulRemoteIP, xRemotePort, xLocalPort ) );
					}
					#endif /* ipconfigHAS_DEBUG_PRINTF */

					if( ( ucTCPFlags & tcpTCP_FLAG_RST ) == 0U )
 8007ff6:	f01b 0f04 	tst.w	fp, #4
 8007ffa:	f040 84fe 	bne.w	80089fa <xProcessReceivedTCPPacket+0xaee>
					{
						( void ) prvTCPSendReset( pxNetworkBuffer );
 8007ffe:	9809      	ldr	r0, [sp, #36]	; 0x24
 8008000:	f7ff faa4 	bl	800754c <prvTCPSendReset>
 8008004:	f000 bcf9 	b.w	80089fa <xProcessReceivedTCPPacket+0xaee>
				else
				{
					/* prvHandleListen() will either return a newly created socket
					(if bReuseSocket is false), otherwise it returns the current
					socket which will later get connected. */
					pxSocket = prvHandleListen( pxSocket, pxNetworkBuffer );
 8008008:	9e09      	ldr	r6, [sp, #36]	; 0x24
/*-----------------------------------------------------------*/

static FreeRTOS_Socket_t *prvHandleListen( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t *pxNetworkBuffer )
{
/* Map the ethernet buffer onto a TCPPacket_t struct for easy access to the fields. */
const TCPPacket_t * pxTCPPacket = ipCAST_CONST_PTR_TO_CONST_TYPE_PTR( TCPPacket_t, pxNetworkBuffer->pucEthernetBuffer );
 800800a:	f8d6 8018 	ldr.w	r8, [r6, #24]
FreeRTOS_Socket_t *pxReturn = NULL;
uint32_t ulInitialSequenceNumber;

	/* Assume that a new Initial Sequence Number will be required. Request
	it now in order to fail out if necessary. */
	ulInitialSequenceNumber = ulApplicationGetNextSequenceNumber( *ipLOCAL_IP_ADDRESS_POINTER,
 800800e:	4bd0      	ldr	r3, [pc, #832]	; (8008350 <xProcessReceivedTCPPacket+0x444>)
 8008010:	6958      	ldr	r0, [r3, #20]
 8008012:	8ca1      	ldrh	r1, [r4, #36]	; 0x24
 8008014:	f8d8 201a 	ldr.w	r2, [r8, #26]
 8008018:	f8b8 3022 	ldrh.w	r3, [r8, #34]	; 0x22
 800801c:	f002 fd80 	bl	800ab20 <ulApplicationGetNextSequenceNumber>
																  pxTCPPacket->xIPHeader.ulSourceIPAddress,
																  pxTCPPacket->xTCPHeader.usSourcePort );

	/* A pure SYN (without ACK) has come in, create a new socket to answer
	it. */
	if( ulInitialSequenceNumber != 0UL )
 8008020:	4607      	mov	r7, r0
 8008022:	2800      	cmp	r0, #0
 8008024:	f000 852a 	beq.w	8008a7c <xProcessReceivedTCPPacket+0xb70>
	{
		if( pxSocket->u.xTCP.bits.bReuseSocket != pdFALSE_UNSIGNED )
 8008028:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 800802c:	f013 0f08 	tst.w	r3, #8
 8008030:	d006      	beq.n	8008040 <xProcessReceivedTCPPacket+0x134>
		{
			/* The flag bReuseSocket indicates that the same instance of the
			listening socket should be used for the connection. */
			pxReturn = pxSocket;
			pxSocket->u.xTCP.bits.bPassQueued = pdTRUE_UNSIGNED;
 8008032:	f043 0304 	orr.w	r3, r3, #4
 8008036:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
			pxSocket->u.xTCP.pxPeerSocket = pxSocket;
 800803a:	6564      	str	r4, [r4, #84]	; 0x54
	{
		if( pxSocket->u.xTCP.bits.bReuseSocket != pdFALSE_UNSIGNED )
		{
			/* The flag bReuseSocket indicates that the same instance of the
			listening socket should be used for the connection. */
			pxReturn = pxSocket;
 800803c:	4625      	mov	r5, r4
 800803e:	e05b      	b.n	80080f8 <xProcessReceivedTCPPacket+0x1ec>
		{
			/* The socket does not have the bReuseSocket flag set meaning create a
			new socket when a connection comes in. */
			pxReturn = NULL;

			if( pxSocket->u.xTCP.usChildCount >= pxSocket->u.xTCP.usBacklog )
 8008040:	f8b4 204e 	ldrh.w	r2, [r4, #78]	; 0x4e
 8008044:	f8b4 3050 	ldrh.w	r3, [r4, #80]	; 0x50
 8008048:	429a      	cmp	r2, r3
 800804a:	d304      	bcc.n	8008056 <xProcessReceivedTCPPacket+0x14a>
				FreeRTOS_printf( ( "Check: Socket %u already has %u / %u child%s\n",
					pxSocket->usLocalPort,
					pxSocket->u.xTCP.usChildCount,
					pxSocket->u.xTCP.usBacklog,
					( pxSocket->u.xTCP.usChildCount == 1U ) ? "" : "ren" ) );
				( void ) prvTCPSendReset( pxNetworkBuffer );
 800804c:	4630      	mov	r0, r6
 800804e:	f7ff fa7d 	bl	800754c <prvTCPSendReset>
 8008052:	f000 bd13 	b.w	8008a7c <xProcessReceivedTCPPacket+0xb70>
			}
			else
			{
				FreeRTOS_Socket_t *pxNewSocket = ( FreeRTOS_Socket_t * )
 8008056:	2002      	movs	r0, #2
 8008058:	2101      	movs	r1, #1
 800805a:	2206      	movs	r2, #6
 800805c:	f7fd fde0 	bl	8005c20 <FreeRTOS_socket>
 8008060:	4605      	mov	r5, r0
					FreeRTOS_socket( FREERTOS_AF_INET, FREERTOS_SOCK_STREAM, FREERTOS_IPPROTO_TCP );

				if( ( pxNewSocket == NULL ) || ( pxNewSocket == FREERTOS_INVALID_SOCKET ) )
 8008062:	1e43      	subs	r3, r0, #1
 8008064:	f113 0f03 	cmn.w	r3, #3
 8008068:	d904      	bls.n	8008074 <xProcessReceivedTCPPacket+0x168>
				{
					FreeRTOS_debug_printf( ( "TCP: Listen: new socket failed\n" ) );
					( void ) prvTCPSendReset( pxNetworkBuffer );
 800806a:	4630      	mov	r0, r6
 800806c:	f7ff fa6e 	bl	800754c <prvTCPSendReset>
 8008070:	f000 bd04 	b.w	8008a7c <xProcessReceivedTCPPacket+0xb70>
static BaseType_t prvTCPSocketCopy( FreeRTOS_Socket_t *pxNewSocket, FreeRTOS_Socket_t *pxSocket )
{
struct freertos_sockaddr xAddress;
BaseType_t xResult;

	pxNewSocket->xReceiveBlockTime = pxSocket->xReceiveBlockTime;
 8008074:	69e3      	ldr	r3, [r4, #28]
 8008076:	61c3      	str	r3, [r0, #28]
	pxNewSocket->xSendBlockTime = pxSocket->xSendBlockTime;
 8008078:	6a23      	ldr	r3, [r4, #32]
 800807a:	6203      	str	r3, [r0, #32]
	pxNewSocket->ucSocketOptions = pxSocket->ucSocketOptions;
 800807c:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26
 8008080:	f880 3026 	strb.w	r3, [r0, #38]	; 0x26
	pxNewSocket->u.xTCP.uxRxStreamSize = pxSocket->u.xTCP.uxRxStreamSize;
 8008084:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8008086:	66c3      	str	r3, [r0, #108]	; 0x6c
	pxNewSocket->u.xTCP.uxTxStreamSize = pxSocket->u.xTCP.uxTxStreamSize;
 8008088:	6f23      	ldr	r3, [r4, #112]	; 0x70
 800808a:	6703      	str	r3, [r0, #112]	; 0x70
	pxNewSocket->u.xTCP.uxLittleSpace = pxSocket->u.xTCP.uxLittleSpace;
 800808c:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800808e:	6643      	str	r3, [r0, #100]	; 0x64
	pxNewSocket->u.xTCP.uxEnoughSpace = pxSocket->u.xTCP.uxEnoughSpace;
 8008090:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 8008092:	6683      	str	r3, [r0, #104]	; 0x68
	pxNewSocket->u.xTCP.uxRxWinSize  = pxSocket->u.xTCP.uxRxWinSize;
 8008094:	f8d4 30d0 	ldr.w	r3, [r4, #208]	; 0xd0
 8008098:	f8c0 30d0 	str.w	r3, [r0, #208]	; 0xd0
	pxNewSocket->u.xTCP.uxTxWinSize  = pxSocket->u.xTCP.uxTxWinSize;
 800809c:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 80080a0:	f8c0 30d4 	str.w	r3, [r0, #212]	; 0xd4

	#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
	{
		/* Child socket of listening sockets will inherit the Socket Set
		Otherwise the owner has no chance of including it into the set. */
		if( pxSocket->pxSocketSet != NULL )
 80080a4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80080a6:	b123      	cbz	r3, 80080b2 <xProcessReceivedTCPPacket+0x1a6>
		{
			pxNewSocket->pxSocketSet = pxSocket->pxSocketSet;
 80080a8:	62c3      	str	r3, [r0, #44]	; 0x2c
			pxNewSocket->xSelectBits = pxSocket->xSelectBits | ( ( EventBits_t ) eSELECT_READ ) | ( ( EventBits_t ) eSELECT_EXCEPT );
 80080aa:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80080ac:	f043 0305 	orr.w	r3, r3, #5
 80080b0:	6303      	str	r3, [r0, #48]	; 0x30
		}
	}
	#endif /* ipconfigSUPPORT_SELECT_FUNCTION */

	/* And bind it to the same local port as its parent. */
	xAddress.sin_addr = *ipLOCAL_IP_ADDRESS_POINTER;
 80080b2:	4ba7      	ldr	r3, [pc, #668]	; (8008350 <xProcessReceivedTCPPacket+0x444>)
 80080b4:	695b      	ldr	r3, [r3, #20]
 80080b6:	9308      	str	r3, [sp, #32]
	xAddress.sin_port = FreeRTOS_htons( pxSocket->usLocalPort );
 80080b8:	8ca2      	ldrh	r2, [r4, #36]	; 0x24
 80080ba:	0a13      	lsrs	r3, r2, #8
 80080bc:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80080c0:	f8ad 301e 	strh.w	r3, [sp, #30]
		orphan temporarily.  Once this socket is really connected, the owner of
		the server socket will be notified. */

		/* When bPassQueued is true, the socket is an orphan until it gets
		connected. */
		pxNewSocket->u.xTCP.bits.bPassQueued = pdTRUE_UNSIGNED;
 80080c4:	f895 3040 	ldrb.w	r3, [r5, #64]	; 0x40
 80080c8:	f043 0304 	orr.w	r3, r3, #4
 80080cc:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
		pxNewSocket->u.xTCP.pxPeerSocket = pxSocket;
 80080d0:	656c      	str	r4, [r5, #84]	; 0x54
			pxSocket->u.xTCP.pxPeerSocket = pxNewSocket;
		}
	}
	#endif

	pxSocket->u.xTCP.usChildCount++;
 80080d2:	f8b4 304e 	ldrh.w	r3, [r4, #78]	; 0x4e
 80080d6:	3301      	adds	r3, #1
 80080d8:	f8a4 304e 	strh.w	r3, [r4, #78]	; 0x4e
		pxSocket->u.xTCP.usChildCount,
		pxSocket->u.xTCP.usBacklog,
		( pxSocket->u.xTCP.usChildCount == 1U ) ? "" : "ren" ) );

	/* Now bind the child socket to the same port as the listening socket. */
	if( vSocketBind ( pxNewSocket, &xAddress, sizeof( xAddress ), pdTRUE ) != 0 )
 80080dc:	4628      	mov	r0, r5
 80080de:	a907      	add	r1, sp, #28
 80080e0:	2208      	movs	r2, #8
 80080e2:	2301      	movs	r3, #1
 80080e4:	f7fe f80c 	bl	8006100 <vSocketBind>
 80080e8:	2800      	cmp	r0, #0
 80080ea:	f000 8482 	beq.w	80089f2 <xProcessReceivedTCPPacket+0xae6>
	{
		FreeRTOS_debug_printf( ( "TCP: Listen: new socket bind error\n" ) );
		( void ) vSocketClose( pxNewSocket );
 80080ee:	4628      	mov	r0, r5
 80080f0:	f7fe f8be 	bl	8006270 <vSocketClose>
 80080f4:	2400      	movs	r4, #0
 80080f6:	e039      	b.n	800816c <xProcessReceivedTCPPacket+0x260>
	}

	if( ( ulInitialSequenceNumber != 0U ) && ( pxReturn != NULL ) )
	{
	/* Map the byte stream onto the ProtocolHeaders_t for easy access to the fields. */
	const ProtocolHeaders_t *pxProtocolHeaders = ipCAST_CONST_PTR_TO_CONST_TYPE_PTR( ProtocolHeaders_t,
 80080f8:	69b1      	ldr	r1, [r6, #24]
		&( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + xIPHeaderSize( pxNetworkBuffer ) ] ) );

		pxReturn->u.xTCP.usRemotePort = FreeRTOS_htons( pxTCPPacket->xTCPHeader.usSourcePort );
 80080fa:	f8b8 2022 	ldrh.w	r2, [r8, #34]	; 0x22
 80080fe:	0a13      	lsrs	r3, r2, #8
 8008100:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8008104:	87ab      	strh	r3, [r5, #60]	; 0x3c
		pxReturn->u.xTCP.ulRemoteIP = FreeRTOS_htonl( pxTCPPacket->xIPHeader.ulSourceIPAddress );
 8008106:	f8d8 201a 	ldr.w	r2, [r8, #26]
 800810a:	0613      	lsls	r3, r2, #24
 800810c:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 8008110:	f402 407f 	and.w	r0, r2, #65280	; 0xff00
 8008114:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 8008118:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
 800811c:	ea43 2312 	orr.w	r3, r3, r2, lsr #8
 8008120:	63ab      	str	r3, [r5, #56]	; 0x38
		pxReturn->u.xTCP.xTCPWindow.ulOurSequenceNumber = ulInitialSequenceNumber;
 8008122:	f8c5 7104 	str.w	r7, [r5, #260]	; 0x104

		/* Here is the SYN action. */
		pxReturn->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber = FreeRTOS_ntohl( pxProtocolHeaders->xTCPHeader.ulSequenceNumber );
 8008126:	f8d1 2026 	ldr.w	r2, [r1, #38]	; 0x26
 800812a:	0613      	lsls	r3, r2, #24
 800812c:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 8008130:	f402 417f 	and.w	r1, r2, #65280	; 0xff00
 8008134:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8008138:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
 800813c:	ea43 2312 	orr.w	r3, r3, r2, lsr #8
 8008140:	f8c5 30e8 	str.w	r3, [r5, #232]	; 0xe8
		ulMSS = FreeRTOS_min_uint32( ( uint32_t ) tcpREDUCED_MSS_THROUGH_INTERNET, ulMSS );
	}

	FreeRTOS_debug_printf( ( "prvSocketSetMSS: %lu bytes for %lxip:%u\n", ulMSS, pxSocket->u.xTCP.ulRemoteIP, pxSocket->u.xTCP.usRemotePort ) );

	pxSocket->u.xTCP.usInitMSS = ( uint16_t ) ulMSS;
 8008144:	f44f 6391 	mov.w	r3, #1160	; 0x488
 8008148:	f8a5 304c 	strh.w	r3, [r5, #76]	; 0x4c
	pxSocket->u.xTCP.usCurMSS  = ( uint16_t ) ulMSS;
 800814c:	f8a5 304a 	strh.w	r3, [r5, #74]	; 0x4a

		/* Here is the SYN action. */
		pxReturn->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber = FreeRTOS_ntohl( pxProtocolHeaders->xTCPHeader.ulSequenceNumber );
		prvSocketSetMSS( pxReturn );

		prvTCPCreateWindow( pxReturn );
 8008150:	4628      	mov	r0, r5
 8008152:	f7ff fa0b 	bl	800756c <prvTCPCreateWindow>

		vTCPStateChange( pxReturn, eSYN_FIRST );
 8008156:	4628      	mov	r0, r5
 8008158:	2103      	movs	r1, #3
 800815a:	f7ff fa87 	bl	800766c <vTCPStateChange>

		/* Make a copy of the header up to the TCP header.  It is needed later
		on, whenever data must be sent to the peer. */
		( void ) memcpy( ( void * ) ( pxReturn->u.xTCP.xPacket.u.ucLastPacket ), ( const void * ) ( pxNetworkBuffer->pucEthernetBuffer ), sizeof( pxReturn->u.xTCP.xPacket.u.ucLastPacket ) );
 800815e:	f105 0082 	add.w	r0, r5, #130	; 0x82
 8008162:	69b1      	ldr	r1, [r6, #24]
 8008164:	2246      	movs	r2, #70	; 0x46
 8008166:	f001 febd 	bl	8009ee4 <memcpy>
 800816a:	462c      	mov	r4, r5
									 ipSIZE_OF_TCP_HEADER );
				}
			}
		}

		if( xResult != pdFAIL )
 800816c:	2c00      	cmp	r4, #0
 800816e:	d161      	bne.n	8008234 <xProcessReceivedTCPPacket+0x328>
 8008170:	2000      	movs	r0, #0
 8008172:	f000 bc92 	b.w	8008a9a <xProcessReceivedTCPPacket+0xb8e>
			}	/* if( pxSocket->u.xTCP.ucTCPState == eTCP_LISTEN ). */
			else
			{
				/* This is not a socket in listening mode. Check for the RST
				flag. */
				if( ( ucTCPFlags & tcpTCP_FLAG_RST ) != 0U )
 8008176:	f01b 0f04 	tst.w	fp, #4
 800817a:	d042      	beq.n	8008202 <xProcessReceivedTCPPacket+0x2f6>
				{
					FreeRTOS_debug_printf( ( "TCP: RST received from %lxip:%u for %u\n", ulRemoteIP, xRemotePort, xLocalPort ) );

					/* Implement https://tools.ietf.org/html/rfc5961#section-3.2. */
					if( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eCONNECT_SYN )
 800817c:	2b02      	cmp	r3, #2
 800817e:	d115      	bne.n	80081ac <xProcessReceivedTCPPacket+0x2a0>
					{
						/* Per the above RFC, "In the SYN-SENT state ... the RST is
						acceptable if the ACK field acknowledges the SYN." */
						if( ulAckNumber == ( pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber + 1UL ) )
 8008180:	f8d0 3104 	ldr.w	r3, [r0, #260]	; 0x104
 8008184:	1c5a      	adds	r2, r3, #1
uint32_t ulLocalIP;
uint16_t xLocalPort = FreeRTOS_htons( pxProtocolHeaders->xTCPHeader.usDestinationPort );
uint16_t xRemotePort = FreeRTOS_htons( pxProtocolHeaders->xTCPHeader.usSourcePort );
uint32_t ulRemoteIP;
uint32_t ulSequenceNumber = FreeRTOS_ntohl( pxProtocolHeaders->xTCPHeader.ulSequenceNumber );
uint32_t ulAckNumber = FreeRTOS_ntohl( pxProtocolHeaders->xTCPHeader.ulAckNr );;
 8008186:	0e33      	lsrs	r3, r6, #24
 8008188:	ea43 6306 	orr.w	r3, r3, r6, lsl #24
 800818c:	f406 417f 	and.w	r1, r6, #65280	; 0xff00
 8008190:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8008194:	f406 067f 	and.w	r6, r6, #16711680	; 0xff0000
 8008198:	ea43 2316 	orr.w	r3, r3, r6, lsr #8
					/* Implement https://tools.ietf.org/html/rfc5961#section-3.2. */
					if( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eCONNECT_SYN )
					{
						/* Per the above RFC, "In the SYN-SENT state ... the RST is
						acceptable if the ACK field acknowledges the SYN." */
						if( ulAckNumber == ( pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber + 1UL ) )
 800819c:	429a      	cmp	r2, r3
 800819e:	f040 842c 	bne.w	80089fa <xProcessReceivedTCPPacket+0xaee>
						{
							vTCPStateChange( pxSocket, eCLOSED );
 80081a2:	2100      	movs	r1, #0
 80081a4:	f7ff fa62 	bl	800766c <vTCPStateChange>
 80081a8:	f000 bc27 	b.w	80089fa <xProcessReceivedTCPPacket+0xaee>
uint16_t ucTCPFlags = pxProtocolHeaders->xTCPHeader.ucTCPFlags;
uint32_t ulLocalIP;
uint16_t xLocalPort = FreeRTOS_htons( pxProtocolHeaders->xTCPHeader.usDestinationPort );
uint16_t xRemotePort = FreeRTOS_htons( pxProtocolHeaders->xTCPHeader.usSourcePort );
uint32_t ulRemoteIP;
uint32_t ulSequenceNumber = FreeRTOS_ntohl( pxProtocolHeaders->xTCPHeader.ulSequenceNumber );
 80081ac:	0e2b      	lsrs	r3, r5, #24
 80081ae:	ea43 6305 	orr.w	r3, r3, r5, lsl #24
 80081b2:	f405 427f 	and.w	r2, r5, #65280	; 0xff00
 80081b6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80081ba:	f405 057f 	and.w	r5, r5, #16711680	; 0xff0000
 80081be:	ea43 2315 	orr.w	r3, r3, r5, lsr #8
						}
					}
					else
					{
						/* Check whether the packet matches the next expected sequence number. */
						if( ulSequenceNumber == pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber )
 80081c2:	f8d0 10e8 	ldr.w	r1, [r0, #232]	; 0xe8
 80081c6:	4299      	cmp	r1, r3
 80081c8:	d104      	bne.n	80081d4 <xProcessReceivedTCPPacket+0x2c8>
						{
							vTCPStateChange( pxSocket, eCLOSED );
 80081ca:	2100      	movs	r1, #0
 80081cc:	f7ff fa4e 	bl	800766c <vTCPStateChange>
 80081d0:	f000 bc13 	b.w	80089fa <xProcessReceivedTCPPacket+0xaee>
						}
						/* Otherwise, check whether the packet is within the receive window. */
						else if( ( ulSequenceNumber > pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber ) &&
 80081d4:	428b      	cmp	r3, r1
 80081d6:	f240 8410 	bls.w	80089fa <xProcessReceivedTCPPacket+0xaee>
								 ( ulSequenceNumber < ( pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber +
 80081da:	f8d0 20dc 	ldr.w	r2, [r0, #220]	; 0xdc
 80081de:	440a      	add	r2, r1
						if( ulSequenceNumber == pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber )
						{
							vTCPStateChange( pxSocket, eCLOSED );
						}
						/* Otherwise, check whether the packet is within the receive window. */
						else if( ( ulSequenceNumber > pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber ) &&
 80081e0:	4293      	cmp	r3, r2
 80081e2:	f080 840a 	bcs.w	80089fa <xProcessReceivedTCPPacket+0xaee>
								 ( ulSequenceNumber < ( pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber +
													  pxSocket->u.xTCP.xTCPWindow.xSize.ulRxWindowLength ) ) )
						{
							/* Send a challenge ACK. */
							( void ) prvTCPSendChallengeAck( pxNetworkBuffer );
 80081e6:	9909      	ldr	r1, [sp, #36]	; 0x24
	( void ) pxNetworkBuffer;
	( void ) ucTCPFlags;
#else
	{
		/* Map the ethernet buffer onto the TCPPacket_t struct for easy access to the fields. */
		TCPPacket_t *pxTCPPacket = ipCAST_PTR_TO_TYPE_PTR( TCPPacket_t, pxNetworkBuffer->pucEthernetBuffer );
 80081e8:	698b      	ldr	r3, [r1, #24]
		const uint32_t ulSendLength = ( uint32_t )
			( ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER ); /* Plus 0 options. */

		pxTCPPacket->xTCPHeader.ucTCPFlags = ucTCPFlags;
 80081ea:	2210      	movs	r2, #16
 80081ec:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f
		pxTCPPacket->xTCPHeader.ucTCPOffset = ( ipSIZE_OF_TCP_HEADER ) << 2;
 80081f0:	2250      	movs	r2, #80	; 0x50
 80081f2:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e

		prvTCPReturnPacket( NULL, pxNetworkBuffer, ulSendLength, pdFALSE );
 80081f6:	2000      	movs	r0, #0
 80081f8:	2228      	movs	r2, #40	; 0x28
 80081fa:	4603      	mov	r3, r0
 80081fc:	f7ff f89c 	bl	8007338 <prvTCPReturnPacket>
 8008200:	e3fb      	b.n	80089fa <xProcessReceivedTCPPacket+0xaee>
					}

					/* Otherwise, do nothing. In any case, the packet cannot be handled. */
					xResult = pdFAIL;
				}
				else if( ( ( ucTCPFlags & tcpTCP_FLAG_CTRL ) == tcpTCP_FLAG_SYN ) && ( pxSocket->u.xTCP.ucTCPState >= ( uint8_t ) eESTABLISHED ) )
 8008202:	f00b 021f 	and.w	r2, fp, #31
 8008206:	2a02      	cmp	r2, #2
 8008208:	d102      	bne.n	8008210 <xProcessReceivedTCPPacket+0x304>
 800820a:	2b04      	cmp	r3, #4
 800820c:	f200 83f5 	bhi.w	80089fa <xProcessReceivedTCPPacket+0xaee>
				{
					/* Update the copy of the TCP header only (skipping eth and IP
					headers).  It might be used later on, whenever data must be sent
					to the peer. */
					const size_t lOffset = ipNUMERIC_CAST( size_t, ipSIZE_OF_ETH_HEADER + uxIPHeaderSizeSocket( pxSocket ) );
					( void ) memcpy( ( void * ) ( &( pxSocket->u.xTCP.xPacket.u.ucLastPacket[ lOffset ] ) ),
 8008210:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8008212:	6992      	ldr	r2, [r2, #24]
 8008214:	f852 1f22 	ldr.w	r1, [r2, #34]!
 8008218:	6856      	ldr	r6, [r2, #4]
 800821a:	6895      	ldr	r5, [r2, #8]
 800821c:	68d0      	ldr	r0, [r2, #12]
 800821e:	f8c4 10a4 	str.w	r1, [r4, #164]	; 0xa4
 8008222:	f8c4 60a8 	str.w	r6, [r4, #168]	; 0xa8
 8008226:	f8c4 50ac 	str.w	r5, [r4, #172]	; 0xac
 800822a:	f8c4 00b0 	str.w	r0, [r4, #176]	; 0xb0
 800822e:	6911      	ldr	r1, [r2, #16]
 8008230:	f8c4 10b4 	str.w	r1, [r4, #180]	; 0xb4
 */
static void prvTCPTouchSocket( FreeRTOS_Socket_t *pxSocket )
{
	#if( ipconfigTCP_HANG_PROTECTION == 1 )
	{
		pxSocket->u.xTCP.xLastActTime = xTaskGetTickCount( );
 8008234:	f7fa ffc2 	bl	80031bc <xTaskGetTickCount>
 8008238:	6620      	str	r0, [r4, #96]	; 0x60
	}
	#endif

	#if( ipconfigTCP_KEEP_ALIVE == 1 )
	{
		pxSocket->u.xTCP.bits.bWaitKeepAlive = pdFALSE_UNSIGNED;
 800823a:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
		pxSocket->u.xTCP.bits.bSendKeepAlive = pdFALSE_UNSIGNED;
 800823e:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
 8008242:	f36f 0341 	bfc	r3, #1, #1
 8008246:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
		pxSocket->u.xTCP.ucKeepRepCount = 0U;
 800824a:	2300      	movs	r3, #0
 800824c:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
		pxSocket->u.xTCP.xLastAliveTime = xTaskGetTickCount();
 8008250:	f7fa ffb4 	bl	80031bc <xTaskGetTickCount>
 8008254:	65e0      	str	r0, [r4, #92]	; 0x5c
			/* _HT_ : if we're in the SYN phase, and peer does not send a MSS option,
			then we MUST assume an MSS size of 536 bytes for backward compatibility. */

			/* When there are no TCP options, the TCP offset equals 20 bytes, which is stored as
			the number 5 (words) in the higher nibble of the TCP-offset byte. */
			if( ( pxProtocolHeaders->xTCPHeader.ucTCPOffset & tcpTCP_OFFSET_LENGTH_BITS ) > tcpTCP_OFFSET_STANDARD_LENGTH )
 8008256:	f899 302e 	ldrb.w	r3, [r9, #46]	; 0x2e
 800825a:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800825e:	2b50      	cmp	r3, #80	; 0x50
 8008260:	f240 80d5 	bls.w	800840e <xProcessReceivedTCPPacket+0x502>
			{
				prvCheckOptions( pxSocket, pxNetworkBuffer );
 8008264:	9909      	ldr	r1, [sp, #36]	; 0x24
 * is longer than the usual 20 (5 x 4) bytes.
 */
_static void prvCheckOptions( FreeRTOS_Socket_t *pxSocket, const NetworkBufferDescriptor_t *pxNetworkBuffer )
{
size_t uxTCPHeaderOffset = ipSIZE_OF_ETH_HEADER + xIPHeaderSize( pxNetworkBuffer );
const ProtocolHeaders_t *pxProtocolHeaders = ipCAST_PTR_TO_TYPE_PTR( ProtocolHeaders_t,
 8008266:	698a      	ldr	r2, [r1, #24]

	pxTCPHeader = &( pxProtocolHeaders->xTCPHeader );


	/* A character pointer to iterate through the option data */
	pucPtr = pxTCPHeader->ucOptdata;
 8008268:	f102 0736 	add.w	r7, r2, #54	; 0x36
	if( pxTCPHeader->ucTCPOffset <= ( 5U << 4U ) )
 800826c:	f892 302e 	ldrb.w	r3, [r2, #46]	; 0x2e
 8008270:	2b50      	cmp	r3, #80	; 0x50
 8008272:	f240 80cc 	bls.w	800840e <xProcessReceivedTCPPacket+0x502>
	{
		/* Avoid integer underflow in computation of ucLength. */
	}
	else
	{
		ucLength = ( ( ( pxTCPHeader->ucTCPOffset >> 4U ) - 5U ) << 2U );
 8008276:	091b      	lsrs	r3, r3, #4
 8008278:	3b05      	subs	r3, #5
 800827a:	009b      	lsls	r3, r3, #2
		uxOptionsLength = ( size_t ) ucLength;
 800827c:	fa5f fa83 	uxtb.w	sl, r3
		if( pxNetworkBuffer->xDataLength > uxOptionOffset )
 8008280:	69cb      	ldr	r3, [r1, #28]
		{
			/* Validate options size calculation. */
			if( ( pxNetworkBuffer->xDataLength > uxOptionOffset ) &&
 8008282:	2b36      	cmp	r3, #54	; 0x36
 8008284:	f240 80c3 	bls.w	800840e <xProcessReceivedTCPPacket+0x502>
				( uxOptionsLength <= ( pxNetworkBuffer->xDataLength - uxOptionOffset ) ) )
 8008288:	3b36      	subs	r3, #54	; 0x36
		ucLength = ( ( ( pxTCPHeader->ucTCPOffset >> 4U ) - 5U ) << 2U );
		uxOptionsLength = ( size_t ) ucLength;
		if( pxNetworkBuffer->xDataLength > uxOptionOffset )
		{
			/* Validate options size calculation. */
			if( ( pxNetworkBuffer->xDataLength > uxOptionOffset ) &&
 800828a:	459a      	cmp	sl, r3
 800828c:	f200 80bf 	bhi.w	800840e <xProcessReceivedTCPPacket+0x502>
				( uxOptionsLength <= ( pxNetworkBuffer->xDataLength - uxOptionOffset ) ) )
			{
				if( ( pxTCPHeader->ucTCPFlags & tcpTCP_FLAG_SYN ) != ( uint8_t ) 0U )
 8008290:	f892 302f 	ldrb.w	r3, [r2, #47]	; 0x2f
 8008294:	f003 0302 	and.w	r3, r3, #2
 8008298:	b2db      	uxtb	r3, r3
 800829a:	9304      	str	r3, [sp, #16]
				}
				/* The length check is only necessary in case the option data are
				corrupted, we don't like to run into invalid memory and crash. */
				for( ;; )
				{
					if( uxOptionsLength == 0U )
 800829c:	f1ba 0f00 	cmp.w	sl, #0
 80082a0:	f000 80b5 	beq.w	800840e <xProcessReceivedTCPPacket+0x502>
								   size_t uxIndex,
								   FreeRTOS_Socket_t * const pxSocket )
	{
	uint32_t ulFirst = ulChar2u32( &( pucPtr[ uxIndex ] ) );
	uint32_t ulLast  = ulChar2u32( &( pucPtr[ uxIndex + 4U ] ) );
	uint32_t ulCount = ulTCPWindowTxSack( &( pxSocket->u.xTCP.xTCPWindow ), ulFirst, ulLast );;
 80082a4:	f104 03d8 	add.w	r3, r4, #216	; 0xd8
 80082a8:	9305      	str	r3, [sp, #20]
uint8_t ucLen;
size_t uxIndex;
TCPWindow_t *pxTCPWindow = &( pxSocket->u.xTCP.xTCPWindow );
BaseType_t xReturn = pdFALSE;

	if( pucPtr[ 0U ] == tcpTCP_OPT_END )
 80082aa:	783b      	ldrb	r3, [r7, #0]
 80082ac:	2b00      	cmp	r3, #0
 80082ae:	f000 80ae 	beq.w	800840e <xProcessReceivedTCPPacket+0x502>
	{
		/* End of options. */
		uxIndex = 0U;
	}
	else if( pucPtr[ 0U ] == tcpTCP_OPT_NOOP )
 80082b2:	2b01      	cmp	r3, #1
 80082b4:	f000 83a3 	beq.w	80089fe <xProcessReceivedTCPPacket+0xaf2>
	{
		/* NOP option, inserted to make the length a multiple of 4. */
		uxIndex = 1U;
	}
	else if( uxRemainingOptionsBytes < 2U )
 80082b8:	f1ba 0f01 	cmp.w	sl, #1
 80082bc:	f240 80a7 	bls.w	800840e <xProcessReceivedTCPPacket+0x502>
		/* Any other well-formed option must be at least two bytes: the option
		type byte followed by a length byte. */
		uxIndex = 0U;
	}
#if( ipconfigUSE_TCP_WIN != 0 )
	else if( pucPtr[ 0 ] == tcpTCP_OPT_WSOPT )
 80082c0:	2b03      	cmp	r3, #3
 80082c2:	d116      	bne.n	80082f2 <xProcessReceivedTCPPacket+0x3e6>
	{
		/* The TCP Window Scale Option. */
		/* Confirm that the option fits in the remaining buffer space. */
		if( ( uxRemainingOptionsBytes < tcpTCP_OPT_WSOPT_LEN ) || ( pucPtr[ 1 ] != tcpTCP_OPT_WSOPT_LEN ) )
 80082c4:	f1ba 0f02 	cmp.w	sl, #2
 80082c8:	f240 80a1 	bls.w	800840e <xProcessReceivedTCPPacket+0x502>
 80082cc:	787b      	ldrb	r3, [r7, #1]
 80082ce:	2b03      	cmp	r3, #3
 80082d0:	f040 809d 	bne.w	800840e <xProcessReceivedTCPPacket+0x502>
			uxIndex = 0U;
		}
		else
		{
			/* Option is only valid in SYN phase. */
			if( xHasSYNFlag != 0 )
 80082d4:	9b04      	ldr	r3, [sp, #16]
 80082d6:	2b00      	cmp	r3, #0
 80082d8:	f000 8393 	beq.w	8008a02 <xProcessReceivedTCPPacket+0xaf6>
			{
				pxSocket->u.xTCP.ucPeerWinScaleFactor = pucPtr[ 2 ];
 80082dc:	78bb      	ldrb	r3, [r7, #2]
 80082de:	f884 30ca 	strb.w	r3, [r4, #202]	; 0xca
				pxSocket->u.xTCP.bits.bWinScaling = pdTRUE_UNSIGNED;
 80082e2:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 80082e6:	f043 0310 	orr.w	r3, r3, #16
 80082ea:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
			}
			uxIndex = tcpTCP_OPT_WSOPT_LEN;
 80082ee:	2503      	movs	r5, #3
 80082f0:	e088      	b.n	8008404 <xProcessReceivedTCPPacket+0x4f8>
		}
	}
#endif	/* ipconfigUSE_TCP_WIN */
	else if( pucPtr[ 0 ] == tcpTCP_OPT_MSS )
 80082f2:	2b02      	cmp	r3, #2
 80082f4:	d12e      	bne.n	8008354 <xProcessReceivedTCPPacket+0x448>
	{
		/* Confirm that the option fits in the remaining buffer space. */
		if( ( uxRemainingOptionsBytes < tcpTCP_OPT_MSS_LEN ) || ( pucPtr[ 1 ] != tcpTCP_OPT_MSS_LEN ) )
 80082f6:	f1ba 0f03 	cmp.w	sl, #3
 80082fa:	f240 8088 	bls.w	800840e <xProcessReceivedTCPPacket+0x502>
 80082fe:	787b      	ldrb	r3, [r7, #1]
 8008300:	2b04      	cmp	r3, #4
 8008302:	f040 8084 	bne.w	800840e <xProcessReceivedTCPPacket+0x502>
 8008306:	78ba      	ldrb	r2, [r7, #2]
 8008308:	78fb      	ldrb	r3, [r7, #3]
 800830a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			/* An MSS option with the correct option length.  FreeRTOS_htons()
			is not needed here because usChar2u16() already returns a host
			endian number. */
			uxNewMSS = usChar2u16( &( pucPtr[ 2 ] ) );

			if( pxSocket->u.xTCP.usInitMSS != uxNewMSS )
 800830e:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
 8008312:	4293      	cmp	r3, r2
 8008314:	d075      	beq.n	8008402 <xProcessReceivedTCPPacket+0x4f6>
					FreeRTOS_debug_printf( ( "MSS change %u -> %lu\n", pxSocket->u.xTCP.usInitMSS, uxNewMSS ) );
				}
			}

			/* If a 'return' condition has not been found. */
			if( xReturn == pdFALSE )
 8008316:	2b00      	cmp	r3, #0
 8008318:	d079      	beq.n	800840e <xProcessReceivedTCPPacket+0x502>
			{
				if( pxSocket->u.xTCP.usInitMSS > uxNewMSS )
 800831a:	4293      	cmp	r3, r2
 800831c:	f080 8373 	bcs.w	8008a06 <xProcessReceivedTCPPacket+0xafa>
				{
					/* our MSS was bigger than the MSS of the other party: adapt it. */
					pxSocket->u.xTCP.bits.bMssChange = pdTRUE_UNSIGNED;
 8008320:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
 8008324:	f042 0201 	orr.w	r2, r2, #1
 8008328:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
						/* The peer advertises a smaller MSS than this socket was
						using.  Use that as well. */
						FreeRTOS_debug_printf( ( "Change mss %d => %lu\n", pxSocket->u.xTCP.usCurMSS, uxNewMSS ) );
						pxSocket->u.xTCP.usCurMSS = ( uint16_t ) uxNewMSS;
					}
					pxTCPWindow->xSize.ulRxWindowLength = ( ( uint32_t ) uxNewMSS ) * ( pxTCPWindow->xSize.ulRxWindowLength / ( ( uint32_t ) uxNewMSS ) );
 800832c:	f8d4 20dc 	ldr.w	r2, [r4, #220]	; 0xdc
 8008330:	fbb2 f2f3 	udiv	r2, r2, r3
 8008334:	fb03 f202 	mul.w	r2, r3, r2
 8008338:	f8c4 20dc 	str.w	r2, [r4, #220]	; 0xdc
					pxTCPWindow->usMSSInit = ( uint16_t ) uxNewMSS;
 800833c:	f8a4 3196 	strh.w	r3, [r4, #406]	; 0x196
					pxTCPWindow->usMSS = ( uint16_t ) uxNewMSS;
 8008340:	f8a4 3194 	strh.w	r3, [r4, #404]	; 0x194
					pxSocket->u.xTCP.usInitMSS = ( uint16_t ) uxNewMSS;
 8008344:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
					pxSocket->u.xTCP.usCurMSS = ( uint16_t ) uxNewMSS;
 8008348:	f8a4 304a 	strh.w	r3, [r4, #74]	; 0x4a
				}

				uxIndex = tcpTCP_OPT_MSS_LEN;
 800834c:	2504      	movs	r5, #4
 800834e:	e059      	b.n	8008404 <xProcessReceivedTCPPacket+0x4f8>
 8008350:	2000d5c0 	.word	0x2000d5c0
	}
	else
	{
		/* All other options have a length field, so that we easily
		can skip past them. */
		ucLen = pucPtr[ 1 ];
 8008354:	787d      	ldrb	r5, [r7, #1]
		if( ( ucLen < ( uint8_t ) 2U ) || ( uxRemainingOptionsBytes < ( size_t ) ucLen ) )
 8008356:	2d01      	cmp	r5, #1
 8008358:	d959      	bls.n	800840e <xProcessReceivedTCPPacket+0x502>
 800835a:	4555      	cmp	r5, sl
 800835c:	d857      	bhi.n	800840e <xProcessReceivedTCPPacket+0x502>
			{
				/* Selective ACK: the peer has received a packet but it is missing
				 * earlier packets. At least this packet does not need retransmission
				 * anymore. ulTCPWindowTxSack( ) takes care of this administration.
				 */
				if( pucPtr[ 0U ] == tcpTCP_OPT_SACK_A )
 800835e:	2b05      	cmp	r3, #5
 8008360:	d148      	bne.n	80083f4 <xProcessReceivedTCPPacket+0x4e8>
				{
					ucLen -= 2U;
 8008362:	1eab      	subs	r3, r5, #2
 8008364:	b2db      	uxtb	r3, r3
					uxIndex += 2U;

					while( ucLen >= ( uint8_t ) 8U )
 8008366:	2b07      	cmp	r3, #7
 8008368:	d946      	bls.n	80083f8 <xProcessReceivedTCPPacket+0x4ec>
 800836a:	463e      	mov	r6, r7
 800836c:	f1a5 080a 	sub.w	r8, r5, #10
 8008370:	f3c8 08c4 	ubfx	r8, r8, #3, #5
 8008374:	f108 0301 	add.w	r3, r8, #1
 8008378:	eb07 03c3 	add.w	r3, r7, r3, lsl #3
 800837c:	9303      	str	r3, [sp, #12]
 * application and hence these functions are defined unconditionally.
 */
static portINLINE uint32_t ulChar2u32 (const uint8_t *apChr);
static portINLINE uint32_t ulChar2u32 (const uint8_t *apChr)
{
	return  ( ( ( uint32_t )apChr[0] ) << 24) |
 800837e:	78b2      	ldrb	r2, [r6, #2]
			( ( ( uint32_t )apChr[1] ) << 16) |
 8008380:	78f3      	ldrb	r3, [r6, #3]
 8008382:	041b      	lsls	r3, r3, #16
 * application and hence these functions are defined unconditionally.
 */
static portINLINE uint32_t ulChar2u32 (const uint8_t *apChr);
static portINLINE uint32_t ulChar2u32 (const uint8_t *apChr)
{
	return  ( ( ( uint32_t )apChr[0] ) << 24) |
 8008384:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
			( ( ( uint32_t )apChr[1] ) << 16) |
			( ( ( uint32_t )apChr[2] ) << 8) |
			( ( ( uint32_t )apChr[3] ) );
 8008388:	7971      	ldrb	r1, [r6, #5]
 800838a:	4319      	orrs	r1, r3
static portINLINE uint32_t ulChar2u32 (const uint8_t *apChr);
static portINLINE uint32_t ulChar2u32 (const uint8_t *apChr)
{
	return  ( ( ( uint32_t )apChr[0] ) << 24) |
			( ( ( uint32_t )apChr[1] ) << 16) |
			( ( ( uint32_t )apChr[2] ) << 8) |
 800838c:	f896 e004 	ldrb.w	lr, [r6, #4]
 * application and hence these functions are defined unconditionally.
 */
static portINLINE uint32_t ulChar2u32 (const uint8_t *apChr);
static portINLINE uint32_t ulChar2u32 (const uint8_t *apChr)
{
	return  ( ( ( uint32_t )apChr[0] ) << 24) |
 8008390:	79b2      	ldrb	r2, [r6, #6]
			( ( ( uint32_t )apChr[1] ) << 16) |
 8008392:	79f3      	ldrb	r3, [r6, #7]
 8008394:	041b      	lsls	r3, r3, #16
 * application and hence these functions are defined unconditionally.
 */
static portINLINE uint32_t ulChar2u32 (const uint8_t *apChr);
static portINLINE uint32_t ulChar2u32 (const uint8_t *apChr)
{
	return  ( ( ( uint32_t )apChr[0] ) << 24) |
 8008396:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
			( ( ( uint32_t )apChr[1] ) << 16) |
			( ( ( uint32_t )apChr[2] ) << 8) |
			( ( ( uint32_t )apChr[3] ) );
 800839a:	7a72      	ldrb	r2, [r6, #9]
 800839c:	4313      	orrs	r3, r2
static portINLINE uint32_t ulChar2u32 (const uint8_t *apChr);
static portINLINE uint32_t ulChar2u32 (const uint8_t *apChr)
{
	return  ( ( ( uint32_t )apChr[0] ) << 24) |
			( ( ( uint32_t )apChr[1] ) << 16) |
			( ( ( uint32_t )apChr[2] ) << 8) |
 800839e:	7a32      	ldrb	r2, [r6, #8]
								   size_t uxIndex,
								   FreeRTOS_Socket_t * const pxSocket )
	{
	uint32_t ulFirst = ulChar2u32( &( pucPtr[ uxIndex ] ) );
	uint32_t ulLast  = ulChar2u32( &( pucPtr[ uxIndex + 4U ] ) );
	uint32_t ulCount = ulTCPWindowTxSack( &( pxSocket->u.xTCP.xTCPWindow ), ulFirst, ulLast );;
 80083a0:	9805      	ldr	r0, [sp, #20]
 80083a2:	ea41 210e 	orr.w	r1, r1, lr, lsl #8
 80083a6:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
 80083aa:	f000 ff7f 	bl	80092ac <ulTCPWindowTxSack>
 80083ae:	4603      	mov	r3, r0

		/* ulTCPWindowTxSack( ) returns the number of bytes which have been acked
		 * starting from the head position.  Advance the tail pointer in txStream.
		 */
		if( ( pxSocket->u.xTCP.txStream  != NULL ) && ( ulCount > 0U ) )
 80083b0:	6fa0      	ldr	r0, [r4, #120]	; 0x78
 80083b2:	b190      	cbz	r0, 80083da <xProcessReceivedTCPPacket+0x4ce>
 80083b4:	b18b      	cbz	r3, 80083da <xProcessReceivedTCPPacket+0x4ce>
		{
			/* Just advancing the tail index, 'ulCount' bytes have been confirmed. */
			( void ) uxStreamBufferGet( pxSocket->u.xTCP.txStream, 0, NULL, ( size_t ) ulCount, pdFALSE );
 80083b6:	2200      	movs	r2, #0
 80083b8:	9200      	str	r2, [sp, #0]
 80083ba:	4611      	mov	r1, r2
 80083bc:	f7fe ff54 	bl	8007268 <uxStreamBufferGet>
			pxSocket->xEventBits |= ( EventBits_t ) eSOCKET_SEND;
 80083c0:	6823      	ldr	r3, [r4, #0]
 80083c2:	f043 0202 	orr.w	r2, r3, #2
 80083c6:	6022      	str	r2, [r4, #0]

			#if ipconfigSUPPORT_SELECT_FUNCTION == 1
			{
				if( ( pxSocket->xSelectBits & ( EventBits_t ) eSELECT_WRITE ) != 0U )
 80083c8:	6b22      	ldr	r2, [r4, #48]	; 0x30
 80083ca:	f012 0f02 	tst.w	r2, #2
 80083ce:	d004      	beq.n	80083da <xProcessReceivedTCPPacket+0x4ce>
				{
					/* The field 'xEventBits' is used to store regular socket events
					 * (at most 8), as well as 'select events', which will be left-shifted.
					 */
					pxSocket->xEventBits |= ( ( EventBits_t ) eSELECT_WRITE ) << SOCKET_EVENT_BIT_COUNT;
 80083d0:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80083d4:	f043 0302 	orr.w	r3, r3, #2
 80083d8:	6023      	str	r3, [r4, #0]
 80083da:	3608      	adds	r6, #8
				if( pucPtr[ 0U ] == tcpTCP_OPT_SACK_A )
				{
					ucLen -= 2U;
					uxIndex += 2U;

					while( ucLen >= ( uint8_t ) 8U )
 80083dc:	9b03      	ldr	r3, [sp, #12]
 80083de:	429e      	cmp	r6, r3
 80083e0:	d1cd      	bne.n	800837e <xProcessReceivedTCPPacket+0x472>
 80083e2:	ea4f 03c8 	mov.w	r3, r8, lsl #3
 80083e6:	330a      	adds	r3, #10
 80083e8:	3d0a      	subs	r5, #10
 80083ea:	eba5 05c8 	sub.w	r5, r5, r8, lsl #3
 80083ee:	f005 05ff 	and.w	r5, r5, #255	; 0xff
 80083f2:	e003      	b.n	80083fc <xProcessReceivedTCPPacket+0x4f0>
			 */
			uxIndex = 0U;
		}
		else
		{
			uxIndex = 0U;
 80083f4:	2300      	movs	r3, #0
 80083f6:	e001      	b.n	80083fc <xProcessReceivedTCPPacket+0x4f0>
				 * earlier packets. At least this packet does not need retransmission
				 * anymore. ulTCPWindowTxSack( ) takes care of this administration.
				 */
				if( pucPtr[ 0U ] == tcpTCP_OPT_SACK_A )
				{
					ucLen -= 2U;
 80083f8:	461d      	mov	r5, r3
					uxIndex += 2U;
 80083fa:	2302      	movs	r3, #2
					{
						/* coverity[break_stmt] : Break statement terminating the loop */
						break;
					}
					uxResult = prvSingleStepTCPHeaderOptions( pucPtr, uxOptionsLength, pxSocket, xHasSYNFlag );
					if( uxResult == 0UL )
 80083fc:	18ed      	adds	r5, r5, r3
 80083fe:	d101      	bne.n	8008404 <xProcessReceivedTCPPacket+0x4f8>
 8008400:	e005      	b.n	800840e <xProcessReceivedTCPPacket+0x502>
					pxTCPWindow->usMSS = ( uint16_t ) uxNewMSS;
					pxSocket->u.xTCP.usInitMSS = ( uint16_t ) uxNewMSS;
					pxSocket->u.xTCP.usCurMSS = ( uint16_t ) uxNewMSS;
				}

				uxIndex = tcpTCP_OPT_MSS_LEN;
 8008402:	2504      	movs	r5, #4
					if( uxResult == 0UL )
					{
						break;
					}
					uxOptionsLength -= uxResult;
					pucPtr = &( pucPtr[ uxResult ] );
 8008404:	442f      	add	r7, r5
				}
				/* The length check is only necessary in case the option data are
				corrupted, we don't like to run into invalid memory and crash. */
				for( ;; )
				{
					if( uxOptionsLength == 0U )
 8008406:	ebba 0a05 	subs.w	sl, sl, r5
 800840a:	f47f af4e 	bne.w	80082aa <xProcessReceivedTCPPacket+0x39e>
			if( ( pxProtocolHeaders->xTCPHeader.ucTCPOffset & tcpTCP_OFFSET_LENGTH_BITS ) > tcpTCP_OFFSET_STANDARD_LENGTH )
			{
				prvCheckOptions( pxSocket, pxNetworkBuffer );
			}

			usWindow = FreeRTOS_ntohs( pxProtocolHeaders->xTCPHeader.usWindow );
 800840e:	f8b9 2030 	ldrh.w	r2, [r9, #48]	; 0x30
 8008412:	0a13      	lsrs	r3, r2, #8
 8008414:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			pxSocket->u.xTCP.ulWindowSize = (uint32_t ) usWindow;
 8008418:	b29b      	uxth	r3, r3
 800841a:	f8c4 30cc 	str.w	r3, [r4, #204]	; 0xcc
			#if( ipconfigUSE_TCP_WIN == 1 )
			{
				/* rfc1323 : The Window field in a SYN (i.e., a <SYN> or <SYN,ACK>)
				segment itself is never scaled. */
				if( ( ucTCPFlags & ( uint8_t ) tcpTCP_FLAG_SYN ) == 0U )
 800841e:	f01b 0f02 	tst.w	fp, #2
 8008422:	d104      	bne.n	800842e <xProcessReceivedTCPPacket+0x522>
				{
					pxSocket->u.xTCP.ulWindowSize =
						( pxSocket->u.xTCP.ulWindowSize << pxSocket->u.xTCP.ucPeerWinScaleFactor );
 8008424:	f894 20ca 	ldrb.w	r2, [r4, #202]	; 0xca
 8008428:	4093      	lsls	r3, r2
			{
				/* rfc1323 : The Window field in a SYN (i.e., a <SYN> or <SYN,ACK>)
				segment itself is never scaled. */
				if( ( ucTCPFlags & ( uint8_t ) tcpTCP_FLAG_SYN ) == 0U )
				{
					pxSocket->u.xTCP.ulWindowSize =
 800842a:	f8c4 30cc 	str.w	r3, [r4, #204]	; 0xcc
 * only, most compilers will inline them, thus avoiding a call and return.
 */
static BaseType_t prvTCPHandleState( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **ppxNetworkBuffer )
{
/* Map the buffer onto the ProtocolHeader_t struct for easy access to the fields. */
ProtocolHeaders_t *pxProtocolHeaders = ipCAST_PTR_TO_TYPE_PTR( ProtocolHeaders_t,
 800842e:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
 8008432:	f8d8 6018 	ldr.w	r6, [r8, #24]
	&( ( *ppxNetworkBuffer )->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + xIPHeaderSize( *ppxNetworkBuffer ) ] ) );
TCPHeader_t *pxTCPHeader = &( pxProtocolHeaders->xTCPHeader );
BaseType_t xSendLength = 0;
uint32_t ulReceiveLength;	/* Number of bytes contained in the TCP message. */
uint8_t *pucRecvData;
uint32_t ulSequenceNumber = FreeRTOS_ntohl (pxTCPHeader->ulSequenceNumber);
 8008436:	f8d6 3026 	ldr.w	r3, [r6, #38]	; 0x26
 800843a:	061a      	lsls	r2, r3, #24
 800843c:	ea42 6213 	orr.w	r2, r2, r3, lsr #24
 8008440:	f403 417f 	and.w	r1, r3, #65280	; 0xff00
 8008444:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8008448:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 800844c:	ea42 2b13 	orr.w	fp, r2, r3, lsr #8
	4 bytes)
	1. in the SYN phase, we shall communicate the MSS
	2. in case of a SACK, Selective ACK, ack a segment which comes in
	out-of-order. */
UBaseType_t uxOptionsLength = 0U;
uint8_t ucTCPFlags = pxTCPHeader->ucTCPFlags;
 8008450:	f896 a02f 	ldrb.w	sl, [r6, #47]	; 0x2f
	node.

	The size of the TCP header is given in a multiple of 4-byte words (single
	byte, needs no ntoh() translation).  A shift-right 2: is the same as
	(offset >> 4) * 4. */
	ucIntermediateResult = ( pxTCPHeader->ucTCPOffset & tcpVALID_BITS_IN_TCP_OFFSET_BYTE ) >> 2;
 8008454:	f896 302e 	ldrb.w	r3, [r6, #46]	; 0x2e
 8008458:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800845c:	089d      	lsrs	r5, r3, #2
	lTCPHeaderLength = ( int32_t ) ucIntermediateResult;

	/* Let pucRecvData point to the first byte received. */
	*ppucRecvData = &( pxNetworkBuffer->pucEthernetBuffer[ ( size_t ) ipSIZE_OF_ETH_HEADER + xIPHeaderLength + ( size_t ) lTCPHeaderLength ] );
 800845e:	f105 0922 	add.w	r9, r5, #34	; 0x22
 8008462:	44b1      	add	r9, r6

	/* Calculate lReceiveLength - the length of the TCP data received.  This is
	equal to the total packet length minus:
	( LinkLayer length (14) + IP header length (20) + size of TCP header(20 +) ).*/
	lReceiveLength = ipNUMERIC_CAST( int32_t, pxNetworkBuffer->xDataLength ) - ( int32_t ) ipSIZE_OF_ETH_HEADER;
 8008464:	f8d8 301c 	ldr.w	r3, [r8, #28]
 8008468:	f1a3 020e 	sub.w	r2, r3, #14

	usLength = FreeRTOS_htons( pxIPHeader->usLength );
 800846c:	8a31      	ldrh	r1, [r6, #16]
 800846e:	0a0b      	lsrs	r3, r1, #8
 8008470:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	lLength =  ( int32_t ) usLength;
 8008474:	b29b      	uxth	r3, r3
 8008476:	4293      	cmp	r3, r2
 8008478:	bfa8      	it	ge
 800847a:	4613      	movge	r3, r2
		lReceiveLength = lLength;
	}

	/* Subtract the size of the TCP and IP headers and the actual data size is
	known. */
	if( lReceiveLength > ( lTCPHeaderLength + ( int32_t ) xIPHeaderLength ) )
 800847c:	f105 0214 	add.w	r2, r5, #20
 8008480:	4293      	cmp	r3, r2
	{
		lReceiveLength -= ( lTCPHeaderLength + ( int32_t ) xIPHeaderLength );
 8008482:	bfc6      	itte	gt
 8008484:	1b5b      	subgt	r3, r3, r5
 8008486:	f1a3 0514 	subgt.w	r5, r3, #20
	}
	else
	{
		lReceiveLength = 0;
 800848a:	2500      	movle	r5, #0
	This field communicates the current value of the urgent pointer as a
	positive offset from the sequence number in this segment.  The urgent
	pointer points to the sequence number of the octet following the urgent
	data.  This field is only be interpreted in segments with the URG control
	bit set. */
	if( ( pxTCPHeader->ucTCPFlags & tcpTCP_FLAG_URG ) != 0U )
 800848c:	f01a 0f20 	tst.w	sl, #32
 8008490:	d009      	beq.n	80084a6 <xProcessReceivedTCPPacket+0x59a>
	{
		/* Although we ignore the urgent data, we have to skip it. */
		lUrgentLength = ( int32_t ) FreeRTOS_htons( pxTCPHeader->usUrgent );
 8008492:	8eb2      	ldrh	r2, [r6, #52]	; 0x34
 8008494:	0a13      	lsrs	r3, r2, #8
 8008496:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800849a:	b29b      	uxth	r3, r3
		*ppucRecvData += lUrgentLength;
 800849c:	4499      	add	r9, r3
		lReceiveLength -= FreeRTOS_min_int32( lReceiveLength, lUrgentLength );
 800849e:	429d      	cmp	r5, r3
 80084a0:	bfd4      	ite	le
 80084a2:	1b6d      	suble	r5, r5, r5
 80084a4:	1aed      	subgt	r5, r5, r3
TCPWindow_t *pxTCPWindow = &( pxSocket->u.xTCP.xTCPWindow );
UBaseType_t uxIntermediateResult = 0;

	/* First get the length and the position of the received data, if any.
	pucRecvData will point to the first byte of the TCP payload. */
	ulReceiveLength = ( uint32_t ) prvCheckRxData( *ppxNetworkBuffer, &pucRecvData );
 80084a6:	462f      	mov	r7, r5

	if( pxSocket->u.xTCP.ucTCPState >= ( uint8_t ) eESTABLISHED )
 80084a8:	f894 1053 	ldrb.w	r1, [r4, #83]	; 0x53
 80084ac:	2904      	cmp	r1, #4
 80084ae:	d90b      	bls.n	80084c8 <xProcessReceivedTCPPacket+0x5bc>
	{
		if ( pxTCPWindow->rx.ulCurrentSequenceNumber == ( ulSequenceNumber + 1UL ) )
 80084b0:	f10b 0301 	add.w	r3, fp, #1
 80084b4:	f8d4 20e8 	ldr.w	r2, [r4, #232]	; 0xe8
 80084b8:	429a      	cmp	r2, r3
 80084ba:	d105      	bne.n	80084c8 <xProcessReceivedTCPPacket+0x5bc>
		{
			/* This is most probably a keep-alive message from peer.  Setting
			'bWinChange' doesn't cause a window-size-change, the flag is used
			here to force sending an immediate ACK. */
			pxSocket->u.xTCP.bits.bWinChange = pdTRUE_UNSIGNED;
 80084bc:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 80084c0:	f043 0301 	orr.w	r3, r3, #1
 80084c4:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
		}
	}

	/* Keep track of the highest sequence number that might be expected within
	this connection. */
	if( ( ipNUMERIC_CAST( int32_t, ulSequenceNumber + ulReceiveLength - pxTCPWindow->rx.ulHighestSequenceNumber ) ) > 0L )
 80084c8:	eb07 030b 	add.w	r3, r7, fp
 80084cc:	461a      	mov	r2, r3
 80084ce:	9304      	str	r3, [sp, #16]
 80084d0:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
 80084d4:	1ad3      	subs	r3, r2, r3
 80084d6:	2b00      	cmp	r3, #0
	{
		pxTCPWindow->rx.ulHighestSequenceNumber = ulSequenceNumber + ulReceiveLength;
 80084d8:	bfc4      	itt	gt
 80084da:	4613      	movgt	r3, r2
 80084dc:	f8c4 30f0 	strgt.w	r3, [r4, #240]	; 0xf0
{
/* Map the ethernet buffer onto the ProtocolHeader_t struct for easy access to the fields. */
const ProtocolHeaders_t *pxProtocolHeaders = ipCAST_CONST_PTR_TO_CONST_TYPE_PTR( ProtocolHeaders_t,
	&( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + xIPHeaderSize( pxNetworkBuffer ) ] ) );
const TCPHeader_t *pxTCPHeader = &pxProtocolHeaders->xTCPHeader;
TCPWindow_t *pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
 80084e0:	f104 03d8 	add.w	r3, r4, #216	; 0xd8
 80084e4:	9303      	str	r3, [sp, #12]
uint32_t ulSequenceNumber, ulSpace;
int32_t lOffset, lStored;
BaseType_t xResult = 0;

	ulSequenceNumber = FreeRTOS_ntohl( pxTCPHeader->ulSequenceNumber );
 80084e6:	f8d8 3018 	ldr.w	r3, [r8, #24]
 80084ea:	f8d3 2026 	ldr.w	r2, [r3, #38]	; 0x26

	if( ( ulReceiveLength > 0U ) && ( pxSocket->u.xTCP.ucTCPState >= ( uint8_t ) eSYN_RECEIVED ) )
 80084ee:	b3af      	cbz	r7, 800855c <xProcessReceivedTCPPacket+0x650>
 80084f0:	2903      	cmp	r1, #3
 80084f2:	d933      	bls.n	800855c <xProcessReceivedTCPPacket+0x650>

		If it can't be "accept"ed it may have to be stored and send a selective
		ack (SACK) option to confirm it.  In that case, lTCPAddRxdata() will be
		called later to store an out-of-order packet (in case lOffset is
		negative). */
		if ( pxSocket->u.xTCP.rxStream != NULL )
 80084f4:	6f61      	ldr	r1, [r4, #116]	; 0x74
 80084f6:	b149      	cbz	r1, 800850c <xProcessReceivedTCPPacket+0x600>
static portINLINE size_t uxStreamBufferGetSpace( const StreamBuffer_t *pxBuffer );
static portINLINE size_t uxStreamBufferGetSpace( const StreamBuffer_t *pxBuffer )
{
/* Returns the number of items which can still be added to uxHead
before hitting on uxTail */
size_t uxHead = pxBuffer->uxHead;
 80084f8:	6888      	ldr	r0, [r1, #8]
size_t uxTail = pxBuffer->uxTail;
 80084fa:	680b      	ldr	r3, [r1, #0]
static portINLINE size_t uxStreamBufferSpace( const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper )
{
/* Returns the space between uxLower and uxUpper, which equals to the distance minus 1 */
size_t uxCount;

	uxCount = pxBuffer->LENGTH + uxUpper - uxLower - 1U;
 80084fc:	6909      	ldr	r1, [r1, #16]
 80084fe:	440b      	add	r3, r1
 8008500:	3b01      	subs	r3, #1
 8008502:	1a1b      	subs	r3, r3, r0
	if( uxCount >= pxBuffer->LENGTH )
 8008504:	4299      	cmp	r1, r3
 8008506:	d802      	bhi.n	800850e <xProcessReceivedTCPPacket+0x602>
	{
		uxCount -= pxBuffer->LENGTH;
 8008508:	1a5b      	subs	r3, r3, r1
 800850a:	e000      	b.n	800850e <xProcessReceivedTCPPacket+0x602>
		{
			ulSpace = ( uint32_t )uxStreamBufferGetSpace ( pxSocket->u.xTCP.rxStream );
		}
		else
		{
			ulSpace = ( uint32_t )pxSocket->u.xTCP.uxRxStreamSize;
 800850c:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
TCPWindow_t *pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
uint32_t ulSequenceNumber, ulSpace;
int32_t lOffset, lStored;
BaseType_t xResult = 0;

	ulSequenceNumber = FreeRTOS_ntohl( pxTCPHeader->ulSequenceNumber );
 800850e:	0e11      	lsrs	r1, r2, #24
 8008510:	ea41 6102 	orr.w	r1, r1, r2, lsl #24
 8008514:	f402 407f 	and.w	r0, r2, #65280	; 0xff00
 8008518:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
 800851c:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
		else
		{
			ulSpace = ( uint32_t )pxSocket->u.xTCP.uxRxStreamSize;
		}

		lOffset = lTCPWindowRxCheck( pxTCPWindow, ulSequenceNumber, ulReceiveLength, ulSpace );
 8008520:	9803      	ldr	r0, [sp, #12]
 8008522:	ea41 2112 	orr.w	r1, r1, r2, lsr #8
 8008526:	463a      	mov	r2, r7
 8008528:	f000 fcbe 	bl	8008ea8 <lTCPWindowRxCheck>

		if( lOffset >= 0 )
 800852c:	1e01      	subs	r1, r0, #0
 800852e:	f2c0 826c 	blt.w	8008a0a <xProcessReceivedTCPPacket+0xafe>
		{
			/* New data has arrived and may be made available to the user.  See
			if the head marker in rxStream may be advanced,	only if lOffset == 0.
			In case the low-water mark is reached, bLowWater will be set
			"low-water" here stands for "little space". */
			lStored = lTCPAddRxdata( pxSocket, ( uint32_t ) lOffset, pucRecvData, ulReceiveLength );
 8008532:	4620      	mov	r0, r4
 8008534:	464a      	mov	r2, r9
 8008536:	463b      	mov	r3, r7
 8008538:	f7fe fb26 	bl	8006b88 <lTCPAddRxdata>

			if( lStored != ( int32_t ) ulReceiveLength )
 800853c:	4285      	cmp	r5, r0
 800853e:	f000 8264 	beq.w	8008a0a <xProcessReceivedTCPPacket+0xafe>
				FreeRTOS_debug_printf( ( "lTCPAddRxdata: stored %ld / %lu bytes? ?\n", lStored, ulReceiveLength ) );

				/* Received data could not be stored.  The socket's flag
				bMallocError has been set.  The socket now has the status
				eCLOSE_WAIT and a RST packet will be sent back. */
				( void ) prvTCPSendReset( pxNetworkBuffer );
 8008542:	4640      	mov	r0, r8
 8008544:	f7ff f802 	bl	800754c <prvTCPSendReset>
 8008548:	e246      	b.n	80089d8 <xProcessReceivedTCPPacket+0xacc>
			/* Now lTCPAddRxdata() will move the rxHead pointer forward
			so data becomes available to the user immediately
			In case the low-water mark is reached, bLowWater will be set. */
			if( ( xResult == 0 ) && ( pxTCPWindow->ulUserDataLength > 0UL ) )
			{
				( void ) lTCPAddRxdata( pxSocket, 0UL, NULL, pxTCPWindow->ulUserDataLength );
 800854a:	4620      	mov	r0, r4
 800854c:	2100      	movs	r1, #0
 800854e:	460a      	mov	r2, r1
 8008550:	f7fe fb1a 	bl	8006b88 <lTCPAddRxdata>
				pxTCPWindow->ulUserDataLength = 0;
 8008554:	2300      	movs	r3, #0
 8008556:	f8c4 3108 	str.w	r3, [r4, #264]	; 0x108
 800855a:	e25b      	b.n	8008a14 <xProcessReceivedTCPPacket+0xb08>
		}
		#endif /* ipconfigUSE_TCP_WIN */
	}
	else
	{
		pxTCPWindow->ucOptionLength = 0U;
 800855c:	2300      	movs	r3, #0
 800855e:	f884 3114 	strb.w	r3, [r4, #276]	; 0x114

/* Set the TCP options (if any) for the outgoing packet. */
static UBaseType_t prvSetOptions( FreeRTOS_Socket_t *pxSocket, const NetworkBufferDescriptor_t *pxNetworkBuffer )
{
/* Map the ethernet buffer onto the ProtocolHeader_t struct for easy access to the fields. */
ProtocolHeaders_t *pxProtocolHeaders = ipCAST_PTR_TO_TYPE_PTR( ProtocolHeaders_t,
 8008562:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008564:	f8d3 8018 	ldr.w	r8, [r3, #24]
 8008568:	e00c      	b.n	8008584 <xProcessReceivedTCPPacket+0x678>
				pxSocket->u.xTCP.usRemotePort,
				uxOptionsLength,
				FreeRTOS_ntohl( pxTCPWindow->ulOptionsData[ 1 ] ) - pxSocket->u.xTCP.xTCPWindow.rx.ulFirstSequenceNumber,
				FreeRTOS_ntohl( pxTCPWindow->ulOptionsData[ 2 ] ) - pxSocket->u.xTCP.xTCPWindow.rx.ulFirstSequenceNumber ) );
		}
		( void ) memcpy( ( void * ) ( pxTCPHeader->ucOptdata ), ( const void * ) ( pxTCPWindow->ulOptionsData ), ( size_t ) uxOptionsLength );
 800856a:	f108 0036 	add.w	r0, r8, #54	; 0x36
 800856e:	f504 71ac 	add.w	r1, r4, #344	; 0x158
 8008572:	464a      	mov	r2, r9
 8008574:	f001 fcb6 	bl	8009ee4 <memcpy>

		/* The header length divided by 4, goes into the higher nibble,
		effectively a shift-left 2. */
		pxTCPHeader->ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 8008578:	f109 0314 	add.w	r3, r9, #20
 800857c:	009b      	lsls	r3, r3, #2
 800857e:	f888 302e 	strb.w	r3, [r8, #46]	; 0x2e
 8008582:	e024      	b.n	80085ce <xProcessReceivedTCPPacket+0x6c2>
	}
	else
#endif	/* ipconfigUSE_TCP_WIN */
	if( ( pxSocket->u.xTCP.ucTCPState >= ( EventBits_t ) eESTABLISHED ) && ( pxSocket->u.xTCP.bits.bMssChange != pdFALSE_UNSIGNED ) )
 8008584:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 8008588:	2b04      	cmp	r3, #4
 800858a:	d91d      	bls.n	80085c8 <xProcessReceivedTCPPacket+0x6bc>
 800858c:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8008590:	f013 0f01 	tst.w	r3, #1
 8008594:	d01a      	beq.n	80085cc <xProcessReceivedTCPPacket+0x6c0>
	{
		/* TCP options must be sent because the MSS has changed. */
		pxSocket->u.xTCP.bits.bMssChange = pdFALSE_UNSIGNED;
 8008596:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 800859a:	f36f 0300 	bfc	r3, #0, #1
 800859e:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
		if( xTCPWindowLoggingLevel >= 0 )
		{
			FreeRTOS_debug_printf( ( "MSS: sending %d\n", pxSocket->u.xTCP.usCurMSS ) );
		}

		pxTCPHeader->ucOptdata[ 0 ] = tcpTCP_OPT_MSS;
 80085a2:	2302      	movs	r3, #2
 80085a4:	f888 3036 	strb.w	r3, [r8, #54]	; 0x36
		pxTCPHeader->ucOptdata[ 1 ] = tcpTCP_OPT_MSS_LEN;
 80085a8:	2504      	movs	r5, #4
 80085aa:	f888 5037 	strb.w	r5, [r8, #55]	; 0x37
		pxTCPHeader->ucOptdata[ 2 ] = ( uint8_t ) ( ( pxSocket->u.xTCP.usCurMSS ) >> 8 );
 80085ae:	f8b4 304a 	ldrh.w	r3, [r4, #74]	; 0x4a
 80085b2:	0a1b      	lsrs	r3, r3, #8
 80085b4:	f888 3038 	strb.w	r3, [r8, #56]	; 0x38
		pxTCPHeader->ucOptdata[ 3 ] = ( uint8_t ) ( ( pxSocket->u.xTCP.usCurMSS ) & 0xffU );
 80085b8:	f8b4 304a 	ldrh.w	r3, [r4, #74]	; 0x4a
 80085bc:	f888 3039 	strb.w	r3, [r8, #57]	; 0x39
		uxOptionsLength = 4U;
		pxTCPHeader->ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 80085c0:	2360      	movs	r3, #96	; 0x60
 80085c2:	f888 302e 	strb.w	r3, [r8, #46]	; 0x2e
 80085c6:	e002      	b.n	80085ce <xProcessReceivedTCPPacket+0x6c2>
/* Map the ethernet buffer onto the ProtocolHeader_t struct for easy access to the fields. */
ProtocolHeaders_t *pxProtocolHeaders = ipCAST_PTR_TO_TYPE_PTR( ProtocolHeaders_t,
	&( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + xIPHeaderSize( pxNetworkBuffer ) ] ) );
TCPHeader_t *pxTCPHeader = &pxProtocolHeaders->xTCPHeader;
const TCPWindow_t *pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
UBaseType_t uxOptionsLength = pxTCPWindow->ucOptionLength;
 80085c8:	2500      	movs	r5, #0
 80085ca:	e000      	b.n	80085ce <xProcessReceivedTCPPacket+0x6c2>
 80085cc:	2500      	movs	r5, #0
	}
	else
	{
		uxOptionsLength = prvSetOptions( pxSocket, *ppxNetworkBuffer );

		if( ( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eSYN_RECEIVED ) && ( ( ucTCPFlags & ( uint8_t ) tcpTCP_FLAG_CTRL ) == ( uint8_t ) tcpTCP_FLAG_SYN ) )
 80085ce:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 80085d2:	2b04      	cmp	r3, #4
 80085d4:	d108      	bne.n	80085e8 <xProcessReceivedTCPPacket+0x6dc>
 80085d6:	f00a 021f 	and.w	r2, sl, #31
 80085da:	2a02      	cmp	r2, #2
 80085dc:	f040 8239 	bne.w	8008a52 <xProcessReceivedTCPPacket+0xb46>

			/* In eSYN_RECEIVED a simple ACK is expected, but apparently the
			'SYN+ACK' didn't arrive.  Step back to the previous state in which
			a first incoming SYN is handled.  The SYN was counted already so
			decrease it first. */
			vTCPStateChange( pxSocket, eSYN_FIRST );
 80085e0:	4620      	mov	r0, r4
 80085e2:	2103      	movs	r1, #3
 80085e4:	f7ff f842 	bl	800766c <vTCPStateChange>
		}

		if( ( ( ucTCPFlags & tcpTCP_FLAG_FIN ) != 0U ) && ( pxSocket->u.xTCP.bits.bFinRecv == pdFALSE_UNSIGNED ) )
 80085e8:	f01a 0f01 	tst.w	sl, #1
 80085ec:	d016      	beq.n	800861c <xProcessReceivedTCPPacket+0x710>
 80085ee:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 80085f2:	f013 0f80 	tst.w	r3, #128	; 0x80
 80085f6:	d111      	bne.n	800861c <xProcessReceivedTCPPacket+0x710>
		{
			/* It's the first time a FIN has been received, remember its
			sequence number. */
			pxTCPWindow->rx.ulFINSequenceNumber = ulSequenceNumber + ulReceiveLength;
 80085f8:	9b04      	ldr	r3, [sp, #16]
 80085fa:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
			pxSocket->u.xTCP.bits.bFinRecv = pdTRUE_UNSIGNED;
 80085fe:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8008602:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8008606:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41

			/* Was peer the first one to send a FIN? */
			if( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED )
 800860a:	f013 0f40 	tst.w	r3, #64	; 0x40
 800860e:	d105      	bne.n	800861c <xProcessReceivedTCPPacket+0x710>
			{
				/* If so, don't send the-last-ACK. */
				pxSocket->u.xTCP.bits.bFinLast = pdTRUE_UNSIGNED;
 8008610:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 8008614:	f043 0302 	orr.w	r3, r3, #2
 8008618:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
			}
		}

		switch( ipNUMERIC_CAST( eIPTCPState_t, pxSocket->u.xTCP.ucTCPState ) )
 800861c:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 8008620:	1e9a      	subs	r2, r3, #2
 8008622:	2a08      	cmp	r2, #8
 8008624:	f200 8193 	bhi.w	800894e <xProcessReceivedTCPPacket+0xa42>
 8008628:	e8df f012 	tbh	[pc, r2, lsl #1]
 800862c:	00090058 	.word	0x00090058
 8008630:	00ef0058 	.word	0x00ef0058
 8008634:	018b018b 	.word	0x018b018b
 8008638:	01910191 	.word	0x01910191
 800863c:	018b      	.short	0x018b
 * communicate what MSS (Maximum Segment Size) they intend to use.   MSS is the
 * nett size of the payload, always smaller than MTU.
*/
static UBaseType_t prvSetSynAckOptions( FreeRTOS_Socket_t *pxSocket, TCPHeader_t * pxTCPHeader )
{
uint16_t usMSS = pxSocket->u.xTCP.usInitMSS;
 800863e:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
UBaseType_t uxOptionsLength;

	/* We send out the TCP Maximum Segment Size option with our SYN[+ACK]. */

	pxTCPHeader->ucOptdata[ 0 ] = ( uint8_t ) tcpTCP_OPT_MSS;
 8008642:	2202      	movs	r2, #2
 8008644:	f886 2036 	strb.w	r2, [r6, #54]	; 0x36
	pxTCPHeader->ucOptdata[ 1 ] = ( uint8_t ) tcpTCP_OPT_MSS_LEN;
 8008648:	2204      	movs	r2, #4
 800864a:	f886 2037 	strb.w	r2, [r6, #55]	; 0x37
	pxTCPHeader->ucOptdata[ 2 ] = ( uint8_t ) ( usMSS >> 8 );
 800864e:	0a1a      	lsrs	r2, r3, #8
 8008650:	f886 2038 	strb.w	r2, [r6, #56]	; 0x38
	pxTCPHeader->ucOptdata[ 3 ] = ( uint8_t ) ( usMSS & 0xffU );
 8008654:	f886 3039 	strb.w	r3, [r6, #57]	; 0x39
	{
	size_t uxWinSize;
	uint8_t ucFactor;

		/* 'xTCP.uxRxWinSize' is the size of the reception window in units of MSS. */
		uxWinSize = pxSocket->u.xTCP.uxRxWinSize * ( size_t ) pxSocket->u.xTCP.usInitMSS;
 8008658:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
 800865c:	f8d4 30d0 	ldr.w	r3, [r4, #208]	; 0xd0
 8008660:	fb03 f202 	mul.w	r2, r3, r2
		ucFactor = 0U;
		while( uxWinSize > 0xffffUL )
 8008664:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 8008668:	d307      	bcc.n	800867a <xProcessReceivedTCPPacket+0x76e>
 800866a:	2300      	movs	r3, #0
		{
			/* Divide by two and increase the binary factor by 1. */
			uxWinSize >>= 1;
 800866c:	0852      	lsrs	r2, r2, #1
			ucFactor++;
 800866e:	3301      	adds	r3, #1
 8008670:	b2db      	uxtb	r3, r3
	uint8_t ucFactor;

		/* 'xTCP.uxRxWinSize' is the size of the reception window in units of MSS. */
		uxWinSize = pxSocket->u.xTCP.uxRxWinSize * ( size_t ) pxSocket->u.xTCP.usInitMSS;
		ucFactor = 0U;
		while( uxWinSize > 0xffffUL )
 8008672:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 8008676:	d2f9      	bcs.n	800866c <xProcessReceivedTCPPacket+0x760>
 8008678:	e000      	b.n	800867c <xProcessReceivedTCPPacket+0x770>
	size_t uxWinSize;
	uint8_t ucFactor;

		/* 'xTCP.uxRxWinSize' is the size of the reception window in units of MSS. */
		uxWinSize = pxSocket->u.xTCP.uxRxWinSize * ( size_t ) pxSocket->u.xTCP.usInitMSS;
		ucFactor = 0U;
 800867a:	2300      	movs	r3, #0
	pxTCPHeader->ucOptdata[ 2 ] = ( uint8_t ) ( usMSS >> 8 );
	pxTCPHeader->ucOptdata[ 3 ] = ( uint8_t ) ( usMSS & 0xffU );

	#if( ipconfigUSE_TCP_WIN != 0 )
	{
		pxSocket->u.xTCP.ucMyWinScaleFactor = prvWinScaleFactor( pxSocket );
 800867c:	f884 30c9 	strb.w	r3, [r4, #201]	; 0xc9

		pxTCPHeader->ucOptdata[ 4 ] = tcpTCP_OPT_NOOP;
 8008680:	2301      	movs	r3, #1
 8008682:	f886 303a 	strb.w	r3, [r6, #58]	; 0x3a
		pxTCPHeader->ucOptdata[ 5 ] = ( uint8_t ) ( tcpTCP_OPT_WSOPT );
 8008686:	2203      	movs	r2, #3
 8008688:	f886 203b 	strb.w	r2, [r6, #59]	; 0x3b
		pxTCPHeader->ucOptdata[ 6 ] = ( uint8_t ) ( tcpTCP_OPT_WSOPT_LEN );
 800868c:	f886 203c 	strb.w	r2, [r6, #60]	; 0x3c
		pxTCPHeader->ucOptdata[ 7 ] = ( uint8_t ) pxSocket->u.xTCP.ucMyWinScaleFactor;
 8008690:	f894 20c9 	ldrb.w	r2, [r4, #201]	; 0xc9
 8008694:	f886 203d 	strb.w	r2, [r6, #61]	; 0x3d
	}
	#endif

	#if( ipconfigUSE_TCP_WIN != 0 )
	{
		pxTCPHeader->ucOptdata[ uxOptionsLength      ] = tcpTCP_OPT_NOOP;
 8008698:	f886 303e 	strb.w	r3, [r6, #62]	; 0x3e
		pxTCPHeader->ucOptdata[ uxOptionsLength + 1U ] = tcpTCP_OPT_NOOP;
 800869c:	f886 303f 	strb.w	r3, [r6, #63]	; 0x3f
		pxTCPHeader->ucOptdata[ uxOptionsLength + 2U ] = tcpTCP_OPT_SACK_P;	/* 4: Sack-Permitted Option. */
 80086a0:	2104      	movs	r1, #4
 80086a2:	f886 1040 	strb.w	r1, [r6, #64]	; 0x40
		pxTCPHeader->ucOptdata[ uxOptionsLength + 3U ] = 2U;	/* 2: length of this option. */
 80086a6:	2302      	movs	r3, #2
 80086a8:	f886 3041 	strb.w	r3, [r6, #65]	; 0x41
			{
				/* A new socket has been created, reply with a SYN+ACK.
				Acknowledge with seq+1 because the SYN is seen as pseudo data
				with len = 1. */
				uxOptionsLength = prvSetSynAckOptions( pxSocket, pxTCPHeader );
				pxTCPHeader->ucTCPFlags = ( uint8_t ) tcpTCP_FLAG_SYN | ( uint8_t ) tcpTCP_FLAG_ACK;
 80086ac:	2312      	movs	r3, #18
 80086ae:	f886 302f 	strb.w	r3, [r6, #47]	; 0x2f
				xSendLength = ( BaseType_t ) uxIntermediateResult;

				/* Set the TCP offset field:  ipSIZE_OF_TCP_HEADER equals 20 and
				uxOptionsLength is a multiple of 4.  The complete expression is:
				ucTCPOffset = ( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) / 4 ) << 4 */
				pxTCPHeader->ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 80086b2:	2380      	movs	r3, #128	; 0x80
 80086b4:	f886 302e 	strb.w	r3, [r6, #46]	; 0x2e
				vTCPStateChange( pxSocket, eSYN_RECEIVED );
 80086b8:	4620      	mov	r0, r4
 80086ba:	f7fe ffd7 	bl	800766c <vTCPStateChange>

				pxTCPWindow->rx.ulHighestSequenceNumber = ulSequenceNumber + 1UL;
 80086be:	f10b 0301 	add.w	r3, fp, #1
 80086c2:	f8c4 30f0 	str.w	r3, [r4, #240]	; 0xf0
				pxTCPWindow->rx.ulCurrentSequenceNumber = ulSequenceNumber + 1UL;
 80086c6:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8
				pxTCPWindow->ulNextTxSequenceNumber     = pxTCPWindow->tx.ulFirstSequenceNumber + 1UL;
 80086ca:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
 80086ce:	3301      	adds	r3, #1
 80086d0:	f8c4 310c 	str.w	r3, [r4, #268]	; 0x10c
				pxTCPWindow->tx.ulCurrentSequenceNumber = pxTCPWindow->tx.ulFirstSequenceNumber + 1UL; /* because we send a TCP_SYN. */
 80086d4:	f8c4 30f8 	str.w	r3, [r4, #248]	; 0xf8
				with len = 1. */
				uxOptionsLength = prvSetSynAckOptions( pxSocket, pxTCPHeader );
				pxTCPHeader->ucTCPFlags = ( uint8_t ) tcpTCP_FLAG_SYN | ( uint8_t ) tcpTCP_FLAG_ACK;

				uxIntermediateResult = uxIPHeaderSizeSocket( pxSocket ) + ipSIZE_OF_TCP_HEADER + uxOptionsLength;
				xSendLength = ( BaseType_t ) uxIntermediateResult;
 80086d8:	2034      	movs	r0, #52	; 0x34
 80086da:	e1c4      	b.n	8008a66 <xProcessReceivedTCPPacket+0xb5a>
 */
static BaseType_t prvHandleSynReceived( FreeRTOS_Socket_t *pxSocket, const NetworkBufferDescriptor_t *pxNetworkBuffer,
	uint32_t ulReceiveLength, UBaseType_t uxOptionsLength )
{
/* Map the ethernet buffer onto the ProtocolHeader_t struct for easy access to the fields. */
ProtocolHeaders_t *pxProtocolHeaders = ipCAST_PTR_TO_TYPE_PTR( ProtocolHeaders_t,
 80086dc:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80086de:	f8d2 8018 	ldr.w	r8, [r2, #24]
	&( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + uxIPHeaderSizeSocket( pxSocket ) ] ) );
TCPHeader_t *pxTCPHeader = &pxProtocolHeaders->xTCPHeader;
TCPWindow_t *pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
uint8_t ucTCPFlags = pxTCPHeader->ucTCPFlags;
 80086e2:	f898 002f 	ldrb.w	r0, [r8, #47]	; 0x2f
uint32_t ulSequenceNumber = FreeRTOS_ntohl( pxTCPHeader->ulSequenceNumber );
 80086e6:	f8d8 2026 	ldr.w	r2, [r8, #38]	; 0x26
 80086ea:	0611      	lsls	r1, r2, #24
 80086ec:	ea41 6112 	orr.w	r1, r1, r2, lsr #24
 80086f0:	f402 467f 	and.w	r6, r2, #65280	; 0xff00
 80086f4:	ea41 2606 	orr.w	r6, r1, r6, lsl #8
 80086f8:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
 80086fc:	ea46 2612 	orr.w	r6, r6, r2, lsr #8

	/* Either expect a ACK or a SYN+ACK. */
	uint8_t ucExpect = tcpTCP_FLAG_ACK;
	if( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eCONNECT_SYN )
	{
		ucExpect |= tcpTCP_FLAG_SYN;
 8008700:	2b02      	cmp	r3, #2
 8008702:	bf14      	ite	ne
 8008704:	2210      	movne	r2, #16
 8008706:	2212      	moveq	r2, #18
	}

	const uint8_t ucFlagsMask = tcpTCP_FLAG_ACK | tcpTCP_FLAG_RST | tcpTCP_FLAG_SYN | tcpTCP_FLAG_FIN;

	if( ( ucTCPFlags & ucFlagsMask ) != ucExpect )
 8008708:	f000 0017 	and.w	r0, r0, #23
 800870c:	4290      	cmp	r0, r2
 800870e:	d022      	beq.n	8008756 <xProcessReceivedTCPPacket+0x84a>
		/* eSYN_RECEIVED: flags 0010 expected, not 0002. */
		/* eSYN_RECEIVED: flags ACK  expected, not SYN. */
		FreeRTOS_debug_printf( ( "%s: flags %04X expected, not %04X\n",
			( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eSYN_RECEIVED ) ? "eSYN_RECEIVED" : "eCONNECT_SYN",
			ucExpect, ucTCPFlags ) );
		vTCPStateChange( pxSocket, eCLOSE_WAIT );
 8008710:	4620      	mov	r0, r4
 8008712:	2108      	movs	r1, #8
 8008714:	f7fe ffaa 	bl	800766c <vTCPStateChange>
		/* Send RST with the expected sequence and ACK numbers,
		otherwise the packet will be ignored. */
		pxTCPWindow->ulOurSequenceNumber = FreeRTOS_htonl( pxTCPHeader->ulAckNr );
 8008718:	f8d8 202a 	ldr.w	r2, [r8, #42]	; 0x2a
 800871c:	0613      	lsls	r3, r2, #24
 800871e:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 8008722:	f402 417f 	and.w	r1, r2, #65280	; 0xff00
 8008726:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 800872a:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
 800872e:	ea43 2312 	orr.w	r3, r3, r2, lsr #8
 8008732:	f8c4 3104 	str.w	r3, [r4, #260]	; 0x104
		pxTCPWindow->rx.ulCurrentSequenceNumber = ulSequenceNumber;
 8008736:	f8c4 60e8 	str.w	r6, [r4, #232]	; 0xe8

		pxTCPHeader->ucTCPFlags |= tcpTCP_FLAG_RST;
 800873a:	f898 302f 	ldrb.w	r3, [r8, #47]	; 0x2f
 800873e:	f043 0304 	orr.w	r3, r3, #4
 8008742:	f888 302f 	strb.w	r3, [r8, #47]	; 0x2f

		uxIntermediateResult = uxIPHeaderSizeSocket( pxSocket ) + ipSIZE_OF_TCP_HEADER + uxOptionsLength;
 8008746:	f105 0628 	add.w	r6, r5, #40	; 0x28
		xSendLength = ( BaseType_t ) uxIntermediateResult;

		pxTCPHeader->ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 800874a:	f105 0314 	add.w	r3, r5, #20
 800874e:	009b      	lsls	r3, r3, #2
 8008750:	f888 302e 	strb.w	r3, [r8, #46]	; 0x2e
 8008754:	e0fc      	b.n	8008950 <xProcessReceivedTCPPacket+0xa44>
	}
	else
	{
		pxTCPWindow->usPeerPortNumber = pxSocket->u.xTCP.usRemotePort;
 8008756:	8fa2      	ldrh	r2, [r4, #60]	; 0x3c
 8008758:	f8a4 2192 	strh.w	r2, [r4, #402]	; 0x192
		pxTCPWindow->usOurPortNumber = pxSocket->usLocalPort;
 800875c:	8ca2      	ldrh	r2, [r4, #36]	; 0x24
 800875e:	f8a4 2190 	strh.w	r2, [r4, #400]	; 0x190

		if( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eCONNECT_SYN )
 8008762:	2b02      	cmp	r3, #2
 8008764:	d125      	bne.n	80087b2 <xProcessReceivedTCPPacket+0x8a6>
		/* Map the Last packet onto the ProtocolHeader_t struct for easy access to the fields. */
		ProtocolHeaders_t *pxLastHeaders = ipCAST_PTR_TO_TYPE_PTR( ProtocolHeaders_t,
			&( pxSocket->u.xTCP.xPacket.u.ucLastPacket[ ipSIZE_OF_ETH_HEADER + uxIPHeaderSizeSocket( pxSocket ) ] ) );

			/* Clear the SYN flag in lastPacket. */
			pxLastHeaders->xTCPHeader.ucTCPFlags = tcpTCP_FLAG_ACK;
 8008766:	2310      	movs	r3, #16
 8008768:	f884 30b1 	strb.w	r3, [r4, #177]	; 0xb1
			pxProtocolHeaders->xTCPHeader.ucTCPFlags = tcpTCP_FLAG_ACK;
 800876c:	f888 302f 	strb.w	r3, [r8, #47]	; 0x2f

			/* This socket was the one connecting actively so now perform the
			synchronisation. */
			vTCPWindowInit( &pxSocket->u.xTCP.xTCPWindow,
 8008770:	9803      	ldr	r0, [sp, #12]
 8008772:	4631      	mov	r1, r6
 8008774:	f8d4 2104 	ldr.w	r2, [r4, #260]	; 0x104
 8008778:	f8b4 304a 	ldrh.w	r3, [r4, #74]	; 0x4a
 800877c:	f000 fb1e 	bl	8008dbc <vTCPWindowInit>
				ulSequenceNumber, pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber, ( uint32_t ) pxSocket->u.xTCP.usCurMSS );
			pxTCPWindow->rx.ulHighestSequenceNumber = ulSequenceNumber + 1U;
 8008780:	3601      	adds	r6, #1
 8008782:	f8c4 60f0 	str.w	r6, [r4, #240]	; 0xf0
			pxTCPWindow->rx.ulCurrentSequenceNumber = ulSequenceNumber + 1U;
 8008786:	f8c4 60e8 	str.w	r6, [r4, #232]	; 0xe8
			pxTCPWindow->tx.ulCurrentSequenceNumber++; /* because we send a TCP_SYN [ | TCP_ACK ]; */
 800878a:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
 800878e:	3301      	adds	r3, #1
 8008790:	f8c4 30f8 	str.w	r3, [r4, #248]	; 0xf8
			pxTCPWindow->ulNextTxSequenceNumber++;
 8008794:	f8d4 310c 	ldr.w	r3, [r4, #268]	; 0x10c
 8008798:	3301      	adds	r3, #1
 800879a:	f8c4 310c 	str.w	r3, [r4, #268]	; 0x10c
			/* Nothing. */
		}

		/* The SYN+ACK has been confirmed, increase the next sequence number by
		1. */
		pxTCPWindow->ulOurSequenceNumber = pxTCPWindow->tx.ulFirstSequenceNumber + 1U;
 800879e:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
 80087a2:	3301      	adds	r3, #1
 80087a4:	f8c4 3104 	str.w	r3, [r4, #260]	; 0x104
				pxSocket->u.xTCP.usRemotePort,
				( unsigned ) pxSocket->u.xTCP.bits.bWinScaling ) );
		}
		#endif /* ipconfigUSE_TCP_WIN */

		if( ( pxSocket->u.xTCP.ucTCPState == ( EventBits_t ) eCONNECT_SYN ) || ( ulReceiveLength != 0UL ) )
 80087a8:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 80087ac:	2b02      	cmp	r3, #2
 80087ae:	d110      	bne.n	80087d2 <xProcessReceivedTCPPacket+0x8c6>
 80087b0:	e010      	b.n	80087d4 <xProcessReceivedTCPPacket+0x8c8>
			pxTCPWindow->rx.ulHighestSequenceNumber = ulSequenceNumber + 1U;
			pxTCPWindow->rx.ulCurrentSequenceNumber = ulSequenceNumber + 1U;
			pxTCPWindow->tx.ulCurrentSequenceNumber++; /* because we send a TCP_SYN [ | TCP_ACK ]; */
			pxTCPWindow->ulNextTxSequenceNumber++;
		}
		else if( ulReceiveLength == 0U )
 80087b2:	2f00      	cmp	r7, #0
 80087b4:	f040 8151 	bne.w	8008a5a <xProcessReceivedTCPPacket+0xb4e>
		{
			pxTCPWindow->rx.ulCurrentSequenceNumber = ulSequenceNumber;
 80087b8:	f8c4 60e8 	str.w	r6, [r4, #232]	; 0xe8
			/* Nothing. */
		}

		/* The SYN+ACK has been confirmed, increase the next sequence number by
		1. */
		pxTCPWindow->ulOurSequenceNumber = pxTCPWindow->tx.ulFirstSequenceNumber + 1U;
 80087bc:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
 80087c0:	3301      	adds	r3, #1
 80087c2:	f8c4 3104 	str.w	r3, [r4, #260]	; 0x104
				pxSocket->u.xTCP.usRemotePort,
				( unsigned ) pxSocket->u.xTCP.bits.bWinScaling ) );
		}
		#endif /* ipconfigUSE_TCP_WIN */

		if( ( pxSocket->u.xTCP.ucTCPState == ( EventBits_t ) eCONNECT_SYN ) || ( ulReceiveLength != 0UL ) )
 80087c6:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 80087ca:	2b02      	cmp	r3, #2
 80087cc:	d002      	beq.n	80087d4 <xProcessReceivedTCPPacket+0x8c8>
	&( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + uxIPHeaderSizeSocket( pxSocket ) ] ) );
TCPHeader_t *pxTCPHeader = &pxProtocolHeaders->xTCPHeader;
TCPWindow_t *pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
uint8_t ucTCPFlags = pxTCPHeader->ucTCPFlags;
uint32_t ulSequenceNumber = FreeRTOS_ntohl( pxTCPHeader->ulSequenceNumber );
BaseType_t xSendLength = 0;
 80087ce:	2600      	movs	r6, #0
 80087d0:	e00c      	b.n	80087ec <xProcessReceivedTCPPacket+0x8e0>
				pxSocket->u.xTCP.usRemotePort,
				( unsigned ) pxSocket->u.xTCP.bits.bWinScaling ) );
		}
		#endif /* ipconfigUSE_TCP_WIN */

		if( ( pxSocket->u.xTCP.ucTCPState == ( EventBits_t ) eCONNECT_SYN ) || ( ulReceiveLength != 0UL ) )
 80087d2:	b157      	cbz	r7, 80087ea <xProcessReceivedTCPPacket+0x8de>
		{
			pxTCPHeader->ucTCPFlags = tcpTCP_FLAG_ACK;
 80087d4:	2310      	movs	r3, #16
 80087d6:	f888 302f 	strb.w	r3, [r8, #47]	; 0x2f

			uxIntermediateResult = uxIPHeaderSizeSocket( pxSocket ) + ( size_t ) ipSIZE_OF_TCP_HEADER + uxOptionsLength;
 80087da:	f105 0628 	add.w	r6, r5, #40	; 0x28
			xSendLength = ( BaseType_t ) uxIntermediateResult;
			pxTCPHeader->ucTCPOffset = ( uint8_t ) ( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 80087de:	f105 0314 	add.w	r3, r5, #20
 80087e2:	009b      	lsls	r3, r3, #2
 80087e4:	f888 302e 	strb.w	r3, [r8, #46]	; 0x2e
 80087e8:	e000      	b.n	80087ec <xProcessReceivedTCPPacket+0x8e0>
	&( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + uxIPHeaderSizeSocket( pxSocket ) ] ) );
TCPHeader_t *pxTCPHeader = &pxProtocolHeaders->xTCPHeader;
TCPWindow_t *pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
uint8_t ucTCPFlags = pxTCPHeader->ucTCPFlags;
uint32_t ulSequenceNumber = FreeRTOS_ntohl( pxTCPHeader->ulSequenceNumber );
BaseType_t xSendLength = 0;
 80087ea:	2600      	movs	r6, #0
			xSendLength = ( BaseType_t ) uxIntermediateResult;
			pxTCPHeader->ucTCPOffset = ( uint8_t ) ( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
		}
		#if( ipconfigUSE_TCP_WIN != 0 )
		{
			if( pxSocket->u.xTCP.bits.bWinScaling == pdFALSE_UNSIGNED )
 80087ec:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 80087f0:	f013 0f10 	tst.w	r3, #16
 80087f4:	d104      	bne.n	8008800 <xProcessReceivedTCPPacket+0x8f4>
			{
				/* The other party did not send a scaling factor.
				A shifting factor in this side must be canceled. */
				pxSocket->u.xTCP.ucMyWinScaleFactor = 0;
 80087f6:	2300      	movs	r3, #0
 80087f8:	f884 30c9 	strb.w	r3, [r4, #201]	; 0xc9
				pxSocket->u.xTCP.ucPeerWinScaleFactor = 0;
 80087fc:	f884 30ca 	strb.w	r3, [r4, #202]	; 0xca
			}
		}
		#endif /* ipconfigUSE_TCP_WIN */
		/* This was the third step of connecting: SYN, SYN+ACK, ACK	so now the
		connection is established. */
		vTCPStateChange( pxSocket, eESTABLISHED );
 8008800:	4620      	mov	r0, r4
 8008802:	2105      	movs	r1, #5
 8008804:	f7fe ff32 	bl	800766c <vTCPStateChange>
 8008808:	e0a2      	b.n	8008950 <xProcessReceivedTCPPacket+0xa44>
 */
static BaseType_t prvHandleEstablished( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **ppxNetworkBuffer,
	uint32_t ulReceiveLength, UBaseType_t uxOptionsLength )
{
/* Map the buffer onto the ProtocolHeader_t struct for easy access to the fields. */
ProtocolHeaders_t *pxProtocolHeaders = ipCAST_PTR_TO_TYPE_PTR( ProtocolHeaders_t,
 800880a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800880c:	f8d3 8018 	ldr.w	r8, [r3, #24]
	&( ( *ppxNetworkBuffer )->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + uxIPHeaderSizeSocket( pxSocket ) ] ) );
TCPHeader_t *pxTCPHeader = &pxProtocolHeaders->xTCPHeader;
TCPWindow_t *pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
uint8_t ucTCPFlags = pxTCPHeader->ucTCPFlags;
 8008810:	f898 902f 	ldrb.w	r9, [r8, #47]	; 0x2f
uint32_t ulSequenceNumber = FreeRTOS_ntohl( pxTCPHeader->ulSequenceNumber ), ulCount, ulIntermediateResult = 0;
 8008814:	f8d8 3026 	ldr.w	r3, [r8, #38]	; 0x26
 8008818:	061a      	lsls	r2, r3, #24
 800881a:	ea42 6213 	orr.w	r2, r2, r3, lsr #24
 800881e:	f403 467f 	and.w	r6, r3, #65280	; 0xff00
 8008822:	ea42 2606 	orr.w	r6, r2, r6, lsl #8
 8008826:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 800882a:	ea46 2613 	orr.w	r6, r6, r3, lsr #8
int32_t lDistance, lSendResult;
uint16_t usWindow;
UBaseType_t uxIntermediateResult = 0;

	/* Remember the window size the peer is advertising. */
	usWindow = FreeRTOS_ntohs( pxTCPHeader->usWindow );
 800882e:	f8b8 2030 	ldrh.w	r2, [r8, #48]	; 0x30
 8008832:	0a13      	lsrs	r3, r2, #8
 8008834:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	pxSocket->u.xTCP.ulWindowSize = ( uint32_t ) usWindow;
 8008838:	b29b      	uxth	r3, r3
	#if( ipconfigUSE_TCP_WIN != 0 )
	{
		pxSocket->u.xTCP.ulWindowSize =
			( pxSocket->u.xTCP.ulWindowSize << pxSocket->u.xTCP.ucPeerWinScaleFactor );
 800883a:	f894 20ca 	ldrb.w	r2, [r4, #202]	; 0xca
 800883e:	4093      	lsls	r3, r2
	/* Remember the window size the peer is advertising. */
	usWindow = FreeRTOS_ntohs( pxTCPHeader->usWindow );
	pxSocket->u.xTCP.ulWindowSize = ( uint32_t ) usWindow;
	#if( ipconfigUSE_TCP_WIN != 0 )
	{
		pxSocket->u.xTCP.ulWindowSize =
 8008840:	f8c4 30cc 	str.w	r3, [r4, #204]	; 0xcc
			( pxSocket->u.xTCP.ulWindowSize << pxSocket->u.xTCP.ucPeerWinScaleFactor );
	}
	#endif /* ipconfigUSE_TCP_WIN */

	if( ( ucTCPFlags & ( uint8_t ) tcpTCP_FLAG_ACK ) != 0U )
 8008844:	f019 0f10 	tst.w	r9, #16
 8008848:	d026      	beq.n	8008898 <xProcessReceivedTCPPacket+0x98c>
	{
		ulCount = ulTCPWindowTxAck( pxTCPWindow, FreeRTOS_ntohl( pxTCPHeader->ulAckNr ) );
 800884a:	f8d8 302a 	ldr.w	r3, [r8, #42]	; 0x2a
 800884e:	061a      	lsls	r2, r3, #24
 8008850:	ea42 6213 	orr.w	r2, r2, r3, lsr #24
 8008854:	f403 417f 	and.w	r1, r3, #65280	; 0xff00
 8008858:	ea42 2101 	orr.w	r1, r2, r1, lsl #8
 800885c:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 8008860:	9803      	ldr	r0, [sp, #12]
 8008862:	ea41 2113 	orr.w	r1, r1, r3, lsr #8
 8008866:	f000 fd15 	bl	8009294 <ulTCPWindowTxAck>
 800886a:	4603      	mov	r3, r0

		/* ulTCPWindowTxAck() returns the number of bytes which have been acked,
		starting at 'tx.ulCurrentSequenceNumber'.  Advance the tail pointer in
		txStream. */
		if( ( pxSocket->u.xTCP.txStream != NULL ) && ( ulCount > 0U ) )
 800886c:	6fa0      	ldr	r0, [r4, #120]	; 0x78
 800886e:	b1c0      	cbz	r0, 80088a2 <xProcessReceivedTCPPacket+0x996>
 8008870:	b1a3      	cbz	r3, 800889c <xProcessReceivedTCPPacket+0x990>
		{
			/* Just advancing the tail index, 'ulCount' bytes have been
			confirmed, and because there is new space in the txStream, the
			user/owner should be woken up. */
			/* _HT_ : only in case the socket's waiting? */
			if( uxStreamBufferGet( pxSocket->u.xTCP.txStream, 0U, NULL, ( size_t ) ulCount, pdFALSE ) != 0U )
 8008872:	2200      	movs	r2, #0
 8008874:	9200      	str	r2, [sp, #0]
 8008876:	4611      	mov	r1, r2
 8008878:	f7fe fcf6 	bl	8007268 <uxStreamBufferGet>
 800887c:	b160      	cbz	r0, 8008898 <xProcessReceivedTCPPacket+0x98c>
			{
				pxSocket->xEventBits |= ( EventBits_t ) eSOCKET_SEND;
 800887e:	6823      	ldr	r3, [r4, #0]
 8008880:	f043 0202 	orr.w	r2, r3, #2
 8008884:	6022      	str	r2, [r4, #0]

				#if ipconfigSUPPORT_SELECT_FUNCTION == 1
				{
					if( ( pxSocket->xSelectBits & ( ( EventBits_t ) eSELECT_WRITE ) ) != 0U )
 8008886:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8008888:	f012 0f02 	tst.w	r2, #2
 800888c:	d004      	beq.n	8008898 <xProcessReceivedTCPPacket+0x98c>
					{
						pxSocket->xEventBits |= ( ( EventBits_t ) eSELECT_WRITE ) << SOCKET_EVENT_BIT_COUNT;
 800888e:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8008892:	f043 0302 	orr.w	r3, r3, #2
 8008896:	6023      	str	r3, [r4, #0]
		}
	}

	/* If this socket has a stream for transmission, add the data to the
	outgoing segment(s). */
	if( pxSocket->u.xTCP.txStream != NULL )
 8008898:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 800889a:	b113      	cbz	r3, 80088a2 <xProcessReceivedTCPPacket+0x996>
	{
		prvTCPAddTxData( pxSocket );
 800889c:	4620      	mov	r0, r4
 800889e:	f7fe fd21 	bl	80072e4 <prvTCPAddTxData>
	}

	pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber = pxTCPWindow->tx.ulCurrentSequenceNumber;
 80088a2:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
 80088a6:	f8c4 3104 	str.w	r3, [r4, #260]	; 0x104

	if( ( pxSocket->u.xTCP.bits.bFinAccepted != pdFALSE_UNSIGNED ) || ( ( ucTCPFlags & ( uint8_t ) tcpTCP_FLAG_FIN ) != 0U ) )
 80088aa:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 80088ae:	f013 0f20 	tst.w	r3, #32
 80088b2:	d102      	bne.n	80088ba <xProcessReceivedTCPPacket+0x9ae>
 80088b4:	f019 0f01 	tst.w	r9, #1
 80088b8:	d021      	beq.n	80088fe <xProcessReceivedTCPPacket+0x9f2>
	{
		/* Peer is requesting to stop, see if we're really finished. */
		xMayClose = pdTRUE;

		/* Checks are only necessary if we haven't sent a FIN yet. */
		if( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED )
 80088ba:	f013 0f40 	tst.w	r3, #64	; 0x40
 80088be:	d112      	bne.n	80088e6 <xProcessReceivedTCPPacket+0x9da>
		{
			/* xTCPWindowTxDone returns true when all Tx queues are empty. */
			bRxComplete = xTCPWindowRxEmpty( pxTCPWindow );
 80088c0:	f8dd a00c 	ldr.w	sl, [sp, #12]
 80088c4:	4650      	mov	r0, sl
 80088c6:	f000 fa4b 	bl	8008d60 <xTCPWindowRxEmpty>
 80088ca:	4681      	mov	r9, r0
			bTxDone		= xTCPWindowTxDone( pxTCPWindow );
 80088cc:	4650      	mov	r0, sl
 80088ce:	f000 fc03 	bl	80090d8 <xTCPWindowTxDone>

			if( ( bRxComplete == 0 ) || ( bTxDone == 0 ) )
 80088d2:	f1b9 0f00 	cmp.w	r9, #0
 80088d6:	d012      	beq.n	80088fe <xProcessReceivedTCPPacket+0x9f2>
 80088d8:	b188      	cbz	r0, 80088fe <xProcessReceivedTCPPacket+0x9f2>
 80088da:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 80088de:	1af3      	subs	r3, r6, r3
					bRxComplete, bTxDone ) );
				xMayClose = pdFALSE;
			}
			else
			{
				ulIntermediateResult = ulSequenceNumber + ulReceiveLength - pxTCPWindow->rx.ulCurrentSequenceNumber;
 80088e0:	443b      	add	r3, r7
			FreeRTOS_debug_printf( ( "TCP: FIN received, mayClose = %ld (Rx %lu Len %ld, Tx %lu)\n",
				xMayClose, ulSequenceNumber - pxSocket->u.xTCP.xTCPWindow.rx.ulFirstSequenceNumber, ulReceiveLength,
				pxTCPWindow->tx.ulCurrentSequenceNumber - pxSocket->u.xTCP.xTCPWindow.tx.ulFirstSequenceNumber ) );
		}

		if( xMayClose != pdFALSE )
 80088e2:	2b01      	cmp	r3, #1
 80088e4:	dc0b      	bgt.n	80088fe <xProcessReceivedTCPPacket+0x9f2>
		{
			pxSocket->u.xTCP.bits.bFinAccepted = pdTRUE_UNSIGNED;
 80088e6:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 80088ea:	f043 0320 	orr.w	r3, r3, #32
 80088ee:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
			xSendLength = prvTCPHandleFin( pxSocket, *ppxNetworkBuffer );
 80088f2:	4620      	mov	r0, r4
 80088f4:	9909      	ldr	r1, [sp, #36]	; 0x24
 80088f6:	f7ff fa95 	bl	8007e24 <prvTCPHandleFin>
 80088fa:	4606      	mov	r6, r0
 80088fc:	e028      	b.n	8008950 <xProcessReceivedTCPPacket+0xa44>
		}
	}

	if( xMayClose == pdFALSE )
	{
		pxTCPHeader->ucTCPFlags = tcpTCP_FLAG_ACK;
 80088fe:	2310      	movs	r3, #16
 8008900:	f888 302f 	strb.w	r3, [r8, #47]	; 0x2f

		if( ulReceiveLength != 0U )
 8008904:	2f00      	cmp	r7, #0
 8008906:	f000 80c5 	beq.w	8008a94 <xProcessReceivedTCPPacket+0xb88>
		{
			uxIntermediateResult = uxIPHeaderSizeSocket( pxSocket ) + ipSIZE_OF_TCP_HEADER + uxOptionsLength;
 800890a:	f105 0628 	add.w	r6, r5, #40	; 0x28
			xSendLength = ( BaseType_t ) uxIntermediateResult;
			/* TCP-offsett equals '( ( length / 4 ) << 4 )', resulting in a shift-left 2 */
			pxTCPHeader->ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 800890e:	f105 0314 	add.w	r3, r5, #20
 8008912:	009b      	lsls	r3, r3, #2
 8008914:	f888 302e 	strb.w	r3, [r8, #46]	; 0x2e

			if( pxSocket->u.xTCP.bits.bFinSent != pdFALSE_UNSIGNED )
 8008918:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 800891c:	f013 0f40 	tst.w	r3, #64	; 0x40
			{
				pxTCPWindow->tx.ulCurrentSequenceNumber = pxTCPWindow->tx.ulFINSequenceNumber;
 8008920:	bf1c      	itt	ne
 8008922:	f8d4 30fc 	ldrne.w	r3, [r4, #252]	; 0xfc
 8008926:	f8c4 30f8 	strne.w	r3, [r4, #248]	; 0xf8
		/* Now get data to be transmitted. */
		/* _HT_ patch: since the MTU has be fixed at 1500 in stead of 1526, TCP
		can not	send-out both TCP options and also a full packet. Sending
		options (SACK) is always more urgent than sending data, which can be
		sent later. */
		if( uxOptionsLength == 0U )
 800892a:	b98d      	cbnz	r5, 8008950 <xProcessReceivedTCPPacket+0xa44>
 800892c:	e000      	b.n	8008930 <xProcessReceivedTCPPacket+0xa24>
 800892e:	2600      	movs	r6, #0
		{
			/* prvTCPPrepareSend might allocate a bigger network buffer, if
			necessary. */
			lSendResult = prvTCPPrepareSend( pxSocket, ppxNetworkBuffer, uxOptionsLength );
 8008930:	4620      	mov	r0, r4
 8008932:	a909      	add	r1, sp, #36	; 0x24
 8008934:	2200      	movs	r2, #0
 8008936:	f7fe ff7d 	bl	8007834 <prvTCPPrepareSend>
			if( lSendResult > 0 )
 800893a:	2800      	cmp	r0, #0
 800893c:	f300 8093 	bgt.w	8008a66 <xProcessReceivedTCPPacket+0xb5a>
 8008940:	e006      	b.n	8008950 <xProcessReceivedTCPPacket+0xa44>
			/* Fall through */
		case eFIN_WAIT_1:	/* (server + client) waiting for a connection termination request from the remote TCP,
							 * or an acknowledgement of the connection termination request previously sent. */
			/* Fall through */
		case eFIN_WAIT_2:	/* (server + client) waiting for a connection termination request from the remote TCP. */
			xSendLength = prvTCPHandleFin( pxSocket, *ppxNetworkBuffer );
 8008942:	4620      	mov	r0, r4
 8008944:	9909      	ldr	r1, [sp, #36]	; 0x24
 8008946:	f7ff fa6d 	bl	8007e24 <prvTCPHandleFin>
 800894a:	4606      	mov	r6, r0
 800894c:	e000      	b.n	8008950 <xProcessReceivedTCPPacket+0xa44>
{
/* Map the buffer onto the ProtocolHeader_t struct for easy access to the fields. */
ProtocolHeaders_t *pxProtocolHeaders = ipCAST_PTR_TO_TYPE_PTR( ProtocolHeaders_t,
	&( ( *ppxNetworkBuffer )->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + xIPHeaderSize( *ppxNetworkBuffer ) ] ) );
TCPHeader_t *pxTCPHeader = &( pxProtocolHeaders->xTCPHeader );
BaseType_t xSendLength = 0;
 800894e:	2600      	movs	r6, #0
			/* No more known states. */
			break;
		}
	}

	if( xSendLength > 0 )
 8008950:	2e00      	cmp	r6, #0
 8008952:	dd41      	ble.n	80089d8 <xProcessReceivedTCPPacket+0xacc>
 */
static BaseType_t prvSendData( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **ppxNetworkBuffer,
	uint32_t ulReceiveLength, BaseType_t xByteCount )
{
/* Map the buffer onto the ProtocolHeader_t struct for easy access to the fields. */
const ProtocolHeaders_t *pxProtocolHeaders = ipCAST_PTR_TO_TYPE_PTR( ProtocolHeaders_t,
 8008954:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008956:	699a      	ldr	r2, [r3, #24]
	#endif
#endif

	/* Set the time-out field, so that we'll be called by the IP-task in case no
	next message will be received. */
	ulRxBufferSpace = pxSocket->u.xTCP.ulHighestRxAllowed - pxTCPWindow->rx.ulCurrentSequenceNumber;
 8008958:	6c65      	ldr	r5, [r4, #68]	; 0x44
 800895a:	f8d4 00e8 	ldr.w	r0, [r4, #232]	; 0xe8
	#if ipconfigUSE_TCP_WIN == 1
	{

		#if( ipconfigTCP_ACK_EARLIER_PACKET != 0 )
		{
			lMinLength = ( ( int32_t ) 2 ) * ( ( int32_t ) pxSocket->u.xTCP.usCurMSS );
 800895e:	f8b4 104a 	ldrh.w	r1, [r4, #74]	; 0x4a
		#endif /* ipconfigTCP_ACK_EARLIER_PACKET */

		/* In case we're receiving data continuously, we might postpone sending
		an ACK to gain performance. */
		/* lint e9007 is OK because 'uxIPHeaderSizeSocket()' has no side-effects. */
		if( ( ulReceiveLength > 0U ) &&							/* Data was sent to this socket. */
 8008962:	b35f      	cbz	r7, 80089bc <xProcessReceivedTCPPacket+0xab0>
	#endif
#endif

	/* Set the time-out field, so that we'll be called by the IP-task in case no
	next message will be received. */
	ulRxBufferSpace = pxSocket->u.xTCP.ulHighestRxAllowed - pxTCPWindow->rx.ulCurrentSequenceNumber;
 8008964:	1a2d      	subs	r5, r5, r0
		#endif /* ipconfigTCP_ACK_EARLIER_PACKET */

		/* In case we're receiving data continuously, we might postpone sending
		an ACK to gain performance. */
		/* lint e9007 is OK because 'uxIPHeaderSizeSocket()' has no side-effects. */
		if( ( ulReceiveLength > 0U ) &&							/* Data was sent to this socket. */
 8008966:	ebb5 0f41 	cmp.w	r5, r1, lsl #1
 800896a:	db27      	blt.n	80089bc <xProcessReceivedTCPPacket+0xab0>
			( lRxSpace >= lMinLength ) &&						/* There is Rx space for more data. */
			( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED ) &&	/* Not in a closure phase. */
 800896c:	f894 1041 	ldrb.w	r1, [r4, #65]	; 0x41

		/* In case we're receiving data continuously, we might postpone sending
		an ACK to gain performance. */
		/* lint e9007 is OK because 'uxIPHeaderSizeSocket()' has no side-effects. */
		if( ( ulReceiveLength > 0U ) &&							/* Data was sent to this socket. */
			( lRxSpace >= lMinLength ) &&						/* There is Rx space for more data. */
 8008970:	f011 0f40 	tst.w	r1, #64	; 0x40
 8008974:	d122      	bne.n	80089bc <xProcessReceivedTCPPacket+0xab0>
			( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED ) &&	/* Not in a closure phase. */
 8008976:	2e28      	cmp	r6, #40	; 0x28
 8008978:	d120      	bne.n	80089bc <xProcessReceivedTCPPacket+0xab0>
			( xSendLength == ipNUMERIC_CAST( BaseType_t, uxIPHeaderSizeSocket( pxSocket ) + ipSIZE_OF_TCP_HEADER ) ) && /* No Tx data or options to be sent. */
 800897a:	f894 1053 	ldrb.w	r1, [r4, #83]	; 0x53
 800897e:	2905      	cmp	r1, #5
 8008980:	d11c      	bne.n	80089bc <xProcessReceivedTCPPacket+0xab0>
			( pxSocket->u.xTCP.ucTCPState == ( uint8_t ) eESTABLISHED ) &&	/* Connection established. */
 8008982:	f892 202f 	ldrb.w	r2, [r2, #47]	; 0x2f
 8008986:	2a10      	cmp	r2, #16
 8008988:	d118      	bne.n	80089bc <xProcessReceivedTCPPacket+0xab0>
			( pxTCPHeader->ucTCPFlags == tcpTCP_FLAG_ACK ) )		/* There are no other flags than an ACK. */
		{
			if( pxSocket->u.xTCP.pxAckMessage != *ppxNetworkBuffer )
 800898a:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 800898c:	4283      	cmp	r3, r0
 800898e:	d004      	beq.n	800899a <xProcessReceivedTCPPacket+0xa8e>
			{
				/* There was still a delayed in queue, delete it. */
				if( pxSocket->u.xTCP.pxAckMessage != NULL )
 8008990:	b108      	cbz	r0, 8008996 <xProcessReceivedTCPPacket+0xa8a>
				{
					vReleaseNetworkBufferAndDescriptor( pxSocket->u.xTCP.pxAckMessage );
 8008992:	f7fb fe1d 	bl	80045d0 <vReleaseNetworkBufferAndDescriptor>
				}

				pxSocket->u.xTCP.pxAckMessage = *ppxNetworkBuffer;
 8008996:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008998:	67e3      	str	r3, [r4, #124]	; 0x7c
			}
			if( ( ulReceiveLength < ( uint32_t ) pxSocket->u.xTCP.usCurMSS ) ||	/* Received a small message. */
 800899a:	f8b4 304a 	ldrh.w	r3, [r4, #74]	; 0x4a
 800899e:	429f      	cmp	r7, r3
 80089a0:	d302      	bcc.n	80089a8 <xProcessReceivedTCPPacket+0xa9c>
 80089a2:	ebb5 0f43 	cmp.w	r5, r3, lsl #1
 80089a6:	da03      	bge.n	80089b0 <xProcessReceivedTCPPacket+0xaa4>
				( lRxSpace < ipNUMERIC_CAST( int32_t, 2U * pxSocket->u.xTCP.usCurMSS ) ) )	/* There are less than 2 x MSS space in the Rx buffer. */
			{
				pxSocket->u.xTCP.usTimeout = ( uint16_t ) tcpDELAYED_ACK_SHORT_DELAY_MS;
 80089a8:	2302      	movs	r3, #2
 80089aa:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
 80089ae:	e002      	b.n	80089b6 <xProcessReceivedTCPPacket+0xaaa>
			else
			{
				/* Normally a delayed ACK should wait 200 ms for a next incoming
				packet.  Only wait 20 ms here to gain performance.  A slow ACK
				for full-size message. */
				pxSocket->u.xTCP.usTimeout = ( uint16_t ) ipMS_TO_MIN_TICKS( tcpDELAYED_ACK_LONGER_DELAY_MS );
 80089b0:	2314      	movs	r3, #20
 80089b2:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
					pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber - pxTCPWindow->tx.ulFirstSequenceNumber,
					xSendLength,
					pxSocket->u.xTCP.usTimeout, lRxSpace ) );
			}

			*ppxNetworkBuffer = NULL;
 80089b6:	2300      	movs	r3, #0
 80089b8:	9309      	str	r3, [sp, #36]	; 0x24
 80089ba:	e00d      	b.n	80089d8 <xProcessReceivedTCPPacket+0xacc>
			xSendLength = 0;
		}
		else if( pxSocket->u.xTCP.pxAckMessage != NULL )
 80089bc:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 80089be:	2800      	cmp	r0, #0
 80089c0:	d053      	beq.n	8008a6a <xProcessReceivedTCPPacket+0xb5e>
		{
			/* As an ACK is not being delayed, remove any earlier delayed ACK
			message. */
			if( pxSocket->u.xTCP.pxAckMessage != *ppxNetworkBuffer )
 80089c2:	4283      	cmp	r3, r0
 80089c4:	d001      	beq.n	80089ca <xProcessReceivedTCPPacket+0xabe>
			{
				vReleaseNetworkBufferAndDescriptor( pxSocket->u.xTCP.pxAckMessage );
 80089c6:	f7fb fe03 	bl	80045d0 <vReleaseNetworkBufferAndDescriptor>
			}

			pxSocket->u.xTCP.pxAckMessage = NULL;
 80089ca:	2300      	movs	r3, #0
 80089cc:	67e3      	str	r3, [r4, #124]	; 0x7c
 80089ce:	e04c      	b.n	8008a6a <xProcessReceivedTCPPacket+0xb5e>
			{
				/* prvTCPHandleState() has sent a message, see if there are more to
				be transmitted. */
				#if( ipconfigUSE_TCP_WIN == 1 )
				{
					( void ) prvTCPSendRepeated( pxSocket, &pxNetworkBuffer );
 80089d0:	4620      	mov	r0, r4
 80089d2:	a909      	add	r1, sp, #36	; 0x24
 80089d4:	f7ff f896 	bl	8007b04 <prvTCPSendRepeated>
				}
				#endif /* ipconfigUSE_TCP_WIN */
			}

			if( pxNetworkBuffer != NULL )
 80089d8:	9809      	ldr	r0, [sp, #36]	; 0x24
 80089da:	b118      	cbz	r0, 80089e4 <xProcessReceivedTCPPacket+0xad8>
			{
				/* We must check if the buffer is unequal to NULL, because the
				socket might keep a reference to it in case a delayed ACK must be
				sent. */
				vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 80089dc:	f7fb fdf8 	bl	80045d0 <vReleaseNetworkBufferAndDescriptor>
				#ifndef _lint
				/* Clear pointers that are freed. */
				pxNetworkBuffer = NULL;
 80089e0:	2300      	movs	r3, #0
 80089e2:	9309      	str	r3, [sp, #36]	; 0x24
				#endif
			}

			/* And finally, calculate when this socket wants to be woken up. */
			( void ) prvTCPNextTimeout ( pxSocket );
 80089e4:	4620      	mov	r0, r4
 80089e6:	f7fe fddb 	bl	80075a0 <prvTCPNextTimeout>
			/* Return pdPASS to tell that the network buffer is 'consumed'. */
			xResult = pdPASS;
 80089ea:	2001      	movs	r0, #1
 80089ec:	e055      	b.n	8008a9a <xProcessReceivedTCPPacket+0xb8e>
const IPHeader_t *pxIPHeader;

	/* Check for a minimum packet size. */
	if( pxNetworkBuffer->xDataLength < ( ipSIZE_OF_ETH_HEADER + xIPHeaderSize( pxNetworkBuffer ) + ipSIZE_OF_TCP_HEADER ) )
	{
		xResult = pdFAIL;
 80089ee:	2000      	movs	r0, #0
 80089f0:	e053      	b.n	8008a9a <xProcessReceivedTCPPacket+0xb8e>
				}
			}
		}
	}

	if( ( ulInitialSequenceNumber != 0U ) && ( pxReturn != NULL ) )
 80089f2:	2d00      	cmp	r5, #0
 80089f4:	f47f ab80 	bne.w	80080f8 <xProcessReceivedTCPPacket+0x1ec>
 80089f8:	e040      	b.n	8008a7c <xProcessReceivedTCPPacket+0xb70>
			}

			/* And finally, calculate when this socket wants to be woken up. */
			( void ) prvTCPNextTimeout ( pxSocket );
			/* Return pdPASS to tell that the network buffer is 'consumed'. */
			xResult = pdPASS;
 80089fa:	2000      	movs	r0, #0
 80089fc:	e04d      	b.n	8008a9a <xProcessReceivedTCPPacket+0xb8e>
		uxIndex = 0U;
	}
	else if( pucPtr[ 0U ] == tcpTCP_OPT_NOOP )
	{
		/* NOP option, inserted to make the length a multiple of 4. */
		uxIndex = 1U;
 80089fe:	2501      	movs	r5, #1
 8008a00:	e500      	b.n	8008404 <xProcessReceivedTCPPacket+0x4f8>
			if( xHasSYNFlag != 0 )
			{
				pxSocket->u.xTCP.ucPeerWinScaleFactor = pucPtr[ 2 ];
				pxSocket->u.xTCP.bits.bWinScaling = pdTRUE_UNSIGNED;
			}
			uxIndex = tcpTCP_OPT_WSOPT_LEN;
 8008a02:	2503      	movs	r5, #3
 8008a04:	e4fe      	b.n	8008404 <xProcessReceivedTCPPacket+0x4f8>
					pxTCPWindow->usMSS = ( uint16_t ) uxNewMSS;
					pxSocket->u.xTCP.usInitMSS = ( uint16_t ) uxNewMSS;
					pxSocket->u.xTCP.usCurMSS = ( uint16_t ) uxNewMSS;
				}

				uxIndex = tcpTCP_OPT_MSS_LEN;
 8008a06:	2504      	movs	r5, #4
 8008a08:	e4fc      	b.n	8008404 <xProcessReceivedTCPPacket+0x4f8>
		#if( ipconfigUSE_TCP_WIN == 1 )
		{
			/* Now lTCPAddRxdata() will move the rxHead pointer forward
			so data becomes available to the user immediately
			In case the low-water mark is reached, bLowWater will be set. */
			if( ( xResult == 0 ) && ( pxTCPWindow->ulUserDataLength > 0UL ) )
 8008a0a:	f8d4 3108 	ldr.w	r3, [r4, #264]	; 0x108
 8008a0e:	2b00      	cmp	r3, #0
 8008a10:	f47f ad9b 	bne.w	800854a <xProcessReceivedTCPPacket+0x63e>

/* Set the TCP options (if any) for the outgoing packet. */
static UBaseType_t prvSetOptions( FreeRTOS_Socket_t *pxSocket, const NetworkBufferDescriptor_t *pxNetworkBuffer )
{
/* Map the ethernet buffer onto the ProtocolHeader_t struct for easy access to the fields. */
ProtocolHeaders_t *pxProtocolHeaders = ipCAST_PTR_TO_TYPE_PTR( ProtocolHeaders_t,
 8008a14:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008a16:	f8d3 8018 	ldr.w	r8, [r3, #24]
	&( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + xIPHeaderSize( pxNetworkBuffer ) ] ) );
TCPHeader_t *pxTCPHeader = &pxProtocolHeaders->xTCPHeader;
const TCPWindow_t *pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
UBaseType_t uxOptionsLength = pxTCPWindow->ucOptionLength;
 8008a1a:	f894 9114 	ldrb.w	r9, [r4, #276]	; 0x114
 8008a1e:	464d      	mov	r5, r9

#if(	ipconfigUSE_TCP_WIN == 1 )
	if( uxOptionsLength != 0U )
 8008a20:	f1b9 0f00 	cmp.w	r9, #0
 8008a24:	f47f ada1 	bne.w	800856a <xProcessReceivedTCPPacket+0x65e>
 8008a28:	e5ac      	b.n	8008584 <xProcessReceivedTCPPacket+0x678>
 */
static BaseType_t prvHandleSynReceived( FreeRTOS_Socket_t *pxSocket, const NetworkBufferDescriptor_t *pxNetworkBuffer,
	uint32_t ulReceiveLength, UBaseType_t uxOptionsLength )
{
/* Map the ethernet buffer onto the ProtocolHeader_t struct for easy access to the fields. */
ProtocolHeaders_t *pxProtocolHeaders = ipCAST_PTR_TO_TYPE_PTR( ProtocolHeaders_t,
 8008a2a:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8008a2c:	f8d2 8018 	ldr.w	r8, [r2, #24]
	&( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + uxIPHeaderSizeSocket( pxSocket ) ] ) );
TCPHeader_t *pxTCPHeader = &pxProtocolHeaders->xTCPHeader;
TCPWindow_t *pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
uint8_t ucTCPFlags = pxTCPHeader->ucTCPFlags;
 8008a30:	f898 002f 	ldrb.w	r0, [r8, #47]	; 0x2f
uint32_t ulSequenceNumber = FreeRTOS_ntohl( pxTCPHeader->ulSequenceNumber );
 8008a34:	f8d8 2026 	ldr.w	r2, [r8, #38]	; 0x26
 8008a38:	0611      	lsls	r1, r2, #24
 8008a3a:	ea41 6112 	orr.w	r1, r1, r2, lsr #24
 8008a3e:	f402 467f 	and.w	r6, r2, #65280	; 0xff00
 8008a42:	ea41 2606 	orr.w	r6, r1, r6, lsl #8
 8008a46:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
 8008a4a:	ea46 2612 	orr.w	r6, r6, r2, lsr #8
BaseType_t xSendLength = 0;
UBaseType_t uxIntermediateResult = 0;

	/* Either expect a ACK or a SYN+ACK. */
	uint8_t ucExpect = tcpTCP_FLAG_ACK;
 8008a4e:	2210      	movs	r2, #16
 8008a50:	e65a      	b.n	8008708 <xProcessReceivedTCPPacket+0x7fc>
			a first incoming SYN is handled.  The SYN was counted already so
			decrease it first. */
			vTCPStateChange( pxSocket, eSYN_FIRST );
		}

		if( ( ( ucTCPFlags & tcpTCP_FLAG_FIN ) != 0U ) && ( pxSocket->u.xTCP.bits.bFinRecv == pdFALSE_UNSIGNED ) )
 8008a52:	f01a 0f01 	tst.w	sl, #1
 8008a56:	d116      	bne.n	8008a86 <xProcessReceivedTCPPacket+0xb7a>
 8008a58:	e7e7      	b.n	8008a2a <xProcessReceivedTCPPacket+0xb1e>
			/* Nothing. */
		}

		/* The SYN+ACK has been confirmed, increase the next sequence number by
		1. */
		pxTCPWindow->ulOurSequenceNumber = pxTCPWindow->tx.ulFirstSequenceNumber + 1U;
 8008a5a:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
 8008a5e:	3301      	adds	r3, #1
 8008a60:	f8c4 3104 	str.w	r3, [r4, #260]	; 0x104
 8008a64:	e6b6      	b.n	80087d4 <xProcessReceivedTCPPacket+0x8c8>
{
/* Map the buffer onto the ProtocolHeader_t struct for easy access to the fields. */
ProtocolHeaders_t *pxProtocolHeaders = ipCAST_PTR_TO_TYPE_PTR( ProtocolHeaders_t,
	&( ( *ppxNetworkBuffer )->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + xIPHeaderSize( *ppxNetworkBuffer ) ] ) );
TCPHeader_t *pxTCPHeader = &( pxProtocolHeaders->xTCPHeader );
BaseType_t xSendLength = 0;
 8008a66:	4606      	mov	r6, r0
 8008a68:	e774      	b.n	8008954 <xProcessReceivedTCPPacket+0xa48>
				xSendLength ) );
		}

		/* Set the parameter 'xReleaseAfterSend' to the value of
		ipconfigZERO_COPY_TX_DRIVER. */
		prvTCPReturnPacket( pxSocket, *ppxNetworkBuffer, ( uint32_t ) xSendLength, ipconfigZERO_COPY_TX_DRIVER );
 8008a6a:	4620      	mov	r0, r4
 8008a6c:	9909      	ldr	r1, [sp, #36]	; 0x24
 8008a6e:	4632      	mov	r2, r6
 8008a70:	2300      	movs	r3, #0
 8008a72:	f7fe fc61 	bl	8007338 <prvTCPReturnPacket>
			}
			#endif /* ipconfigUSE_TCP_WIN */

			/* In prvTCPHandleState() the incoming messages will be handled
			depending on the current state of the connection. */
			if( prvTCPHandleState( pxSocket, &pxNetworkBuffer ) > 0 )
 8008a76:	2e00      	cmp	r6, #0
 8008a78:	dcaa      	bgt.n	80089d0 <xProcessReceivedTCPPacket+0xac4>
 8008a7a:	e7ad      	b.n	80089d8 <xProcessReceivedTCPPacket+0xacc>
			}

			/* And finally, calculate when this socket wants to be woken up. */
			( void ) prvTCPNextTimeout ( pxSocket );
			/* Return pdPASS to tell that the network buffer is 'consumed'. */
			xResult = pdPASS;
 8008a7c:	2000      	movs	r0, #0
 8008a7e:	e00c      	b.n	8008a9a <xProcessReceivedTCPPacket+0xb8e>
				/* If so, don't send the-last-ACK. */
				pxSocket->u.xTCP.bits.bFinLast = pdTRUE_UNSIGNED;
			}
		}

		switch( ipNUMERIC_CAST( eIPTCPState_t, pxSocket->u.xTCP.ucTCPState ) )
 8008a80:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 8008a84:	e62a      	b.n	80086dc <xProcessReceivedTCPPacket+0x7d0>
			a first incoming SYN is handled.  The SYN was counted already so
			decrease it first. */
			vTCPStateChange( pxSocket, eSYN_FIRST );
		}

		if( ( ( ucTCPFlags & tcpTCP_FLAG_FIN ) != 0U ) && ( pxSocket->u.xTCP.bits.bFinRecv == pdFALSE_UNSIGNED ) )
 8008a86:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8008a8a:	f013 0f80 	tst.w	r3, #128	; 0x80
 8008a8e:	f43f adb3 	beq.w	80085f8 <xProcessReceivedTCPPacket+0x6ec>
 8008a92:	e7f5      	b.n	8008a80 <xProcessReceivedTCPPacket+0xb74>
		/* Now get data to be transmitted. */
		/* _HT_ patch: since the MTU has be fixed at 1500 in stead of 1526, TCP
		can not	send-out both TCP options and also a full packet. Sending
		options (SACK) is always more urgent than sending data, which can be
		sent later. */
		if( uxOptionsLength == 0U )
 8008a94:	2d00      	cmp	r5, #0
 8008a96:	d19f      	bne.n	80089d8 <xProcessReceivedTCPPacket+0xacc>
 8008a98:	e749      	b.n	800892e <xProcessReceivedTCPPacket+0xa22>
			xResult = pdPASS;
		}
	}
	/* pdPASS being returned means the buffer has been consumed. */
	return xResult;
}
 8008a9a:	b00b      	add	sp, #44	; 0x2c
 8008a9c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08008aa0 <xTCPCheckNewClient>:
 * In the API accept(), the user asks is there is a new client?  As API's can
 * not walk through the xBoundTCPSocketsList the IP-task will do this.
 */
BaseType_t xTCPCheckNewClient( FreeRTOS_Socket_t *pxSocket )
{
TickType_t uxLocalPort = ( TickType_t ) FreeRTOS_htons( pxSocket->usLocalPort );
 8008aa0:	8c81      	ldrh	r1, [r0, #36]	; 0x24
 8008aa2:	0a0b      	lsrs	r3, r1, #8
 8008aa4:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 8008aa8:	b289      	uxth	r1, r1
BaseType_t xResult = pdFALSE;
const ListItem_t *pxEndTCP = listGET_END_MARKER( &xBoundTCPSocketsList );

	/* Here xBoundTCPSocketsList can be accessed safely IP-task is the only one
	who has access. */
	for( pxIterator = ( const ListItem_t * ) listGET_HEAD_ENTRY( &xBoundTCPSocketsList );
 8008aaa:	4a10      	ldr	r2, [pc, #64]	; (8008aec <xTCPCheckNewClient+0x4c>)
 8008aac:	68d3      	ldr	r3, [r2, #12]
 8008aae:	3208      	adds	r2, #8
 8008ab0:	4293      	cmp	r3, r2
 8008ab2:	d016      	beq.n	8008ae2 <xTCPCheckNewClient+0x42>
/*
 * In the API accept(), the user asks is there is a new client?  As API's can
 * not walk through the xBoundTCPSocketsList the IP-task will do this.
 */
BaseType_t xTCPCheckNewClient( FreeRTOS_Socket_t *pxSocket )
{
 8008ab4:	b430      	push	{r4, r5}
BaseType_t xResult = pdFALSE;
const ListItem_t *pxEndTCP = listGET_END_MARKER( &xBoundTCPSocketsList );

	/* Here xBoundTCPSocketsList can be accessed safely IP-task is the only one
	who has access. */
	for( pxIterator = ( const ListItem_t * ) listGET_HEAD_ENTRY( &xBoundTCPSocketsList );
 8008ab6:	4614      	mov	r4, r2
		pxIterator != pxEndTCP;
		pxIterator = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
	{
		if( listGET_LIST_ITEM_VALUE( pxIterator ) == ( configLIST_VOLATILE TickType_t ) uxLocalPort )
 8008ab8:	681a      	ldr	r2, [r3, #0]
 8008aba:	428a      	cmp	r2, r1
 8008abc:	d10c      	bne.n	8008ad8 <xTCPCheckNewClient+0x38>
		{
			pxFound = ipCAST_PTR_TO_TYPE_PTR( FreeRTOS_Socket_t, listGET_LIST_ITEM_OWNER( pxIterator ) );
 8008abe:	68da      	ldr	r2, [r3, #12]
			if( ( pxFound->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_TCP ) && ( pxFound->u.xTCP.bits.bPassAccept != pdFALSE_UNSIGNED ) )
 8008ac0:	f892 5027 	ldrb.w	r5, [r2, #39]	; 0x27
 8008ac4:	2d06      	cmp	r5, #6
 8008ac6:	d107      	bne.n	8008ad8 <xTCPCheckNewClient+0x38>
 8008ac8:	f892 5040 	ldrb.w	r5, [r2, #64]	; 0x40
 8008acc:	f015 0f02 	tst.w	r5, #2
 8008ad0:	d002      	beq.n	8008ad8 <xTCPCheckNewClient+0x38>
			{
				pxSocket->u.xTCP.pxPeerSocket = pxFound;
 8008ad2:	6542      	str	r2, [r0, #84]	; 0x54
				FreeRTOS_debug_printf( ( "xTCPCheckNewClient[0]: client on port %u\n", pxSocket->usLocalPort ) );
				xResult = pdTRUE;
 8008ad4:	2001      	movs	r0, #1
				break;
 8008ad6:	e006      	b.n	8008ae6 <xTCPCheckNewClient+0x46>

	/* Here xBoundTCPSocketsList can be accessed safely IP-task is the only one
	who has access. */
	for( pxIterator = ( const ListItem_t * ) listGET_HEAD_ENTRY( &xBoundTCPSocketsList );
		pxIterator != pxEndTCP;
		pxIterator = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
 8008ad8:	685b      	ldr	r3, [r3, #4]
BaseType_t xResult = pdFALSE;
const ListItem_t *pxEndTCP = listGET_END_MARKER( &xBoundTCPSocketsList );

	/* Here xBoundTCPSocketsList can be accessed safely IP-task is the only one
	who has access. */
	for( pxIterator = ( const ListItem_t * ) listGET_HEAD_ENTRY( &xBoundTCPSocketsList );
 8008ada:	42a3      	cmp	r3, r4
 8008adc:	d1ec      	bne.n	8008ab8 <xTCPCheckNewClient+0x18>
BaseType_t xTCPCheckNewClient( FreeRTOS_Socket_t *pxSocket )
{
TickType_t uxLocalPort = ( TickType_t ) FreeRTOS_htons( pxSocket->usLocalPort );
const ListItem_t *pxIterator;
FreeRTOS_Socket_t *pxFound;
BaseType_t xResult = pdFALSE;
 8008ade:	2000      	movs	r0, #0
 8008ae0:	e001      	b.n	8008ae6 <xTCPCheckNewClient+0x46>
 8008ae2:	2000      	movs	r0, #0
 8008ae4:	4770      	bx	lr
				break;
			}
		}
	}
	return xResult;
}
 8008ae6:	bc30      	pop	{r4, r5}
 8008ae8:	4770      	bx	lr
 8008aea:	bf00      	nop
 8008aec:	2000d4f8 	.word	0x2000d4f8

08008af0 <vListInsertGeneric>:
static void vListInsertGeneric( List_t * const pxList, ListItem_t * const pxNewListItem, MiniListItem_t * const pxWhere )
{
	/* Insert a new list item into pxList, it does not sort the list,
	but it puts the item just before xListEnd, so it will be the last item
	returned by listGET_HEAD_ENTRY() */
	pxNewListItem->pxNext = ( struct xLIST_ITEM * configLIST_VOLATILE )pxWhere;
 8008af0:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxPrevious = pxWhere->pxPrevious;
 8008af2:	6893      	ldr	r3, [r2, #8]
 8008af4:	608b      	str	r3, [r1, #8]
	pxWhere->pxPrevious->pxNext = pxNewListItem;
 8008af6:	6893      	ldr	r3, [r2, #8]
 8008af8:	6059      	str	r1, [r3, #4]
	pxWhere->pxPrevious = pxNewListItem;
 8008afa:	6091      	str	r1, [r2, #8]

	/* Remember which list the item is in. */
	listLIST_ITEM_CONTAINER( pxNewListItem ) = ( struct xLIST * configLIST_VOLATILE )pxList;
 8008afc:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 8008afe:	6803      	ldr	r3, [r0, #0]
 8008b00:	3301      	adds	r3, #1
 8008b02:	6003      	str	r3, [r0, #0]
 8008b04:	4770      	bx	lr
 8008b06:	bf00      	nop

08008b08 <xTCPWindowRxFind>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	static TCPSegment_t *xTCPWindowRxFind( const TCPWindow_t *pxWindow, uint32_t ulSequenceNumber )
	{
 8008b08:	b410      	push	{r4}
	const ListItem_t* pxEnd;
	TCPSegment_t *pxSegment, *pxReturn = NULL;

		/* Find a segment with a given sequence number in the list of received
		segments. */
		pxEnd = listGET_END_MARKER( &pxWindow->xRxSegments );
 8008b0a:	f100 04ac 	add.w	r4, r0, #172	; 0xac

		for( pxIterator  = listGET_NEXT( pxEnd );
 8008b0e:	f8d0 30b0 	ldr.w	r3, [r0, #176]	; 0xb0
 8008b12:	429c      	cmp	r4, r3
 8008b14:	d00d      	beq.n	8008b32 <xTCPWindowRxFind+0x2a>
			 pxIterator != pxEnd;
			 pxIterator  = listGET_NEXT( pxIterator ) )
		{
			pxSegment = ipCAST_PTR_TO_TYPE_PTR( TCPSegment_t, listGET_LIST_ITEM_OWNER( pxIterator ) );
 8008b16:	68d8      	ldr	r0, [r3, #12]

			if( pxSegment->ulSequenceNumber == ulSequenceNumber )
 8008b18:	6802      	ldr	r2, [r0, #0]
 8008b1a:	428a      	cmp	r2, r1
 8008b1c:	d104      	bne.n	8008b28 <xTCPWindowRxFind+0x20>
 8008b1e:	e009      	b.n	8008b34 <xTCPWindowRxFind+0x2c>

		for( pxIterator  = listGET_NEXT( pxEnd );
			 pxIterator != pxEnd;
			 pxIterator  = listGET_NEXT( pxIterator ) )
		{
			pxSegment = ipCAST_PTR_TO_TYPE_PTR( TCPSegment_t, listGET_LIST_ITEM_OWNER( pxIterator ) );
 8008b20:	68d8      	ldr	r0, [r3, #12]

			if( pxSegment->ulSequenceNumber == ulSequenceNumber )
 8008b22:	6802      	ldr	r2, [r0, #0]
 8008b24:	428a      	cmp	r2, r1
 8008b26:	d005      	beq.n	8008b34 <xTCPWindowRxFind+0x2c>
		segments. */
		pxEnd = listGET_END_MARKER( &pxWindow->xRxSegments );

		for( pxIterator  = listGET_NEXT( pxEnd );
			 pxIterator != pxEnd;
			 pxIterator  = listGET_NEXT( pxIterator ) )
 8008b28:	685b      	ldr	r3, [r3, #4]

		/* Find a segment with a given sequence number in the list of received
		segments. */
		pxEnd = listGET_END_MARKER( &pxWindow->xRxSegments );

		for( pxIterator  = listGET_NEXT( pxEnd );
 8008b2a:	429c      	cmp	r4, r3
 8008b2c:	d1f8      	bne.n	8008b20 <xTCPWindowRxFind+0x18>

	static TCPSegment_t *xTCPWindowRxFind( const TCPWindow_t *pxWindow, uint32_t ulSequenceNumber )
	{
	const ListItem_t *pxIterator;
	const ListItem_t* pxEnd;
	TCPSegment_t *pxSegment, *pxReturn = NULL;
 8008b2e:	2000      	movs	r0, #0
 8008b30:	e000      	b.n	8008b34 <xTCPWindowRxFind+0x2c>
 8008b32:	2000      	movs	r0, #0
				break;
			}
		}

		return pxReturn;
	}
 8008b34:	f85d 4b04 	ldr.w	r4, [sp], #4
 8008b38:	4770      	bx	lr
 8008b3a:	bf00      	nop

08008b3c <prvTCPWindowTxHasSpace>:
	{
	const ListItem_t *pxItem;
	TCPSegment_t *pxReturn;

		/* Returns the head of a queue but it won't be detached. */
		if( listLIST_IS_EMPTY( pxList ) != pdFALSE )
 8008b3c:	6d43      	ldr	r3, [r0, #84]	; 0x54
 8008b3e:	b1c3      	cbz	r3, 8008b72 <prvTCPWindowTxHasSpace+0x36>
			pxReturn = NULL;
		}
		else
		{
			pxItem = ( ListItem_t * ) listGET_HEAD_ENTRY( pxList );
			pxReturn = ipCAST_PTR_TO_TYPE_PTR( TCPSegment_t, listGET_LIST_ITEM_OWNER( pxItem ) );
 8008b40:	6e03      	ldr	r3, [r0, #96]	; 0x60
 8008b42:	68da      	ldr	r2, [r3, #12]
		/* This function will look if there is new transmission data.  It will
		return true if there is data to be sent. */

		pxSegment = xTCPWindowPeekHead( &( pxWindow->xTxQueue ) );

		if( pxSegment == NULL )
 8008b44:	b1c2      	cbz	r2, 8008b78 <prvTCPWindowTxHasSpace+0x3c>
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	static BaseType_t prvTCPWindowTxHasSpace( TCPWindow_t const * pxWindow, uint32_t ulWindowSize )
	{
 8008b46:	b410      	push	{r4}
		}
		else
		{
			/* How much data is outstanding, i.e. how much data has been sent
			but not yet acknowledged ? */
			if( pxWindow->tx.ulHighestSequenceNumber >= pxWindow->tx.ulCurrentSequenceNumber )
 8008b48:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8008b4a:	6a04      	ldr	r4, [r0, #32]
 8008b4c:	42a3      	cmp	r3, r4
 8008b4e:	d315      	bcc.n	8008b7c <prvTCPWindowTxHasSpace+0x40>
			{
				ulTxOutstanding = pxWindow->tx.ulHighestSequenceNumber - pxWindow->tx.ulCurrentSequenceNumber;
 8008b50:	1b1b      	subs	r3, r3, r4

			/* Subtract this from the peer's space. */
			ulNettSize = ulWindowSize - FreeRTOS_min_uint32( ulWindowSize, ulTxOutstanding );

			/* See if the next segment may be sent. */
			if( ulNettSize >= ( uint32_t ) pxSegment->lDataLength )
 8008b52:	6892      	ldr	r2, [r2, #8]
			{
				ulTxOutstanding = 0UL;
			}

			/* Subtract this from the peer's space. */
			ulNettSize = ulWindowSize - FreeRTOS_min_uint32( ulWindowSize, ulTxOutstanding );
 8008b54:	4299      	cmp	r1, r3
 8008b56:	bf94      	ite	ls
 8008b58:	1a49      	subls	r1, r1, r1
 8008b5a:	1ac9      	subhi	r1, r1, r3

			/* See if the next segment may be sent. */
			if( ulNettSize >= ( uint32_t ) pxSegment->lDataLength )
 8008b5c:	4291      	cmp	r1, r2
 8008b5e:	bf34      	ite	cc
 8008b60:	2100      	movcc	r1, #0
 8008b62:	2101      	movcs	r1, #1

			/* If 'xHasSpace', it looks like the peer has at least space for 1
			more new segment of size MSS.  xSize.ulTxWindowLength is the self-imposed
			limitation of the transmission window (in case of many resends it
			may be decreased). */
			if( ( ulTxOutstanding != 0UL ) && ( pxWindow->xSize.ulTxWindowLength < ( ulTxOutstanding + ( ( uint32_t ) pxSegment->lDataLength ) ) ) )
 8008b64:	b17b      	cbz	r3, 8008b86 <prvTCPWindowTxHasSpace+0x4a>
 8008b66:	4413      	add	r3, r2
 8008b68:	6882      	ldr	r2, [r0, #8]
			{
				xHasSpace = pdFALSE;
 8008b6a:	429a      	cmp	r2, r3
 8008b6c:	bf38      	it	cc
 8008b6e:	2100      	movcc	r1, #0
 8008b70:	e009      	b.n	8008b86 <prvTCPWindowTxHasSpace+0x4a>

		pxSegment = xTCPWindowPeekHead( &( pxWindow->xTxQueue ) );

		if( pxSegment == NULL )
		{
			xHasSpace = pdFALSE;
 8008b72:	2100      	movs	r1, #0
				xHasSpace = pdFALSE;
			}
		}

		return xHasSpace;
	}
 8008b74:	4608      	mov	r0, r1
 8008b76:	4770      	bx	lr

		pxSegment = xTCPWindowPeekHead( &( pxWindow->xTxQueue ) );

		if( pxSegment == NULL )
		{
			xHasSpace = pdFALSE;
 8008b78:	2100      	movs	r1, #0
 8008b7a:	e7fb      	b.n	8008b74 <prvTCPWindowTxHasSpace+0x38>

			/* Subtract this from the peer's space. */
			ulNettSize = ulWindowSize - FreeRTOS_min_uint32( ulWindowSize, ulTxOutstanding );

			/* See if the next segment may be sent. */
			if( ulNettSize >= ( uint32_t ) pxSegment->lDataLength )
 8008b7c:	6890      	ldr	r0, [r2, #8]
 8008b7e:	4281      	cmp	r1, r0
 8008b80:	bf34      	ite	cc
 8008b82:	2100      	movcc	r1, #0
 8008b84:	2101      	movcs	r1, #1
				xHasSpace = pdFALSE;
			}
		}

		return xHasSpace;
	}
 8008b86:	4608      	mov	r0, r1
 8008b88:	f85d 4b04 	ldr.w	r4, [sp], #4
 8008b8c:	4770      	bx	lr
 8008b8e:	bf00      	nop

08008b90 <vTCPWindowFree>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	static void vTCPWindowFree( TCPSegment_t *pxSegment )
	{
 8008b90:	b510      	push	{r4, lr}
 8008b92:	4604      	mov	r4, r0
		/*  Free entry pxSegment because it's not used any more.  The ownership
		will be passed back to the segment pool.

		Unlink it from one of the queues, if any. */
		if( listLIST_ITEM_CONTAINER( &( pxSegment->xQueueItem ) ) != NULL )
 8008b94:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8008b96:	b113      	cbz	r3, 8008b9e <vTCPWindowFree+0xe>
		{
			( void ) uxListRemove( &( pxSegment->xQueueItem ) );
 8008b98:	3018      	adds	r0, #24
 8008b9a:	f7f9 fbdd 	bl	8002358 <uxListRemove>
		}

		pxSegment->ulSequenceNumber = 0UL;
 8008b9e:	2300      	movs	r3, #0
 8008ba0:	6023      	str	r3, [r4, #0]
		pxSegment->lDataLength = 0L;
 8008ba2:	60a3      	str	r3, [r4, #8]
		pxSegment->u.ulFlags = 0UL;
 8008ba4:	6163      	str	r3, [r4, #20]

		/* Take it out of xRxSegments/xTxSegments */
		if( listLIST_ITEM_CONTAINER( &( pxSegment->xSegmentItem ) ) != NULL )
 8008ba6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8008ba8:	b11b      	cbz	r3, 8008bb2 <vTCPWindowFree+0x22>
		{
			( void ) uxListRemove( &( pxSegment->xSegmentItem ) );
 8008baa:	f104 002c 	add.w	r0, r4, #44	; 0x2c
 8008bae:	f7f9 fbd3 	bl	8002358 <uxListRemove>

#if( ipconfigUSE_TCP_WIN == 1 )
	static portINLINE void vListInsertFifo( List_t * const pxList, ListItem_t * const pxNewListItem );
	static portINLINE void vListInsertFifo( List_t * const pxList, ListItem_t * const pxNewListItem )
	{
		vListInsertGeneric( pxList, pxNewListItem, &pxList->xListEnd );
 8008bb2:	4a04      	ldr	r2, [pc, #16]	; (8008bc4 <vTCPWindowFree+0x34>)
 8008bb4:	4610      	mov	r0, r2
 8008bb6:	f104 012c 	add.w	r1, r4, #44	; 0x2c
 8008bba:	3208      	adds	r2, #8
 8008bbc:	f7ff ff98 	bl	8008af0 <vListInsertGeneric>
 8008bc0:	bd10      	pop	{r4, pc}
 8008bc2:	bf00      	nop
 8008bc4:	2000d3f4 	.word	0x2000d3f4

08008bc8 <xTCPWindowNew>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	static TCPSegment_t *xTCPWindowNew( TCPWindow_t *pxWindow, uint32_t ulSequenceNumber, int32_t lCount, BaseType_t xIsForRx )
	{
 8008bc8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	TCPSegment_t *pxSegment;
	ListItem_t * pxItem;

		/* Allocate a new segment.  The socket will borrow all segments from a
		common pool: 'xSegmentList', which is a list of 'TCPSegment_t' */
		if( listLIST_IS_EMPTY( &xSegmentList ) != pdFALSE )
 8008bcc:	4c23      	ldr	r4, [pc, #140]	; (8008c5c <xTCPWindowNew+0x94>)
 8008bce:	6824      	ldr	r4, [r4, #0]
 8008bd0:	2c00      	cmp	r4, #0
 8008bd2:	d03f      	beq.n	8008c54 <xTCPWindowNew+0x8c>
		}
		else
		{
			/* Pop the item at the head of the list.  Semaphore protection is
			not required as only the IP task will call these functions.  */
			pxItem = ( ListItem_t * ) listGET_HEAD_ENTRY( &xSegmentList );
 8008bd4:	4c21      	ldr	r4, [pc, #132]	; (8008c5c <xTCPWindowNew+0x94>)
 8008bd6:	68e7      	ldr	r7, [r4, #12]
			pxSegment = ipCAST_PTR_TO_TYPE_PTR( TCPSegment_t, listGET_LIST_ITEM_OWNER( pxItem ) );
 8008bd8:	68fc      	ldr	r4, [r7, #12]

			configASSERT( pxItem != NULL );
 8008bda:	b947      	cbnz	r7, 8008bee <xTCPWindowNew+0x26>
 8008bdc:	f04f 0314 	mov.w	r3, #20
 8008be0:	f383 8811 	msr	BASEPRI, r3
 8008be4:	f3bf 8f6f 	isb	sy
 8008be8:	f3bf 8f4f 	dsb	sy
 8008bec:	e7fe      	b.n	8008bec <xTCPWindowNew+0x24>
			configASSERT( pxSegment != NULL );
 8008bee:	b944      	cbnz	r4, 8008c02 <xTCPWindowNew+0x3a>
 8008bf0:	f04f 0314 	mov.w	r3, #20
 8008bf4:	f383 8811 	msr	BASEPRI, r3
 8008bf8:	f3bf 8f6f 	isb	sy
 8008bfc:	f3bf 8f4f 	dsb	sy
 8008c00:	e7fe      	b.n	8008c00 <xTCPWindowNew+0x38>
 8008c02:	461d      	mov	r5, r3
 8008c04:	4690      	mov	r8, r2
 8008c06:	4689      	mov	r9, r1
 8008c08:	4606      	mov	r6, r0

			/* Remove the item from xSegmentList. */
			( void ) uxListRemove( pxItem );
 8008c0a:	4638      	mov	r0, r7
 8008c0c:	f7f9 fba4 	bl	8002358 <uxListRemove>

			/* Add it to either the connections' Rx or Tx queue. */
			if( xIsForRx != 0 )
 8008c10:	b13d      	cbz	r5, 8008c22 <xTCPWindowNew+0x5a>

#if( ipconfigUSE_TCP_WIN == 1 )
	static portINLINE void vListInsertFifo( List_t * const pxList, ListItem_t * const pxNewListItem );
	static portINLINE void vListInsertFifo( List_t * const pxList, ListItem_t * const pxNewListItem )
	{
		vListInsertGeneric( pxList, pxNewListItem, &pxList->xListEnd );
 8008c12:	f106 00a4 	add.w	r0, r6, #164	; 0xa4
 8008c16:	4639      	mov	r1, r7
 8008c18:	f106 02ac 	add.w	r2, r6, #172	; 0xac
 8008c1c:	f7ff ff68 	bl	8008af0 <vListInsertGeneric>
 8008c20:	e006      	b.n	8008c30 <xTCPWindowNew+0x68>
 8008c22:	f106 0090 	add.w	r0, r6, #144	; 0x90
 8008c26:	4639      	mov	r1, r7
 8008c28:	f106 0298 	add.w	r2, r6, #152	; 0x98
 8008c2c:	f7ff ff60 	bl	8008af0 <vListInsertGeneric>
/*-----------------------------------------------------------*/

static portINLINE void vTCPTimerSet( TCPTimer_t *pxTimer );
static portINLINE void vTCPTimerSet( TCPTimer_t *pxTimer )
{
	pxTimer->ulBorn = xTaskGetTickCount ( );
 8008c30:	f7fa fac4 	bl	80031bc <xTaskGetTickCount>
 8008c34:	6120      	str	r0, [r4, #16]
			}

			/* And set the segment's timer to zero */
			vTCPTimerSet( &pxSegment->xTransmitTimer );

			pxSegment->u.ulFlags = 0;
 8008c36:	2300      	movs	r3, #0
 8008c38:	6163      	str	r3, [r4, #20]
			pxSegment->u.bits.bIsForRx = ( xIsForRx != 0 ) ? 1U : 0U;
 8008c3a:	1aed      	subs	r5, r5, r3
 8008c3c:	bf18      	it	ne
 8008c3e:	2501      	movne	r5, #1
 8008c40:	f365 0382 	bfi	r3, r5, #2, #1
 8008c44:	75a3      	strb	r3, [r4, #22]
			pxSegment->lMaxLength = lCount;
 8008c46:	f8c4 8004 	str.w	r8, [r4, #4]
			pxSegment->lDataLength = lCount;
 8008c4a:	f8c4 8008 	str.w	r8, [r4, #8]
			pxSegment->ulSequenceNumber = ulSequenceNumber;
 8008c4e:	f8c4 9000 	str.w	r9, [r4]
 8008c52:	e000      	b.n	8008c56 <xTCPWindowNew+0x8e>
		if( listLIST_IS_EMPTY( &xSegmentList ) != pdFALSE )
		{
			/* If the TCP-stack runs out of segments, you might consider
			increasing 'ipconfigTCP_WIN_SEG_COUNT'. */
			FreeRTOS_debug_printf( ( "xTCPWindow%cxNew: Error: all segments occupied\n", ( xIsForRx != 0 ) ? 'R' : 'T' ) );
			pxSegment = NULL;
 8008c54:	2400      	movs	r4, #0
			}
			#endif /* ipconfigHAS_DEBUG_PRINTF */
		}

		return pxSegment;
	}
 8008c56:	4620      	mov	r0, r4
 8008c58:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8008c5c:	2000d3f4 	.word	0x2000d3f4

08008c60 <prvTCPWindowTxCheckAck>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	static uint32_t prvTCPWindowTxCheckAck( TCPWindow_t *pxWindow, uint32_t ulFirst, uint32_t ulLast )
	{
 8008c60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008c64:	b083      	sub	sp, #12
 8008c66:	4682      	mov	sl, r0
 8008c68:	9201      	str	r2, [sp, #4]
	uint32_t ulBytesConfirmed = 0U;
	uint32_t ulSequenceNumber = ulFirst, ulDataLength;
	const ListItem_t *pxIterator;
	const ListItem_t *pxEnd = listGET_END_MARKER( &pxWindow->xTxSegments );
 8008c6a:	f100 0898 	add.w	r8, r0, #152	; 0x98
		  RTO is Retransmit timeout

		 A Smoothed RTT will increase quickly, but it is conservative when
		 becoming smaller. */

		pxIterator  = listGET_NEXT( pxEnd );
 8008c6e:	f8d0 509c 	ldr.w	r5, [r0, #156]	; 0x9c
		while( ( pxIterator != pxEnd ) && ( xSequenceLessThan( ulSequenceNumber, ulLast ) != 0 ) )
 8008c72:	45a8      	cmp	r8, r5
 8008c74:	d05c      	beq.n	8008d30 <prvTCPWindowTxCheckAck+0xd0>
 8008c76:	460c      	mov	r4, r1
 8008c78:	f102 39ff 	add.w	r9, r2, #4294967295
	static portINLINE BaseType_t xSequenceLessThan( uint32_t a, uint32_t b )
	{
	BaseType_t xResult;

		/* Test if a < b */
		if( ( ( b - ( a + 1UL ) ) & 0x80000000UL ) == 0UL )
 8008c7c:	ebc1 0309 	rsb	r3, r1, r9

		 A Smoothed RTT will increase quickly, but it is conservative when
		 becoming smaller. */

		pxIterator  = listGET_NEXT( pxEnd );
		while( ( pxIterator != pxEnd ) && ( xSequenceLessThan( ulSequenceNumber, ulLast ) != 0 ) )
 8008c80:	2b00      	cmp	r3, #0
 8008c82:	db58      	blt.n	8008d36 <prvTCPWindowTxCheckAck+0xd6>
 8008c84:	2300      	movs	r3, #0
 8008c86:	9300      	str	r3, [sp, #0]
 8008c88:	ea6f 0b02 	mvn.w	fp, r2
		{
			xDoUnlink = pdFALSE;
			pxSegment = ipCAST_PTR_TO_TYPE_PTR( TCPSegment_t, listGET_LIST_ITEM_OWNER( pxIterator ) );
 8008c8c:	68ee      	ldr	r6, [r5, #12]

			/* Move to the next item because the current item might get
			removed. */
			pxIterator = ( const ListItem_t * ) listGET_NEXT( pxIterator );
 8008c8e:	686d      	ldr	r5, [r5, #4]

			/* Continue if this segment does not fall within the ACK'd range. */
			if( xSequenceGreaterThan( ulSequenceNumber, pxSegment->ulSequenceNumber ) != pdFALSE )
 8008c90:	6833      	ldr	r3, [r6, #0]
 8008c92:	43da      	mvns	r2, r3
 8008c94:	42e2      	cmn	r2, r4
 8008c96:	d544      	bpl.n	8008d22 <prvTCPWindowTxCheckAck+0xc2>
			{
				continue;
			}

			/* Is it ready? */
			if( ulSequenceNumber != pxSegment->ulSequenceNumber )
 8008c98:	429c      	cmp	r4, r3
 8008c9a:	d15d      	bne.n	8008d58 <prvTCPWindowTxCheckAck+0xf8>
			{
				/* coverity[break_stmt] : Break statement terminating the loop */
				break;
			}

			ulDataLength = ( uint32_t ) pxSegment->lDataLength;
 8008c9c:	68b7      	ldr	r7, [r6, #8]

			if( pxSegment->u.bits.bAcked == pdFALSE_UNSIGNED )
 8008c9e:	7db3      	ldrb	r3, [r6, #22]
 8008ca0:	f013 0f02 	tst.w	r3, #2
 8008ca4:	d153      	bne.n	8008d4e <prvTCPWindowTxCheckAck+0xee>
			{
				if( xSequenceGreaterThan( pxSegment->ulSequenceNumber + ( uint32_t )ulDataLength, ulLast ) != pdFALSE )
 8008ca6:	19e2      	adds	r2, r4, r7
 8008ca8:	eb1b 0f02 	cmn.w	fp, r2
 8008cac:	d554      	bpl.n	8008d58 <prvTCPWindowTxCheckAck+0xf8>
					#endif	/* ipconfigHAS_DEBUG_PRINTF */
					break;
				}

				/* This segment is fully ACK'd, set the flag. */
				pxSegment->u.bits.bAcked = pdTRUE;
 8008cae:	f043 0302 	orr.w	r3, r3, #2
 8008cb2:	75b3      	strb	r3, [r6, #22]

				/* Calculate the RTT only if the segment was sent-out for the
				first time and if this is the last ACK'd segment in a range. */
				if( ( pxSegment->u.bits.ucTransmitCount == 1U ) && ( ( pxSegment->ulSequenceNumber + ulDataLength ) == ulLast ) )
 8008cb4:	7d33      	ldrb	r3, [r6, #20]
 8008cb6:	2b01      	cmp	r3, #1
 8008cb8:	d144      	bne.n	8008d44 <prvTCPWindowTxCheckAck+0xe4>
 8008cba:	9b01      	ldr	r3, [sp, #4]
 8008cbc:	4293      	cmp	r3, r2
 8008cbe:	d141      	bne.n	8008d44 <prvTCPWindowTxCheckAck+0xe4>
/*-----------------------------------------------------------*/

static portINLINE uint32_t ulTimerGetAge( const TCPTimer_t *pxTimer );
static portINLINE uint32_t ulTimerGetAge( const TCPTimer_t *pxTimer )
{
	return ( ( xTaskGetTickCount() - ( ( TickType_t ) pxTimer->ulBorn ) ) * portTICK_PERIOD_MS );
 8008cc0:	f7fa fa7c 	bl	80031bc <xTaskGetTickCount>
 8008cc4:	6933      	ldr	r3, [r6, #16]
 8008cc6:	1ac0      	subs	r0, r0, r3
				first time and if this is the last ACK'd segment in a range. */
				if( ( pxSegment->u.bits.ucTransmitCount == 1U ) && ( ( pxSegment->ulSequenceNumber + ulDataLength ) == ulLast ) )
				{
					int32_t mS = ( int32_t ) ulTimerGetAge( &( pxSegment->xTransmitTimer ) );

					if( pxWindow->lSRTT >= mS )
 8008cc8:	f8da 3038 	ldr.w	r3, [sl, #56]	; 0x38
 8008ccc:	4298      	cmp	r0, r3
 8008cce:	dc08      	bgt.n	8008ce2 <prvTCPWindowTxCheckAck+0x82>
					{
						/* RTT becomes smaller: adapt slowly. */
						pxWindow->lSRTT = ( ( winSRTT_DECREMENT_NEW * mS ) + ( winSRTT_DECREMENT_CURRENT * pxWindow->lSRTT ) ) / ( winSRTT_DECREMENT_NEW + winSRTT_DECREMENT_CURRENT );
 8008cd0:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 8008cd4:	181b      	adds	r3, r3, r0
 8008cd6:	bf48      	it	mi
 8008cd8:	3307      	addmi	r3, #7
 8008cda:	10db      	asrs	r3, r3, #3
 8008cdc:	f8ca 3038 	str.w	r3, [sl, #56]	; 0x38
 8008ce0:	e008      	b.n	8008cf4 <prvTCPWindowTxCheckAck+0x94>
					}
					else
					{
						/* RTT becomes larger: adapt quicker */
						pxWindow->lSRTT = ( ( winSRTT_INCREMENT_NEW * mS ) + ( winSRTT_INCREMENT_CURRENT * pxWindow->lSRTT ) ) / ( winSRTT_INCREMENT_NEW + winSRTT_INCREMENT_CURRENT );
 8008ce2:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8008ce6:	4418      	add	r0, r3
 8008ce8:	0040      	lsls	r0, r0, #1
 8008cea:	bf48      	it	mi
 8008cec:	3007      	addmi	r0, #7
 8008cee:	10c0      	asrs	r0, r0, #3
 8008cf0:	f8ca 0038 	str.w	r0, [sl, #56]	; 0x38
					}

					/* Cap to the minimum of 50ms. */
					if( pxWindow->lSRTT < winSRTT_CAP_mS )
 8008cf4:	f8da 3038 	ldr.w	r3, [sl, #56]	; 0x38
 8008cf8:	2b31      	cmp	r3, #49	; 0x31
 8008cfa:	dc23      	bgt.n	8008d44 <prvTCPWindowTxCheckAck+0xe4>
					{
						pxWindow->lSRTT = winSRTT_CAP_mS;
 8008cfc:	2332      	movs	r3, #50	; 0x32
 8008cfe:	f8ca 3038 	str.w	r3, [sl, #56]	; 0x38
 8008d02:	e01f      	b.n	8008d44 <prvTCPWindowTxCheckAck+0xe4>
						ulLast - pxWindow->tx.ulFirstSequenceNumber,
						pxSegment->ulSequenceNumber - pxWindow->tx.ulFirstSequenceNumber ) );
				}

				/* Increase the left-hand value of the transmission window. */
				pxWindow->tx.ulCurrentSequenceNumber += ulDataLength;
 8008d04:	193b      	adds	r3, r7, r4
 8008d06:	f8ca 3020 	str.w	r3, [sl, #32]

				/* This function will return the number of bytes that the tail
				of txStream may be advanced. */
				ulBytesConfirmed += ulDataLength;
 8008d0a:	9b00      	ldr	r3, [sp, #0]
 8008d0c:	443b      	add	r3, r7
 8008d0e:	9300      	str	r3, [sp, #0]

				/* All segments below tx.ulCurrentSequenceNumber may be freed. */
				vTCPWindowFree( pxSegment );
 8008d10:	4630      	mov	r0, r6
 8008d12:	f7ff ff3d 	bl	8008b90 <vTCPWindowFree>
 8008d16:	e003      	b.n	8008d20 <prvTCPWindowTxCheckAck+0xc0>
			}

			if( ( xDoUnlink != pdFALSE ) && ( listLIST_ITEM_CONTAINER( &( pxSegment->xQueueItem ) ) != NULL ) )
			{
				/* Remove item from its queues. */
				( void ) uxListRemove( &pxSegment->xQueueItem );
 8008d18:	f106 0018 	add.w	r0, r6, #24
 8008d1c:	f7f9 fb1c 	bl	8002358 <uxListRemove>
			}

			ulSequenceNumber += ulDataLength;
 8008d20:	443c      	add	r4, r7

		 A Smoothed RTT will increase quickly, but it is conservative when
		 becoming smaller. */

		pxIterator  = listGET_NEXT( pxEnd );
		while( ( pxIterator != pxEnd ) && ( xSequenceLessThan( ulSequenceNumber, ulLast ) != 0 ) )
 8008d22:	45a8      	cmp	r8, r5
 8008d24:	d018      	beq.n	8008d58 <prvTCPWindowTxCheckAck+0xf8>
	static portINLINE BaseType_t xSequenceLessThan( uint32_t a, uint32_t b )
	{
	BaseType_t xResult;

		/* Test if a < b */
		if( ( ( b - ( a + 1UL ) ) & 0x80000000UL ) == 0UL )
 8008d26:	ebc4 0309 	rsb	r3, r4, r9

		 A Smoothed RTT will increase quickly, but it is conservative when
		 becoming smaller. */

		pxIterator  = listGET_NEXT( pxEnd );
		while( ( pxIterator != pxEnd ) && ( xSequenceLessThan( ulSequenceNumber, ulLast ) != 0 ) )
 8008d2a:	2b00      	cmp	r3, #0
 8008d2c:	daae      	bge.n	8008c8c <prvTCPWindowTxCheckAck+0x2c>
 8008d2e:	e013      	b.n	8008d58 <prvTCPWindowTxCheckAck+0xf8>

#if( ipconfigUSE_TCP_WIN == 1 )

	static uint32_t prvTCPWindowTxCheckAck( TCPWindow_t *pxWindow, uint32_t ulFirst, uint32_t ulLast )
	{
	uint32_t ulBytesConfirmed = 0U;
 8008d30:	2300      	movs	r3, #0
 8008d32:	9300      	str	r3, [sp, #0]
 8008d34:	e010      	b.n	8008d58 <prvTCPWindowTxCheckAck+0xf8>
 8008d36:	2300      	movs	r3, #0
 8008d38:	9300      	str	r3, [sp, #0]
 8008d3a:	e00d      	b.n	8008d58 <prvTCPWindowTxCheckAck+0xf8>

				/* No need to unlink it any more. */
				xDoUnlink = pdFALSE;
			}

			if( ( xDoUnlink != pdFALSE ) && ( listLIST_ITEM_CONTAINER( &( pxSegment->xQueueItem ) ) != NULL ) )
 8008d3c:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 8008d3e:	2b00      	cmp	r3, #0
 8008d40:	d1ea      	bne.n	8008d18 <prvTCPWindowTxCheckAck+0xb8>
 8008d42:	e7ed      	b.n	8008d20 <prvTCPWindowTxCheckAck+0xc0>
				xDoUnlink = pdTRUE;
			}

			/* pxSegment->u.bits.bAcked is now true.  Is it located at the left
			side of the transmission queue?  If so, it may be freed. */
			if( ulSequenceNumber == pxWindow->tx.ulCurrentSequenceNumber )
 8008d44:	f8da 3020 	ldr.w	r3, [sl, #32]
 8008d48:	42a3      	cmp	r3, r4
 8008d4a:	d1f7      	bne.n	8008d3c <prvTCPWindowTxCheckAck+0xdc>
 8008d4c:	e7da      	b.n	8008d04 <prvTCPWindowTxCheckAck+0xa4>
 8008d4e:	f8da 3020 	ldr.w	r3, [sl, #32]
 8008d52:	42a3      	cmp	r3, r4
 8008d54:	d1e4      	bne.n	8008d20 <prvTCPWindowTxCheckAck+0xc0>
 8008d56:	e7d5      	b.n	8008d04 <prvTCPWindowTxCheckAck+0xa4>

			ulSequenceNumber += ulDataLength;
		}

		return ulBytesConfirmed;
	}
 8008d58:	9800      	ldr	r0, [sp, #0]
 8008d5a:	b003      	add	sp, #12
 8008d5c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08008d60 <xTCPWindowRxEmpty>:
		/* When the peer has a close request (FIN flag), the driver will check
		if there are missing packets in the Rx-queue.  It will accept the
		closure of the connection if both conditions are true:
		  - the Rx-queue is empty
		  - the highest Rx sequence number has been ACK'ed */
		if( listLIST_IS_EMPTY( ( &pxWindow->xRxSegments ) ) == pdFALSE )
 8008d60:	f8d0 30a4 	ldr.w	r3, [r0, #164]	; 0xa4
 8008d64:	b92b      	cbnz	r3, 8008d72 <xTCPWindowRxEmpty+0x12>
static portINLINE BaseType_t xSequenceGreaterThanOrEqual( uint32_t a, uint32_t b )
{
BaseType_t xResult;

	/* Test if a >= b */
	if( ( ( a - b ) & 0x80000000UL ) == 0UL )
 8008d66:	6903      	ldr	r3, [r0, #16]
 8008d68:	6980      	ldr	r0, [r0, #24]
 8008d6a:	1a18      	subs	r0, r3, r0
 8008d6c:	43c0      	mvns	r0, r0
 8008d6e:	0fc0      	lsrs	r0, r0, #31
 8008d70:	4770      	bx	lr
		  - the Rx-queue is empty
		  - the highest Rx sequence number has been ACK'ed */
		if( listLIST_IS_EMPTY( ( &pxWindow->xRxSegments ) ) == pdFALSE )
		{
			/* Rx data has been stored while earlier packets were missing. */
			xReturn = pdFALSE;
 8008d72:	2000      	movs	r0, #0
				( pxWindow->rx.ulHighestSequenceNumber - pxWindow->rx.ulFirstSequenceNumber ) ) );
			xReturn = pdFALSE;
		}

		return xReturn;
	}
 8008d74:	4770      	bx	lr
 8008d76:	bf00      	nop

08008d78 <vTCPWindowDestroy>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	void vTCPWindowDestroy( TCPWindow_t const * pxWindow )
	{
 8008d78:	b570      	push	{r4, r5, r6, lr}
 8008d7a:	4606      	mov	r6, r0
 8008d7c:	2501      	movs	r5, #1
 8008d7e:	e000      	b.n	8008d82 <vTCPWindowDestroy+0xa>
 8008d80:	3501      	adds	r5, #1
		owned segments to the pool.  In order to save code, it will make 2 rounds,
		one to remove the segments from xRxSegments, and a second round to clear
		xTxSegments*/
		for( xRound = 0; xRound < 2; xRound++ )
		{
			if( xRound != 0 )
 8008d82:	2d01      	cmp	r5, #1
 8008d84:	d007      	beq.n	8008d96 <vTCPWindowDestroy+0x1e>
			else
			{
				pxSegments = &( pxWindow->xTxSegments );
			}

			if( listLIST_IS_INITIALISED( pxSegments ) )
 8008d86:	f8d6 30ac 	ldr.w	r3, [r6, #172]	; 0xac
 8008d8a:	f1b3 3fff 	cmp.w	r3, #4294967295
 8008d8e:	d112      	bne.n	8008db6 <vTCPWindowDestroy+0x3e>
		xTxSegments*/
		for( xRound = 0; xRound < 2; xRound++ )
		{
			if( xRound != 0 )
			{
				pxSegments = &( pxWindow->xRxSegments );
 8008d90:	f106 04a4 	add.w	r4, r6, #164	; 0xa4
 8008d94:	e006      	b.n	8008da4 <vTCPWindowDestroy+0x2c>
			else
			{
				pxSegments = &( pxWindow->xTxSegments );
			}

			if( listLIST_IS_INITIALISED( pxSegments ) )
 8008d96:	f8d6 3098 	ldr.w	r3, [r6, #152]	; 0x98
 8008d9a:	f1b3 3fff 	cmp.w	r3, #4294967295
 8008d9e:	d1ef      	bne.n	8008d80 <vTCPWindowDestroy+0x8>
			{
				pxSegments = &( pxWindow->xRxSegments );
			}
			else
			{
				pxSegments = &( pxWindow->xTxSegments );
 8008da0:	f106 0490 	add.w	r4, r6, #144	; 0x90
			}

			if( listLIST_IS_INITIALISED( pxSegments ) )
			{
				while( listCURRENT_LIST_LENGTH( pxSegments ) > 0U )
 8008da4:	6823      	ldr	r3, [r4, #0]
 8008da6:	b133      	cbz	r3, 8008db6 <vTCPWindowDestroy+0x3e>
				{
					pxSegment = ipCAST_PTR_TO_TYPE_PTR( TCPSegment_t, listGET_OWNER_OF_HEAD_ENTRY( pxSegments ) );
 8008da8:	68e3      	ldr	r3, [r4, #12]
					vTCPWindowFree( pxSegment );
 8008daa:	68d8      	ldr	r0, [r3, #12]
 8008dac:	f7ff fef0 	bl	8008b90 <vTCPWindowFree>
				pxSegments = &( pxWindow->xTxSegments );
			}

			if( listLIST_IS_INITIALISED( pxSegments ) )
			{
				while( listCURRENT_LIST_LENGTH( pxSegments ) > 0U )
 8008db0:	6823      	ldr	r3, [r4, #0]
 8008db2:	2b00      	cmp	r3, #0
 8008db4:	d1f8      	bne.n	8008da8 <vTCPWindowDestroy+0x30>

		/*  Destroy a window.  A TCP window doesn't serve any more.  Return all
		owned segments to the pool.  In order to save code, it will make 2 rounds,
		one to remove the segments from xRxSegments, and a second round to clear
		xTxSegments*/
		for( xRound = 0; xRound < 2; xRound++ )
 8008db6:	2d01      	cmp	r5, #1
 8008db8:	dde2      	ble.n	8008d80 <vTCPWindowDestroy+0x8>
					pxSegment = ipCAST_PTR_TO_TYPE_PTR( TCPSegment_t, listGET_OWNER_OF_HEAD_ENTRY( pxSegments ) );
					vTCPWindowFree( pxSegment );
				}
			}
		}
	}
 8008dba:	bd70      	pop	{r4, r5, r6, pc}

08008dbc <vTCPWindowInit>:
	vTCPWindowInit( pxWindow, ulAckNumber, ulSequenceNumber, ulMSS );
}
/*-----------------------------------------------------------*/

void vTCPWindowInit( TCPWindow_t *pxWindow, uint32_t ulAckNumber, uint32_t ulSequenceNumber, uint32_t ulMSS )
{
 8008dbc:	b410      	push	{r4}
const int32_t l500ms = 500;

	pxWindow->u.ulFlags = 0UL;
 8008dbe:	2400      	movs	r4, #0
 8008dc0:	6004      	str	r4, [r0, #0]
	pxWindow->u.bits.bHasInit = pdTRUE_UNSIGNED;
 8008dc2:	2401      	movs	r4, #1
 8008dc4:	7004      	strb	r4, [r0, #0]

	if( ulMSS != 0UL )
 8008dc6:	b193      	cbz	r3, 8008dee <vTCPWindowInit+0x32>
 8008dc8:	461c      	mov	r4, r3
	{
		if( pxWindow->usMSSInit != 0U )
 8008dca:	f8b0 30be 	ldrh.w	r3, [r0, #190]	; 0xbe
 8008dce:	b10b      	cbz	r3, 8008dd4 <vTCPWindowInit+0x18>
		{
			pxWindow->usMSSInit = ( uint16_t ) ulMSS;
 8008dd0:	f8a0 40be 	strh.w	r4, [r0, #190]	; 0xbe
		}

		if( ( ulMSS < ( uint32_t ) pxWindow->usMSS ) || ( pxWindow->usMSS == 0U ) )
 8008dd4:	f8b0 30bc 	ldrh.w	r3, [r0, #188]	; 0xbc
 8008dd8:	429c      	cmp	r4, r3
 8008dda:	d300      	bcc.n	8008dde <vTCPWindowInit+0x22>
 8008ddc:	b93b      	cbnz	r3, 8008dee <vTCPWindowInit+0x32>
		{
			pxWindow->xSize.ulRxWindowLength = ( pxWindow->xSize.ulRxWindowLength / ulMSS ) * ulMSS;
 8008dde:	6843      	ldr	r3, [r0, #4]
 8008de0:	fbb3 f3f4 	udiv	r3, r3, r4
 8008de4:	fb04 f303 	mul.w	r3, r4, r3
 8008de8:	6043      	str	r3, [r0, #4]
			pxWindow->usMSS = ( uint16_t ) ulMSS;
 8008dea:	f8a0 40bc 	strh.w	r4, [r0, #188]	; 0xbc
		pxWindow->xTxSegment.lMaxLength = ( int32_t ) pxWindow->usMSS;
	}
	#endif /* ipconfigUSE_TCP_WIN == 1 */

	/*Start with a timeout of 2 * 500 ms (1 sec). */
	pxWindow->lSRTT = l500ms;
 8008dee:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
 8008df2:	6383      	str	r3, [r0, #56]	; 0x38

	/* Just for logging, to print relative sequence numbers. */
	pxWindow->rx.ulFirstSequenceNumber = ulAckNumber;
 8008df4:	60c1      	str	r1, [r0, #12]

	/* The segment asked for in the next transmission. */
	pxWindow->rx.ulCurrentSequenceNumber = ulAckNumber;
 8008df6:	6101      	str	r1, [r0, #16]

	/* The right-hand side of the receive window. */
	pxWindow->rx.ulHighestSequenceNumber = ulAckNumber;
 8008df8:	6181      	str	r1, [r0, #24]

	pxWindow->tx.ulFirstSequenceNumber = ulSequenceNumber;
 8008dfa:	61c2      	str	r2, [r0, #28]

	/* The segment asked for in next transmission. */
	pxWindow->tx.ulCurrentSequenceNumber = ulSequenceNumber;
 8008dfc:	6202      	str	r2, [r0, #32]

	/* The sequence number given to the next outgoing byte to be added is
	maintained by lTCPWindowTxAdd(). */
	pxWindow->ulNextTxSequenceNumber = ulSequenceNumber;
 8008dfe:	6342      	str	r2, [r0, #52]	; 0x34

	/* The right-hand side of the transmit window. */
	pxWindow->tx.ulHighestSequenceNumber = ulSequenceNumber;
 8008e00:	6282      	str	r2, [r0, #40]	; 0x28
	pxWindow->ulOurSequenceNumber = ulSequenceNumber;
 8008e02:	62c2      	str	r2, [r0, #44]	; 0x2c
}
 8008e04:	f85d 4b04 	ldr.w	r4, [sp], #4
 8008e08:	4770      	bx	lr
 8008e0a:	bf00      	nop

08008e0c <vTCPWindowCreate>:
#endif /* ipconfigUSE_TCP_WIN == 1 */
/*-----------------------------------------------------------*/

void vTCPWindowCreate( TCPWindow_t *pxWindow, uint32_t ulRxWindowLength,
	uint32_t ulTxWindowLength, uint32_t ulAckNumber, uint32_t ulSequenceNumber, uint32_t ulMSS )
{
 8008e0c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008e10:	4605      	mov	r5, r0
 8008e12:	468a      	mov	sl, r1
 8008e14:	4691      	mov	r9, r2
 8008e16:	4698      	mov	r8, r3
	/* Create and initialize a window. */

	#if( ipconfigUSE_TCP_WIN == 1 )
	{
		if( xTCPSegments == NULL )
 8008e18:	4b21      	ldr	r3, [pc, #132]	; (8008ea0 <vTCPWindowCreate+0x94>)
 8008e1a:	681b      	ldr	r3, [r3, #0]
 8008e1c:	bb03      	cbnz	r3, 8008e60 <vTCPWindowCreate+0x54>
	{
	BaseType_t xIndex, xReturn;

		/* Allocate space for 'xTCPSegments' and store them in 'xSegmentList'. */

		vListInitialise( &xSegmentList );
 8008e1e:	4821      	ldr	r0, [pc, #132]	; (8008ea4 <vTCPWindowCreate+0x98>)
 8008e20:	f7f9 fa64 	bl	80022ec <vListInitialise>
		xTCPSegments = ipCAST_PTR_TO_TYPE_PTR( TCPSegment_t, pvPortMallocLarge( ( size_t ) ipconfigTCP_WIN_SEG_COUNT * sizeof( xTCPSegments[ 0 ] ) ) );
 8008e24:	f44f 5070 	mov.w	r0, #15360	; 0x3c00
 8008e28:	f7fb f858 	bl	8003edc <pvPortMalloc>
 8008e2c:	4606      	mov	r6, r0
 8008e2e:	4b1c      	ldr	r3, [pc, #112]	; (8008ea0 <vTCPWindowCreate+0x94>)
 8008e30:	6018      	str	r0, [r3, #0]

		if( xTCPSegments == NULL )
 8008e32:	b1a8      	cbz	r0, 8008e60 <vTCPWindowCreate+0x54>
			xReturn = pdFAIL;
		}
		else
		{
			/* Clear the allocated space. */
			( void ) memset( xTCPSegments, 0, ( size_t ) ipconfigTCP_WIN_SEG_COUNT * sizeof( xTCPSegments[ 0 ] ) );
 8008e34:	2100      	movs	r1, #0
 8008e36:	f44f 5270 	mov.w	r2, #15360	; 0x3c00
 8008e3a:	f001 f87f 	bl	8009f3c <memset>
 8008e3e:	4634      	mov	r4, r6
 8008e40:	f506 5670 	add.w	r6, r6, #15360	; 0x3c00

#if( ipconfigUSE_TCP_WIN == 1 )
	static portINLINE void vListInsertFifo( List_t * const pxList, ListItem_t * const pxNewListItem );
	static portINLINE void vListInsertFifo( List_t * const pxList, ListItem_t * const pxNewListItem )
	{
		vListInsertGeneric( pxList, pxNewListItem, &pxList->xListEnd );
 8008e44:	4f17      	ldr	r7, [pc, #92]	; (8008ea4 <vTCPWindowCreate+0x98>)
 8008e46:	f107 0b08 	add.w	fp, r7, #8

			for( xIndex = 0; xIndex < ipconfigTCP_WIN_SEG_COUNT; xIndex++ )
			{
				/* Could call vListInitialiseItem here but all data has been
				nulled already.  Set the owner to a segment descriptor. */
				listSET_LIST_ITEM_OWNER( &( xTCPSegments[ xIndex ].xSegmentItem  ),( void * ) &( xTCPSegments[ xIndex ] ) );
 8008e4a:	63a4      	str	r4, [r4, #56]	; 0x38
				listSET_LIST_ITEM_OWNER( &( xTCPSegments[ xIndex ].xQueueItem ), ( void * ) &( xTCPSegments[ xIndex ] ) );
 8008e4c:	6264      	str	r4, [r4, #36]	; 0x24

#if( ipconfigUSE_TCP_WIN == 1 )
	static portINLINE void vListInsertFifo( List_t * const pxList, ListItem_t * const pxNewListItem );
	static portINLINE void vListInsertFifo( List_t * const pxList, ListItem_t * const pxNewListItem )
	{
		vListInsertGeneric( pxList, pxNewListItem, &pxList->xListEnd );
 8008e4e:	4638      	mov	r0, r7
 8008e50:	f104 012c 	add.w	r1, r4, #44	; 0x2c
 8008e54:	465a      	mov	r2, fp
 8008e56:	f7ff fe4b 	bl	8008af0 <vListInsertGeneric>
 8008e5a:	3440      	adds	r4, #64	; 0x40
		else
		{
			/* Clear the allocated space. */
			( void ) memset( xTCPSegments, 0, ( size_t ) ipconfigTCP_WIN_SEG_COUNT * sizeof( xTCPSegments[ 0 ] ) );

			for( xIndex = 0; xIndex < ipconfigTCP_WIN_SEG_COUNT; xIndex++ )
 8008e5c:	42b4      	cmp	r4, r6
 8008e5e:	d1f4      	bne.n	8008e4a <vTCPWindowCreate+0x3e>
		if( xTCPSegments == NULL )
		{
			( void ) prvCreateSectors();
		}

		vListInitialise( &( pxWindow->xTxSegments ) );
 8008e60:	f105 0090 	add.w	r0, r5, #144	; 0x90
 8008e64:	f7f9 fa42 	bl	80022ec <vListInitialise>
		vListInitialise( &( pxWindow->xRxSegments ) );
 8008e68:	f105 00a4 	add.w	r0, r5, #164	; 0xa4
 8008e6c:	f7f9 fa3e 	bl	80022ec <vListInitialise>

		vListInitialise( &( pxWindow->xPriorityQueue ) );	/* Priority queue: segments which must be sent immediately */
 8008e70:	f105 0040 	add.w	r0, r5, #64	; 0x40
 8008e74:	f7f9 fa3a 	bl	80022ec <vListInitialise>
		vListInitialise( &( pxWindow->xTxQueue ) );			/* Transmit queue: segments queued for transmission */
 8008e78:	f105 0054 	add.w	r0, r5, #84	; 0x54
 8008e7c:	f7f9 fa36 	bl	80022ec <vListInitialise>
		vListInitialise( &( pxWindow->xWaitQueue ) );		/* Waiting queue:  outstanding segments */
 8008e80:	f105 0068 	add.w	r0, r5, #104	; 0x68
 8008e84:	f7f9 fa32 	bl	80022ec <vListInitialise>
	{
		FreeRTOS_debug_printf( ( "vTCPWindowCreate: for WinLen = Rx/Tx: %lu/%lu\n",
			ulRxWindowLength, ulTxWindowLength ) );
	}

	pxWindow->xSize.ulRxWindowLength = ulRxWindowLength;
 8008e88:	f8c5 a004 	str.w	sl, [r5, #4]
	pxWindow->xSize.ulTxWindowLength = ulTxWindowLength;
 8008e8c:	f8c5 9008 	str.w	r9, [r5, #8]

	vTCPWindowInit( pxWindow, ulAckNumber, ulSequenceNumber, ulMSS );
 8008e90:	4628      	mov	r0, r5
 8008e92:	4641      	mov	r1, r8
 8008e94:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8008e96:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8008e98:	f7ff ff90 	bl	8008dbc <vTCPWindowInit>
 8008e9c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8008ea0:	2000d3f0 	.word	0x2000d3f0
 8008ea4:	2000d3f4 	.word	0x2000d3f4

08008ea8 <lTCPWindowRxCheck>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	int32_t lTCPWindowRxCheck( TCPWindow_t *pxWindow, uint32_t ulSequenceNumber, uint32_t ulLength, uint32_t ulSpace )
	{
 8008ea8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008eac:	4606      	mov	r6, r0
 8008eae:	4688      	mov	r8, r1
 8008eb0:	4617      	mov	r7, r2
		or there is not enough space.

		As a side-effect, pxWindow->ulUserDataLength will get set to non-zero,
		if more Rx data may be passed to the user after this packet. */

		ulCurrentSequenceNumber = pxWindow->rx.ulCurrentSequenceNumber;
 8008eb2:	6904      	ldr	r4, [r0, #16]

		/* For Selective Ack (SACK), used when out-of-sequence data come in. */
		pxWindow->ucOptionLength = 0U;
 8008eb4:	2200      	movs	r2, #0
 8008eb6:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c

		/* Non-zero if TCP-windows contains data which must be popped. */
		pxWindow->ulUserDataLength = 0UL;
 8008eba:	6302      	str	r2, [r0, #48]	; 0x30

		if( ulCurrentSequenceNumber == ulSequenceNumber )
 8008ebc:	428c      	cmp	r4, r1
 8008ebe:	d144      	bne.n	8008f4a <lTCPWindowRxCheck+0xa2>
		{
			/* This is the packet with the lowest sequence number we're waiting
			for.  It can be passed directly to the rx stream. */
			if( ulLength > ulSpace )
 8008ec0:	429f      	cmp	r7, r3
 8008ec2:	f200 808b 	bhi.w	8008fdc <lTCPWindowRxCheck+0x134>
				FreeRTOS_debug_printf( ( "lTCPWindowRxCheck: Refuse %lu bytes, due to lack of space (%lu)\n", ulLength, ulSpace ) );
				lReturn = -1;
			}
			else
			{
				ulCurrentSequenceNumber += ulLength;
 8008ec6:	4427      	add	r7, r4

				if( listCURRENT_LIST_LENGTH( &( pxWindow->xRxSegments ) ) != 0U )
 8008ec8:	f8d0 30a4 	ldr.w	r3, [r0, #164]	; 0xa4
 8008ecc:	2b00      	cmp	r3, #0
 8008ece:	d038      	beq.n	8008f42 <lTCPWindowRxCheck+0x9a>
	static TCPSegment_t *xTCPWindowRxConfirm( const TCPWindow_t *pxWindow, uint32_t ulSequenceNumber, uint32_t ulLength )
	{
	TCPSegment_t *pxBest = NULL;
	const ListItem_t *pxIterator;
	uint32_t ulNextSequenceNumber = ulSequenceNumber + ulLength;
	const ListItem_t * pxEnd = listGET_END_MARKER( &pxWindow->xRxSegments );
 8008ed0:	f100 05ac 	add.w	r5, r0, #172	; 0xac
		and (ulSequenceNumber+ulLength).  Normally none will be found, because
		the next RX segment should have a sequence number equal to
		'(ulSequenceNumber+ulLength)'. */

		/* Iterate through all RX segments that are stored: */
		for( pxIterator  = listGET_NEXT( pxEnd );
 8008ed4:	4690      	mov	r8, r2
 8008ed6:	f8d6 30b0 	ldr.w	r3, [r6, #176]	; 0xb0
 8008eda:	429d      	cmp	r5, r3
 8008edc:	d01f      	beq.n	8008f1e <lTCPWindowRxCheck+0x76>
 8008ede:	46c6      	mov	lr, r8
			 pxIterator != pxEnd;
			 pxIterator  = listGET_NEXT( pxIterator ) )
		{
			pxSegment = ipCAST_PTR_TO_TYPE_PTR( TCPSegment_t, listGET_LIST_ITEM_OWNER( pxIterator ) );
 8008ee0:	68d8      	ldr	r0, [r3, #12]
			/* And see if there is a segment for which:
			'ulSequenceNumber' <= 'pxSegment->ulSequenceNumber' < 'ulNextSequenceNumber'
			If there are more matching segments, the one with the lowest sequence number
			shall be taken */
			if( ( xSequenceGreaterThanOrEqual( pxSegment->ulSequenceNumber, ulSequenceNumber ) != 0 ) &&
 8008ee2:	6802      	ldr	r2, [r0, #0]
static portINLINE BaseType_t xSequenceGreaterThanOrEqual( uint32_t a, uint32_t b )
{
BaseType_t xResult;

	/* Test if a >= b */
	if( ( ( a - b ) & 0x80000000UL ) == 0UL )
 8008ee4:	1b11      	subs	r1, r2, r4
			pxSegment = ipCAST_PTR_TO_TYPE_PTR( TCPSegment_t, listGET_LIST_ITEM_OWNER( pxIterator ) );
			/* And see if there is a segment for which:
			'ulSequenceNumber' <= 'pxSegment->ulSequenceNumber' < 'ulNextSequenceNumber'
			If there are more matching segments, the one with the lowest sequence number
			shall be taken */
			if( ( xSequenceGreaterThanOrEqual( pxSegment->ulSequenceNumber, ulSequenceNumber ) != 0 ) &&
 8008ee6:	2900      	cmp	r1, #0
 8008ee8:	db0f      	blt.n	8008f0a <lTCPWindowRxCheck+0x62>
 8008eea:	43d1      	mvns	r1, r2
 8008eec:	42f9      	cmn	r1, r7
 8008eee:	d40c      	bmi.n	8008f0a <lTCPWindowRxCheck+0x62>
				( xSequenceLessThan( pxSegment->ulSequenceNumber, ulNextSequenceNumber ) != 0 ) )
			{
				if( ( pxBest == NULL ) || ( xSequenceLessThan( pxSegment->ulSequenceNumber, pxBest->ulSequenceNumber ) != 0 ) )
 8008ef0:	f1be 0f00 	cmp.w	lr, #0
 8008ef4:	d008      	beq.n	8008f08 <lTCPWindowRxCheck+0x60>
 8008ef6:	f8de 1000 	ldr.w	r1, [lr]
	static portINLINE BaseType_t xSequenceLessThan( uint32_t a, uint32_t b )
	{
	BaseType_t xResult;

		/* Test if a < b */
		if( ( ( b - ( a + 1UL ) ) & 0x80000000UL ) == 0UL )
 8008efa:	43d2      	mvns	r2, r2
			If there are more matching segments, the one with the lowest sequence number
			shall be taken */
			if( ( xSequenceGreaterThanOrEqual( pxSegment->ulSequenceNumber, ulSequenceNumber ) != 0 ) &&
				( xSequenceLessThan( pxSegment->ulSequenceNumber, ulNextSequenceNumber ) != 0 ) )
			{
				if( ( pxBest == NULL ) || ( xSequenceLessThan( pxSegment->ulSequenceNumber, pxBest->ulSequenceNumber ) != 0 ) )
 8008efc:	440a      	add	r2, r1
				{
					pxBest = pxSegment;
 8008efe:	ea1e 0e22 	ands.w	lr, lr, r2, asr #32
 8008f02:	bf38      	it	cc
 8008f04:	4686      	movcc	lr, r0
 8008f06:	e000      	b.n	8008f0a <lTCPWindowRxCheck+0x62>
 8008f08:	4686      	mov	lr, r0
		'(ulSequenceNumber+ulLength)'. */

		/* Iterate through all RX segments that are stored: */
		for( pxIterator  = listGET_NEXT( pxEnd );
			 pxIterator != pxEnd;
			 pxIterator  = listGET_NEXT( pxIterator ) )
 8008f0a:	685b      	ldr	r3, [r3, #4]
		and (ulSequenceNumber+ulLength).  Normally none will be found, because
		the next RX segment should have a sequence number equal to
		'(ulSequenceNumber+ulLength)'. */

		/* Iterate through all RX segments that are stored: */
		for( pxIterator  = listGET_NEXT( pxEnd );
 8008f0c:	429d      	cmp	r5, r3
 8008f0e:	d1e7      	bne.n	8008ee0 <lTCPWindowRxCheck+0x38>
                    clean them out. */
                    do
                    {
                        pxFound = xTCPWindowRxConfirm( pxWindow, ulSequenceNumber, ulLength );

                        if ( pxFound != NULL )
 8008f10:	f1be 0f00 	cmp.w	lr, #0
 8008f14:	d005      	beq.n	8008f22 <lTCPWindowRxCheck+0x7a>
                        {
                            /* Remove it because it will be passed to user directly. */
                            vTCPWindowFree( pxFound );
 8008f16:	4670      	mov	r0, lr
 8008f18:	f7ff fe3a 	bl	8008b90 <vTCPWindowFree>
 8008f1c:	e7db      	b.n	8008ed6 <lTCPWindowRxCheck+0x2e>
		and (ulSequenceNumber+ulLength).  Normally none will be found, because
		the next RX segment should have a sequence number equal to
		'(ulSequenceNumber+ulLength)'. */

		/* Iterate through all RX segments that are stored: */
		for( pxIterator  = listGET_NEXT( pxEnd );
 8008f1e:	463c      	mov	r4, r7
 8008f20:	e000      	b.n	8008f24 <lTCPWindowRxCheck+0x7c>
 8008f22:	463c      	mov	r4, r7

					/*  Check for following segments that are already in the
					queue and increment ulCurrentSequenceNumber. */
					for( ;; )
					{
						pxFound = xTCPWindowRxFind( pxWindow, ulCurrentSequenceNumber );
 8008f24:	4630      	mov	r0, r6
 8008f26:	4621      	mov	r1, r4
 8008f28:	f7ff fdee 	bl	8008b08 <xTCPWindowRxFind>
						if( pxFound == NULL )
 8008f2c:	b120      	cbz	r0, 8008f38 <lTCPWindowRxCheck+0x90>
						{
							break;
						}
						ulCurrentSequenceNumber += ( uint32_t ) pxFound->lDataLength;
 8008f2e:	6882      	ldr	r2, [r0, #8]
 8008f30:	4414      	add	r4, r2

						/* As all packet below this one have been passed to the
						user it can be discarded. */
						vTCPWindowFree( pxFound );
 8008f32:	f7ff fe2d 	bl	8008b90 <vTCPWindowFree>
					}
 8008f36:	e7f5      	b.n	8008f24 <lTCPWindowRxCheck+0x7c>

					if( ulSavedSequenceNumber != ulCurrentSequenceNumber )
 8008f38:	42bc      	cmp	r4, r7
 8008f3a:	d002      	beq.n	8008f42 <lTCPWindowRxCheck+0x9a>
					{
						/*  After the current data-package, there is more data
						to be popped. */
						pxWindow->ulUserDataLength = ulCurrentSequenceNumber - ulSavedSequenceNumber;
 8008f3c:	1be7      	subs	r7, r4, r7
 8008f3e:	6337      	str	r7, [r6, #48]	; 0x30
 8008f40:	4627      	mov	r7, r4
								listCURRENT_LIST_LENGTH( &pxWindow->xRxSegments ) ) );
						}
					}
				}

				pxWindow->rx.ulCurrentSequenceNumber = ulCurrentSequenceNumber;
 8008f42:	6137      	str	r7, [r6, #16]

				/* Packet was expected, may be passed directly to the socket
				buffer or application.  Store the packet at offset 0. */
				lReturn = 0;
 8008f44:	2000      	movs	r0, #0
 8008f46:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			}
		}
		else if( ulCurrentSequenceNumber == ( ulSequenceNumber + 1UL ) )
 8008f4a:	1c4a      	adds	r2, r1, #1
 8008f4c:	42a2      	cmp	r2, r4
 8008f4e:	d049      	beq.n	8008fe4 <lTCPWindowRxCheck+0x13c>
			/* The packet is not the one expected.  See if it falls within the Rx
			window so it can be stored. */

			/*  An "out-of-sequence" segment was received, must have missed one.
			Prepare a SACK (Selective ACK). */
			ulLast = ulSequenceNumber + ulLength;
 8008f50:	19cd      	adds	r5, r1, r7

			ulIntermediateResult = ulLast - ulCurrentSequenceNumber;
 8008f52:	1b2a      	subs	r2, r5, r4
			/* The cast from unsigned long to signed long is on purpose. */
			lDistance = ( int32_t ) ulIntermediateResult;

			if( lDistance <= 0 )
 8008f54:	2a00      	cmp	r2, #0
 8008f56:	dd49      	ble.n	8008fec <lTCPWindowRxCheck+0x144>
				/* An earlier has been received, must be a retransmission of a
				packet that has been accepted already.  No need to send out a
				Selective ACK (SACK). */
				lReturn = -1;
			}
			else if( lDistance > ( int32_t ) ulSpace )
 8008f58:	429a      	cmp	r2, r3
 8008f5a:	dc4b      	bgt.n	8008ff4 <lTCPWindowRxCheck+0x14c>
				 * This is useful because subsequent packets will be SACK'd with
				 * single one message
				 */
				for( ;; )
				{
					pxFound = xTCPWindowRxFind( pxWindow, ulLast );
 8008f5c:	4630      	mov	r0, r6
 8008f5e:	4629      	mov	r1, r5
 8008f60:	f7ff fdd2 	bl	8008b08 <xTCPWindowRxFind>
					if( pxFound == NULL )
 8008f64:	b110      	cbz	r0, 8008f6c <lTCPWindowRxCheck+0xc4>
					{
						break;
					}
					ulLast += ( uint32_t ) pxFound->lDataLength;
 8008f66:	6883      	ldr	r3, [r0, #8]
 8008f68:	441d      	add	r5, r3
				}
 8008f6a:	e7f7      	b.n	8008f5c <lTCPWindowRxCheck+0xb4>
						( unsigned ) ( ulLast - pxWindow->rx.ulFirstSequenceNumber ) ) );
				}

				/* Now prepare the SACK message.
				Code OPTION_CODE_SINGLE_SACK already in network byte order. */
				pxWindow->ulOptionsData[0] = OPTION_CODE_SINGLE_SACK;
 8008f6c:	4b25      	ldr	r3, [pc, #148]	; (8009004 <lTCPWindowRxCheck+0x15c>)
 8008f6e:	f8c6 3080 	str.w	r3, [r6, #128]	; 0x80

				/* First sequence number that we received. */
				pxWindow->ulOptionsData[1] = FreeRTOS_htonl( ulSequenceNumber );
 8008f72:	ea4f 6308 	mov.w	r3, r8, lsl #24
 8008f76:	ea43 6318 	orr.w	r3, r3, r8, lsr #24
 8008f7a:	f408 427f 	and.w	r2, r8, #65280	; 0xff00
 8008f7e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8008f82:	f408 027f 	and.w	r2, r8, #16711680	; 0xff0000
 8008f86:	ea43 2312 	orr.w	r3, r3, r2, lsr #8
 8008f8a:	f8c6 3084 	str.w	r3, [r6, #132]	; 0x84

				/* Last + 1 */
				pxWindow->ulOptionsData[2] = FreeRTOS_htonl( ulLast );
 8008f8e:	062b      	lsls	r3, r5, #24
 8008f90:	ea43 6315 	orr.w	r3, r3, r5, lsr #24
 8008f94:	f405 427f 	and.w	r2, r5, #65280	; 0xff00
 8008f98:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8008f9c:	f405 057f 	and.w	r5, r5, #16711680	; 0xff0000
 8008fa0:	ea43 2515 	orr.w	r5, r3, r5, lsr #8
 8008fa4:	f8c6 5088 	str.w	r5, [r6, #136]	; 0x88

				/* Which make 12 (3*4) option bytes. */
				pxWindow->ucOptionLength = ( uint8_t ) ( 3U * sizeof( pxWindow->ulOptionsData[ 0 ] ) );
 8008fa8:	230c      	movs	r3, #12
 8008faa:	f886 303c 	strb.w	r3, [r6, #60]	; 0x3c

				pxFound = xTCPWindowRxFind( pxWindow, ulSequenceNumber );
 8008fae:	4630      	mov	r0, r6
 8008fb0:	4641      	mov	r1, r8
 8008fb2:	f7ff fda9 	bl	8008b08 <xTCPWindowRxFind>

				if( pxFound != NULL )
 8008fb6:	bb08      	cbnz	r0, 8008ffc <lTCPWindowRxCheck+0x154>
					again. */
					lReturn = -1;
				}
				else
				{
					pxFound = xTCPWindowRxNew( pxWindow, ulSequenceNumber, ( int32_t ) ulLength );
 8008fb8:	4630      	mov	r0, r6
 8008fba:	4641      	mov	r1, r8
 8008fbc:	463a      	mov	r2, r7
 8008fbe:	2301      	movs	r3, #1
 8008fc0:	f7ff fe02 	bl	8008bc8 <xTCPWindowNew>

					if( pxFound == NULL )
 8008fc4:	b930      	cbnz	r0, 8008fd4 <lTCPWindowRxCheck+0x12c>
					{
						/* Can not send a SACK, because the segment cannot be
						stored. */
						pxWindow->ucOptionLength = 0U;
 8008fc6:	2300      	movs	r3, #0
 8008fc8:	f886 303c 	strb.w	r3, [r6, #60]	; 0x3c

						/* Needs to be stored but there is no segment
						available. */
						lReturn = -1;
 8008fcc:	f04f 30ff 	mov.w	r0, #4294967295
 8008fd0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
							FreeRTOS_flush_logging( );
						}

						/* Return a positive value.  The packet may be accepted
						and stored but an earlier packet is still missing. */
						ulIntermediateResult = ulSequenceNumber - ulCurrentSequenceNumber;
 8008fd4:	ebc4 0008 	rsb	r0, r4, r8
 8008fd8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			/* This is the packet with the lowest sequence number we're waiting
			for.  It can be passed directly to the rx stream. */
			if( ulLength > ulSpace )
			{
				FreeRTOS_debug_printf( ( "lTCPWindowRxCheck: Refuse %lu bytes, due to lack of space (%lu)\n", ulLength, ulSpace ) );
				lReturn = -1;
 8008fdc:	f04f 30ff 	mov.w	r0, #4294967295
 8008fe0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		}
		else if( ulCurrentSequenceNumber == ( ulSequenceNumber + 1UL ) )
		{
			/* Looks like a TCP keep-alive message.  Do not accept/store Rx data
			ulUserDataLength = 0. Not packet out-of-sync.  Just reply to it. */
			lReturn = -1;
 8008fe4:	f04f 30ff 	mov.w	r0, #4294967295
 8008fe8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if( lDistance <= 0 )
			{
				/* An earlier has been received, must be a retransmission of a
				packet that has been accepted already.  No need to send out a
				Selective ACK (SACK). */
				lReturn = -1;
 8008fec:	f04f 30ff 	mov.w	r0, #4294967295
 8008ff0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			else if( lDistance > ( int32_t ) ulSpace )
			{
				/* The new segment is ahead of rx.ulCurrentSequenceNumber.  The
				sequence number of this packet is too far ahead, ignore it. */
				FreeRTOS_debug_printf( ( "lTCPWindowRxCheck: Refuse %lu+%lu bytes, due to lack of space (%lu)\n", lDistance, ulLength, ulSpace ) );
				lReturn = -1;
 8008ff4:	f04f 30ff 	mov.w	r0, #4294967295
 8008ff8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				if( pxFound != NULL )
				{
					/* This out-of-sequence packet has been received for a
					second time.  It is already stored but do send a SACK
					again. */
					lReturn = -1;
 8008ffc:	f04f 30ff 	mov.w	r0, #4294967295
				}
			}
		}

		return lReturn;
	}
 8009000:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8009004:	0a050101 	.word	0x0a050101

08009008 <lTCPWindowTxAdd>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	int32_t lTCPWindowTxAdd( TCPWindow_t *pxWindow, uint32_t ulLength, int32_t lPosition, int32_t lMax )
	{
 8009008:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800900c:	b083      	sub	sp, #12
 800900e:	4605      	mov	r5, r0
 8009010:	4616      	mov	r6, r2
 8009012:	469a      	mov	sl, r3
	int32_t lBytesLeft = ( int32_t ) ulLength, lToWrite;
 8009014:	460f      	mov	r7, r1
	int32_t lDone = 0;
	int32_t lBufferIndex = lPosition;
	TCPSegment_t *pxSegment = pxWindow->pxHeadSegment;
 8009016:	6fc3      	ldr	r3, [r0, #124]	; 0x7c

		/* Puts a message in the Tx-window (after buffer size has been
		verified). */
		if( pxSegment != NULL )
 8009018:	b1f3      	cbz	r3, 8009058 <lTCPWindowTxAdd+0x50>
		{
			if( pxSegment->lDataLength < pxSegment->lMaxLength )
 800901a:	689a      	ldr	r2, [r3, #8]
 800901c:	6858      	ldr	r0, [r3, #4]
 800901e:	4282      	cmp	r2, r0
 8009020:	da1d      	bge.n	800905e <lTCPWindowTxAdd+0x56>
			{
				if( ( pxSegment->u.bits.bOutstanding == pdFALSE_UNSIGNED ) && ( pxSegment->lDataLength != 0 ) )
 8009022:	7d9c      	ldrb	r4, [r3, #22]
 8009024:	f014 0f01 	tst.w	r4, #1
 8009028:	d11c      	bne.n	8009064 <lTCPWindowTxAdd+0x5c>
 800902a:	b1f2      	cbz	r2, 800906a <lTCPWindowTxAdd+0x62>
				{
					/* Adding data to a segment that was already in the TX queue.  It
					will be filled-up to a maximum of MSS (maximum segment size). */
					lToWrite = FreeRTOS_min_int32( lBytesLeft, pxSegment->lMaxLength - pxSegment->lDataLength );
 800902c:	ebc2 0800 	rsb	r8, r2, r0
	static portINLINE uint32_t FreeRTOS_round_down (uint32_t a, uint32_t d);
	static portINLINE BaseType_t  FreeRTOS_min_BaseType  (BaseType_t  a, BaseType_t  b);

	static portINLINE int32_t  FreeRTOS_max_int32  (int32_t  a, int32_t  b) { return ( a >= b ) ? a : b; }
	static portINLINE uint32_t FreeRTOS_max_uint32 (uint32_t a, uint32_t b) { return ( a >= b ) ? a : b; }
	static portINLINE int32_t  FreeRTOS_min_int32  (int32_t  a, int32_t  b) { return ( a <= b ) ? a : b; }
 8009030:	4588      	cmp	r8, r1
 8009032:	bfa8      	it	ge
 8009034:	4688      	movge	r8, r1

					pxSegment->lDataLength += lToWrite;
 8009036:	4442      	add	r2, r8
 8009038:	609a      	str	r2, [r3, #8]

					if( pxSegment->lDataLength >= pxSegment->lMaxLength )
 800903a:	4290      	cmp	r0, r2
					{
						/* This segment is full, don't add more bytes. */
						pxWindow->pxHeadSegment = NULL;
 800903c:	bfdc      	itt	le
 800903e:	2300      	movle	r3, #0
 8009040:	67eb      	strle	r3, [r5, #124]	; 0x7c
					}

					lBytesLeft -= lToWrite;
 8009042:	ebc8 0701 	rsb	r7, r8, r1

					/* ulNextTxSequenceNumber is the sequence number of the next byte to
					be stored for transmission. */
					pxWindow->ulNextTxSequenceNumber += ( uint32_t ) lToWrite;
 8009046:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8009048:	4443      	add	r3, r8
 800904a:	636b      	str	r3, [r5, #52]	; 0x34
	{
	int32_t lReturn;

		/* +TCP stores data in circular buffers.  Calculate the next position to
		store. */
		lReturn = lPosition + lCount;
 800904c:	4446      	add	r6, r8
		if( lReturn >= lMax )
 800904e:	45b2      	cmp	sl, r6
 8009050:	dc0d      	bgt.n	800906e <lTCPWindowTxAdd+0x66>
		{
			lReturn -= lMax;
 8009052:	ebca 0606 	rsb	r6, sl, r6
 8009056:	e00a      	b.n	800906e <lTCPWindowTxAdd+0x66>
#if( ipconfigUSE_TCP_WIN == 1 )

	int32_t lTCPWindowTxAdd( TCPWindow_t *pxWindow, uint32_t ulLength, int32_t lPosition, int32_t lMax )
	{
	int32_t lBytesLeft = ( int32_t ) ulLength, lToWrite;
	int32_t lDone = 0;
 8009058:	f04f 0800 	mov.w	r8, #0
 800905c:	e007      	b.n	800906e <lTCPWindowTxAdd+0x66>
 800905e:	f04f 0800 	mov.w	r8, #0
 8009062:	e004      	b.n	800906e <lTCPWindowTxAdd+0x66>
 8009064:	f04f 0800 	mov.w	r8, #0
 8009068:	e001      	b.n	800906e <lTCPWindowTxAdd+0x66>
 800906a:	f04f 0800 	mov.w	r8, #0
					lBufferIndex = lTCPIncrementTxPosition( lBufferIndex, lMax, lToWrite );
				}
			}
		}

		while( lBytesLeft > 0 )
 800906e:	2f00      	cmp	r7, #0
 8009070:	dd2d      	ble.n	80090ce <lTCPWindowTxAdd+0xc6>
		{
			/* The current transmission segment is full, create new segments as
			needed. */
			pxSegment = xTCPWindowTxNew( pxWindow, pxWindow->ulNextTxSequenceNumber, ( int32_t ) pxWindow->usMSS );
 8009072:	f04f 0900 	mov.w	r9, #0
				lBufferIndex = lTCPIncrementTxPosition( lBufferIndex, lMax, lToWrite );
				pxWindow->ulNextTxSequenceNumber += ( uint32_t ) lToWrite;
				lDone += lToWrite;

				/* Link this segment in the Tx-Queue. */
				vListInsertFifo( &( pxWindow->xTxQueue ), &( pxSegment->xQueueItem ) );
 8009076:	f105 0b54 	add.w	fp, r5, #84	; 0x54

#if( ipconfigUSE_TCP_WIN == 1 )
	static portINLINE void vListInsertFifo( List_t * const pxList, ListItem_t * const pxNewListItem );
	static portINLINE void vListInsertFifo( List_t * const pxList, ListItem_t * const pxNewListItem )
	{
		vListInsertGeneric( pxList, pxNewListItem, &pxList->xListEnd );
 800907a:	f105 035c 	add.w	r3, r5, #92	; 0x5c
 800907e:	9301      	str	r3, [sp, #4]

		while( lBytesLeft > 0 )
		{
			/* The current transmission segment is full, create new segments as
			needed. */
			pxSegment = xTCPWindowTxNew( pxWindow, pxWindow->ulNextTxSequenceNumber, ( int32_t ) pxWindow->usMSS );
 8009080:	4628      	mov	r0, r5
 8009082:	6b69      	ldr	r1, [r5, #52]	; 0x34
 8009084:	f8b5 20bc 	ldrh.w	r2, [r5, #188]	; 0xbc
 8009088:	464b      	mov	r3, r9
 800908a:	f7ff fd9d 	bl	8008bc8 <xTCPWindowNew>

			if( pxSegment != NULL )
 800908e:	4604      	mov	r4, r0
 8009090:	b1e8      	cbz	r0, 80090ce <lTCPWindowTxAdd+0xc6>
 8009092:	6843      	ldr	r3, [r0, #4]
 8009094:	42bb      	cmp	r3, r7
 8009096:	bfa8      	it	ge
 8009098:	463b      	movge	r3, r7
			{
				/* Store as many as needed, but no more than the maximum
				(MSS). */
				lToWrite = FreeRTOS_min_int32( lBytesLeft, pxSegment->lMaxLength );

				pxSegment->lDataLength = lToWrite;
 800909a:	6083      	str	r3, [r0, #8]
				pxSegment->lStreamPos = lBufferIndex;
 800909c:	60c6      	str	r6, [r0, #12]
				lBytesLeft -= lToWrite;
 800909e:	1aff      	subs	r7, r7, r3
	{
	int32_t lReturn;

		/* +TCP stores data in circular buffers.  Calculate the next position to
		store. */
		lReturn = lPosition + lCount;
 80090a0:	441e      	add	r6, r3
		if( lReturn >= lMax )
 80090a2:	45b2      	cmp	sl, r6
		{
			lReturn -= lMax;
 80090a4:	bfd8      	it	le
 80090a6:	ebca 0606 	rsble	r6, sl, r6

				pxSegment->lDataLength = lToWrite;
				pxSegment->lStreamPos = lBufferIndex;
				lBytesLeft -= lToWrite;
				lBufferIndex = lTCPIncrementTxPosition( lBufferIndex, lMax, lToWrite );
				pxWindow->ulNextTxSequenceNumber += ( uint32_t ) lToWrite;
 80090aa:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 80090ac:	441a      	add	r2, r3
 80090ae:	636a      	str	r2, [r5, #52]	; 0x34
				lDone += lToWrite;
 80090b0:	4498      	add	r8, r3

#if( ipconfigUSE_TCP_WIN == 1 )
	static portINLINE void vListInsertFifo( List_t * const pxList, ListItem_t * const pxNewListItem );
	static portINLINE void vListInsertFifo( List_t * const pxList, ListItem_t * const pxNewListItem )
	{
		vListInsertGeneric( pxList, pxNewListItem, &pxList->xListEnd );
 80090b2:	4658      	mov	r0, fp
 80090b4:	f104 0118 	add.w	r1, r4, #24
 80090b8:	9a01      	ldr	r2, [sp, #4]
 80090ba:	f7ff fd19 	bl	8008af0 <vListInsertGeneric>
				/* Link this segment in the Tx-Queue. */
				vListInsertFifo( &( pxWindow->xTxQueue ), &( pxSegment->xQueueItem ) );

				/* Let 'pxHeadSegment' point to this segment if there is still
				space. */
				if( pxSegment->lDataLength < pxSegment->lMaxLength )
 80090be:	68a2      	ldr	r2, [r4, #8]
 80090c0:	6863      	ldr	r3, [r4, #4]
 80090c2:	429a      	cmp	r2, r3
				{
					pxWindow->pxHeadSegment = pxSegment;
 80090c4:	bfa8      	it	ge
 80090c6:	464c      	movge	r4, r9
 80090c8:	67ec      	str	r4, [r5, #124]	; 0x7c
					lBufferIndex = lTCPIncrementTxPosition( lBufferIndex, lMax, lToWrite );
				}
			}
		}

		while( lBytesLeft > 0 )
 80090ca:	2f00      	cmp	r7, #0
 80090cc:	dcd8      	bgt.n	8009080 <lTCPWindowTxAdd+0x78>
				break;
			}
		}

		return lDone;
	}
 80090ce:	4640      	mov	r0, r8
 80090d0:	b003      	add	sp, #12
 80090d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80090d6:	bf00      	nop

080090d8 <xTCPWindowTxDone>:

#if( ipconfigUSE_TCP_WIN == 1 )

	BaseType_t xTCPWindowTxDone( const TCPWindow_t *pxWindow )
	{
		return listLIST_IS_EMPTY( ( &pxWindow->xTxSegments) );
 80090d8:	f8d0 0090 	ldr.w	r0, [r0, #144]	; 0x90
	}
 80090dc:	fab0 f080 	clz	r0, r0
 80090e0:	0940      	lsrs	r0, r0, #5
 80090e2:	4770      	bx	lr

080090e4 <xTCPWindowTxHasData>:
	{
	TCPSegment_t const * pxSegment;
	BaseType_t xReturn;
	TickType_t ulAge, ulMaxAge;

		*pulDelay = 0U;
 80090e4:	2300      	movs	r3, #0
 80090e6:	6013      	str	r3, [r2, #0]

		if( listLIST_IS_EMPTY( &pxWindow->xPriorityQueue ) == pdFALSE )
 80090e8:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80090ea:	bb43      	cbnz	r3, 800913e <xTCPWindowTxHasData+0x5a>
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	BaseType_t xTCPWindowTxHasData( TCPWindow_t const * pxWindow, uint32_t ulWindowSize, TickType_t *pulDelay )
	{
 80090ec:	b570      	push	{r4, r5, r6, lr}
 80090ee:	4615      	mov	r5, r2
 80090f0:	4604      	mov	r4, r0
	{
	const ListItem_t *pxItem;
	TCPSegment_t *pxReturn;

		/* Returns the head of a queue but it won't be detached. */
		if( listLIST_IS_EMPTY( pxList ) != pdFALSE )
 80090f2:	6e83      	ldr	r3, [r0, #104]	; 0x68
 80090f4:	b17b      	cbz	r3, 8009116 <xTCPWindowTxHasData+0x32>
			pxReturn = NULL;
		}
		else
		{
			pxItem = ( ListItem_t * ) listGET_HEAD_ENTRY( pxList );
			pxReturn = ipCAST_PTR_TO_TYPE_PTR( TCPSegment_t, listGET_LIST_ITEM_OWNER( pxItem ) );
 80090f6:	6f43      	ldr	r3, [r0, #116]	; 0x74
 80090f8:	68de      	ldr	r6, [r3, #12]
		}
		else
		{
			pxSegment = xTCPWindowPeekHead( &( pxWindow->xWaitQueue ) );

			if( pxSegment != NULL )
 80090fa:	b166      	cbz	r6, 8009116 <xTCPWindowTxHasData+0x32>
/*-----------------------------------------------------------*/

static portINLINE uint32_t ulTimerGetAge( const TCPTimer_t *pxTimer );
static portINLINE uint32_t ulTimerGetAge( const TCPTimer_t *pxTimer )
{
	return ( ( xTaskGetTickCount() - ( ( TickType_t ) pxTimer->ulBorn ) ) * portTICK_PERIOD_MS );
 80090fc:	f7fa f85e 	bl	80031bc <xTaskGetTickCount>
 8009100:	6933      	ldr	r3, [r6, #16]
 8009102:	1ac0      	subs	r0, r0, r3
				ulAge = ulTimerGetAge( &pxSegment->xTransmitTimer );

				/* After a packet has been sent for the first time, it will wait
				'1 * lSRTT' ms for an ACK. A second time it will wait '2 * lSRTT' ms,
				each time doubling the time-out */
				ulMaxAge = ( 1UL << pxSegment->u.bits.ucTransmitCount ) * ( ( uint32_t ) pxWindow->lSRTT );
 8009104:	7d32      	ldrb	r2, [r6, #20]
 8009106:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8009108:	4093      	lsls	r3, r2

				if( ulMaxAge > ulAge )
 800910a:	4283      	cmp	r3, r0
 800910c:	d919      	bls.n	8009142 <xTCPWindowTxHasData+0x5e>
				{
					/* A segment must be sent after this amount of msecs */
					*pulDelay = ulMaxAge - ulAge;
 800910e:	1a1b      	subs	r3, r3, r0
 8009110:	602b      	str	r3, [r5, #0]
				}

				xReturn = pdTRUE;
 8009112:	2001      	movs	r0, #1
 8009114:	bd70      	pop	{r4, r5, r6, pc}
	{
	const ListItem_t *pxItem;
	TCPSegment_t *pxReturn;

		/* Returns the head of a queue but it won't be detached. */
		if( listLIST_IS_EMPTY( pxList ) != pdFALSE )
 8009116:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8009118:	b1ab      	cbz	r3, 8009146 <xTCPWindowTxHasData+0x62>
			pxReturn = NULL;
		}
		else
		{
			pxItem = ( ListItem_t * ) listGET_HEAD_ENTRY( pxList );
			pxReturn = ipCAST_PTR_TO_TYPE_PTR( TCPSegment_t, listGET_LIST_ITEM_OWNER( pxItem ) );
 800911a:	6e23      	ldr	r3, [r4, #96]	; 0x60
 800911c:	68dd      	ldr	r5, [r3, #12]
				/* No priority segment, no outstanding data, see if there is new
				transmission data. */
				pxSegment = xTCPWindowPeekHead( &pxWindow->xTxQueue );

				/* See if it fits in the peer's reception window. */
				if( pxSegment == NULL )
 800911e:	b1a5      	cbz	r5, 800914a <xTCPWindowTxHasData+0x66>
				{
					xReturn = pdFALSE;
				}
				else if( prvTCPWindowTxHasSpace( pxWindow, ulWindowSize ) == pdFALSE )
 8009120:	4620      	mov	r0, r4
 8009122:	f7ff fd0b 	bl	8008b3c <prvTCPWindowTxHasSpace>
 8009126:	b190      	cbz	r0, 800914e <xTCPWindowTxHasData+0x6a>
				{
					/* Too many outstanding messages. */
					xReturn = pdFALSE;
				}
				else if( ( pxWindow->u.bits.bSendFullSize != pdFALSE_UNSIGNED ) && ( pxSegment->lDataLength < pxSegment->lMaxLength ) )
 8009128:	7823      	ldrb	r3, [r4, #0]
 800912a:	f013 0f02 	tst.w	r3, #2
 800912e:	d010      	beq.n	8009152 <xTCPWindowTxHasData+0x6e>
 8009130:	68ab      	ldr	r3, [r5, #8]
 8009132:	6868      	ldr	r0, [r5, #4]
 8009134:	4283      	cmp	r3, r0
 8009136:	bfb4      	ite	lt
 8009138:	2000      	movlt	r0, #0
 800913a:	2001      	movge	r0, #1
 800913c:	bd70      	pop	{r4, r5, r6, pc}
		if( listLIST_IS_EMPTY( &pxWindow->xPriorityQueue ) == pdFALSE )
		{
			/* No need to look at retransmissions or new transmission as long as
			there are priority segments.  *pulDelay equals zero, meaning it must
			be sent out immediately. */
			xReturn = pdTRUE;
 800913e:	2001      	movs	r0, #1
				}
			}
		}

		return xReturn;
	}
 8009140:	4770      	bx	lr
				{
					/* A segment must be sent after this amount of msecs */
					*pulDelay = ulMaxAge - ulAge;
				}

				xReturn = pdTRUE;
 8009142:	2001      	movs	r0, #1
 8009144:	bd70      	pop	{r4, r5, r6, pc}
				pxSegment = xTCPWindowPeekHead( &pxWindow->xTxQueue );

				/* See if it fits in the peer's reception window. */
				if( pxSegment == NULL )
				{
					xReturn = pdFALSE;
 8009146:	2000      	movs	r0, #0
 8009148:	bd70      	pop	{r4, r5, r6, pc}
 800914a:	2000      	movs	r0, #0
 800914c:	bd70      	pop	{r4, r5, r6, pc}
				}
				else if( prvTCPWindowTxHasSpace( pxWindow, ulWindowSize ) == pdFALSE )
				{
					/* Too many outstanding messages. */
					xReturn = pdFALSE;
 800914e:	2000      	movs	r0, #0
 8009150:	bd70      	pop	{r4, r5, r6, pc}
					bytes). */
					xReturn = pdFALSE;
				}
				else
				{
					xReturn = pdTRUE;
 8009152:	2001      	movs	r0, #1
				}
			}
		}

		return xReturn;
	}
 8009154:	bd70      	pop	{r4, r5, r6, pc}
 8009156:	bf00      	nop

08009158 <ulTCPWindowTxGet>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	uint32_t ulTCPWindowTxGet( TCPWindow_t *pxWindow, uint32_t ulWindowSize, int32_t *plPosition )
	{
 8009158:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800915c:	4604      	mov	r4, r0
 800915e:	4688      	mov	r8, r1
 8009160:	4616      	mov	r6, r2
	{
	TCPSegment_t *pxSegment;
	ListItem_t * pxItem;

		/* Detaches and returns the head of a queue. */
		if( listLIST_IS_EMPTY( pxList ) != pdFALSE )
 8009162:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8009164:	2b00      	cmp	r3, #0
 8009166:	f000 8084 	beq.w	8009272 <ulTCPWindowTxGet+0x11a>
		{
			pxSegment = NULL;
		}
		else
		{
			pxItem = ( ListItem_t * ) listGET_HEAD_ENTRY( pxList );
 800916a:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
			pxSegment = ipCAST_PTR_TO_TYPE_PTR( TCPSegment_t, listGET_LIST_ITEM_OWNER( pxItem ) );
 800916c:	68c5      	ldr	r5, [r0, #12]

			( void ) uxListRemove( pxItem );
 800916e:	f7f9 f8f3 	bl	8002358 <uxListRemove>
		/* Fetches data to be sent-out now.

		Priority messages: segments with a resend need no check current sliding
		window size. */
		pxSegment = xTCPWindowGetHead( &( pxWindow->xPriorityQueue ) );
		pxWindow->ulOurSequenceNumber = pxWindow->tx.ulHighestSequenceNumber;
 8009172:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8009174:	62e3      	str	r3, [r4, #44]	; 0x2c

		if( pxSegment == NULL )
 8009176:	2d00      	cmp	r5, #0
 8009178:	d14a      	bne.n	8009210 <ulTCPWindowTxGet+0xb8>
	{
	const ListItem_t *pxItem;
	TCPSegment_t *pxReturn;

		/* Returns the head of a queue but it won't be detached. */
		if( listLIST_IS_EMPTY( pxList ) != pdFALSE )
 800917a:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 800917c:	b1bb      	cbz	r3, 80091ae <ulTCPWindowTxGet+0x56>
			pxReturn = NULL;
		}
		else
		{
			pxItem = ( ListItem_t * ) listGET_HEAD_ENTRY( pxList );
			pxReturn = ipCAST_PTR_TO_TYPE_PTR( TCPSegment_t, listGET_LIST_ITEM_OWNER( pxItem ) );
 800917e:	6f63      	ldr	r3, [r4, #116]	; 0x74
 8009180:	68df      	ldr	r7, [r3, #12]
			/* Waiting messages: outstanding messages with a running timer
			neither check peer's reception window size because these packets
			have been sent earlier. */
			pxSegment = xTCPWindowPeekHead( &( pxWindow->xWaitQueue ) );

			if( pxSegment != NULL )
 8009182:	b1a7      	cbz	r7, 80091ae <ulTCPWindowTxGet+0x56>
			{
				/* Do check the timing. */
				ulMaxTime = ( 1UL << pxSegment->u.bits.ucTransmitCount ) * ( ( uint32_t ) pxWindow->lSRTT );
 8009184:	7d3b      	ldrb	r3, [r7, #20]
 8009186:	6ba5      	ldr	r5, [r4, #56]	; 0x38
 8009188:	409d      	lsls	r5, r3
/*-----------------------------------------------------------*/

static portINLINE uint32_t ulTimerGetAge( const TCPTimer_t *pxTimer );
static portINLINE uint32_t ulTimerGetAge( const TCPTimer_t *pxTimer )
{
	return ( ( xTaskGetTickCount() - ( ( TickType_t ) pxTimer->ulBorn ) ) * portTICK_PERIOD_MS );
 800918a:	f7fa f817 	bl	80031bc <xTaskGetTickCount>
 800918e:	693b      	ldr	r3, [r7, #16]
 8009190:	1ac0      	subs	r0, r0, r3
			if( pxSegment != NULL )
			{
				/* Do check the timing. */
				ulMaxTime = ( 1UL << pxSegment->u.bits.ucTransmitCount ) * ( ( uint32_t ) pxWindow->lSRTT );

				if( ulTimerGetAge( &pxSegment->xTransmitTimer ) > ulMaxTime )
 8009192:	4285      	cmp	r5, r0
 8009194:	d20b      	bcs.n	80091ae <ulTCPWindowTxGet+0x56>
	{
	TCPSegment_t *pxSegment;
	ListItem_t * pxItem;

		/* Detaches and returns the head of a queue. */
		if( listLIST_IS_EMPTY( pxList ) != pdFALSE )
 8009196:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 8009198:	b123      	cbz	r3, 80091a4 <ulTCPWindowTxGet+0x4c>
		{
			pxSegment = NULL;
		}
		else
		{
			pxItem = ( ListItem_t * ) listGET_HEAD_ENTRY( pxList );
 800919a:	6f60      	ldr	r0, [r4, #116]	; 0x74
			pxSegment = ipCAST_PTR_TO_TYPE_PTR( TCPSegment_t, listGET_LIST_ITEM_OWNER( pxItem ) );
 800919c:	68c5      	ldr	r5, [r0, #12]

			( void ) uxListRemove( pxItem );
 800919e:	f7f9 f8db 	bl	8002358 <uxListRemove>
 80091a2:	e000      	b.n	80091a6 <ulTCPWindowTxGet+0x4e>
	ListItem_t * pxItem;

		/* Detaches and returns the head of a queue. */
		if( listLIST_IS_EMPTY( pxList ) != pdFALSE )
		{
			pxSegment = NULL;
 80091a4:	2500      	movs	r5, #0
				if( ulTimerGetAge( &pxSegment->xTransmitTimer ) > ulMaxTime )
				{
					/* A normal (non-fast) retransmission.  Move it from the
					head of the waiting queue. */
					pxSegment = xTCPWindowGetHead( &( pxWindow->xWaitQueue ) );
					pxSegment->u.bits.ucDupAckCount = ( uint8_t ) pdFALSE_UNSIGNED;
 80091a6:	2300      	movs	r3, #0
 80091a8:	756b      	strb	r3, [r5, #21]
				{
					pxSegment = NULL;
				}
			}

			if( pxSegment == NULL )
 80091aa:	2d00      	cmp	r5, #0
 80091ac:	d130      	bne.n	8009210 <ulTCPWindowTxGet+0xb8>
	{
	const ListItem_t *pxItem;
	TCPSegment_t *pxReturn;

		/* Returns the head of a queue but it won't be detached. */
		if( listLIST_IS_EMPTY( pxList ) != pdFALSE )
 80091ae:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80091b0:	2b00      	cmp	r3, #0
 80091b2:	d05b      	beq.n	800926c <ulTCPWindowTxGet+0x114>
			pxReturn = NULL;
		}
		else
		{
			pxItem = ( ListItem_t * ) listGET_HEAD_ENTRY( pxList );
			pxReturn = ipCAST_PTR_TO_TYPE_PTR( TCPSegment_t, listGET_LIST_ITEM_OWNER( pxItem ) );
 80091b4:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80091b6:	68db      	ldr	r3, [r3, #12]
			{
				/* New messages: sent-out for the first time.  Check current
				sliding window size of peer. */
				pxSegment = xTCPWindowPeekHead( &( pxWindow->xTxQueue ) );

				if( pxSegment == NULL )
 80091b8:	2b00      	cmp	r3, #0
 80091ba:	d05d      	beq.n	8009278 <ulTCPWindowTxGet+0x120>
				{
					/* No segments queued. */
					ulReturn = 0UL;
				}
				else if( ( pxWindow->u.bits.bSendFullSize != pdFALSE_UNSIGNED ) && ( pxSegment->lDataLength < pxSegment->lMaxLength ) )
 80091bc:	7822      	ldrb	r2, [r4, #0]
 80091be:	f012 0f02 	tst.w	r2, #2
 80091c2:	d003      	beq.n	80091cc <ulTCPWindowTxGet+0x74>
 80091c4:	689a      	ldr	r2, [r3, #8]
 80091c6:	685b      	ldr	r3, [r3, #4]
 80091c8:	429a      	cmp	r2, r3
 80091ca:	db55      	blt.n	8009278 <ulTCPWindowTxGet+0x120>
				{
					/* A segment has been queued but the driver waits until it
					has a full size of MSS. */
					ulReturn = 0;
				}
				else if( prvTCPWindowTxHasSpace( pxWindow, ulWindowSize ) == pdFALSE )
 80091cc:	4620      	mov	r0, r4
 80091ce:	4641      	mov	r1, r8
 80091d0:	f7ff fcb4 	bl	8008b3c <prvTCPWindowTxHasSpace>
 80091d4:	2800      	cmp	r0, #0
 80091d6:	d04f      	beq.n	8009278 <ulTCPWindowTxGet+0x120>
	{
	TCPSegment_t *pxSegment;
	ListItem_t * pxItem;

		/* Detaches and returns the head of a queue. */
		if( listLIST_IS_EMPTY( pxList ) != pdFALSE )
 80091d8:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80091da:	2b00      	cmp	r3, #0
 80091dc:	d055      	beq.n	800928a <ulTCPWindowTxGet+0x132>
		{
			pxSegment = NULL;
		}
		else
		{
			pxItem = ( ListItem_t * ) listGET_HEAD_ENTRY( pxList );
 80091de:	6e20      	ldr	r0, [r4, #96]	; 0x60
			pxSegment = ipCAST_PTR_TO_TYPE_PTR( TCPSegment_t, listGET_LIST_ITEM_OWNER( pxItem ) );
 80091e0:	68c5      	ldr	r5, [r0, #12]

			( void ) uxListRemove( pxItem );
 80091e2:	f7f9 f8b9 	bl	8002358 <uxListRemove>
					/* Move it out of the Tx queue. */
					pxSegment = xTCPWindowGetHead( &( pxWindow->xTxQueue ) );

					/* Don't let pxHeadSegment point to this segment any more,
					so no more data will be added. */
					if( pxWindow->pxHeadSegment == pxSegment )
 80091e6:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
 80091e8:	42ab      	cmp	r3, r5
 80091ea:	d103      	bne.n	80091f4 <ulTCPWindowTxGet+0x9c>
 80091ec:	e000      	b.n	80091f0 <ulTCPWindowTxGet+0x98>
	ListItem_t * pxItem;

		/* Detaches and returns the head of a queue. */
		if( listLIST_IS_EMPTY( pxList ) != pdFALSE )
		{
			pxSegment = NULL;
 80091ee:	2500      	movs	r5, #0

					/* Don't let pxHeadSegment point to this segment any more,
					so no more data will be added. */
					if( pxWindow->pxHeadSegment == pxSegment )
					{
						pxWindow->pxHeadSegment = NULL;
 80091f0:	2300      	movs	r3, #0
 80091f2:	67e3      	str	r3, [r4, #124]	; 0x7c
					}

					/* pxWindow->tx.highest registers the highest sequence
					number in our transmission window. */
					pxWindow->tx.ulHighestSequenceNumber = pxSegment->ulSequenceNumber + ( ( uint32_t ) pxSegment->lDataLength );
 80091f4:	68aa      	ldr	r2, [r5, #8]
 80091f6:	682b      	ldr	r3, [r5, #0]
 80091f8:	4413      	add	r3, r2
 80091fa:	62a3      	str	r3, [r4, #40]	; 0x28

		/* See if it has already been determined to return 0. */
		if( ulReturn != 0UL )
		{
			/* pxSegment is not NULL when ulReturn != 0UL. */
			configASSERT( pxSegment != NULL );
 80091fc:	b945      	cbnz	r5, 8009210 <ulTCPWindowTxGet+0xb8>
 80091fe:	f04f 0314 	mov.w	r3, #20
 8009202:	f383 8811 	msr	BASEPRI, r3
 8009206:	f3bf 8f6f 	isb	sy
 800920a:	f3bf 8f4f 	dsb	sy
 800920e:	e7fe      	b.n	800920e <ulTCPWindowTxGet+0xb6>
			configASSERT( listLIST_ITEM_CONTAINER( &(pxSegment->xQueueItem ) ) == NULL );
 8009210:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8009212:	b143      	cbz	r3, 8009226 <ulTCPWindowTxGet+0xce>
 8009214:	f04f 0314 	mov.w	r3, #20
 8009218:	f383 8811 	msr	BASEPRI, r3
 800921c:	f3bf 8f6f 	isb	sy
 8009220:	f3bf 8f4f 	dsb	sy
 8009224:	e7fe      	b.n	8009224 <ulTCPWindowTxGet+0xcc>

#if( ipconfigUSE_TCP_WIN == 1 )
	static portINLINE void vListInsertFifo( List_t * const pxList, ListItem_t * const pxNewListItem );
	static portINLINE void vListInsertFifo( List_t * const pxList, ListItem_t * const pxNewListItem )
	{
		vListInsertGeneric( pxList, pxNewListItem, &pxList->xListEnd );
 8009226:	f104 0068 	add.w	r0, r4, #104	; 0x68
 800922a:	f105 0118 	add.w	r1, r5, #24
 800922e:	f104 0270 	add.w	r2, r4, #112	; 0x70
 8009232:	f7ff fc5d 	bl	8008af0 <vListInsertGeneric>
			/* Now that the segment will be transmitted, add it to the tail of
			the waiting queue. */
			vListInsertFifo( &pxWindow->xWaitQueue, &pxSegment->xQueueItem );

			/* And mark it as outstanding. */
			pxSegment->u.bits.bOutstanding = pdTRUE_UNSIGNED;
 8009236:	7dab      	ldrb	r3, [r5, #22]
 8009238:	f043 0301 	orr.w	r3, r3, #1
 800923c:	75ab      	strb	r3, [r5, #22]

			/* Administer the transmit count, needed for fast
			retransmissions. */
			( pxSegment->u.bits.ucTransmitCount )++;
 800923e:	7d2b      	ldrb	r3, [r5, #20]
 8009240:	3301      	adds	r3, #1
 8009242:	b2db      	uxtb	r3, r3
 8009244:	752b      	strb	r3, [r5, #20]

			/* If there have been several retransmissions (4), decrease the
			size of the transmission window to at most 2 times MSS. */
			if( pxSegment->u.bits.ucTransmitCount == MAX_TRANSMIT_COUNT_USING_LARGE_WINDOW )
 8009246:	2b04      	cmp	r3, #4
 8009248:	d106      	bne.n	8009258 <ulTCPWindowTxGet+0x100>
			{
				if( pxWindow->xSize.ulTxWindowLength > ( 2U * ( ( uint32_t ) pxWindow->usMSS ) ) )
 800924a:	f8b4 30bc 	ldrh.w	r3, [r4, #188]	; 0xbc
 800924e:	005b      	lsls	r3, r3, #1
 8009250:	68a2      	ldr	r2, [r4, #8]
 8009252:	429a      	cmp	r2, r3
					FreeRTOS_debug_printf( ( "ulTCPWindowTxGet[%u - %d]: Change Tx window: %lu -> %u\n",
						pxWindow->usPeerPortNumber,
						pxWindow->usOurPortNumber,
						pxWindow->xSize.ulTxWindowLength,
						2U * pxWindow->usMSS ) );
					pxWindow->xSize.ulTxWindowLength = ( 2UL * pxWindow->usMSS );
 8009254:	bf88      	it	hi
 8009256:	60a3      	strhi	r3, [r4, #8]
/*-----------------------------------------------------------*/

static portINLINE void vTCPTimerSet( TCPTimer_t *pxTimer );
static portINLINE void vTCPTimerSet( TCPTimer_t *pxTimer )
{
	pxTimer->ulBorn = xTaskGetTickCount ( );
 8009258:	f7f9 ffb0 	bl	80031bc <xTaskGetTickCount>
 800925c:	6128      	str	r0, [r5, #16]
			}

			/* Clear the transmit timer. */
			vTCPTimerSet( &( pxSegment->xTransmitTimer ) );

			pxWindow->ulOurSequenceNumber = pxSegment->ulSequenceNumber;
 800925e:	682b      	ldr	r3, [r5, #0]
 8009260:	62e3      	str	r3, [r4, #44]	; 0x2c

			/* Inform the caller where to find the data within the queue. */
			*plPosition = pxSegment->lStreamPos;
 8009262:	68eb      	ldr	r3, [r5, #12]
 8009264:	6033      	str	r3, [r6, #0]

			/* And return the length of the data segment */
			ulReturn = ( uint32_t ) pxSegment->lDataLength;
 8009266:	68a8      	ldr	r0, [r5, #8]
 8009268:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	{
	const ListItem_t *pxItem;
	TCPSegment_t *pxReturn;

		/* Returns the head of a queue but it won't be detached. */
		if( listLIST_IS_EMPTY( pxList ) != pdFALSE )
 800926c:	2000      	movs	r0, #0
 800926e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		/* Fetches data to be sent-out now.

		Priority messages: segments with a resend need no check current sliding
		window size. */
		pxSegment = xTCPWindowGetHead( &( pxWindow->xPriorityQueue ) );
		pxWindow->ulOurSequenceNumber = pxWindow->tx.ulHighestSequenceNumber;
 8009272:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8009274:	62c3      	str	r3, [r0, #44]	; 0x2c
 8009276:	e780      	b.n	800917a <ulTCPWindowTxGet+0x22>
	{
	const ListItem_t *pxItem;
	TCPSegment_t *pxReturn;

		/* Returns the head of a queue but it won't be detached. */
		if( listLIST_IS_EMPTY( pxList ) != pdFALSE )
 8009278:	2000      	movs	r0, #0
 800927a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
						pxWindow->pxHeadSegment = NULL;
					}

					/* pxWindow->tx.highest registers the highest sequence
					number in our transmission window. */
					pxWindow->tx.ulHighestSequenceNumber = pxSegment->ulSequenceNumber + ( ( uint32_t ) pxSegment->lDataLength );
 800927e:	2200      	movs	r2, #0
 8009280:	6891      	ldr	r1, [r2, #8]
 8009282:	6813      	ldr	r3, [r2, #0]
 8009284:	440b      	add	r3, r1
 8009286:	62a3      	str	r3, [r4, #40]	; 0x28
 8009288:	e7b9      	b.n	80091fe <ulTCPWindowTxGet+0xa6>
					/* Move it out of the Tx queue. */
					pxSegment = xTCPWindowGetHead( &( pxWindow->xTxQueue ) );

					/* Don't let pxHeadSegment point to this segment any more,
					so no more data will be added. */
					if( pxWindow->pxHeadSegment == pxSegment )
 800928a:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
 800928c:	2b00      	cmp	r3, #0
 800928e:	d1f6      	bne.n	800927e <ulTCPWindowTxGet+0x126>
 8009290:	e7ad      	b.n	80091ee <ulTCPWindowTxGet+0x96>
 8009292:	bf00      	nop

08009294 <ulTCPWindowTxAck>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	uint32_t ulTCPWindowTxAck( TCPWindow_t *pxWindow, uint32_t ulSequenceNumber )
	{
 8009294:	b508      	push	{r3, lr}
	uint32_t ulFirstSequence, ulReturn;

		/* Receive a normal ACK. */

		ulFirstSequence = pxWindow->tx.ulCurrentSequenceNumber;
 8009296:	6a03      	ldr	r3, [r0, #32]
	BaseType_t xResult;

		/* Test if a <= b
		Return true if the unsigned subtraction of (b-a) doesn't generate an
		arithmetic overflow. */
		if( ( ( b - a ) & 0x80000000UL ) == 0UL )
 8009298:	1a5a      	subs	r2, r3, r1

		/* Receive a normal ACK. */

		ulFirstSequence = pxWindow->tx.ulCurrentSequenceNumber;

		if( xSequenceLessThanOrEqual( ulSequenceNumber, ulFirstSequence ) != pdFALSE )
 800929a:	2a00      	cmp	r2, #0
 800929c:	da04      	bge.n	80092a8 <ulTCPWindowTxAck+0x14>
 800929e:	460a      	mov	r2, r1
		{
			ulReturn = 0UL;
		}
		else
		{
			ulReturn = prvTCPWindowTxCheckAck( pxWindow, ulFirstSequence, ulSequenceNumber );
 80092a0:	4619      	mov	r1, r3
 80092a2:	f7ff fcdd 	bl	8008c60 <prvTCPWindowTxCheckAck>
 80092a6:	bd08      	pop	{r3, pc}

		ulFirstSequence = pxWindow->tx.ulCurrentSequenceNumber;

		if( xSequenceLessThanOrEqual( ulSequenceNumber, ulFirstSequence ) != pdFALSE )
		{
			ulReturn = 0UL;
 80092a8:	2000      	movs	r0, #0
		{
			ulReturn = prvTCPWindowTxCheckAck( pxWindow, ulFirstSequence, ulSequenceNumber );
		}

		return ulReturn;
	}
 80092aa:	bd08      	pop	{r3, pc}

080092ac <ulTCPWindowTxSack>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	uint32_t ulTCPWindowTxSack( TCPWindow_t *pxWindow, uint32_t ulFirst, uint32_t ulLast )
	{
 80092ac:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80092b0:	4607      	mov	r7, r0
 80092b2:	460e      	mov	r6, r1
	uint32_t ulAckCount;
	uint32_t ulCurrentSequenceNumber = pxWindow->tx.ulCurrentSequenceNumber;

		/* Receive a SACK option. */
		ulAckCount = prvTCPWindowTxCheckAck( pxWindow, ulFirst, ulLast );
 80092b4:	f7ff fcd4 	bl	8008c60 <prvTCPWindowTxCheckAck>
 80092b8:	4680      	mov	r8, r0
	uint32_t ulCount = 0UL;

		/* A higher Tx block has been acknowledged.  Now iterate through the
		 xWaitQueue to find a possible condition for a FAST retransmission. */

		pxEnd = listGET_END_MARKER( &( pxWindow->xWaitQueue ) );
 80092ba:	f107 0570 	add.w	r5, r7, #112	; 0x70

		pxIterator  = listGET_NEXT( pxEnd );
 80092be:	6f7c      	ldr	r4, [r7, #116]	; 0x74

		while( pxIterator != pxEnd )
 80092c0:	42a5      	cmp	r5, r4
 80092c2:	d022      	beq.n	800930a <ulTCPWindowTxSack+0x5e>
				if( xSequenceLessThan( pxSegment->ulSequenceNumber, ulFirst ) != pdFALSE )
				{
					pxSegment->u.bits.ucDupAckCount++;
					if( pxSegment->u.bits.ucDupAckCount == DUPLICATE_ACKS_BEFORE_FAST_RETRANSMIT )
					{
						pxSegment->u.bits.ucTransmitCount = ( uint8_t ) pdFALSE;
 80092c4:	f04f 0a00 	mov.w	sl, #0

						/* Remove it from xWaitQueue. */
						( void ) uxListRemove( &pxSegment->xQueueItem );
						/* Add this segment to the priority queue so it gets
						retransmitted immediately. */
						vListInsertFifo( &( pxWindow->xPriorityQueue ), &( pxSegment->xQueueItem ) );
 80092c8:	f107 0940 	add.w	r9, r7, #64	; 0x40

#if( ipconfigUSE_TCP_WIN == 1 )
	static portINLINE void vListInsertFifo( List_t * const pxList, ListItem_t * const pxNewListItem );
	static portINLINE void vListInsertFifo( List_t * const pxList, ListItem_t * const pxNewListItem )
	{
		vListInsertGeneric( pxList, pxNewListItem, &pxList->xListEnd );
 80092cc:	3748      	adds	r7, #72	; 0x48
		pxIterator  = listGET_NEXT( pxEnd );

		while( pxIterator != pxEnd )
		{
			/* Get the owner, which is a TCP segment. */
			pxSegment = ipCAST_PTR_TO_TYPE_PTR( TCPSegment_t, listGET_LIST_ITEM_OWNER( pxIterator ) );
 80092ce:	68e1      	ldr	r1, [r4, #12]

			/* Hop to the next item before the current gets unlinked. */
			pxIterator  = listGET_NEXT( pxIterator );
 80092d0:	6864      	ldr	r4, [r4, #4]

			/* Fast retransmission:
			When 3 packets with a higher sequence number have been acknowledged
			by the peer, it is very unlikely a current packet will ever arrive.
			It will be retransmitted far before the RTO. */
			if( pxSegment->u.bits.bAcked == pdFALSE_UNSIGNED )
 80092d2:	7d8b      	ldrb	r3, [r1, #22]
 80092d4:	f013 0f02 	tst.w	r3, #2
 80092d8:	d115      	bne.n	8009306 <ulTCPWindowTxSack+0x5a>
 80092da:	680b      	ldr	r3, [r1, #0]
 80092dc:	43db      	mvns	r3, r3
			{
				if( xSequenceLessThan( pxSegment->ulSequenceNumber, ulFirst ) != pdFALSE )
 80092de:	42f3      	cmn	r3, r6
 80092e0:	d411      	bmi.n	8009306 <ulTCPWindowTxSack+0x5a>
				{
					pxSegment->u.bits.ucDupAckCount++;
 80092e2:	7d4b      	ldrb	r3, [r1, #21]
 80092e4:	3301      	adds	r3, #1
 80092e6:	b2db      	uxtb	r3, r3
 80092e8:	754b      	strb	r3, [r1, #21]
					if( pxSegment->u.bits.ucDupAckCount == DUPLICATE_ACKS_BEFORE_FAST_RETRANSMIT )
 80092ea:	2b03      	cmp	r3, #3
 80092ec:	d10b      	bne.n	8009306 <ulTCPWindowTxSack+0x5a>
					{
						pxSegment->u.bits.ucTransmitCount = ( uint8_t ) pdFALSE;
 80092ee:	f881 a014 	strb.w	sl, [r1, #20]
								ulFirst - pxWindow->tx.ulFirstSequenceNumber ) );
							FreeRTOS_flush_logging( );
						}

						/* Remove it from xWaitQueue. */
						( void ) uxListRemove( &pxSegment->xQueueItem );
 80092f2:	f101 0b18 	add.w	fp, r1, #24
 80092f6:	4658      	mov	r0, fp
 80092f8:	f7f9 f82e 	bl	8002358 <uxListRemove>

#if( ipconfigUSE_TCP_WIN == 1 )
	static portINLINE void vListInsertFifo( List_t * const pxList, ListItem_t * const pxNewListItem );
	static portINLINE void vListInsertFifo( List_t * const pxList, ListItem_t * const pxNewListItem )
	{
		vListInsertGeneric( pxList, pxNewListItem, &pxList->xListEnd );
 80092fc:	4648      	mov	r0, r9
 80092fe:	4659      	mov	r1, fp
 8009300:	463a      	mov	r2, r7
 8009302:	f7ff fbf5 	bl	8008af0 <vListInsertGeneric>

		pxEnd = listGET_END_MARKER( &( pxWindow->xWaitQueue ) );

		pxIterator  = listGET_NEXT( pxEnd );

		while( pxIterator != pxEnd )
 8009306:	42a5      	cmp	r5, r4
 8009308:	d1e1      	bne.n	80092ce <ulTCPWindowTxSack+0x22>
				pxWindow->tx.ulCurrentSequenceNumber - pxWindow->tx.ulFirstSequenceNumber ) );
			FreeRTOS_flush_logging( );
		}

		return ulAckCount;
	}
 800930a:	4640      	mov	r0, r8
 800930c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

08009310 <vProcessGeneratedUDPPacket>:
	}
};
/*-----------------------------------------------------------*/

void vProcessGeneratedUDPPacket( NetworkBufferDescriptor_t * const pxNetworkBuffer )
{
 8009310:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8009314:	b082      	sub	sp, #8
 8009316:	4604      	mov	r4, r0
UDPPacket_t *pxUDPPacket;
IPHeader_t *pxIPHeader;
eARPLookupResult_t eReturned;
uint32_t ulIPAddress = pxNetworkBuffer->ulIPAddress;
 8009318:	6943      	ldr	r3, [r0, #20]
 800931a:	9301      	str	r3, [sp, #4]
size_t uxPayloadSize;

	/* Map the UDP packet onto the start of the frame. */
	pxUDPPacket = ipCAST_PTR_TO_TYPE_PTR( UDPPacket_t, pxNetworkBuffer->pucEthernetBuffer );
 800931c:	6985      	ldr	r5, [r0, #24]
		uxPayloadSize = pxNetworkBuffer->xDataLength - sizeof( ICMPPacket_t );
	}
	else
#endif
	{
		uxPayloadSize = pxNetworkBuffer->xDataLength - sizeof( UDPPacket_t );
 800931e:	69c6      	ldr	r6, [r0, #28]
 8009320:	3e2a      	subs	r6, #42	; 0x2a
	}

	/* Determine the ARP cache status for the requested IP address. */
	eReturned = eARPGetCacheEntry( &( ulIPAddress ), &( pxUDPPacket->xEthernetHeader.xDestinationAddress ) );
 8009322:	a801      	add	r0, sp, #4
 8009324:	4629      	mov	r1, r5
 8009326:	f7fb fac1 	bl	80048ac <eARPGetCacheEntry>

	if( eReturned != eCantSendPacket )
 800932a:	2802      	cmp	r0, #2
 800932c:	d064      	beq.n	80093f8 <vProcessGeneratedUDPPacket+0xe8>
	{
		if( eReturned == eARPCacheHit )
 800932e:	2801      	cmp	r0, #1
 8009330:	d154      	bne.n	80093dc <vProcessGeneratedUDPPacket+0xcc>
			pxIPHeader = &( pxUDPPacket->xIPHeader );

		#if ( ipconfigSUPPORT_OUTGOING_PINGS == 1 )
			/* Is it possible that the packet is not actually a UDP packet
			after all, but an ICMP packet. */
			if( pxNetworkBuffer->usPort != ( uint16_t ) ipPACKET_CONTAINS_ICMP_DATA )
 8009332:	8c23      	ldrh	r3, [r4, #32]
 8009334:	b173      	cbz	r3, 8009354 <vProcessGeneratedUDPPacket+0x44>
			{
			UDPHeader_t *pxUDPHeader;

				pxUDPHeader = &( pxUDPPacket->xUDPHeader );

				pxUDPHeader->usDestinationPort = pxNetworkBuffer->usPort;
 8009336:	84ab      	strh	r3, [r5, #36]	; 0x24
				pxUDPHeader->usSourcePort = pxNetworkBuffer->usBoundPort;
 8009338:	8c63      	ldrh	r3, [r4, #34]	; 0x22
 800933a:	846b      	strh	r3, [r5, #34]	; 0x22
				pxUDPHeader->usLength = ( uint16_t ) ( uxPayloadSize + sizeof( UDPHeader_t ) );
 800933c:	f106 0308 	add.w	r3, r6, #8
 8009340:	b29b      	uxth	r3, r3
				pxUDPHeader->usLength = FreeRTOS_htons( pxUDPHeader->usLength );
 8009342:	0a1a      	lsrs	r2, r3, #8
 8009344:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
 8009348:	84eb      	strh	r3, [r5, #38]	; 0x26
				pxUDPHeader->usChecksum = 0U;
 800934a:	2300      	movs	r3, #0
 800934c:	f885 3028 	strb.w	r3, [r5, #40]	; 0x28
 8009350:	f885 3029 	strb.w	r3, [r5, #41]	; 0x29
			*/

			/* Save options now, as they will be overwritten by memcpy */
			#if( ipconfigDRIVER_INCLUDED_TX_IP_CHECKSUM == 0 )
			{
				ucSocketOptions = pxNetworkBuffer->pucEthernetBuffer[ ipSOCKET_OPTIONS_OFFSET ];
 8009354:	f8d4 c018 	ldr.w	ip, [r4, #24]
 8009358:	f81c 8f06 	ldrb.w	r8, [ip, #6]!
			 * Offset the memcpy by the size of a MAC address to start at the packet's
			 * Ethernet header 'source' MAC address; the preceding 'destination' should not be altered.
			 */
			/* The Ethernet source address is at offset 6. */
			char *pxUdpSrcAddrOffset = ( char *) ( &( pxNetworkBuffer->pucEthernetBuffer[ sizeof( MACAddress_t ) ] ) );
			( void ) memcpy( ( void * ) pxUdpSrcAddrOffset, ( const void * ) ( xDefaultPartUDPPacketHeader.ucBytes ), sizeof( xDefaultPartUDPPacketHeader ) );
 800935c:	f8df e0a4 	ldr.w	lr, [pc, #164]	; 8009404 <vProcessGeneratedUDPPacket+0xf4>
 8009360:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 8009364:	69a7      	ldr	r7, [r4, #24]
 8009366:	f8c7 0006 	str.w	r0, [r7, #6]
 800936a:	f8cc 1004 	str.w	r1, [ip, #4]
 800936e:	f8cc 2008 	str.w	r2, [ip, #8]
 8009372:	f8cc 300c 	str.w	r3, [ip, #12]
 8009376:	e8be 0003 	ldmia.w	lr!, {r0, r1}
 800937a:	f8cc 0010 	str.w	r0, [ip, #16]
 800937e:	f8cc 1014 	str.w	r1, [ip, #20]

		#if ipconfigSUPPORT_OUTGOING_PINGS == 1
			if( pxNetworkBuffer->usPort == ( uint16_t ) ipPACKET_CONTAINS_ICMP_DATA )
 8009382:	8c23      	ldrh	r3, [r4, #32]
 8009384:	b923      	cbnz	r3, 8009390 <vProcessGeneratedUDPPacket+0x80>
			{
				pxIPHeader->ucProtocol = ipPROTOCOL_ICMP;
 8009386:	2301      	movs	r3, #1
 8009388:	75eb      	strb	r3, [r5, #23]
				pxIPHeader->usLength = ( uint16_t ) ( uxPayloadSize + sizeof( IPHeader_t ) + sizeof( ICMPHeader_t ) );
 800938a:	361c      	adds	r6, #28
 800938c:	822e      	strh	r6, [r5, #16]
 800938e:	e001      	b.n	8009394 <vProcessGeneratedUDPPacket+0x84>
			}
			else
		#endif /* ipconfigSUPPORT_OUTGOING_PINGS */
			{
				pxIPHeader->usLength = ( uint16_t ) ( uxPayloadSize + sizeof( IPHeader_t ) + sizeof( UDPHeader_t ) );
 8009390:	361c      	adds	r6, #28
 8009392:	822e      	strh	r6, [r5, #16]
			}

			pxIPHeader->usLength = FreeRTOS_htons( pxIPHeader->usLength );
 8009394:	8a2a      	ldrh	r2, [r5, #16]
 8009396:	0a13      	lsrs	r3, r2, #8
 8009398:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800939c:	822b      	strh	r3, [r5, #16]
			pxIPHeader->ulDestinationIPAddress = pxNetworkBuffer->ulIPAddress;
 800939e:	6963      	ldr	r3, [r4, #20]
 80093a0:	f8c5 301e 	str.w	r3, [r5, #30]
			}
			#endif

			#if( ipconfigDRIVER_INCLUDED_TX_IP_CHECKSUM == 0 )
			{
				pxIPHeader->usHeaderChecksum = 0U;
 80093a4:	2000      	movs	r0, #0
 80093a6:	7628      	strb	r0, [r5, #24]
 80093a8:	7668      	strb	r0, [r5, #25]
				pxIPHeader->usHeaderChecksum = usGenerateChecksum( 0U, ( uint8_t * ) &( pxIPHeader->ucVersionHeaderLength ), ipSIZE_OF_IPv4_HEADER );
 80093aa:	f105 010e 	add.w	r1, r5, #14
 80093ae:	2214      	movs	r2, #20
 80093b0:	f7fb ffb4 	bl	800531c <usGenerateChecksum>
				pxIPHeader->usHeaderChecksum = ~FreeRTOS_htons( pxIPHeader->usHeaderChecksum );
 80093b4:	0a03      	lsrs	r3, r0, #8
 80093b6:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 80093ba:	43c0      	mvns	r0, r0
 80093bc:	8328      	strh	r0, [r5, #24]

				if( ( ucSocketOptions & ( uint8_t ) FREERTOS_SO_UDPCKSUM_OUT ) != 0U )
 80093be:	f018 0f02 	tst.w	r8, #2
 80093c2:	d005      	beq.n	80093d0 <vProcessGeneratedUDPPacket+0xc0>
				{
					( void ) usGenerateProtocolChecksum( ( uint8_t * ) pxUDPPacket, pxNetworkBuffer->xDataLength, pdTRUE );
 80093c4:	4628      	mov	r0, r5
 80093c6:	69e1      	ldr	r1, [r4, #28]
 80093c8:	2201      	movs	r2, #1
 80093ca:	f7fc f817 	bl	80053fc <usGenerateProtocolChecksum>
 80093ce:	e00e      	b.n	80093ee <vProcessGeneratedUDPPacket+0xde>
				}
				else
				{
					pxUDPPacket->xUDPHeader.usChecksum = 0U;
 80093d0:	2300      	movs	r3, #0
 80093d2:	f885 3028 	strb.w	r3, [r5, #40]	; 0x28
 80093d6:	f885 3029 	strb.w	r3, [r5, #41]	; 0x29
 80093da:	e008      	b.n	80093ee <vProcessGeneratedUDPPacket+0xde>
				}
			}
			#endif
		}
		else if( eReturned == eARPCacheMiss )
 80093dc:	b960      	cbnz	r0, 80093f8 <vProcessGeneratedUDPPacket+0xe8>
		{
			/* Add an entry to the ARP table with a null hardware address.
			This allows the ARP timer to know that an ARP reply is
			outstanding, and perform retransmissions if necessary. */
			vARPRefreshCacheEntry( NULL, ulIPAddress );
 80093de:	9901      	ldr	r1, [sp, #4]
 80093e0:	f7fb f968 	bl	80046b4 <vARPRefreshCacheEntry>

			/* Generate an ARP for the required IP address. */
			iptracePACKET_DROPPED_TO_GENERATE_ARP( pxNetworkBuffer->ulIPAddress );
			pxNetworkBuffer->ulIPAddress = ulIPAddress;
 80093e4:	9b01      	ldr	r3, [sp, #4]
 80093e6:	6163      	str	r3, [r4, #20]
			vARPGenerateRequestPacket( pxNetworkBuffer );
 80093e8:	4620      	mov	r0, r4
 80093ea:	f7fb fabf 	bl	800496c <vARPGenerateRequestPacket>
				pxNetworkBuffer->xDataLength = ( size_t ) ipconfigETHERNET_MINIMUM_PACKET_BYTES;
			}
		}
		#endif

		( void ) xNetworkInterfaceOutput( pxNetworkBuffer, pdTRUE );
 80093ee:	4620      	mov	r0, r4
 80093f0:	2101      	movs	r1, #1
 80093f2:	f7fa ff37 	bl	8004264 <xNetworkInterfaceOutput>
 80093f6:	e002      	b.n	80093fe <vProcessGeneratedUDPPacket+0xee>
	}
	else
	{
		/* The packet can't be sent (DHCP not completed?).  Just drop the
		packet. */
		vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 80093f8:	4620      	mov	r0, r4
 80093fa:	f7fb f8e9 	bl	80045d0 <vReleaseNetworkBufferAndDescriptor>
	}
}
 80093fe:	b002      	add	sp, #8
 8009400:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8009404:	2000d5c0 	.word	0x2000d5c0

08009408 <xProcessReceivedUDPPacket>:

BaseType_t xProcessReceivedUDPPacket( NetworkBufferDescriptor_t *pxNetworkBuffer, uint16_t usPort )
{
BaseType_t xReturn = pdPASS;
FreeRTOS_Socket_t *pxSocket;
configASSERT( pxNetworkBuffer != NULL );
 8009408:	b940      	cbnz	r0, 800941c <xProcessReceivedUDPPacket+0x14>
 800940a:	f04f 0314 	mov.w	r3, #20
 800940e:	f383 8811 	msr	BASEPRI, r3
 8009412:	f3bf 8f6f 	isb	sy
 8009416:	f3bf 8f4f 	dsb	sy
 800941a:	e7fe      	b.n	800941a <xProcessReceivedUDPPacket+0x12>
	}
}
/*-----------------------------------------------------------*/

BaseType_t xProcessReceivedUDPPacket( NetworkBufferDescriptor_t *pxNetworkBuffer, uint16_t usPort )
{
 800941c:	b570      	push	{r4, r5, r6, lr}
 800941e:	4604      	mov	r4, r0
BaseType_t xReturn = pdPASS;
FreeRTOS_Socket_t *pxSocket;
configASSERT( pxNetworkBuffer != NULL );
configASSERT( pxNetworkBuffer->pucEthernetBuffer != NULL );
 8009420:	6985      	ldr	r5, [r0, #24]
 8009422:	b945      	cbnz	r5, 8009436 <xProcessReceivedUDPPacket+0x2e>
 8009424:	f04f 0314 	mov.w	r3, #20
 8009428:	f383 8811 	msr	BASEPRI, r3
 800942c:	f3bf 8f6f 	isb	sy
 8009430:	f3bf 8f4f 	dsb	sy
 8009434:	e7fe      	b.n	8009434 <xProcessReceivedUDPPacket+0x2c>
 8009436:	4608      	mov	r0, r1

/* Map the ethernet buffer to the UDPPacket_t struct for easy access to the fields. */
const UDPPacket_t *pxUDPPacket = ipCAST_CONST_PTR_TO_CONST_TYPE_PTR( UDPPacket_t, pxNetworkBuffer->pucEthernetBuffer );

	/* Caller must check for minimum packet size. */
	pxSocket = pxUDPSocketLookup( usPort );
 8009438:	f7fc ff6c 	bl	8006314 <pxUDPSocketLookup>

	if( pxSocket != NULL )
 800943c:	4606      	mov	r6, r0
 800943e:	b310      	cbz	r0, 8009486 <xProcessReceivedUDPPacket+0x7e>
	{

		/* When refreshing the ARP cache with received UDP packets we must be
		careful;  hundreds of broadcast messages may pass and if we're not
		handling them, no use to fill the ARP cache with those IP addresses. */
		vARPRefreshCacheEntry( &( pxUDPPacket->xEthernetHeader.xSourceAddress ), pxUDPPacket->xIPHeader.ulSourceIPAddress );
 8009440:	1da8      	adds	r0, r5, #6
 8009442:	f8d5 101a 	ldr.w	r1, [r5, #26]
 8009446:	f7fb f935 	bl	80046b4 <vARPRefreshCacheEntry>
		if( xReturn == pdPASS )	/*lint !e774: Boolean within 'if' always evaluates to True, depending on configuration. [MISRA 2012 Rule 14.3, required. */
		#else
		/* xReturn is still pdPASS. */
		#endif
		{
			vTaskSuspendAll();
 800944a:	f7f9 feaf 	bl	80031ac <vTaskSuspendAll>
			{
				taskENTER_CRITICAL();
 800944e:	f7f8 fcb7 	bl	8001dc0 <vPortEnterCritical>
					}
					else
					{
						/* Add the network packet to the list of packets to be
						processed by the socket. */
						vListInsertEnd( &( pxSocket->u.xUDP.xWaitingPacketsList ), &( pxNetworkBuffer->xBufferListItem ) );
 8009452:	f106 0038 	add.w	r0, r6, #56	; 0x38
 8009456:	4621      	mov	r1, r4
 8009458:	f7f8 ff58 	bl	800230c <vListInsertEnd>
					}
				}
				taskEXIT_CRITICAL();
 800945c:	f7f8 fcd2 	bl	8001e04 <vPortExitCritical>
			}
			( void ) xTaskResumeAll();
 8009460:	f7f9 ff44 	bl	80032ec <xTaskResumeAll>

			/* Set the socket's receive event */
			if( pxSocket->xEventGroup != NULL )
 8009464:	6870      	ldr	r0, [r6, #4]
 8009466:	b110      	cbz	r0, 800946e <xProcessReceivedUDPPacket+0x66>
			{
				( void ) xEventGroupSetBits( pxSocket->xEventGroup, ( EventBits_t ) eSOCKET_RECEIVE );
 8009468:	2101      	movs	r1, #1
 800946a:	f7f8 fecb 	bl	8002204 <xEventGroupSetBits>
			}

			#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
			{
				if( ( pxSocket->pxSocketSet != NULL ) && ( ( pxSocket->xSelectBits & ( ( EventBits_t ) eSELECT_READ ) ) != 0U ) )
 800946e:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8009470:	b1cb      	cbz	r3, 80094a6 <xProcessReceivedUDPPacket+0x9e>
 8009472:	6b32      	ldr	r2, [r6, #48]	; 0x30
 8009474:	f012 0f01 	tst.w	r2, #1
 8009478:	d017      	beq.n	80094aa <xProcessReceivedUDPPacket+0xa2>
				{
					( void ) xEventGroupSetBits( pxSocket->pxSocketSet->xSelectGroup, ( EventBits_t ) eSELECT_READ );
 800947a:	6818      	ldr	r0, [r3, #0]
 800947c:	2101      	movs	r1, #1
 800947e:	f7f8 fec1 	bl	8002204 <xEventGroupSetBits>
}
/*-----------------------------------------------------------*/

BaseType_t xProcessReceivedUDPPacket( NetworkBufferDescriptor_t *pxNetworkBuffer, uint16_t usPort )
{
BaseType_t xReturn = pdPASS;
 8009482:	2001      	movs	r0, #1
 8009484:	bd70      	pop	{r4, r5, r6, pc}
		#if( ipconfigUSE_DNS == 1 ) && ( ipconfigDNS_USE_CALLBACKS == 1 )
			/* A DNS reply, check for the source port.  Although the DNS client
			does open a UDP socket to send a messages, this socket will be
			closed after a short timeout.  Messages that come late (after the
			socket is closed) will be treated here. */
			if( FreeRTOS_ntohs( pxUDPPacket->xUDPHeader.usSourcePort ) == ( uint16_t ) ipDNS_PORT )
 8009486:	8c6a      	ldrh	r2, [r5, #34]	; 0x22
 8009488:	0a13      	lsrs	r3, r2, #8
 800948a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800948e:	b21b      	sxth	r3, r3
 8009490:	2b35      	cmp	r3, #53	; 0x35
 8009492:	d10c      	bne.n	80094ae <xProcessReceivedUDPPacket+0xa6>
			{
				vARPRefreshCacheEntry( &( pxUDPPacket->xEthernetHeader.xSourceAddress ), pxUDPPacket->xIPHeader.ulSourceIPAddress );
 8009494:	1da8      	adds	r0, r5, #6
 8009496:	f8d5 101a 	ldr.w	r1, [r5, #26]
 800949a:	f7fb f90b 	bl	80046b4 <vARPRefreshCacheEntry>
				xReturn = ( BaseType_t )ulDNSHandlePacket( pxNetworkBuffer );
 800949e:	4620      	mov	r0, r4
 80094a0:	f7fb fd64 	bl	8004f6c <ulDNSHandlePacket>
 80094a4:	bd70      	pop	{r4, r5, r6, pc}
}
/*-----------------------------------------------------------*/

BaseType_t xProcessReceivedUDPPacket( NetworkBufferDescriptor_t *pxNetworkBuffer, uint16_t usPort )
{
BaseType_t xReturn = pdPASS;
 80094a6:	2001      	movs	r0, #1
 80094a8:	bd70      	pop	{r4, r5, r6, pc}
 80094aa:	2001      	movs	r0, #1
 80094ac:	bd70      	pop	{r4, r5, r6, pc}
				xReturn = ( BaseType_t )ulNBNSHandlePacket( pxNetworkBuffer );
			}
			else
		#endif /* ipconfigUSE_NBNS */
			{
				xReturn = pdFAIL;
 80094ae:	2000      	movs	r0, #0
			}
	}

	return xReturn;
}
 80094b0:	bd70      	pop	{r4, r5, r6, pc}
 80094b2:	bf00      	nop

080094b4 <UART_get_channel>:
	/* Local variable */
	XMC_USIC_CH_t * context = (XMC_USIC_CH_t *)p_context;
	eUART_Channel channel;

	/* Check for UART channel number */
	if( XMC_UART0_CH0 == context )
 80094b4:	4b11      	ldr	r3, [pc, #68]	; (80094fc <UART_get_channel+0x48>)
 80094b6:	4298      	cmp	r0, r3
 80094b8:	d015      	beq.n	80094e6 <UART_get_channel+0x32>
	{
		channel = UART_CHANNEL_0;
	}
	else if( XMC_UART0_CH1 == context )
 80094ba:	f503 7300 	add.w	r3, r3, #512	; 0x200
 80094be:	4298      	cmp	r0, r3
 80094c0:	d013      	beq.n	80094ea <UART_get_channel+0x36>
	{
		channel = UART_CHANNEL_1;
	}
	else if( XMC_UART1_CH0 == context )
 80094c2:	4b0f      	ldr	r3, [pc, #60]	; (8009500 <UART_get_channel+0x4c>)
 80094c4:	4298      	cmp	r0, r3
 80094c6:	d012      	beq.n	80094ee <UART_get_channel+0x3a>
	{
		channel = UART_CHANNEL_2;
	}
	else if( XMC_UART1_CH1 == context )
 80094c8:	f503 7300 	add.w	r3, r3, #512	; 0x200
 80094cc:	4298      	cmp	r0, r3
 80094ce:	d010      	beq.n	80094f2 <UART_get_channel+0x3e>
	{
		channel = UART_CHANNEL_3;
	}
	else if( XMC_UART2_CH0 == context )
 80094d0:	f503 5378 	add.w	r3, r3, #15872	; 0x3e00
 80094d4:	4298      	cmp	r0, r3
 80094d6:	d00e      	beq.n	80094f6 <UART_get_channel+0x42>
	{
		channel = UART_CHANNEL_4;
	}
	else if( XMC_UART2_CH1 == context )
	{
		channel = UART_CHANNEL_5;
 80094d8:	f503 7300 	add.w	r3, r3, #512	; 0x200
 80094dc:	4298      	cmp	r0, r3
 80094de:	bf0c      	ite	eq
 80094e0:	2005      	moveq	r0, #5
 80094e2:	2000      	movne	r0, #0
 80094e4:	4770      	bx	lr
	eUART_Channel channel;

	/* Check for UART channel number */
	if( XMC_UART0_CH0 == context )
	{
		channel = UART_CHANNEL_0;
 80094e6:	2000      	movs	r0, #0
 80094e8:	4770      	bx	lr
	}
	else if( XMC_UART0_CH1 == context )
	{
		channel = UART_CHANNEL_1;
 80094ea:	2001      	movs	r0, #1
 80094ec:	4770      	bx	lr
	}
	else if( XMC_UART1_CH0 == context )
	{
		channel = UART_CHANNEL_2;
 80094ee:	2002      	movs	r0, #2
 80094f0:	4770      	bx	lr
	}
	else if( XMC_UART1_CH1 == context )
	{
		channel = UART_CHANNEL_3;
 80094f2:	2003      	movs	r0, #3
 80094f4:	4770      	bx	lr
	}
	else if( XMC_UART2_CH0 == context )
	{
		channel = UART_CHANNEL_4;
 80094f6:	2004      	movs	r0, #4
	{
		channel = UART_CHANNEL_5;
	}
	else{ /* else not required */ }
	return channel;
}
 80094f8:	4770      	bx	lr
 80094fa:	bf00      	nop
 80094fc:	40030000 	.word	0x40030000
 8009500:	48020000 	.word	0x48020000

08009504 <reconfigure_rx_fifo>:
	}
}


void reconfigure_rx_fifo( void * p_channel, unsigned long data_size )
{
 8009504:	b508      	push	{r3, lr}
	/* Local Variables */
	tStUART_Configuartion * p_config_l = ((tStUART_Channel*)p_channel)->p_config;
 8009506:	6800      	ldr	r0, [r0, #0]
	unsigned long fifo_size = 0U;
	unsigned long ret_limit_val = 0U;

	/* Get FIFO size in bytes */
	fifo_size = (unsigned long) ( 0x01UL << (unsigned char) (p_config_l->fifo_cfg.rx_fifo_size) );
 8009508:	7f43      	ldrb	r3, [r0, #29]
 800950a:	2201      	movs	r2, #1
 800950c:	409a      	lsls	r2, r3
	/* If data size is more than FIFO size, configure the limit to the FIFO size */
	ret_limit_val = ( data_size < fifo_size ) ? data_size - 1U : fifo_size - 1U;
 800950e:	428a      	cmp	r2, r1
 8009510:	bf8c      	ite	hi
 8009512:	f101 32ff 	addhi.w	r2, r1, #4294967295
 8009516:	f102 32ff 	addls.w	r2, r2, #4294967295
	/* Set the limit value */
	XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit( (XMC_USIC_CH_t *const)p_config_l->p_channel_context,
 800951a:	6800      	ldr	r0, [r0, #0]
 800951c:	4619      	mov	r1, r3
 800951e:	f7f8 fb99 	bl	8001c54 <XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit>
 8009522:	bd08      	pop	{r3, pc}

08009524 <UART_init>:
 * <i>Imp Note:</i>
 *
 */
long UART_init( void * p_channel, const unsigned char init )
{
	DRIVER_ASSERT( NULL == p_channel, UART_STATUS_INVALID_ARGUMENT );
 8009524:	2800      	cmp	r0, #0
 8009526:	f000 80ed 	beq.w	8009704 <UART_init+0x1e0>
 *
 * <i>Imp Note:</i>
 *
 */
long UART_init( void * p_channel, const unsigned char init )
{
 800952a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800952e:	4604      	mov	r4, r0
 8009530:	460d      	mov	r5, r1
	DRIVER_ASSERT( NULL == p_channel, UART_STATUS_INVALID_ARGUMENT );
	/* Local Variables */
	const tStUART_Configuartion * p_config_l = ((const tStUART_Channel *) p_channel)->p_config;
 8009532:	6806      	ldr	r6, [r0, #0]
	tStUART_Control * p_control_l = ((tStUART_Channel*) p_channel)->p_control;
 8009534:	f8d0 8004 	ldr.w	r8, [r0, #4]

void calc_fifo( const void * p_channel, unsigned long fifo_size_arr[2] )
{
	/* Local variables */
	const tStUART_Configuartion * p_config_l = ((const tStUART_Channel *) p_channel)->p_config;
	eUART_Channel channel = UART_get_channel( p_config_l->p_channel_context );
 8009538:	6837      	ldr	r7, [r6, #0]
 800953a:	4638      	mov	r0, r7
 800953c:	f7ff ffba 	bl	80094b4 <UART_get_channel>

	/* Check channel */
	switch( channel )
 8009540:	2803      	cmp	r0, #3
 8009542:	d003      	beq.n	800954c <UART_init+0x28>
 8009544:	2805      	cmp	r0, #5
 8009546:	d001      	beq.n	800954c <UART_init+0x28>
 8009548:	2801      	cmp	r0, #1
 800954a:	d104      	bne.n	8009556 <UART_init+0x32>
	/* Local Variables */
	const tStUART_Configuartion * p_config_l = ((const tStUART_Channel *) p_channel)->p_config;
	tStUART_Control * p_control_l = ((tStUART_Channel*) p_channel)->p_control;

	long ret_status = UART_STATUS_FAILED;
	unsigned long fifo_size[2] = {0U};
 800954c:	f04f 0900 	mov.w	r9, #0
			break;
		case UART_CHANNEL_1:
		case UART_CHANNEL_3:
		case UART_CHANNEL_5:
			/* Update fifo_size */
			fifo_size_arr[0] = 16U;
 8009550:	f04f 0a10 	mov.w	sl, #16
 8009554:	e003      	b.n	800955e <UART_init+0x3a>
		case UART_CHANNEL_0:
		case UART_CHANNEL_2:
		case UART_CHANNEL_4:
			/* Update fifo_size */
			fifo_size_arr[0] = 48U;
			fifo_size_arr[1] = 32U;
 8009556:	f04f 0920 	mov.w	r9, #32
		default:/* Considering all in default */
		case UART_CHANNEL_0:
		case UART_CHANNEL_2:
		case UART_CHANNEL_4:
			/* Update fifo_size */
			fifo_size_arr[0] = 48U;
 800955a:	f04f 0a30 	mov.w	sl, #48	; 0x30

	/* calculate FIFO size */
	calc_fifo( p_channel, fifo_size );

	/* Check input argument */
	switch( init )
 800955e:	2d00      	cmp	r5, #0
 8009560:	f000 80c6 	beq.w	80096f0 <UART_init+0x1cc>
 8009564:	2d01      	cmp	r5, #1
 8009566:	f040 80cf 	bne.w	8009708 <UART_init+0x1e4>
	{
		/* Open UART Channel */
		case UART_INIT_OPEN:
			/* Check for initialization */
			if( p_control_l->state.state_value > 0 ){ break;	}
 800956a:	f8d8 3018 	ldr.w	r3, [r8, #24]
 800956e:	2b00      	cmp	r3, #0
 8009570:	f040 80cd 	bne.w	800970e <UART_init+0x1ea>
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_RXFIFO_GetLevel() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_RXFIFO_Flush(XMC_USIC_CH_t *const channel)
{
  channel->TRBSCR = (uint32_t)USIC_CH_TRBSCR_FLUSHRB_Msk;
 8009574:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8009578:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
			else{	/* Not required */	}

			/* Flush RX FIFO */
			XMC_USIC_CH_RXFIFO_Flush( (XMC_USIC_CH_t *)(p_config_l->p_channel_context) );
			/* Initialize UART channel for communication */
			XMC_UART_CH_Init( (XMC_USIC_CH_t *)p_config_l->p_channel_context,
 800957c:	4631      	mov	r1, r6
 800957e:	f851 0b04 	ldr.w	r0, [r1], #4
 8009582:	f7f8 fa2d 	bl	80019e0 <XMC_UART_CH_Init>
 8009586:	7fb2      	ldrb	r2, [r6, #30]
 8009588:	6833      	ldr	r3, [r6, #0]
 800958a:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 * XMC_USIC_CH_EnableInputInversion(), XMC_USIC_CH_EnableInputDigitalFilter(), XMC_USIC_CH_EnableInputSync(),
 * XMC_USIC_CH_SetInputSamplingFreq()\n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_SetInputSource(XMC_USIC_CH_t *const channel, const XMC_USIC_CH_INPUT_t input, const uint8_t source)
{
  channel->DXCR[input] = (uint32_t)((channel->DXCR[input] & (uint32_t)(~USIC_CH_DXCR_DSEL_Msk)) |
 800958e:	69da      	ldr	r2, [r3, #28]
 8009590:	f022 0107 	bic.w	r1, r2, #7
                         ((uint32_t)source << USIC_CH_DXCR_DSEL_Pos));
 8009594:	7ff2      	ldrb	r2, [r6, #31]
 * XMC_USIC_CH_EnableInputInversion(), XMC_USIC_CH_EnableInputDigitalFilter(), XMC_USIC_CH_EnableInputSync(),
 * XMC_USIC_CH_SetInputSamplingFreq()\n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_SetInputSource(XMC_USIC_CH_t *const channel, const XMC_USIC_CH_INPUT_t input, const uint8_t source)
{
  channel->DXCR[input] = (uint32_t)((channel->DXCR[input] & (uint32_t)(~USIC_CH_DXCR_DSEL_Msk)) |
 8009596:	430a      	orrs	r2, r1
 8009598:	61da      	str	r2, [r3, #28]
								&(p_config_l->channel_cfg) );
			/* Set input source path, decides the mode of communication as well */
			XMC_USIC_CH_SetInputSource( (XMC_USIC_CH_t *)p_config_l->p_channel_context,
							p_config_l->channel_input, p_config_l->channel_input_source );
			/* Configure transmit FIFO */
			XMC_USIC_CH_TXFIFO_Configure( (XMC_USIC_CH_t *)p_config_l->p_channel_context,
 800959a:	6830      	ldr	r0, [r6, #0]
 800959c:	4651      	mov	r1, sl
 800959e:	7f32      	ldrb	r2, [r6, #28]
 80095a0:	2301      	movs	r3, #1
 80095a2:	f7f8 fb29 	bl	8001bf8 <XMC_USIC_CH_TXFIFO_Configure>
											fifo_size[0], p_config_l->fifo_cfg.tx_fifo_size, 1U );
			/* Configure receive FIFO */
			XMC_USIC_CH_RXFIFO_Configure( (XMC_USIC_CH_t *)p_config_l->p_channel_context, fifo_size[1],
 80095a6:	6830      	ldr	r0, [r6, #0]
 80095a8:	4649      	mov	r1, r9
 80095aa:	7f72      	ldrb	r2, [r6, #29]
 80095ac:	2301      	movs	r3, #1
 80095ae:	f7f8 fb39 	bl	8001c24 <XMC_USIC_CH_RXFIFO_Configure>
											p_config_l->fifo_cfg.rx_fifo_size, 1U );
			/* Start UART channel */
			XMC_UART_CH_Start( (XMC_USIC_CH_t *)p_config_l->p_channel_context );
 80095b2:	6832      	ldr	r2, [r6, #0]
 * \par<b>Related APIs:</b><BR>
 * XMC_UART_CH_Stop(), XMC_UART_CH_Transmit()\n\n\n
 */
__STATIC_INLINE void XMC_UART_CH_Start(XMC_USIC_CH_t *const channel)
{
  channel->CCR = (uint32_t)(((channel->CCR) & (~USIC_CH_CCR_MODE_Msk)) | (uint32_t)XMC_USIC_CH_OPERATING_MODE_UART);
 80095b4:	6c13      	ldr	r3, [r2, #64]	; 0x40
 80095b6:	f023 030f 	bic.w	r3, r3, #15
 80095ba:	f043 0302 	orr.w	r3, r3, #2
 80095be:	6413      	str	r3, [r2, #64]	; 0x40
								,2U
								#endif
								);
			#endif

			XMC_USIC_CH_TXFIFO_SetInterruptNodePointer( (XMC_USIC_CH_t *)p_config_l->p_channel_context,
 80095c0:	6830      	ldr	r0, [r6, #0]
 80095c2:	2110      	movs	r1, #16
 80095c4:	6932      	ldr	r2, [r6, #16]
 80095c6:	f7f8 fb57 	bl	8001c78 <XMC_USIC_CH_TXFIFO_SetInterruptNodePointer>
												XMC_USIC_CH_TXFIFO_INTERRUPT_NODE_POINTER_STANDARD,
												p_config_l->isr_config.tx_sr );

			/* Set service request for rx FIFO receive interrupt */
			XMC_USIC_CH_RXFIFO_SetInterruptNodePointer( (XMC_USIC_CH_t *)p_config_l->p_channel_context,
 80095ca:	6830      	ldr	r0, [r6, #0]
 80095cc:	2110      	movs	r1, #16
 80095ce:	6972      	ldr	r2, [r6, #20]
 80095d0:	f7f8 fb60 	bl	8001c94 <XMC_USIC_CH_RXFIFO_SetInterruptNodePointer>
												XMC_USIC_CH_RXFIFO_INTERRUPT_NODE_POINTER_STANDARD,
												(p_config_l->isr_config.rx_sr) );
			XMC_USIC_CH_RXFIFO_SetInterruptNodePointer( (XMC_USIC_CH_t *)p_config_l->p_channel_context,
 80095d4:	6830      	ldr	r0, [r6, #0]
 80095d6:	2113      	movs	r1, #19
 80095d8:	6972      	ldr	r2, [r6, #20]
 80095da:	f7f8 fb5b 	bl	8001c94 <XMC_USIC_CH_RXFIFO_SetInterruptNodePointer>
				NVIC_EnableIRQ( (IRQn_Type)p_config_l->isr_config.event_irq.irq_num );
			} else{ /* Not required */ }
			#endif	/* UART_PROTOCOL_EVENT_USED */

			/* Set priority and enable NVIC node for transmit interrupt */
			NVIC_SetPriority( (IRQn_Type)(p_config_l->isr_config.tx_irq.irq_num),
 80095de:	7e35      	ldrb	r5, [r6, #24]
 80095e0:	b2e8      	uxtb	r0, r5
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80095e2:	4b4e      	ldr	r3, [pc, #312]	; (800971c <UART_init+0x1f8>)
 80095e4:	68d9      	ldr	r1, [r3, #12]
								NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
								p_config_l->isr_config.tx_irq.irq_priority,
 80095e6:	7e73      	ldrb	r3, [r6, #25]
				NVIC_EnableIRQ( (IRQn_Type)p_config_l->isr_config.event_irq.irq_num );
			} else{ /* Not required */ }
			#endif	/* UART_PROTOCOL_EVENT_USED */

			/* Set priority and enable NVIC node for transmit interrupt */
			NVIC_SetPriority( (IRQn_Type)(p_config_l->isr_config.tx_irq.irq_num),
 80095e8:	f003 027f 	and.w	r2, r3, #127	; 0x7f
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 80095ec:	f3c1 2302 	ubfx	r3, r1, #8, #3
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80095f0:	f1c3 0707 	rsb	r7, r3, #7
 80095f4:	2f06      	cmp	r7, #6
 80095f6:	bf28      	it	cs
 80095f8:	2706      	movcs	r7, #6
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80095fa:	1d99      	adds	r1, r3, #6
 80095fc:	2906      	cmp	r1, #6
 80095fe:	bf8c      	ite	hi
 8009600:	f103 31ff 	addhi.w	r1, r3, #4294967295
 8009604:	2100      	movls	r1, #0

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8009606:	2301      	movs	r3, #1
 8009608:	40bb      	lsls	r3, r7
 800960a:	3b01      	subs	r3, #1
 800960c:	4013      	ands	r3, r2
 800960e:	408b      	lsls	r3, r1
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 8009610:	f010 0f80 	tst.w	r0, #128	; 0x80
 8009614:	d107      	bne.n	8009626 <UART_init+0x102>
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8009616:	009b      	lsls	r3, r3, #2
 8009618:	b2db      	uxtb	r3, r3
 800961a:	4a41      	ldr	r2, [pc, #260]	; (8009720 <UART_init+0x1fc>)
 800961c:	fa42 f080 	sxtab	r0, r2, r0
 8009620:	f880 3300 	strb.w	r3, [r0, #768]	; 0x300
 8009624:	e005      	b.n	8009632 <UART_init+0x10e>
  }
  else
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8009626:	f005 050f 	and.w	r5, r5, #15
 800962a:	009b      	lsls	r3, r3, #2
 800962c:	b2db      	uxtb	r3, r3
 800962e:	4a3d      	ldr	r2, [pc, #244]	; (8009724 <UART_init+0x200>)
 8009630:	5553      	strb	r3, [r2, r5]
								NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
								p_config_l->isr_config.tx_irq.irq_priority,
								0U) );
			NVIC_EnableIRQ( (IRQn_Type)(p_config_l->isr_config.tx_irq.irq_num) );
 8009632:	7e32      	ldrb	r2, [r6, #24]
 8009634:	b2d3      	uxtb	r3, r2
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
 8009636:	f013 0f80 	tst.w	r3, #128	; 0x80
 800963a:	d109      	bne.n	8009650 <UART_init+0x12c>
  {
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 800963c:	b25b      	sxtb	r3, r3
 800963e:	095b      	lsrs	r3, r3, #5
 8009640:	f002 021f 	and.w	r2, r2, #31
 8009644:	2101      	movs	r1, #1
 8009646:	fa01 f202 	lsl.w	r2, r1, r2
 800964a:	4935      	ldr	r1, [pc, #212]	; (8009720 <UART_init+0x1fc>)
 800964c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
			/* Set priority and enable NVIC node for receive interrupt */
			NVIC_SetPriority( (IRQn_Type)(p_config_l->isr_config.rx_irq.irq_num),
 8009650:	7eb5      	ldrb	r5, [r6, #26]
 8009652:	b2e8      	uxtb	r0, r5
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8009654:	4b31      	ldr	r3, [pc, #196]	; (800971c <UART_init+0x1f8>)
 8009656:	68d9      	ldr	r1, [r3, #12]
								NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
								p_config_l->isr_config.rx_irq.irq_priority,
 8009658:	7ef3      	ldrb	r3, [r6, #27]
								NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
								p_config_l->isr_config.tx_irq.irq_priority,
								0U) );
			NVIC_EnableIRQ( (IRQn_Type)(p_config_l->isr_config.tx_irq.irq_num) );
			/* Set priority and enable NVIC node for receive interrupt */
			NVIC_SetPriority( (IRQn_Type)(p_config_l->isr_config.rx_irq.irq_num),
 800965a:	f003 027f 	and.w	r2, r3, #127	; 0x7f
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 800965e:	f3c1 2302 	ubfx	r3, r1, #8, #3
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8009662:	f1c3 0707 	rsb	r7, r3, #7
 8009666:	2f06      	cmp	r7, #6
 8009668:	bf28      	it	cs
 800966a:	2706      	movcs	r7, #6
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800966c:	1d99      	adds	r1, r3, #6
 800966e:	2906      	cmp	r1, #6
 8009670:	bf8c      	ite	hi
 8009672:	f103 31ff 	addhi.w	r1, r3, #4294967295
 8009676:	2100      	movls	r1, #0

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8009678:	2301      	movs	r3, #1
 800967a:	40bb      	lsls	r3, r7
 800967c:	3b01      	subs	r3, #1
 800967e:	4013      	ands	r3, r2
 8009680:	408b      	lsls	r3, r1
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 8009682:	f010 0f80 	tst.w	r0, #128	; 0x80
 8009686:	d107      	bne.n	8009698 <UART_init+0x174>
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8009688:	009b      	lsls	r3, r3, #2
 800968a:	b2db      	uxtb	r3, r3
 800968c:	4a24      	ldr	r2, [pc, #144]	; (8009720 <UART_init+0x1fc>)
 800968e:	fa42 f080 	sxtab	r0, r2, r0
 8009692:	f880 3300 	strb.w	r3, [r0, #768]	; 0x300
 8009696:	e005      	b.n	80096a4 <UART_init+0x180>
  }
  else
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8009698:	f005 050f 	and.w	r5, r5, #15
 800969c:	009b      	lsls	r3, r3, #2
 800969e:	b2db      	uxtb	r3, r3
 80096a0:	4a20      	ldr	r2, [pc, #128]	; (8009724 <UART_init+0x200>)
 80096a2:	5553      	strb	r3, [r2, r5]
								NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
								p_config_l->isr_config.rx_irq.irq_priority,
								0U) );
			NVIC_EnableIRQ( (IRQn_Type)(p_config_l->isr_config.rx_irq.irq_num) );
 80096a4:	7eb2      	ldrb	r2, [r6, #26]
 80096a6:	b2d3      	uxtb	r3, r2
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
 80096a8:	f013 0f80 	tst.w	r3, #128	; 0x80
 80096ac:	d109      	bne.n	80096c2 <UART_init+0x19e>
  {
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80096ae:	b25b      	sxtb	r3, r3
 80096b0:	095b      	lsrs	r3, r3, #5
 80096b2:	f002 021f 	and.w	r2, r2, #31
 80096b6:	2101      	movs	r1, #1
 80096b8:	fa01 f202 	lsl.w	r2, r1, r2
 80096bc:	4918      	ldr	r1, [pc, #96]	; (8009720 <UART_init+0x1fc>)
 80096be:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

			/* Enable receive buffer event */
			reconfigure_rx_fifo( p_channel, 1 );
 80096c2:	4620      	mov	r0, r4
 80096c4:	2101      	movs	r1, #1
 80096c6:	f7ff ff1d 	bl	8009504 <reconfigure_rx_fifo>
			XMC_USIC_CH_RXFIFO_EnableEvent( (XMC_USIC_CH_t *)(p_config_l->p_channel_context),
 80096ca:	6832      	ldr	r2, [r6, #0]
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_RXFIFO_SetInterruptNodePointer() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_RXFIFO_EnableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
  channel->RBCTR |= event;
 80096cc:	f8d2 310c 	ldr.w	r3, [r2, #268]	; 0x10c
 80096d0:	f043 43c0 	orr.w	r3, r3, #1610612736	; 0x60000000
 80096d4:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
					(unsigned long) ((unsigned long) XMC_USIC_CH_RXFIFO_EVENT_CONF_STANDARD |
					(unsigned long)XMC_USIC_CH_RXFIFO_EVENT_CONF_ALTERNATE) );

			/* Set initialize state */
			p_control_l->state.state_value = 1;
 80096d8:	2301      	movs	r3, #1
 80096da:	f8c8 3018 	str.w	r3, [r8, #24]
			p_control_l->state.mode = 1;	/* Default mode is interrupt */
 80096de:	f8d8 3018 	ldr.w	r3, [r8, #24]
 80096e2:	f043 0320 	orr.w	r3, r3, #32
 80096e6:	f8c8 3018 	str.w	r3, [r8, #24]
			/* Update return status */
			ret_status = UART_STATUS_SUCCESS;
 80096ea:	2000      	movs	r0, #0
			break;
 80096ec:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		/* Close UART Channel */
		case UART_INIT_CLOSE:
			if( XMC_UART_CH_STATUS_BUSY == XMC_UART_CH_Stop( (XMC_USIC_CH_t *)p_config_l->p_channel_context )
 80096f0:	4638      	mov	r0, r7
 80096f2:	f7f8 f9e1 	bl	8001ab8 <XMC_UART_CH_Stop>
 80096f6:	2802      	cmp	r0, #2
 80096f8:	d00c      	beq.n	8009714 <UART_init+0x1f0>
				ret_status = UART_STATUS_BUSY;
			}
			else
			{
				/* Reset control state */
				p_control_l->state.state_value = 0;
 80096fa:	2000      	movs	r0, #0
 80096fc:	f8c8 0018 	str.w	r0, [r8, #24]
 8009700:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 * <i>Imp Note:</i>
 *
 */
long UART_init( void * p_channel, const unsigned char init )
{
	DRIVER_ASSERT( NULL == p_channel, UART_STATUS_INVALID_ARGUMENT );
 8009704:	2003      	movs	r0, #3
			break;
	}

	/* Return status */
	return ret_status;
}
 8009706:	4770      	bx	lr
			}
			break;
		/* Default case */
		default:
			/* Update return status */
			ret_status = UART_STATUS_INVALID_ARGUMENT;
 8009708:	2003      	movs	r0, #3
 800970a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	DRIVER_ASSERT( NULL == p_channel, UART_STATUS_INVALID_ARGUMENT );
	/* Local Variables */
	const tStUART_Configuartion * p_config_l = ((const tStUART_Channel *) p_channel)->p_config;
	tStUART_Control * p_control_l = ((tStUART_Channel*) p_channel)->p_control;

	long ret_status = UART_STATUS_FAILED;
 800970e:	2001      	movs	r0, #1
 8009710:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		case UART_INIT_CLOSE:
			if( XMC_UART_CH_STATUS_BUSY == XMC_UART_CH_Stop( (XMC_USIC_CH_t *)p_config_l->p_channel_context )
				)
			{
				/* Update return status */
				ret_status = UART_STATUS_BUSY;
 8009714:	2002      	movs	r0, #2
			break;
	}

	/* Return status */
	return ret_status;
}
 8009716:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800971a:	bf00      	nop
 800971c:	e000ed00 	.word	0xe000ed00
 8009720:	e000e100 	.word	0xe000e100
 8009724:	e000ed14 	.word	0xe000ed14

08009728 <UART_set_baud>:
 * <i>Imp Note:</i>
 *
 */
long UART_set_baud( void * p_channel, const unsigned long speed )
{
	DRIVER_ASSERT( NULL == p_channel, UART_STATUS_INVALID_ARGUMENT );
 8009728:	2800      	cmp	r0, #0
 800972a:	d038      	beq.n	800979e <UART_set_baud+0x76>
 *
 * <i>Imp Note:</i>
 *
 */
long UART_set_baud( void * p_channel, const unsigned long speed )
{
 800972c:	b538      	push	{r3, r4, r5, lr}
	DRIVER_ASSERT( NULL == p_channel, UART_STATUS_INVALID_ARGUMENT );
	/* Local Arguments */
	tStUART_Configuartion * p_config_l = ((tStUART_Channel*)p_channel)->p_config;
 800972e:	6805      	ldr	r5, [r0, #0]
	tStUART_Control * p_control_l = ((tStUART_Channel*) p_channel)->p_control;
 8009730:	6843      	ldr	r3, [r0, #4]
	unsigned char status = 1;
	eUART_Status ret_status = UART_STATUS_FAILED;

	/* Check input argument validity */
	switch( speed )
 8009732:	f5b1 5f16 	cmp.w	r1, #9600	; 0x2580
 8009736:	d010      	beq.n	800975a <UART_set_baud+0x32>
 8009738:	d806      	bhi.n	8009748 <UART_set_baud+0x20>
 800973a:	f5b1 6f96 	cmp.w	r1, #1200	; 0x4b0
 800973e:	d00c      	beq.n	800975a <UART_set_baud+0x32>
 8009740:	f5b1 5f96 	cmp.w	r1, #4800	; 0x12c0
 8009744:	d12d      	bne.n	80097a2 <UART_set_baud+0x7a>
 8009746:	e008      	b.n	800975a <UART_set_baud+0x32>
 8009748:	f5b1 4f16 	cmp.w	r1, #38400	; 0x9600
 800974c:	d005      	beq.n	800975a <UART_set_baud+0x32>
 800974e:	f5b1 3fe1 	cmp.w	r1, #115200	; 0x1c200
 8009752:	d002      	beq.n	800975a <UART_set_baud+0x32>
 8009754:	f5b1 4f96 	cmp.w	r1, #19200	; 0x4b00
 8009758:	d123      	bne.n	80097a2 <UART_set_baud+0x7a>
			/* Return status */
			return ret_status;
	}

	/* Check state of Tx and Rx locks */
	if( (1 == p_control_l->state.tx_lock) || (1 == p_control_l->state.rx_lock) ||
 800975a:	699a      	ldr	r2, [r3, #24]
 800975c:	f012 0f02 	tst.w	r2, #2
 8009760:	d113      	bne.n	800978a <UART_set_baud+0x62>
 8009762:	699a      	ldr	r2, [r3, #24]
 8009764:	f012 0f08 	tst.w	r2, #8
 8009768:	d111      	bne.n	800978e <UART_set_baud+0x66>
			(1 == p_control_l->state.tx_busy) || (1 == p_control_l->state.rx_busy)
 800976a:	699a      	ldr	r2, [r3, #24]
			/* Return status */
			return ret_status;
	}

	/* Check state of Tx and Rx locks */
	if( (1 == p_control_l->state.tx_lock) || (1 == p_control_l->state.rx_lock) ||
 800976c:	f012 0f04 	tst.w	r2, #4
 8009770:	d10f      	bne.n	8009792 <UART_set_baud+0x6a>
			(1 == p_control_l->state.tx_busy) || (1 == p_control_l->state.rx_busy)
 8009772:	699b      	ldr	r3, [r3, #24]
 8009774:	f013 0f10 	tst.w	r3, #16
 8009778:	d10d      	bne.n	8009796 <UART_set_baud+0x6e>
 800977a:	460c      	mov	r4, r1
		ret_status = UART_STATUS_BUSY;
	}
	else
	{
		/* Update speed */
		status = XMC_UART_CH_SetBaudrate( (XMC_USIC_CH_t *)(p_config_l->p_channel_context),
 800977c:	6828      	ldr	r0, [r5, #0]
 800977e:	7aea      	ldrb	r2, [r5, #11]
 8009780:	f7f8 f966 	bl	8001a50 <XMC_UART_CH_SetBaudrate>
											speed, p_config_l->channel_cfg.oversampling );
		/* Check operation status */
		if( XMC_UART_CH_STATUS_OK == status )
 8009784:	b948      	cbnz	r0, 800979a <UART_set_baud+0x72>
		{
			p_config_l->channel_cfg.baudrate  =speed;
 8009786:	606c      	str	r4, [r5, #4]
 8009788:	bd38      	pop	{r3, r4, r5, pc}
	/* Check state of Tx and Rx locks */
	if( (1 == p_control_l->state.tx_lock) || (1 == p_control_l->state.rx_lock) ||
			(1 == p_control_l->state.tx_busy) || (1 == p_control_l->state.rx_busy)
			)
	{
		ret_status = UART_STATUS_BUSY;
 800978a:	2002      	movs	r0, #2
 800978c:	bd38      	pop	{r3, r4, r5, pc}
 800978e:	2002      	movs	r0, #2
 8009790:	bd38      	pop	{r3, r4, r5, pc}
 8009792:	2002      	movs	r0, #2
 8009794:	bd38      	pop	{r3, r4, r5, pc}
 8009796:	2002      	movs	r0, #2
 8009798:	bd38      	pop	{r3, r4, r5, pc}
			p_config_l->channel_cfg.baudrate  =speed;
			ret_status = UART_STATUS_SUCCESS;
		}
		else
		{
			ret_status = UART_STATUS_FAILED;
 800979a:	2001      	movs	r0, #1
		}
	}

	/* Return status */
	return ret_status;
 800979c:	bd38      	pop	{r3, r4, r5, pc}
 * <i>Imp Note:</i>
 *
 */
long UART_set_baud( void * p_channel, const unsigned long speed )
{
	DRIVER_ASSERT( NULL == p_channel, UART_STATUS_INVALID_ARGUMENT );
 800979e:	2003      	movs	r0, #3
		}
	}

	/* Return status */
	return ret_status;
}
 80097a0:	4770      	bx	lr

		/* Invalid arguments */
		default:
			ret_status = UART_STATUS_INVALID_ARGUMENT;
			/* Return status */
			return ret_status;
 80097a2:	2003      	movs	r0, #3
		}
	}

	/* Return status */
	return ret_status;
}
 80097a4:	bd38      	pop	{r3, r4, r5, pc}
 80097a6:	bf00      	nop

080097a8 <UART_transmit>:
 *
 */
long UART_transmit( void * p_channel, const unsigned char * p_src, const unsigned long length )
{
	/* Input argument validity */
	DRIVER_ASSERT( NULL == p_src, UART_STATUS_INVALID_ARGUMENT );
 80097a8:	2900      	cmp	r1, #0
 80097aa:	d06c      	beq.n	8009886 <UART_transmit+0xde>
 *
 * <i>Imp Note:</i>
 *
 */
long UART_transmit( void * p_channel, const unsigned char * p_src, const unsigned long length )
{
 80097ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80097b0:	460c      	mov	r4, r1
	/* Input argument validity */
	DRIVER_ASSERT( NULL == p_src, UART_STATUS_INVALID_ARGUMENT );
	DRIVER_ASSERT( 0U == length, UART_STATUS_INVALID_ARGUMENT );
 80097b2:	2a00      	cmp	r2, #0
 80097b4:	d069      	beq.n	800988a <UART_transmit+0xe2>
	/* Local Arguments */
	tStUART_Configuartion * p_config_l = ((tStUART_Channel*)p_channel)->p_config;
 80097b6:	6805      	ldr	r5, [r0, #0]
	tStUART_Control * p_control_l = ((tStUART_Channel*) p_channel)->p_control;
 80097b8:	6846      	ldr	r6, [r0, #4]

	/* Local Arguments */
	eUART_Status ret_status = UART_STATUS_FAILED;
	DRIVER_ASSERT( 0U == p_control_l->state.init, UART_STATUS_NOT_INITIALIZED );
 80097ba:	69b3      	ldr	r3, [r6, #24]
 80097bc:	f013 0f01 	tst.w	r3, #1
 80097c0:	d066      	beq.n	8009890 <UART_transmit+0xe8>


	/* Check mode of UART, Direct or Interrupt */
	switch( p_control_l->state.mode )
 80097c2:	69b3      	ldr	r3, [r6, #24]
 80097c4:	f013 0f20 	tst.w	r3, #32
 80097c8:	d131      	bne.n	800982e <UART_transmit+0x86>
	tStUART_Control * p_control_l = ((tStUART_Channel*) p_channel)->p_control;
	unsigned long count_l = 0;
	eUART_Status ret_status = UART_STATUS_SUCCESS;

	/* Wait for current transfer to complete */
	while( 1 == p_control_l->state.tx_busy );
 80097ca:	69b3      	ldr	r3, [r6, #24]
 80097cc:	f013 0f04 	tst.w	r3, #4
 80097d0:	d1fb      	bne.n	80097ca <UART_transmit+0x22>
	p_control_l->state.tx_busy = 1;
 80097d2:	69b3      	ldr	r3, [r6, #24]
 80097d4:	f043 0304 	orr.w	r3, r3, #4
 80097d8:	61b3      	str	r3, [r6, #24]

	/* Check FIFO usage */
	if( p_config_l->fifo_cfg.tx_fifo_size != XMC_USIC_CH_FIFO_DISABLED )
 80097da:	7f2b      	ldrb	r3, [r5, #28]
 80097dc:	b1bb      	cbz	r3, 800980e <UART_transmit+0x66>
	{
		XMC_USIC_CH_TXFIFO_Flush( (XMC_USIC_CH_t *)(p_config_l->p_channel_context) );
 80097de:	682b      	ldr	r3, [r5, #0]
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_GetLevel() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_TXFIFO_Flush(XMC_USIC_CH_t *const channel)
{
  channel->TRBSCR = (uint32_t)USIC_CH_TRBSCR_FLUSHTB_Msk;
 80097e0:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 80097e4:	f8c3 1118 	str.w	r1, [r3, #280]	; 0x118
 80097e8:	4627      	mov	r7, r4
 80097ea:	4414      	add	r4, r2
 80097ec:	4688      	mov	r8, r1
		for( count_l = 0; count_l < length; ++count_l )
		{
			XMC_UART_CH_Transmit( (XMC_USIC_CH_t *)(p_config_l->p_channel_context), p_src[count_l] );
 80097ee:	6828      	ldr	r0, [r5, #0]
 80097f0:	f817 1b01 	ldrb.w	r1, [r7], #1
 80097f4:	f7f8 f944 	bl	8001a80 <XMC_UART_CH_Transmit>
			if( 1 == XMC_USIC_CH_TXFIFO_IsFull( (XMC_USIC_CH_t *const)p_config_l->p_channel_context ) )
 80097f8:	682b      	ldr	r3, [r5, #0]
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_IsEmpty(), XMC_USIC_CH_TXFIFO_Flush() \n\n\n
 */
__STATIC_INLINE bool XMC_USIC_CH_TXFIFO_IsFull(XMC_USIC_CH_t *const channel)
{
  return (bool)(channel->TRBSR & USIC_CH_TRBSR_TFULL_Msk);
 80097fa:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
 80097fe:	f412 5f80 	tst.w	r2, #4096	; 0x1000
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_GetLevel() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_TXFIFO_Flush(XMC_USIC_CH_t *const channel)
{
  channel->TRBSCR = (uint32_t)USIC_CH_TRBSCR_FLUSHTB_Msk;
 8009802:	bf18      	it	ne
 8009804:	f8c3 8118 	strne.w	r8, [r3, #280]	; 0x118

	/* Check FIFO usage */
	if( p_config_l->fifo_cfg.tx_fifo_size != XMC_USIC_CH_FIFO_DISABLED )
	{
		XMC_USIC_CH_TXFIFO_Flush( (XMC_USIC_CH_t *)(p_config_l->p_channel_context) );
		for( count_l = 0; count_l < length; ++count_l )
 8009808:	42a7      	cmp	r7, r4
 800980a:	d1f0      	bne.n	80097ee <UART_transmit+0x46>
 800980c:	e008      	b.n	8009820 <UART_transmit+0x78>
 800980e:	4627      	mov	r7, r4
 8009810:	4414      	add	r4, r2
	}
	else
	{
		for( count_l = 0; count_l < length; ++count_l )
		{
			XMC_UART_CH_Transmit( (XMC_USIC_CH_t *)(p_config_l->p_channel_context), p_src[count_l] );
 8009812:	6828      	ldr	r0, [r5, #0]
 8009814:	f817 1b01 	ldrb.w	r1, [r7], #1
 8009818:	f7f8 f932 	bl	8001a80 <XMC_UART_CH_Transmit>
			}
		}
	}
	else
	{
		for( count_l = 0; count_l < length; ++count_l )
 800981c:	42a7      	cmp	r7, r4
 800981e:	d1f8      	bne.n	8009812 <UART_transmit+0x6a>
		{
			XMC_UART_CH_Transmit( (XMC_USIC_CH_t *)(p_config_l->p_channel_context), p_src[count_l] );
		}
	}
	/* Update transfer parameters */
	p_control_l->state.tx_busy = 0;
 8009820:	69b3      	ldr	r3, [r6, #24]
 8009822:	f023 0304 	bic.w	r3, r3, #4
 8009826:	61b3      	str	r3, [r6, #24]
	/* Check mode of UART, Direct or Interrupt */
	switch( p_control_l->state.mode )
	{
	default:
		case UART_MODE_DIRECT:
			ret_status = UART_tx_direct( p_channel, p_src, length );
 8009828:	2000      	movs	r0, #0
		break;
 800982a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

		case UART_MODE_INTERRUPT:
			/* Check transmit busy status and perform operation */
			if( 0 == p_control_l->state.tx_busy )
 800982e:	69b3      	ldr	r3, [r6, #24]
 8009830:	f013 0f04 	tst.w	r3, #4
 8009834:	d124      	bne.n	8009880 <UART_transmit+0xd8>
			{
				/* Update required parameters for transmission interrupt */
				p_control_l->p_tx_data = (unsigned char *)p_src;
 8009836:	6031      	str	r1, [r6, #0]
				p_control_l->tx_data_count = length;
 8009838:	60b2      	str	r2, [r6, #8]
				p_control_l->tx_data_index = 0;
 800983a:	2300      	movs	r3, #0
 800983c:	60f3      	str	r3, [r6, #12]
				p_control_l->state.tx_busy = 1;
 800983e:	69b3      	ldr	r3, [r6, #24]
 8009840:	f043 0304 	orr.w	r3, r3, #4
 8009844:	61b3      	str	r3, [r6, #24]

				/* Trigger transmission interrupt */
				if( p_config_l->fifo_cfg.tx_fifo_size != XMC_USIC_CH_FIFO_DISABLED )
 8009846:	7f2b      	ldrb	r3, [r5, #28]
 8009848:	b163      	cbz	r3, 8009864 <UART_transmit+0xbc>
				{
					/* Clear transmit FIFO */
					XMC_USIC_CH_TXFIFO_Flush( (XMC_USIC_CH_t *)(p_config_l->p_channel_context) );
 800984a:	682b      	ldr	r3, [r5, #0]
 800984c:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8009850:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
					/* Enable transmit buffer event */
					XMC_USIC_CH_TXFIFO_EnableEvent( (XMC_USIC_CH_t *)(p_config_l->p_channel_context),
 8009854:	682a      	ldr	r2, [r5, #0]
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_SetInterruptNodePointer() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_TXFIFO_EnableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
  channel->TBCTR |= event;
 8009856:	f8d2 3108 	ldr.w	r3, [r2, #264]	; 0x108
 800985a:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 800985e:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
 8009862:	e004      	b.n	800986e <UART_transmit+0xc6>
												(unsigned long) XMC_USIC_CH_TXFIFO_EVENT_CONF_STANDARD );
				}
				else
				{
					/* Enable transmit buffer event */
					XMC_USIC_CH_EnableEvent( (XMC_USIC_CH_t *)(p_config_l->p_channel_context),
 8009864:	682a      	ldr	r2, [r5, #0]
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_DisableEvent(), XMC_USIC_CH_SetInterruptNodePointer() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_EnableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
  channel->CCR |= event;
 8009866:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8009868:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800986c:	6413      	str	r3, [r2, #64]	; 0x40
											(unsigned long) XMC_USIC_CH_EVENT_TRANSMIT_BUFFER );
				}
				/* Trigger the transmit buffer interrupt */
				XMC_USIC_CH_TriggerServiceRequest( (XMC_USIC_CH_t *)(p_config_l->p_channel_context),
 800986e:	682a      	ldr	r2, [r5, #0]
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_SetInterruptNodePointer() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_TriggerServiceRequest(XMC_USIC_CH_t *const channel, const uint32_t service_request_line)
{
  channel->FMR = (uint32_t)(USIC_CH_FMR_SIO0_Msk << service_request_line);
 8009870:	6929      	ldr	r1, [r5, #16]
 8009872:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8009876:	408b      	lsls	r3, r1
 8009878:	6693      	str	r3, [r2, #104]	; 0x68
												(unsigned long)p_config_l->isr_config.tx_sr );
				/* Update status */
				ret_status = UART_STATUS_SUCCESS;
 800987a:	2000      	movs	r0, #0
 800987c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			}
			else
			{
				ret_status = UART_STATUS_BUSY;
 8009880:	2002      	movs	r0, #2
			}
		break;
	}

	/* Return status */
	return ret_status;
 8009882:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 *
 */
long UART_transmit( void * p_channel, const unsigned char * p_src, const unsigned long length )
{
	/* Input argument validity */
	DRIVER_ASSERT( NULL == p_src, UART_STATUS_INVALID_ARGUMENT );
 8009886:	2003      	movs	r0, #3
		break;
	}

	/* Return status */
	return ret_status;
}
 8009888:	4770      	bx	lr
 */
long UART_transmit( void * p_channel, const unsigned char * p_src, const unsigned long length )
{
	/* Input argument validity */
	DRIVER_ASSERT( NULL == p_src, UART_STATUS_INVALID_ARGUMENT );
	DRIVER_ASSERT( 0U == length, UART_STATUS_INVALID_ARGUMENT );
 800988a:	2003      	movs	r0, #3
 800988c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	tStUART_Configuartion * p_config_l = ((tStUART_Channel*)p_channel)->p_config;
	tStUART_Control * p_control_l = ((tStUART_Channel*) p_channel)->p_control;

	/* Local Arguments */
	eUART_Status ret_status = UART_STATUS_FAILED;
	DRIVER_ASSERT( 0U == p_control_l->state.init, UART_STATUS_NOT_INITIALIZED );
 8009890:	2005      	movs	r0, #5
		break;
	}

	/* Return status */
	return ret_status;
}
 8009892:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8009896:	bf00      	nop

08009898 <UART_receive>:
 *
 */
long UART_receive( void * p_channel, unsigned char * const p_dest, const unsigned long length )
{
	/* Input argument validity */
	DRIVER_ASSERT( NULL == p_dest, UART_STATUS_INVALID_ARGUMENT );
 8009898:	2900      	cmp	r1, #0
 800989a:	f000 8097 	beq.w	80099cc <UART_receive+0x134>
 *
 * <i>Imp Note:</i>
 *
 */
long UART_receive( void * p_channel, unsigned char * const p_dest, const unsigned long length )
{
 800989e:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80098a2:	460b      	mov	r3, r1
	/* Input argument validity */
	DRIVER_ASSERT( NULL == p_dest, UART_STATUS_INVALID_ARGUMENT );
	DRIVER_ASSERT( 0U == length, UART_STATUS_INVALID_ARGUMENT );
 80098a4:	2a00      	cmp	r2, #0
 80098a6:	f000 8093 	beq.w	80099d0 <UART_receive+0x138>
	/* Local Arguments */
	tStUART_Configuartion * p_config_l = ((tStUART_Channel*)p_channel)->p_config;
 80098aa:	6807      	ldr	r7, [r0, #0]
	tStUART_Control * p_control_l = ((tStUART_Channel*) p_channel)->p_control;
 80098ac:	6846      	ldr	r6, [r0, #4]

	/* Local Arguments */
	eUART_Status ret_status = UART_STATUS_FAILED;
	DRIVER_ASSERT( 0U == p_control_l->state.init, UART_STATUS_NOT_INITIALIZED );
 80098ae:	69b1      	ldr	r1, [r6, #24]
 80098b0:	f011 0f01 	tst.w	r1, #1
 80098b4:	f000 808f 	beq.w	80099d6 <UART_receive+0x13e>
 80098b8:	4698      	mov	r8, r3
 80098ba:	4614      	mov	r4, r2
 80098bc:	4605      	mov	r5, r0

	switch( p_control_l->state.mode )
 80098be:	69b3      	ldr	r3, [r6, #24]
 80098c0:	f013 0f20 	tst.w	r3, #32
 80098c4:	d149      	bne.n	800995a <UART_receive+0xc2>
	tStUART_Control * p_control_l = ((tStUART_Channel*) p_channel)->p_control;
	unsigned long count_l = 0;
	eUART_Status ret_status = UART_STATUS_SUCCESS;

	/* Wait for current transfer to complete */
	while( (1 == p_control_l->state.rx_busy) && (1 == p_control_l->state.rx_lock) );
 80098c6:	69b3      	ldr	r3, [r6, #24]
 80098c8:	f013 0f10 	tst.w	r3, #16
 80098cc:	f000 8086 	beq.w	80099dc <UART_receive+0x144>
 80098d0:	69b3      	ldr	r3, [r6, #24]
 80098d2:	f013 0f08 	tst.w	r3, #8
 80098d6:	d1f6      	bne.n	80098c6 <UART_receive+0x2e>
	p_control_l->state.rx_busy = 1;
 80098d8:	69b3      	ldr	r3, [r6, #24]
 80098da:	f043 0310 	orr.w	r3, r3, #16
 80098de:	61b3      	str	r3, [r6, #24]
	p_control_l->state.rx_lock = 1;
 80098e0:	69b3      	ldr	r3, [r6, #24]
 80098e2:	f043 0308 	orr.w	r3, r3, #8
 80098e6:	61b3      	str	r3, [r6, #24]

	/* Receive data directly */
	if( p_config_l->fifo_cfg.rx_fifo_size != XMC_USIC_CH_FIFO_DISABLED )
 80098e8:	7f7b      	ldrb	r3, [r7, #29]
 80098ea:	b913      	cbnz	r3, 80098f2 <UART_receive+0x5a>
 80098ec:	4645      	mov	r5, r8
 80098ee:	4444      	add	r4, r8
 80098f0:	e01d      	b.n	800992e <UART_receive+0x96>
 *
 * <i>Imp Note:</i>
 *
 */
long UART_receive( void * p_channel, unsigned char * const p_dest, const unsigned long length )
{
 80098f2:	f04f 0900 	mov.w	r9, #0
	if( p_config_l->fifo_cfg.rx_fifo_size != XMC_USIC_CH_FIFO_DISABLED )
	{
		for( count_l = 0; count_l < length; ++count_l )
		{
			/* Check if FIFO is empty or not */
			if( 0 == XMC_USIC_CH_RXFIFO_IsEmpty( (XMC_USIC_CH_t *const)p_config_l->p_channel_context ) )
 80098f6:	6838      	ldr	r0, [r7, #0]
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_RXFIFO_Flush(), XMC_USIC_CH_RXFIFO_PutData() \n\n\n
 */
__STATIC_INLINE bool XMC_USIC_CH_RXFIFO_IsEmpty(XMC_USIC_CH_t *const channel)
{
  return (bool)(channel->TRBSR & USIC_CH_TRBSR_REMPTY_Msk);
 80098f8:	f8d0 3114 	ldr.w	r3, [r0, #276]	; 0x114
 80098fc:	f013 0f08 	tst.w	r3, #8
 8009900:	d104      	bne.n	800990c <UART_receive+0x74>
			{
				p_dest[count_l] = (unsigned char)XMC_UART_CH_GetReceivedData( (XMC_USIC_CH_t *const)p_config_l->p_channel_context );
 8009902:	f7f8 f8cf 	bl	8001aa4 <XMC_UART_CH_GetReceivedData>
 8009906:	f808 0009 	strb.w	r0, [r8, r9]
 800990a:	e00b      	b.n	8009924 <UART_receive+0x8c>
 800990c:	f8d0 3114 	ldr.w	r3, [r0, #276]	; 0x114
			}
			else if( 1 == XMC_USIC_CH_RXFIFO_IsEmpty( (XMC_USIC_CH_t *const)p_config_l->p_channel_context ) )
 8009910:	f013 0f08 	tst.w	r3, #8
 8009914:	d006      	beq.n	8009924 <UART_receive+0x8c>
			{
				/* Dynamically setup the trigger limit for FIFO */
				if( count_l < length )
 8009916:	454c      	cmp	r4, r9
 8009918:	d904      	bls.n	8009924 <UART_receive+0x8c>
				{
					reconfigure_rx_fifo( p_channel, (length - count_l) );
 800991a:	4628      	mov	r0, r5
 800991c:	ebc9 0104 	rsb	r1, r9, r4
 8009920:	f7ff fdf0 	bl	8009504 <reconfigure_rx_fifo>
	p_control_l->state.rx_lock = 1;

	/* Receive data directly */
	if( p_config_l->fifo_cfg.rx_fifo_size != XMC_USIC_CH_FIFO_DISABLED )
	{
		for( count_l = 0; count_l < length; ++count_l )
 8009924:	f109 0901 	add.w	r9, r9, #1
 8009928:	45a1      	cmp	r9, r4
 800992a:	d1e4      	bne.n	80098f6 <UART_receive+0x5e>
 800992c:	e00a      	b.n	8009944 <UART_receive+0xac>
	else
	{
		for( count_l = 0; count_l < length; ++count_l )
		{
			/* Wait to receive data */
			while( 0 == (XMC_UART_CH_GetStatusFlag( (XMC_USIC_CH_t *)(p_config_l->p_channel_context) ) & ((1<<14) | (1<<15)) ) );
 800992e:	6838      	ldr	r0, [r7, #0]
 * \par<b>Related APIs:</b><BR>
 * XMC_UART_CH_EnableEvent(),  XMC_UART_CH_ClearStatusFlag()\n\n\n
 */
__STATIC_INLINE uint32_t XMC_UART_CH_GetStatusFlag(XMC_USIC_CH_t *const channel)
{
  return channel->PSR_ASCMode;
 8009930:	6c83      	ldr	r3, [r0, #72]	; 0x48
 8009932:	f413 4f40 	tst.w	r3, #49152	; 0xc000
 8009936:	d0fb      	beq.n	8009930 <UART_receive+0x98>
			p_dest[count_l] = (unsigned char)XMC_UART_CH_GetReceivedData( (XMC_USIC_CH_t *)(p_config_l->p_channel_context) );
 8009938:	f7f8 f8b4 	bl	8001aa4 <XMC_UART_CH_GetReceivedData>
 800993c:	f805 0b01 	strb.w	r0, [r5], #1
			} else { /* Not needed */ }
		}
	}
	else
	{
		for( count_l = 0; count_l < length; ++count_l )
 8009940:	42a5      	cmp	r5, r4
 8009942:	d1f4      	bne.n	800992e <UART_receive+0x96>
			p_dest[count_l] = (unsigned char)XMC_UART_CH_GetReceivedData( (XMC_USIC_CH_t *)(p_config_l->p_channel_context) );
		}
	}

	/* Update transfer parameters */
	p_control_l->state.rx_busy = 0;
 8009944:	69b3      	ldr	r3, [r6, #24]
 8009946:	f023 0310 	bic.w	r3, r3, #16
 800994a:	61b3      	str	r3, [r6, #24]
	p_control_l->state.rx_lock = 0;
 800994c:	69b3      	ldr	r3, [r6, #24]
 800994e:	f023 0308 	bic.w	r3, r3, #8
 8009952:	61b3      	str	r3, [r6, #24]

	switch( p_control_l->state.mode )
	{
	default:
		case UART_MODE_DIRECT:
			ret_status = UART_rx_direct( p_channel, p_dest, length );
 8009954:	2000      	movs	r0, #0
		break;
 8009956:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

		case UART_MODE_INTERRUPT:
			/* Check receive busy status and perform operation */
			if( (0 == p_control_l->state.rx_busy) && (0 == p_control_l->state.rx_lock) )/* 0x18 == (p_control_l->state.state_value & 0x18) */
 800995a:	69b3      	ldr	r3, [r6, #24]
 800995c:	f013 0f10 	tst.w	r3, #16
 8009960:	d12e      	bne.n	80099c0 <UART_receive+0x128>
 8009962:	69b3      	ldr	r3, [r6, #24]
 8009964:	f013 0f08 	tst.w	r3, #8
 8009968:	d12d      	bne.n	80099c6 <UART_receive+0x12e>
			{
				/* Update receiver parameters */
				p_control_l->p_rx_data = p_dest;
 800996a:	f8c6 8004 	str.w	r8, [r6, #4]
				p_control_l->rx_data_count = length;
 800996e:	6132      	str	r2, [r6, #16]
				p_control_l->rx_data_index = 0;
 8009970:	2300      	movs	r3, #0
 8009972:	6173      	str	r3, [r6, #20]
				p_control_l->state.rx_busy = 1;
 8009974:	69b3      	ldr	r3, [r6, #24]
 8009976:	f043 0310 	orr.w	r3, r3, #16
 800997a:	61b3      	str	r3, [r6, #24]
				p_control_l->state.rx_lock = 1;
 800997c:	69b3      	ldr	r3, [r6, #24]
 800997e:	f043 0308 	orr.w	r3, r3, #8
 8009982:	61b3      	str	r3, [r6, #24]

				/* Check FIFO configuration and trigger event */
				if( p_config_l->fifo_cfg.rx_fifo_size != XMC_USIC_CH_FIFO_DISABLED )
 8009984:	7f7b      	ldrb	r3, [r7, #29]
 8009986:	b18b      	cbz	r3, 80099ac <UART_receive+0x114>
				{
					/* Clear receiver FIFO */
					XMC_USIC_CH_RXFIFO_Flush( (XMC_USIC_CH_t *)(p_config_l->p_channel_context) );
 8009988:	683b      	ldr	r3, [r7, #0]
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_RXFIFO_GetLevel() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_RXFIFO_Flush(XMC_USIC_CH_t *const channel)
{
  channel->TRBSCR = (uint32_t)USIC_CH_TRBSCR_FLUSHRB_Msk;
 800998a:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 800998e:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118

					/* Reconfigure FIFO for current data size */
					reconfigure_rx_fifo( p_channel, p_control_l->rx_data_count );
 8009992:	6931      	ldr	r1, [r6, #16]
 8009994:	f7ff fdb6 	bl	8009504 <reconfigure_rx_fifo>

					/* Enable receive buffer event */
					XMC_USIC_CH_RXFIFO_EnableEvent( (XMC_USIC_CH_t *)(p_config_l->p_channel_context),
 8009998:	683a      	ldr	r2, [r7, #0]
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_RXFIFO_SetInterruptNodePointer() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_RXFIFO_EnableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
  channel->RBCTR |= event;
 800999a:	f8d2 310c 	ldr.w	r3, [r2, #268]	; 0x10c
 800999e:	f043 43c0 	orr.w	r3, r3, #1610612736	; 0x60000000
 80099a2:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
					XMC_USIC_CH_RXFIFO_EnableEvent( (XMC_USIC_CH_t *)(p_config_l->p_channel_context),
								(unsigned long) ((unsigned long) XMC_USIC_CH_EVENT_STANDARD_RECEIVE |
								(unsigned long) XMC_USIC_CH_EVENT_ALTERNATIVE_RECEIVE) );
				}
				/* Update status */
				ret_status = UART_STATUS_SUCCESS;
 80099a6:	2000      	movs	r0, #0
 80099a8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
								(unsigned long) ((unsigned long) XMC_USIC_CH_RXFIFO_EVENT_CONF_STANDARD |
								(unsigned long)XMC_USIC_CH_RXFIFO_EVENT_CONF_ALTERNATE) );
				}
				else
				{/* Enable receive buffer event */
					XMC_USIC_CH_RXFIFO_EnableEvent( (XMC_USIC_CH_t *)(p_config_l->p_channel_context),
 80099ac:	683a      	ldr	r2, [r7, #0]
 80099ae:	f8d2 310c 	ldr.w	r3, [r2, #268]	; 0x10c
 80099b2:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 80099b6:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
								(unsigned long) ((unsigned long) XMC_USIC_CH_EVENT_STANDARD_RECEIVE |
								(unsigned long) XMC_USIC_CH_EVENT_ALTERNATIVE_RECEIVE) );
				}
				/* Update status */
				ret_status = UART_STATUS_SUCCESS;
 80099ba:	2000      	movs	r0, #0
 80099bc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			}
			else
			{
				ret_status = UART_STATUS_BUSY;
 80099c0:	2002      	movs	r0, #2
 80099c2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80099c6:	2002      	movs	r0, #2
			}
		break;
	}

	/* Return status */
	return ret_status;
 80099c8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 *
 */
long UART_receive( void * p_channel, unsigned char * const p_dest, const unsigned long length )
{
	/* Input argument validity */
	DRIVER_ASSERT( NULL == p_dest, UART_STATUS_INVALID_ARGUMENT );
 80099cc:	2003      	movs	r0, #3
		break;
	}

	/* Return status */
	return ret_status;
}
 80099ce:	4770      	bx	lr
 */
long UART_receive( void * p_channel, unsigned char * const p_dest, const unsigned long length )
{
	/* Input argument validity */
	DRIVER_ASSERT( NULL == p_dest, UART_STATUS_INVALID_ARGUMENT );
	DRIVER_ASSERT( 0U == length, UART_STATUS_INVALID_ARGUMENT );
 80099d0:	2003      	movs	r0, #3
 80099d2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	tStUART_Configuartion * p_config_l = ((tStUART_Channel*)p_channel)->p_config;
	tStUART_Control * p_control_l = ((tStUART_Channel*) p_channel)->p_control;

	/* Local Arguments */
	eUART_Status ret_status = UART_STATUS_FAILED;
	DRIVER_ASSERT( 0U == p_control_l->state.init, UART_STATUS_NOT_INITIALIZED );
 80099d6:	2005      	movs	r0, #5
 80099d8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	unsigned long count_l = 0;
	eUART_Status ret_status = UART_STATUS_SUCCESS;

	/* Wait for current transfer to complete */
	while( (1 == p_control_l->state.rx_busy) && (1 == p_control_l->state.rx_lock) );
	p_control_l->state.rx_busy = 1;
 80099dc:	69b3      	ldr	r3, [r6, #24]
 80099de:	f043 0310 	orr.w	r3, r3, #16
 80099e2:	61b3      	str	r3, [r6, #24]
	p_control_l->state.rx_lock = 1;
 80099e4:	69b3      	ldr	r3, [r6, #24]
 80099e6:	f043 0308 	orr.w	r3, r3, #8
 80099ea:	61b3      	str	r3, [r6, #24]

	/* Receive data directly */
	if( p_config_l->fifo_cfg.rx_fifo_size != XMC_USIC_CH_FIFO_DISABLED )
 80099ec:	7f7b      	ldrb	r3, [r7, #29]
 80099ee:	2b00      	cmp	r3, #0
 80099f0:	f47f af7f 	bne.w	80098f2 <UART_receive+0x5a>
 80099f4:	e77a      	b.n	80098ec <UART_receive+0x54>
 80099f6:	bf00      	nop

080099f8 <UART_abort>:
 *
 */
long UART_abort( void * p_channel, const unsigned char tx_rx )
{
	/* Input argument validity */
	DRIVER_ASSERT( NULL == p_channel, UART_STATUS_INVALID_ARGUMENT );
 80099f8:	2800      	cmp	r0, #0
 80099fa:	d078      	beq.n	8009aee <UART_abort+0xf6>
 *
 * <i>Imp Note:</i>
 *
 */
long UART_abort( void * p_channel, const unsigned char tx_rx )
{
 80099fc:	b508      	push	{r3, lr}
 80099fe:	4603      	mov	r3, r0
	/* Input argument validity */
	DRIVER_ASSERT( NULL == p_channel, UART_STATUS_INVALID_ARGUMENT );
	/* Local Arguments */
	tStUART_Configuartion * p_config_l = ((tStUART_Channel*)p_channel)->p_config;
 8009a00:	6800      	ldr	r0, [r0, #0]
	tStUART_Control * p_control_l = ((tStUART_Channel*) p_channel)->p_control;
 8009a02:	685b      	ldr	r3, [r3, #4]
	eUART_Status ret_status = UART_STATUS_FAILED;
	DRIVER_ASSERT( 0U == p_control_l->state.init, UART_STATUS_NOT_INITIALIZED );
 8009a04:	699a      	ldr	r2, [r3, #24]
 8009a06:	f012 0f01 	tst.w	r2, #1
 8009a0a:	d072      	beq.n	8009af2 <UART_abort+0xfa>

	/* Check the abort request */
	switch( tx_rx )
 8009a0c:	2901      	cmp	r1, #1
 8009a0e:	d022      	beq.n	8009a56 <UART_abort+0x5e>
 8009a10:	b111      	cbz	r1, 8009a18 <UART_abort+0x20>
 8009a12:	2902      	cmp	r1, #2
 8009a14:	d037      	beq.n	8009a86 <UART_abort+0x8e>
 8009a16:	e06e      	b.n	8009af6 <UART_abort+0xfe>
	{
		case UART_ABORT_TX:
			/* Reset Transmitter Parameters */
			p_control_l->state.tx_busy = 0;
 8009a18:	699a      	ldr	r2, [r3, #24]
 8009a1a:	f022 0204 	bic.w	r2, r2, #4
 8009a1e:	619a      	str	r2, [r3, #24]
			p_control_l->p_tx_data = NULL;
 8009a20:	2200      	movs	r2, #0
 8009a22:	601a      	str	r2, [r3, #0]

			/* Disable the transmitter events */
			if( p_config_l->fifo_cfg.rx_fifo_size != XMC_USIC_CH_FIFO_DISABLED )
 8009a24:	7f43      	ldrb	r3, [r0, #29]
 8009a26:	b163      	cbz	r3, 8009a42 <UART_abort+0x4a>
			{
			      /* Disable the transmit FIFO event */
			      XMC_USIC_CH_TXFIFO_DisableEvent( (XMC_USIC_CH_t *)(p_config_l->p_channel_context),
 8009a28:	6802      	ldr	r2, [r0, #0]
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_GetEvent(), XMC_USIC_CH_TXFIFO_EnableEvent() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_TXFIFO_DisableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
  channel->TBCTR &= (uint32_t)~event;
 8009a2a:	f8d2 3108 	ldr.w	r3, [r2, #264]	; 0x108
 8009a2e:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 8009a32:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
			    		  	  	  	  	  (unsigned long) XMC_USIC_CH_TXFIFO_EVENT_CONF_STANDARD );
			      XMC_USIC_CH_TXFIFO_Flush( (XMC_USIC_CH_t *)(p_config_l->p_channel_context) );
 8009a36:	6803      	ldr	r3, [r0, #0]
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_GetLevel() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_TXFIFO_Flush(XMC_USIC_CH_t *const channel)
{
  channel->TRBSCR = (uint32_t)USIC_CH_TRBSCR_FLUSHTB_Msk;
 8009a38:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8009a3c:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
 8009a40:	e004      	b.n	8009a4c <UART_abort+0x54>
			}
			else
			{
			      /*Disable the standard transmit event*/
			      XMC_USIC_CH_DisableEvent( (XMC_USIC_CH_t *)(p_config_l->p_channel_context),
 8009a42:	6802      	ldr	r2, [r0, #0]
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_EnableEvent(), XMC_USIC_CH_SetInterruptNodePointer() \n\n\n
*/
__STATIC_INLINE void XMC_USIC_CH_DisableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
  channel->CCR &= (uint32_t)~event;
 8009a44:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8009a46:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8009a4a:	6413      	str	r3, [r2, #64]	; 0x40
			    		  	  	  	  (unsigned long) XMC_USIC_CH_EVENT_TRANSMIT_BUFFER );
			}
			XMC_USIC_CH_SetTransmitBufferStatus( (XMC_USIC_CH_t *)(p_config_l->p_channel_context),
 8009a4c:	6803      	ldr	r3, [r0, #0]
 * XMC_USIC_CH_GetTransmitBufferStatus() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_SetTransmitBufferStatus(XMC_USIC_CH_t *const channel,
		                                                 const XMC_USIC_CH_TBUF_STATUS_SET_t transmit_buffer_status)
{
  channel->FMR = (uint32_t)transmit_buffer_status;
 8009a4e:	2202      	movs	r2, #2
 8009a50:	669a      	str	r2, [r3, #104]	; 0x68
			/* Return with Failed status */
			break;
	}

	/* Return status */
	return ret_status;
 8009a52:	2001      	movs	r0, #1
 8009a54:	bd08      	pop	{r3, pc}
													XMC_USIC_CH_TBUF_STATUS_SET_IDLE );
		break;

		case UART_ABORT_RX:
			/* Reset Receiver Parameters */
			p_control_l->state.rx_busy = 0;
 8009a56:	699a      	ldr	r2, [r3, #24]
 8009a58:	f022 0210 	bic.w	r2, r2, #16
 8009a5c:	619a      	str	r2, [r3, #24]
			p_control_l->p_rx_data = NULL;
 8009a5e:	2200      	movs	r2, #0
 8009a60:	605a      	str	r2, [r3, #4]
			/* Disable the transmitter events */
			if( p_config_l->fifo_cfg.rx_fifo_size != XMC_USIC_CH_FIFO_DISABLED )
 8009a62:	7f43      	ldrb	r3, [r0, #29]
 8009a64:	b143      	cbz	r3, 8009a78 <UART_abort+0x80>
			{
				/* Disable the receiver event */
				XMC_USIC_CH_TXFIFO_DisableEvent( (XMC_USIC_CH_t *)(p_config_l->p_channel_context),
 8009a66:	6802      	ldr	r2, [r0, #0]
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_GetEvent(), XMC_USIC_CH_TXFIFO_EnableEvent() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_TXFIFO_DisableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
  channel->TBCTR &= (uint32_t)~event;
 8009a68:	f8d2 3108 	ldr.w	r3, [r2, #264]	; 0x108
 8009a6c:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
 8009a70:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
			/* Return with Failed status */
			break;
	}

	/* Return status */
	return ret_status;
 8009a74:	2001      	movs	r0, #1
 8009a76:	bd08      	pop	{r3, pc}
						(unsigned long) ((unsigned long) XMC_USIC_CH_RXFIFO_EVENT_CONF_STANDARD |
										(unsigned long) XMC_USIC_CH_RXFIFO_EVENT_CONF_ALTERNATE) );
			}
			else
			{
				XMC_UART_CH_DisableEvent( (XMC_USIC_CH_t *)(p_config_l->p_channel_context),
 8009a78:	6800      	ldr	r0, [r0, #0]
 8009a7a:	f44f 4140 	mov.w	r1, #49152	; 0xc000
 8009a7e:	f7f8 f82d 	bl	8001adc <XMC_UART_CH_DisableEvent>
			/* Return with Failed status */
			break;
	}

	/* Return status */
	return ret_status;
 8009a82:	2001      	movs	r0, #1
 8009a84:	bd08      	pop	{r3, pc}
			}
		break;

		case UART_ABORT_TX_RX:
			/* Reset Transmitter and Receiver parameters */
			p_control_l->state.tx_busy = 0;
 8009a86:	699a      	ldr	r2, [r3, #24]
 8009a88:	f022 0204 	bic.w	r2, r2, #4
 8009a8c:	619a      	str	r2, [r3, #24]
			p_control_l->p_tx_data = NULL;
 8009a8e:	2100      	movs	r1, #0
 8009a90:	6019      	str	r1, [r3, #0]
			p_control_l->state.rx_busy = 0;
 8009a92:	699a      	ldr	r2, [r3, #24]
 8009a94:	f022 0210 	bic.w	r2, r2, #16
 8009a98:	619a      	str	r2, [r3, #24]
			p_control_l->p_rx_data = NULL;
 8009a9a:	6059      	str	r1, [r3, #4]

			/* Disable the transmitter events */
			if( p_config_l->fifo_cfg.tx_fifo_size != XMC_USIC_CH_FIFO_DISABLED )
 8009a9c:	7f03      	ldrb	r3, [r0, #28]
 8009a9e:	b163      	cbz	r3, 8009aba <UART_abort+0xc2>
			{
				/* Disable the transmit FIFO event */
				XMC_USIC_CH_TXFIFO_DisableEvent( (XMC_USIC_CH_t *)(p_config_l->p_channel_context),
 8009aa0:	6802      	ldr	r2, [r0, #0]
 8009aa2:	f8d2 3108 	ldr.w	r3, [r2, #264]	; 0x108
 8009aa6:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 8009aaa:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
									(unsigned long) XMC_USIC_CH_TXFIFO_EVENT_CONF_STANDARD );
				XMC_USIC_CH_TXFIFO_Flush( (XMC_USIC_CH_t *)(p_config_l->p_channel_context) );
 8009aae:	6803      	ldr	r3, [r0, #0]
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_GetLevel() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_TXFIFO_Flush(XMC_USIC_CH_t *const channel)
{
  channel->TRBSCR = (uint32_t)USIC_CH_TRBSCR_FLUSHTB_Msk;
 8009ab0:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8009ab4:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
 8009ab8:	e004      	b.n	8009ac4 <UART_abort+0xcc>
			}
			else
			{
				/*Disable the standard transmit event*/
				XMC_USIC_CH_DisableEvent( (XMC_USIC_CH_t *)(p_config_l->p_channel_context),
 8009aba:	6802      	ldr	r2, [r0, #0]
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_EnableEvent(), XMC_USIC_CH_SetInterruptNodePointer() \n\n\n
*/
__STATIC_INLINE void XMC_USIC_CH_DisableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
  channel->CCR &= (uint32_t)~event;
 8009abc:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8009abe:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8009ac2:	6413      	str	r3, [r2, #64]	; 0x40
									(unsigned long) XMC_USIC_CH_EVENT_TRANSMIT_BUFFER );
			}
			XMC_USIC_CH_SetTransmitBufferStatus( (XMC_USIC_CH_t *)(p_config_l->p_channel_context),
 8009ac4:	6803      	ldr	r3, [r0, #0]
 * XMC_USIC_CH_GetTransmitBufferStatus() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_SetTransmitBufferStatus(XMC_USIC_CH_t *const channel,
		                                                 const XMC_USIC_CH_TBUF_STATUS_SET_t transmit_buffer_status)
{
  channel->FMR = (uint32_t)transmit_buffer_status;
 8009ac6:	2202      	movs	r2, #2
 8009ac8:	669a      	str	r2, [r3, #104]	; 0x68
													XMC_USIC_CH_TBUF_STATUS_SET_IDLE );

			/* Disable the receiver events */
			if( p_config_l->fifo_cfg.rx_fifo_size != XMC_USIC_CH_FIFO_DISABLED )
 8009aca:	7f43      	ldrb	r3, [r0, #29]
 8009acc:	b143      	cbz	r3, 8009ae0 <UART_abort+0xe8>
			{
				/* Disable the receiver event */
				XMC_USIC_CH_TXFIFO_DisableEvent( (XMC_USIC_CH_t *)(p_config_l->p_channel_context), (unsigned long)
 8009ace:	6802      	ldr	r2, [r0, #0]
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_GetEvent(), XMC_USIC_CH_TXFIFO_EnableEvent() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_TXFIFO_DisableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
  channel->TBCTR &= (uint32_t)~event;
 8009ad0:	f8d2 3108 	ldr.w	r3, [r2, #264]	; 0x108
 8009ad4:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
 8009ad8:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
			/* Return with Failed status */
			break;
	}

	/* Return status */
	return ret_status;
 8009adc:	2001      	movs	r0, #1
 8009ade:	bd08      	pop	{r3, pc}
									(unsigned long) XMC_USIC_CH_RXFIFO_EVENT_CONF_ALTERNATE)
									);
			}
			else
			{
				XMC_UART_CH_DisableEvent( (XMC_USIC_CH_t *)(p_config_l->p_channel_context),
 8009ae0:	6800      	ldr	r0, [r0, #0]
 8009ae2:	f44f 4140 	mov.w	r1, #49152	; 0xc000
 8009ae6:	f7f7 fff9 	bl	8001adc <XMC_UART_CH_DisableEvent>
			/* Return with Failed status */
			break;
	}

	/* Return status */
	return ret_status;
 8009aea:	2001      	movs	r0, #1
 8009aec:	bd08      	pop	{r3, pc}
 *
 */
long UART_abort( void * p_channel, const unsigned char tx_rx )
{
	/* Input argument validity */
	DRIVER_ASSERT( NULL == p_channel, UART_STATUS_INVALID_ARGUMENT );
 8009aee:	2003      	movs	r0, #3
			break;
	}

	/* Return status */
	return ret_status;
}
 8009af0:	4770      	bx	lr
	DRIVER_ASSERT( NULL == p_channel, UART_STATUS_INVALID_ARGUMENT );
	/* Local Arguments */
	tStUART_Configuartion * p_config_l = ((tStUART_Channel*)p_channel)->p_config;
	tStUART_Control * p_control_l = ((tStUART_Channel*) p_channel)->p_control;
	eUART_Status ret_status = UART_STATUS_FAILED;
	DRIVER_ASSERT( 0U == p_control_l->state.init, UART_STATUS_NOT_INITIALIZED );
 8009af2:	2005      	movs	r0, #5
 8009af4:	bd08      	pop	{r3, pc}
			/* Return with Failed status */
			break;
	}

	/* Return status */
	return ret_status;
 8009af6:	2001      	movs	r0, #1
}
 8009af8:	bd08      	pop	{r3, pc}
 8009afa:	bf00      	nop

08009afc <UART_isr_entry>:
	defined(UART_RX_INTERRUPT_USED) ||	\
	defined(UART_PROTOCOL_EVENT_USED))
void UART_isr_entry( void * p_channel, const eUART_InterruptOperation type );
void UART_isr_entry( void * p_channel, const eUART_InterruptOperation type )
{
	DRIVER_ASSERT_NRET( NULL == p_channel );
 8009afc:	b900      	cbnz	r0, 8009b00 <UART_isr_entry+0x4>
 8009afe:	e7fe      	b.n	8009afe <UART_isr_entry+0x2>
#if (defined(UART_TX_INTERRUPT_USED) ||	\
	defined(UART_RX_INTERRUPT_USED) ||	\
	defined(UART_PROTOCOL_EVENT_USED))
void UART_isr_entry( void * p_channel, const eUART_InterruptOperation type );
void UART_isr_entry( void * p_channel, const eUART_InterruptOperation type )
{
 8009b00:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8009b04:	b082      	sub	sp, #8
 8009b06:	4606      	mov	r6, r0
	DRIVER_ASSERT_NRET( NULL == p_channel );
	/* Check for UART channel and type of ISR request */
	switch( type )
 8009b08:	2901      	cmp	r1, #1
 8009b0a:	d056      	beq.n	8009bba <UART_isr_entry+0xbe>
 *
 */
void UART_tx_isr_entry( void * p_channel )
{
	/* Local Arguments */
	tStUART_Configuartion * p_config_l = ((tStUART_Channel*)p_channel)->p_config;
 8009b0c:	6805      	ldr	r5, [r0, #0]
	tStUART_Control * p_control_l = ((tStUART_Channel*) p_channel)->p_control;
 8009b0e:	6844      	ldr	r4, [r0, #4]

	if( 1 == p_control_l->state.tx_busy )
 8009b10:	69a3      	ldr	r3, [r4, #24]
 8009b12:	f013 0f04 	tst.w	r3, #4
 8009b16:	f000 80e2 	beq.w	8009cde <UART_isr_entry+0x1e2>
	{
		/* Check data sent */
		if( p_control_l->tx_data_index < p_control_l->tx_data_count )
 8009b1a:	68e3      	ldr	r3, [r4, #12]
 8009b1c:	68a2      	ldr	r2, [r4, #8]
 8009b1e:	4293      	cmp	r3, r2
 8009b20:	d223      	bcs.n	8009b6a <UART_isr_entry+0x6e>
		{
			/* Check FIFO used or not */
			if( p_config_l->fifo_cfg.tx_fifo_size != XMC_USIC_CH_FIFO_DISABLED )
 8009b22:	7f2a      	ldrb	r2, [r5, #28]
 8009b24:	b1c2      	cbz	r2, 8009b58 <UART_isr_entry+0x5c>
			{
				/* Fill FIFO and send data */
				while( 0 == XMC_USIC_CH_TXFIFO_IsFull( (XMC_USIC_CH_t *const)p_config_l->p_channel_context ) )
 8009b26:	6828      	ldr	r0, [r5, #0]
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_IsEmpty(), XMC_USIC_CH_TXFIFO_Flush() \n\n\n
 */
__STATIC_INLINE bool XMC_USIC_CH_TXFIFO_IsFull(XMC_USIC_CH_t *const channel)
{
  return (bool)(channel->TRBSR & USIC_CH_TRBSR_TFULL_Msk);
 8009b28:	f8d0 2114 	ldr.w	r2, [r0, #276]	; 0x114
 8009b2c:	f412 5f80 	tst.w	r2, #4096	; 0x1000
 8009b30:	d004      	beq.n	8009b3c <UART_isr_entry+0x40>
 8009b32:	e0d4      	b.n	8009cde <UART_isr_entry+0x1e2>
				{
					if( p_control_l->tx_data_index < p_control_l->tx_data_count )
 8009b34:	68a2      	ldr	r2, [r4, #8]
 8009b36:	429a      	cmp	r2, r3
 8009b38:	f240 80d1 	bls.w	8009cde <UART_isr_entry+0x1e2>
					{
						/* Load the FIFO byte by byte till either FIFO is full or all data is loaded */
						XMC_UART_CH_Transmit( (XMC_USIC_CH_t *const)p_config_l->p_channel_context,
								(unsigned short) p_control_l->p_tx_data[p_control_l->tx_data_index] );
 8009b3c:	6822      	ldr	r2, [r4, #0]
				while( 0 == XMC_USIC_CH_TXFIFO_IsFull( (XMC_USIC_CH_t *const)p_config_l->p_channel_context ) )
				{
					if( p_control_l->tx_data_index < p_control_l->tx_data_count )
					{
						/* Load the FIFO byte by byte till either FIFO is full or all data is loaded */
						XMC_UART_CH_Transmit( (XMC_USIC_CH_t *const)p_config_l->p_channel_context,
 8009b3e:	5cd1      	ldrb	r1, [r2, r3]
 8009b40:	f7f7 ff9e 	bl	8001a80 <XMC_UART_CH_Transmit>
								(unsigned short) p_control_l->p_tx_data[p_control_l->tx_data_index] );
						/* Increment data index */
						++(p_control_l->tx_data_index);
 8009b44:	68e3      	ldr	r3, [r4, #12]
 8009b46:	3301      	adds	r3, #1
 8009b48:	60e3      	str	r3, [r4, #12]
		{
			/* Check FIFO used or not */
			if( p_config_l->fifo_cfg.tx_fifo_size != XMC_USIC_CH_FIFO_DISABLED )
			{
				/* Fill FIFO and send data */
				while( 0 == XMC_USIC_CH_TXFIFO_IsFull( (XMC_USIC_CH_t *const)p_config_l->p_channel_context ) )
 8009b4a:	6828      	ldr	r0, [r5, #0]
 8009b4c:	f8d0 2114 	ldr.w	r2, [r0, #276]	; 0x114
 8009b50:	f412 5f80 	tst.w	r2, #4096	; 0x1000
 8009b54:	d0ee      	beq.n	8009b34 <UART_isr_entry+0x38>
 8009b56:	e0c2      	b.n	8009cde <UART_isr_entry+0x1e2>
				}
			}
			else/* Send directly */
			{
				XMC_UART_CH_Transmit( (XMC_USIC_CH_t *const)p_config_l->p_channel_context,
						p_control_l->p_tx_data[p_control_l->tx_data_index] );
 8009b58:	6822      	ldr	r2, [r4, #0]
					}
				}
			}
			else/* Send directly */
			{
				XMC_UART_CH_Transmit( (XMC_USIC_CH_t *const)p_config_l->p_channel_context,
 8009b5a:	6828      	ldr	r0, [r5, #0]
 8009b5c:	5cd1      	ldrb	r1, [r2, r3]
 8009b5e:	f7f7 ff8f 	bl	8001a80 <XMC_UART_CH_Transmit>
						p_control_l->p_tx_data[p_control_l->tx_data_index] );
				++(p_control_l->tx_data_index);
 8009b62:	68e3      	ldr	r3, [r4, #12]
 8009b64:	3301      	adds	r3, #1
 8009b66:	60e3      	str	r3, [r4, #12]
 8009b68:	e0b9      	b.n	8009cde <UART_isr_entry+0x1e2>
			}
		}
		else/* Data is fully sent, ensure it and complete the transfer */
		{
			/* Check FIFO empty status now */
			if( 1 == XMC_USIC_CH_TXFIFO_IsEmpty( (XMC_USIC_CH_t *const)p_config_l->p_channel_context ) )
 8009b6a:	682b      	ldr	r3, [r5, #0]
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_Flush(), XMC_USIC_CH_TXFIFO_PutData() \n\n\n
 */
__STATIC_INLINE bool XMC_USIC_CH_TXFIFO_IsEmpty(XMC_USIC_CH_t *const channel)
{
  return (bool)(channel->TRBSR & USIC_CH_TRBSR_TEMPTY_Msk);
 8009b6c:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
 8009b70:	f412 6f00 	tst.w	r2, #2048	; 0x800
 8009b74:	f000 80b3 	beq.w	8009cde <UART_isr_entry+0x1e2>
			{
				if( p_config_l->fifo_cfg.tx_fifo_size != XMC_USIC_CH_FIFO_DISABLED )
 8009b78:	7f2a      	ldrb	r2, [r5, #28]
 8009b7a:	b132      	cbz	r2, 8009b8a <UART_isr_entry+0x8e>
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_GetEvent(), XMC_USIC_CH_TXFIFO_EnableEvent() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_TXFIFO_DisableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
  channel->TBCTR &= (uint32_t)~event;
 8009b7c:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
 8009b80:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
 8009b84:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
 8009b88:	e003      	b.n	8009b92 <UART_isr_entry+0x96>
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_EnableEvent(), XMC_USIC_CH_SetInterruptNodePointer() \n\n\n
*/
__STATIC_INLINE void XMC_USIC_CH_DisableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
  channel->CCR &= (uint32_t)~event;
 8009b8a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8009b8c:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8009b90:	641a      	str	r2, [r3, #64]	; 0x40
												(unsigned long) XMC_USIC_CH_EVENT_TRANSMIT_BUFFER );
				}

				/* Wait for transmit buffer to get free to ensure data has been sent */
				while( XMC_USIC_CH_TBUF_STATUS_BUSY ==
						XMC_USIC_CH_GetTransmitBufferStatus( (XMC_USIC_CH_t *const)p_config_l->p_channel_context )
 8009b92:	682b      	ldr	r3, [r5, #0]
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_SetDataOutputMode() \n\n\n
 */
__STATIC_INLINE XMC_USIC_CH_TBUF_STATUS_t XMC_USIC_CH_GetTransmitBufferStatus(XMC_USIC_CH_t *const channel)
{
  return (XMC_USIC_CH_TBUF_STATUS_t)(channel->TCSR & USIC_CH_TCSR_TDV_Msk);
 8009b94:	6b9a      	ldr	r2, [r3, #56]	; 0x38
					XMC_USIC_CH_DisableEvent( (XMC_USIC_CH_t *const)p_config_l->p_channel_context,
												(unsigned long) XMC_USIC_CH_EVENT_TRANSMIT_BUFFER );
				}

				/* Wait for transmit buffer to get free to ensure data has been sent */
				while( XMC_USIC_CH_TBUF_STATUS_BUSY ==
 8009b96:	f012 0f80 	tst.w	r2, #128	; 0x80
 8009b9a:	d1fb      	bne.n	8009b94 <UART_isr_entry+0x98>
						XMC_USIC_CH_GetTransmitBufferStatus( (XMC_USIC_CH_t *const)p_config_l->p_channel_context )
						);

				/* Release resources for transmission */
				p_control_l->p_tx_data = NULL;
 8009b9c:	2700      	movs	r7, #0
 8009b9e:	6027      	str	r7, [r4, #0]
				p_control_l->state.tx_busy = 0;
 8009ba0:	69a3      	ldr	r3, [r4, #24]
 8009ba2:	f023 0304 	bic.w	r3, r3, #4
 8009ba6:	61a3      	str	r3, [r4, #24]

				/* Call callback if available */
				#if( UART_CALLBACK_HANDLER_USED == 1U )
				((tStUART_Channel*)p_channel)->p_callback->fp_callback( UART_get_channel( (XMC_USIC_CH_t *const)p_config_l->p_channel_context ),
 8009ba8:	6828      	ldr	r0, [r5, #0]
 8009baa:	f7ff fc83 	bl	80094b4 <UART_get_channel>
 8009bae:	68b3      	ldr	r3, [r6, #8]
 8009bb0:	681b      	ldr	r3, [r3, #0]
 8009bb2:	4639      	mov	r1, r7
 8009bb4:	2207      	movs	r2, #7
 8009bb6:	4798      	blx	r3
 8009bb8:	e091      	b.n	8009cde <UART_isr_entry+0x1e2>
 *
 */
void UART_rx_isr_entry( void * p_channel )
{
	/* Local Arguments */
	tStUART_Configuartion * p_config_l = ((tStUART_Channel*)p_channel)->p_config;
 8009bba:	6805      	ldr	r5, [r0, #0]
	tStUART_Control * p_control_l = ((tStUART_Channel*) p_channel)->p_control;
 8009bbc:	6844      	ldr	r4, [r0, #4]
	if( (1 == p_control_l->state.rx_lock) && (1 == p_control_l->state.rx_busy) )
 8009bbe:	69a3      	ldr	r3, [r4, #24]
 8009bc0:	f013 0f08 	tst.w	r3, #8
 8009bc4:	d061      	beq.n	8009c8a <UART_isr_entry+0x18e>
 8009bc6:	69a3      	ldr	r3, [r4, #24]
 8009bc8:	f013 0f10 	tst.w	r3, #16
 8009bcc:	d05d      	beq.n	8009c8a <UART_isr_entry+0x18e>
	{
		/* Check for FIFO usage */
		if( p_config_l->fifo_cfg.rx_fifo_size != XMC_USIC_CH_FIFO_DISABLED )
 8009bce:	7f6b      	ldrb	r3, [r5, #29]
 8009bd0:	bb4b      	cbnz	r3, 8009c26 <UART_isr_entry+0x12a>
 8009bd2:	e037      	b.n	8009c44 <UART_isr_entry+0x148>
		{
			/* Check FIFO empty status */
			while( 0 == XMC_USIC_CH_RXFIFO_IsEmpty( (XMC_USIC_CH_t *const)p_config_l->p_channel_context ) )
			{
				/* Receive data */
				if( p_control_l->rx_data_index < p_control_l->rx_data_count )
 8009bd4:	6967      	ldr	r7, [r4, #20]
 8009bd6:	6923      	ldr	r3, [r4, #16]
 8009bd8:	429f      	cmp	r7, r3
 8009bda:	d208      	bcs.n	8009bee <UART_isr_entry+0xf2>
				{
					p_control_l->p_rx_data[p_control_l->rx_data_index] =
 8009bdc:	f8d4 8004 	ldr.w	r8, [r4, #4]
						(unsigned char)XMC_UART_CH_GetReceivedData( (XMC_USIC_CH_t *const)p_config_l->p_channel_context );
 8009be0:	f7f7 ff60 	bl	8001aa4 <XMC_UART_CH_GetReceivedData>
 8009be4:	f808 0007 	strb.w	r0, [r8, r7]
					/* Increment data index */
					++(p_control_l->rx_data_index);
 8009be8:	6963      	ldr	r3, [r4, #20]
 8009bea:	3301      	adds	r3, #1
 8009bec:	6163      	str	r3, [r4, #20]
				}
				/* Check for data count and index equality */
				if( p_control_l->rx_data_index == p_control_l->rx_data_count )
 8009bee:	6962      	ldr	r2, [r4, #20]
 8009bf0:	6923      	ldr	r3, [r4, #16]
 8009bf2:	429a      	cmp	r2, r3
 8009bf4:	d117      	bne.n	8009c26 <UART_isr_entry+0x12a>
				{
					/* Release FIFO and reset parameters*/
					p_control_l->state.rx_busy = 0;
 8009bf6:	69a3      	ldr	r3, [r4, #24]
 8009bf8:	f023 0310 	bic.w	r3, r3, #16
 8009bfc:	61a3      	str	r3, [r4, #24]
					p_control_l->state.rx_lock = 0;
 8009bfe:	69a3      	ldr	r3, [r4, #24]
 8009c00:	f023 0308 	bic.w	r3, r3, #8
 8009c04:	61a3      	str	r3, [r4, #24]
					XMC_USIC_CH_RXFIFO_DisableEvent( (XMC_USIC_CH_t *const)p_config_l->p_channel_context,
 8009c06:	682a      	ldr	r2, [r5, #0]
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_RXFIFO_GetEvent(), XMC_USIC_CH_RXFIFO_EnableEvent() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_RXFIFO_DisableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
  channel->RBCTR &= (uint32_t)~event;
 8009c08:	f8d2 310c 	ldr.w	r3, [r2, #268]	; 0x10c
 8009c0c:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
 8009c10:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
									(unsigned long) ((unsigned long) XMC_USIC_CH_RXFIFO_EVENT_CONF_STANDARD |
									(unsigned long) XMC_USIC_CH_RXFIFO_EVENT_CONF_ALTERNATE) );

					/* Call callback if available */
					#if( UART_CALLBACK_HANDLER_USED == 1U )
					((tStUART_Channel*)p_channel)->p_callback->fp_callback( UART_get_channel( (XMC_USIC_CH_t *const)p_config_l->p_channel_context ),
 8009c14:	6828      	ldr	r0, [r5, #0]
 8009c16:	f7ff fc4d 	bl	80094b4 <UART_get_channel>
 8009c1a:	68b3      	ldr	r3, [r6, #8]
 8009c1c:	681b      	ldr	r3, [r3, #0]
 8009c1e:	2100      	movs	r1, #0
 8009c20:	2208      	movs	r2, #8
 8009c22:	4798      	blx	r3
 8009c24:	e005      	b.n	8009c32 <UART_isr_entry+0x136>
	{
		/* Check for FIFO usage */
		if( p_config_l->fifo_cfg.rx_fifo_size != XMC_USIC_CH_FIFO_DISABLED )
		{
			/* Check FIFO empty status */
			while( 0 == XMC_USIC_CH_RXFIFO_IsEmpty( (XMC_USIC_CH_t *const)p_config_l->p_channel_context ) )
 8009c26:	6828      	ldr	r0, [r5, #0]
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_RXFIFO_Flush(), XMC_USIC_CH_RXFIFO_PutData() \n\n\n
 */
__STATIC_INLINE bool XMC_USIC_CH_RXFIFO_IsEmpty(XMC_USIC_CH_t *const channel)
{
  return (bool)(channel->TRBSR & USIC_CH_TRBSR_REMPTY_Msk);
 8009c28:	f8d0 3114 	ldr.w	r3, [r0, #276]	; 0x114
 8009c2c:	f013 0f08 	tst.w	r3, #8
 8009c30:	d0d0      	beq.n	8009bd4 <UART_isr_entry+0xd8>
					/* Break operation */
					break;
				}
			}
			/* Dynamically setup the trigger limit for FIFO */
			if( p_control_l->rx_data_index < p_control_l->rx_data_count )
 8009c32:	6963      	ldr	r3, [r4, #20]
 8009c34:	6921      	ldr	r1, [r4, #16]
 8009c36:	428b      	cmp	r3, r1
 8009c38:	d251      	bcs.n	8009cde <UART_isr_entry+0x1e2>
			{
				reconfigure_rx_fifo( p_channel, p_control_l->rx_data_count - p_control_l->rx_data_index );
 8009c3a:	4630      	mov	r0, r6
 8009c3c:	1ac9      	subs	r1, r1, r3
 8009c3e:	f7ff fc61 	bl	8009504 <reconfigure_rx_fifo>
 8009c42:	e04c      	b.n	8009cde <UART_isr_entry+0x1e2>
			}
		}
		else
		{
			/* Check data index */
			if( p_control_l->rx_data_index < p_control_l->rx_data_count )
 8009c44:	6967      	ldr	r7, [r4, #20]
 8009c46:	6923      	ldr	r3, [r4, #16]
 8009c48:	429f      	cmp	r7, r3
 8009c4a:	d208      	bcs.n	8009c5e <UART_isr_entry+0x162>
			{
				/* receive data and put it in buffer */
				p_control_l->p_rx_data[p_control_l->rx_data_index] = (unsigned char)XMC_UART_CH_GetReceivedData(
 8009c4c:	6866      	ldr	r6, [r4, #4]
 8009c4e:	6828      	ldr	r0, [r5, #0]
 8009c50:	f7f7 ff28 	bl	8001aa4 <XMC_UART_CH_GetReceivedData>
 8009c54:	55f0      	strb	r0, [r6, r7]
															(XMC_USIC_CH_t *const)p_config_l->p_channel_context );
				/* Update data index */
				++(p_control_l->rx_data_index);
 8009c56:	6963      	ldr	r3, [r4, #20]
 8009c58:	3301      	adds	r3, #1
 8009c5a:	6163      	str	r3, [r4, #20]
 8009c5c:	e03f      	b.n	8009cde <UART_isr_entry+0x1e2>
			}
			else
			{
				/* Release rx control */
				p_control_l->state.rx_busy = 0;
 8009c5e:	69a3      	ldr	r3, [r4, #24]
 8009c60:	f023 0310 	bic.w	r3, r3, #16
 8009c64:	61a3      	str	r3, [r4, #24]
				p_control_l->state.rx_lock = 0;
 8009c66:	69a3      	ldr	r3, [r4, #24]
 8009c68:	f023 0308 	bic.w	r3, r3, #8
 8009c6c:	61a3      	str	r3, [r4, #24]
				/* Disable events */
				XMC_USIC_CH_DisableEvent( (XMC_USIC_CH_t *const)p_config_l->p_channel_context,
 8009c6e:	682a      	ldr	r2, [r5, #0]
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_EnableEvent(), XMC_USIC_CH_SetInterruptNodePointer() \n\n\n
*/
__STATIC_INLINE void XMC_USIC_CH_DisableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
  channel->CCR &= (uint32_t)~event;
 8009c70:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8009c72:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 8009c76:	6413      	str	r3, [r2, #64]	; 0x40
							(unsigned long) ((unsigned long) XMC_USIC_CH_EVENT_STANDARD_RECEIVE |
							(unsigned long) XMC_USIC_CH_EVENT_ALTERNATIVE_RECEIVE) );
				/* Call callback */
				#if( UART_CALLBACK_HANDLER_USED == 1U )
				((tStUART_Channel*)p_channel)->p_callback->fp_callback( UART_get_channel( (XMC_USIC_CH_t *const)p_config_l->p_channel_context ),
 8009c78:	6828      	ldr	r0, [r5, #0]
 8009c7a:	f7ff fc1b 	bl	80094b4 <UART_get_channel>
 8009c7e:	68b3      	ldr	r3, [r6, #8]
 8009c80:	681b      	ldr	r3, [r3, #0]
 8009c82:	2100      	movs	r1, #0
 8009c84:	2208      	movs	r2, #8
 8009c86:	4798      	blx	r3
 8009c88:	e029      	b.n	8009cde <UART_isr_entry+0x1e2>
	/* Receive data directly and pass it to callback,
	 * for this operation events for receiver should always be enabled
	 *
	 * Note: If need this functionality then, enable receiver events for direct use
	 *  */
	unsigned char data_l = 255;
 8009c8a:	23ff      	movs	r3, #255	; 0xff
 8009c8c:	f88d 3007 	strb.w	r3, [sp, #7]

	/* Clear receive event */
	XMC_USIC_CH_DisableEvent( (XMC_USIC_CH_t *const)p_config_l->p_channel_context,
 8009c90:	682a      	ldr	r2, [r5, #0]
 8009c92:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8009c94:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 8009c98:	6413      	str	r3, [r2, #64]	; 0x40
			(unsigned long) ((unsigned long) XMC_USIC_CH_EVENT_STANDARD_RECEIVE |
			(unsigned long) XMC_USIC_CH_EVENT_ALTERNATIVE_RECEIVE) );

	/* Check for FIFO usage */
	if( p_config_l->fifo_cfg.rx_fifo_size != XMC_USIC_CH_FIFO_DISABLED )
 8009c9a:	7f6b      	ldrb	r3, [r5, #29]
 8009c9c:	b153      	cbz	r3, 8009cb4 <UART_isr_entry+0x1b8>
	{
		/* Check if FIFO is empty or not */
		if( 0 == XMC_USIC_CH_RXFIFO_IsEmpty( (XMC_USIC_CH_t *const)p_config_l->p_channel_context ) )
 8009c9e:	6828      	ldr	r0, [r5, #0]
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_RXFIFO_Flush(), XMC_USIC_CH_RXFIFO_PutData() \n\n\n
 */
__STATIC_INLINE bool XMC_USIC_CH_RXFIFO_IsEmpty(XMC_USIC_CH_t *const channel)
{
  return (bool)(channel->TRBSR & USIC_CH_TRBSR_REMPTY_Msk);
 8009ca0:	f8d0 3114 	ldr.w	r3, [r0, #276]	; 0x114
 8009ca4:	f013 0f08 	tst.w	r3, #8
 8009ca8:	d109      	bne.n	8009cbe <UART_isr_entry+0x1c2>
		{
			data_l = (unsigned char)XMC_UART_CH_GetReceivedData( (XMC_USIC_CH_t *const)p_config_l->p_channel_context );
 8009caa:	f7f7 fefb 	bl	8001aa4 <XMC_UART_CH_GetReceivedData>
 8009cae:	f88d 0007 	strb.w	r0, [sp, #7]
 8009cb2:	e004      	b.n	8009cbe <UART_isr_entry+0x1c2>
		}
	}
	else
	{
		/* Receive data */
		data_l = (unsigned char)XMC_UART_CH_GetReceivedData( (XMC_USIC_CH_t *const)p_config_l->p_channel_context );
 8009cb4:	6828      	ldr	r0, [r5, #0]
 8009cb6:	f7f7 fef5 	bl	8001aa4 <XMC_UART_CH_GetReceivedData>
 8009cba:	f88d 0007 	strb.w	r0, [sp, #7]
	}

	/* Call callback */
	#if( UART_CALLBACK_HANDLER_USED == 1U )
	((tStUART_Channel*)p_channel)->p_callback->fp_callback( UART_get_channel( (XMC_USIC_CH_t *const)p_config_l->p_channel_context ),
 8009cbe:	6828      	ldr	r0, [r5, #0]
 8009cc0:	f7ff fbf8 	bl	80094b4 <UART_get_channel>
 8009cc4:	68b3      	ldr	r3, [r6, #8]
 8009cc6:	681b      	ldr	r3, [r3, #0]
 8009cc8:	f10d 0107 	add.w	r1, sp, #7
 8009ccc:	2206      	movs	r2, #6
 8009cce:	4798      	blx	r3
															&data_l, UART_EVENT_RX_CHAR );
	#endif
	/* Enable Rx Event */
	XMC_USIC_CH_RXFIFO_EnableEvent( (XMC_USIC_CH_t *)(p_config_l->p_channel_context),
 8009cd0:	682a      	ldr	r2, [r5, #0]
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_RXFIFO_SetInterruptNodePointer() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_RXFIFO_EnableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
  channel->RBCTR |= event;
 8009cd2:	f8d2 310c 	ldr.w	r3, [r2, #268]	; 0x10c
 8009cd6:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8009cda:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
		case UART_INTERRUPT_OPERATION_ERROR:
			UART_err_isr_entry( p_channel );
		break;
	#endif
	}
}
 8009cde:	b002      	add	sp, #8
 8009ce0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08009ce4 <USIC0_2_IRQHandler>:
 *
 * <i>Imp Note:</i>
 *
 */
void UART_0_TX_HANDLER( void )
{
 8009ce4:	b508      	push	{r3, lr}
	/* Call ISR entry function */
	UART_isr_entry( &UART_Channel_0, UART_INTERRUPT_OPERATION_TX );
 8009ce6:	4802      	ldr	r0, [pc, #8]	; (8009cf0 <USIC0_2_IRQHandler+0xc>)
 8009ce8:	2100      	movs	r1, #0
 8009cea:	f7ff ff07 	bl	8009afc <UART_isr_entry>
 8009cee:	bd08      	pop	{r3, pc}
 8009cf0:	2000d5f8 	.word	0x2000d5f8

08009cf4 <USIC0_1_IRQHandler>:
 *
 * <i>Imp Note:</i>
 *
 */
void UART_0_RX_HANDLER( void )
{
 8009cf4:	b508      	push	{r3, lr}
	/* Call ISR entry function */
	UART_isr_entry( &UART_Channel_0, UART_INTERRUPT_OPERATION_RX );
 8009cf6:	4802      	ldr	r0, [pc, #8]	; (8009d00 <USIC0_1_IRQHandler+0xc>)
 8009cf8:	2101      	movs	r1, #1
 8009cfa:	f7ff feff 	bl	8009afc <UART_isr_entry>
 8009cfe:	bd08      	pop	{r3, pc}
 8009d00:	2000d5f8 	.word	0x2000d5f8

08009d04 <SCU_init>:
 *
 * <i>Imp Note:</i>
 *
 */
long SCU_init( void * p_channel, const unsigned char init )
{
 8009d04:	b570      	push	{r4, r5, r6, lr}
	/* Local Varibales */
	long ret_status = SCU_STATUS_FAILED;

	tStSCU_GlobalConfiguartion * p_config_l = ((tStSCU *)p_channel)->p_module_config;
 8009d06:	6804      	ldr	r4, [r0, #0]
	tStSCU_Control * p_control_l = ((tStSCU *)p_channel)->p_control;
 8009d08:	6845      	ldr	r5, [r0, #4]

	/* Check init */
	switch( init )
 8009d0a:	2900      	cmp	r1, #0
 8009d0c:	d061      	beq.n	8009dd2 <SCU_init+0xce>
 8009d0e:	2901      	cmp	r1, #1
 8009d10:	d165      	bne.n	8009dde <SCU_init+0xda>
	{
		/* Initialize SCU */
		case 1:
//			XMC_SCU_CLOCK_Init( (const XMC_SCU_CLOCK_CONFIG_t *const) p_config_l->p_config );
			/* Enable Traps */
			XMC_SCU_TRAP_Enable( p_config_l->traps );
 8009d12:	6860      	ldr	r0, [r4, #4]
 8009d14:	f7f7 f90a 	bl	8000f2c <XMC_SCU_TRAP_Enable>
			XMC_SCU_INTERRUPT_EnableNmiRequest( p_config_l->nmi_request );
 8009d18:	68e0      	ldr	r0, [r4, #12]
 8009d1a:	f7f7 f91b 	bl	8000f54 <XMC_SCU_INTERRUPT_EnableNmiRequest>
			XMC_SCU_INTERRUPT_SetEventHandler( 0, p_config_l->trap_handler );
 8009d1e:	2000      	movs	r0, #0
 8009d20:	68a1      	ldr	r1, [r4, #8]
 8009d22:	f7f7 f9b3 	bl	800108c <XMC_SCU_INTERRUPT_SetEventHandler>

			/* Enable Events */
			#if (USING_WATCHDOG == 1U)
			XMC_SCU_INTERRUPT_EnableEvent( p_config_l->events );
 8009d26:	6920      	ldr	r0, [r4, #16]
 8009d28:	f7f7 f8e4 	bl	8000ef4 <XMC_SCU_INTERRUPT_EnableEvent>
			XMC_SCU_CLOCK_SetWdtClockDivider( p_config_l->wdt_clock_div );
 8009d2c:	69a0      	ldr	r0, [r4, #24]
 8009d2e:	f7f7 f959 	bl	8000fe4 <XMC_SCU_CLOCK_SetWdtClockDivider>
			XMC_SCU_CLOCK_SetWdtClockSource( p_config_l->wdt_clock );
 8009d32:	6a20      	ldr	r0, [r4, #32]
 8009d34:	f7f7 f93a 	bl	8000fac <XMC_SCU_CLOCK_SetWdtClockSource>
 * The working mode is set during initialization in XMC_WDT_Init(). Invoke this API to alter the mode as needed later in
 * the program.
 */
__STATIC_INLINE void XMC_WDT_SetMode(XMC_WDT_MODE_t mode)
{
  WDT->CTR = (WDT->CTR & (uint32_t)~WDT_CTR_PRE_Msk) | (uint32_t)mode;
 8009d38:	4a2a      	ldr	r2, [pc, #168]	; (8009de4 <SCU_init+0xe0>)
 8009d3a:	6853      	ldr	r3, [r2, #4]
 8009d3c:	f894 1024 	ldrb.w	r1, [r4, #36]	; 0x24
 8009d40:	f023 0302 	bic.w	r3, r3, #2
 8009d44:	430b      	orrs	r3, r1
 8009d46:	6053      	str	r3, [r2, #4]
 * or feeding of watchdog. The pulse width is initially set during initialization in XMC_WDT_Init(). Invoke this API to
 * alter the width as needed later in the program.
 */
__STATIC_INLINE void XMC_WDT_SetServicePulseWidth(uint8_t service_pulse_width)
{
  WDT->CTR = (WDT->CTR & (uint32_t)~WDT_CTR_SPW_Msk) | ((uint32_t)service_pulse_width << WDT_CTR_SPW_Pos);
 8009d48:	6853      	ldr	r3, [r2, #4]
 8009d4a:	7f21      	ldrb	r1, [r4, #28]
 8009d4c:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 8009d50:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8009d54:	6053      	str	r3, [r2, #4]
			XMC_WDT_SetMode( p_config_l->wdt_mode );
			XMC_WDT_SetServicePulseWidth( p_config_l->wdt_servie_pulse_width );
			XMC_WDT_Init( (const XMC_WDT_CONFIG_t *const)p_config_l->p_wdt_config );
 8009d56:	6960      	ldr	r0, [r4, #20]
 8009d58:	f7f7 ffb4 	bl	8001cc4 <XMC_WDT_Init>
 *
 */
__STATIC_INLINE void XMC_SCU_POWER_EnableMonitor(uint8_t threshold, uint8_t interval)
{
  SCU_POWER->PWRMON = SCU_POWER_PWRMON_ENB_Msk | 
                      ((uint32_t)threshold << SCU_POWER_PWRMON_THRS_Pos) | 
 8009d5c:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
 8009d60:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
                      ((uint32_t)interval << SCU_POWER_PWRMON_INTV_Pos);
 8009d64:	f894 2026 	ldrb.w	r2, [r4, #38]	; 0x26
 *
 */
__STATIC_INLINE void XMC_SCU_POWER_EnableMonitor(uint8_t threshold, uint8_t interval)
{
  SCU_POWER->PWRMON = SCU_POWER_PWRMON_ENB_Msk | 
                      ((uint32_t)threshold << SCU_POWER_PWRMON_THRS_Pos) | 
 8009d68:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 * XMC_SCU_TRAP_Enable() \n\n\n
 *
 */
__STATIC_INLINE void XMC_SCU_POWER_EnableMonitor(uint8_t threshold, uint8_t interval)
{
  SCU_POWER->PWRMON = SCU_POWER_PWRMON_ENB_Msk | 
 8009d6c:	4a1e      	ldr	r2, [pc, #120]	; (8009de8 <SCU_init+0xe4>)
 8009d6e:	62d3      	str	r3, [r2, #44]	; 0x2c
			#if (USING_BROWN_OUT_DETECT == 1U)
			XMC_SCU_POWER_EnableMonitor( p_config_l->threshold, p_config_l->interval );
			#endif

			/* Configure NVIC */
			NVIC_SetPriority( (IRQn_Type)p_config_l->p_isr_config->irq.irq_num,
 8009d70:	6823      	ldr	r3, [r4, #0]
 8009d72:	781e      	ldrb	r6, [r3, #0]
 8009d74:	b2f0      	uxtb	r0, r6
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8009d76:	4a1d      	ldr	r2, [pc, #116]	; (8009dec <SCU_init+0xe8>)
 8009d78:	68d1      	ldr	r1, [r2, #12]
								NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
								(IRQn_Type)p_config_l->p_isr_config->irq.irq_priority, 0U) );
 8009d7a:	785b      	ldrb	r3, [r3, #1]
			#if (USING_BROWN_OUT_DETECT == 1U)
			XMC_SCU_POWER_EnableMonitor( p_config_l->threshold, p_config_l->interval );
			#endif

			/* Configure NVIC */
			NVIC_SetPriority( (IRQn_Type)p_config_l->p_isr_config->irq.irq_num,
 8009d7c:	f003 027f 	and.w	r2, r3, #127	; 0x7f
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8009d80:	f3c1 2302 	ubfx	r3, r1, #8, #3
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8009d84:	f1c3 0407 	rsb	r4, r3, #7
 8009d88:	2c06      	cmp	r4, #6
 8009d8a:	bf28      	it	cs
 8009d8c:	2406      	movcs	r4, #6
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8009d8e:	1d99      	adds	r1, r3, #6
 8009d90:	2906      	cmp	r1, #6
 8009d92:	bf8c      	ite	hi
 8009d94:	f103 31ff 	addhi.w	r1, r3, #4294967295
 8009d98:	2100      	movls	r1, #0

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8009d9a:	2301      	movs	r3, #1
 8009d9c:	40a3      	lsls	r3, r4
 8009d9e:	3b01      	subs	r3, #1
 8009da0:	4013      	ands	r3, r2
 8009da2:	408b      	lsls	r3, r1
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 8009da4:	f010 0f80 	tst.w	r0, #128	; 0x80
 8009da8:	d107      	bne.n	8009dba <SCU_init+0xb6>
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8009daa:	009b      	lsls	r3, r3, #2
 8009dac:	b2db      	uxtb	r3, r3
 8009dae:	4a10      	ldr	r2, [pc, #64]	; (8009df0 <SCU_init+0xec>)
 8009db0:	fa42 f080 	sxtab	r0, r2, r0
 8009db4:	f880 3300 	strb.w	r3, [r0, #768]	; 0x300
 8009db8:	e005      	b.n	8009dc6 <SCU_init+0xc2>
  }
  else
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8009dba:	f006 060f 	and.w	r6, r6, #15
 8009dbe:	009b      	lsls	r3, r3, #2
 8009dc0:	b2db      	uxtb	r3, r3
 8009dc2:	4a0c      	ldr	r2, [pc, #48]	; (8009df4 <SCU_init+0xf0>)
 8009dc4:	5593      	strb	r3, [r2, r6]
								NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
								(IRQn_Type)p_config_l->p_isr_config->irq.irq_priority, 0U) );

			/* Update control parameters */
			p_control_l->state.init = 1;
 8009dc6:	682b      	ldr	r3, [r5, #0]
 8009dc8:	f043 0301 	orr.w	r3, r3, #1
 8009dcc:	602b      	str	r3, [r5, #0]
 *
 */
long SCU_init( void * p_channel, const unsigned char init )
{
	/* Local Varibales */
	long ret_status = SCU_STATUS_FAILED;
 8009dce:	2001      	movs	r0, #1
								NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
								(IRQn_Type)p_config_l->p_isr_config->irq.irq_priority, 0U) );

			/* Update control parameters */
			p_control_l->state.init = 1;
		break;
 8009dd0:	bd70      	pop	{r4, r5, r6, pc}
		/* De-initialize SCU */
		case 0:
			p_control_l->state.init = 0;
 8009dd2:	682b      	ldr	r3, [r5, #0]
 8009dd4:	f023 0301 	bic.w	r3, r3, #1
 8009dd8:	602b      	str	r3, [r5, #0]
 *
 */
long SCU_init( void * p_channel, const unsigned char init )
{
	/* Local Varibales */
	long ret_status = SCU_STATUS_FAILED;
 8009dda:	2001      	movs	r0, #1
			p_control_l->state.init = 1;
		break;
		/* De-initialize SCU */
		case 0:
			p_control_l->state.init = 0;
		break;
 8009ddc:	bd70      	pop	{r4, r5, r6, pc}
		/* Invalid Arguments */
		default:
		ret_status = SCU_STATUS_INVALID_ARGUMENT;
 8009dde:	2002      	movs	r0, #2
	}

	/* Return status */
	return ret_status;
}
 8009de0:	bd70      	pop	{r4, r5, r6, pc}
 8009de2:	bf00      	nop
 8009de4:	50008000 	.word	0x50008000
 8009de8:	50004200 	.word	0x50004200
 8009dec:	e000ed00 	.word	0xe000ed00
 8009df0:	e000e100 	.word	0xe000e100
 8009df4:	e000ed14 	.word	0xe000ed14

08009df8 <SCU_Trap_Handler>:

/* Trap Handler for SCU Traps */
void SCU_Trap_Handler( void )
{
	/* TODO: Debug and Understand first */
	__asm("NOP");
 8009df8:	bf00      	nop
 8009dfa:	4770      	bx	lr

08009dfc <SCU_0_IRQHandler>:
* Function Definitions
*******************************************************************************/


void SCU_Interrupt_Handler( void )
{
 8009dfc:	b508      	push	{r3, lr}
	XMC_SCU_IRQHandler( 0 );
 8009dfe:	2000      	movs	r0, #0
 8009e00:	f7f7 f960 	bl	80010c4 <XMC_SCU_IRQHandler>
 8009e04:	bd08      	pop	{r3, pc}
 8009e06:	bf00      	nop

08009e08 <RTC_init>:
 * <i>Imp Note:</i>
 *
 */
long RTC_init( void * p_channel, const unsigned char init )
{
	DRIVER_ASSERT( NULL == p_channel, RTC_STATUS_INVALID_ARGUMENT );
 8009e08:	2800      	cmp	r0, #0
 8009e0a:	d04b      	beq.n	8009ea4 <RTC_init+0x9c>
 *
 * <i>Imp Note:</i>
 *
 */
long RTC_init( void * p_channel, const unsigned char init )
{
 8009e0c:	b570      	push	{r4, r5, r6, lr}
	DRIVER_ASSERT( NULL == p_channel, RTC_STATUS_INVALID_ARGUMENT );
	/* Local Variables */
	tStRTC_ModuleConfiguartion * p_config_l = ((tStRTC *)p_channel)->p_config;
 8009e0e:	6806      	ldr	r6, [r0, #0]
	tStRTC_Control * p_control_l = ((tStRTC *)p_channel)->p_control;
 8009e10:	6845      	ldr	r5, [r0, #4]
	long ret_status = RTC_STATUS_FAILED;

	/* Check Initiallization */
	switch( init )
 8009e12:	2900      	cmp	r1, #0
 8009e14:	d03a      	beq.n	8009e8c <RTC_init+0x84>
 8009e16:	2901      	cmp	r1, #1
 8009e18:	d146      	bne.n	8009ea8 <RTC_init+0xa0>
	{
		case RTC_INIT_OPEN:
			/* Check initialization state */
			if( 1 == p_control_l->state.init )
 8009e1a:	f895 3048 	ldrb.w	r3, [r5, #72]	; 0x48
 8009e1e:	f013 0f01 	tst.w	r3, #1
 8009e22:	d143      	bne.n	8009eac <RTC_init+0xa4>
				ret_status = RTC_STATUS_ALREADY_INITIALIZED;
			}
			else
			{
				/* Set RTC CLock source */
				XMC_SCU_HIB_SetRtcClockSource( p_config_l->clock_source );
 8009e24:	7a30      	ldrb	r0, [r6, #8]
 8009e26:	f7f7 f8cb 	bl	8000fc0 <XMC_SCU_HIB_SetRtcClockSource>
				/* Initialize RTC channel */
				ret_status = XMC_RTC_Init( (const XMC_RTC_CONFIG_t *const) p_config_l->p_channel_config );
 8009e2a:	6870      	ldr	r0, [r6, #4]
 8009e2c:	f7f7 f806 	bl	8000e3c <XMC_RTC_Init>
				/* Check status */
				if( XMC_RTC_STATUS_OK == ret_status )
 8009e30:	4604      	mov	r4, r0
 8009e32:	2800      	cmp	r0, #0
 8009e34:	d13c      	bne.n	8009eb0 <RTC_init+0xa8>
				{
					/* Set Default RTC Time */
					XMC_RTC_SetTime( &(p_config_l->p_channel_config->time) );
 8009e36:	6870      	ldr	r0, [r6, #4]
 8009e38:	f7f7 fd54 	bl	80018e4 <XMC_RTC_SetTime>
					/* Set Alarm */
					XMC_RTC_SetAlarm( &(p_config_l->p_channel_config->alarm) );
 8009e3c:	6870      	ldr	r0, [r6, #4]
 8009e3e:	3008      	adds	r0, #8
 8009e40:	f7f7 fd90 	bl	8001964 <XMC_RTC_SetAlarm>

					/* Get standard time values */
					#if (RTC_USING_STANDARD_TIME == 1U)
					XMC_RTC_GetTimeStdFormat( &(p_control_l->time) );
 8009e44:	4628      	mov	r0, r5
 8009e46:	f7f7 fd65 	bl	8001914 <XMC_RTC_GetTimeStdFormat>
					XMC_RTC_GetAlarmStdFormat( &(p_control_l->alarm) );
 8009e4a:	f105 0024 	add.w	r0, r5, #36	; 0x24
 8009e4e:	f7f7 fda1 	bl	8001994 <XMC_RTC_GetAlarmStdFormat>
					#endif
					/* Enable RTC Events */
					XMC_RTC_EnableEvent( RTC_EVENTS );
 8009e52:	f44f 70b7 	mov.w	r0, #366	; 0x16e
 8009e56:	f7f7 f82d 	bl	8000eb4 <XMC_RTC_EnableEvent>
					/* Enable Hibernate Wakeup for RTC Alarm */
					XMC_RTC_EnableHibernationWakeUp( XMC_RTC_WAKEUP_EVENT_ON_ALARM );
 8009e5a:	2004      	movs	r0, #4
 8009e5c:	f7f7 f83a 	bl	8000ed4 <XMC_RTC_EnableHibernationWakeUp>

					#if (RTC_ALARM_NMI_REQUEST == 1U)
					/* Enable NMI request for RTC Alarm
					 * Note: NMI has to be handled in NMI handler */
					XMC_SCU_INTERRUPT_EnableNmiRequest( XMC_SCU_NMIREQ_RTC_AI );
 8009e60:	2004      	movs	r0, #4
 8009e62:	f7f7 f877 	bl	8000f54 <XMC_SCU_INTERRUPT_EnableNmiRequest>
					#elif (RTC_ALARM_NMI_REQUEST == 0U)
					XMC_SCU_INTERRUPT_SetEventHandler( XMC_SCU_INTERRUPT_EVENT_RTC_ALARM, &RTC_Alarm_Handler );
					#endif
					/* Set RTC Event Handlers,
					 * Note: Not checking the return status, should consider the max event numbers */
					XMC_SCU_INTERRUPT_SetEventHandler( XMC_SCU_INTERRUPT_EVENT_RTC_PERIODIC, &RTC_Event_Handler );
 8009e66:	2002      	movs	r0, #2
 8009e68:	4912      	ldr	r1, [pc, #72]	; (8009eb4 <RTC_init+0xac>)
 8009e6a:	f7f7 f90f 	bl	800108c <XMC_SCU_INTERRUPT_SetEventHandler>
					XMC_SCU_INTERRUPT_EnableEvent( XMC_SCU_INTERRUPT_EVENT_RTC_PERIODIC | XMC_SCU_INTERRUPT_EVENT_RTC_ALARM );
 8009e6e:	2006      	movs	r0, #6
 8009e70:	f7f7 f840 	bl	8000ef4 <XMC_SCU_INTERRUPT_EnableEvent>

					/* Enable and Start RTC */
					XMC_RTC_Enable();
 8009e74:	f7f6 ffdc 	bl	8000e30 <XMC_RTC_Enable>
					XMC_RTC_Start();
 8009e78:	f7f7 fd02 	bl	8001880 <XMC_RTC_Start>

					/* Update parameters */
					p_control_l->state.init = 1;
 8009e7c:	f895 3048 	ldrb.w	r3, [r5, #72]	; 0x48
 8009e80:	f043 0301 	orr.w	r3, r3, #1
 8009e84:	f885 3048 	strb.w	r3, [r5, #72]	; 0x48
					/* Update return status */
					ret_status = RTC_STATUS_SUCCESS;
 8009e88:	4620      	mov	r0, r4
 8009e8a:	bd70      	pop	{r4, r5, r6, pc}
			}
		break;

		case RTC_INIT_CLOSE:
			/* Disable and Stop RTC */
			XMC_RTC_Disable();
 8009e8c:	f7f6 ffd4 	bl	8000e38 <XMC_RTC_Disable>
			XMC_RTC_Stop();
 8009e90:	f7f7 fd06 	bl	80018a0 <XMC_RTC_Stop>
			ret_status = RTC_STATUS_SUCCESS;
			/* update initialization satte */
			p_control_l->state.init = 0;
 8009e94:	f895 3048 	ldrb.w	r3, [r5, #72]	; 0x48
 8009e98:	f36f 0300 	bfc	r3, #0, #1
 8009e9c:	f885 3048 	strb.w	r3, [r5, #72]	; 0x48

		case RTC_INIT_CLOSE:
			/* Disable and Stop RTC */
			XMC_RTC_Disable();
			XMC_RTC_Stop();
			ret_status = RTC_STATUS_SUCCESS;
 8009ea0:	2000      	movs	r0, #0
			/* update initialization satte */
			p_control_l->state.init = 0;
		break;
 8009ea2:	bd70      	pop	{r4, r5, r6, pc}
 * <i>Imp Note:</i>
 *
 */
long RTC_init( void * p_channel, const unsigned char init )
{
	DRIVER_ASSERT( NULL == p_channel, RTC_STATUS_INVALID_ARGUMENT );
 8009ea4:	2003      	movs	r0, #3
			ret_status = RTC_STATUS_INVALID_ARGUMENT;
	}

	/* Return status */
	return ret_status;
}
 8009ea6:	4770      	bx	lr
			/* update initialization satte */
			p_control_l->state.init = 0;
		break;

		default:
			ret_status = RTC_STATUS_INVALID_ARGUMENT;
 8009ea8:	2003      	movs	r0, #3
 8009eaa:	bd70      	pop	{r4, r5, r6, pc}
	{
		case RTC_INIT_OPEN:
			/* Check initialization state */
			if( 1 == p_control_l->state.init )
			{
				ret_status = RTC_STATUS_ALREADY_INITIALIZED;
 8009eac:	2005      	movs	r0, #5
 8009eae:	bd70      	pop	{r4, r5, r6, pc}
			ret_status = RTC_STATUS_INVALID_ARGUMENT;
	}

	/* Return status */
	return ret_status;
}
 8009eb0:	bd70      	pop	{r4, r5, r6, pc}
 8009eb2:	bf00      	nop
 8009eb4:	08009eb9 	.word	0x08009eb9

08009eb8 <RTC_Event_Handler>:

/* RTC ISR Entries */
#if (RTC_USED == 1U)
void RTC_Event_Handler( void )
{
	__asm("NOP");
 8009eb8:	bf00      	nop
 8009eba:	4770      	bx	lr

08009ebc <memcmp>:
	const unsigned char *p_arg_two_l = (unsigned char *)p_arg_two;
	size_t size_l = 0;
	int ret_l = 0;

	/* Compare memory for differences */
	for( size_l = 0; size_l < size; ++size_l )
 8009ebc:	b172      	cbz	r2, 8009edc <memcmp+0x20>
 *
 * <i>Imp Note:</i>
 *
 */
int memcmp( const void * p_arg_one, const void *p_arg_two, size_t size )
{
 8009ebe:	b430      	push	{r4, r5}
 8009ec0:	4603      	mov	r3, r0
 8009ec2:	3901      	subs	r1, #1
 8009ec4:	1882      	adds	r2, r0, r2
	const unsigned char *p_arg_two_l = (unsigned char *)p_arg_two;
	size_t size_l = 0;
	int ret_l = 0;

	/* Compare memory for differences */
	for( size_l = 0; size_l < size; ++size_l )
 8009ec6:	2000      	movs	r0, #0
	{
		/* Values are not equal */
		if( *(p_arg_one_l + size_l) != *(p_arg_two_l + size_l) )
 8009ec8:	f813 5b01 	ldrb.w	r5, [r3], #1
 8009ecc:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8009ed0:	42a5      	cmp	r5, r4
		{
			/* Check the greater or smaller between both */
			ret_l = ( *(p_arg_one_l + size_l) - *(p_arg_two_l + size_l) );
 8009ed2:	bf18      	it	ne
 8009ed4:	1b28      	subne	r0, r5, r4
	const unsigned char *p_arg_two_l = (unsigned char *)p_arg_two;
	size_t size_l = 0;
	int ret_l = 0;

	/* Compare memory for differences */
	for( size_l = 0; size_l < size; ++size_l )
 8009ed6:	4293      	cmp	r3, r2
 8009ed8:	d1f6      	bne.n	8009ec8 <memcmp+0xc>
 8009eda:	e001      	b.n	8009ee0 <memcmp+0x24>
{
	/* Local variables */
	const unsigned char *p_arg_one_l = (unsigned char *)p_arg_one;
	const unsigned char *p_arg_two_l = (unsigned char *)p_arg_two;
	size_t size_l = 0;
	int ret_l = 0;
 8009edc:	2000      	movs	r0, #0
 8009ede:	4770      	bx	lr
		}
	}

	/* Check for return value */
	return (ret_l != 0 ? ret_l : 0);
}
 8009ee0:	bc30      	pop	{r4, r5}
 8009ee2:	4770      	bx	lr

08009ee4 <memcpy>:
	/* Local variables */
	char * p_dest_l = (char *) p_dest;
	const char * p_src_l = (const char *) p_src;
	size_t size_l = 0;

	for( size_l = 0; size_l < size; ++size_l )
 8009ee4:	b152      	cbz	r2, 8009efc <memcpy+0x18>
 * <i>Imp Note:</i>	
 *
 */
void *memcpy( void *__restrict p_dest, const void *__restrict p_src,
				size_t size )
{
 8009ee6:	b410      	push	{r4}
 8009ee8:	1e43      	subs	r3, r0, #1
 8009eea:	188a      	adds	r2, r1, r2
	const char * p_src_l = (const char *) p_src;
	size_t size_l = 0;

	for( size_l = 0; size_l < size; ++size_l )
	{
		*p_dest_l++ = *p_src_l++;
 8009eec:	f811 4b01 	ldrb.w	r4, [r1], #1
 8009ef0:	f803 4f01 	strb.w	r4, [r3, #1]!
	/* Local variables */
	char * p_dest_l = (char *) p_dest;
	const char * p_src_l = (const char *) p_src;
	size_t size_l = 0;

	for( size_l = 0; size_l < size; ++size_l )
 8009ef4:	4291      	cmp	r1, r2
 8009ef6:	d1f9      	bne.n	8009eec <memcpy+0x8>
	#undef LITTLEBLOCKSIZE
	#undef TOO_SMALL

	return p_dest;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 8009ef8:	f85d 4b04 	ldr.w	r4, [sp], #4
 8009efc:	4770      	bx	lr
 8009efe:	bf00      	nop

08009f00 <memmove>:
 *
 * <i>Imp Note:</i>
 *
 */
void *memmove( void *p_dest, const void *p_src, size_t length )
{
 8009f00:	b410      	push	{r4}
#if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
  char *dst = (char *)p_dest;
  const char *src = (const char *)p_src;

  if (src < dst && dst < src + length)
 8009f02:	4288      	cmp	r0, r1
 8009f04:	d801      	bhi.n	8009f0a <memmove+0xa>
	  *--dst = *--src;
	}
    }
  else
    {
      while (length--)
 8009f06:	b96a      	cbnz	r2, 8009f24 <memmove+0x24>
 8009f08:	e014      	b.n	8009f34 <memmove+0x34>
{
#if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
  char *dst = (char *)p_dest;
  const char *src = (const char *)p_src;

  if (src < dst && dst < src + length)
 8009f0a:	188b      	adds	r3, r1, r2
 8009f0c:	4298      	cmp	r0, r3
 8009f0e:	d2fa      	bcs.n	8009f06 <memmove+0x6>
    {
      /* Have to copy backwards */
      src += length;
      dst += length;
 8009f10:	1881      	adds	r1, r0, r2
      while (length--)
 8009f12:	b17a      	cbz	r2, 8009f34 <memmove+0x34>
 8009f14:	1a9a      	subs	r2, r3, r2
	{
	  *--dst = *--src;
 8009f16:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 8009f1a:	f801 4d01 	strb.w	r4, [r1, #-1]!
  if (src < dst && dst < src + length)
    {
      /* Have to copy backwards */
      src += length;
      dst += length;
      while (length--)
 8009f1e:	4293      	cmp	r3, r2
 8009f20:	d1f9      	bne.n	8009f16 <memmove+0x16>
 8009f22:	e007      	b.n	8009f34 <memmove+0x34>
 8009f24:	1e43      	subs	r3, r0, #1
 8009f26:	440a      	add	r2, r1
    }
  else
    {
      while (length--)
	{
	  *dst++ = *src++;
 8009f28:	f811 4b01 	ldrb.w	r4, [r1], #1
 8009f2c:	f803 4f01 	strb.w	r4, [r3, #1]!
	  *--dst = *--src;
	}
    }
  else
    {
      while (length--)
 8009f30:	4291      	cmp	r1, r2
 8009f32:	d1f9      	bne.n	8009f28 <memmove+0x28>
        }
    }

  return p_dest;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 8009f34:	f85d 4b04 	ldr.w	r4, [sp], #4
 8009f38:	4770      	bx	lr
 8009f3a:	bf00      	nop

08009f3c <memset>:
{
	/* Local variables */
	char * p_arg_l = (char *) p_arg;

	/* Fill values in memory with setval */
	while( size-- )
 8009f3c:	b12a      	cbz	r2, 8009f4a <memset+0xe>
 8009f3e:	1882      	adds	r2, r0, r2
 8009f40:	4603      	mov	r3, r0
	{
		*p_arg_l++ = (char) setval;
 8009f42:	f803 1b01 	strb.w	r1, [r3], #1
{
	/* Local variables */
	char * p_arg_l = (char *) p_arg;

	/* Fill values in memory with setval */
	while( size-- )
 8009f46:	4293      	cmp	r3, r2
 8009f48:	d1fb      	bne.n	8009f42 <memset+0x6>
		*p_arg_l++ = (char) setval;
	}

	/* Return starting memory address */
	return p_arg;
}
 8009f4a:	4770      	bx	lr

08009f4c <strcmp>:
	const char *p_arg_two_l = (char *)p_s2;
	size_t size_l = 0;
	int ret_l = 0;

	/* Compare memory for differences */
	for( size_l = 0; (*p_arg_one_l != '\0' || *p_arg_two_l != '\0'); ++size_l )
 8009f4c:	780b      	ldrb	r3, [r1, #0]
 8009f4e:	2b00      	cmp	r3, #0
 8009f50:	d1fd      	bne.n	8009f4e <strcmp+0x2>
		}
	}

	/* Check for return value */
	return (ret_l != 0 ? ret_l : 0);
}
 8009f52:	2000      	movs	r0, #0
 8009f54:	4770      	bx	lr
 8009f56:	bf00      	nop

08009f58 <strcpy>:
	/* Local variables */
	char * p_dest_l = p_dest;
	const char * p_src_l = p_src;

	/* Start copying data from src to dest */
	while( *p_src_l != '\0' )
 8009f58:	780b      	ldrb	r3, [r1, #0]
 8009f5a:	b13b      	cbz	r3, 8009f6c <strcpy+0x14>
 8009f5c:	4602      	mov	r2, r0
	{
		*p_dest_l = *p_src_l;
 8009f5e:	f802 3b01 	strb.w	r3, [r2], #1
	/* Local variables */
	char * p_dest_l = p_dest;
	const char * p_src_l = p_src;

	/* Start copying data from src to dest */
	while( *p_src_l != '\0' )
 8009f62:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 8009f66:	2b00      	cmp	r3, #0
 8009f68:	d1f9      	bne.n	8009f5e <strcpy+0x6>
 8009f6a:	e000      	b.n	8009f6e <strcpy+0x16>
 *
 */
char * strcpy (char * p_dest, const char *p_src)
{
	/* Local variables */
	char * p_dest_l = p_dest;
 8009f6c:	4602      	mov	r2, r0
		/* Increment both src and dest pointers */
		++p_src_l;
		++p_dest_l;
	}
	/* We have reached Null termination */
	*p_dest_l = *p_src_l;
 8009f6e:	2300      	movs	r3, #0
 8009f70:	7013      	strb	r3, [r2, #0]

	/* Return destination pointer */
	return p_dest;
}
 8009f72:	4770      	bx	lr

08009f74 <strlen>:
 *
 * <i>Imp Note:</i>
 *
 */
size_t strlen(const char * p_arg)
{
 8009f74:	4603      	mov	r3, r0
	/* Local variables */
	char * p_arg_l = (char *) p_arg;
	size_t length_l = 0;

	/* Check for Null termination character */
	for( /* Already Initialized */; *p_arg_l != '\0'; ++p_arg_l )
 8009f76:	7802      	ldrb	r2, [r0, #0]
 8009f78:	b132      	cbz	r2, 8009f88 <strlen+0x14>
 8009f7a:	2000      	movs	r0, #0
	{
		length_l += 1;
 8009f7c:	3001      	adds	r0, #1
	/* Local variables */
	char * p_arg_l = (char *) p_arg;
	size_t length_l = 0;

	/* Check for Null termination character */
	for( /* Already Initialized */; *p_arg_l != '\0'; ++p_arg_l )
 8009f7e:	f813 2f01 	ldrb.w	r2, [r3, #1]!
 8009f82:	2a00      	cmp	r2, #0
 8009f84:	d1fa      	bne.n	8009f7c <strlen+0x8>
 8009f86:	4770      	bx	lr
 */
size_t strlen(const char * p_arg)
{
	/* Local variables */
	char * p_arg_l = (char *) p_arg;
	size_t length_l = 0;
 8009f88:	2000      	movs	r0, #0
		length_l += 1;
	}

	/* Return length of string */
	return length_l;
}
 8009f8a:	4770      	bx	lr

08009f8c <_ZN11GPIO_Pins__4initEv>:
 * 	Tasks:
 * 	1. CAN pins needs to be initialized if not working in Loopback mode
 *
 */
void GPIO_Pins__::init( void )
{
 8009f8c:	b538      	push	{r3, r4, r5, lr}
 8009f8e:	4d0f      	ldr	r5, [pc, #60]	; (8009fcc <_ZN11GPIO_Pins__4initEv+0x40>)
 8009f90:	1d2c      	adds	r4, r5, #4
 8009f92:	3554      	adds	r5, #84	; 0x54
	for( pins = 0; pins < ::sg_pins_array_size; ++pins )
	{
		XMC_GPIO_Init( ::sg_gpio_pins[pins].p_port,
						::sg_gpio_pins[pins].pin,
						 &::sg_gpio_pins[pins].config
		);
 8009f94:	f854 0c04 	ldr.w	r0, [r4, #-4]
 8009f98:	7b21      	ldrb	r1, [r4, #12]
 8009f9a:	4622      	mov	r2, r4
 8009f9c:	f7f6 ff02 	bl	8000da4 <XMC_GPIO_Init>
 8009fa0:	3414      	adds	r4, #20
{
	/* Local Variables */
	unsigned char pins = 0;

	/* Initialize Peripherals Pins */
	for( pins = 0; pins < ::sg_pins_array_size; ++pins )
 8009fa2:	42ac      	cmp	r4, r5
 8009fa4:	d1f6      	bne.n	8009f94 <_ZN11GPIO_Pins__4initEv+0x8>
 8009fa6:	4d0a      	ldr	r5, [pc, #40]	; (8009fd0 <_ZN11GPIO_Pins__4initEv+0x44>)
 8009fa8:	1d2c      	adds	r4, r5, #4
 8009faa:	35cc      	adds	r5, #204	; 0xcc
    for( pins = 0; pins < ::sg_eth_gpio_pins_size; ++pins )
    {
        XMC_GPIO_Init( ::sg_eth_gpio_pins[pins].p_port,
                        ::sg_eth_gpio_pins[pins].pin,
                        &::sg_eth_gpio_pins[pins].config
                        );
 8009fac:	f854 0c04 	ldr.w	r0, [r4, #-4]
 8009fb0:	7b21      	ldrb	r1, [r4, #12]
 8009fb2:	4622      	mov	r2, r4
 8009fb4:	f7f6 fef6 	bl	8000da4 <XMC_GPIO_Init>
 8009fb8:	3414      	adds	r4, #20
		);
	}

	#ifdef ETHERNET_USED
    /* Initialize Ethernet pins */
    for( pins = 0; pins < ::sg_eth_gpio_pins_size; ++pins )
 8009fba:	42ac      	cmp	r4, r5
 8009fbc:	d1f6      	bne.n	8009fac <_ZN11GPIO_Pins__4initEv+0x20>
                        );
    }
    /* Initialize HW functionality for Ethernet pins */
    XMC_GPIO_SetHardwareControl( ::sg_eth_gpio_pins[0].p_port, ::sg_eth_gpio_pins[0].pin,
                            XMC_GPIO_HWCTRL_PERIPHERAL1
                            );
 8009fbe:	4805      	ldr	r0, [pc, #20]	; (8009fd4 <_ZN11GPIO_Pins__4initEv+0x48>)
 8009fc0:	2100      	movs	r1, #0
 8009fc2:	2201      	movs	r2, #1
 8009fc4:	f7f7 fc4c 	bl	8001860 <XMC_GPIO_SetHardwareControl>
 8009fc8:	bd38      	pop	{r3, r4, r5, pc}
 8009fca:	bf00      	nop
 8009fcc:	0800ad48 	.word	0x0800ad48
 8009fd0:	0800ac80 	.word	0x0800ac80
 8009fd4:	48028200 	.word	0x48028200

08009fd8 <gpio_init_c>:
extern "C"
{

void gpio_init_c( void );
void gpio_init_c( void )
{
 8009fd8:	b508      	push	{r3, lr}
	/* Initialize Hardware pins functionality options */
	GPIO_Pins__::init();
 8009fda:	f7ff ffd7 	bl	8009f8c <_ZN11GPIO_Pins__4initEv>
 8009fde:	bd08      	pop	{r3, pc}

08009fe0 <CAN_module_init>:
 * <i>Imp Note:</i>
 *
 */
long CAN_module_init( void * p_module, const unsigned char init )
{
	DRIVER_ASSERT( NULL == p_module, CAN_STATUS_INVALID_ARGUMENT );
 8009fe0:	b300      	cbz	r0, 800a024 <CAN_module_init+0x44>
 *
 * <i>Imp Note:</i>
 *
 */
long CAN_module_init( void * p_module, const unsigned char init )
{
 8009fe2:	b538      	push	{r3, r4, r5, lr}
	DRIVER_ASSERT( NULL == p_module, CAN_STATUS_INVALID_ARGUMENT );
	/* Local Variables */
	tStCAN_GlobalModuleConfiguartion * const p_config_l = ((tStCAN_GlobalModule *)p_module)->p_module_config;
 8009fe4:	6804      	ldr	r4, [r0, #0]
	tStCAN_GlobalStatusControl * const p_control_l = ((tStCAN_GlobalModule *)p_module)->p_control;
 8009fe6:	6845      	ldr	r5, [r0, #4]
	unsigned long frequency_l = 0;
	eCAN_Status ret_status = CAN_STATUS_SUCCESS;

	/* Check initialization */
	switch( init )
 8009fe8:	b179      	cbz	r1, 800a00a <CAN_module_init+0x2a>
 8009fea:	2901      	cmp	r1, #1
 8009fec:	d116      	bne.n	800a01c <CAN_module_init+0x3c>
	{
		case CAN_INIT_OPEN:
			frequency_l = XMC_CAN_InitEx( (XMC_CAN_t *const) p_config_l->p_module_context,
 8009fee:	6820      	ldr	r0, [r4, #0]
 8009ff0:	7a21      	ldrb	r1, [r4, #8]
 8009ff2:	6862      	ldr	r2, [r4, #4]
 8009ff4:	f7f7 f914 	bl	8001220 <XMC_CAN_InitEx>
									p_config_l->clock_source, p_config_l->frequency );
			/* Cross check the frequency */
			if( frequency_l == p_config_l->frequency )
 8009ff8:	6863      	ldr	r3, [r4, #4]
 8009ffa:	4283      	cmp	r3, r0
 8009ffc:	d110      	bne.n	800a020 <CAN_module_init+0x40>
			{
				/* Update initialization status */
				p_control_l->init = 1;
 8009ffe:	682b      	ldr	r3, [r5, #0]
 800a000:	f043 0301 	orr.w	r3, r3, #1
 800a004:	602b      	str	r3, [r5, #0]
	DRIVER_ASSERT( NULL == p_module, CAN_STATUS_INVALID_ARGUMENT );
	/* Local Variables */
	tStCAN_GlobalModuleConfiguartion * const p_config_l = ((tStCAN_GlobalModule *)p_module)->p_module_config;
	tStCAN_GlobalStatusControl * const p_control_l = ((tStCAN_GlobalModule *)p_module)->p_control;
	unsigned long frequency_l = 0;
	eCAN_Status ret_status = CAN_STATUS_SUCCESS;
 800a006:	2000      	movs	r0, #0
 800a008:	bd38      	pop	{r3, r4, r5, pc}
			}
			break;

		case CAN_INIT_CLOSE:
			/* Disable CAN */
			XMC_CAN_Disable( (XMC_CAN_t *const) p_config_l->p_module_context );
 800a00a:	6820      	ldr	r0, [r4, #0]
 800a00c:	f7f7 f8ee 	bl	80011ec <XMC_CAN_Disable>
			/* Update initialization status */
			p_control_l->init = 0;
 800a010:	682b      	ldr	r3, [r5, #0]
 800a012:	f023 0301 	bic.w	r3, r3, #1
 800a016:	602b      	str	r3, [r5, #0]
	DRIVER_ASSERT( NULL == p_module, CAN_STATUS_INVALID_ARGUMENT );
	/* Local Variables */
	tStCAN_GlobalModuleConfiguartion * const p_config_l = ((tStCAN_GlobalModule *)p_module)->p_module_config;
	tStCAN_GlobalStatusControl * const p_control_l = ((tStCAN_GlobalModule *)p_module)->p_control;
	unsigned long frequency_l = 0;
	eCAN_Status ret_status = CAN_STATUS_SUCCESS;
 800a018:	2000      	movs	r0, #0
		case CAN_INIT_CLOSE:
			/* Disable CAN */
			XMC_CAN_Disable( (XMC_CAN_t *const) p_config_l->p_module_context );
			/* Update initialization status */
			p_control_l->init = 0;
			break;
 800a01a:	bd38      	pop	{r3, r4, r5, pc}

		default:
			ret_status = CAN_STATUS_INVALID_ARGUMENT;
 800a01c:	2003      	movs	r0, #3
 800a01e:	bd38      	pop	{r3, r4, r5, pc}
				/* Update initialization status */
				p_control_l->init = 1;
			}
			else
			{
				ret_status = CAN_STATUS_FAILED;
 800a020:	2001      	movs	r0, #1
		default:
			ret_status = CAN_STATUS_INVALID_ARGUMENT;
	}

	/* Return status */
	return ret_status;
 800a022:	bd38      	pop	{r3, r4, r5, pc}
 * <i>Imp Note:</i>
 *
 */
long CAN_module_init( void * p_module, const unsigned char init )
{
	DRIVER_ASSERT( NULL == p_module, CAN_STATUS_INVALID_ARGUMENT );
 800a024:	2003      	movs	r0, #3
 800a026:	4770      	bx	lr

0800a028 <CAN_node_init>:
 * <i>Imp Note:</i>
 *
 */
long CAN_node_init( void * p_channel, const unsigned char node, const unsigned char init )
{
	DRIVER_ASSERT( NULL == p_channel, CAN_STATUS_INVALID_ARGUMENT );
 800a028:	2800      	cmp	r0, #0
 800a02a:	f000 816d 	beq.w	800a308 <CAN_node_init+0x2e0>
 *
 * <i>Imp Note:</i>
 *
 */
long CAN_node_init( void * p_channel, const unsigned char node, const unsigned char init )
{
 800a02e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	DRIVER_ASSERT( NULL == p_channel, CAN_STATUS_INVALID_ARGUMENT );
	/* Local Variables */
	tStCAN_NodeConfiguartion * const p_config_l = ((tStCAN_Node *)p_channel)->p_config;
 800a030:	6804      	ldr	r4, [r0, #0]
	tStCAN_Control * const p_control_l = ((tStCAN_Node *)p_channel)->p_control;
 800a032:	6845      	ldr	r5, [r0, #4]
	long status_l = -1;
	eCAN_Status ret_status = CAN_STATUS_FAILED;


	/* Check initialization */
	switch( init )
 800a034:	2a00      	cmp	r2, #0
 800a036:	f000 8156 	beq.w	800a2e6 <CAN_node_init+0x2be>
 800a03a:	2a01      	cmp	r2, #1
 800a03c:	f040 815e 	bne.w	800a2fc <CAN_node_init+0x2d4>
	{
		case CAN_INIT_OPEN:
			/* Check already opened or not */
			if( 1 == p_control_l->state.init )
 800a040:	682b      	ldr	r3, [r5, #0]
 800a042:	f013 0f01 	tst.w	r3, #1
 800a046:	f040 815b 	bne.w	800a300 <CAN_node_init+0x2d8>
			{
				ret_status = CAN_STATUS_ALREADY_INITIALIZED;
			}
			else
			{
				p_control_l->state.node = (unsigned long) (node & 0x03);
 800a04a:	782b      	ldrb	r3, [r5, #0]
 800a04c:	f361 03c4 	bfi	r3, r1, #3, #2
 800a050:	702b      	strb	r3, [r5, #0]
				status_l = XMC_CAN_NODE_NominalBitTimeConfigureEx( (XMC_CAN_NODE_t *const) p_config_l->p_channel_context,
 800a052:	6820      	ldr	r0, [r4, #0]
 800a054:	6861      	ldr	r1, [r4, #4]
 800a056:	f7f7 f857 	bl	8001108 <XMC_CAN_NODE_NominalBitTimeConfigureEx>
									(const XMC_CAN_NODE_NOMINAL_BIT_TIME_CONFIG_t *const) p_config_l->p_bit_time_config );

				/* Check status */
				if( XMC_CAN_STATUS_SUCCESS == status_l )
 800a05a:	4606      	mov	r6, r0
 800a05c:	2800      	cmp	r0, #0
 800a05e:	f040 8151 	bne.w	800a304 <CAN_node_init+0x2dc>
				{
					/* Allow changes to CAN Control */
					XMC_CAN_NODE_EnableConfigurationChange( (XMC_CAN_NODE_t *const) p_config_l->p_channel_context );
 800a062:	6822      	ldr	r2, [r4, #0]
 *
 */

__STATIC_INLINE void XMC_CAN_NODE_EnableConfigurationChange(XMC_CAN_NODE_t *const can_node)
{
  can_node->NCR |= (uint32_t)CAN_NODE_NCR_CCE_Msk;
 800a064:	6813      	ldr	r3, [r2, #0]
 800a066:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800a06a:	6013      	str	r3, [r2, #0]

					/* Configure Tx and Rx Message Objects */
					XMC_CAN_MO_Config( (const XMC_CAN_MO_t *const) p_config_l->p_message_tx );
 800a06c:	68a0      	ldr	r0, [r4, #8]
 800a06e:	f7f7 f91b 	bl	80012a8 <XMC_CAN_MO_Config>
					XMC_CAN_MO_Config( (const XMC_CAN_MO_t *const) p_config_l->p_message_rx );
 800a072:	68e0      	ldr	r0, [r4, #12]
 800a074:	f7f7 f918 	bl	80012a8 <XMC_CAN_MO_Config>

					XMC_CAN_AllocateMOtoNodeList( CAN_GLOBAL, (unsigned char)p_control_l->state.node,
 800a078:	4fa4      	ldr	r7, [pc, #656]	; (800a30c <CAN_node_init+0x2e4>)
 800a07a:	7829      	ldrb	r1, [r5, #0]
 800a07c:	4638      	mov	r0, r7
 800a07e:	f3c1 01c1 	ubfx	r1, r1, #3, #2
 800a082:	7c22      	ldrb	r2, [r4, #16]
 800a084:	f7f7 f8a4 	bl	80011d0 <XMC_CAN_AllocateMOtoNodeList>
											(unsigned char)(p_config_l->message_tx_number & 0xFF) );
					XMC_CAN_AllocateMOtoNodeList( CAN_GLOBAL, (unsigned char)p_control_l->state.node,
 800a088:	7829      	ldrb	r1, [r5, #0]
 800a08a:	4638      	mov	r0, r7
 800a08c:	f3c1 01c1 	ubfx	r1, r1, #3, #2
 800a090:	7ca2      	ldrb	r2, [r4, #18]
 800a092:	f7f7 f89d 	bl	80011d0 <XMC_CAN_AllocateMOtoNodeList>
											(unsigned char)(p_config_l->message_rx_number & 0xFF) );

					/* If loopback is enabled then GPIO pins shall not be initialized */
					if( XMC_CAN_LOOKBACKMODE_ENABLED == p_config_l->loopback )
 800a096:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
 800a09a:	b92b      	cbnz	r3, 800a0a8 <CAN_node_init+0x80>
					{
						XMC_CAN_NODE_EnableLoopBack( (XMC_CAN_NODE_t *const) p_config_l->p_channel_context );
 800a09c:	6822      	ldr	r2, [r4, #0]
 *
 */

__STATIC_INLINE void XMC_CAN_NODE_EnableLoopBack(XMC_CAN_NODE_t *const can_node)
{
  can_node->NPCR |= (uint32_t)CAN_NODE_NPCR_LBM_Msk;
 800a09e:	68d3      	ldr	r3, [r2, #12]
 800a0a0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800a0a4:	60d3      	str	r3, [r2, #12]
 800a0a6:	e009      	b.n	800a0bc <CAN_node_init+0x94>
					}
					else
					{
						XMC_CAN_NODE_SetReceiveInput( (XMC_CAN_NODE_t *const) p_config_l->p_channel_context,
 800a0a8:	6821      	ldr	r1, [r4, #0]
 */

__STATIC_INLINE void XMC_CAN_NODE_SetReceiveInput(XMC_CAN_NODE_t *const can_node,
                                              const XMC_CAN_NODE_RECEIVE_INPUT_t input)
{
  can_node->NPCR = ((can_node->NPCR) & ~(uint32_t)(CAN_NODE_NPCR_RXSEL_Msk)) |
 800a0aa:	68cb      	ldr	r3, [r1, #12]
                   (((uint32_t)input << CAN_NODE_NPCR_RXSEL_Pos) & (uint32_t)CAN_NODE_NPCR_RXSEL_Msk);
 800a0ac:	f894 2026 	ldrb.w	r2, [r4, #38]	; 0x26
 800a0b0:	f002 0207 	and.w	r2, r2, #7
 */

__STATIC_INLINE void XMC_CAN_NODE_SetReceiveInput(XMC_CAN_NODE_t *const can_node,
                                              const XMC_CAN_NODE_RECEIVE_INPUT_t input)
{
  can_node->NPCR = ((can_node->NPCR) & ~(uint32_t)(CAN_NODE_NPCR_RXSEL_Msk)) |
 800a0b4:	f023 0307 	bic.w	r3, r3, #7
 800a0b8:	4313      	orrs	r3, r2
 800a0ba:	60cb      	str	r3, [r1, #12]
					}

					/* Interrupt Configurations for CAN Node */
					#if (CAN_USING_INTERRUPT == 1U)
					/* Set Error Event Nodes */
					XMC_CAN_NODE_SetEventNodePointer( (XMC_CAN_NODE_t *const) p_config_l->p_channel_context,
 800a0bc:	6821      	ldr	r1, [r4, #0]

__STATIC_INLINE void XMC_CAN_NODE_SetEventNodePointer(XMC_CAN_NODE_t *const can_node,
                                          const XMC_CAN_NODE_POINTER_EVENT_t ptr_event,
                                          const uint32_t service_request)
{
  can_node->NIPR = (uint32_t)((can_node->NIPR) & ~(uint32_t)(CAN_NODE_NIPR_Msk << (uint32_t)ptr_event)) | (service_request << (uint32_t)ptr_event);
 800a0be:	688b      	ldr	r3, [r1, #8]
 800a0c0:	f023 0207 	bic.w	r2, r3, #7
 800a0c4:	69e3      	ldr	r3, [r4, #28]
 800a0c6:	685b      	ldr	r3, [r3, #4]
 800a0c8:	4313      	orrs	r3, r2
 800a0ca:	608b      	str	r3, [r1, #8]
										XMC_CAN_NODE_POINTER_EVENT_ALERT, p_config_l->isr_event_conifg->sr );
					XMC_CAN_NODE_SetEventNodePointer( (XMC_CAN_NODE_t *const) p_config_l->p_channel_context,
 800a0cc:	6822      	ldr	r2, [r4, #0]
 800a0ce:	6893      	ldr	r3, [r2, #8]
 800a0d0:	69e1      	ldr	r1, [r4, #28]
 800a0d2:	6849      	ldr	r1, [r1, #4]
 800a0d4:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800a0d8:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
 800a0dc:	6093      	str	r3, [r2, #8]
										XMC_CAN_NODE_POINTER_EVENT_LEC, p_config_l->isr_event_conifg->sr );
					XMC_CAN_NODE_SetEventNodePointer( (XMC_CAN_NODE_t *const) p_config_l->p_channel_context,
 800a0de:	6822      	ldr	r2, [r4, #0]
 800a0e0:	6893      	ldr	r3, [r2, #8]
 800a0e2:	69e1      	ldr	r1, [r4, #28]
 800a0e4:	6849      	ldr	r1, [r1, #4]
 800a0e6:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800a0ea:	ea43 3301 	orr.w	r3, r3, r1, lsl #12
 800a0ee:	6093      	str	r3, [r2, #8]
								XMC_CAN_NODE_POINTER_EVENT_FRAME_COUNTER, p_config_l->isr_event_conifg->sr );

					/* Set Transfer Event Nodes */
					XMC_CAN_NODE_SetEventNodePointer( (XMC_CAN_NODE_t *const) p_config_l->p_channel_context,
 800a0f0:	6822      	ldr	r2, [r4, #0]
 800a0f2:	6893      	ldr	r3, [r2, #8]
 800a0f4:	6961      	ldr	r1, [r4, #20]
 800a0f6:	6849      	ldr	r1, [r1, #4]
 800a0f8:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 800a0fc:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 800a100:	6093      	str	r3, [r2, #8]

__STATIC_INLINE void XMC_CAN_MO_SetEventNodePointer(const XMC_CAN_MO_t *const can_mo,
                                                const XMC_CAN_MO_POINTER_EVENT_t can_mo_ptr_int,
                                                const uint32_t service_request)
{
  can_mo->can_mo_ptr->MOIPR = ((can_mo->can_mo_ptr->MOIPR ) & ~(uint32_t)((uint32_t)CAN_MO_MOIPR_Msk << (uint32_t)can_mo_ptr_int)) |
 800a102:	68a3      	ldr	r3, [r4, #8]
 800a104:	681a      	ldr	r2, [r3, #0]
 800a106:	6893      	ldr	r3, [r2, #8]
									XMC_CAN_NODE_POINTER_EVENT_TRANSFER_OK, p_config_l->isr_config->sr );

					/* Set Message Object Events Node Pointer */
					XMC_CAN_MO_SetEventNodePointer( p_config_l->p_message_tx,
 800a108:	69a1      	ldr	r1, [r4, #24]
                          (service_request << (uint32_t)can_mo_ptr_int);
 800a10a:	6849      	ldr	r1, [r1, #4]

__STATIC_INLINE void XMC_CAN_MO_SetEventNodePointer(const XMC_CAN_MO_t *const can_mo,
                                                const XMC_CAN_MO_POINTER_EVENT_t can_mo_ptr_int,
                                                const uint32_t service_request)
{
  can_mo->can_mo_ptr->MOIPR = ((can_mo->can_mo_ptr->MOIPR ) & ~(uint32_t)((uint32_t)CAN_MO_MOIPR_Msk << (uint32_t)can_mo_ptr_int)) |
 800a10c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800a110:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
 800a114:	6093      	str	r3, [r2, #8]
 800a116:	68a3      	ldr	r3, [r4, #8]
 800a118:	6819      	ldr	r1, [r3, #0]
 800a11a:	688b      	ldr	r3, [r1, #8]
 800a11c:	f023 0207 	bic.w	r2, r3, #7
										XMC_CAN_MO_POINTER_EVENT_TRANSMIT, p_config_l->isr_mo_conifg->sr );
					XMC_CAN_MO_SetEventNodePointer( p_config_l->p_message_tx,
 800a120:	69a3      	ldr	r3, [r4, #24]
 800a122:	685b      	ldr	r3, [r3, #4]
 800a124:	4313      	orrs	r3, r2
 800a126:	608b      	str	r3, [r1, #8]
 */

__STATIC_INLINE void XMC_CAN_MO_EnableEvent(const XMC_CAN_MO_t *const can_mo,
                                        const uint32_t event)
{
  can_mo->can_mo_ptr->MOFCR |= event;
 800a128:	68a3      	ldr	r3, [r4, #8]
 800a12a:	681a      	ldr	r2, [r3, #0]
 800a12c:	6813      	ldr	r3, [r2, #0]
 800a12e:	f043 0304 	orr.w	r3, r3, #4
 800a132:	6013      	str	r3, [r2, #0]
 800a134:	68a3      	ldr	r3, [r4, #8]
 800a136:	681b      	ldr	r3, [r3, #0]
 800a138:	681a      	ldr	r2, [r3, #0]
 800a13a:	601a      	str	r2, [r3, #0]

					XMC_CAN_MO_EnableEvent( p_config_l->p_message_tx, XMC_CAN_MO_POINTER_EVENT_TRANSMIT );
					XMC_CAN_MO_EnableEvent( p_config_l->p_message_tx, XMC_CAN_MO_POINTER_EVENT_RECEIVE );

					#if (CAN_USING_EVENTS == 1U)
					for( status_l = 0; status_l < (long)p_config_l->events; ++status_l )
 800a13c:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
 800a140:	b153      	cbz	r3, 800a158 <CAN_node_init+0x130>
					{
						XMC_CAN_NODE_EnableEvent( (XMC_CAN_NODE_t *const) p_config_l->p_channel_context,
													p_config_l->p_events[status_l] );
 800a142:	6a23      	ldr	r3, [r4, #32]
					XMC_CAN_MO_EnableEvent( p_config_l->p_message_tx, XMC_CAN_MO_POINTER_EVENT_RECEIVE );

					#if (CAN_USING_EVENTS == 1U)
					for( status_l = 0; status_l < (long)p_config_l->events; ++status_l )
					{
						XMC_CAN_NODE_EnableEvent( (XMC_CAN_NODE_t *const) p_config_l->p_channel_context,
 800a144:	6820      	ldr	r0, [r4, #0]
 800a146:	f853 1026 	ldr.w	r1, [r3, r6, lsl #2]
 800a14a:	f7f7 f919 	bl	8001380 <XMC_CAN_NODE_EnableEvent>

					XMC_CAN_MO_EnableEvent( p_config_l->p_message_tx, XMC_CAN_MO_POINTER_EVENT_TRANSMIT );
					XMC_CAN_MO_EnableEvent( p_config_l->p_message_tx, XMC_CAN_MO_POINTER_EVENT_RECEIVE );

					#if (CAN_USING_EVENTS == 1U)
					for( status_l = 0; status_l < (long)p_config_l->events; ++status_l )
 800a14e:	3601      	adds	r6, #1
 800a150:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
 800a154:	42b3      	cmp	r3, r6
 800a156:	dcf4      	bgt.n	800a142 <CAN_node_init+0x11a>
					{
						XMC_CAN_NODE_EnableEvent( (XMC_CAN_NODE_t *const) p_config_l->p_channel_context,
													p_config_l->p_events[status_l] );
					}
					/* Setup NVIC for CAN Events */
					NVIC_SetPriority( (IRQn_Type)p_config_l->isr_event_conifg->irq.irq_num,
 800a158:	69e3      	ldr	r3, [r4, #28]
 800a15a:	781e      	ldrb	r6, [r3, #0]
 800a15c:	b2f0      	uxtb	r0, r6
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 800a15e:	4a6c      	ldr	r2, [pc, #432]	; (800a310 <CAN_node_init+0x2e8>)
 800a160:	68d1      	ldr	r1, [r2, #12]
						NVIC_EncodePriority(NVIC_GetPriorityGrouping(), p_config_l->isr_event_conifg->irq.irq_priority, 0U) );
 800a162:	785b      	ldrb	r3, [r3, #1]
					{
						XMC_CAN_NODE_EnableEvent( (XMC_CAN_NODE_t *const) p_config_l->p_channel_context,
													p_config_l->p_events[status_l] );
					}
					/* Setup NVIC for CAN Events */
					NVIC_SetPriority( (IRQn_Type)p_config_l->isr_event_conifg->irq.irq_num,
 800a164:	f003 027f 	and.w	r2, r3, #127	; 0x7f
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 800a168:	f3c1 2302 	ubfx	r3, r1, #8, #3
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800a16c:	f1c3 0707 	rsb	r7, r3, #7
 800a170:	2f06      	cmp	r7, #6
 800a172:	bf28      	it	cs
 800a174:	2706      	movcs	r7, #6
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800a176:	1d99      	adds	r1, r3, #6
 800a178:	2906      	cmp	r1, #6
 800a17a:	bf8c      	ite	hi
 800a17c:	f103 31ff 	addhi.w	r1, r3, #4294967295
 800a180:	2100      	movls	r1, #0

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800a182:	2301      	movs	r3, #1
 800a184:	40bb      	lsls	r3, r7
 800a186:	3b01      	subs	r3, #1
 800a188:	4013      	ands	r3, r2
 800a18a:	408b      	lsls	r3, r1
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 800a18c:	f010 0f80 	tst.w	r0, #128	; 0x80
 800a190:	d107      	bne.n	800a1a2 <CAN_node_init+0x17a>
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800a192:	009b      	lsls	r3, r3, #2
 800a194:	b2db      	uxtb	r3, r3
 800a196:	4a5f      	ldr	r2, [pc, #380]	; (800a314 <CAN_node_init+0x2ec>)
 800a198:	fa42 f080 	sxtab	r0, r2, r0
 800a19c:	f880 3300 	strb.w	r3, [r0, #768]	; 0x300
 800a1a0:	e005      	b.n	800a1ae <CAN_node_init+0x186>
  }
  else
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800a1a2:	f006 060f 	and.w	r6, r6, #15
 800a1a6:	009b      	lsls	r3, r3, #2
 800a1a8:	b2db      	uxtb	r3, r3
 800a1aa:	4a5b      	ldr	r2, [pc, #364]	; (800a318 <CAN_node_init+0x2f0>)
 800a1ac:	5593      	strb	r3, [r2, r6]
						NVIC_EncodePriority(NVIC_GetPriorityGrouping(), p_config_l->isr_event_conifg->irq.irq_priority, 0U) );
					NVIC_EnableIRQ( (IRQn_Type)p_config_l->isr_event_conifg->irq.irq_num );
 800a1ae:	69e3      	ldr	r3, [r4, #28]
 800a1b0:	781a      	ldrb	r2, [r3, #0]
 800a1b2:	b2d3      	uxtb	r3, r2
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
 800a1b4:	f013 0f80 	tst.w	r3, #128	; 0x80
 800a1b8:	d109      	bne.n	800a1ce <CAN_node_init+0x1a6>
  {
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 800a1ba:	b25b      	sxtb	r3, r3
 800a1bc:	095b      	lsrs	r3, r3, #5
 800a1be:	f002 021f 	and.w	r2, r2, #31
 800a1c2:	2101      	movs	r1, #1
 800a1c4:	fa01 f202 	lsl.w	r2, r1, r2
 800a1c8:	4952      	ldr	r1, [pc, #328]	; (800a314 <CAN_node_init+0x2ec>)
 800a1ca:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
					#endif	/* CAN_USING_EVENTS */

					/* Setup NVIC for CAN Transfer */
					NVIC_SetPriority( (IRQn_Type)p_config_l->isr_config->irq.irq_num,
 800a1ce:	6963      	ldr	r3, [r4, #20]
 800a1d0:	781e      	ldrb	r6, [r3, #0]
 800a1d2:	b2f0      	uxtb	r0, r6
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 800a1d4:	4b4e      	ldr	r3, [pc, #312]	; (800a310 <CAN_node_init+0x2e8>)
 800a1d6:	68d9      	ldr	r1, [r3, #12]
						NVIC_EncodePriority(NVIC_GetPriorityGrouping(), p_config_l->isr_event_conifg->irq.irq_priority, 0U) );
 800a1d8:	69e3      	ldr	r3, [r4, #28]
 800a1da:	785b      	ldrb	r3, [r3, #1]
						NVIC_EncodePriority(NVIC_GetPriorityGrouping(), p_config_l->isr_event_conifg->irq.irq_priority, 0U) );
					NVIC_EnableIRQ( (IRQn_Type)p_config_l->isr_event_conifg->irq.irq_num );
					#endif	/* CAN_USING_EVENTS */

					/* Setup NVIC for CAN Transfer */
					NVIC_SetPriority( (IRQn_Type)p_config_l->isr_config->irq.irq_num,
 800a1dc:	f003 027f 	and.w	r2, r3, #127	; 0x7f
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 800a1e0:	f3c1 2302 	ubfx	r3, r1, #8, #3
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800a1e4:	f1c3 0707 	rsb	r7, r3, #7
 800a1e8:	2f06      	cmp	r7, #6
 800a1ea:	bf28      	it	cs
 800a1ec:	2706      	movcs	r7, #6
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800a1ee:	1d99      	adds	r1, r3, #6
 800a1f0:	2906      	cmp	r1, #6
 800a1f2:	bf8c      	ite	hi
 800a1f4:	f103 31ff 	addhi.w	r1, r3, #4294967295
 800a1f8:	2100      	movls	r1, #0

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800a1fa:	2301      	movs	r3, #1
 800a1fc:	40bb      	lsls	r3, r7
 800a1fe:	3b01      	subs	r3, #1
 800a200:	4013      	ands	r3, r2
 800a202:	408b      	lsls	r3, r1
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 800a204:	f010 0f80 	tst.w	r0, #128	; 0x80
 800a208:	d107      	bne.n	800a21a <CAN_node_init+0x1f2>
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800a20a:	009b      	lsls	r3, r3, #2
 800a20c:	b2db      	uxtb	r3, r3
 800a20e:	4a41      	ldr	r2, [pc, #260]	; (800a314 <CAN_node_init+0x2ec>)
 800a210:	fa42 f080 	sxtab	r0, r2, r0
 800a214:	f880 3300 	strb.w	r3, [r0, #768]	; 0x300
 800a218:	e005      	b.n	800a226 <CAN_node_init+0x1fe>
  }
  else
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800a21a:	f006 060f 	and.w	r6, r6, #15
 800a21e:	009b      	lsls	r3, r3, #2
 800a220:	b2db      	uxtb	r3, r3
 800a222:	4a3d      	ldr	r2, [pc, #244]	; (800a318 <CAN_node_init+0x2f0>)
 800a224:	5593      	strb	r3, [r2, r6]
						NVIC_EncodePriority(NVIC_GetPriorityGrouping(), p_config_l->isr_event_conifg->irq.irq_priority, 0U) );
					NVIC_EnableIRQ( (IRQn_Type)p_config_l->isr_config->irq.irq_num );
 800a226:	6963      	ldr	r3, [r4, #20]
 800a228:	781a      	ldrb	r2, [r3, #0]
 800a22a:	b2d3      	uxtb	r3, r2
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
 800a22c:	f013 0f80 	tst.w	r3, #128	; 0x80
 800a230:	d109      	bne.n	800a246 <CAN_node_init+0x21e>
  {
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 800a232:	b25b      	sxtb	r3, r3
 800a234:	095b      	lsrs	r3, r3, #5
 800a236:	f002 021f 	and.w	r2, r2, #31
 800a23a:	2101      	movs	r1, #1
 800a23c:	fa01 f202 	lsl.w	r2, r1, r2
 800a240:	4934      	ldr	r1, [pc, #208]	; (800a314 <CAN_node_init+0x2ec>)
 800a242:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
					/* Setup NVIC for CAN MO */
					NVIC_SetPriority( (IRQn_Type)p_config_l->isr_mo_conifg->irq.irq_num,
 800a246:	69a3      	ldr	r3, [r4, #24]
 800a248:	781e      	ldrb	r6, [r3, #0]
 800a24a:	b2f0      	uxtb	r0, r6
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 800a24c:	4b30      	ldr	r3, [pc, #192]	; (800a310 <CAN_node_init+0x2e8>)
 800a24e:	68d9      	ldr	r1, [r3, #12]
						NVIC_EncodePriority(NVIC_GetPriorityGrouping(), p_config_l->isr_event_conifg->irq.irq_priority, 0U) );
 800a250:	69e3      	ldr	r3, [r4, #28]
 800a252:	785b      	ldrb	r3, [r3, #1]
					/* Setup NVIC for CAN Transfer */
					NVIC_SetPriority( (IRQn_Type)p_config_l->isr_config->irq.irq_num,
						NVIC_EncodePriority(NVIC_GetPriorityGrouping(), p_config_l->isr_event_conifg->irq.irq_priority, 0U) );
					NVIC_EnableIRQ( (IRQn_Type)p_config_l->isr_config->irq.irq_num );
					/* Setup NVIC for CAN MO */
					NVIC_SetPriority( (IRQn_Type)p_config_l->isr_mo_conifg->irq.irq_num,
 800a254:	f003 027f 	and.w	r2, r3, #127	; 0x7f
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 800a258:	f3c1 2302 	ubfx	r3, r1, #8, #3
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800a25c:	f1c3 0707 	rsb	r7, r3, #7
 800a260:	2f06      	cmp	r7, #6
 800a262:	bf28      	it	cs
 800a264:	2706      	movcs	r7, #6
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800a266:	1d99      	adds	r1, r3, #6
 800a268:	2906      	cmp	r1, #6
 800a26a:	bf8c      	ite	hi
 800a26c:	f103 31ff 	addhi.w	r1, r3, #4294967295
 800a270:	2100      	movls	r1, #0

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800a272:	2301      	movs	r3, #1
 800a274:	40bb      	lsls	r3, r7
 800a276:	3b01      	subs	r3, #1
 800a278:	4013      	ands	r3, r2
 800a27a:	408b      	lsls	r3, r1
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 800a27c:	f010 0f80 	tst.w	r0, #128	; 0x80
 800a280:	d107      	bne.n	800a292 <CAN_node_init+0x26a>
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800a282:	009b      	lsls	r3, r3, #2
 800a284:	b2db      	uxtb	r3, r3
 800a286:	4a23      	ldr	r2, [pc, #140]	; (800a314 <CAN_node_init+0x2ec>)
 800a288:	fa42 f080 	sxtab	r0, r2, r0
 800a28c:	f880 3300 	strb.w	r3, [r0, #768]	; 0x300
 800a290:	e005      	b.n	800a29e <CAN_node_init+0x276>
  }
  else
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800a292:	f006 060f 	and.w	r6, r6, #15
 800a296:	009b      	lsls	r3, r3, #2
 800a298:	b2db      	uxtb	r3, r3
 800a29a:	4a1f      	ldr	r2, [pc, #124]	; (800a318 <CAN_node_init+0x2f0>)
 800a29c:	5593      	strb	r3, [r2, r6]
						NVIC_EncodePriority(NVIC_GetPriorityGrouping(), p_config_l->isr_event_conifg->irq.irq_priority, 0U) );
					NVIC_EnableIRQ( (IRQn_Type)p_config_l->isr_mo_conifg->irq.irq_num );
 800a29e:	69a3      	ldr	r3, [r4, #24]
 800a2a0:	781a      	ldrb	r2, [r3, #0]
 800a2a2:	b2d3      	uxtb	r3, r2
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
 800a2a4:	f013 0f80 	tst.w	r3, #128	; 0x80
 800a2a8:	d109      	bne.n	800a2be <CAN_node_init+0x296>
  {
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 800a2aa:	b25b      	sxtb	r3, r3
 800a2ac:	095b      	lsrs	r3, r3, #5
 800a2ae:	f002 021f 	and.w	r2, r2, #31
 800a2b2:	2101      	movs	r1, #1
 800a2b4:	fa01 f202 	lsl.w	r2, r1, r2
 800a2b8:	4916      	ldr	r1, [pc, #88]	; (800a314 <CAN_node_init+0x2ec>)
 800a2ba:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
					#endif	/* CAN_USING_INTERRUPT */

					/* ENable CAN Node */
					XMC_CAN_NODE_Enable( (XMC_CAN_NODE_t *const) p_config_l->p_channel_context );
 800a2be:	6823      	ldr	r3, [r4, #0]
 * None
 *
 */
__STATIC_INLINE void XMC_CAN_NODE_Enable(XMC_CAN_NODE_t *const can_node)
{
  can_node->NCR &= ~(uint32_t)CAN_NODE_NCR_CANDIS_Msk;
 800a2c0:	681a      	ldr	r2, [r3, #0]
 800a2c2:	f022 0210 	bic.w	r2, r2, #16
 800a2c6:	601a      	str	r2, [r3, #0]
 * XMC_CAN_NODE_SetInitBit()
 *
 */
__STATIC_INLINE void XMC_CAN_NODE_ResetInitBit(XMC_CAN_NODE_t *const can_node)
{
  can_node->NCR &= ~(uint32_t)CAN_NODE_NCR_INIT_Msk;
 800a2c8:	681a      	ldr	r2, [r3, #0]
 800a2ca:	f022 0201 	bic.w	r2, r2, #1
 800a2ce:	601a      	str	r2, [r3, #0]

					/* Disbale CAN Node configuration changes */
					XMC_CAN_NODE_DisableConfigurationChange( (XMC_CAN_NODE_t *const) p_config_l->p_channel_context );
 800a2d0:	6822      	ldr	r2, [r4, #0]
 *
 */

__STATIC_INLINE void XMC_CAN_NODE_DisableConfigurationChange(XMC_CAN_NODE_t *const can_node)
{
  can_node->NCR &= ~(uint32_t)CAN_NODE_NCR_CCE_Msk;
 800a2d2:	6813      	ldr	r3, [r2, #0]
 800a2d4:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800a2d8:	6013      	str	r3, [r2, #0]

					/* Update status */
					p_control_l->state.init = 1;
 800a2da:	682b      	ldr	r3, [r5, #0]
 800a2dc:	f043 0301 	orr.w	r3, r3, #1
 800a2e0:	602b      	str	r3, [r5, #0]
	DRIVER_ASSERT( NULL == p_channel, CAN_STATUS_INVALID_ARGUMENT );
	/* Local Variables */
	tStCAN_NodeConfiguartion * const p_config_l = ((tStCAN_Node *)p_channel)->p_config;
	tStCAN_Control * const p_control_l = ((tStCAN_Node *)p_channel)->p_control;
	long status_l = -1;
	eCAN_Status ret_status = CAN_STATUS_FAILED;
 800a2e2:	2001      	movs	r0, #1
 800a2e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			}
			break;

		case CAN_INIT_CLOSE:
			/* Disbale CAN Node */
			XMC_CAN_NODE_Disable( (XMC_CAN_NODE_t *const) p_config_l->p_channel_context );
 800a2e6:	6822      	ldr	r2, [r4, #0]
 * None
 *
 */
__STATIC_INLINE void XMC_CAN_NODE_Disable(XMC_CAN_NODE_t *const can_node)
{
  can_node->NCR |= (uint32_t)CAN_NODE_NCR_CANDIS_Msk;
 800a2e8:	6813      	ldr	r3, [r2, #0]
 800a2ea:	f043 0310 	orr.w	r3, r3, #16
 800a2ee:	6013      	str	r3, [r2, #0]
			/* Update status */
			p_control_l->state.init = 0;
 800a2f0:	682b      	ldr	r3, [r5, #0]
 800a2f2:	f023 0301 	bic.w	r3, r3, #1
 800a2f6:	602b      	str	r3, [r5, #0]
	DRIVER_ASSERT( NULL == p_channel, CAN_STATUS_INVALID_ARGUMENT );
	/* Local Variables */
	tStCAN_NodeConfiguartion * const p_config_l = ((tStCAN_Node *)p_channel)->p_config;
	tStCAN_Control * const p_control_l = ((tStCAN_Node *)p_channel)->p_control;
	long status_l = -1;
	eCAN_Status ret_status = CAN_STATUS_FAILED;
 800a2f8:	2001      	movs	r0, #1
		case CAN_INIT_CLOSE:
			/* Disbale CAN Node */
			XMC_CAN_NODE_Disable( (XMC_CAN_NODE_t *const) p_config_l->p_channel_context );
			/* Update status */
			p_control_l->state.init = 0;
			break;
 800a2fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

		default:
			ret_status = CAN_STATUS_INVALID_ARGUMENT;
 800a2fc:	2003      	movs	r0, #3
 800a2fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	{
		case CAN_INIT_OPEN:
			/* Check already opened or not */
			if( 1 == p_control_l->state.init )
			{
				ret_status = CAN_STATUS_ALREADY_INITIALIZED;
 800a300:	2006      	movs	r0, #6
 800a302:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					/* Update status */
					p_control_l->state.init = 1;
				}
				else
				{
					ret_status = CAN_STATUS_FAILED;
 800a304:	2001      	movs	r0, #1
		default:
			ret_status = CAN_STATUS_INVALID_ARGUMENT;
	}

	/* Return status */
	return ret_status;
 800a306:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 * <i>Imp Note:</i>
 *
 */
long CAN_node_init( void * p_channel, const unsigned char node, const unsigned char init )
{
	DRIVER_ASSERT( NULL == p_channel, CAN_STATUS_INVALID_ARGUMENT );
 800a308:	2003      	movs	r0, #3
 800a30a:	4770      	bx	lr
 800a30c:	48014000 	.word	0x48014000
 800a310:	e000ed00 	.word	0xe000ed00
 800a314:	e000e100 	.word	0xe000e100
 800a318:	e000ed14 	.word	0xe000ed14

0800a31c <CAN_ISR_Handler_Entry>:

#if (CAN_USING_INTERRUPT == 1U)
/** Channels ISR Entries **/
void CAN_ISR_Handler_Entry( void * p_channel, const eCAN_EventType event_type, const eCAN_Event event )
{
	DRIVER_ASSERT_NRET( NULL == p_channel );
 800a31c:	b900      	cbnz	r0, 800a320 <CAN_ISR_Handler_Entry+0x4>
 800a31e:	e7fe      	b.n	800a31e <CAN_ISR_Handler_Entry+0x2>


#if (CAN_USING_INTERRUPT == 1U)
/** Channels ISR Entries **/
void CAN_ISR_Handler_Entry( void * p_channel, const eCAN_EventType event_type, const eCAN_Event event )
{
 800a320:	b510      	push	{r4, lr}
 800a322:	4603      	mov	r3, r0
	DRIVER_ASSERT_NRET( NULL == p_channel );
	/* Local Variables */
	XMC_CAN_NODE_t * const p_node_l = (XMC_CAN_NODE_t *) ((tStCAN_Node *)p_channel)->p_config->p_channel_context;
 800a324:	6800      	ldr	r0, [r0, #0]
 800a326:	6804      	ldr	r4, [r0, #0]

	/* Check Event Type */
	switch( event_type )
 800a328:	2901      	cmp	r1, #1
 800a32a:	d017      	beq.n	800a35c <CAN_ISR_Handler_Entry+0x40>
 800a32c:	2902      	cmp	r1, #2
 800a32e:	d02a      	beq.n	800a386 <CAN_ISR_Handler_Entry+0x6a>
 800a330:	4618      	mov	r0, r3
	{
	default:
		case CAN_EVENT_TYPE_NODE_TRANSFER:
		/* Check Node Transfer event */
		switch( event )
 800a332:	2a01      	cmp	r2, #1
 800a334:	d008      	beq.n	800a348 <CAN_ISR_Handler_Entry+0x2c>
		{
		default:
			case CAN_EVENT_NODE_TRANSFER_TRANSMIT:
			#if (CAN_CALLBACK_HANDLER_USED == 1U)
				if( ((tStCAN_Node *)p_channel)->p_callback->fp_callback != NULL )
 800a336:	689b      	ldr	r3, [r3, #8]
 800a338:	681b      	ldr	r3, [r3, #0]
 800a33a:	b103      	cbz	r3, 800a33e <CAN_ISR_Handler_Entry+0x22>
				{
					((tStCAN_Node *)p_channel)->p_callback->fp_callback( p_channel, event_type, event );
 800a33c:	4798      	blx	r3
 *
 */

__STATIC_INLINE void XMC_CAN_NODE_ClearStatus(XMC_CAN_NODE_t *const can_node,XMC_CAN_NODE_STATUS_t can_node_status)
{
   can_node->NSR &= ~(uint32_t)can_node_status;
 800a33e:	6863      	ldr	r3, [r4, #4]
 800a340:	f023 0308 	bic.w	r3, r3, #8
 800a344:	6063      	str	r3, [r4, #4]
 800a346:	bd10      	pop	{r4, pc}
				/* Clear TX status */
				XMC_CAN_NODE_ClearStatus( p_node_l, XMC_CAN_NODE_STATUS_TX_OK );
			break;
			case CAN_EVENT_NODE_TRANSFER_RECEIVE:
			#if (CAN_CALLBACK_HANDLER_USED == 1U)
				if( ((tStCAN_Node *)p_channel)->p_callback->fp_callback != NULL )
 800a348:	689b      	ldr	r3, [r3, #8]
 800a34a:	681b      	ldr	r3, [r3, #0]
 800a34c:	b10b      	cbz	r3, 800a352 <CAN_ISR_Handler_Entry+0x36>
				{
					((tStCAN_Node *)p_channel)->p_callback->fp_callback( p_channel, event_type, event );
 800a34e:	2201      	movs	r2, #1
 800a350:	4798      	blx	r3
 800a352:	6863      	ldr	r3, [r4, #4]
 800a354:	f023 0310 	bic.w	r3, r3, #16
 800a358:	6063      	str	r3, [r4, #4]
 800a35a:	bd10      	pop	{r4, pc}
		}
		break;	/* CAN_EVENT_NODE_TRANSFER_TRANSMIT */

		case CAN_EVENT_TYPE_NODE_ERROR:
			/* Check Node Error Event */
			switch( event )
 800a35c:	2a03      	cmp	r2, #3
 800a35e:	d00e      	beq.n	800a37e <CAN_ISR_Handler_Entry+0x62>
 800a360:	2a04      	cmp	r2, #4
 800a362:	d010      	beq.n	800a386 <CAN_ISR_Handler_Entry+0x6a>
 *
 */

__STATIC_INLINE uint32_t XMC_CAN_NODE_GetStatus(XMC_CAN_NODE_t *const can_node)
{
  return ((can_node->NSR));
 800a364:	6863      	ldr	r3, [r4, #4]
			{
			default:
				case CAN_EVENT_NODE_ALERT:
					/* Check Bus-Off */
					if( XMC_CAN_NODE_GetStatus( p_node_l ) & CAN_NODE_NSR_BOFF_Msk )
 800a366:	f013 0f80 	tst.w	r3, #128	; 0x80
 800a36a:	d003      	beq.n	800a374 <CAN_ISR_Handler_Entry+0x58>
 *
 */

__STATIC_INLINE void XMC_CAN_NODE_ClearStatus(XMC_CAN_NODE_t *const can_node,XMC_CAN_NODE_STATUS_t can_node_status)
{
   can_node->NSR &= ~(uint32_t)can_node_status;
 800a36c:	6863      	ldr	r3, [r4, #4]
 800a36e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800a372:	6063      	str	r3, [r4, #4]
 800a374:	6863      	ldr	r3, [r4, #4]
 800a376:	f023 0320 	bic.w	r3, r3, #32
 800a37a:	6063      	str	r3, [r4, #4]
 800a37c:	bd10      	pop	{r4, pc}
 800a37e:	6863      	ldr	r3, [r4, #4]
 800a380:	f023 0307 	bic.w	r3, r3, #7
 800a384:	6063      	str	r3, [r4, #4]
 800a386:	bd10      	pop	{r4, pc}

0800a388 <CAN0_2_IRQHandler>:

/*****************************************************************************/

#if (CAN1_CHANNEL_USED == 1U)
void CAN1_Node_Transfer_Handler( void )
{
 800a388:	b510      	push	{r4, lr}
	unsigned long status_l = XMC_CAN_NODE_GetStatus( (XMC_CAN_NODE_t *const)CAN1.p_config->p_channel_context );
 800a38a:	4b0a      	ldr	r3, [pc, #40]	; (800a3b4 <CAN0_2_IRQHandler+0x2c>)
 800a38c:	681b      	ldr	r3, [r3, #0]
 800a38e:	681b      	ldr	r3, [r3, #0]
 *
 */

__STATIC_INLINE uint32_t XMC_CAN_NODE_GetStatus(XMC_CAN_NODE_t *const can_node)
{
  return ((can_node->NSR));
 800a390:	685c      	ldr	r4, [r3, #4]
	if( status_l & CAN_NODE_NSR_TXOK_Msk )
 800a392:	f014 0f08 	tst.w	r4, #8
 800a396:	d004      	beq.n	800a3a2 <CAN0_2_IRQHandler+0x1a>
	{
		CAN_ISR_Handler_Entry( &CAN1, CAN_EVENT_TYPE_NODE_TRANSFER, CAN_EVENT_NODE_TRANSFER_TRANSMIT );
 800a398:	4806      	ldr	r0, [pc, #24]	; (800a3b4 <CAN0_2_IRQHandler+0x2c>)
 800a39a:	2100      	movs	r1, #0
 800a39c:	460a      	mov	r2, r1
 800a39e:	f7ff ffbd 	bl	800a31c <CAN_ISR_Handler_Entry>
	}

	if( status_l & CAN_NODE_NSR_RXOK_Msk )
 800a3a2:	f014 0f10 	tst.w	r4, #16
 800a3a6:	d004      	beq.n	800a3b2 <CAN0_2_IRQHandler+0x2a>
	{
		CAN_ISR_Handler_Entry( &CAN1, CAN_EVENT_TYPE_NODE_TRANSFER, CAN_EVENT_NODE_TRANSFER_RECEIVE );
 800a3a8:	4802      	ldr	r0, [pc, #8]	; (800a3b4 <CAN0_2_IRQHandler+0x2c>)
 800a3aa:	2100      	movs	r1, #0
 800a3ac:	2201      	movs	r2, #1
 800a3ae:	f7ff ffb5 	bl	800a31c <CAN_ISR_Handler_Entry>
 800a3b2:	bd10      	pop	{r4, pc}
 800a3b4:	2000d7c8 	.word	0x2000d7c8

0800a3b8 <CAN0_3_IRQHandler>:
	}
}

void CAN1_MessageObject_Handler( void )
{
 800a3b8:	b508      	push	{r3, lr}
	/* Check transmit or receive event for CAN Node MO's */
	unsigned long status_l = XMC_CAN_MO_GetStatus( CAN1.p_config->p_message_rx );
 800a3ba:	4b0d      	ldr	r3, [pc, #52]	; (800a3f0 <CAN0_3_IRQHandler+0x38>)
 800a3bc:	681b      	ldr	r3, [r3, #0]
 *
 */

__STATIC_INLINE uint32_t XMC_CAN_MO_GetStatus(const XMC_CAN_MO_t *const can_mo)
{
  return ((can_mo->can_mo_ptr->MOSTAT));
 800a3be:	68db      	ldr	r3, [r3, #12]
 800a3c0:	681b      	ldr	r3, [r3, #0]
 800a3c2:	69db      	ldr	r3, [r3, #28]
	if( status_l & (CAN_MO_MOSTAT_RXPND_Msk|CAN_MO_MOSTAT_MSGVAL_Msk) )/* Message Validity and reception */
 800a3c4:	f013 0f21 	tst.w	r3, #33	; 0x21
 800a3c8:	d004      	beq.n	800a3d4 <CAN0_3_IRQHandler+0x1c>
	{
		CAN_ISR_Handler_Entry( &CAN1, CAN_EVENT_TYPE_MO_TRANSFER, CAN_EVENT_MESSAGE_RECEIVE );
 800a3ca:	4809      	ldr	r0, [pc, #36]	; (800a3f0 <CAN0_3_IRQHandler+0x38>)
 800a3cc:	2102      	movs	r1, #2
 800a3ce:	2206      	movs	r2, #6
 800a3d0:	f7ff ffa4 	bl	800a31c <CAN_ISR_Handler_Entry>
	}

	/* Transmitter check */
	status_l = XMC_CAN_MO_GetStatus( CAN1.p_config->p_message_tx );
 800a3d4:	4b06      	ldr	r3, [pc, #24]	; (800a3f0 <CAN0_3_IRQHandler+0x38>)
 800a3d6:	681b      	ldr	r3, [r3, #0]
 800a3d8:	689b      	ldr	r3, [r3, #8]
 800a3da:	681b      	ldr	r3, [r3, #0]
 800a3dc:	69db      	ldr	r3, [r3, #28]
	if( status_l & (CAN_MO_MOSTAT_TXPND_Msk|CAN_MO_MOSTAT_MSGVAL_Msk) )/* Message Validity and transmission */
 800a3de:	f013 0f22 	tst.w	r3, #34	; 0x22
 800a3e2:	d004      	beq.n	800a3ee <CAN0_3_IRQHandler+0x36>
	{
		CAN_ISR_Handler_Entry( &CAN1, CAN_EVENT_TYPE_MO_TRANSFER, CAN_EVENT_MESSAGE_TRANSMIT );
 800a3e4:	4802      	ldr	r0, [pc, #8]	; (800a3f0 <CAN0_3_IRQHandler+0x38>)
 800a3e6:	2102      	movs	r1, #2
 800a3e8:	2205      	movs	r2, #5
 800a3ea:	f7ff ff97 	bl	800a31c <CAN_ISR_Handler_Entry>
 800a3ee:	bd08      	pop	{r3, pc}
 800a3f0:	2000d7c8 	.word	0x2000d7c8

0800a3f4 <CAN0_4_IRQHandler>:
	}
}

#if (CAN1_EVENTS_USED == 1U)
void CAN1_Event_Handler( void )
{
 800a3f4:	b510      	push	{r4, lr}
	unsigned long status_l = XMC_CAN_NODE_GetStatus( (XMC_CAN_NODE_t *const)CAN1.p_config->p_channel_context );
 800a3f6:	4b0a      	ldr	r3, [pc, #40]	; (800a420 <CAN0_4_IRQHandler+0x2c>)
 800a3f8:	681b      	ldr	r3, [r3, #0]
 800a3fa:	681b      	ldr	r3, [r3, #0]
 *
 */

__STATIC_INLINE uint32_t XMC_CAN_NODE_GetStatus(XMC_CAN_NODE_t *const can_node)
{
  return ((can_node->NSR));
 800a3fc:	685c      	ldr	r4, [r3, #4]
	/* Check status */
	if( status_l & CAN_NODE_NSR_ALERT_Msk )
 800a3fe:	f014 0f20 	tst.w	r4, #32
 800a402:	d004      	beq.n	800a40e <CAN0_4_IRQHandler+0x1a>
	{
		/* Need to check the Alert levels */
		CAN_ISR_Handler_Entry( &CAN1, CAN_EVENT_TYPE_MO_TRANSFER, CAN_EVENT_NODE_ALERT );
 800a404:	4806      	ldr	r0, [pc, #24]	; (800a420 <CAN0_4_IRQHandler+0x2c>)
 800a406:	2102      	movs	r1, #2
 800a408:	460a      	mov	r2, r1
 800a40a:	f7ff ff87 	bl	800a31c <CAN_ISR_Handler_Entry>
	}

	if( status_l & CAN_NODE_NSR_LEC_Msk )
 800a40e:	f014 0f07 	tst.w	r4, #7
 800a412:	d004      	beq.n	800a41e <CAN0_4_IRQHandler+0x2a>
	{
		CAN_ISR_Handler_Entry( &CAN1, CAN_EVENT_TYPE_MO_TRANSFER, CAN_EVENT_NODE_LEC );
 800a414:	4802      	ldr	r0, [pc, #8]	; (800a420 <CAN0_4_IRQHandler+0x2c>)
 800a416:	2102      	movs	r1, #2
 800a418:	2203      	movs	r2, #3
 800a41a:	f7ff ff7f 	bl	800a31c <CAN_ISR_Handler_Entry>
 800a41e:	bd10      	pop	{r4, pc}
 800a420:	2000d7c8 	.word	0x2000d7c8

0800a424 <CAN0_5_IRQHandler>:

/*****************************************************************************/

#if (CAN2_CHANNEL_USED == 1U)
void CAN2_Node_Transfer_Handler( void )
{
 800a424:	b510      	push	{r4, lr}
	unsigned long status_l = XMC_CAN_NODE_GetStatus( (XMC_CAN_NODE_t *const)CAN2.p_config->p_channel_context );
 800a426:	4b0a      	ldr	r3, [pc, #40]	; (800a450 <CAN0_5_IRQHandler+0x2c>)
 800a428:	681b      	ldr	r3, [r3, #0]
 800a42a:	681b      	ldr	r3, [r3, #0]
 800a42c:	685c      	ldr	r4, [r3, #4]
	if( status_l & CAN_NODE_NSR_TXOK_Msk )
 800a42e:	f014 0f08 	tst.w	r4, #8
 800a432:	d004      	beq.n	800a43e <CAN0_5_IRQHandler+0x1a>
	{
		CAN_ISR_Handler_Entry( &CAN2, CAN_EVENT_TYPE_NODE_TRANSFER, CAN_EVENT_NODE_TRANSFER_TRANSMIT );
 800a434:	4806      	ldr	r0, [pc, #24]	; (800a450 <CAN0_5_IRQHandler+0x2c>)
 800a436:	2100      	movs	r1, #0
 800a438:	460a      	mov	r2, r1
 800a43a:	f7ff ff6f 	bl	800a31c <CAN_ISR_Handler_Entry>
	}

	if( status_l & CAN_NODE_NSR_RXOK_Msk )
 800a43e:	f014 0f10 	tst.w	r4, #16
 800a442:	d004      	beq.n	800a44e <CAN0_5_IRQHandler+0x2a>
	{
		CAN_ISR_Handler_Entry( &CAN2, CAN_EVENT_TYPE_NODE_TRANSFER, CAN_EVENT_NODE_TRANSFER_RECEIVE );
 800a444:	4802      	ldr	r0, [pc, #8]	; (800a450 <CAN0_5_IRQHandler+0x2c>)
 800a446:	2100      	movs	r1, #0
 800a448:	2201      	movs	r2, #1
 800a44a:	f7ff ff67 	bl	800a31c <CAN_ISR_Handler_Entry>
 800a44e:	bd10      	pop	{r4, pc}
 800a450:	2000d7d4 	.word	0x2000d7d4

0800a454 <CAN0_6_IRQHandler>:
	}
}

void CAN2_MessageObject_Handler( void )
{
 800a454:	b508      	push	{r3, lr}
	/* Check transmit or receive event for CAN Node MO's */
	unsigned long status_l = XMC_CAN_MO_GetStatus( CAN2.p_config->p_message_rx );
 800a456:	4b0d      	ldr	r3, [pc, #52]	; (800a48c <CAN0_6_IRQHandler+0x38>)
 800a458:	681b      	ldr	r3, [r3, #0]
 *
 */

__STATIC_INLINE uint32_t XMC_CAN_MO_GetStatus(const XMC_CAN_MO_t *const can_mo)
{
  return ((can_mo->can_mo_ptr->MOSTAT));
 800a45a:	68db      	ldr	r3, [r3, #12]
 800a45c:	681b      	ldr	r3, [r3, #0]
 800a45e:	69db      	ldr	r3, [r3, #28]
	if( status_l & (CAN_MO_MOSTAT_RXPND_Msk|CAN_MO_MOSTAT_MSGVAL_Msk) )/* Message Validity and reception */
 800a460:	f013 0f21 	tst.w	r3, #33	; 0x21
 800a464:	d004      	beq.n	800a470 <CAN0_6_IRQHandler+0x1c>
	{
		CAN_ISR_Handler_Entry( &CAN2, CAN_EVENT_TYPE_MO_TRANSFER, CAN_EVENT_MESSAGE_RECEIVE );
 800a466:	4809      	ldr	r0, [pc, #36]	; (800a48c <CAN0_6_IRQHandler+0x38>)
 800a468:	2102      	movs	r1, #2
 800a46a:	2206      	movs	r2, #6
 800a46c:	f7ff ff56 	bl	800a31c <CAN_ISR_Handler_Entry>
	}

	/* Transmitter check */
	status_l = XMC_CAN_MO_GetStatus( CAN2.p_config->p_message_tx );
 800a470:	4b06      	ldr	r3, [pc, #24]	; (800a48c <CAN0_6_IRQHandler+0x38>)
 800a472:	681b      	ldr	r3, [r3, #0]
 800a474:	689b      	ldr	r3, [r3, #8]
 800a476:	681b      	ldr	r3, [r3, #0]
 800a478:	69db      	ldr	r3, [r3, #28]
	if( status_l & (CAN_MO_MOSTAT_TXPND_Msk|CAN_MO_MOSTAT_MSGVAL_Msk) )/* Message Validity and transmission */
 800a47a:	f013 0f22 	tst.w	r3, #34	; 0x22
 800a47e:	d004      	beq.n	800a48a <CAN0_6_IRQHandler+0x36>
	{
		CAN_ISR_Handler_Entry( &CAN2, CAN_EVENT_TYPE_MO_TRANSFER, CAN_EVENT_MESSAGE_TRANSMIT );
 800a480:	4802      	ldr	r0, [pc, #8]	; (800a48c <CAN0_6_IRQHandler+0x38>)
 800a482:	2102      	movs	r1, #2
 800a484:	2205      	movs	r2, #5
 800a486:	f7ff ff49 	bl	800a31c <CAN_ISR_Handler_Entry>
 800a48a:	bd08      	pop	{r3, pc}
 800a48c:	2000d7d4 	.word	0x2000d7d4

0800a490 <CAN0_7_IRQHandler>:
	}
}
#if (CAN2_EVENTS_USED == 1U)
void CAN2_Event_Handler( void )
{
 800a490:	b510      	push	{r4, lr}
	unsigned long status_l = XMC_CAN_NODE_GetStatus( (XMC_CAN_NODE_t *const)CAN2.p_config->p_channel_context );
 800a492:	4b0a      	ldr	r3, [pc, #40]	; (800a4bc <CAN0_7_IRQHandler+0x2c>)
 800a494:	681b      	ldr	r3, [r3, #0]
 800a496:	681b      	ldr	r3, [r3, #0]
 *
 */

__STATIC_INLINE uint32_t XMC_CAN_NODE_GetStatus(XMC_CAN_NODE_t *const can_node)
{
  return ((can_node->NSR));
 800a498:	685c      	ldr	r4, [r3, #4]
	/* Check status */
	if( status_l & CAN_NODE_NSR_ALERT_Msk )
 800a49a:	f014 0f20 	tst.w	r4, #32
 800a49e:	d004      	beq.n	800a4aa <CAN0_7_IRQHandler+0x1a>
	{
		/* Need to check the Alert levels */
		CAN_ISR_Handler_Entry( &CAN2, CAN_EVENT_TYPE_MO_TRANSFER, CAN_EVENT_NODE_ALERT );
 800a4a0:	4806      	ldr	r0, [pc, #24]	; (800a4bc <CAN0_7_IRQHandler+0x2c>)
 800a4a2:	2102      	movs	r1, #2
 800a4a4:	460a      	mov	r2, r1
 800a4a6:	f7ff ff39 	bl	800a31c <CAN_ISR_Handler_Entry>
	}

	if( status_l & CAN_NODE_NSR_LEC_Msk )
 800a4aa:	f014 0f07 	tst.w	r4, #7
 800a4ae:	d004      	beq.n	800a4ba <CAN0_7_IRQHandler+0x2a>
	{
		CAN_ISR_Handler_Entry( &CAN2, CAN_EVENT_TYPE_MO_TRANSFER, CAN_EVENT_NODE_LEC );
 800a4b0:	4802      	ldr	r0, [pc, #8]	; (800a4bc <CAN0_7_IRQHandler+0x2c>)
 800a4b2:	2102      	movs	r1, #2
 800a4b4:	2203      	movs	r2, #3
 800a4b6:	f7ff ff31 	bl	800a31c <CAN_ISR_Handler_Entry>
 800a4ba:	bd10      	pop	{r4, pc}
 800a4bc:	2000d7d4 	.word	0x2000d7d4

0800a4c0 <_ZN12ClientTask__11client_bodyEPv>:
 * @brief
 *
 * <i>Imp Note:</i>
 */
void ClientTask__ :: client_body( void *pvParameters )
{
 800a4c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800a4c4:	b092      	sub	sp, #72	; 0x48
    (void) pvParameters;
	/* Local variables */
	struct freertos_sockaddr xServerAddress;
	Socket_t xClientSocket;
	constexpr TickType_t xSendTimeOut = pdMS_TO_TICKS( 5000 );
 800a4c6:	f241 3388 	movw	r3, #5000	; 0x1388
 800a4ca:	9303      	str	r3, [sp, #12]
    TickType_t xTimeOnShutdown = 0;

#ifdef USING_RAW_CLIENT
    unsigned long data_len = sizeof(struct xIP_PACKET) + CLIENT_DATA_LENGTH;
    char buffer_l[sizeof(struct xIP_PACKET) + CLIENT_DATA_LENGTH] = {};
 800a4cc:	2300      	movs	r3, #0
 800a4ce:	9306      	str	r3, [sp, #24]
 800a4d0:	9307      	str	r3, [sp, #28]
 800a4d2:	9308      	str	r3, [sp, #32]
 800a4d4:	9309      	str	r3, [sp, #36]	; 0x24
 800a4d6:	930a      	str	r3, [sp, #40]	; 0x28
 800a4d8:	930b      	str	r3, [sp, #44]	; 0x2c
 800a4da:	930c      	str	r3, [sp, #48]	; 0x30
 800a4dc:	930d      	str	r3, [sp, #52]	; 0x34
 800a4de:	930e      	str	r3, [sp, #56]	; 0x38
 800a4e0:	930f      	str	r3, [sp, #60]	; 0x3c
 800a4e2:	9310      	str	r3, [sp, #64]	; 0x40
 800a4e4:	9311      	str	r3, [sp, #68]	; 0x44
    char buffer_l[sizeof(struct xUDP_PACKET) + CLIENT_DATA_LENGTH] = {};
#endif

	/* Configure server details */
#ifdef USING_RAW_CLIENT
	xServerAddress.sin_port = FreeRTOS_htons( 0/*5901*/ );
 800a4e6:	f8ad 3012 	strh.w	r3, [sp, #18]
#elif defined(USING_RAW_UDP_CLIENT)
	xServerAddress.sin_port = FreeRTOS_htons( 5901 );
#endif
	xServerAddress.sin_addr = FreeRTOS_inet_addr( "192.168.1.7" );/* For RAW it will become 0.0.0.0, let this be same */
 800a4ea:	4832      	ldr	r0, [pc, #200]	; (800a5b4 <_ZN12ClientTask__11client_bodyEPv+0xf4>)
 800a4ec:	f7fc f804 	bl	80064f8 <FreeRTOS_inet_addr>
 800a4f0:	9005      	str	r0, [sp, #20]
	/* Fill in the packet information
	 * Note: You can fill packet information in any way as you like,
	 * I have filled information using the existing method provided in FreeRTOS+Plus, and quite handy too! */
	char *pxIpSrcAddrOffset = ( char *) ( & (buffer_l[sizeof( MACAddress_t )]) );
#ifdef USING_RAW_CLIENT
	( void ) memcpy( ( void * ) pxIpSrcAddrOffset, ( const void * ) ( xDefaultPartRAWPacketHeader.ucBytes ), sizeof( xDefaultPartRAWPacketHeader ) );
 800a4f2:	4c31      	ldr	r4, [pc, #196]	; (800a5b8 <_ZN12ClientTask__11client_bodyEPv+0xf8>)
 800a4f4:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800a4f6:	f8cd 001e 	str.w	r0, [sp, #30]
 800a4fa:	f8cd 1022 	str.w	r1, [sp, #34]	; 0x22
 800a4fe:	f8cd 2026 	str.w	r2, [sp, #38]	; 0x26
 800a502:	f8cd 302a 	str.w	r3, [sp, #42]	; 0x2a
 800a506:	cc03      	ldmia	r4!, {r0, r1}
 800a508:	f8cd 002e 	str.w	r0, [sp, #46]	; 0x2e
 800a50c:	f8cd 1032 	str.w	r1, [sp, #50]	; 0x32
	pxIpSrcAddrOffset = ( char *) ( & (buffer_l[sizeof(xIP_PACKET)]) );
#elif defined(USING_RAW_UDP_CLIENT)
	( void ) memcpy( ( void * ) pxIpSrcAddrOffset, ( const void * ) ( xDefaultPartUDPPacketHeader.ucBytes ), sizeof( xDefaultPartUDPPacketHeader ) );
	pxIpSrcAddrOffset = ( char *) ( & (buffer_l[sizeof(xUDP_PACKET)]) );
#endif
	( void ) memcpy( ( void * ) pxIpSrcAddrOffset, (char *)"Hella Server\r\n", CLIENT_DATA_LENGTH );
 800a510:	4b2a      	ldr	r3, [pc, #168]	; (800a5bc <_ZN12ClientTask__11client_bodyEPv+0xfc>)
 800a512:	cb07      	ldmia	r3!, {r0, r1, r2}
 800a514:	f8cd 003a 	str.w	r0, [sp, #58]	; 0x3a
 800a518:	f8cd 103e 	str.w	r1, [sp, #62]	; 0x3e
 800a51c:	f8cd 2042 	str.w	r2, [sp, #66]	; 0x42
 800a520:	881b      	ldrh	r3, [r3, #0]
 800a522:	f8ad 3046 	strh.w	r3, [sp, #70]	; 0x46
	/* Connect to a server and create a task for client */
	for(  ; ; )
	{
		/* Attempt to open the socket. */
#ifdef USING_RAW_CLIENT
		xClientSocket = FreeRTOS_socket( FREERTOS_AF_INET, FREERTOS_SOCK_RAW, FREERTOS_IPPROTO_RAW );
 800a526:	f04f 0802 	mov.w	r8, #2
 800a52a:	4640      	mov	r0, r8
 800a52c:	2103      	movs	r1, #3
 800a52e:	22ff      	movs	r2, #255	; 0xff
 800a530:	f7fb fb76 	bl	8005c20 <FreeRTOS_socket>
 800a534:	4604      	mov	r4, r0
#elif defined(USING_RAW_UDP_CLIENT)
		xClientSocket = FreeRTOS_socket( FREERTOS_AF_INET, FREERTOS_SOCK_RAW, FREERTOS_IPPROTO_UDP );
#endif
		configASSERT( xClientSocket != FREERTOS_INVALID_SOCKET );
 800a536:	f1b0 3fff 	cmp.w	r0, #4294967295
 800a53a:	d108      	bne.n	800a54e <_ZN12ClientTask__11client_bodyEPv+0x8e>
            "	mov %0, %1												\n"\
            "	msr basepri, %0											\n"\
            "	isb														\n"\
            "	dsb														\n"\
            : "=r" ( ulNewBASEPRI ) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
        );
 800a53c:	f04f 0314 	mov.w	r3, #20
 800a540:	f383 8811 	msr	BASEPRI, r3
 800a544:	f3bf 8f6f 	isb	sy
 800a548:	f3bf 8f4f 	dsb	sy
 800a54c:	e7fe      	b.n	800a54c <_ZN12ClientTask__11client_bodyEPv+0x8c>

		FreeRTOS_setsockopt( xClientSocket, 0, FREERTOS_SO_SNDTIMEO, &xSendTimeOut, sizeof( xSendTimeOut ) );
 800a54e:	2304      	movs	r3, #4
 800a550:	9300      	str	r3, [sp, #0]
 800a552:	2100      	movs	r1, #0
 800a554:	2201      	movs	r2, #1
 800a556:	ab03      	add	r3, sp, #12
 800a558:	f7fc fbba 	bl	8006cd0 <FreeRTOS_setsockopt>

		/* Start processing */
		for( ; ; )
		{
            if( 0 == FreeRTOS_sendto( xClientSocket, buffer_l, data_len, FREERTOS_MSG_DONTWAIT, &xServerAddress, sizeof(xServerAddress) ) )
 800a55c:	ae04      	add	r6, sp, #16
 800a55e:	2508      	movs	r5, #8
 800a560:	9600      	str	r6, [sp, #0]
 800a562:	9501      	str	r5, [sp, #4]
 800a564:	4620      	mov	r0, r4
 800a566:	a906      	add	r1, sp, #24
 800a568:	2230      	movs	r2, #48	; 0x30
 800a56a:	2310      	movs	r3, #16
 800a56c:	f7fb fd2c 	bl	8005fc8 <FreeRTOS_sendto>
 800a570:	b120      	cbz	r0, 800a57c <_ZN12ClientTask__11client_bodyEPv+0xbc>
                /* Break loop to recreate the client socket */
                break;
            }
            else
            {
                vTaskDelay( pdMS_TO_TICKS(1000) );
 800a572:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800a576:	f7f8 ff89 	bl	800348c <vTaskDelay>

        /* Close socket */
        FreeRTOS_closesocket( xClientSocket );
	}

	vTaskDelete( NULL );
 800a57a:	e7f1      	b.n	800a560 <_ZN12ClientTask__11client_bodyEPv+0xa0>
                vTaskDelay( pdMS_TO_TICKS(1000) );
            }
        }

        /* Initiate a shutdown in case it has not already been initiated. */
        FreeRTOS_shutdown( xClientSocket, FREERTOS_SHUT_RDWR );
 800a57c:	4620      	mov	r0, r4
 800a57e:	4641      	mov	r1, r8
 800a580:	f7fc fa74 	bl	8006a6c <FreeRTOS_shutdown>

        /* Wait for the shutdown to take effect, indicated by FreeRTOS_recv()
         * returning an error. */
        xTimeOnShutdown = xTaskGetTickCount();
 800a584:	f7f8 fe1a 	bl	80031bc <xTaskGetTickCount>
 800a588:	4607      	mov	r7, r0
        do
        {
            if( FreeRTOS_recv( xClientSocket, buffer_l, sizeof(buffer_l), 0 ) < 0 )
 800a58a:	2630      	movs	r6, #48	; 0x30
 800a58c:	2500      	movs	r5, #0
 800a58e:	4620      	mov	r0, r4
 800a590:	a906      	add	r1, sp, #24
 800a592:	4632      	mov	r2, r6
 800a594:	462b      	mov	r3, r5
 800a596:	f7fc f86b 	bl	8006670 <FreeRTOS_recv>
 800a59a:	2800      	cmp	r0, #0
 800a59c:	db05      	blt.n	800a5aa <_ZN12ClientTask__11client_bodyEPv+0xea>
            {
                break;
            }
        } while( ( xTaskGetTickCount() - xTimeOnShutdown ) < pdMS_TO_TICKS(1000) );
 800a59e:	f7f8 fe0d 	bl	80031bc <xTaskGetTickCount>
 800a5a2:	1bc0      	subs	r0, r0, r7
        FreeRTOS_shutdown( xClientSocket, FREERTOS_SHUT_RDWR );

        /* Wait for the shutdown to take effect, indicated by FreeRTOS_recv()
         * returning an error. */
        xTimeOnShutdown = xTaskGetTickCount();
        do
 800a5a4:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 800a5a8:	d3f1      	bcc.n	800a58e <_ZN12ClientTask__11client_bodyEPv+0xce>
                break;
            }
        } while( ( xTaskGetTickCount() - xTimeOnShutdown ) < pdMS_TO_TICKS(1000) );

        /* Close socket */
        FreeRTOS_closesocket( xClientSocket );
 800a5aa:	4620      	mov	r0, r4
 800a5ac:	f7fb fe48 	bl	8006240 <FreeRTOS_closesocket>
	}

	vTaskDelete( NULL );
 800a5b0:	e7bb      	b.n	800a52a <_ZN12ClientTask__11client_bodyEPv+0x6a>
 800a5b2:	bf00      	nop
 800a5b4:	0800ad98 	.word	0x0800ad98
 800a5b8:	2000d5a8 	.word	0x2000d5a8
 800a5bc:	0800ada4 	.word	0x0800ada4

0800a5c0 <_ZN9LedTask__6xvinitEv>:
 * @brief		LED Task iniitalization function
 *
 * <i>Imp Note:</i>
 */
void LedTask__ :: xvinit( void )
{
 800a5c0:	b510      	push	{r4, lr}
 800a5c2:	b082      	sub	sp, #8
 800a5c4:	4604      	mov	r4, r0
	/* Return Status of Task */
	BaseType_t xReturned = pdFAIL;

	/* Create task */
	xReturned = xTaskCreate( LedTask__::xsvTaskEntryPoint, xLedTaskParams.p_name,
			xLedTaskParams.stackDepth, this, xLedTaskParams.priority, &xHandle );
 800a5c6:	8a02      	ldrh	r2, [r0, #16]
 800a5c8:	6943      	ldr	r3, [r0, #20]
 800a5ca:	9300      	str	r3, [sp, #0]
 800a5cc:	f100 0318 	add.w	r3, r0, #24
 800a5d0:	9301      	str	r3, [sp, #4]
 800a5d2:	4806      	ldr	r0, [pc, #24]	; (800a5ec <_ZN9LedTask__6xvinitEv+0x2c>)
 800a5d4:	68e1      	ldr	r1, [r4, #12]
 800a5d6:	4623      	mov	r3, r4
 800a5d8:	f7f8 fc44 	bl	8002e64 <xTaskCreate>

	/* Delete task if not created successfully */
	if( xReturned != pdPASS )
 800a5dc:	2801      	cmp	r0, #1
 800a5de:	d003      	beq.n	800a5e8 <_ZN9LedTask__6xvinitEv+0x28>
	{
		vTaskDelete( xHandle );
 800a5e0:	69a0      	ldr	r0, [r4, #24]
 800a5e2:	f7f8 fd31 	bl	8003048 <vTaskDelete>
	/* Create task */
	xReturned = xTaskCreate( LedTask__::xsvTaskEntryPoint, xLedTaskParams.p_name,
			xLedTaskParams.stackDepth, this, xLedTaskParams.priority, &xHandle );

	/* Delete task if not created successfully */
	if( xReturned != pdPASS )
 800a5e6:	e7fe      	b.n	800a5e6 <_ZN9LedTask__6xvinitEv+0x26>
	}
	else
	{
		/* Can do some initial processing if needed */
	}
}
 800a5e8:	b002      	add	sp, #8
 800a5ea:	bd10      	pop	{r4, pc}
 800a5ec:	0800a621 	.word	0x0800a621

0800a5f0 <_ZN9LedTask__11xvTaskEntryEPv>:
 * @brief		LED Task Entry function
 *
 * <i>Imp Note:</i>
 */
void LedTask__ :: xvTaskEntry( void *pvParams )
{
 800a5f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800a5f2:	b083      	sub	sp, #12
 800a5f4:	4604      	mov	r4, r0
	/* Not using */
	(void)pvParams;

	/* Local Variables */
    TickType_t xLastWakeTime = 0;
 800a5f6:	2300      	movs	r3, #0
 800a5f8:	9301      	str	r3, [sp, #4]
    const TickType_t xFrequency = 500;

    /* Initialize the xLastWakeTime variable with the current time. */
    xLastWakeTime = xTaskGetTickCount();
 800a5fa:	f7f8 fddf 	bl	80031bc <xTaskGetTickCount>
 800a5fe:	ad02      	add	r5, sp, #8
 800a600:	f845 0d04 	str.w	r0, [r5, #-4]!

__STATIC_INLINE void XMC_GPIO_ToggleOutput(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_ToggleOutput: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10001U << pin;
 800a604:	f04f 1701 	mov.w	r7, #65537	; 0x10001

    /* Task execution entry */
    for( ; ; )
    {
		GPIO__::fp_toggle( (XMC_GPIO_PORT_t *)xLedPort, xLedPin );
		vTaskDelayUntil( &xLastWakeTime, xFrequency );
 800a608:	f44f 76fa 	mov.w	r6, #500	; 0x1f4
    xLastWakeTime = xTaskGetTickCount();

    /* Task execution entry */
    for( ; ; )
    {
		GPIO__::fp_toggle( (XMC_GPIO_PORT_t *)xLedPort, xLedPin );
 800a60c:	6863      	ldr	r3, [r4, #4]
 800a60e:	7a22      	ldrb	r2, [r4, #8]
 800a610:	fa07 f202 	lsl.w	r2, r7, r2
 800a614:	605a      	str	r2, [r3, #4]
		vTaskDelayUntil( &xLastWakeTime, xFrequency );
 800a616:	4628      	mov	r0, r5
 800a618:	4631      	mov	r1, r6
 800a61a:	f7f8 fee5 	bl	80033e8 <vTaskDelayUntil>
	}

	/* Should never reach here, if so the delete the task and free memory */
	vTaskDelete( NULL );
 800a61e:	e7f5      	b.n	800a60c <_ZN9LedTask__11xvTaskEntryEPv+0x1c>

0800a620 <_ZN9LedTask__17xsvTaskEntryPointEPv>:
	/* Task Info */
	TaskCreationParams xLedTaskParams;
	TaskHandle_t xHandle;

	/* Will work as a linker to the actual task function */
	static void xsvTaskEntryPoint( void *params )
 800a620:	b508      	push	{r3, lr}
	{
		((LedTask__ *) params)->xvTaskEntry(params);
 800a622:	4601      	mov	r1, r0
 800a624:	f7ff ffe4 	bl	800a5f0 <_ZN9LedTask__11xvTaskEntryEPv>

0800a628 <_ZN12ClientTask__12client_entryEPv>:
	/** Data Members **/
	const char * const xtask_name = "ClientTask";
	TaskHandle_t * xhandle = nullptr;

	/******* Private Member Functions *******/
	static void client_entry( void * pvParameters )
 800a628:	b508      	push	{r3, lr}
	{
		/* Pass the control to server body */
		((ClientTask__ *) pvParameters)->client_body( pvParameters );
 800a62a:	4601      	mov	r1, r0
 800a62c:	f7ff ff48 	bl	800a4c0 <_ZN12ClientTask__11client_bodyEPv>
 800a630:	bd08      	pop	{r3, pc}
 800a632:	bf00      	nop

0800a634 <raw_udp_server>:
 * @brief		Simple UDP Server
 *
 * <i>Imp Note:</i>
 */
void raw_udp_server( void * pvParameters )
{
 800a634:	b5f0      	push	{r4, r5, r6, r7, lr}
 800a636:	b099      	sub	sp, #100	; 0x64
	Socket_t xListeningSocket = NULL;
	struct freertos_sockaddr xClient, xServer;
	socklen_t xAddressLength;

	unsigned long data_len = sizeof(struct xUDP_PACKET) + RAW_UDP_SERVER_DATA_LENGTH;
	char data[sizeof(struct xUDP_PACKET) + RAW_UDP_SERVER_DATA_LENGTH] = {};
 800a638:	a808      	add	r0, sp, #32
 800a63a:	2100      	movs	r1, #0
 800a63c:	223e      	movs	r2, #62	; 0x3e
 800a63e:	f7ff fc7d 	bl	8009f3c <memset>

	/* Attempt to open the socket. */
	xListeningSocket = FreeRTOS_socket( FREERTOS_AF_INET, FREERTOS_SOCK_RAW, FREERTOS_IPPROTO_UDP );
 800a642:	2002      	movs	r0, #2
 800a644:	2103      	movs	r1, #3
 800a646:	2211      	movs	r2, #17
 800a648:	f7fb faea 	bl	8005c20 <FreeRTOS_socket>
 800a64c:	4606      	mov	r6, r0
	configASSERT( xListeningSocket != FREERTOS_INVALID_SOCKET );
 800a64e:	f1b0 3fff 	cmp.w	r0, #4294967295
 800a652:	d108      	bne.n	800a666 <raw_udp_server+0x32>
 800a654:	f04f 0314 	mov.w	r3, #20
 800a658:	f383 8811 	msr	BASEPRI, r3
 800a65c:	f3bf 8f6f 	isb	sy
 800a660:	f3bf 8f4f 	dsb	sy
 800a664:	e7fe      	b.n	800a664 <raw_udp_server+0x30>

	/* Bind the socket to the port that the client task will send to,
	 * then listen for incoming connections. */
	xServer.sin_port = 6000;
	xServer.sin_port = FreeRTOS_htons( xServer.sin_port );
 800a666:	f247 0317 	movw	r3, #28695	; 0x7017
 800a66a:	f8ad 301a 	strh.w	r3, [sp, #26]
	if( -1 == FreeRTOS_bind( xListeningSocket, &xServer, sizeof( xServer ) ) )
 800a66e:	a906      	add	r1, sp, #24
 800a670:	2208      	movs	r2, #8
 800a672:	f7fb fc65 	bl	8005f40 <FreeRTOS_bind>
 800a676:	f1b0 3fff 	cmp.w	r0, #4294967295
 800a67a:	d103      	bne.n	800a684 <raw_udp_server+0x50>
	{
		FreeRTOS_closesocket( xListeningSocket );
 800a67c:	4630      	mov	r0, r6
 800a67e:	f7fb fddf 	bl	8006240 <FreeRTOS_closesocket>

	/* Bind the socket to the port that the client task will send to,
	 * then listen for incoming connections. */
	xServer.sin_port = 6000;
	xServer.sin_port = FreeRTOS_htons( xServer.sin_port );
	if( -1 == FreeRTOS_bind( xListeningSocket, &xServer, sizeof( xServer ) ) )
 800a682:	e7fe      	b.n	800a682 <raw_udp_server+0x4e>
		/* Receive data from Client */
		FreeRTOS_recvfrom(	xListeningSocket, (data + sizeof(struct xUDP_PACKET)), RAW_UDP_SERVER_DATA_LENGTH, 0, &xClient, &xAddressLength );

		/* Update UDP data */
		char *pxIpSrcAddrOffset = ( char *) ( & (data[sizeof( MACAddress_t )]) );
		( void ) memcpy( ( void * ) pxIpSrcAddrOffset, ( const void * ) ( xDefaultPartUDPPacketHeader.ucBytes ), sizeof( xDefaultPartUDPPacketHeader ) );
 800a684:	4f14      	ldr	r7, [pc, #80]	; (800a6d8 <raw_udp_server+0xa4>)

	/* Create task to receive data from client */
	for( ; ; )
	{
		/* Receive data from Client */
		FreeRTOS_recvfrom(	xListeningSocket, (data + sizeof(struct xUDP_PACKET)), RAW_UDP_SERVER_DATA_LENGTH, 0, &xClient, &xAddressLength );
 800a686:	ad04      	add	r5, sp, #16
 800a688:	9500      	str	r5, [sp, #0]
 800a68a:	ab03      	add	r3, sp, #12
 800a68c:	9301      	str	r3, [sp, #4]
 800a68e:	4630      	mov	r0, r6
 800a690:	f10d 014a 	add.w	r1, sp, #74	; 0x4a
 800a694:	2214      	movs	r2, #20
 800a696:	2300      	movs	r3, #0
 800a698:	f7fb fba6 	bl	8005de8 <FreeRTOS_recvfrom>

		/* Update UDP data */
		char *pxIpSrcAddrOffset = ( char *) ( & (data[sizeof( MACAddress_t )]) );
		( void ) memcpy( ( void * ) pxIpSrcAddrOffset, ( const void * ) ( xDefaultPartUDPPacketHeader.ucBytes ), sizeof( xDefaultPartUDPPacketHeader ) );
 800a69c:	463c      	mov	r4, r7
 800a69e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800a6a0:	f8cd 0026 	str.w	r0, [sp, #38]	; 0x26
 800a6a4:	f8cd 102a 	str.w	r1, [sp, #42]	; 0x2a
 800a6a8:	f8cd 202e 	str.w	r2, [sp, #46]	; 0x2e
 800a6ac:	f8cd 3032 	str.w	r3, [sp, #50]	; 0x32
 800a6b0:	cc03      	ldmia	r4!, {r0, r1}
 800a6b2:	f8cd 0036 	str.w	r0, [sp, #54]	; 0x36
 800a6b6:	f8cd 103a 	str.w	r1, [sp, #58]	; 0x3a

		FreeRTOS_sendto( xListeningSocket, data, data_len, 0, &xClient, xAddressLength );
 800a6ba:	9500      	str	r5, [sp, #0]
 800a6bc:	9b03      	ldr	r3, [sp, #12]
 800a6be:	9301      	str	r3, [sp, #4]
 800a6c0:	4630      	mov	r0, r6
 800a6c2:	a908      	add	r1, sp, #32
 800a6c4:	223e      	movs	r2, #62	; 0x3e
 800a6c6:	2300      	movs	r3, #0
 800a6c8:	f7fb fc7e 	bl	8005fc8 <FreeRTOS_sendto>
		vTaskDelay(500);
 800a6cc:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 800a6d0:	f7f8 fedc 	bl	800348c <vTaskDelay>
	}
 800a6d4:	e7d7      	b.n	800a686 <raw_udp_server+0x52>
 800a6d6:	bf00      	nop
 800a6d8:	2000d5c0 	.word	0x2000d5c0

0800a6dc <_ZN12ServerTask__11server_bodyEPv>:
 *
 * <i>Imp Note:</i>
 * 				Example taken from FreeRTOS-Plus TCP demo
 */
void ServerTask__ :: server_body( void *pvParameters )
{
 800a6dc:	b570      	push	{r4, r5, r6, lr}
 800a6de:	b088      	sub	sp, #32
	/* Local variables */
	struct freertos_sockaddr xClient, xBindAddress;
	Socket_t xListeningSocket = NULL;
	Socket_t xConnectedSocket = NULL;

	socklen_t xSize = sizeof( xClient );
 800a6e0:	2308      	movs	r3, #8
 800a6e2:	9302      	str	r3, [sp, #8]
	TickType_t xReceiveTimeOut = portMAX_DELAY;
 800a6e4:	f04f 33ff 	mov.w	r3, #4294967295
 800a6e8:	9303      	str	r3, [sp, #12]
	const BaseType_t xBacklog = MAX_CLIENTS;

	while( FreeRTOS_IsNetworkUp() != pdTRUE )
	{
		/* Sleep, then check again */
		vTaskDelay( NETWORK_RETRY_DELAY );
 800a6ea:	f44f 74fa 	mov.w	r4, #500	; 0x1f4

	socklen_t xSize = sizeof( xClient );
	TickType_t xReceiveTimeOut = portMAX_DELAY;
	const BaseType_t xBacklog = MAX_CLIENTS;

	while( FreeRTOS_IsNetworkUp() != pdTRUE )
 800a6ee:	e002      	b.n	800a6f6 <_ZN12ServerTask__11server_bodyEPv+0x1a>
	{
		/* Sleep, then check again */
		vTaskDelay( NETWORK_RETRY_DELAY );
 800a6f0:	4620      	mov	r0, r4
 800a6f2:	f7f8 fecb 	bl	800348c <vTaskDelay>

	socklen_t xSize = sizeof( xClient );
	TickType_t xReceiveTimeOut = portMAX_DELAY;
	const BaseType_t xBacklog = MAX_CLIENTS;

	while( FreeRTOS_IsNetworkUp() != pdTRUE )
 800a6f6:	f7fb f9a1 	bl	8005a3c <FreeRTOS_IsNetworkUp>
 800a6fa:	2801      	cmp	r0, #1
 800a6fc:	d1f8      	bne.n	800a6f0 <_ZN12ServerTask__11server_bodyEPv+0x14>
	{
		/* Local Variables */
		BaseType_t ret_status = pdTRUE;
		/* Create Task */
		ret_status = xTaskCreate( fp_task_code, p_name, stack_depth, parameters,
									priority, p_task_handle );
 800a6fe:	2302      	movs	r3, #2
 800a700:	9300      	str	r3, [sp, #0]
 800a702:	2300      	movs	r3, #0
 800a704:	9301      	str	r3, [sp, #4]
 800a706:	4833      	ldr	r0, [pc, #204]	; (800a7d4 <_ZN12ServerTask__11server_bodyEPv+0xf8>)
 800a708:	4933      	ldr	r1, [pc, #204]	; (800a7d8 <_ZN12ServerTask__11server_bodyEPv+0xfc>)
 800a70a:	f44f 72f0 	mov.w	r2, #480	; 0x1e0
 800a70e:	f7f8 fba9 	bl	8002e64 <xTaskCreate>
		/* Check return status */
		if( ret_status != pdTRUE )
 800a712:	2801      	cmp	r0, #1
 800a714:	d003      	beq.n	800a71e <_ZN12ServerTask__11server_bodyEPv+0x42>
		{
			vTaskDelete( *p_task_handle );
 800a716:	2300      	movs	r3, #0
 800a718:	6818      	ldr	r0, [r3, #0]
 800a71a:	f7f8 fc95 	bl	8003048 <vTaskDelete>

	#ifdef USING_RAW_UDP_SERVER
	/* Create another server task */
	(void) RTOS_WRAPPER__::create( raw_udp_server, rus_task_name,
									configMINIMAL_STACK_SIZE<<1, NULL,
									ipconfigIP_TASK_PRIORITY - 1, NULL );
 800a71e:	4b2f      	ldr	r3, [pc, #188]	; (800a7dc <_ZN12ServerTask__11server_bodyEPv+0x100>)
	{
		/* Local Variables */
		BaseType_t ret_status = pdTRUE;
		/* Create Task */
		ret_status = xTaskCreate( fp_task_code, p_name, stack_depth, parameters,
									priority, p_task_handle );
 800a720:	6819      	ldr	r1, [r3, #0]
 800a722:	2302      	movs	r3, #2
 800a724:	9300      	str	r3, [sp, #0]
 800a726:	2300      	movs	r3, #0
 800a728:	9301      	str	r3, [sp, #4]
 800a72a:	482d      	ldr	r0, [pc, #180]	; (800a7e0 <_ZN12ServerTask__11server_bodyEPv+0x104>)
 800a72c:	22f0      	movs	r2, #240	; 0xf0
 800a72e:	f7f8 fb99 	bl	8002e64 <xTaskCreate>
		/* Check return status */
		if( ret_status != pdTRUE )
 800a732:	2801      	cmp	r0, #1
 800a734:	d003      	beq.n	800a73e <_ZN12ServerTask__11server_bodyEPv+0x62>
		{
			vTaskDelete( *p_task_handle );
 800a736:	2300      	movs	r3, #0
 800a738:	6818      	ldr	r0, [r3, #0]
 800a73a:	f7f8 fc85 	bl	8003048 <vTaskDelete>
	#endif

	/* Attempt to open the socket. */
	xListeningSocket = FreeRTOS_socket( FREERTOS_AF_INET, FREERTOS_SOCK_STREAM, FREERTOS_IPPROTO_TCP );
 800a73e:	2002      	movs	r0, #2
 800a740:	2101      	movs	r1, #1
 800a742:	2206      	movs	r2, #6
 800a744:	f7fb fa6c 	bl	8005c20 <FreeRTOS_socket>
 800a748:	4604      	mov	r4, r0
	configASSERT( xListeningSocket != FREERTOS_INVALID_SOCKET );
 800a74a:	f1b0 3fff 	cmp.w	r0, #4294967295
 800a74e:	d108      	bne.n	800a762 <_ZN12ServerTask__11server_bodyEPv+0x86>
 800a750:	f04f 0314 	mov.w	r3, #20
 800a754:	f383 8811 	msr	BASEPRI, r3
 800a758:	f3bf 8f6f 	isb	sy
 800a75c:	f3bf 8f4f 	dsb	sy
 800a760:	e7fe      	b.n	800a760 <_ZN12ServerTask__11server_bodyEPv+0x84>

	/* Set a time out so accept() will just wait for a connection. */
	FreeRTOS_setsockopt( xListeningSocket, 0, FREERTOS_SO_RCVTIMEO, &xReceiveTimeOut, sizeof( xReceiveTimeOut ) );
 800a762:	2304      	movs	r3, #4
 800a764:	9300      	str	r3, [sp, #0]
 800a766:	2100      	movs	r1, #0
 800a768:	460a      	mov	r2, r1
 800a76a:	ab03      	add	r3, sp, #12
 800a76c:	f7fc fab0 	bl	8006cd0 <FreeRTOS_setsockopt>

	/* Bind the socket to the port that the client task will send to,
	 * then listen for incoming connections. */
	xBindAddress.sin_port = INFINEON_HOST_SERVER_PORT;
	xBindAddress.sin_port = FreeRTOS_htons( xBindAddress.sin_port );
 800a770:	f640 4317 	movw	r3, #3095	; 0xc17
 800a774:	f8ad 301a 	strh.w	r3, [sp, #26]
	FreeRTOS_bind( xListeningSocket, &xBindAddress, sizeof( xBindAddress ) );
 800a778:	4620      	mov	r0, r4
 800a77a:	a906      	add	r1, sp, #24
 800a77c:	2208      	movs	r2, #8
 800a77e:	f7fb fbdf 	bl	8005f40 <FreeRTOS_bind>
	FreeRTOS_listen( xListeningSocket, xBacklog );
 800a782:	4620      	mov	r0, r4
 800a784:	2102      	movs	r1, #2
 800a786:	f7fc f927 	bl	80069d8 <FreeRTOS_listen>
	{
		/* Local Variables */
		BaseType_t ret_status = pdTRUE;
		/* Create Task */
		ret_status = xTaskCreate( fp_task_code, p_name, stack_depth, parameters,
									priority, p_task_handle );
 800a78a:	4e16      	ldr	r6, [pc, #88]	; (800a7e4 <_ZN12ServerTask__11server_bodyEPv+0x108>)
 800a78c:	4d16      	ldr	r5, [pc, #88]	; (800a7e8 <_ZN12ServerTask__11server_bodyEPv+0x10c>)

	/* Create task to receive data from client */
	for( ; ; )
	{
		/* Wait for a client to connect. */
		xConnectedSocket = FreeRTOS_accept( xListeningSocket, &xClient, &xSize );
 800a78e:	4620      	mov	r0, r4
 800a790:	a904      	add	r1, sp, #16
 800a792:	aa02      	add	r2, sp, #8
 800a794:	f7fb fed6 	bl	8006544 <FreeRTOS_accept>
 800a798:	4603      	mov	r3, r0
		configASSERT( xConnectedSocket != FREERTOS_INVALID_SOCKET );
 800a79a:	f1b0 3fff 	cmp.w	r0, #4294967295
 800a79e:	d108      	bne.n	800a7b2 <_ZN12ServerTask__11server_bodyEPv+0xd6>
 800a7a0:	f04f 0314 	mov.w	r3, #20
 800a7a4:	f383 8811 	msr	BASEPRI, r3
 800a7a8:	f3bf 8f6f 	isb	sy
 800a7ac:	f3bf 8f4f 	dsb	sy
 800a7b0:	e7fe      	b.n	800a7b0 <_ZN12ServerTask__11server_bodyEPv+0xd4>
 800a7b2:	2204      	movs	r2, #4
 800a7b4:	9200      	str	r2, [sp, #0]
 800a7b6:	2200      	movs	r2, #0
 800a7b8:	9201      	str	r2, [sp, #4]
 800a7ba:	4628      	mov	r0, r5
 800a7bc:	4631      	mov	r1, r6
 800a7be:	22f0      	movs	r2, #240	; 0xf0
 800a7c0:	f7f8 fb50 	bl	8002e64 <xTaskCreate>
		/* Check return status */
		if( ret_status != pdTRUE )
 800a7c4:	2801      	cmp	r0, #1
 800a7c6:	d0e2      	beq.n	800a78e <_ZN12ServerTask__11server_bodyEPv+0xb2>
		{
			vTaskDelete( *p_task_handle );
 800a7c8:	2300      	movs	r3, #0
 800a7ca:	6818      	ldr	r0, [r3, #0]
 800a7cc:	f7f8 fc3c 	bl	8003048 <vTaskDelete>
 800a7d0:	e7dd      	b.n	800a78e <_ZN12ServerTask__11server_bodyEPv+0xb2>
 800a7d2:	bf00      	nop
 800a7d4:	0800a629 	.word	0x0800a629
 800a7d8:	0800adb4 	.word	0x0800adb4
 800a7dc:	2000d800 	.word	0x2000d800
 800a7e0:	0800a635 	.word	0x0800a635
 800a7e4:	0800adc0 	.word	0x0800adc0
 800a7e8:	0800a8c9 	.word	0x0800a8c9

0800a7ec <_ZN12ServerTask__19server_handler_bodyEPv>:
 * @brief		Simple Echo server
 *
 * <i>Imp Note:</i>
 */
void ServerTask__ :: server_handler_body( void * pvParameters )
{
 800a7ec:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800a7f0:	b085      	sub	sp, #20
 800a7f2:	460f      	mov	r7, r1
	Socket_t xConnectedSocket = NULL;
	uint8_t *pucRxBuffer = NULL;
	BaseType_t lBytes = 0;
	BaseType_t lSent = 0;
	BaseType_t lTotalSent = 0;
	constexpr TickType_t xReceiveTimeOut = pdMS_TO_TICKS( portMAX_DELAY );
 800a7f4:	4b32      	ldr	r3, [pc, #200]	; (800a8c0 <_ZN12ServerTask__19server_handler_bodyEPv+0xd4>)
 800a7f6:	9302      	str	r3, [sp, #8]
	constexpr TickType_t xSendTimeOut = pdMS_TO_TICKS( 5000 );
 800a7f8:	f241 3388 	movw	r3, #5000	; 0x1388
 800a7fc:	9303      	str	r3, [sp, #12]

	/* Get the client details */
	xConnectedSocket = (Socket_t) pvParameters;

	/* Send Accept confirmation to client */
	FreeRTOS_send( xConnectedSocket, "Hello\r\n", sizeof("Hello\r\n"), 0 );
 800a7fe:	4608      	mov	r0, r1
 800a800:	4930      	ldr	r1, [pc, #192]	; (800a8c4 <_ZN12ServerTask__19server_handler_bodyEPv+0xd8>)
 800a802:	2208      	movs	r2, #8
 800a804:	2300      	movs	r3, #0
 800a806:	f7fc f80d 	bl	8006824 <FreeRTOS_send>
 * <i>Imp Note:</i>
 *
 */
inline void * operator new[]( size_t size )
{
	return pvPortMalloc( size );
 800a80a:	f44f 6091 	mov.w	r0, #1160	; 0x488
 800a80e:	f7f9 fb65 	bl	8003edc <pvPortMalloc>
	/* Attempt to create the buffer used to receive the string to be echoed
	 * back.  This could be avoided using a zero copy interface that just
	 * returned the same buffer. */
	pucRxBuffer = new uint8_t[ipconfigTCP_MSS];
	/* Check memory allocation for buffer validity */
	if( pucRxBuffer != NULL )
 800a812:	4606      	mov	r6, r0
 800a814:	b368      	cbz	r0, 800a872 <_ZN12ServerTask__19server_handler_bodyEPv+0x86>
	{
		/* Set socket options for client */
		FreeRTOS_setsockopt( xConnectedSocket, 0, FREERTOS_SO_RCVTIMEO, &xReceiveTimeOut, sizeof( xReceiveTimeOut ) );
 800a816:	2404      	movs	r4, #4
 800a818:	9400      	str	r4, [sp, #0]
 800a81a:	4638      	mov	r0, r7
 800a81c:	2100      	movs	r1, #0
 800a81e:	460a      	mov	r2, r1
 800a820:	ab02      	add	r3, sp, #8
 800a822:	f7fc fa55 	bl	8006cd0 <FreeRTOS_setsockopt>
		FreeRTOS_setsockopt( xConnectedSocket, 0, FREERTOS_SO_SNDTIMEO, &xSendTimeOut, sizeof( xReceiveTimeOut ) );
 800a826:	9400      	str	r4, [sp, #0]
 800a828:	4638      	mov	r0, r7
 800a82a:	2100      	movs	r1, #0
 800a82c:	2201      	movs	r2, #1
 800a82e:	ab03      	add	r3, sp, #12
 800a830:	f7fc fa4e 	bl	8006cd0 <FreeRTOS_setsockopt>
		/* Receive data from client */
		for( ; ; )
		{
			/* Zero out the receive array so there is NULL at the end of the string
				when it is printed out. */
			memset( pucRxBuffer, 0x00, ipconfigTCP_MSS );
 800a834:	f44f 6991 	mov.w	r9, #1160	; 0x488
 800a838:	f04f 0800 	mov.w	r8, #0
 800a83c:	4630      	mov	r0, r6
 800a83e:	4641      	mov	r1, r8
 800a840:	464a      	mov	r2, r9
 800a842:	f7ff fb7b 	bl	8009f3c <memset>

			/* Receive data on the socket. */
			lBytes = FreeRTOS_recv( xConnectedSocket, pucRxBuffer, ipconfigTCP_MSS, 0 );
 800a846:	4638      	mov	r0, r7
 800a848:	4631      	mov	r1, r6
 800a84a:	464a      	mov	r2, r9
 800a84c:	4643      	mov	r3, r8
 800a84e:	f7fb ff0f 	bl	8006670 <FreeRTOS_recv>

			/* If data was received, echo it back. */
			if( lBytes >= 0 )
 800a852:	1e05      	subs	r5, r0, #0
 800a854:	db0d      	blt.n	800a872 <_ZN12ServerTask__19server_handler_bodyEPv+0x86>
			{
				lSent = 0;
				lTotalSent = 0;

				/* Call send() until all the data has been sent. */
				while( ( lSent >= 0 ) && ( lTotalSent < lBytes ) )
 800a856:	ddf1      	ble.n	800a83c <_ZN12ServerTask__19server_handler_bodyEPv+0x50>
 800a858:	4644      	mov	r4, r8
				{
					lSent = FreeRTOS_send( xConnectedSocket, pucRxBuffer, lBytes - lTotalSent, 0 );
 800a85a:	4638      	mov	r0, r7
 800a85c:	4631      	mov	r1, r6
 800a85e:	1b2a      	subs	r2, r5, r4
 800a860:	4643      	mov	r3, r8
 800a862:	f7fb ffdf 	bl	8006824 <FreeRTOS_send>
					lTotalSent += lSent;
 800a866:	4404      	add	r4, r0
			{
				lSent = 0;
				lTotalSent = 0;

				/* Call send() until all the data has been sent. */
				while( ( lSent >= 0 ) && ( lTotalSent < lBytes ) )
 800a868:	2800      	cmp	r0, #0
 800a86a:	db02      	blt.n	800a872 <_ZN12ServerTask__19server_handler_bodyEPv+0x86>
 800a86c:	42a5      	cmp	r5, r4
 800a86e:	dcf4      	bgt.n	800a85a <_ZN12ServerTask__19server_handler_bodyEPv+0x6e>
 800a870:	e7e4      	b.n	800a83c <_ZN12ServerTask__19server_handler_bodyEPv+0x50>
			}
		}
	}

	/* Initiate a shutdown in case it has not already been initiated. */
	FreeRTOS_shutdown( xConnectedSocket, FREERTOS_SHUT_RDWR );
 800a872:	4638      	mov	r0, r7
 800a874:	2102      	movs	r1, #2
 800a876:	f7fc f8f9 	bl	8006a6c <FreeRTOS_shutdown>

	/* Wait for the shutdown to take effect, indicated by FreeRTOS_recv()
	 * returning an error. */
	xTimeOnShutdown = xTaskGetTickCount();
 800a87a:	f7f8 fc9f 	bl	80031bc <xTaskGetTickCount>
 800a87e:	4681      	mov	r9, r0
	do
	{
		if( FreeRTOS_recv( xConnectedSocket, pucRxBuffer, ipconfigTCP_MSS, 0 ) < 0 )
 800a880:	f44f 6591 	mov.w	r5, #1160	; 0x488
 800a884:	2400      	movs	r4, #0
	FreeRTOS_shutdown( xConnectedSocket, FREERTOS_SHUT_RDWR );

	/* Wait for the shutdown to take effect, indicated by FreeRTOS_recv()
	 * returning an error. */
	xTimeOnShutdown = xTaskGetTickCount();
	do
 800a886:	f241 3887 	movw	r8, #4999	; 0x1387
	{
		if( FreeRTOS_recv( xConnectedSocket, pucRxBuffer, ipconfigTCP_MSS, 0 ) < 0 )
 800a88a:	4638      	mov	r0, r7
 800a88c:	4631      	mov	r1, r6
 800a88e:	462a      	mov	r2, r5
 800a890:	4623      	mov	r3, r4
 800a892:	f7fb feed 	bl	8006670 <FreeRTOS_recv>
 800a896:	2800      	cmp	r0, #0
 800a898:	db05      	blt.n	800a8a6 <_ZN12ServerTask__19server_handler_bodyEPv+0xba>
		{
			break;
		}
	} while( ( xTaskGetTickCount() - xTimeOnShutdown ) < tcpechoSHUTDOWN_DELAY );
 800a89a:	f7f8 fc8f 	bl	80031bc <xTaskGetTickCount>
 800a89e:	ebc9 0000 	rsb	r0, r9, r0
	FreeRTOS_shutdown( xConnectedSocket, FREERTOS_SHUT_RDWR );

	/* Wait for the shutdown to take effect, indicated by FreeRTOS_recv()
	 * returning an error. */
	xTimeOnShutdown = xTaskGetTickCount();
	do
 800a8a2:	4540      	cmp	r0, r8
 800a8a4:	d9f1      	bls.n	800a88a <_ZN12ServerTask__19server_handler_bodyEPv+0x9e>
			break;
		}
	} while( ( xTaskGetTickCount() - xTimeOnShutdown ) < tcpechoSHUTDOWN_DELAY );

	/* Finished with the socket, buffer, the task. */
	delete[] pucRxBuffer;
 800a8a6:	b116      	cbz	r6, 800a8ae <_ZN12ServerTask__19server_handler_bodyEPv+0xc2>
 * <i>Imp Note:</i>
 *
 */
inline void operator delete[]( void * p_arg )
{
	vPortFree( p_arg );
 800a8a8:	4630      	mov	r0, r6
 800a8aa:	f7f9 fbbb 	bl	8004024 <vPortFree>
	FreeRTOS_closesocket( xConnectedSocket );
 800a8ae:	4638      	mov	r0, r7
 800a8b0:	f7fb fcc6 	bl	8006240 <FreeRTOS_closesocket>

	vTaskDelete( NULL );
 800a8b4:	2000      	movs	r0, #0
 800a8b6:	f7f8 fbc7 	bl	8003048 <vTaskDelete>
}
 800a8ba:	b005      	add	sp, #20
 800a8bc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800a8c0:	00418936 	.word	0x00418936
 800a8c4:	0800add0 	.word	0x0800add0

0800a8c8 <_ZN12ServerTask__20server_handler_entryEPv>:
	 * <i>Imp Note:</i>
	 *
	 */
	void server_body( void *pvParameters );

	static void server_handler_entry( void * pvParameters )
 800a8c8:	b508      	push	{r3, lr}
	{
		/* Pass the control to server handler body */
		((ServerTask__ *) pvParameters)->server_handler_body( pvParameters );
 800a8ca:	4601      	mov	r1, r0
 800a8cc:	f7ff ff8e 	bl	800a7ec <_ZN12ServerTask__19server_handler_bodyEPv>
 800a8d0:	bd08      	pop	{r3, pc}
 800a8d2:	bf00      	nop

0800a8d4 <BusFault_Handler>:
			" ldr r2, bus_fault_handler_address_const                   \n"
			" bx r2                                                     \n"
			" bus_fault_handler_address_const: .word get_registers_from_stack    \n"
	);
#endif
	for( ; ; );
 800a8d4:	e7fe      	b.n	800a8d4 <BusFault_Handler>
 800a8d6:	bf00      	nop

0800a8d8 <HardFault_Handler>:
			" ldr r2, hard_fault_handler_address_const                  \n"
			" bx r2                                                     \n"
			" hard_fault_handler_address_const: .word get_registers_from_stack    \n"
	);
#endif	/* EXCEPTION_HANDLER_DEBUG_ON */
	for( ; ; );
 800a8d8:	e7fe      	b.n	800a8d8 <HardFault_Handler>
 800a8da:	bf00      	nop

0800a8dc <MemManage_Handler>:
         " ldr r2, mem_manage_handler_address_const                  \n"
         " bx r2                                                     \n"
         " mem_manage_handler_address_const: .word get_registers_from_stack    \n"
        );
#endif	/* EXCEPTION_HANDLER_DEBUG_ON */
    for( ; ; );
 800a8dc:	e7fe      	b.n	800a8dc <MemManage_Handler>
 800a8de:	bf00      	nop

0800a8e0 <UsageFault_Handler>:
         " ldr r2, usage_fault_handler_address_const                  \n"
         " bx r2                                                     \n"
         " usage_fault_handler_address_const: .word get_registers_from_stack    \n"
        );
#endif	/* EXCEPTION_HANDLER_DEBUG_ON */
    for( ; ; );
 800a8e0:	e7fe      	b.n	800a8e0 <UsageFault_Handler>
 800a8e2:	bf00      	nop

0800a8e4 <NMI_Handler>:



/** NMI Handler for NMI Traps **/
void NMI_Handler( void )
{
 800a8e4:	b508      	push	{r3, lr}
	/* Local Variables */
	unsigned long status_l = 0;

	#if (USING_BROWN_OUT_DETECT == 1U)
	float power_l = XMC_SCU_POWER_GetEVR33Voltage();
 800a8e6:	f7f6 fb8d 	bl	8001004 <XMC_SCU_POWER_GetEVR33Voltage>
	/* Check System Power */
	if( power_l < BROWN_OUT_DETECT_VOLTAGE )
 800a8ea:	eddf 7a0e 	vldr	s15, [pc, #56]	; 800a924 <NMI_Handler+0x40>
 800a8ee:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800a8f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a8f6:	d506      	bpl.n	800a906 <NMI_Handler+0x22>
 800a8f8:	f04f 1202 	mov.w	r2, #131074	; 0x20002
 800a8fc:	4b0a      	ldr	r3, [pc, #40]	; (800a928 <NMI_Handler+0x44>)
 800a8fe:	605a      	str	r2, [r3, #4]
	{
		XMC_GPIO_ToggleOutput( (XMC_GPIO_PORT_t *)XMC_GPIO_PORT1, 1 );
		/* We have got a Brown-Out trap, clear it for now! */
		XMC_SCU_TRAP_ClearStatus( status_l );
 800a900:	2000      	movs	r0, #0
 800a902:	f7f6 fb21 	bl	8000f48 <XMC_SCU_TRAP_ClearStatus>
	}
	#endif	/* USING_BROWN_OUT_DETECT */

	/* Get SCU Interrupt status */
	status_l = XMC_SCU_INTERUPT_GetEventStatus();
 800a906:	f7f6 fafd 	bl	8000f04 <XMC_SCU_INTERUPT_GetEventStatus>
	/* Watchdog Trap Pre-Warn occured */
	if( status_l & SCU_INTERRUPT_SRRAW_PRWARN_Msk )
 800a90a:	f010 0f01 	tst.w	r0, #1
 800a90e:	d000      	beq.n	800a912 <NMI_Handler+0x2e>
	{
		__asm("NOP");
 800a910:	bf00      	nop
	}
	/* RTC Alarm has occured */
	if( status_l & SCU_INTERRUPT_SRRAW_AI_Msk )
 800a912:	f010 0f04 	tst.w	r0, #4
 800a916:	d002      	beq.n	800a91e <NMI_Handler+0x3a>
	{
		/* TODO: (Update) Ring a Bell using DAC, LED used for test indication (not to be used in projects) */
//		XMC_GPIO_SetOutputLevel( (XMC_GPIO_PORT_t *)XMC_GPIO_PORT1, 1, XMC_GPIO_OUTPUT_LEVEL_HIGH );
		XMC_SCU_INTERRUPT_ClearEventStatus( XMC_SCU_NMIREQ_RTC_AI );
 800a918:	2004      	movs	r0, #4
 800a91a:	f7f6 faf9 	bl	8000f10 <XMC_SCU_INTERRUPT_ClearEventStatus>
	}

	/* Get SCU Trap status register, check specific trap status */
	status_l = XMC_SCU_TRAP_GetStatus();
 800a91e:	f7f6 fb0d 	bl	8000f3c <XMC_SCU_TRAP_GetStatus>
 800a922:	bd08      	pop	{r3, pc}
 800a924:	40333333 	.word	0x40333333
 800a928:	48028100 	.word	0x48028100

0800a92c <_ZN9LedTask__D1Ev>:
	LedTask__() = delete;
	LedTask__( const LedTask__ & ) = delete;
	LedTask__ operator=( const LedTask__& ) = delete;

	/* Destructor for Led task class */
	virtual ~LedTask__()
 800a92c:	b510      	push	{r4, lr}
 800a92e:	4604      	mov	r4, r0
	{
 800a930:	4b03      	ldr	r3, [pc, #12]	; (800a940 <_ZN9LedTask__D1Ev+0x14>)
 800a932:	6003      	str	r3, [r0, #0]
		;/* Do Nothing for now
		or Free Dynamic Allocated Memory (if any) */
		vTaskDelete( xHandle );
 800a934:	6980      	ldr	r0, [r0, #24]
 800a936:	f7f8 fb87 	bl	8003048 <vTaskDelete>
	}
 800a93a:	4620      	mov	r0, r4
 800a93c:	bd10      	pop	{r4, pc}
 800a93e:	bf00      	nop
 800a940:	0800adf0 	.word	0x0800adf0

0800a944 <_ZN9LedTask__D0Ev>:
	LedTask__() = delete;
	LedTask__( const LedTask__ & ) = delete;
	LedTask__ operator=( const LedTask__& ) = delete;

	/* Destructor for Led task class */
	virtual ~LedTask__()
 800a944:	b510      	push	{r4, lr}
 800a946:	4604      	mov	r4, r0
	{
 800a948:	4b04      	ldr	r3, [pc, #16]	; (800a95c <_ZN9LedTask__D0Ev+0x18>)
 800a94a:	6003      	str	r3, [r0, #0]
		;/* Do Nothing for now
		or Free Dynamic Allocated Memory (if any) */
		vTaskDelete( xHandle );
 800a94c:	6980      	ldr	r0, [r0, #24]
 800a94e:	f7f8 fb7b 	bl	8003048 <vTaskDelete>
 * <i>Imp Note:</i>
 *
 */
inline void operator delete( void * p_arg )
{
	vPortFree( p_arg );
 800a952:	4620      	mov	r0, r4
 800a954:	f7f9 fb66 	bl	8004024 <vPortFree>
	}
 800a958:	4620      	mov	r0, r4
 800a95a:	bd10      	pop	{r4, pc}
 800a95c:	0800adf0 	.word	0x0800adf0

0800a960 <_ZN12ServerTask__12server_entryEPv>:
	/** Data Members **/
	const char * const xtask_name = "ServerTask";
	TaskHandle_t * xhandle = nullptr;

	/******* Private Member Functions *******/
	static void server_entry( void * pvParameters )
 800a960:	b508      	push	{r3, lr}
	{
		/* Pass the control to server body */
		((ServerTask__ *) pvParameters)->server_body( pvParameters );
 800a962:	4601      	mov	r1, r0
 800a964:	f7ff feba 	bl	800a6dc <_ZN12ServerTask__11server_bodyEPv>
 800a968:	bd08      	pop	{r3, pc}
 800a96a:	bf00      	nop

0800a96c <main>:
 * @brief main() - Application entry point
 *
 * <b>Details of function</b><br>
 */
int main(void)
{
 800a96c:	b500      	push	{lr}
 800a96e:	b083      	sub	sp, #12
 * <i>Imp Note:</i>
 *
 */
inline void * operator new( size_t size )
{
	return pvPortMalloc( size );
 800a970:	201c      	movs	r0, #28
 800a972:	f7f9 fab3 	bl	8003edc <pvPortMalloc>
class LedTask__
{
public:
	/** Constructors and Destructors */
	explicit LedTask__( XMC_GPIO_PORT_t * port, uint8_t pin, TaskCreationParams *param ) :
		xLedPort(port), xLedPin(pin), xHandle(NULL)
 800a976:	4a1a      	ldr	r2, [pc, #104]	; (800a9e0 <main+0x74>)
 800a978:	6002      	str	r2, [r0, #0]
 800a97a:	4a1a      	ldr	r2, [pc, #104]	; (800a9e4 <main+0x78>)
 800a97c:	6042      	str	r2, [r0, #4]
 800a97e:	2200      	movs	r2, #0
 800a980:	7202      	strb	r2, [r0, #8]
 800a982:	6182      	str	r2, [r0, #24]
	{
		xLedTaskParams.p_name = param->p_name;
 800a984:	4a18      	ldr	r2, [pc, #96]	; (800a9e8 <main+0x7c>)
 800a986:	60c2      	str	r2, [r0, #12]
		xLedTaskParams.priority = param->priority;
 800a988:	2201      	movs	r2, #1
 800a98a:	6142      	str	r2, [r0, #20]
		xLedTaskParams.stackDepth = param->stackDepth;
 800a98c:	2278      	movs	r2, #120	; 0x78
 800a98e:	8202      	strh	r2, [r0, #16]
	 * <i>Imp Note:</i>
	 * Application task creation shall be done using new while creating objects
	 * otherwise Bus Fault Exception will come!!
	 * */
	LedTask__ * LedTask = new LedTask__( XMC_GPIO_PORT1 , 0, &TaskParams );
	LedTask->xvinit();
 800a990:	f7ff fe16 	bl	800a5c0 <_ZN9LedTask__6xvinitEv>
	
	/* Initialize the RTOS’s TCP/IP stack.  The tasks that use the network
	 * are created in the vApplicationIPNetworkEventHook() hook function below.
	 * The hook function is called when the network connects. */
	BaseType_t xReturn = FreeRTOS_IPInit( ucIPAddress, ucNetMask, ucGatewayAddress, ucDNSServerAddress, ucMACAddress );
 800a994:	4b15      	ldr	r3, [pc, #84]	; (800a9ec <main+0x80>)
 800a996:	9300      	str	r3, [sp, #0]
 800a998:	4815      	ldr	r0, [pc, #84]	; (800a9f0 <main+0x84>)
 800a99a:	4916      	ldr	r1, [pc, #88]	; (800a9f4 <main+0x88>)
 800a99c:	4a16      	ldr	r2, [pc, #88]	; (800a9f8 <main+0x8c>)
 800a99e:	4b17      	ldr	r3, [pc, #92]	; (800a9fc <main+0x90>)
 800a9a0:	f7fa fb3c 	bl	800501c <FreeRTOS_IPInit>

	/* Check IP Init status */
	if( xReturn == pdPASS )
 800a9a4:	2801      	cmp	r0, #1
 800a9a6:	d115      	bne.n	800a9d4 <main+0x68>
	{
		/* Local Variables */
		BaseType_t ret_status = pdTRUE;
		/* Create Task */
		ret_status = xTaskCreate( fp_task_code, p_name, stack_depth, parameters,
									priority, p_task_handle );
 800a9a8:	2303      	movs	r3, #3
 800a9aa:	9300      	str	r3, [sp, #0]
 800a9ac:	2300      	movs	r3, #0
 800a9ae:	9301      	str	r3, [sp, #4]
 800a9b0:	4813      	ldr	r0, [pc, #76]	; (800aa00 <main+0x94>)
 800a9b2:	4914      	ldr	r1, [pc, #80]	; (800aa04 <main+0x98>)
 800a9b4:	2278      	movs	r2, #120	; 0x78
 800a9b6:	f7f8 fa55 	bl	8002e64 <xTaskCreate>
		/* Check return status */
		if( ret_status != pdTRUE )
 800a9ba:	2801      	cmp	r0, #1
 800a9bc:	d003      	beq.n	800a9c6 <main+0x5a>
		{
			vTaskDelete( *p_task_handle );
 800a9be:	2300      	movs	r3, #0
 800a9c0:	6818      	ldr	r0, [r3, #0]
 800a9c2:	f7f8 fb41 	bl	8003048 <vTaskDelete>
	{
		/* Create Server Handler task */
		ServerTask__ server( ipconfigIP_TASK_PRIORITY, configMINIMAL_STACK_SIZE );
		/* Start Task Scheduler */
		vTaskStartScheduler();
 800a9c6:	f7f8 fbaf 	bl	8003128 <vTaskStartScheduler>
__STATIC_INLINE void XMC_GPIO_SetOutputLevel(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_OUTPUT_LEVEL_t level)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLevel: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));
  XMC_ASSERT("XMC_GPIO_SetOutputLevel: Invalid output level", XMC_GPIO_CHECK_OUTPUT_LEVEL(level));
  
  port->OMR = (uint32_t)level << pin;
 800a9ca:	2201      	movs	r2, #1
 800a9cc:	4b05      	ldr	r3, [pc, #20]	; (800a9e4 <main+0x78>)
 800a9ce:	605a      	str	r2, [r3, #4]
		/* Processor should never cross from here */
		GPIO__::fp_ctrl( XMC_GPIO_PORT1 , 0, XMC_GPIO_OUTPUT_LEVEL_HIGH );
		for( ; ; )
		{
			__asm("NOP");
 800a9d0:	bf00      	nop
 800a9d2:	e7fd      	b.n	800a9d0 <main+0x64>
 800a9d4:	2201      	movs	r2, #1
 800a9d6:	4b03      	ldr	r3, [pc, #12]	; (800a9e4 <main+0x78>)
 800a9d8:	605a      	str	r2, [r3, #4]
	{
		GPIO__::fp_ctrl( XMC_GPIO_PORT1 , 0, XMC_GPIO_OUTPUT_LEVEL_HIGH );
		/* Could not initialize Network, shall hang N/W related tasks */
		for( ; ; )
		{
			__asm("NOP");
 800a9da:	bf00      	nop
	 * are created in the vApplicationIPNetworkEventHook() hook function below.
	 * The hook function is called when the network connects. */
	BaseType_t xReturn = FreeRTOS_IPInit( ucIPAddress, ucNetMask, ucGatewayAddress, ucDNSServerAddress, ucMACAddress );

	/* Check IP Init status */
	if( xReturn == pdPASS )
 800a9dc:	e7fd      	b.n	800a9da <main+0x6e>
 800a9de:	bf00      	nop
 800a9e0:	0800adf0 	.word	0x0800adf0
 800a9e4:	48028100 	.word	0x48028100
 800a9e8:	0800ae00 	.word	0x0800ae00
 800a9ec:	2000d804 	.word	0x2000d804
 800a9f0:	0800ae18 	.word	0x0800ae18
 800a9f4:	0800ae1c 	.word	0x0800ae1c
 800a9f8:	0800adfc 	.word	0x0800adfc
 800a9fc:	0800adf8 	.word	0x0800adf8
 800aa00:	0800a961 	.word	0x0800a961
 800aa04:	0800ae0c 	.word	0x0800ae0c

0800aa08 <init_user_before_main>:
 *
 * <i>Imp Note:</i>
 *
 */
extern "C" void init_user_before_main( void )
{
 800aa08:	b508      	push	{r3, lr}
	extern void init_system_before_main( void );
	init_system_before_main();
 800aa0a:	f7f5 fc73 	bl	80002f4 <init_system_before_main>

	/* Initialize GPIO Pin functionalities */
	extern void gpio_init_c( void );
	gpio_init_c();
 800aa0e:	f7ff fae3 	bl	8009fd8 <gpio_init_c>

	/*----------------- Initialize Peripherals --------------------*/

	/* Initialize UART Channels */
	UART_init( &UART_Channel_0, 1 );	/* Used for Application Logging */
 800aa12:	480e      	ldr	r0, [pc, #56]	; (800aa4c <init_user_before_main+0x44>)
 800aa14:	2101      	movs	r1, #1
 800aa16:	f7fe fd85 	bl	8009524 <UART_init>

	/* Initialize CAN Module */
	CAN_module_init( &CAN_Global, 1 );
 800aa1a:	480d      	ldr	r0, [pc, #52]	; (800aa50 <init_user_before_main+0x48>)
 800aa1c:	2101      	movs	r1, #1
 800aa1e:	f7ff fadf 	bl	8009fe0 <CAN_module_init>
	/* Initialize CAN Nodes */
	CAN_node_init( &CAN1, 1, 1 );
 800aa22:	480c      	ldr	r0, [pc, #48]	; (800aa54 <init_user_before_main+0x4c>)
 800aa24:	2101      	movs	r1, #1
 800aa26:	460a      	mov	r2, r1
 800aa28:	f7ff fafe 	bl	800a028 <CAN_node_init>
	CAN_node_init( &CAN2, 2, 1 );
 800aa2c:	480a      	ldr	r0, [pc, #40]	; (800aa58 <init_user_before_main+0x50>)
 800aa2e:	2102      	movs	r1, #2
 800aa30:	2201      	movs	r2, #1
 800aa32:	f7ff faf9 	bl	800a028 <CAN_node_init>

	/* Initialize Ethernet MAC */
	extern void initialize_ethernet_mac( void );	/* MAC Initialization fucntion */
	initialize_ethernet_mac();
 800aa36:	f7f9 fc7b 	bl	8004330 <initialize_ethernet_mac>

	/* Initialize SCU and WDT */
	SCU_init( &SCU, 1 );
 800aa3a:	4808      	ldr	r0, [pc, #32]	; (800aa5c <init_user_before_main+0x54>)
 800aa3c:	2101      	movs	r1, #1
 800aa3e:	f7ff f961 	bl	8009d04 <SCU_init>
	/* Initialize RTC */
	RTC_init( &RTC_, 1 );
 800aa42:	4807      	ldr	r0, [pc, #28]	; (800aa60 <init_user_before_main+0x58>)
 800aa44:	2101      	movs	r1, #1
 800aa46:	f7ff f9df 	bl	8009e08 <RTC_init>
 800aa4a:	bd08      	pop	{r3, pc}
 800aa4c:	2000d5f8 	.word	0x2000d5f8
 800aa50:	2000d694 	.word	0x2000d694
 800aa54:	2000d7c8 	.word	0x2000d7c8
 800aa58:	2000d7d4 	.word	0x2000d7d4
 800aa5c:	2000d658 	.word	0x2000d658
 800aa60:	2000d674 	.word	0x2000d674

0800aa64 <UART_callback_handler>:
{
	/* Local variables */
	unsigned char * p_data_l = p_data;

	/* Check events */
	switch( event )
 800aa64:	2a06      	cmp	r2, #6
 800aa66:	d008      	beq.n	800aa7a <UART_callback_handler+0x16>
 800aa68:	2a08      	cmp	r2, #8
 800aa6a:	d002      	beq.n	800aa72 <UART_callback_handler+0xe>
	{
		default:
		case UART_EVENT_TX_COMPLETE:
			if( UART_CHANNEL_0 == channel )
 800aa6c:	b900      	cbnz	r0, 800aa70 <UART_callback_handler+0xc>
			{
				/* Transmission successful! */
				__asm("NOP");
 800aa6e:	bf00      	nop
 800aa70:	4770      	bx	lr
			}
			break;

		case UART_EVENT_RX_COMPLETE:
			if( UART_CHANNEL_0 == channel )
 800aa72:	2800      	cmp	r0, #0
 800aa74:	d1fc      	bne.n	800aa70 <UART_callback_handler+0xc>
			{
				/* Reception successful! */
				__asm("NOP");
 800aa76:	bf00      	nop
 800aa78:	4770      	bx	lr
			}
			break;
		case UART_EVENT_RX_CHAR:
			switch( channel )
 800aa7a:	2802      	cmp	r0, #2
 800aa7c:	d0f8      	beq.n	800aa70 <UART_callback_handler+0xc>

#if (UART_CALLBACK_HANDLER_USED == 1U)
/* UART Callback handler */
void UART_callback_handler( const eUART_Channel channel, unsigned char *p_data, const eUART_Event event );
void UART_callback_handler( const eUART_Channel channel, unsigned char *p_data, const eUART_Event event )
{
 800aa7e:	b508      	push	{r3, lr}
			switch( channel )
			{
			default:
			case UART_CHANNEL_0:
				/* Reception successfull, transmit received data */
				UART_Api_Functions.fp_transmit( &UART_Channel_0, p_data_l, 1 );
 800aa80:	4b02      	ldr	r3, [pc, #8]	; (800aa8c <UART_callback_handler+0x28>)
 800aa82:	689b      	ldr	r3, [r3, #8]
 800aa84:	4802      	ldr	r0, [pc, #8]	; (800aa90 <UART_callback_handler+0x2c>)
 800aa86:	2201      	movs	r2, #1
 800aa88:	4798      	blx	r3
 800aa8a:	bd08      	pop	{r3, pc}
 800aa8c:	2000d608 	.word	0x2000d608
 800aa90:	2000d5f8 	.word	0x2000d5f8

0800aa94 <CAN_callback_handler>:
/* CAN Callback Handler */
#if (CAN_CALLBACK_HANDLER_USED == 1U)
void CAN_callback_handler( void * p_channel, const eCAN_EventType event_type, const eCAN_Event event );
void CAN_callback_handler( void * p_channel, const eCAN_EventType event_type, const eCAN_Event event )
{
	DRIVER_ASSERT_NRET( NULL == p_channel );
 800aa94:	b900      	cbnz	r0, 800aa98 <CAN_callback_handler+0x4>
 800aa96:	e7fe      	b.n	800aa96 <CAN_callback_handler+0x2>

/* CAN Callback Handler */
#if (CAN_CALLBACK_HANDLER_USED == 1U)
void CAN_callback_handler( void * p_channel, const eCAN_EventType event_type, const eCAN_Event event );
void CAN_callback_handler( void * p_channel, const eCAN_EventType event_type, const eCAN_Event event )
{
 800aa98:	b510      	push	{r4, lr}
	DRIVER_ASSERT_NRET( NULL == p_channel );
	/* Local Variables */
	tStCAN_NodeConfiguartion * const p_config_l = ((tStCAN_Node *)p_channel)->p_config;
 800aa9a:	6801      	ldr	r1, [r0, #0]
	tStCAN_Control * const p_control_l = ((tStCAN_Node *)p_channel)->p_control;
 800aa9c:	6844      	ldr	r4, [r0, #4]
	switch( event_type )
	{
	default:
		case CAN_EVENT_TYPE_NODE_TRANSFER:
		/* Check Node Transfer event */
		switch( event )
 800aa9e:	2a01      	cmp	r2, #1
 800aaa0:	d00c      	beq.n	800aabc <CAN_callback_handler+0x28>
		{
		default:
			case CAN_EVENT_NODE_TRANSFER_TRANSMIT:
				if( (1 == p_control_l->state.init) && (1 == p_control_l->state.tx_busy) )
 800aaa2:	6823      	ldr	r3, [r4, #0]
 800aaa4:	f013 0f01 	tst.w	r3, #1
 800aaa8:	d017      	beq.n	800aada <CAN_callback_handler+0x46>
 800aaaa:	6823      	ldr	r3, [r4, #0]
 800aaac:	f013 0f02 	tst.w	r3, #2
 800aab0:	d013      	beq.n	800aada <CAN_callback_handler+0x46>
				{
					p_control_l->state.tx_busy = 0;
 800aab2:	6823      	ldr	r3, [r4, #0]
 800aab4:	f023 0302 	bic.w	r3, r3, #2
 800aab8:	6023      	str	r3, [r4, #0]
 800aaba:	bd10      	pop	{r4, pc}
				}
			break;
			case CAN_EVENT_NODE_TRANSFER_RECEIVE:
				if( (1 == p_control_l->state.init) && (0 == p_control_l->state.rx_busy) )
 800aabc:	6823      	ldr	r3, [r4, #0]
 800aabe:	f013 0f01 	tst.w	r3, #1
 800aac2:	d00a      	beq.n	800aada <CAN_callback_handler+0x46>
 800aac4:	6823      	ldr	r3, [r4, #0]
 800aac6:	f013 0f04 	tst.w	r3, #4
 800aaca:	d106      	bne.n	800aada <CAN_callback_handler+0x46>
				{
					XMC_CAN_MO_ReceiveData( p_config_l->p_message_rx );
 800aacc:	68c8      	ldr	r0, [r1, #12]
 800aace:	f7f6 fc39 	bl	8001344 <XMC_CAN_MO_ReceiveData>
					p_control_l->state.rx_busy = 0;
 800aad2:	6823      	ldr	r3, [r4, #0]
 800aad4:	f023 0304 	bic.w	r3, r3, #4
 800aad8:	6023      	str	r3, [r4, #0]
 800aada:	bd10      	pop	{r4, pc}

0800aadc <SCU_callback_handler>:
/* SCU Callback Handler */
#if (SCU_CALLBACK_HANDLER_USED == 1U)
void SCU_callback_handler( void );
void SCU_callback_handler( void )
{
	__asm("NOP");
 800aadc:	bf00      	nop
 800aade:	4770      	bx	lr

0800aae0 <RTC_callback_handler>:

/* RTC Callback Handler */
#if (RTC_CALLBACK_HANDLER_USED == 1U)
void RTC_callback_handler( void * p_channel, const eRTC_Events event );
void RTC_callback_handler( void * p_channel, const eRTC_Events event )
{
 800aae0:	4770      	bx	lr
 800aae2:	bf00      	nop

0800aae4 <vApplicationStackOverflowHook>:
/*-----------------------------------------------------------*/

#if(  configCHECK_FOR_STACK_OVERFLOW > 0 )
void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName )
{
 800aae4:	4770      	bx	lr
 800aae6:	bf00      	nop

0800aae8 <vApplicationIdleHook>:
void vApplicationIdleHook( void );
void vApplicationIdleHook( void )
{
	/* It must *NOT* attempt to block.  In this case the
	 * idle task just sleeps or yields to lower the CPU usage. */
	portYIELD();
 800aae8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800aaec:	4b03      	ldr	r3, [pc, #12]	; (800aafc <vApplicationIdleHook+0x14>)
 800aaee:	601a      	str	r2, [r3, #0]
 800aaf0:	f3bf 8f4f 	dsb	sy
 800aaf4:	f3bf 8f6f 	isb	sy
 800aaf8:	4770      	bx	lr
 800aafa:	bf00      	nop
 800aafc:	e000ed04 	.word	0xe000ed04

0800ab00 <vApplicationMallocFailedHook>:
	configTOTAL_HEAP_SIZE configuration constant in FreeRTOSConfig.h. */

    /* Report malloc failed hook */
	for( ; ; )
	{
		__asm("NOP");
 800ab00:	bf00      	nop
	}
 800ab02:	e7fd      	b.n	800ab00 <vApplicationMallocFailedHook>

0800ab04 <uxRand>:
{
const uint32_t ulMultiplier = 0x015a4e35UL, ulIncrement = 1UL;

	/* Utility function to generate a pseudo random number. */

	ulNextRand = ( ulMultiplier * ulNextRand ) + ulIncrement;
 800ab04:	4a04      	ldr	r2, [pc, #16]	; (800ab18 <uxRand+0x14>)
 800ab06:	6810      	ldr	r0, [r2, #0]
 800ab08:	4b04      	ldr	r3, [pc, #16]	; (800ab1c <uxRand+0x18>)
 800ab0a:	fb03 f000 	mul.w	r0, r3, r0
 800ab0e:	3001      	adds	r0, #1
 800ab10:	6010      	str	r0, [r2, #0]
	return( ( int ) ( ulNextRand >> 16UL ) & 0x7fffUL );
}
 800ab12:	f3c0 400e 	ubfx	r0, r0, #16, #15
 800ab16:	4770      	bx	lr
 800ab18:	2000d428 	.word	0x2000d428
 800ab1c:	015a4e35 	.word	0x015a4e35

0800ab20 <ulApplicationGetNextSequenceNumber>:
uint32_t ulApplicationGetNextSequenceNumber( uint32_t ulSourceAddress,
uint16_t usSourcePort, uint32_t ulDestinationAddress, uint16_t usDestinationPort );
uint32_t ulApplicationGetNextSequenceNumber( uint32_t ulSourceAddress, uint16_t usSourcePort,
						uint32_t ulDestinationAddress, uint16_t usDestinationPort
						)
{
 800ab20:	b508      	push	{r3, lr}
     ( void ) ulSourceAddress;
     ( void ) usSourcePort;
     ( void ) ulDestinationAddress;
     ( void ) usDestinationPort;

     return uxRand();
 800ab22:	f7ff ffef 	bl	800ab04 <uxRand>
}
 800ab26:	bd08      	pop	{r3, pc}

0800ab28 <xApplicationGetRandomNumber>:


BaseType_t xApplicationGetRandomNumber( uint32_t *pulNumber );
BaseType_t xApplicationGetRandomNumber( uint32_t *pulNumber )
{
 800ab28:	b510      	push	{r4, lr}
 800ab2a:	4604      	mov	r4, r0
	*pulNumber = uxRand();
 800ab2c:	f7ff ffea 	bl	800ab04 <uxRand>
 800ab30:	6020      	str	r0, [r4, #0]
	return pdTRUE;
}
 800ab32:	2001      	movs	r0, #1
 800ab34:	bd10      	pop	{r4, pc}
 800ab36:	bf00      	nop
