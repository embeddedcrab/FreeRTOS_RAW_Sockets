   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .eabi_attribute 28,1
   5              	 .fpu fpv4-sp-d16
   6              	 .eabi_attribute 23,1
   7              	 .eabi_attribute 24,1
   8              	 .eabi_attribute 25,1
   9              	 .eabi_attribute 26,1
  10              	 .eabi_attribute 30,1
  11              	 .eabi_attribute 34,1
  12              	 .eabi_attribute 18,4
  13              	 .thumb
  14              	 .file "stream_buffer.c"
  15              	 .text
  16              	.Ltext0:
  17              	 .cfi_sections .debug_frame
  18              	 .section .text.prvBytesInBuffer,"ax",%progbits
  19              	 .align 2
  20              	 .thumb
  21              	 .thumb_func
  23              	prvBytesInBuffer:
  24              	.LFB24:
  25              	 .file 1 "../FreeRTOS/Source/stream_buffer.c"
   1:../FreeRTOS/Source/stream_buffer.c **** /*
   2:../FreeRTOS/Source/stream_buffer.c ****  * FreeRTOS Kernel V10.4.1
   3:../FreeRTOS/Source/stream_buffer.c ****  * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:../FreeRTOS/Source/stream_buffer.c ****  *
   5:../FreeRTOS/Source/stream_buffer.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:../FreeRTOS/Source/stream_buffer.c ****  * this software and associated documentation files (the "Software"), to deal in
   7:../FreeRTOS/Source/stream_buffer.c ****  * the Software without restriction, including without limitation the rights to
   8:../FreeRTOS/Source/stream_buffer.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:../FreeRTOS/Source/stream_buffer.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:../FreeRTOS/Source/stream_buffer.c ****  * subject to the following conditions:
  11:../FreeRTOS/Source/stream_buffer.c ****  *
  12:../FreeRTOS/Source/stream_buffer.c ****  * The above copyright notice and this permission notice shall be included in all
  13:../FreeRTOS/Source/stream_buffer.c ****  * copies or substantial portions of the Software.
  14:../FreeRTOS/Source/stream_buffer.c ****  *
  15:../FreeRTOS/Source/stream_buffer.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:../FreeRTOS/Source/stream_buffer.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:../FreeRTOS/Source/stream_buffer.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:../FreeRTOS/Source/stream_buffer.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:../FreeRTOS/Source/stream_buffer.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:../FreeRTOS/Source/stream_buffer.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:../FreeRTOS/Source/stream_buffer.c ****  *
  22:../FreeRTOS/Source/stream_buffer.c ****  * https://www.FreeRTOS.org
  23:../FreeRTOS/Source/stream_buffer.c ****  * https://github.com/FreeRTOS
  24:../FreeRTOS/Source/stream_buffer.c ****  *
  25:../FreeRTOS/Source/stream_buffer.c ****  */
  26:../FreeRTOS/Source/stream_buffer.c **** 
  27:../FreeRTOS/Source/stream_buffer.c **** /* Standard includes. */
  28:../FreeRTOS/Source/stream_buffer.c **** #include <stdint.h>
  29:../FreeRTOS/Source/stream_buffer.c **** #include <string.h>
  30:../FreeRTOS/Source/stream_buffer.c **** 
  31:../FreeRTOS/Source/stream_buffer.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  32:../FreeRTOS/Source/stream_buffer.c ****  * all the API functions to use the MPU wrappers.  That should only be done when
  33:../FreeRTOS/Source/stream_buffer.c ****  * task.h is included from an application file. */
  34:../FreeRTOS/Source/stream_buffer.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  35:../FreeRTOS/Source/stream_buffer.c **** 
  36:../FreeRTOS/Source/stream_buffer.c **** /* FreeRTOS includes. */
  37:../FreeRTOS/Source/stream_buffer.c **** #include "FreeRTOS.h"
  38:../FreeRTOS/Source/stream_buffer.c **** #include "task.h"
  39:../FreeRTOS/Source/stream_buffer.c **** #include "stream_buffer.h"
  40:../FreeRTOS/Source/stream_buffer.c **** 
  41:../FreeRTOS/Source/stream_buffer.c **** #if ( configUSE_TASK_NOTIFICATIONS != 1 )
  42:../FreeRTOS/Source/stream_buffer.c ****     #error configUSE_TASK_NOTIFICATIONS must be set to 1 to build stream_buffer.c
  43:../FreeRTOS/Source/stream_buffer.c **** #endif
  44:../FreeRTOS/Source/stream_buffer.c **** 
  45:../FreeRTOS/Source/stream_buffer.c **** /* Lint e961, e9021 and e750 are suppressed as a MISRA exception justified
  46:../FreeRTOS/Source/stream_buffer.c ****  * because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
  47:../FreeRTOS/Source/stream_buffer.c ****  * for the header files above, but not in this file, in order to generate the
  48:../FreeRTOS/Source/stream_buffer.c ****  * correct privileged Vs unprivileged linkage and placement. */
  49:../FreeRTOS/Source/stream_buffer.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
  50:../FreeRTOS/Source/stream_buffer.c **** 
  51:../FreeRTOS/Source/stream_buffer.c **** /* If the user has not provided application specific Rx notification macros,
  52:../FreeRTOS/Source/stream_buffer.c ****  * or #defined the notification macros away, them provide default implementations
  53:../FreeRTOS/Source/stream_buffer.c ****  * that uses task notifications. */
  54:../FreeRTOS/Source/stream_buffer.c **** /*lint -save -e9026 Function like macros allowed and needed here so they can be overridden. */
  55:../FreeRTOS/Source/stream_buffer.c **** #ifndef sbRECEIVE_COMPLETED
  56:../FreeRTOS/Source/stream_buffer.c ****     #define sbRECEIVE_COMPLETED( pxStreamBuffer )                         \
  57:../FreeRTOS/Source/stream_buffer.c ****     vTaskSuspendAll();                                                    \
  58:../FreeRTOS/Source/stream_buffer.c ****     {                                                                     \
  59:../FreeRTOS/Source/stream_buffer.c ****         if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )              \
  60:../FreeRTOS/Source/stream_buffer.c ****         {                                                                 \
  61:../FreeRTOS/Source/stream_buffer.c ****             ( void ) xTaskNotify( ( pxStreamBuffer )->xTaskWaitingToSend, \
  62:../FreeRTOS/Source/stream_buffer.c ****                                   ( uint32_t ) 0,                         \
  63:../FreeRTOS/Source/stream_buffer.c ****                                   eNoAction );                            \
  64:../FreeRTOS/Source/stream_buffer.c ****             ( pxStreamBuffer )->xTaskWaitingToSend = NULL;                \
  65:../FreeRTOS/Source/stream_buffer.c ****         }                                                                 \
  66:../FreeRTOS/Source/stream_buffer.c ****     }                                                                     \
  67:../FreeRTOS/Source/stream_buffer.c ****     ( void ) xTaskResumeAll();
  68:../FreeRTOS/Source/stream_buffer.c **** #endif /* sbRECEIVE_COMPLETED */
  69:../FreeRTOS/Source/stream_buffer.c **** 
  70:../FreeRTOS/Source/stream_buffer.c **** #ifndef sbRECEIVE_COMPLETED_FROM_ISR
  71:../FreeRTOS/Source/stream_buffer.c ****     #define sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer,                            \
  72:../FreeRTOS/Source/stream_buffer.c ****                                           pxHigherPriorityTaskWoken )                \
  73:../FreeRTOS/Source/stream_buffer.c ****     {                                                                                \
  74:../FreeRTOS/Source/stream_buffer.c ****         UBaseType_t uxSavedInterruptStatus;                                          \
  75:../FreeRTOS/Source/stream_buffer.c ****                                                                                      \
  76:../FreeRTOS/Source/stream_buffer.c ****         uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();  \
  77:../FreeRTOS/Source/stream_buffer.c ****         {                                                                            \
  78:../FreeRTOS/Source/stream_buffer.c ****             if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )                     \
  79:../FreeRTOS/Source/stream_buffer.c ****             {                                                                        \
  80:../FreeRTOS/Source/stream_buffer.c ****                 ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend, \
  81:../FreeRTOS/Source/stream_buffer.c ****                                              ( uint32_t ) 0,                         \
  82:../FreeRTOS/Source/stream_buffer.c ****                                              eNoAction,                              \
  83:../FreeRTOS/Source/stream_buffer.c ****                                              pxHigherPriorityTaskWoken );            \
  84:../FreeRTOS/Source/stream_buffer.c ****                 ( pxStreamBuffer )->xTaskWaitingToSend = NULL;                       \
  85:../FreeRTOS/Source/stream_buffer.c ****             }                                                                        \
  86:../FreeRTOS/Source/stream_buffer.c ****         }                                                                            \
  87:../FreeRTOS/Source/stream_buffer.c ****         portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );                 \
  88:../FreeRTOS/Source/stream_buffer.c ****     }
  89:../FreeRTOS/Source/stream_buffer.c **** #endif /* sbRECEIVE_COMPLETED_FROM_ISR */
  90:../FreeRTOS/Source/stream_buffer.c **** 
  91:../FreeRTOS/Source/stream_buffer.c **** /* If the user has not provided an application specific Tx notification macro,
  92:../FreeRTOS/Source/stream_buffer.c ****  * or #defined the notification macro away, them provide a default implementation
  93:../FreeRTOS/Source/stream_buffer.c ****  * that uses task notifications. */
  94:../FreeRTOS/Source/stream_buffer.c **** #ifndef sbSEND_COMPLETED
  95:../FreeRTOS/Source/stream_buffer.c ****     #define sbSEND_COMPLETED( pxStreamBuffer )                               \
  96:../FreeRTOS/Source/stream_buffer.c ****     vTaskSuspendAll();                                                       \
  97:../FreeRTOS/Source/stream_buffer.c ****     {                                                                        \
  98:../FreeRTOS/Source/stream_buffer.c ****         if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )              \
  99:../FreeRTOS/Source/stream_buffer.c ****         {                                                                    \
 100:../FreeRTOS/Source/stream_buffer.c ****             ( void ) xTaskNotify( ( pxStreamBuffer )->xTaskWaitingToReceive, \
 101:../FreeRTOS/Source/stream_buffer.c ****                                   ( uint32_t ) 0,                            \
 102:../FreeRTOS/Source/stream_buffer.c ****                                   eNoAction );                               \
 103:../FreeRTOS/Source/stream_buffer.c ****             ( pxStreamBuffer )->xTaskWaitingToReceive = NULL;                \
 104:../FreeRTOS/Source/stream_buffer.c ****         }                                                                    \
 105:../FreeRTOS/Source/stream_buffer.c ****     }                                                                        \
 106:../FreeRTOS/Source/stream_buffer.c ****     ( void ) xTaskResumeAll();
 107:../FreeRTOS/Source/stream_buffer.c **** #endif /* sbSEND_COMPLETED */
 108:../FreeRTOS/Source/stream_buffer.c **** 
 109:../FreeRTOS/Source/stream_buffer.c **** #ifndef sbSEND_COMPLETE_FROM_ISR
 110:../FreeRTOS/Source/stream_buffer.c ****     #define sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken )       \
 111:../FreeRTOS/Source/stream_buffer.c ****     {                                                                                   \
 112:../FreeRTOS/Source/stream_buffer.c ****         UBaseType_t uxSavedInterruptStatus;                                             \
 113:../FreeRTOS/Source/stream_buffer.c ****                                                                                         \
 114:../FreeRTOS/Source/stream_buffer.c ****         uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();     \
 115:../FreeRTOS/Source/stream_buffer.c ****         {                                                                               \
 116:../FreeRTOS/Source/stream_buffer.c ****             if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )                     \
 117:../FreeRTOS/Source/stream_buffer.c ****             {                                                                           \
 118:../FreeRTOS/Source/stream_buffer.c ****                 ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive, \
 119:../FreeRTOS/Source/stream_buffer.c ****                                              ( uint32_t ) 0,                            \
 120:../FreeRTOS/Source/stream_buffer.c ****                                              eNoAction,                                 \
 121:../FreeRTOS/Source/stream_buffer.c ****                                              pxHigherPriorityTaskWoken );               \
 122:../FreeRTOS/Source/stream_buffer.c ****                 ( pxStreamBuffer )->xTaskWaitingToReceive = NULL;                       \
 123:../FreeRTOS/Source/stream_buffer.c ****             }                                                                           \
 124:../FreeRTOS/Source/stream_buffer.c ****         }                                                                               \
 125:../FreeRTOS/Source/stream_buffer.c ****         portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );                    \
 126:../FreeRTOS/Source/stream_buffer.c ****     }
 127:../FreeRTOS/Source/stream_buffer.c **** #endif /* sbSEND_COMPLETE_FROM_ISR */
 128:../FreeRTOS/Source/stream_buffer.c **** /*lint -restore (9026) */
 129:../FreeRTOS/Source/stream_buffer.c **** 
 130:../FreeRTOS/Source/stream_buffer.c **** /* The number of bytes used to hold the length of a message in the buffer. */
 131:../FreeRTOS/Source/stream_buffer.c **** #define sbBYTES_TO_STORE_MESSAGE_LENGTH    ( sizeof( configMESSAGE_BUFFER_LENGTH_TYPE ) )
 132:../FreeRTOS/Source/stream_buffer.c **** 
 133:../FreeRTOS/Source/stream_buffer.c **** /* Bits stored in the ucFlags field of the stream buffer. */
 134:../FreeRTOS/Source/stream_buffer.c **** #define sbFLAGS_IS_MESSAGE_BUFFER          ( ( uint8_t ) 1 ) /* Set if the stream buffer was create
 135:../FreeRTOS/Source/stream_buffer.c **** #define sbFLAGS_IS_STATICALLY_ALLOCATED    ( ( uint8_t ) 2 ) /* Set if the stream buffer was create
 136:../FreeRTOS/Source/stream_buffer.c **** 
 137:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
 138:../FreeRTOS/Source/stream_buffer.c **** 
 139:../FreeRTOS/Source/stream_buffer.c **** /* Structure that hold state information on the buffer. */
 140:../FreeRTOS/Source/stream_buffer.c **** typedef struct StreamBufferDef_t                 /*lint !e9058 Style convention uses tag. */
 141:../FreeRTOS/Source/stream_buffer.c **** {
 142:../FreeRTOS/Source/stream_buffer.c ****     volatile size_t xTail;                       /* Index to the next item to read within the buffe
 143:../FreeRTOS/Source/stream_buffer.c ****     volatile size_t xHead;                       /* Index to the next item to write within the buff
 144:../FreeRTOS/Source/stream_buffer.c ****     size_t xLength;                              /* The length of the buffer pointed to by pucBuffe
 145:../FreeRTOS/Source/stream_buffer.c ****     size_t xTriggerLevelBytes;                   /* The number of bytes that must be in the stream 
 146:../FreeRTOS/Source/stream_buffer.c ****     volatile TaskHandle_t xTaskWaitingToReceive; /* Holds the handle of a task waiting for data, or
 147:../FreeRTOS/Source/stream_buffer.c ****     volatile TaskHandle_t xTaskWaitingToSend;    /* Holds the handle of a task waiting to send data
 148:../FreeRTOS/Source/stream_buffer.c ****     uint8_t * pucBuffer;                         /* Points to the buffer itself - that is - the RAM
 149:../FreeRTOS/Source/stream_buffer.c ****     uint8_t ucFlags;
 150:../FreeRTOS/Source/stream_buffer.c **** 
 151:../FreeRTOS/Source/stream_buffer.c ****     #if ( configUSE_TRACE_FACILITY == 1 )
 152:../FreeRTOS/Source/stream_buffer.c ****         UBaseType_t uxStreamBufferNumber; /* Used for tracing purposes. */
 153:../FreeRTOS/Source/stream_buffer.c ****     #endif
 154:../FreeRTOS/Source/stream_buffer.c **** } StreamBuffer_t;
 155:../FreeRTOS/Source/stream_buffer.c **** 
 156:../FreeRTOS/Source/stream_buffer.c **** /*
 157:../FreeRTOS/Source/stream_buffer.c ****  * The number of bytes available to be read from the buffer.
 158:../FreeRTOS/Source/stream_buffer.c ****  */
 159:../FreeRTOS/Source/stream_buffer.c **** static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer ) PRIVILEGED_FUNCTION;
 160:../FreeRTOS/Source/stream_buffer.c **** 
 161:../FreeRTOS/Source/stream_buffer.c **** /*
 162:../FreeRTOS/Source/stream_buffer.c ****  * Add xCount bytes from pucData into the pxStreamBuffer message buffer.
 163:../FreeRTOS/Source/stream_buffer.c ****  * Returns the number of bytes written, which will either equal xCount in the
 164:../FreeRTOS/Source/stream_buffer.c ****  * success case, or 0 if there was not enough space in the buffer (in which case
 165:../FreeRTOS/Source/stream_buffer.c ****  * no data is written into the buffer).
 166:../FreeRTOS/Source/stream_buffer.c ****  */
 167:../FreeRTOS/Source/stream_buffer.c **** static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer,
 168:../FreeRTOS/Source/stream_buffer.c ****                                      const uint8_t * pucData,
 169:../FreeRTOS/Source/stream_buffer.c ****                                      size_t xCount ) PRIVILEGED_FUNCTION;
 170:../FreeRTOS/Source/stream_buffer.c **** 
 171:../FreeRTOS/Source/stream_buffer.c **** /*
 172:../FreeRTOS/Source/stream_buffer.c ****  * If the stream buffer is being used as a message buffer, then reads an entire
 173:../FreeRTOS/Source/stream_buffer.c ****  * message out of the buffer.  If the stream buffer is being used as a stream
 174:../FreeRTOS/Source/stream_buffer.c ****  * buffer then read as many bytes as possible from the buffer.
 175:../FreeRTOS/Source/stream_buffer.c ****  * prvReadBytesFromBuffer() is called to actually extract the bytes from the
 176:../FreeRTOS/Source/stream_buffer.c ****  * buffer's data storage area.
 177:../FreeRTOS/Source/stream_buffer.c ****  */
 178:../FreeRTOS/Source/stream_buffer.c **** static size_t prvReadMessageFromBuffer( StreamBuffer_t * pxStreamBuffer,
 179:../FreeRTOS/Source/stream_buffer.c ****                                         void * pvRxData,
 180:../FreeRTOS/Source/stream_buffer.c ****                                         size_t xBufferLengthBytes,
 181:../FreeRTOS/Source/stream_buffer.c ****                                         size_t xBytesAvailable,
 182:../FreeRTOS/Source/stream_buffer.c ****                                         size_t xBytesToStoreMessageLength ) PRIVILEGED_FUNCTION;
 183:../FreeRTOS/Source/stream_buffer.c **** 
 184:../FreeRTOS/Source/stream_buffer.c **** /*
 185:../FreeRTOS/Source/stream_buffer.c ****  * If the stream buffer is being used as a message buffer, then writes an entire
 186:../FreeRTOS/Source/stream_buffer.c ****  * message to the buffer.  If the stream buffer is being used as a stream
 187:../FreeRTOS/Source/stream_buffer.c ****  * buffer then write as many bytes as possible to the buffer.
 188:../FreeRTOS/Source/stream_buffer.c ****  * prvWriteBytestoBuffer() is called to actually send the bytes to the buffer's
 189:../FreeRTOS/Source/stream_buffer.c ****  * data storage area.
 190:../FreeRTOS/Source/stream_buffer.c ****  */
 191:../FreeRTOS/Source/stream_buffer.c **** static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
 192:../FreeRTOS/Source/stream_buffer.c ****                                        const void * pvTxData,
 193:../FreeRTOS/Source/stream_buffer.c ****                                        size_t xDataLengthBytes,
 194:../FreeRTOS/Source/stream_buffer.c ****                                        size_t xSpace,
 195:../FreeRTOS/Source/stream_buffer.c ****                                        size_t xRequiredSpace ) PRIVILEGED_FUNCTION;
 196:../FreeRTOS/Source/stream_buffer.c **** 
 197:../FreeRTOS/Source/stream_buffer.c **** /*
 198:../FreeRTOS/Source/stream_buffer.c ****  * Read xMaxCount bytes from the pxStreamBuffer message buffer and write them
 199:../FreeRTOS/Source/stream_buffer.c ****  * to pucData.
 200:../FreeRTOS/Source/stream_buffer.c ****  */
 201:../FreeRTOS/Source/stream_buffer.c **** static size_t prvReadBytesFromBuffer( StreamBuffer_t * pxStreamBuffer,
 202:../FreeRTOS/Source/stream_buffer.c ****                                       uint8_t * pucData,
 203:../FreeRTOS/Source/stream_buffer.c ****                                       size_t xMaxCount,
 204:../FreeRTOS/Source/stream_buffer.c ****                                       size_t xBytesAvailable ) PRIVILEGED_FUNCTION;
 205:../FreeRTOS/Source/stream_buffer.c **** 
 206:../FreeRTOS/Source/stream_buffer.c **** /*
 207:../FreeRTOS/Source/stream_buffer.c ****  * Called by both pxStreamBufferCreate() and pxStreamBufferCreateStatic() to
 208:../FreeRTOS/Source/stream_buffer.c ****  * initialise the members of the newly created stream buffer structure.
 209:../FreeRTOS/Source/stream_buffer.c ****  */
 210:../FreeRTOS/Source/stream_buffer.c **** static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
 211:../FreeRTOS/Source/stream_buffer.c ****                                           uint8_t * const pucBuffer,
 212:../FreeRTOS/Source/stream_buffer.c ****                                           size_t xBufferSizeBytes,
 213:../FreeRTOS/Source/stream_buffer.c ****                                           size_t xTriggerLevelBytes,
 214:../FreeRTOS/Source/stream_buffer.c ****                                           uint8_t ucFlags ) PRIVILEGED_FUNCTION;
 215:../FreeRTOS/Source/stream_buffer.c **** 
 216:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
 217:../FreeRTOS/Source/stream_buffer.c **** 
 218:../FreeRTOS/Source/stream_buffer.c **** #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 219:../FreeRTOS/Source/stream_buffer.c **** 
 220:../FreeRTOS/Source/stream_buffer.c ****     StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,
 221:../FreeRTOS/Source/stream_buffer.c ****                                                      size_t xTriggerLevelBytes,
 222:../FreeRTOS/Source/stream_buffer.c ****                                                      BaseType_t xIsMessageBuffer )
 223:../FreeRTOS/Source/stream_buffer.c ****     {
 224:../FreeRTOS/Source/stream_buffer.c ****         uint8_t * pucAllocatedMemory;
 225:../FreeRTOS/Source/stream_buffer.c ****         uint8_t ucFlags;
 226:../FreeRTOS/Source/stream_buffer.c **** 
 227:../FreeRTOS/Source/stream_buffer.c ****         /* In case the stream buffer is going to be used as a message buffer
 228:../FreeRTOS/Source/stream_buffer.c ****          * (that is, it will hold discrete messages with a little meta data that
 229:../FreeRTOS/Source/stream_buffer.c ****          * says how big the next message is) check the buffer will be large enough
 230:../FreeRTOS/Source/stream_buffer.c ****          * to hold at least one message. */
 231:../FreeRTOS/Source/stream_buffer.c ****         if( xIsMessageBuffer == pdTRUE )
 232:../FreeRTOS/Source/stream_buffer.c ****         {
 233:../FreeRTOS/Source/stream_buffer.c ****             /* Is a message buffer but not statically allocated. */
 234:../FreeRTOS/Source/stream_buffer.c ****             ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
 235:../FreeRTOS/Source/stream_buffer.c ****             configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
 236:../FreeRTOS/Source/stream_buffer.c ****         }
 237:../FreeRTOS/Source/stream_buffer.c ****         else
 238:../FreeRTOS/Source/stream_buffer.c ****         {
 239:../FreeRTOS/Source/stream_buffer.c ****             /* Not a message buffer and not statically allocated. */
 240:../FreeRTOS/Source/stream_buffer.c ****             ucFlags = 0;
 241:../FreeRTOS/Source/stream_buffer.c ****             configASSERT( xBufferSizeBytes > 0 );
 242:../FreeRTOS/Source/stream_buffer.c ****         }
 243:../FreeRTOS/Source/stream_buffer.c **** 
 244:../FreeRTOS/Source/stream_buffer.c ****         configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );
 245:../FreeRTOS/Source/stream_buffer.c **** 
 246:../FreeRTOS/Source/stream_buffer.c ****         /* A trigger level of 0 would cause a waiting task to unblock even when
 247:../FreeRTOS/Source/stream_buffer.c ****          * the buffer was empty. */
 248:../FreeRTOS/Source/stream_buffer.c ****         if( xTriggerLevelBytes == ( size_t ) 0 )
 249:../FreeRTOS/Source/stream_buffer.c ****         {
 250:../FreeRTOS/Source/stream_buffer.c ****             xTriggerLevelBytes = ( size_t ) 1;
 251:../FreeRTOS/Source/stream_buffer.c ****         }
 252:../FreeRTOS/Source/stream_buffer.c **** 
 253:../FreeRTOS/Source/stream_buffer.c ****         /* A stream buffer requires a StreamBuffer_t structure and a buffer.
 254:../FreeRTOS/Source/stream_buffer.c ****          * Both are allocated in a single call to pvPortMalloc().  The
 255:../FreeRTOS/Source/stream_buffer.c ****          * StreamBuffer_t structure is placed at the start of the allocated memory
 256:../FreeRTOS/Source/stream_buffer.c ****          * and the buffer follows immediately after.  The requested size is
 257:../FreeRTOS/Source/stream_buffer.c ****          * incremented so the free space is returned as the user would expect -
 258:../FreeRTOS/Source/stream_buffer.c ****          * this is a quirk of the implementation that means otherwise the free
 259:../FreeRTOS/Source/stream_buffer.c ****          * space would be reported as one byte smaller than would be logically
 260:../FreeRTOS/Source/stream_buffer.c ****          * expected. */
 261:../FreeRTOS/Source/stream_buffer.c ****         xBufferSizeBytes++;
 262:../FreeRTOS/Source/stream_buffer.c ****         pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t 
 263:../FreeRTOS/Source/stream_buffer.c **** 
 264:../FreeRTOS/Source/stream_buffer.c ****         if( pucAllocatedMemory != NULL )
 265:../FreeRTOS/Source/stream_buffer.c ****         {
 266:../FreeRTOS/Source/stream_buffer.c ****             prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory,       /* Structu
 267:../FreeRTOS/Source/stream_buffer.c ****                                           pucAllocatedMemory + sizeof( StreamBuffer_t ), /* Storage
 268:../FreeRTOS/Source/stream_buffer.c ****                                           xBufferSizeBytes,
 269:../FreeRTOS/Source/stream_buffer.c ****                                           xTriggerLevelBytes,
 270:../FreeRTOS/Source/stream_buffer.c ****                                           ucFlags );
 271:../FreeRTOS/Source/stream_buffer.c **** 
 272:../FreeRTOS/Source/stream_buffer.c ****             traceSTREAM_BUFFER_CREATE( ( ( StreamBuffer_t * ) pucAllocatedMemory ), xIsMessageBuffe
 273:../FreeRTOS/Source/stream_buffer.c ****         }
 274:../FreeRTOS/Source/stream_buffer.c ****         else
 275:../FreeRTOS/Source/stream_buffer.c ****         {
 276:../FreeRTOS/Source/stream_buffer.c ****             traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
 277:../FreeRTOS/Source/stream_buffer.c ****         }
 278:../FreeRTOS/Source/stream_buffer.c **** 
 279:../FreeRTOS/Source/stream_buffer.c ****         return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as alloca
 280:../FreeRTOS/Source/stream_buffer.c ****     }
 281:../FreeRTOS/Source/stream_buffer.c **** 
 282:../FreeRTOS/Source/stream_buffer.c **** #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 283:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
 284:../FreeRTOS/Source/stream_buffer.c **** 
 285:../FreeRTOS/Source/stream_buffer.c **** #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
 286:../FreeRTOS/Source/stream_buffer.c **** 
 287:../FreeRTOS/Source/stream_buffer.c ****     StreamBufferHandle_t xStreamBufferGenericCreateStatic( size_t xBufferSizeBytes,
 288:../FreeRTOS/Source/stream_buffer.c ****                                                            size_t xTriggerLevelBytes,
 289:../FreeRTOS/Source/stream_buffer.c ****                                                            BaseType_t xIsMessageBuffer,
 290:../FreeRTOS/Source/stream_buffer.c ****                                                            uint8_t * const pucStreamBufferStorageAr
 291:../FreeRTOS/Source/stream_buffer.c ****                                                            StaticStreamBuffer_t * const pxStaticStr
 292:../FreeRTOS/Source/stream_buffer.c ****     {
 293:../FreeRTOS/Source/stream_buffer.c ****         StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) pxStaticStreamBuffer; /*lint !
 294:../FreeRTOS/Source/stream_buffer.c ****         StreamBufferHandle_t xReturn;
 295:../FreeRTOS/Source/stream_buffer.c ****         uint8_t ucFlags;
 296:../FreeRTOS/Source/stream_buffer.c **** 
 297:../FreeRTOS/Source/stream_buffer.c ****         configASSERT( pucStreamBufferStorageArea );
 298:../FreeRTOS/Source/stream_buffer.c ****         configASSERT( pxStaticStreamBuffer );
 299:../FreeRTOS/Source/stream_buffer.c ****         configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );
 300:../FreeRTOS/Source/stream_buffer.c **** 
 301:../FreeRTOS/Source/stream_buffer.c ****         /* A trigger level of 0 would cause a waiting task to unblock even when
 302:../FreeRTOS/Source/stream_buffer.c ****          * the buffer was empty. */
 303:../FreeRTOS/Source/stream_buffer.c ****         if( xTriggerLevelBytes == ( size_t ) 0 )
 304:../FreeRTOS/Source/stream_buffer.c ****         {
 305:../FreeRTOS/Source/stream_buffer.c ****             xTriggerLevelBytes = ( size_t ) 1;
 306:../FreeRTOS/Source/stream_buffer.c ****         }
 307:../FreeRTOS/Source/stream_buffer.c **** 
 308:../FreeRTOS/Source/stream_buffer.c ****         if( xIsMessageBuffer != pdFALSE )
 309:../FreeRTOS/Source/stream_buffer.c ****         {
 310:../FreeRTOS/Source/stream_buffer.c ****             /* Statically allocated message buffer. */
 311:../FreeRTOS/Source/stream_buffer.c ****             ucFlags = sbFLAGS_IS_MESSAGE_BUFFER | sbFLAGS_IS_STATICALLY_ALLOCATED;
 312:../FreeRTOS/Source/stream_buffer.c ****         }
 313:../FreeRTOS/Source/stream_buffer.c ****         else
 314:../FreeRTOS/Source/stream_buffer.c ****         {
 315:../FreeRTOS/Source/stream_buffer.c ****             /* Statically allocated stream buffer. */
 316:../FreeRTOS/Source/stream_buffer.c ****             ucFlags = sbFLAGS_IS_STATICALLY_ALLOCATED;
 317:../FreeRTOS/Source/stream_buffer.c ****         }
 318:../FreeRTOS/Source/stream_buffer.c **** 
 319:../FreeRTOS/Source/stream_buffer.c ****         /* In case the stream buffer is going to be used as a message buffer
 320:../FreeRTOS/Source/stream_buffer.c ****          * (that is, it will hold discrete messages with a little meta data that
 321:../FreeRTOS/Source/stream_buffer.c ****          * says how big the next message is) check the buffer will be large enough
 322:../FreeRTOS/Source/stream_buffer.c ****          * to hold at least one message. */
 323:../FreeRTOS/Source/stream_buffer.c ****         configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
 324:../FreeRTOS/Source/stream_buffer.c **** 
 325:../FreeRTOS/Source/stream_buffer.c ****         #if ( configASSERT_DEFINED == 1 )
 326:../FreeRTOS/Source/stream_buffer.c ****             {
 327:../FreeRTOS/Source/stream_buffer.c ****                 /* Sanity check that the size of the structure used to declare a
 328:../FreeRTOS/Source/stream_buffer.c ****                  * variable of type StaticStreamBuffer_t equals the size of the real
 329:../FreeRTOS/Source/stream_buffer.c ****                  * message buffer structure. */
 330:../FreeRTOS/Source/stream_buffer.c ****                 volatile size_t xSize = sizeof( StaticStreamBuffer_t );
 331:../FreeRTOS/Source/stream_buffer.c ****                 configASSERT( xSize == sizeof( StreamBuffer_t ) );
 332:../FreeRTOS/Source/stream_buffer.c ****             } /*lint !e529 xSize is referenced is configASSERT() is defined. */
 333:../FreeRTOS/Source/stream_buffer.c ****         #endif /* configASSERT_DEFINED */
 334:../FreeRTOS/Source/stream_buffer.c **** 
 335:../FreeRTOS/Source/stream_buffer.c ****         if( ( pucStreamBufferStorageArea != NULL ) && ( pxStaticStreamBuffer != NULL ) )
 336:../FreeRTOS/Source/stream_buffer.c ****         {
 337:../FreeRTOS/Source/stream_buffer.c ****             prvInitialiseNewStreamBuffer( pxStreamBuffer,
 338:../FreeRTOS/Source/stream_buffer.c ****                                           pucStreamBufferStorageArea,
 339:../FreeRTOS/Source/stream_buffer.c ****                                           xBufferSizeBytes,
 340:../FreeRTOS/Source/stream_buffer.c ****                                           xTriggerLevelBytes,
 341:../FreeRTOS/Source/stream_buffer.c ****                                           ucFlags );
 342:../FreeRTOS/Source/stream_buffer.c **** 
 343:../FreeRTOS/Source/stream_buffer.c ****             /* Remember this was statically allocated in case it is ever deleted
 344:../FreeRTOS/Source/stream_buffer.c ****              * again. */
 345:../FreeRTOS/Source/stream_buffer.c ****             pxStreamBuffer->ucFlags |= sbFLAGS_IS_STATICALLY_ALLOCATED;
 346:../FreeRTOS/Source/stream_buffer.c **** 
 347:../FreeRTOS/Source/stream_buffer.c ****             traceSTREAM_BUFFER_CREATE( pxStreamBuffer, xIsMessageBuffer );
 348:../FreeRTOS/Source/stream_buffer.c **** 
 349:../FreeRTOS/Source/stream_buffer.c ****             xReturn = ( StreamBufferHandle_t ) pxStaticStreamBuffer; /*lint !e9087 Data hiding requ
 350:../FreeRTOS/Source/stream_buffer.c ****         }
 351:../FreeRTOS/Source/stream_buffer.c ****         else
 352:../FreeRTOS/Source/stream_buffer.c ****         {
 353:../FreeRTOS/Source/stream_buffer.c ****             xReturn = NULL;
 354:../FreeRTOS/Source/stream_buffer.c ****             traceSTREAM_BUFFER_CREATE_STATIC_FAILED( xReturn, xIsMessageBuffer );
 355:../FreeRTOS/Source/stream_buffer.c ****         }
 356:../FreeRTOS/Source/stream_buffer.c **** 
 357:../FreeRTOS/Source/stream_buffer.c ****         return xReturn;
 358:../FreeRTOS/Source/stream_buffer.c ****     }
 359:../FreeRTOS/Source/stream_buffer.c **** 
 360:../FreeRTOS/Source/stream_buffer.c **** #endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
 361:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
 362:../FreeRTOS/Source/stream_buffer.c **** 
 363:../FreeRTOS/Source/stream_buffer.c **** void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
 364:../FreeRTOS/Source/stream_buffer.c **** {
 365:../FreeRTOS/Source/stream_buffer.c ****     StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
 366:../FreeRTOS/Source/stream_buffer.c **** 
 367:../FreeRTOS/Source/stream_buffer.c ****     configASSERT( pxStreamBuffer );
 368:../FreeRTOS/Source/stream_buffer.c **** 
 369:../FreeRTOS/Source/stream_buffer.c ****     traceSTREAM_BUFFER_DELETE( xStreamBuffer );
 370:../FreeRTOS/Source/stream_buffer.c **** 
 371:../FreeRTOS/Source/stream_buffer.c ****     if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
 372:../FreeRTOS/Source/stream_buffer.c ****     {
 373:../FreeRTOS/Source/stream_buffer.c ****         #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 374:../FreeRTOS/Source/stream_buffer.c ****             {
 375:../FreeRTOS/Source/stream_buffer.c ****                 /* Both the structure and the buffer were allocated using a single call
 376:../FreeRTOS/Source/stream_buffer.c ****                 * to pvPortMalloc(), hence only one call to vPortFree() is required. */
 377:../FreeRTOS/Source/stream_buffer.c ****                 vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics req
 378:../FreeRTOS/Source/stream_buffer.c ****             }
 379:../FreeRTOS/Source/stream_buffer.c ****         #else
 380:../FreeRTOS/Source/stream_buffer.c ****             {
 381:../FreeRTOS/Source/stream_buffer.c ****                 /* Should not be possible to get here, ucFlags must be corrupt.
 382:../FreeRTOS/Source/stream_buffer.c ****                  * Force an assert. */
 383:../FreeRTOS/Source/stream_buffer.c ****                 configASSERT( xStreamBuffer == ( StreamBufferHandle_t ) ~0 );
 384:../FreeRTOS/Source/stream_buffer.c ****             }
 385:../FreeRTOS/Source/stream_buffer.c ****         #endif
 386:../FreeRTOS/Source/stream_buffer.c ****     }
 387:../FreeRTOS/Source/stream_buffer.c ****     else
 388:../FreeRTOS/Source/stream_buffer.c ****     {
 389:../FreeRTOS/Source/stream_buffer.c ****         /* The structure and buffer were not allocated dynamically and cannot be
 390:../FreeRTOS/Source/stream_buffer.c ****          * freed - just scrub the structure so future use will assert. */
 391:../FreeRTOS/Source/stream_buffer.c ****         ( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
 392:../FreeRTOS/Source/stream_buffer.c ****     }
 393:../FreeRTOS/Source/stream_buffer.c **** }
 394:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
 395:../FreeRTOS/Source/stream_buffer.c **** 
 396:../FreeRTOS/Source/stream_buffer.c **** BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
 397:../FreeRTOS/Source/stream_buffer.c **** {
 398:../FreeRTOS/Source/stream_buffer.c ****     StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 399:../FreeRTOS/Source/stream_buffer.c ****     BaseType_t xReturn = pdFAIL;
 400:../FreeRTOS/Source/stream_buffer.c **** 
 401:../FreeRTOS/Source/stream_buffer.c ****     #if ( configUSE_TRACE_FACILITY == 1 )
 402:../FreeRTOS/Source/stream_buffer.c ****         UBaseType_t uxStreamBufferNumber;
 403:../FreeRTOS/Source/stream_buffer.c ****     #endif
 404:../FreeRTOS/Source/stream_buffer.c **** 
 405:../FreeRTOS/Source/stream_buffer.c ****     configASSERT( pxStreamBuffer );
 406:../FreeRTOS/Source/stream_buffer.c **** 
 407:../FreeRTOS/Source/stream_buffer.c ****     #if ( configUSE_TRACE_FACILITY == 1 )
 408:../FreeRTOS/Source/stream_buffer.c ****         {
 409:../FreeRTOS/Source/stream_buffer.c ****             /* Store the stream buffer number so it can be restored after the
 410:../FreeRTOS/Source/stream_buffer.c ****              * reset. */
 411:../FreeRTOS/Source/stream_buffer.c ****             uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
 412:../FreeRTOS/Source/stream_buffer.c ****         }
 413:../FreeRTOS/Source/stream_buffer.c ****     #endif
 414:../FreeRTOS/Source/stream_buffer.c **** 
 415:../FreeRTOS/Source/stream_buffer.c ****     /* Can only reset a message buffer if there are no tasks blocked on it. */
 416:../FreeRTOS/Source/stream_buffer.c ****     taskENTER_CRITICAL();
 417:../FreeRTOS/Source/stream_buffer.c ****     {
 418:../FreeRTOS/Source/stream_buffer.c ****         if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
 419:../FreeRTOS/Source/stream_buffer.c ****         {
 420:../FreeRTOS/Source/stream_buffer.c ****             if( pxStreamBuffer->xTaskWaitingToSend == NULL )
 421:../FreeRTOS/Source/stream_buffer.c ****             {
 422:../FreeRTOS/Source/stream_buffer.c ****                 prvInitialiseNewStreamBuffer( pxStreamBuffer,
 423:../FreeRTOS/Source/stream_buffer.c ****                                               pxStreamBuffer->pucBuffer,
 424:../FreeRTOS/Source/stream_buffer.c ****                                               pxStreamBuffer->xLength,
 425:../FreeRTOS/Source/stream_buffer.c ****                                               pxStreamBuffer->xTriggerLevelBytes,
 426:../FreeRTOS/Source/stream_buffer.c ****                                               pxStreamBuffer->ucFlags );
 427:../FreeRTOS/Source/stream_buffer.c ****                 xReturn = pdPASS;
 428:../FreeRTOS/Source/stream_buffer.c **** 
 429:../FreeRTOS/Source/stream_buffer.c ****                 #if ( configUSE_TRACE_FACILITY == 1 )
 430:../FreeRTOS/Source/stream_buffer.c ****                     {
 431:../FreeRTOS/Source/stream_buffer.c ****                         pxStreamBuffer->uxStreamBufferNumber = uxStreamBufferNumber;
 432:../FreeRTOS/Source/stream_buffer.c ****                     }
 433:../FreeRTOS/Source/stream_buffer.c ****                 #endif
 434:../FreeRTOS/Source/stream_buffer.c **** 
 435:../FreeRTOS/Source/stream_buffer.c ****                 traceSTREAM_BUFFER_RESET( xStreamBuffer );
 436:../FreeRTOS/Source/stream_buffer.c ****             }
 437:../FreeRTOS/Source/stream_buffer.c ****         }
 438:../FreeRTOS/Source/stream_buffer.c ****     }
 439:../FreeRTOS/Source/stream_buffer.c ****     taskEXIT_CRITICAL();
 440:../FreeRTOS/Source/stream_buffer.c **** 
 441:../FreeRTOS/Source/stream_buffer.c ****     return xReturn;
 442:../FreeRTOS/Source/stream_buffer.c **** }
 443:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
 444:../FreeRTOS/Source/stream_buffer.c **** 
 445:../FreeRTOS/Source/stream_buffer.c **** BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer,
 446:../FreeRTOS/Source/stream_buffer.c ****                                          size_t xTriggerLevel )
 447:../FreeRTOS/Source/stream_buffer.c **** {
 448:../FreeRTOS/Source/stream_buffer.c ****     StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 449:../FreeRTOS/Source/stream_buffer.c ****     BaseType_t xReturn;
 450:../FreeRTOS/Source/stream_buffer.c **** 
 451:../FreeRTOS/Source/stream_buffer.c ****     configASSERT( pxStreamBuffer );
 452:../FreeRTOS/Source/stream_buffer.c **** 
 453:../FreeRTOS/Source/stream_buffer.c ****     /* It is not valid for the trigger level to be 0. */
 454:../FreeRTOS/Source/stream_buffer.c ****     if( xTriggerLevel == ( size_t ) 0 )
 455:../FreeRTOS/Source/stream_buffer.c ****     {
 456:../FreeRTOS/Source/stream_buffer.c ****         xTriggerLevel = ( size_t ) 1;
 457:../FreeRTOS/Source/stream_buffer.c ****     }
 458:../FreeRTOS/Source/stream_buffer.c **** 
 459:../FreeRTOS/Source/stream_buffer.c ****     /* The trigger level is the number of bytes that must be in the stream
 460:../FreeRTOS/Source/stream_buffer.c ****      * buffer before a task that is waiting for data is unblocked. */
 461:../FreeRTOS/Source/stream_buffer.c ****     if( xTriggerLevel <= pxStreamBuffer->xLength )
 462:../FreeRTOS/Source/stream_buffer.c ****     {
 463:../FreeRTOS/Source/stream_buffer.c ****         pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
 464:../FreeRTOS/Source/stream_buffer.c ****         xReturn = pdPASS;
 465:../FreeRTOS/Source/stream_buffer.c ****     }
 466:../FreeRTOS/Source/stream_buffer.c ****     else
 467:../FreeRTOS/Source/stream_buffer.c ****     {
 468:../FreeRTOS/Source/stream_buffer.c ****         xReturn = pdFALSE;
 469:../FreeRTOS/Source/stream_buffer.c ****     }
 470:../FreeRTOS/Source/stream_buffer.c **** 
 471:../FreeRTOS/Source/stream_buffer.c ****     return xReturn;
 472:../FreeRTOS/Source/stream_buffer.c **** }
 473:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
 474:../FreeRTOS/Source/stream_buffer.c **** 
 475:../FreeRTOS/Source/stream_buffer.c **** size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
 476:../FreeRTOS/Source/stream_buffer.c **** {
 477:../FreeRTOS/Source/stream_buffer.c ****     const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 478:../FreeRTOS/Source/stream_buffer.c ****     size_t xSpace;
 479:../FreeRTOS/Source/stream_buffer.c **** 
 480:../FreeRTOS/Source/stream_buffer.c ****     configASSERT( pxStreamBuffer );
 481:../FreeRTOS/Source/stream_buffer.c **** 
 482:../FreeRTOS/Source/stream_buffer.c ****     xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
 483:../FreeRTOS/Source/stream_buffer.c ****     xSpace -= pxStreamBuffer->xHead;
 484:../FreeRTOS/Source/stream_buffer.c ****     xSpace -= ( size_t ) 1;
 485:../FreeRTOS/Source/stream_buffer.c **** 
 486:../FreeRTOS/Source/stream_buffer.c ****     if( xSpace >= pxStreamBuffer->xLength )
 487:../FreeRTOS/Source/stream_buffer.c ****     {
 488:../FreeRTOS/Source/stream_buffer.c ****         xSpace -= pxStreamBuffer->xLength;
 489:../FreeRTOS/Source/stream_buffer.c ****     }
 490:../FreeRTOS/Source/stream_buffer.c ****     else
 491:../FreeRTOS/Source/stream_buffer.c ****     {
 492:../FreeRTOS/Source/stream_buffer.c ****         mtCOVERAGE_TEST_MARKER();
 493:../FreeRTOS/Source/stream_buffer.c ****     }
 494:../FreeRTOS/Source/stream_buffer.c **** 
 495:../FreeRTOS/Source/stream_buffer.c ****     return xSpace;
 496:../FreeRTOS/Source/stream_buffer.c **** }
 497:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
 498:../FreeRTOS/Source/stream_buffer.c **** 
 499:../FreeRTOS/Source/stream_buffer.c **** size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
 500:../FreeRTOS/Source/stream_buffer.c **** {
 501:../FreeRTOS/Source/stream_buffer.c ****     const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 502:../FreeRTOS/Source/stream_buffer.c ****     size_t xReturn;
 503:../FreeRTOS/Source/stream_buffer.c **** 
 504:../FreeRTOS/Source/stream_buffer.c ****     configASSERT( pxStreamBuffer );
 505:../FreeRTOS/Source/stream_buffer.c **** 
 506:../FreeRTOS/Source/stream_buffer.c ****     xReturn = prvBytesInBuffer( pxStreamBuffer );
 507:../FreeRTOS/Source/stream_buffer.c ****     return xReturn;
 508:../FreeRTOS/Source/stream_buffer.c **** }
 509:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
 510:../FreeRTOS/Source/stream_buffer.c **** 
 511:../FreeRTOS/Source/stream_buffer.c **** size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
 512:../FreeRTOS/Source/stream_buffer.c ****                           const void * pvTxData,
 513:../FreeRTOS/Source/stream_buffer.c ****                           size_t xDataLengthBytes,
 514:../FreeRTOS/Source/stream_buffer.c ****                           TickType_t xTicksToWait )
 515:../FreeRTOS/Source/stream_buffer.c **** {
 516:../FreeRTOS/Source/stream_buffer.c ****     StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 517:../FreeRTOS/Source/stream_buffer.c ****     size_t xReturn, xSpace = 0;
 518:../FreeRTOS/Source/stream_buffer.c ****     size_t xRequiredSpace = xDataLengthBytes;
 519:../FreeRTOS/Source/stream_buffer.c ****     TimeOut_t xTimeOut;
 520:../FreeRTOS/Source/stream_buffer.c **** 
 521:../FreeRTOS/Source/stream_buffer.c ****     /* Having a 'isFeasible' variable allows to respect the convention that there is only a return 
 522:../FreeRTOS/Source/stream_buffer.c ****      * could be done as soon as we realise the send cannot happen. We will let the call to 'prvWrit
 523:../FreeRTOS/Source/stream_buffer.c ****     BaseType_t xIsFeasible;
 524:../FreeRTOS/Source/stream_buffer.c **** 
 525:../FreeRTOS/Source/stream_buffer.c ****     configASSERT( pvTxData );
 526:../FreeRTOS/Source/stream_buffer.c ****     configASSERT( pxStreamBuffer );
 527:../FreeRTOS/Source/stream_buffer.c **** 
 528:../FreeRTOS/Source/stream_buffer.c ****     /* This send function is used to write to both message buffers and stream
 529:../FreeRTOS/Source/stream_buffer.c ****      * buffers.  If this is a message buffer then the space needed must be
 530:../FreeRTOS/Source/stream_buffer.c ****      * increased by the amount of bytes needed to store the length of the
 531:../FreeRTOS/Source/stream_buffer.c ****      * message. */
 532:../FreeRTOS/Source/stream_buffer.c ****     if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 533:../FreeRTOS/Source/stream_buffer.c ****     {
 534:../FreeRTOS/Source/stream_buffer.c ****         xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
 535:../FreeRTOS/Source/stream_buffer.c **** 
 536:../FreeRTOS/Source/stream_buffer.c ****         /* Overflow? */
 537:../FreeRTOS/Source/stream_buffer.c ****         configASSERT( xRequiredSpace > xDataLengthBytes );
 538:../FreeRTOS/Source/stream_buffer.c **** 
 539:../FreeRTOS/Source/stream_buffer.c ****         /* In the case of the message buffer, one has to be able to write the complete message as o
 540:../FreeRTOS/Source/stream_buffer.c ****          * a stream buffer for semantic reasons. Check if it is physically possible to write the me
 541:../FreeRTOS/Source/stream_buffer.c ****          * the length of the buffer. */
 542:../FreeRTOS/Source/stream_buffer.c ****         if( xRequiredSpace > pxStreamBuffer->xLength )
 543:../FreeRTOS/Source/stream_buffer.c ****         {
 544:../FreeRTOS/Source/stream_buffer.c ****             /* The message could never be written because it is greater than the buffer length.
 545:../FreeRTOS/Source/stream_buffer.c ****              * By setting xIsFeasable to FALSE, we skip over the following do..while loop, thus avo
 546:../FreeRTOS/Source/stream_buffer.c ****              * a deadlock. The call to 'prvWriteMessageToBuffer' toward the end of this function wi
 547:../FreeRTOS/Source/stream_buffer.c ****              * xRequiredSpace greater than xSpace will suffice in not writing anything to the inter
 548:../FreeRTOS/Source/stream_buffer.c ****              * Now, the function will return 0 because the message could not be written. Should an 
 549:../FreeRTOS/Source/stream_buffer.c ****              * returned instead ??? In my opinion, probably.. But the return type doesn't allow for
 550:../FreeRTOS/Source/stream_buffer.c ****              * values to be returned. A confusion could exist to the caller. Returning 0 because a 
 551:../FreeRTOS/Source/stream_buffer.c ****              * and a subsequent send attempts could eventually succeed, and returning 0 because a w
 552:../FreeRTOS/Source/stream_buffer.c ****              * happen because of the size are two scenarios to me :/ */
 553:../FreeRTOS/Source/stream_buffer.c ****             xIsFeasible = pdFALSE;
 554:../FreeRTOS/Source/stream_buffer.c ****         }
 555:../FreeRTOS/Source/stream_buffer.c ****         else
 556:../FreeRTOS/Source/stream_buffer.c ****         {
 557:../FreeRTOS/Source/stream_buffer.c ****             /* It is possible to write the message completely in the buffer. This is the intended r
 558:../FreeRTOS/Source/stream_buffer.c ****              * Let's continue with the regular timeout logic. */
 559:../FreeRTOS/Source/stream_buffer.c ****             xIsFeasible = pdTRUE;
 560:../FreeRTOS/Source/stream_buffer.c ****         }
 561:../FreeRTOS/Source/stream_buffer.c ****     }
 562:../FreeRTOS/Source/stream_buffer.c ****     else
 563:../FreeRTOS/Source/stream_buffer.c ****     {
 564:../FreeRTOS/Source/stream_buffer.c ****         /* In the case of the stream buffer, not being able to completely write the message in the 
 565:../FreeRTOS/Source/stream_buffer.c ****          * is an acceptable scenario, but it has to be dealt with properly */
 566:../FreeRTOS/Source/stream_buffer.c ****         if( xRequiredSpace > pxStreamBuffer->xLength )
 567:../FreeRTOS/Source/stream_buffer.c ****         {
 568:../FreeRTOS/Source/stream_buffer.c ****             /* Not enough buffer space. We will attempt to write as much as we can in this run
 569:../FreeRTOS/Source/stream_buffer.c ****              * so that the caller can send the remaining in subsequent calls. We avoid a deadlock b
 570:../FreeRTOS/Source/stream_buffer.c ****              * offering the possibility to take the 'else' branch in the  'if( xSpace < xRequiredSp
 571:../FreeRTOS/Source/stream_buffer.c ****              * condition inside the following do..while loop */
 572:../FreeRTOS/Source/stream_buffer.c ****             xRequiredSpace = pxStreamBuffer->xLength;
 573:../FreeRTOS/Source/stream_buffer.c **** 
 574:../FreeRTOS/Source/stream_buffer.c ****             /* TODO FIXME: Is there a check we should do with the xTriggerLevelBytes value ? */
 575:../FreeRTOS/Source/stream_buffer.c **** 
 576:../FreeRTOS/Source/stream_buffer.c ****             /* With the adjustment to 'xRequiredSpace', the deadlock is avoided, thus it's now feas
 577:../FreeRTOS/Source/stream_buffer.c ****             xIsFeasible = pdTRUE;
 578:../FreeRTOS/Source/stream_buffer.c ****         }
 579:../FreeRTOS/Source/stream_buffer.c ****         else
 580:../FreeRTOS/Source/stream_buffer.c ****         {
 581:../FreeRTOS/Source/stream_buffer.c ****             /* It is possible to write the message completely in the buffer. */
 582:../FreeRTOS/Source/stream_buffer.c ****             xIsFeasible = pdTRUE;
 583:../FreeRTOS/Source/stream_buffer.c ****         }
 584:../FreeRTOS/Source/stream_buffer.c ****     }
 585:../FreeRTOS/Source/stream_buffer.c **** 
 586:../FreeRTOS/Source/stream_buffer.c ****     /* Added check against xIsFeasible. If it's not feasible, don't even wait for notification, let
 587:../FreeRTOS/Source/stream_buffer.c ****     if( ( xTicksToWait != ( TickType_t ) 0 ) && ( xIsFeasible == pdTRUE ) )
 588:../FreeRTOS/Source/stream_buffer.c ****     {
 589:../FreeRTOS/Source/stream_buffer.c ****         vTaskSetTimeOutState( &xTimeOut );
 590:../FreeRTOS/Source/stream_buffer.c **** 
 591:../FreeRTOS/Source/stream_buffer.c ****         do
 592:../FreeRTOS/Source/stream_buffer.c ****         {
 593:../FreeRTOS/Source/stream_buffer.c ****             /* Wait until the required number of bytes are free in the message
 594:../FreeRTOS/Source/stream_buffer.c ****              * buffer. */
 595:../FreeRTOS/Source/stream_buffer.c ****             taskENTER_CRITICAL();
 596:../FreeRTOS/Source/stream_buffer.c ****             {
 597:../FreeRTOS/Source/stream_buffer.c ****                 xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
 598:../FreeRTOS/Source/stream_buffer.c **** 
 599:../FreeRTOS/Source/stream_buffer.c ****                 if( xSpace < xRequiredSpace )
 600:../FreeRTOS/Source/stream_buffer.c ****                 {
 601:../FreeRTOS/Source/stream_buffer.c ****                     /* Clear notification state as going to wait for space. */
 602:../FreeRTOS/Source/stream_buffer.c ****                     ( void ) xTaskNotifyStateClear( NULL );
 603:../FreeRTOS/Source/stream_buffer.c **** 
 604:../FreeRTOS/Source/stream_buffer.c ****                     /* Should only be one writer. */
 605:../FreeRTOS/Source/stream_buffer.c ****                     configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
 606:../FreeRTOS/Source/stream_buffer.c ****                     pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
 607:../FreeRTOS/Source/stream_buffer.c ****                 }
 608:../FreeRTOS/Source/stream_buffer.c ****                 else
 609:../FreeRTOS/Source/stream_buffer.c ****                 {
 610:../FreeRTOS/Source/stream_buffer.c ****                     taskEXIT_CRITICAL();
 611:../FreeRTOS/Source/stream_buffer.c ****                     break;
 612:../FreeRTOS/Source/stream_buffer.c ****                 }
 613:../FreeRTOS/Source/stream_buffer.c ****             }
 614:../FreeRTOS/Source/stream_buffer.c ****             taskEXIT_CRITICAL();
 615:../FreeRTOS/Source/stream_buffer.c **** 
 616:../FreeRTOS/Source/stream_buffer.c ****             traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
 617:../FreeRTOS/Source/stream_buffer.c ****             ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
 618:../FreeRTOS/Source/stream_buffer.c ****             pxStreamBuffer->xTaskWaitingToSend = NULL;
 619:../FreeRTOS/Source/stream_buffer.c ****         } while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
 620:../FreeRTOS/Source/stream_buffer.c ****     }
 621:../FreeRTOS/Source/stream_buffer.c ****     else
 622:../FreeRTOS/Source/stream_buffer.c ****     {
 623:../FreeRTOS/Source/stream_buffer.c ****         mtCOVERAGE_TEST_MARKER();
 624:../FreeRTOS/Source/stream_buffer.c ****     }
 625:../FreeRTOS/Source/stream_buffer.c **** 
 626:../FreeRTOS/Source/stream_buffer.c ****     if( xSpace == ( size_t ) 0 )
 627:../FreeRTOS/Source/stream_buffer.c ****     {
 628:../FreeRTOS/Source/stream_buffer.c ****         xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
 629:../FreeRTOS/Source/stream_buffer.c ****     }
 630:../FreeRTOS/Source/stream_buffer.c ****     else
 631:../FreeRTOS/Source/stream_buffer.c ****     {
 632:../FreeRTOS/Source/stream_buffer.c ****         mtCOVERAGE_TEST_MARKER();
 633:../FreeRTOS/Source/stream_buffer.c ****     }
 634:../FreeRTOS/Source/stream_buffer.c **** 
 635:../FreeRTOS/Source/stream_buffer.c ****     xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequire
 636:../FreeRTOS/Source/stream_buffer.c **** 
 637:../FreeRTOS/Source/stream_buffer.c ****     if( xReturn > ( size_t ) 0 )
 638:../FreeRTOS/Source/stream_buffer.c ****     {
 639:../FreeRTOS/Source/stream_buffer.c ****         traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );
 640:../FreeRTOS/Source/stream_buffer.c **** 
 641:../FreeRTOS/Source/stream_buffer.c ****         /* Was a task waiting for the data? */
 642:../FreeRTOS/Source/stream_buffer.c ****         if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
 643:../FreeRTOS/Source/stream_buffer.c ****         {
 644:../FreeRTOS/Source/stream_buffer.c ****             sbSEND_COMPLETED( pxStreamBuffer );
 645:../FreeRTOS/Source/stream_buffer.c ****         }
 646:../FreeRTOS/Source/stream_buffer.c ****         else
 647:../FreeRTOS/Source/stream_buffer.c ****         {
 648:../FreeRTOS/Source/stream_buffer.c ****             mtCOVERAGE_TEST_MARKER();
 649:../FreeRTOS/Source/stream_buffer.c ****         }
 650:../FreeRTOS/Source/stream_buffer.c ****     }
 651:../FreeRTOS/Source/stream_buffer.c ****     else
 652:../FreeRTOS/Source/stream_buffer.c ****     {
 653:../FreeRTOS/Source/stream_buffer.c ****         mtCOVERAGE_TEST_MARKER();
 654:../FreeRTOS/Source/stream_buffer.c ****         traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
 655:../FreeRTOS/Source/stream_buffer.c ****     }
 656:../FreeRTOS/Source/stream_buffer.c **** 
 657:../FreeRTOS/Source/stream_buffer.c ****     return xReturn;
 658:../FreeRTOS/Source/stream_buffer.c **** }
 659:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
 660:../FreeRTOS/Source/stream_buffer.c **** 
 661:../FreeRTOS/Source/stream_buffer.c **** size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
 662:../FreeRTOS/Source/stream_buffer.c ****                                  const void * pvTxData,
 663:../FreeRTOS/Source/stream_buffer.c ****                                  size_t xDataLengthBytes,
 664:../FreeRTOS/Source/stream_buffer.c ****                                  BaseType_t * const pxHigherPriorityTaskWoken )
 665:../FreeRTOS/Source/stream_buffer.c **** {
 666:../FreeRTOS/Source/stream_buffer.c ****     StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 667:../FreeRTOS/Source/stream_buffer.c ****     size_t xReturn, xSpace;
 668:../FreeRTOS/Source/stream_buffer.c ****     size_t xRequiredSpace = xDataLengthBytes;
 669:../FreeRTOS/Source/stream_buffer.c **** 
 670:../FreeRTOS/Source/stream_buffer.c ****     configASSERT( pvTxData );
 671:../FreeRTOS/Source/stream_buffer.c ****     configASSERT( pxStreamBuffer );
 672:../FreeRTOS/Source/stream_buffer.c **** 
 673:../FreeRTOS/Source/stream_buffer.c ****     /* This send function is used to write to both message buffers and stream
 674:../FreeRTOS/Source/stream_buffer.c ****      * buffers.  If this is a message buffer then the space needed must be
 675:../FreeRTOS/Source/stream_buffer.c ****      * increased by the amount of bytes needed to store the length of the
 676:../FreeRTOS/Source/stream_buffer.c ****      * message. */
 677:../FreeRTOS/Source/stream_buffer.c ****     if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 678:../FreeRTOS/Source/stream_buffer.c ****     {
 679:../FreeRTOS/Source/stream_buffer.c ****         xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
 680:../FreeRTOS/Source/stream_buffer.c ****     }
 681:../FreeRTOS/Source/stream_buffer.c ****     else
 682:../FreeRTOS/Source/stream_buffer.c ****     {
 683:../FreeRTOS/Source/stream_buffer.c ****         mtCOVERAGE_TEST_MARKER();
 684:../FreeRTOS/Source/stream_buffer.c ****     }
 685:../FreeRTOS/Source/stream_buffer.c **** 
 686:../FreeRTOS/Source/stream_buffer.c ****     xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
 687:../FreeRTOS/Source/stream_buffer.c ****     xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequire
 688:../FreeRTOS/Source/stream_buffer.c **** 
 689:../FreeRTOS/Source/stream_buffer.c ****     if( xReturn > ( size_t ) 0 )
 690:../FreeRTOS/Source/stream_buffer.c ****     {
 691:../FreeRTOS/Source/stream_buffer.c ****         /* Was a task waiting for the data? */
 692:../FreeRTOS/Source/stream_buffer.c ****         if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
 693:../FreeRTOS/Source/stream_buffer.c ****         {
 694:../FreeRTOS/Source/stream_buffer.c ****             sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
 695:../FreeRTOS/Source/stream_buffer.c ****         }
 696:../FreeRTOS/Source/stream_buffer.c ****         else
 697:../FreeRTOS/Source/stream_buffer.c ****         {
 698:../FreeRTOS/Source/stream_buffer.c ****             mtCOVERAGE_TEST_MARKER();
 699:../FreeRTOS/Source/stream_buffer.c ****         }
 700:../FreeRTOS/Source/stream_buffer.c ****     }
 701:../FreeRTOS/Source/stream_buffer.c ****     else
 702:../FreeRTOS/Source/stream_buffer.c ****     {
 703:../FreeRTOS/Source/stream_buffer.c ****         mtCOVERAGE_TEST_MARKER();
 704:../FreeRTOS/Source/stream_buffer.c ****     }
 705:../FreeRTOS/Source/stream_buffer.c **** 
 706:../FreeRTOS/Source/stream_buffer.c ****     traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );
 707:../FreeRTOS/Source/stream_buffer.c **** 
 708:../FreeRTOS/Source/stream_buffer.c ****     return xReturn;
 709:../FreeRTOS/Source/stream_buffer.c **** }
 710:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
 711:../FreeRTOS/Source/stream_buffer.c **** 
 712:../FreeRTOS/Source/stream_buffer.c **** static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
 713:../FreeRTOS/Source/stream_buffer.c ****                                        const void * pvTxData,
 714:../FreeRTOS/Source/stream_buffer.c ****                                        size_t xDataLengthBytes,
 715:../FreeRTOS/Source/stream_buffer.c ****                                        size_t xSpace,
 716:../FreeRTOS/Source/stream_buffer.c ****                                        size_t xRequiredSpace )
 717:../FreeRTOS/Source/stream_buffer.c **** {
 718:../FreeRTOS/Source/stream_buffer.c ****     BaseType_t xShouldWrite;
 719:../FreeRTOS/Source/stream_buffer.c ****     size_t xReturn;
 720:../FreeRTOS/Source/stream_buffer.c **** 
 721:../FreeRTOS/Source/stream_buffer.c ****     if( xSpace == ( size_t ) 0 )
 722:../FreeRTOS/Source/stream_buffer.c ****     {
 723:../FreeRTOS/Source/stream_buffer.c ****         /* Doesn't matter if this is a stream buffer or a message buffer, there
 724:../FreeRTOS/Source/stream_buffer.c ****          * is no space to write. */
 725:../FreeRTOS/Source/stream_buffer.c ****         xShouldWrite = pdFALSE;
 726:../FreeRTOS/Source/stream_buffer.c ****     }
 727:../FreeRTOS/Source/stream_buffer.c ****     else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )
 728:../FreeRTOS/Source/stream_buffer.c ****     {
 729:../FreeRTOS/Source/stream_buffer.c ****         /* This is a stream buffer, as opposed to a message buffer, so writing a
 730:../FreeRTOS/Source/stream_buffer.c ****          * stream of bytes rather than discrete messages.  Write as many bytes as
 731:../FreeRTOS/Source/stream_buffer.c ****          * possible. */
 732:../FreeRTOS/Source/stream_buffer.c ****         xShouldWrite = pdTRUE;
 733:../FreeRTOS/Source/stream_buffer.c ****         xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
 734:../FreeRTOS/Source/stream_buffer.c ****     }
 735:../FreeRTOS/Source/stream_buffer.c ****     else if( xSpace >= xRequiredSpace )
 736:../FreeRTOS/Source/stream_buffer.c ****     {
 737:../FreeRTOS/Source/stream_buffer.c ****         /* This is a message buffer, as opposed to a stream buffer, and there
 738:../FreeRTOS/Source/stream_buffer.c ****          * is enough space to write both the message length and the message itself
 739:../FreeRTOS/Source/stream_buffer.c ****          * into the buffer.  Start by writing the length of the data, the data
 740:../FreeRTOS/Source/stream_buffer.c ****          * itself will be written later in this function. */
 741:../FreeRTOS/Source/stream_buffer.c ****         xShouldWrite = pdTRUE;
 742:../FreeRTOS/Source/stream_buffer.c ****         ( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), 
 743:../FreeRTOS/Source/stream_buffer.c ****     }
 744:../FreeRTOS/Source/stream_buffer.c ****     else
 745:../FreeRTOS/Source/stream_buffer.c ****     {
 746:../FreeRTOS/Source/stream_buffer.c ****         /* There is space available, but not enough space. */
 747:../FreeRTOS/Source/stream_buffer.c ****         xShouldWrite = pdFALSE;
 748:../FreeRTOS/Source/stream_buffer.c ****     }
 749:../FreeRTOS/Source/stream_buffer.c **** 
 750:../FreeRTOS/Source/stream_buffer.c ****     if( xShouldWrite != pdFALSE )
 751:../FreeRTOS/Source/stream_buffer.c ****     {
 752:../FreeRTOS/Source/stream_buffer.c ****         /* Writes the data itself. */
 753:../FreeRTOS/Source/stream_buffer.c ****         xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthB
 754:../FreeRTOS/Source/stream_buffer.c ****     }
 755:../FreeRTOS/Source/stream_buffer.c ****     else
 756:../FreeRTOS/Source/stream_buffer.c ****     {
 757:../FreeRTOS/Source/stream_buffer.c ****         xReturn = 0;
 758:../FreeRTOS/Source/stream_buffer.c ****     }
 759:../FreeRTOS/Source/stream_buffer.c **** 
 760:../FreeRTOS/Source/stream_buffer.c ****     return xReturn;
 761:../FreeRTOS/Source/stream_buffer.c **** }
 762:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
 763:../FreeRTOS/Source/stream_buffer.c **** 
 764:../FreeRTOS/Source/stream_buffer.c **** size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
 765:../FreeRTOS/Source/stream_buffer.c ****                              void * pvRxData,
 766:../FreeRTOS/Source/stream_buffer.c ****                              size_t xBufferLengthBytes,
 767:../FreeRTOS/Source/stream_buffer.c ****                              TickType_t xTicksToWait )
 768:../FreeRTOS/Source/stream_buffer.c **** {
 769:../FreeRTOS/Source/stream_buffer.c ****     StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 770:../FreeRTOS/Source/stream_buffer.c ****     size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
 771:../FreeRTOS/Source/stream_buffer.c **** 
 772:../FreeRTOS/Source/stream_buffer.c ****     configASSERT( pvRxData );
 773:../FreeRTOS/Source/stream_buffer.c ****     configASSERT( pxStreamBuffer );
 774:../FreeRTOS/Source/stream_buffer.c **** 
 775:../FreeRTOS/Source/stream_buffer.c ****     /* This receive function is used by both message buffers, which store
 776:../FreeRTOS/Source/stream_buffer.c ****      * discrete messages, and stream buffers, which store a continuous stream of
 777:../FreeRTOS/Source/stream_buffer.c ****      * bytes.  Discrete messages include an additional
 778:../FreeRTOS/Source/stream_buffer.c ****      * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
 779:../FreeRTOS/Source/stream_buffer.c ****      * message. */
 780:../FreeRTOS/Source/stream_buffer.c ****     if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 781:../FreeRTOS/Source/stream_buffer.c ****     {
 782:../FreeRTOS/Source/stream_buffer.c ****         xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
 783:../FreeRTOS/Source/stream_buffer.c ****     }
 784:../FreeRTOS/Source/stream_buffer.c ****     else
 785:../FreeRTOS/Source/stream_buffer.c ****     {
 786:../FreeRTOS/Source/stream_buffer.c ****         xBytesToStoreMessageLength = 0;
 787:../FreeRTOS/Source/stream_buffer.c ****     }
 788:../FreeRTOS/Source/stream_buffer.c **** 
 789:../FreeRTOS/Source/stream_buffer.c ****     if( xTicksToWait != ( TickType_t ) 0 )
 790:../FreeRTOS/Source/stream_buffer.c ****     {
 791:../FreeRTOS/Source/stream_buffer.c ****         /* Checking if there is data and clearing the notification state must be
 792:../FreeRTOS/Source/stream_buffer.c ****          * performed atomically. */
 793:../FreeRTOS/Source/stream_buffer.c ****         taskENTER_CRITICAL();
 794:../FreeRTOS/Source/stream_buffer.c ****         {
 795:../FreeRTOS/Source/stream_buffer.c ****             xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 796:../FreeRTOS/Source/stream_buffer.c **** 
 797:../FreeRTOS/Source/stream_buffer.c ****             /* If this function was invoked by a message buffer read then
 798:../FreeRTOS/Source/stream_buffer.c ****              * xBytesToStoreMessageLength holds the number of bytes used to hold
 799:../FreeRTOS/Source/stream_buffer.c ****              * the length of the next discrete message.  If this function was
 800:../FreeRTOS/Source/stream_buffer.c ****              * invoked by a stream buffer read then xBytesToStoreMessageLength will
 801:../FreeRTOS/Source/stream_buffer.c ****              * be 0. */
 802:../FreeRTOS/Source/stream_buffer.c ****             if( xBytesAvailable <= xBytesToStoreMessageLength )
 803:../FreeRTOS/Source/stream_buffer.c ****             {
 804:../FreeRTOS/Source/stream_buffer.c ****                 /* Clear notification state as going to wait for data. */
 805:../FreeRTOS/Source/stream_buffer.c ****                 ( void ) xTaskNotifyStateClear( NULL );
 806:../FreeRTOS/Source/stream_buffer.c **** 
 807:../FreeRTOS/Source/stream_buffer.c ****                 /* Should only be one reader. */
 808:../FreeRTOS/Source/stream_buffer.c ****                 configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
 809:../FreeRTOS/Source/stream_buffer.c ****                 pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
 810:../FreeRTOS/Source/stream_buffer.c ****             }
 811:../FreeRTOS/Source/stream_buffer.c ****             else
 812:../FreeRTOS/Source/stream_buffer.c ****             {
 813:../FreeRTOS/Source/stream_buffer.c ****                 mtCOVERAGE_TEST_MARKER();
 814:../FreeRTOS/Source/stream_buffer.c ****             }
 815:../FreeRTOS/Source/stream_buffer.c ****         }
 816:../FreeRTOS/Source/stream_buffer.c ****         taskEXIT_CRITICAL();
 817:../FreeRTOS/Source/stream_buffer.c **** 
 818:../FreeRTOS/Source/stream_buffer.c ****         if( xBytesAvailable <= xBytesToStoreMessageLength )
 819:../FreeRTOS/Source/stream_buffer.c ****         {
 820:../FreeRTOS/Source/stream_buffer.c ****             /* Wait for data to be available. */
 821:../FreeRTOS/Source/stream_buffer.c ****             traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
 822:../FreeRTOS/Source/stream_buffer.c ****             ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
 823:../FreeRTOS/Source/stream_buffer.c ****             pxStreamBuffer->xTaskWaitingToReceive = NULL;
 824:../FreeRTOS/Source/stream_buffer.c **** 
 825:../FreeRTOS/Source/stream_buffer.c ****             /* Recheck the data available after blocking. */
 826:../FreeRTOS/Source/stream_buffer.c ****             xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 827:../FreeRTOS/Source/stream_buffer.c ****         }
 828:../FreeRTOS/Source/stream_buffer.c ****         else
 829:../FreeRTOS/Source/stream_buffer.c ****         {
 830:../FreeRTOS/Source/stream_buffer.c ****             mtCOVERAGE_TEST_MARKER();
 831:../FreeRTOS/Source/stream_buffer.c ****         }
 832:../FreeRTOS/Source/stream_buffer.c ****     }
 833:../FreeRTOS/Source/stream_buffer.c ****     else
 834:../FreeRTOS/Source/stream_buffer.c ****     {
 835:../FreeRTOS/Source/stream_buffer.c ****         xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 836:../FreeRTOS/Source/stream_buffer.c ****     }
 837:../FreeRTOS/Source/stream_buffer.c **** 
 838:../FreeRTOS/Source/stream_buffer.c ****     /* Whether receiving a discrete message (where xBytesToStoreMessageLength
 839:../FreeRTOS/Source/stream_buffer.c ****      * holds the number of bytes used to store the message length) or a stream of
 840:../FreeRTOS/Source/stream_buffer.c ****      * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
 841:../FreeRTOS/Source/stream_buffer.c ****      * available must be greater than xBytesToStoreMessageLength to be able to
 842:../FreeRTOS/Source/stream_buffer.c ****      * read bytes from the buffer. */
 843:../FreeRTOS/Source/stream_buffer.c ****     if( xBytesAvailable > xBytesToStoreMessageLength )
 844:../FreeRTOS/Source/stream_buffer.c ****     {
 845:../FreeRTOS/Source/stream_buffer.c ****         xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, x
 846:../FreeRTOS/Source/stream_buffer.c **** 
 847:../FreeRTOS/Source/stream_buffer.c ****         /* Was a task waiting for space in the buffer? */
 848:../FreeRTOS/Source/stream_buffer.c ****         if( xReceivedLength != ( size_t ) 0 )
 849:../FreeRTOS/Source/stream_buffer.c ****         {
 850:../FreeRTOS/Source/stream_buffer.c ****             traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
 851:../FreeRTOS/Source/stream_buffer.c ****             sbRECEIVE_COMPLETED( pxStreamBuffer );
 852:../FreeRTOS/Source/stream_buffer.c ****         }
 853:../FreeRTOS/Source/stream_buffer.c ****         else
 854:../FreeRTOS/Source/stream_buffer.c ****         {
 855:../FreeRTOS/Source/stream_buffer.c ****             mtCOVERAGE_TEST_MARKER();
 856:../FreeRTOS/Source/stream_buffer.c ****         }
 857:../FreeRTOS/Source/stream_buffer.c ****     }
 858:../FreeRTOS/Source/stream_buffer.c ****     else
 859:../FreeRTOS/Source/stream_buffer.c ****     {
 860:../FreeRTOS/Source/stream_buffer.c ****         traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
 861:../FreeRTOS/Source/stream_buffer.c ****         mtCOVERAGE_TEST_MARKER();
 862:../FreeRTOS/Source/stream_buffer.c ****     }
 863:../FreeRTOS/Source/stream_buffer.c **** 
 864:../FreeRTOS/Source/stream_buffer.c ****     return xReceivedLength;
 865:../FreeRTOS/Source/stream_buffer.c **** }
 866:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
 867:../FreeRTOS/Source/stream_buffer.c **** 
 868:../FreeRTOS/Source/stream_buffer.c **** size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
 869:../FreeRTOS/Source/stream_buffer.c **** {
 870:../FreeRTOS/Source/stream_buffer.c ****     StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 871:../FreeRTOS/Source/stream_buffer.c ****     size_t xReturn, xBytesAvailable, xOriginalTail;
 872:../FreeRTOS/Source/stream_buffer.c ****     configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;
 873:../FreeRTOS/Source/stream_buffer.c **** 
 874:../FreeRTOS/Source/stream_buffer.c ****     configASSERT( pxStreamBuffer );
 875:../FreeRTOS/Source/stream_buffer.c **** 
 876:../FreeRTOS/Source/stream_buffer.c ****     /* Ensure the stream buffer is being used as a message buffer. */
 877:../FreeRTOS/Source/stream_buffer.c ****     if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 878:../FreeRTOS/Source/stream_buffer.c ****     {
 879:../FreeRTOS/Source/stream_buffer.c ****         xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 880:../FreeRTOS/Source/stream_buffer.c **** 
 881:../FreeRTOS/Source/stream_buffer.c ****         if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
 882:../FreeRTOS/Source/stream_buffer.c ****         {
 883:../FreeRTOS/Source/stream_buffer.c ****             /* The number of bytes available is greater than the number of bytes
 884:../FreeRTOS/Source/stream_buffer.c ****              * required to hold the length of the next message, so another message
 885:../FreeRTOS/Source/stream_buffer.c ****              * is available.  Return its length without removing the length bytes
 886:../FreeRTOS/Source/stream_buffer.c ****              * from the buffer.  A copy of the tail is stored so the buffer can be
 887:../FreeRTOS/Source/stream_buffer.c ****              * returned to its prior state as the message is not actually being
 888:../FreeRTOS/Source/stream_buffer.c ****              * removed from the buffer. */
 889:../FreeRTOS/Source/stream_buffer.c ****             xOriginalTail = pxStreamBuffer->xTail;
 890:../FreeRTOS/Source/stream_buffer.c ****             ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO
 891:../FreeRTOS/Source/stream_buffer.c ****             xReturn = ( size_t ) xTempReturn;
 892:../FreeRTOS/Source/stream_buffer.c ****             pxStreamBuffer->xTail = xOriginalTail;
 893:../FreeRTOS/Source/stream_buffer.c ****         }
 894:../FreeRTOS/Source/stream_buffer.c ****         else
 895:../FreeRTOS/Source/stream_buffer.c ****         {
 896:../FreeRTOS/Source/stream_buffer.c ****             /* The minimum amount of bytes in a message buffer is
 897:../FreeRTOS/Source/stream_buffer.c ****              * ( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
 898:../FreeRTOS/Source/stream_buffer.c ****              * less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
 899:../FreeRTOS/Source/stream_buffer.c ****              * value is 0. */
 900:../FreeRTOS/Source/stream_buffer.c ****             configASSERT( xBytesAvailable == 0 );
 901:../FreeRTOS/Source/stream_buffer.c ****             xReturn = 0;
 902:../FreeRTOS/Source/stream_buffer.c ****         }
 903:../FreeRTOS/Source/stream_buffer.c ****     }
 904:../FreeRTOS/Source/stream_buffer.c ****     else
 905:../FreeRTOS/Source/stream_buffer.c ****     {
 906:../FreeRTOS/Source/stream_buffer.c ****         xReturn = 0;
 907:../FreeRTOS/Source/stream_buffer.c ****     }
 908:../FreeRTOS/Source/stream_buffer.c **** 
 909:../FreeRTOS/Source/stream_buffer.c ****     return xReturn;
 910:../FreeRTOS/Source/stream_buffer.c **** }
 911:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
 912:../FreeRTOS/Source/stream_buffer.c **** 
 913:../FreeRTOS/Source/stream_buffer.c **** size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
 914:../FreeRTOS/Source/stream_buffer.c ****                                     void * pvRxData,
 915:../FreeRTOS/Source/stream_buffer.c ****                                     size_t xBufferLengthBytes,
 916:../FreeRTOS/Source/stream_buffer.c ****                                     BaseType_t * const pxHigherPriorityTaskWoken )
 917:../FreeRTOS/Source/stream_buffer.c **** {
 918:../FreeRTOS/Source/stream_buffer.c ****     StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 919:../FreeRTOS/Source/stream_buffer.c ****     size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
 920:../FreeRTOS/Source/stream_buffer.c **** 
 921:../FreeRTOS/Source/stream_buffer.c ****     configASSERT( pvRxData );
 922:../FreeRTOS/Source/stream_buffer.c ****     configASSERT( pxStreamBuffer );
 923:../FreeRTOS/Source/stream_buffer.c **** 
 924:../FreeRTOS/Source/stream_buffer.c ****     /* This receive function is used by both message buffers, which store
 925:../FreeRTOS/Source/stream_buffer.c ****      * discrete messages, and stream buffers, which store a continuous stream of
 926:../FreeRTOS/Source/stream_buffer.c ****      * bytes.  Discrete messages include an additional
 927:../FreeRTOS/Source/stream_buffer.c ****      * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
 928:../FreeRTOS/Source/stream_buffer.c ****      * message. */
 929:../FreeRTOS/Source/stream_buffer.c ****     if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 930:../FreeRTOS/Source/stream_buffer.c ****     {
 931:../FreeRTOS/Source/stream_buffer.c ****         xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
 932:../FreeRTOS/Source/stream_buffer.c ****     }
 933:../FreeRTOS/Source/stream_buffer.c ****     else
 934:../FreeRTOS/Source/stream_buffer.c ****     {
 935:../FreeRTOS/Source/stream_buffer.c ****         xBytesToStoreMessageLength = 0;
 936:../FreeRTOS/Source/stream_buffer.c ****     }
 937:../FreeRTOS/Source/stream_buffer.c **** 
 938:../FreeRTOS/Source/stream_buffer.c ****     xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 939:../FreeRTOS/Source/stream_buffer.c **** 
 940:../FreeRTOS/Source/stream_buffer.c ****     /* Whether receiving a discrete message (where xBytesToStoreMessageLength
 941:../FreeRTOS/Source/stream_buffer.c ****      * holds the number of bytes used to store the message length) or a stream of
 942:../FreeRTOS/Source/stream_buffer.c ****      * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
 943:../FreeRTOS/Source/stream_buffer.c ****      * available must be greater than xBytesToStoreMessageLength to be able to
 944:../FreeRTOS/Source/stream_buffer.c ****      * read bytes from the buffer. */
 945:../FreeRTOS/Source/stream_buffer.c ****     if( xBytesAvailable > xBytesToStoreMessageLength )
 946:../FreeRTOS/Source/stream_buffer.c ****     {
 947:../FreeRTOS/Source/stream_buffer.c ****         xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, x
 948:../FreeRTOS/Source/stream_buffer.c **** 
 949:../FreeRTOS/Source/stream_buffer.c ****         /* Was a task waiting for space in the buffer? */
 950:../FreeRTOS/Source/stream_buffer.c ****         if( xReceivedLength != ( size_t ) 0 )
 951:../FreeRTOS/Source/stream_buffer.c ****         {
 952:../FreeRTOS/Source/stream_buffer.c ****             sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
 953:../FreeRTOS/Source/stream_buffer.c ****         }
 954:../FreeRTOS/Source/stream_buffer.c ****         else
 955:../FreeRTOS/Source/stream_buffer.c ****         {
 956:../FreeRTOS/Source/stream_buffer.c ****             mtCOVERAGE_TEST_MARKER();
 957:../FreeRTOS/Source/stream_buffer.c ****         }
 958:../FreeRTOS/Source/stream_buffer.c ****     }
 959:../FreeRTOS/Source/stream_buffer.c ****     else
 960:../FreeRTOS/Source/stream_buffer.c ****     {
 961:../FreeRTOS/Source/stream_buffer.c ****         mtCOVERAGE_TEST_MARKER();
 962:../FreeRTOS/Source/stream_buffer.c ****     }
 963:../FreeRTOS/Source/stream_buffer.c **** 
 964:../FreeRTOS/Source/stream_buffer.c ****     traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );
 965:../FreeRTOS/Source/stream_buffer.c **** 
 966:../FreeRTOS/Source/stream_buffer.c ****     return xReceivedLength;
 967:../FreeRTOS/Source/stream_buffer.c **** }
 968:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
 969:../FreeRTOS/Source/stream_buffer.c **** 
 970:../FreeRTOS/Source/stream_buffer.c **** static size_t prvReadMessageFromBuffer( StreamBuffer_t * pxStreamBuffer,
 971:../FreeRTOS/Source/stream_buffer.c ****                                         void * pvRxData,
 972:../FreeRTOS/Source/stream_buffer.c ****                                         size_t xBufferLengthBytes,
 973:../FreeRTOS/Source/stream_buffer.c ****                                         size_t xBytesAvailable,
 974:../FreeRTOS/Source/stream_buffer.c ****                                         size_t xBytesToStoreMessageLength )
 975:../FreeRTOS/Source/stream_buffer.c **** {
 976:../FreeRTOS/Source/stream_buffer.c ****     size_t xOriginalTail, xReceivedLength, xNextMessageLength;
 977:../FreeRTOS/Source/stream_buffer.c ****     configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;
 978:../FreeRTOS/Source/stream_buffer.c **** 
 979:../FreeRTOS/Source/stream_buffer.c ****     if( xBytesToStoreMessageLength != ( size_t ) 0 )
 980:../FreeRTOS/Source/stream_buffer.c ****     {
 981:../FreeRTOS/Source/stream_buffer.c ****         /* A discrete message is being received.  First receive the length
 982:../FreeRTOS/Source/stream_buffer.c ****          * of the message.  A copy of the tail is stored so the buffer can be
 983:../FreeRTOS/Source/stream_buffer.c ****          * returned to its prior state if the length of the message is too
 984:../FreeRTOS/Source/stream_buffer.c ****          * large for the provided buffer. */
 985:../FreeRTOS/Source/stream_buffer.c ****         xOriginalTail = pxStreamBuffer->xTail;
 986:../FreeRTOS/Source/stream_buffer.c ****         ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBy
 987:../FreeRTOS/Source/stream_buffer.c ****         xNextMessageLength = ( size_t ) xTempNextMessageLength;
 988:../FreeRTOS/Source/stream_buffer.c **** 
 989:../FreeRTOS/Source/stream_buffer.c ****         /* Reduce the number of bytes available by the number of bytes just
 990:../FreeRTOS/Source/stream_buffer.c ****          * read out. */
 991:../FreeRTOS/Source/stream_buffer.c ****         xBytesAvailable -= xBytesToStoreMessageLength;
 992:../FreeRTOS/Source/stream_buffer.c **** 
 993:../FreeRTOS/Source/stream_buffer.c ****         /* Check there is enough space in the buffer provided by the
 994:../FreeRTOS/Source/stream_buffer.c ****          * user. */
 995:../FreeRTOS/Source/stream_buffer.c ****         if( xNextMessageLength > xBufferLengthBytes )
 996:../FreeRTOS/Source/stream_buffer.c ****         {
 997:../FreeRTOS/Source/stream_buffer.c ****             /* The user has provided insufficient space to read the message
 998:../FreeRTOS/Source/stream_buffer.c ****              * so return the buffer to its previous state (so the length of
 999:../FreeRTOS/Source/stream_buffer.c ****              * the message is in the buffer again). */
1000:../FreeRTOS/Source/stream_buffer.c ****             pxStreamBuffer->xTail = xOriginalTail;
1001:../FreeRTOS/Source/stream_buffer.c ****             xNextMessageLength = 0;
1002:../FreeRTOS/Source/stream_buffer.c ****         }
1003:../FreeRTOS/Source/stream_buffer.c ****         else
1004:../FreeRTOS/Source/stream_buffer.c ****         {
1005:../FreeRTOS/Source/stream_buffer.c ****             mtCOVERAGE_TEST_MARKER();
1006:../FreeRTOS/Source/stream_buffer.c ****         }
1007:../FreeRTOS/Source/stream_buffer.c ****     }
1008:../FreeRTOS/Source/stream_buffer.c ****     else
1009:../FreeRTOS/Source/stream_buffer.c ****     {
1010:../FreeRTOS/Source/stream_buffer.c ****         /* A stream of bytes is being received (as opposed to a discrete
1011:../FreeRTOS/Source/stream_buffer.c ****          * message), so read as many bytes as possible. */
1012:../FreeRTOS/Source/stream_buffer.c ****         xNextMessageLength = xBufferLengthBytes;
1013:../FreeRTOS/Source/stream_buffer.c ****     }
1014:../FreeRTOS/Source/stream_buffer.c **** 
1015:../FreeRTOS/Source/stream_buffer.c ****     /* Read the actual data. */
1016:../FreeRTOS/Source/stream_buffer.c ****     xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageL
1017:../FreeRTOS/Source/stream_buffer.c **** 
1018:../FreeRTOS/Source/stream_buffer.c ****     return xReceivedLength;
1019:../FreeRTOS/Source/stream_buffer.c **** }
1020:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
1021:../FreeRTOS/Source/stream_buffer.c **** 
1022:../FreeRTOS/Source/stream_buffer.c **** BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
1023:../FreeRTOS/Source/stream_buffer.c **** {
1024:../FreeRTOS/Source/stream_buffer.c ****     const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
1025:../FreeRTOS/Source/stream_buffer.c ****     BaseType_t xReturn;
1026:../FreeRTOS/Source/stream_buffer.c ****     size_t xTail;
1027:../FreeRTOS/Source/stream_buffer.c **** 
1028:../FreeRTOS/Source/stream_buffer.c ****     configASSERT( pxStreamBuffer );
1029:../FreeRTOS/Source/stream_buffer.c **** 
1030:../FreeRTOS/Source/stream_buffer.c ****     /* True if no bytes are available. */
1031:../FreeRTOS/Source/stream_buffer.c ****     xTail = pxStreamBuffer->xTail;
1032:../FreeRTOS/Source/stream_buffer.c **** 
1033:../FreeRTOS/Source/stream_buffer.c ****     if( pxStreamBuffer->xHead == xTail )
1034:../FreeRTOS/Source/stream_buffer.c ****     {
1035:../FreeRTOS/Source/stream_buffer.c ****         xReturn = pdTRUE;
1036:../FreeRTOS/Source/stream_buffer.c ****     }
1037:../FreeRTOS/Source/stream_buffer.c ****     else
1038:../FreeRTOS/Source/stream_buffer.c ****     {
1039:../FreeRTOS/Source/stream_buffer.c ****         xReturn = pdFALSE;
1040:../FreeRTOS/Source/stream_buffer.c ****     }
1041:../FreeRTOS/Source/stream_buffer.c **** 
1042:../FreeRTOS/Source/stream_buffer.c ****     return xReturn;
1043:../FreeRTOS/Source/stream_buffer.c **** }
1044:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
1045:../FreeRTOS/Source/stream_buffer.c **** 
1046:../FreeRTOS/Source/stream_buffer.c **** BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
1047:../FreeRTOS/Source/stream_buffer.c **** {
1048:../FreeRTOS/Source/stream_buffer.c ****     BaseType_t xReturn;
1049:../FreeRTOS/Source/stream_buffer.c ****     size_t xBytesToStoreMessageLength;
1050:../FreeRTOS/Source/stream_buffer.c ****     const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
1051:../FreeRTOS/Source/stream_buffer.c **** 
1052:../FreeRTOS/Source/stream_buffer.c ****     configASSERT( pxStreamBuffer );
1053:../FreeRTOS/Source/stream_buffer.c **** 
1054:../FreeRTOS/Source/stream_buffer.c ****     /* This generic version of the receive function is used by both message
1055:../FreeRTOS/Source/stream_buffer.c ****      * buffers, which store discrete messages, and stream buffers, which store a
1056:../FreeRTOS/Source/stream_buffer.c ****      * continuous stream of bytes.  Discrete messages include an additional
1057:../FreeRTOS/Source/stream_buffer.c ****      * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
1058:../FreeRTOS/Source/stream_buffer.c ****     if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
1059:../FreeRTOS/Source/stream_buffer.c ****     {
1060:../FreeRTOS/Source/stream_buffer.c ****         xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
1061:../FreeRTOS/Source/stream_buffer.c ****     }
1062:../FreeRTOS/Source/stream_buffer.c ****     else
1063:../FreeRTOS/Source/stream_buffer.c ****     {
1064:../FreeRTOS/Source/stream_buffer.c ****         xBytesToStoreMessageLength = 0;
1065:../FreeRTOS/Source/stream_buffer.c ****     }
1066:../FreeRTOS/Source/stream_buffer.c **** 
1067:../FreeRTOS/Source/stream_buffer.c ****     /* True if the available space equals zero. */
1068:../FreeRTOS/Source/stream_buffer.c ****     if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
1069:../FreeRTOS/Source/stream_buffer.c ****     {
1070:../FreeRTOS/Source/stream_buffer.c ****         xReturn = pdTRUE;
1071:../FreeRTOS/Source/stream_buffer.c ****     }
1072:../FreeRTOS/Source/stream_buffer.c ****     else
1073:../FreeRTOS/Source/stream_buffer.c ****     {
1074:../FreeRTOS/Source/stream_buffer.c ****         xReturn = pdFALSE;
1075:../FreeRTOS/Source/stream_buffer.c ****     }
1076:../FreeRTOS/Source/stream_buffer.c **** 
1077:../FreeRTOS/Source/stream_buffer.c ****     return xReturn;
1078:../FreeRTOS/Source/stream_buffer.c **** }
1079:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
1080:../FreeRTOS/Source/stream_buffer.c **** 
1081:../FreeRTOS/Source/stream_buffer.c **** BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
1082:../FreeRTOS/Source/stream_buffer.c ****                                               BaseType_t * pxHigherPriorityTaskWoken )
1083:../FreeRTOS/Source/stream_buffer.c **** {
1084:../FreeRTOS/Source/stream_buffer.c ****     StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
1085:../FreeRTOS/Source/stream_buffer.c ****     BaseType_t xReturn;
1086:../FreeRTOS/Source/stream_buffer.c ****     UBaseType_t uxSavedInterruptStatus;
1087:../FreeRTOS/Source/stream_buffer.c **** 
1088:../FreeRTOS/Source/stream_buffer.c ****     configASSERT( pxStreamBuffer );
1089:../FreeRTOS/Source/stream_buffer.c **** 
1090:../FreeRTOS/Source/stream_buffer.c ****     uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
1091:../FreeRTOS/Source/stream_buffer.c ****     {
1092:../FreeRTOS/Source/stream_buffer.c ****         if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
1093:../FreeRTOS/Source/stream_buffer.c ****         {
1094:../FreeRTOS/Source/stream_buffer.c ****             ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
1095:../FreeRTOS/Source/stream_buffer.c ****                                          ( uint32_t ) 0,
1096:../FreeRTOS/Source/stream_buffer.c ****                                          eNoAction,
1097:../FreeRTOS/Source/stream_buffer.c ****                                          pxHigherPriorityTaskWoken );
1098:../FreeRTOS/Source/stream_buffer.c ****             ( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
1099:../FreeRTOS/Source/stream_buffer.c ****             xReturn = pdTRUE;
1100:../FreeRTOS/Source/stream_buffer.c ****         }
1101:../FreeRTOS/Source/stream_buffer.c ****         else
1102:../FreeRTOS/Source/stream_buffer.c ****         {
1103:../FreeRTOS/Source/stream_buffer.c ****             xReturn = pdFALSE;
1104:../FreeRTOS/Source/stream_buffer.c ****         }
1105:../FreeRTOS/Source/stream_buffer.c ****     }
1106:../FreeRTOS/Source/stream_buffer.c ****     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1107:../FreeRTOS/Source/stream_buffer.c **** 
1108:../FreeRTOS/Source/stream_buffer.c ****     return xReturn;
1109:../FreeRTOS/Source/stream_buffer.c **** }
1110:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
1111:../FreeRTOS/Source/stream_buffer.c **** 
1112:../FreeRTOS/Source/stream_buffer.c **** BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
1113:../FreeRTOS/Source/stream_buffer.c ****                                                  BaseType_t * pxHigherPriorityTaskWoken )
1114:../FreeRTOS/Source/stream_buffer.c **** {
1115:../FreeRTOS/Source/stream_buffer.c ****     StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
1116:../FreeRTOS/Source/stream_buffer.c ****     BaseType_t xReturn;
1117:../FreeRTOS/Source/stream_buffer.c ****     UBaseType_t uxSavedInterruptStatus;
1118:../FreeRTOS/Source/stream_buffer.c **** 
1119:../FreeRTOS/Source/stream_buffer.c ****     configASSERT( pxStreamBuffer );
1120:../FreeRTOS/Source/stream_buffer.c **** 
1121:../FreeRTOS/Source/stream_buffer.c ****     uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
1122:../FreeRTOS/Source/stream_buffer.c ****     {
1123:../FreeRTOS/Source/stream_buffer.c ****         if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
1124:../FreeRTOS/Source/stream_buffer.c ****         {
1125:../FreeRTOS/Source/stream_buffer.c ****             ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
1126:../FreeRTOS/Source/stream_buffer.c ****                                          ( uint32_t ) 0,
1127:../FreeRTOS/Source/stream_buffer.c ****                                          eNoAction,
1128:../FreeRTOS/Source/stream_buffer.c ****                                          pxHigherPriorityTaskWoken );
1129:../FreeRTOS/Source/stream_buffer.c ****             ( pxStreamBuffer )->xTaskWaitingToSend = NULL;
1130:../FreeRTOS/Source/stream_buffer.c ****             xReturn = pdTRUE;
1131:../FreeRTOS/Source/stream_buffer.c ****         }
1132:../FreeRTOS/Source/stream_buffer.c ****         else
1133:../FreeRTOS/Source/stream_buffer.c ****         {
1134:../FreeRTOS/Source/stream_buffer.c ****             xReturn = pdFALSE;
1135:../FreeRTOS/Source/stream_buffer.c ****         }
1136:../FreeRTOS/Source/stream_buffer.c ****     }
1137:../FreeRTOS/Source/stream_buffer.c ****     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1138:../FreeRTOS/Source/stream_buffer.c **** 
1139:../FreeRTOS/Source/stream_buffer.c ****     return xReturn;
1140:../FreeRTOS/Source/stream_buffer.c **** }
1141:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
1142:../FreeRTOS/Source/stream_buffer.c **** 
1143:../FreeRTOS/Source/stream_buffer.c **** static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer,
1144:../FreeRTOS/Source/stream_buffer.c ****                                      const uint8_t * pucData,
1145:../FreeRTOS/Source/stream_buffer.c ****                                      size_t xCount )
1146:../FreeRTOS/Source/stream_buffer.c **** {
1147:../FreeRTOS/Source/stream_buffer.c ****     size_t xNextHead, xFirstLength;
1148:../FreeRTOS/Source/stream_buffer.c **** 
1149:../FreeRTOS/Source/stream_buffer.c ****     configASSERT( xCount > ( size_t ) 0 );
1150:../FreeRTOS/Source/stream_buffer.c **** 
1151:../FreeRTOS/Source/stream_buffer.c ****     xNextHead = pxStreamBuffer->xHead;
1152:../FreeRTOS/Source/stream_buffer.c **** 
1153:../FreeRTOS/Source/stream_buffer.c ****     /* Calculate the number of bytes that can be added in the first write -
1154:../FreeRTOS/Source/stream_buffer.c ****      * which may be less than the total number of bytes that need to be added if
1155:../FreeRTOS/Source/stream_buffer.c ****      * the buffer will wrap back to the beginning. */
1156:../FreeRTOS/Source/stream_buffer.c ****     xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );
1157:../FreeRTOS/Source/stream_buffer.c **** 
1158:../FreeRTOS/Source/stream_buffer.c ****     /* Write as many bytes as can be written in the first write. */
1159:../FreeRTOS/Source/stream_buffer.c ****     configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );
1160:../FreeRTOS/Source/stream_buffer.c ****     ( void ) memcpy( ( void * ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) p
1161:../FreeRTOS/Source/stream_buffer.c **** 
1162:../FreeRTOS/Source/stream_buffer.c ****     /* If the number of bytes written was less than the number that could be
1163:../FreeRTOS/Source/stream_buffer.c ****      * written in the first write... */
1164:../FreeRTOS/Source/stream_buffer.c ****     if( xCount > xFirstLength )
1165:../FreeRTOS/Source/stream_buffer.c ****     {
1166:../FreeRTOS/Source/stream_buffer.c ****         /* ...then write the remaining bytes to the start of the buffer. */
1167:../FreeRTOS/Source/stream_buffer.c ****         configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
1168:../FreeRTOS/Source/stream_buffer.c ****         ( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstL
1169:../FreeRTOS/Source/stream_buffer.c ****     }
1170:../FreeRTOS/Source/stream_buffer.c ****     else
1171:../FreeRTOS/Source/stream_buffer.c ****     {
1172:../FreeRTOS/Source/stream_buffer.c ****         mtCOVERAGE_TEST_MARKER();
1173:../FreeRTOS/Source/stream_buffer.c ****     }
1174:../FreeRTOS/Source/stream_buffer.c **** 
1175:../FreeRTOS/Source/stream_buffer.c ****     xNextHead += xCount;
1176:../FreeRTOS/Source/stream_buffer.c **** 
1177:../FreeRTOS/Source/stream_buffer.c ****     if( xNextHead >= pxStreamBuffer->xLength )
1178:../FreeRTOS/Source/stream_buffer.c ****     {
1179:../FreeRTOS/Source/stream_buffer.c ****         xNextHead -= pxStreamBuffer->xLength;
1180:../FreeRTOS/Source/stream_buffer.c ****     }
1181:../FreeRTOS/Source/stream_buffer.c ****     else
1182:../FreeRTOS/Source/stream_buffer.c ****     {
1183:../FreeRTOS/Source/stream_buffer.c ****         mtCOVERAGE_TEST_MARKER();
1184:../FreeRTOS/Source/stream_buffer.c ****     }
1185:../FreeRTOS/Source/stream_buffer.c **** 
1186:../FreeRTOS/Source/stream_buffer.c ****     pxStreamBuffer->xHead = xNextHead;
1187:../FreeRTOS/Source/stream_buffer.c **** 
1188:../FreeRTOS/Source/stream_buffer.c ****     return xCount;
1189:../FreeRTOS/Source/stream_buffer.c **** }
1190:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
1191:../FreeRTOS/Source/stream_buffer.c **** 
1192:../FreeRTOS/Source/stream_buffer.c **** static size_t prvReadBytesFromBuffer( StreamBuffer_t * pxStreamBuffer,
1193:../FreeRTOS/Source/stream_buffer.c ****                                       uint8_t * pucData,
1194:../FreeRTOS/Source/stream_buffer.c ****                                       size_t xMaxCount,
1195:../FreeRTOS/Source/stream_buffer.c ****                                       size_t xBytesAvailable )
1196:../FreeRTOS/Source/stream_buffer.c **** {
1197:../FreeRTOS/Source/stream_buffer.c ****     size_t xCount, xFirstLength, xNextTail;
1198:../FreeRTOS/Source/stream_buffer.c **** 
1199:../FreeRTOS/Source/stream_buffer.c ****     /* Use the minimum of the wanted bytes and the available bytes. */
1200:../FreeRTOS/Source/stream_buffer.c ****     xCount = configMIN( xBytesAvailable, xMaxCount );
1201:../FreeRTOS/Source/stream_buffer.c **** 
1202:../FreeRTOS/Source/stream_buffer.c ****     if( xCount > ( size_t ) 0 )
1203:../FreeRTOS/Source/stream_buffer.c ****     {
1204:../FreeRTOS/Source/stream_buffer.c ****         xNextTail = pxStreamBuffer->xTail;
1205:../FreeRTOS/Source/stream_buffer.c **** 
1206:../FreeRTOS/Source/stream_buffer.c ****         /* Calculate the number of bytes that can be read - which may be
1207:../FreeRTOS/Source/stream_buffer.c ****          * less than the number wanted if the data wraps around to the start of
1208:../FreeRTOS/Source/stream_buffer.c ****          * the buffer. */
1209:../FreeRTOS/Source/stream_buffer.c ****         xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );
1210:../FreeRTOS/Source/stream_buffer.c **** 
1211:../FreeRTOS/Source/stream_buffer.c ****         /* Obtain the number of bytes it is possible to obtain in the first
1212:../FreeRTOS/Source/stream_buffer.c ****          * read.  Asserts check bounds of read and write. */
1213:../FreeRTOS/Source/stream_buffer.c ****         configASSERT( xFirstLength <= xMaxCount );
1214:../FreeRTOS/Source/stream_buffer.c ****         configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
1215:../FreeRTOS/Source/stream_buffer.c ****         ( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTa
1216:../FreeRTOS/Source/stream_buffer.c **** 
1217:../FreeRTOS/Source/stream_buffer.c ****         /* If the total number of wanted bytes is greater than the number
1218:../FreeRTOS/Source/stream_buffer.c ****          * that could be read in the first read... */
1219:../FreeRTOS/Source/stream_buffer.c ****         if( xCount > xFirstLength )
1220:../FreeRTOS/Source/stream_buffer.c ****         {
1221:../FreeRTOS/Source/stream_buffer.c ****             /*...then read the remaining bytes from the start of the buffer. */
1222:../FreeRTOS/Source/stream_buffer.c ****             configASSERT( xCount <= xMaxCount );
1223:../FreeRTOS/Source/stream_buffer.c ****             ( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->
1224:../FreeRTOS/Source/stream_buffer.c ****         }
1225:../FreeRTOS/Source/stream_buffer.c ****         else
1226:../FreeRTOS/Source/stream_buffer.c ****         {
1227:../FreeRTOS/Source/stream_buffer.c ****             mtCOVERAGE_TEST_MARKER();
1228:../FreeRTOS/Source/stream_buffer.c ****         }
1229:../FreeRTOS/Source/stream_buffer.c **** 
1230:../FreeRTOS/Source/stream_buffer.c ****         /* Move the tail pointer to effectively remove the data read from
1231:../FreeRTOS/Source/stream_buffer.c ****          * the buffer. */
1232:../FreeRTOS/Source/stream_buffer.c ****         xNextTail += xCount;
1233:../FreeRTOS/Source/stream_buffer.c **** 
1234:../FreeRTOS/Source/stream_buffer.c ****         if( xNextTail >= pxStreamBuffer->xLength )
1235:../FreeRTOS/Source/stream_buffer.c ****         {
1236:../FreeRTOS/Source/stream_buffer.c ****             xNextTail -= pxStreamBuffer->xLength;
1237:../FreeRTOS/Source/stream_buffer.c ****         }
1238:../FreeRTOS/Source/stream_buffer.c **** 
1239:../FreeRTOS/Source/stream_buffer.c ****         pxStreamBuffer->xTail = xNextTail;
1240:../FreeRTOS/Source/stream_buffer.c ****     }
1241:../FreeRTOS/Source/stream_buffer.c ****     else
1242:../FreeRTOS/Source/stream_buffer.c ****     {
1243:../FreeRTOS/Source/stream_buffer.c ****         mtCOVERAGE_TEST_MARKER();
1244:../FreeRTOS/Source/stream_buffer.c ****     }
1245:../FreeRTOS/Source/stream_buffer.c **** 
1246:../FreeRTOS/Source/stream_buffer.c ****     return xCount;
1247:../FreeRTOS/Source/stream_buffer.c **** }
1248:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
1249:../FreeRTOS/Source/stream_buffer.c **** 
1250:../FreeRTOS/Source/stream_buffer.c **** static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
1251:../FreeRTOS/Source/stream_buffer.c **** {
  26              	 .loc 1 1251 0
  27              	 .cfi_startproc
  28              	 
  29              	 
  30              	 
  31              	.LVL0:
1252:../FreeRTOS/Source/stream_buffer.c **** /* Returns the distance between xTail and xHead. */
1253:../FreeRTOS/Source/stream_buffer.c ****     size_t xCount;
1254:../FreeRTOS/Source/stream_buffer.c **** 
1255:../FreeRTOS/Source/stream_buffer.c ****     xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
  32              	 .loc 1 1255 0
  33 0000 8268     	 ldr r2,[r0,#8]
  34 0002 4368     	 ldr r3,[r0,#4]
  35 0004 1344     	 add r3,r3,r2
  36              	.LVL1:
1256:../FreeRTOS/Source/stream_buffer.c ****     xCount -= pxStreamBuffer->xTail;
  37              	 .loc 1 1256 0
  38 0006 0068     	 ldr r0,[r0]
  39              	.LVL2:
  40 0008 181A     	 subs r0,r3,r0
  41              	.LVL3:
1257:../FreeRTOS/Source/stream_buffer.c **** 
1258:../FreeRTOS/Source/stream_buffer.c ****     if( xCount >= pxStreamBuffer->xLength )
  42              	 .loc 1 1258 0
  43 000a 8242     	 cmp r2,r0
1259:../FreeRTOS/Source/stream_buffer.c ****     {
1260:../FreeRTOS/Source/stream_buffer.c ****         xCount -= pxStreamBuffer->xLength;
  44              	 .loc 1 1260 0
  45 000c 98BF     	 it ls
  46 000e 801A     	 subls r0,r0,r2
  47              	.LVL4:
1261:../FreeRTOS/Source/stream_buffer.c ****     }
1262:../FreeRTOS/Source/stream_buffer.c ****     else
1263:../FreeRTOS/Source/stream_buffer.c ****     {
1264:../FreeRTOS/Source/stream_buffer.c ****         mtCOVERAGE_TEST_MARKER();
1265:../FreeRTOS/Source/stream_buffer.c ****     }
1266:../FreeRTOS/Source/stream_buffer.c **** 
1267:../FreeRTOS/Source/stream_buffer.c ****     return xCount;
1268:../FreeRTOS/Source/stream_buffer.c **** }
  48              	 .loc 1 1268 0
  49 0010 7047     	 bx lr
  50              	 .cfi_endproc
  51              	.LFE24:
  53 0012 00BF     	 .section .text.prvInitialiseNewStreamBuffer,"ax",%progbits
  54              	 .align 2
  55              	 .thumb
  56              	 .thumb_func
  58              	prvInitialiseNewStreamBuffer:
  59              	.LFB25:
1269:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
1270:../FreeRTOS/Source/stream_buffer.c **** 
1271:../FreeRTOS/Source/stream_buffer.c **** static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
1272:../FreeRTOS/Source/stream_buffer.c ****                                           uint8_t * const pucBuffer,
1273:../FreeRTOS/Source/stream_buffer.c ****                                           size_t xBufferSizeBytes,
1274:../FreeRTOS/Source/stream_buffer.c ****                                           size_t xTriggerLevelBytes,
1275:../FreeRTOS/Source/stream_buffer.c ****                                           uint8_t ucFlags )
1276:../FreeRTOS/Source/stream_buffer.c **** {
  60              	 .loc 1 1276 0
  61              	 .cfi_startproc
  62              	 
  63              	 
  64              	.LVL5:
  65 0000 2DE9F041 	 push {r4,r5,r6,r7,r8,lr}
  66              	.LCFI0:
  67              	 .cfi_def_cfa_offset 24
  68              	 .cfi_offset 4,-24
  69              	 .cfi_offset 5,-20
  70              	 .cfi_offset 6,-16
  71              	 .cfi_offset 7,-12
  72              	 .cfi_offset 8,-8
  73              	 .cfi_offset 14,-4
  74 0004 0446     	 mov r4,r0
  75 0006 0E46     	 mov r6,r1
  76 0008 9046     	 mov r8,r2
  77 000a 1F46     	 mov r7,r3
  78              	.LVL6:
  79              	.LBB85:
1277:../FreeRTOS/Source/stream_buffer.c ****     /* Assert here is deliberately writing to the entire buffer to ensure it can
1278:../FreeRTOS/Source/stream_buffer.c ****      * be written to without generating exceptions, and is setting the buffer to a
1279:../FreeRTOS/Source/stream_buffer.c ****      * known value to assist in development/debugging. */
1280:../FreeRTOS/Source/stream_buffer.c ****     #if ( configASSERT_DEFINED == 1 )
1281:../FreeRTOS/Source/stream_buffer.c ****         {
1282:../FreeRTOS/Source/stream_buffer.c ****             /* The value written just has to be identifiable when looking at the
1283:../FreeRTOS/Source/stream_buffer.c ****              * memory.  Don't use 0xA5 as that is the stack fill value and could
1284:../FreeRTOS/Source/stream_buffer.c ****              * result in confusion as to what is actually being observed. */
1285:../FreeRTOS/Source/stream_buffer.c ****             const BaseType_t xWriteValue = 0x55;
1286:../FreeRTOS/Source/stream_buffer.c ****             configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer )
  80              	 .loc 1 1286 0
  81 000c 0846     	 mov r0,r1
  82              	.LVL7:
  83 000e 5521     	 movs r1,#85
  84              	.LVL8:
  85 0010 FFF7FEFF 	 bl memset
  86              	.LVL9:
  87 0014 0546     	 mov r5,r0
  88 0016 B042     	 cmp r0,r6
  89 0018 08D0     	 beq .L4
  90              	.LBB86:
  91              	.LBB87:
  92              	 .file 2 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h"
   1:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*
   2:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * FreeRTOS Kernel V10.4.1
   3:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
   5:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * this software and associated documentation files (the "Software"), to deal in
   7:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * the Software without restriction, including without limitation the rights to
   8:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * subject to the following conditions:
  11:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  12:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * The above copyright notice and this permission notice shall be included in all
  13:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * copies or substantial portions of the Software.
  14:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  15:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  22:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * https://www.FreeRTOS.org
  23:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * https://github.com/FreeRTOS
  24:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  25:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * 1 tab == 4 spaces!
  26:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  */
  27:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  28:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  29:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** #ifndef PORTMACRO_H
  30:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define PORTMACRO_H
  31:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  32:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifdef __cplusplus
  33:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         extern "C" {
  34:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
  35:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  36:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------
  37:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * Port specific definitions.
  38:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  39:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * The settings in this file configure FreeRTOS correctly for the
  40:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * given hardware and compiler.
  41:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  42:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * These settings should not be altered.
  43:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *-----------------------------------------------------------
  44:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  */
  45:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  46:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Type definitions. */
  47:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portCHAR          char
  48:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portFLOAT         float
  49:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portDOUBLE        double
  50:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portLONG          long
  51:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portSHORT         short
  52:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portSTACK_TYPE    uint32_t
  53:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portBASE_TYPE     long
  54:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  55:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     typedef portSTACK_TYPE   StackType_t;
  56:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     typedef long             BaseType_t;
  57:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     typedef unsigned long    UBaseType_t;
  58:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  59:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #if ( configUSE_16_BIT_TICKS == 1 )
  60:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         typedef uint16_t     TickType_t;
  61:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portMAX_DELAY              ( TickType_t ) 0xffff
  62:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #else
  63:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         typedef uint32_t     TickType_t;
  64:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portMAX_DELAY              ( TickType_t ) 0xffffffffUL
  65:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  66:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
  67:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * not need to be guarded with a critical section. */
  68:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portTICK_TYPE_IS_ATOMIC    1
  69:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
  70:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
  71:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  72:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Architecture specifics. */
  73:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portSTACK_GROWTH      ( -1 )
  74:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portTICK_PERIOD_MS    ( ( TickType_t ) 1000 / configTICK_RATE_HZ )
  75:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portBYTE_ALIGNMENT    8
  76:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portDONT_DISCARD      __attribute__( ( used ) )
  77:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
  78:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  79:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Scheduler utilities. */
  80:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portYIELD()                                 \
  81:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     {                                                   \
  82:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         /* Set a PendSV to request a context switch. */ \
  83:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT; \
  84:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****                                                         \
  85:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         /* Barriers are normally not required but do ensure the code is completely \
  86:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****          * within the specified behaviour for the architecture. */ \
  87:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile ( "dsb" ::: "memory" );                     \
  88:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile ( "isb" );                                  \
  89:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     }
  90:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  91:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portNVIC_INT_CTRL_REG     ( *( ( volatile uint32_t * ) 0xe000ed04 ) )
  92:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portNVIC_PENDSVSET_BIT    ( 1UL << 28UL )
  93:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portEND_SWITCHING_ISR( xSwitchRequired )    if( xSwitchRequired != pdFALSE ) portYIELD(
  94:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portYIELD_FROM_ISR( x )                     portEND_SWITCHING_ISR( x )
  95:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
  96:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  97:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Critical section management. */
  98:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     extern void vPortEnterCritical( void );
  99:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     extern void vPortExitCritical( void );
 100:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portSET_INTERRUPT_MASK_FROM_ISR()         ulPortRaiseBASEPRI()
 101:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portCLEAR_INTERRUPT_MASK_FROM_ISR( x )    vPortSetBASEPRI( x )
 102:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portDISABLE_INTERRUPTS()                  vPortRaiseBASEPRI()
 103:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portENABLE_INTERRUPTS()                   vPortSetBASEPRI( 0 )
 104:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portENTER_CRITICAL()                      vPortEnterCritical()
 105:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portEXIT_CRITICAL()                       vPortExitCritical()
 106:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 107:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 108:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 109:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Task function macros as described on the FreeRTOS.org WEB site.  These are
 110:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * not necessary for to use this port.  They are defined so the common demo files
 111:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * (which build with all the ports) will build. */
 112:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portTASK_FUNCTION_PROTO( vFunction, pvParameters )    void vFunction( void * pvParamete
 113:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portTASK_FUNCTION( vFunction, pvParameters )          void vFunction( void * pvParamete
 114:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 115:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 116:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Tickless idle/low power functionality. */
 117:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifndef portSUPPRESS_TICKS_AND_SLEEP
 118:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
 119:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime )    vPortSuppressTicksAndSleep( xE
 120:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
 121:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 122:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 123:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Architecture specific optimisations. */
 124:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
 125:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define configUSE_PORT_OPTIMISED_TASK_SELECTION    1
 126:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
 127:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 128:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
 129:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 130:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Generic helper function. */
 131:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t 
 132:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         {
 133:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             uint8_t ucReturn;
 134:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 135:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             __asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 136:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 137:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             return ucReturn;
 138:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         }
 139:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 140:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Check the configuration. */
 141:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #if ( configMAX_PRIORITIES > 32 )
 142:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             #error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIO
 143:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #endif
 144:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 145:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Store/clear the ready priorities in a bit map. */
 146:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities )    ( uxReadyPriorities )
 147:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities )     ( uxReadyPriorities )
 148:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 149:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 150:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 151:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities )    uxTopPriority = ( 3
 152:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 153:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 154:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 155:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 156:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 157:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifdef configASSERT
 158:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         void vPortValidateInterruptPriority( void );
 159:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portASSERT_IF_INTERRUPT_PRIORITY_INVALID()    vPortValidateInterruptPriority()
 160:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
 161:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 162:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* portNOP() is not required by this port. */
 163:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portNOP()
 164:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 165:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portINLINE              __inline
 166:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 167:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifndef portFORCE_INLINE
 168:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portFORCE_INLINE    inline __attribute__( ( always_inline ) )
 169:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
 170:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 171:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     portFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )
 172:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     {
 173:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         uint32_t ulCurrentInterrupt;
 174:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         BaseType_t xReturn;
 175:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 176:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         /* Obtain the number of the currently executing interrupt. */
 177:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile ( "mrs %0, ipsr" : "=r" ( ulCurrentInterrupt )::"memory" );
 178:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 179:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         if( ulCurrentInterrupt == 0 )
 180:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         {
 181:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             xReturn = pdFALSE;
 182:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         }
 183:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         else
 184:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         {
 185:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             xReturn = pdTRUE;
 186:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         }
 187:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 188:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         return xReturn;
 189:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     }
 190:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 191:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 192:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 193:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     portFORCE_INLINE static void vPortRaiseBASEPRI( void )
 194:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     {
 195:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         uint32_t ulNewBASEPRI;
 196:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile
  93              	 .loc 2 197 0
  94              	
  95 001a 4FF01403 	 mov r3,#20
  96 001e 83F31188 	 msr basepri,r3
  97 0022 BFF36F8F 	 isb 
  98 0026 BFF34F8F 	 dsb 
  99              	
 100              	
 101              	.LVL10:
 102              	 .thumb
 103              	.L5:
 104              	.LBE87:
 105              	.LBE86:
 106              	 .loc 1 1286 0 discriminator 1
 107 002a FEE7     	 b .L5
 108              	.L4:
 109              	.LBE85:
1287:../FreeRTOS/Source/stream_buffer.c ****         } /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
1288:../FreeRTOS/Source/stream_buffer.c ****     #endif
1289:../FreeRTOS/Source/stream_buffer.c **** 
1290:../FreeRTOS/Source/stream_buffer.c ****     ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 mem
 110              	 .loc 1 1290 0
 111 002c 2046     	 mov r0,r4
 112 002e 0021     	 movs r1,#0
 113 0030 2422     	 movs r2,#36
 114 0032 FFF7FEFF 	 bl memset
 115              	.LVL11:
1291:../FreeRTOS/Source/stream_buffer.c ****     pxStreamBuffer->pucBuffer = pucBuffer;
 116              	 .loc 1 1291 0
 117 0036 A561     	 str r5,[r4,#24]
1292:../FreeRTOS/Source/stream_buffer.c ****     pxStreamBuffer->xLength = xBufferSizeBytes;
 118              	 .loc 1 1292 0
 119 0038 C4F80880 	 str r8,[r4,#8]
1293:../FreeRTOS/Source/stream_buffer.c ****     pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
 120              	 .loc 1 1293 0
 121 003c E760     	 str r7,[r4,#12]
1294:../FreeRTOS/Source/stream_buffer.c ****     pxStreamBuffer->ucFlags = ucFlags;
 122              	 .loc 1 1294 0
 123 003e 9DF81830 	 ldrb r3,[sp,#24]
 124 0042 2377     	 strb r3,[r4,#28]
 125 0044 BDE8F081 	 pop {r4,r5,r6,r7,r8,pc}
 126              	 .cfi_endproc
 127              	.LFE25:
 129              	 .section .text.prvWriteBytesToBuffer,"ax",%progbits
 130              	 .align 2
 131              	 .thumb
 132              	 .thumb_func
 134              	prvWriteBytesToBuffer:
 135              	.LFB22:
1146:../FreeRTOS/Source/stream_buffer.c ****     size_t xNextHead, xFirstLength;
 136              	 .loc 1 1146 0
 137              	 .cfi_startproc
 138              	 
 139              	 
 140              	.LVL12:
1149:../FreeRTOS/Source/stream_buffer.c **** 
 141              	 .loc 1 1149 0
 142 0000 42B9     	 cbnz r2,.L8
 143              	.LBB88:
 144              	.LBB89:
 145              	 .loc 2 197 0
 146              	
 147 0002 4FF01403 	 mov r3,#20
 148 0006 83F31188 	 msr basepri,r3
 149 000a BFF36F8F 	 isb 
 150 000e BFF34F8F 	 dsb 
 151              	
 152              	
 153              	.LVL13:
 154              	 .thumb
 155              	.L9:
 156              	.LBE89:
 157              	.LBE88:
1149:../FreeRTOS/Source/stream_buffer.c **** 
 158              	 .loc 1 1149 0 discriminator 1
 159 0012 FEE7     	 b .L9
 160              	.L8:
1146:../FreeRTOS/Source/stream_buffer.c ****     size_t xNextHead, xFirstLength;
 161              	 .loc 1 1146 0
 162 0014 2DE9F041 	 push {r4,r5,r6,r7,r8,lr}
 163              	.LCFI1:
 164              	 .cfi_def_cfa_offset 24
 165              	 .cfi_offset 4,-24
 166              	 .cfi_offset 5,-20
 167              	 .cfi_offset 6,-16
 168              	 .cfi_offset 7,-12
 169              	 .cfi_offset 8,-8
 170              	 .cfi_offset 14,-4
 171 0018 1746     	 mov r7,r2
1151:../FreeRTOS/Source/stream_buffer.c **** 
 172              	 .loc 1 1151 0
 173 001a 4668     	 ldr r6,[r0,#4]
 174              	.LVL14:
1156:../FreeRTOS/Source/stream_buffer.c **** 
 175              	 .loc 1 1156 0
 176 001c 8368     	 ldr r3,[r0,#8]
 177 001e C6EB0308 	 rsb r8,r6,r3
 178 0022 9045     	 cmp r8,r2
 179 0024 28BF     	 it cs
 180 0026 9046     	 movcs r8,r2
 181              	.LVL15:
1159:../FreeRTOS/Source/stream_buffer.c ****     ( void ) memcpy( ( void * ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) p
 182              	 .loc 1 1159 0
 183 0028 08EB0602 	 add r2,r8,r6
 184              	.LVL16:
 185 002c 9342     	 cmp r3,r2
 186 002e 08D2     	 bcs .L10
 187              	.LBB90:
 188              	.LBB91:
 189              	 .loc 2 197 0
 190              	
 191 0030 4FF01403 	 mov r3,#20
 192 0034 83F31188 	 msr basepri,r3
 193 0038 BFF36F8F 	 isb 
 194 003c BFF34F8F 	 dsb 
 195              	
 196              	
 197              	.LVL17:
 198              	 .thumb
 199              	.L11:
 200              	.LBE91:
 201              	.LBE90:
1159:../FreeRTOS/Source/stream_buffer.c ****     ( void ) memcpy( ( void * ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) p
 202              	 .loc 1 1159 0 discriminator 2
 203 0040 FEE7     	 b .L11
 204              	.L10:
 205 0042 0D46     	 mov r5,r1
 206 0044 0446     	 mov r4,r0
1160:../FreeRTOS/Source/stream_buffer.c **** 
 207              	 .loc 1 1160 0
 208 0046 8069     	 ldr r0,[r0,#24]
 209              	.LVL18:
 210 0048 3044     	 add r0,r0,r6
 211 004a 4246     	 mov r2,r8
 212 004c FFF7FEFF 	 bl memcpy
 213              	.LVL19:
1164:../FreeRTOS/Source/stream_buffer.c ****     {
 214              	 .loc 1 1164 0
 215 0050 4745     	 cmp r7,r8
 216 0052 12D9     	 bls .L12
1167:../FreeRTOS/Source/stream_buffer.c ****         ( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstL
 217              	 .loc 1 1167 0
 218 0054 C8EB0702 	 rsb r2,r8,r7
 219 0058 A368     	 ldr r3,[r4,#8]
 220 005a 9A42     	 cmp r2,r3
 221 005c 08D9     	 bls .L13
 222              	.LBB92:
 223              	.LBB93:
 224              	 .loc 2 197 0
 225              	
 226 005e 4FF01403 	 mov r3,#20
 227 0062 83F31188 	 msr basepri,r3
 228 0066 BFF36F8F 	 isb 
 229 006a BFF34F8F 	 dsb 
 230              	
 231              	
 232              	.LVL20:
 233              	 .thumb
 234              	.L14:
 235              	.LBE93:
 236              	.LBE92:
1167:../FreeRTOS/Source/stream_buffer.c ****         ( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstL
 237              	 .loc 1 1167 0 discriminator 3
 238 006e FEE7     	 b .L14
 239              	.L13:
1168:../FreeRTOS/Source/stream_buffer.c ****     }
 240              	 .loc 1 1168 0
 241 0070 A069     	 ldr r0,[r4,#24]
 242 0072 05EB0801 	 add r1,r5,r8
 243 0076 FFF7FEFF 	 bl memcpy
 244              	.LVL21:
 245              	.L12:
1175:../FreeRTOS/Source/stream_buffer.c **** 
 246              	 .loc 1 1175 0
 247 007a BB19     	 adds r3,r7,r6
 248              	.LVL22:
1177:../FreeRTOS/Source/stream_buffer.c ****     {
 249              	 .loc 1 1177 0
 250 007c A268     	 ldr r2,[r4,#8]
 251 007e 9342     	 cmp r3,r2
1179:../FreeRTOS/Source/stream_buffer.c ****     }
 252              	 .loc 1 1179 0
 253 0080 28BF     	 it cs
 254 0082 9B1A     	 subcs r3,r3,r2
 255              	.LVL23:
1186:../FreeRTOS/Source/stream_buffer.c **** 
 256              	 .loc 1 1186 0
 257 0084 6360     	 str r3,[r4,#4]
1189:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
 258              	 .loc 1 1189 0
 259 0086 3846     	 mov r0,r7
 260 0088 BDE8F081 	 pop {r4,r5,r6,r7,r8,pc}
 261              	 .cfi_endproc
 262              	.LFE22:
 264              	 .section .text.prvWriteMessageToBuffer,"ax",%progbits
 265              	 .align 2
 266              	 .thumb
 267              	 .thumb_func
 269              	prvWriteMessageToBuffer:
 270              	.LFB13:
 717:../FreeRTOS/Source/stream_buffer.c ****     BaseType_t xShouldWrite;
 271              	 .loc 1 717 0
 272              	 .cfi_startproc
 273              	 
 274              	 
 275              	.LVL24:
 276 0000 30B5     	 push {r4,r5,lr}
 277              	.LCFI2:
 278              	 .cfi_def_cfa_offset 12
 279              	 .cfi_offset 4,-12
 280              	 .cfi_offset 5,-8
 281              	 .cfi_offset 14,-4
 282 0002 83B0     	 sub sp,sp,#12
 283              	.LCFI3:
 284              	 .cfi_def_cfa_offset 24
 285 0004 0192     	 str r2,[sp,#4]
 721:../FreeRTOS/Source/stream_buffer.c ****     {
 286              	 .loc 1 721 0
 287 0006 A3B1     	 cbz r3,.L21
 288 0008 1A46     	 mov r2,r3
 289              	.LVL25:
 290 000a 0D46     	 mov r5,r1
 291 000c 0446     	 mov r4,r0
 727:../FreeRTOS/Source/stream_buffer.c ****     {
 292              	 .loc 1 727 0
 293 000e 037F     	 ldrb r3,[r0,#28]
 294              	.LVL26:
 295 0010 13F0010F 	 tst r3,#1
 296 0014 05D1     	 bne .L19
 297              	.LVL27:
 733:../FreeRTOS/Source/stream_buffer.c ****     }
 298              	 .loc 1 733 0
 299 0016 019B     	 ldr r3,[sp,#4]
 300 0018 9A42     	 cmp r2,r3
 301 001a 28BF     	 it cs
 302 001c 1A46     	 movcs r2,r3
 303              	.LVL28:
 304 001e 0192     	 str r2,[sp,#4]
 305              	.LVL29:
 306 0020 0BE0     	 b .L20
 307              	.LVL30:
 308              	.L19:
 735:../FreeRTOS/Source/stream_buffer.c ****     {
 309              	 .loc 1 735 0
 310 0022 069B     	 ldr r3,[sp,#24]
 311 0024 9A42     	 cmp r2,r3
 312 0026 06D3     	 bcc .L22
 313              	.LVL31:
 742:../FreeRTOS/Source/stream_buffer.c ****     }
 314              	 .loc 1 742 0
 315 0028 01A9     	 add r1,sp,#4
 316              	.LVL32:
 317 002a 0422     	 movs r2,#4
 318              	.LVL33:
 319 002c FFF7FEFF 	 bl prvWriteBytesToBuffer
 320              	.LVL34:
 321 0030 03E0     	 b .L20
 322              	.LVL35:
 323              	.L21:
 757:../FreeRTOS/Source/stream_buffer.c ****     }
 324              	 .loc 1 757 0
 325 0032 0020     	 movs r0,#0
 326              	.LVL36:
 327 0034 06E0     	 b .L23
 328              	.LVL37:
 329              	.L22:
 330 0036 0020     	 movs r0,#0
 331              	.LVL38:
 332 0038 04E0     	 b .L23
 333              	.LVL39:
 334              	.L20:
 753:../FreeRTOS/Source/stream_buffer.c ****     }
 335              	 .loc 1 753 0
 336 003a 2046     	 mov r0,r4
 337 003c 2946     	 mov r1,r5
 338 003e 019A     	 ldr r2,[sp,#4]
 339 0040 FFF7FEFF 	 bl prvWriteBytesToBuffer
 340              	.LVL40:
 341              	.L23:
 761:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
 342              	 .loc 1 761 0
 343 0044 03B0     	 add sp,sp,#12
 344              	.LCFI4:
 345              	 .cfi_def_cfa_offset 12
 346              	 
 347 0046 30BD     	 pop {r4,r5,pc}
 348              	 .cfi_endproc
 349              	.LFE13:
 351              	 .section .text.prvReadBytesFromBuffer,"ax",%progbits
 352              	 .align 2
 353              	 .thumb
 354              	 .thumb_func
 356              	prvReadBytesFromBuffer:
 357              	.LFB23:
1196:../FreeRTOS/Source/stream_buffer.c ****     size_t xCount, xFirstLength, xNextTail;
 358              	 .loc 1 1196 0
 359              	 .cfi_startproc
 360              	 
 361              	 
 362              	.LVL41:
 363 0000 2DE9F843 	 push {r3,r4,r5,r6,r7,r8,r9,lr}
 364              	.LCFI5:
 365              	 .cfi_def_cfa_offset 32
 366              	 .cfi_offset 3,-32
 367              	 .cfi_offset 4,-28
 368              	 .cfi_offset 5,-24
 369              	 .cfi_offset 6,-20
 370              	 .cfi_offset 7,-16
 371              	 .cfi_offset 8,-12
 372              	 .cfi_offset 9,-8
 373              	 .cfi_offset 14,-4
1200:../FreeRTOS/Source/stream_buffer.c **** 
 374              	 .loc 1 1200 0
 375 0004 9046     	 mov r8,r2
 376 0006 9A42     	 cmp r2,r3
 377 0008 28BF     	 it cs
 378 000a 9846     	 movcs r8,r3
 379              	.LVL42:
1202:../FreeRTOS/Source/stream_buffer.c ****     {
 380              	 .loc 1 1202 0
 381 000c B8F1000F 	 cmp r8,#0
 382 0010 3ED0     	 beq .L26
1204:../FreeRTOS/Source/stream_buffer.c **** 
 383              	 .loc 1 1204 0
 384 0012 0468     	 ldr r4,[r0]
 385              	.LVL43:
1209:../FreeRTOS/Source/stream_buffer.c **** 
 386              	 .loc 1 1209 0
 387 0014 8368     	 ldr r3,[r0,#8]
 388              	.LVL44:
 389 0016 1F1B     	 subs r7,r3,r4
 390 0018 4745     	 cmp r7,r8
 391 001a 28BF     	 it cs
 392 001c 4746     	 movcs r7,r8
 393              	.LVL45:
1213:../FreeRTOS/Source/stream_buffer.c ****         configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
 394              	 .loc 1 1213 0
 395 001e BA42     	 cmp r2,r7
 396 0020 08D2     	 bcs .L27
 397              	.LBB94:
 398              	.LBB95:
 399              	 .loc 2 197 0
 400              	
 401 0022 4FF01403 	 mov r3,#20
 402 0026 83F31188 	 msr basepri,r3
 403 002a BFF36F8F 	 isb 
 404 002e BFF34F8F 	 dsb 
 405              	
 406              	
 407              	.LVL46:
 408              	 .thumb
 409              	.L28:
 410              	.LBE95:
 411              	.LBE94:
1213:../FreeRTOS/Source/stream_buffer.c ****         configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
 412              	 .loc 1 1213 0 discriminator 1
 413 0032 FEE7     	 b .L28
 414              	.L27:
1214:../FreeRTOS/Source/stream_buffer.c ****         ( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTa
 415              	 .loc 1 1214 0
 416 0034 3D19     	 adds r5,r7,r4
 417 0036 AB42     	 cmp r3,r5
 418 0038 08D2     	 bcs .L29
 419              	.LBB96:
 420              	.LBB97:
 421              	 .loc 2 197 0
 422              	
 423 003a 4FF01403 	 mov r3,#20
 424 003e 83F31188 	 msr basepri,r3
 425 0042 BFF36F8F 	 isb 
 426 0046 BFF34F8F 	 dsb 
 427              	
 428              	
 429              	.LVL47:
 430              	 .thumb
 431              	.L30:
 432              	.LBE97:
 433              	.LBE96:
1214:../FreeRTOS/Source/stream_buffer.c ****         ( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTa
 434              	 .loc 1 1214 0 discriminator 2
 435 004a FEE7     	 b .L30
 436              	.L29:
 437 004c 9146     	 mov r9,r2
 438 004e 0E46     	 mov r6,r1
 439 0050 0546     	 mov r5,r0
1215:../FreeRTOS/Source/stream_buffer.c **** 
 440              	 .loc 1 1215 0
 441 0052 8169     	 ldr r1,[r0,#24]
 442              	.LVL48:
 443 0054 3046     	 mov r0,r6
 444              	.LVL49:
 445 0056 2144     	 add r1,r1,r4
 446 0058 3A46     	 mov r2,r7
 447              	.LVL50:
 448 005a FFF7FEFF 	 bl memcpy
 449              	.LVL51:
1219:../FreeRTOS/Source/stream_buffer.c ****         {
 450              	 .loc 1 1219 0
 451 005e B845     	 cmp r8,r7
 452 0060 10D9     	 bls .L31
1222:../FreeRTOS/Source/stream_buffer.c ****             ( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->
 453              	 .loc 1 1222 0
 454 0062 C145     	 cmp r9,r8
 455 0064 08D2     	 bcs .L32
 456              	.LBB98:
 457              	.LBB99:
 458              	 .loc 2 197 0
 459              	
 460 0066 4FF01403 	 mov r3,#20
 461 006a 83F31188 	 msr basepri,r3
 462 006e BFF36F8F 	 isb 
 463 0072 BFF34F8F 	 dsb 
 464              	
 465              	
 466              	.LVL52:
 467              	 .thumb
 468              	.L33:
 469              	.LBE99:
 470              	.LBE98:
1222:../FreeRTOS/Source/stream_buffer.c ****             ( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->
 471              	 .loc 1 1222 0 discriminator 3
 472 0076 FEE7     	 b .L33
 473              	.L32:
1223:../FreeRTOS/Source/stream_buffer.c ****         }
 474              	 .loc 1 1223 0
 475 0078 F019     	 adds r0,r6,r7
 476 007a A969     	 ldr r1,[r5,#24]
 477 007c C7EB0802 	 rsb r2,r7,r8
 478 0080 FFF7FEFF 	 bl memcpy
 479              	.LVL53:
 480              	.L31:
1232:../FreeRTOS/Source/stream_buffer.c **** 
 481              	 .loc 1 1232 0
 482 0084 4444     	 add r4,r4,r8
 483              	.LVL54:
1234:../FreeRTOS/Source/stream_buffer.c ****         {
 484              	 .loc 1 1234 0
 485 0086 AB68     	 ldr r3,[r5,#8]
 486 0088 9C42     	 cmp r4,r3
1236:../FreeRTOS/Source/stream_buffer.c ****         }
 487              	 .loc 1 1236 0
 488 008a 28BF     	 it cs
 489 008c E41A     	 subcs r4,r4,r3
 490              	.LVL55:
1239:../FreeRTOS/Source/stream_buffer.c ****     }
 491              	 .loc 1 1239 0
 492 008e 2C60     	 str r4,[r5]
 493              	.LVL56:
 494              	.L26:
1247:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
 495              	 .loc 1 1247 0
 496 0090 4046     	 mov r0,r8
 497 0092 BDE8F883 	 pop {r3,r4,r5,r6,r7,r8,r9,pc}
 498              	 .cfi_endproc
 499              	.LFE23:
 501 0096 00BF     	 .section .text.xStreamBufferGenericCreate,"ax",%progbits
 502              	 .align 2
 503              	 .global xStreamBufferGenericCreate
 504              	 .thumb
 505              	 .thumb_func
 507              	xStreamBufferGenericCreate:
 508              	.LFB5:
 223:../FreeRTOS/Source/stream_buffer.c ****         uint8_t * pucAllocatedMemory;
 509              	 .loc 1 223 0
 510              	 .cfi_startproc
 511              	 
 512              	 
 513              	.LVL57:
 514 0000 F0B5     	 push {r4,r5,r6,r7,lr}
 515              	.LCFI6:
 516              	 .cfi_def_cfa_offset 20
 517              	 .cfi_offset 4,-20
 518              	 .cfi_offset 5,-16
 519              	 .cfi_offset 6,-12
 520              	 .cfi_offset 7,-8
 521              	 .cfi_offset 14,-4
 522 0002 83B0     	 sub sp,sp,#12
 523              	.LCFI7:
 524              	 .cfi_def_cfa_offset 32
 525 0004 0C46     	 mov r4,r1
 231:../FreeRTOS/Source/stream_buffer.c ****         {
 526              	 .loc 1 231 0
 527 0006 012A     	 cmp r2,#1
 528 0008 0AD1     	 bne .L37
 529              	.LVL58:
 235:../FreeRTOS/Source/stream_buffer.c ****         }
 530              	 .loc 1 235 0
 531 000a 0428     	 cmp r0,#4
 532 000c 12D8     	 bhi .L45
 533              	.LBB100:
 534              	.LBB101:
 535              	 .loc 2 197 0
 536              	
 537 000e 4FF01403 	 mov r3,#20
 538 0012 83F31188 	 msr basepri,r3
 539 0016 BFF36F8F 	 isb 
 540 001a BFF34F8F 	 dsb 
 541              	
 542              	
 543              	.LVL59:
 544              	 .thumb
 545              	.L39:
 546              	.LBE101:
 547              	.LBE100:
 235:../FreeRTOS/Source/stream_buffer.c ****         }
 548              	 .loc 1 235 0 discriminator 1
 549 001e FEE7     	 b .L39
 550              	.LVL60:
 551              	.L37:
 241:../FreeRTOS/Source/stream_buffer.c ****         }
 552              	 .loc 1 241 0
 553 0020 50B9     	 cbnz r0,.L46
 554              	.LBB102:
 555              	.LBB103:
 556              	 .loc 2 197 0
 557              	
 558 0022 4FF01403 	 mov r3,#20
 559 0026 83F31188 	 msr basepri,r3
 560 002a BFF36F8F 	 isb 
 561 002e BFF34F8F 	 dsb 
 562              	
 563              	
 564              	.LVL61:
 565              	 .thumb
 566              	.L40:
 567              	.LBE103:
 568              	.LBE102:
 241:../FreeRTOS/Source/stream_buffer.c ****         }
 569              	 .loc 1 241 0 discriminator 2
 570 0032 FEE7     	 b .L40
 571              	.LVL62:
 572              	.L45:
 234:../FreeRTOS/Source/stream_buffer.c ****             configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
 573              	 .loc 1 234 0
 574 0034 0126     	 movs r6,#1
 575 0036 00E0     	 b .L38
 576              	.LVL63:
 577              	.L46:
 240:../FreeRTOS/Source/stream_buffer.c ****             configASSERT( xBufferSizeBytes > 0 );
 578              	 .loc 1 240 0
 579 0038 0026     	 movs r6,#0
 580              	.LVL64:
 581              	.L38:
 244:../FreeRTOS/Source/stream_buffer.c **** 
 582              	 .loc 1 244 0
 583 003a A042     	 cmp r0,r4
 584 003c 08D2     	 bcs .L41
 585              	.LBB104:
 586              	.LBB105:
 587              	 .loc 2 197 0
 588              	
 589 003e 4FF01403 	 mov r3,#20
 590 0042 83F31188 	 msr basepri,r3
 591 0046 BFF36F8F 	 isb 
 592 004a BFF34F8F 	 dsb 
 593              	
 594              	
 595              	.LVL65:
 596              	 .thumb
 597              	.L42:
 598              	.LBE105:
 599              	.LBE104:
 244:../FreeRTOS/Source/stream_buffer.c **** 
 600              	 .loc 1 244 0 discriminator 3
 601 004e FEE7     	 b .L42
 602              	.L41:
 250:../FreeRTOS/Source/stream_buffer.c ****         }
 603              	 .loc 1 250 0
 604 0050 002C     	 cmp r4,#0
 605 0052 08BF     	 it eq
 606 0054 0124     	 moveq r4,#1
 607              	.LVL66:
 261:../FreeRTOS/Source/stream_buffer.c ****         pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t 
 608              	 .loc 1 261 0
 609 0056 471C     	 adds r7,r0,#1
 610              	.LVL67:
 262:../FreeRTOS/Source/stream_buffer.c **** 
 611              	 .loc 1 262 0
 612 0058 2530     	 adds r0,r0,#37
 613 005a FFF7FEFF 	 bl pvPortMalloc
 614              	.LVL68:
 264:../FreeRTOS/Source/stream_buffer.c ****         {
 615              	 .loc 1 264 0
 616 005e 0546     	 mov r5,r0
 617 0060 30B1     	 cbz r0,.L44
 266:../FreeRTOS/Source/stream_buffer.c ****                                           pucAllocatedMemory + sizeof( StreamBuffer_t ), /* Storage
 618              	 .loc 1 266 0
 619 0062 0096     	 str r6,[sp]
 620 0064 05F12401 	 add r1,r5,#36
 621 0068 3A46     	 mov r2,r7
 622 006a 2346     	 mov r3,r4
 623 006c FFF7FEFF 	 bl prvInitialiseNewStreamBuffer
 624              	.LVL69:
 625              	.L44:
 280:../FreeRTOS/Source/stream_buffer.c **** 
 626              	 .loc 1 280 0
 627 0070 2846     	 mov r0,r5
 628 0072 03B0     	 add sp,sp,#12
 629              	.LCFI8:
 630              	 .cfi_def_cfa_offset 20
 631              	 
 632 0074 F0BD     	 pop {r4,r5,r6,r7,pc}
 633              	 .cfi_endproc
 634              	.LFE5:
 636 0076 00BF     	 .section .text.vStreamBufferDelete,"ax",%progbits
 637              	 .align 2
 638              	 .global vStreamBufferDelete
 639              	 .thumb
 640              	 .thumb_func
 642              	vStreamBufferDelete:
 643              	.LFB6:
 364:../FreeRTOS/Source/stream_buffer.c ****     StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
 644              	 .loc 1 364 0
 645              	 .cfi_startproc
 646              	 
 647              	 
 648              	.LVL70:
 649 0000 08B5     	 push {r3,lr}
 650              	.LCFI9:
 651              	 .cfi_def_cfa_offset 8
 652              	 .cfi_offset 3,-8
 653              	 .cfi_offset 14,-4
 654              	.LVL71:
 367:../FreeRTOS/Source/stream_buffer.c **** 
 655              	 .loc 1 367 0
 656 0002 40B9     	 cbnz r0,.L49
 657              	.LBB106:
 658              	.LBB107:
 659              	 .loc 2 197 0
 660              	
 661 0004 4FF01403 	 mov r3,#20
 662 0008 83F31188 	 msr basepri,r3
 663 000c BFF36F8F 	 isb 
 664 0010 BFF34F8F 	 dsb 
 665              	
 666              	
 667              	.LVL72:
 668              	 .thumb
 669              	.L50:
 670              	.LBE107:
 671              	.LBE106:
 367:../FreeRTOS/Source/stream_buffer.c **** 
 672              	 .loc 1 367 0 discriminator 1
 673 0014 FEE7     	 b .L50
 674              	.L49:
 371:../FreeRTOS/Source/stream_buffer.c ****     {
 675              	 .loc 1 371 0
 676 0016 037F     	 ldrb r3,[r0,#28]
 677 0018 13F0020F 	 tst r3,#2
 678 001c 02D1     	 bne .L51
 377:../FreeRTOS/Source/stream_buffer.c ****             }
 679              	 .loc 1 377 0
 680 001e FFF7FEFF 	 bl vPortFree
 681              	.LVL73:
 682 0022 08BD     	 pop {r3,pc}
 683              	.LVL74:
 684              	.L51:
 391:../FreeRTOS/Source/stream_buffer.c ****     }
 685              	 .loc 1 391 0
 686 0024 0021     	 movs r1,#0
 687 0026 2422     	 movs r2,#36
 688 0028 FFF7FEFF 	 bl memset
 689              	.LVL75:
 690 002c 08BD     	 pop {r3,pc}
 691              	 .cfi_endproc
 692              	.LFE6:
 694 002e 00BF     	 .section .text.xStreamBufferReset,"ax",%progbits
 695              	 .align 2
 696              	 .global xStreamBufferReset
 697              	 .thumb
 698              	 .thumb_func
 700              	xStreamBufferReset:
 701              	.LFB7:
 397:../FreeRTOS/Source/stream_buffer.c ****     StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 702              	 .loc 1 397 0
 703              	 .cfi_startproc
 704              	 
 705              	 
 706              	.LVL76:
 405:../FreeRTOS/Source/stream_buffer.c **** 
 707              	 .loc 1 405 0
 708 0000 40B9     	 cbnz r0,.L55
 709              	.LBB108:
 710              	.LBB109:
 711              	 .loc 2 197 0
 712              	
 713 0002 4FF01403 	 mov r3,#20
 714 0006 83F31188 	 msr basepri,r3
 715 000a BFF36F8F 	 isb 
 716 000e BFF34F8F 	 dsb 
 717              	
 718              	
 719              	.LVL77:
 720              	 .thumb
 721              	.L56:
 722              	.LBE109:
 723              	.LBE108:
 405:../FreeRTOS/Source/stream_buffer.c **** 
 724              	 .loc 1 405 0 discriminator 1
 725 0012 FEE7     	 b .L56
 726              	.L55:
 397:../FreeRTOS/Source/stream_buffer.c ****     StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 727              	 .loc 1 397 0
 728 0014 30B5     	 push {r4,r5,lr}
 729              	.LCFI10:
 730              	 .cfi_def_cfa_offset 12
 731              	 .cfi_offset 4,-12
 732              	 .cfi_offset 5,-8
 733              	 .cfi_offset 14,-4
 734 0016 83B0     	 sub sp,sp,#12
 735              	.LCFI11:
 736              	 .cfi_def_cfa_offset 24
 737 0018 0446     	 mov r4,r0
 411:../FreeRTOS/Source/stream_buffer.c ****         }
 738              	 .loc 1 411 0
 739 001a 056A     	 ldr r5,[r0,#32]
 740              	.LVL78:
 416:../FreeRTOS/Source/stream_buffer.c ****     {
 741              	 .loc 1 416 0
 742 001c FFF7FEFF 	 bl vPortEnterCritical
 743              	.LVL79:
 418:../FreeRTOS/Source/stream_buffer.c ****         {
 744              	 .loc 1 418 0
 745 0020 2369     	 ldr r3,[r4,#16]
 746 0022 63B9     	 cbnz r3,.L58
 420:../FreeRTOS/Source/stream_buffer.c ****             {
 747              	 .loc 1 420 0
 748 0024 6369     	 ldr r3,[r4,#20]
 749 0026 63B9     	 cbnz r3,.L59
 422:../FreeRTOS/Source/stream_buffer.c ****                                               pxStreamBuffer->pucBuffer,
 750              	 .loc 1 422 0
 751 0028 A169     	 ldr r1,[r4,#24]
 752 002a A268     	 ldr r2,[r4,#8]
 753 002c E368     	 ldr r3,[r4,#12]
 754 002e 207F     	 ldrb r0,[r4,#28]
 755 0030 0090     	 str r0,[sp]
 756 0032 2046     	 mov r0,r4
 757 0034 FFF7FEFF 	 bl prvInitialiseNewStreamBuffer
 758              	.LVL80:
 431:../FreeRTOS/Source/stream_buffer.c ****                     }
 759              	 .loc 1 431 0
 760 0038 2562     	 str r5,[r4,#32]
 427:../FreeRTOS/Source/stream_buffer.c **** 
 761              	 .loc 1 427 0
 762 003a 0124     	 movs r4,#1
 763              	.LVL81:
 764 003c 02E0     	 b .L57
 765              	.LVL82:
 766              	.L58:
 399:../FreeRTOS/Source/stream_buffer.c **** 
 767              	 .loc 1 399 0
 768 003e 0024     	 movs r4,#0
 769              	.LVL83:
 770 0040 00E0     	 b .L57
 771              	.LVL84:
 772              	.L59:
 773 0042 0024     	 movs r4,#0
 774              	.LVL85:
 775              	.L57:
 439:../FreeRTOS/Source/stream_buffer.c **** 
 776              	 .loc 1 439 0
 777 0044 FFF7FEFF 	 bl vPortExitCritical
 778              	.LVL86:
 442:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
 779              	 .loc 1 442 0
 780 0048 2046     	 mov r0,r4
 781 004a 03B0     	 add sp,sp,#12
 782              	.LCFI12:
 783              	 .cfi_def_cfa_offset 12
 784              	 
 785 004c 30BD     	 pop {r4,r5,pc}
 786              	 .cfi_endproc
 787              	.LFE7:
 789 004e 00BF     	 .section .text.xStreamBufferSetTriggerLevel,"ax",%progbits
 790              	 .align 2
 791              	 .global xStreamBufferSetTriggerLevel
 792              	 .thumb
 793              	 .thumb_func
 795              	xStreamBufferSetTriggerLevel:
 796              	.LFB8:
 447:../FreeRTOS/Source/stream_buffer.c ****     StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 797              	 .loc 1 447 0
 798              	 .cfi_startproc
 799              	 
 800              	 
 801              	 
 802              	.LVL87:
 451:../FreeRTOS/Source/stream_buffer.c **** 
 803              	 .loc 1 451 0
 804 0000 40B9     	 cbnz r0,.L62
 805              	.LBB110:
 806              	.LBB111:
 807              	 .loc 2 197 0
 808              	
 809 0002 4FF01403 	 mov r3,#20
 810 0006 83F31188 	 msr basepri,r3
 811 000a BFF36F8F 	 isb 
 812 000e BFF34F8F 	 dsb 
 813              	
 814              	
 815              	.LVL88:
 816              	 .thumb
 817              	.L63:
 818              	.LBE111:
 819              	.LBE110:
 451:../FreeRTOS/Source/stream_buffer.c **** 
 820              	 .loc 1 451 0 discriminator 1
 821 0012 FEE7     	 b .L63
 822              	.L62:
 456:../FreeRTOS/Source/stream_buffer.c ****     }
 823              	 .loc 1 456 0
 824 0014 0029     	 cmp r1,#0
 825 0016 08BF     	 it eq
 826 0018 0121     	 moveq r1,#1
 827              	.LVL89:
 461:../FreeRTOS/Source/stream_buffer.c ****     {
 828              	 .loc 1 461 0
 829 001a 8268     	 ldr r2,[r0,#8]
 830 001c 9142     	 cmp r1,r2
 463:../FreeRTOS/Source/stream_buffer.c ****         xReturn = pdPASS;
 831              	 .loc 1 463 0
 832 001e 9ABF     	 itte ls
 833 0020 C160     	 strls r1,[r0,#12]
 834              	.LVL90:
 464:../FreeRTOS/Source/stream_buffer.c ****     }
 835              	 .loc 1 464 0
 836 0022 0120     	 movls r0,#1
 837              	.LVL91:
 468:../FreeRTOS/Source/stream_buffer.c ****     }
 838              	 .loc 1 468 0
 839 0024 0020     	 movhi r0,#0
 840              	.LVL92:
 472:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
 841              	 .loc 1 472 0
 842 0026 7047     	 bx lr
 843              	 .cfi_endproc
 844              	.LFE8:
 846              	 .section .text.xStreamBufferSpacesAvailable,"ax",%progbits
 847              	 .align 2
 848              	 .global xStreamBufferSpacesAvailable
 849              	 .thumb
 850              	 .thumb_func
 852              	xStreamBufferSpacesAvailable:
 853              	.LFB9:
 476:../FreeRTOS/Source/stream_buffer.c ****     const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 854              	 .loc 1 476 0
 855              	 .cfi_startproc
 856              	 
 857              	 
 858              	 
 859              	.LVL93:
 480:../FreeRTOS/Source/stream_buffer.c **** 
 860              	 .loc 1 480 0
 861 0000 40B9     	 cbnz r0,.L68
 862              	.LBB112:
 863              	.LBB113:
 864              	 .loc 2 197 0
 865              	
 866 0002 4FF01403 	 mov r3,#20
 867 0006 83F31188 	 msr basepri,r3
 868 000a BFF36F8F 	 isb 
 869 000e BFF34F8F 	 dsb 
 870              	
 871              	
 872              	.LVL94:
 873              	 .thumb
 874              	.L69:
 875              	.LBE113:
 876              	.LBE112:
 480:../FreeRTOS/Source/stream_buffer.c **** 
 877              	 .loc 1 480 0 discriminator 1
 878 0012 FEE7     	 b .L69
 879              	.L68:
 482:../FreeRTOS/Source/stream_buffer.c ****     xSpace -= pxStreamBuffer->xHead;
 880              	 .loc 1 482 0
 881 0014 8268     	 ldr r2,[r0,#8]
 882 0016 0368     	 ldr r3,[r0]
 883              	.LVL95:
 483:../FreeRTOS/Source/stream_buffer.c ****     xSpace -= ( size_t ) 1;
 884              	 .loc 1 483 0
 885 0018 4068     	 ldr r0,[r0,#4]
 886              	.LVL96:
 482:../FreeRTOS/Source/stream_buffer.c ****     xSpace -= pxStreamBuffer->xHead;
 887              	 .loc 1 482 0
 888 001a 1344     	 add r3,r3,r2
 889              	.LVL97:
 890 001c 013B     	 subs r3,r3,#1
 891              	.LVL98:
 484:../FreeRTOS/Source/stream_buffer.c **** 
 892              	 .loc 1 484 0
 893 001e 181A     	 subs r0,r3,r0
 894              	.LVL99:
 486:../FreeRTOS/Source/stream_buffer.c ****     {
 895              	 .loc 1 486 0
 896 0020 8242     	 cmp r2,r0
 488:../FreeRTOS/Source/stream_buffer.c ****     }
 897              	 .loc 1 488 0
 898 0022 98BF     	 it ls
 899 0024 801A     	 subls r0,r0,r2
 900              	.LVL100:
 496:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
 901              	 .loc 1 496 0
 902 0026 7047     	 bx lr
 903              	 .cfi_endproc
 904              	.LFE9:
 906              	 .section .text.xStreamBufferBytesAvailable,"ax",%progbits
 907              	 .align 2
 908              	 .global xStreamBufferBytesAvailable
 909              	 .thumb
 910              	 .thumb_func
 912              	xStreamBufferBytesAvailable:
 913              	.LFB10:
 500:../FreeRTOS/Source/stream_buffer.c ****     const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 914              	 .loc 1 500 0
 915              	 .cfi_startproc
 916              	 
 917              	 
 918              	.LVL101:
 919 0000 08B5     	 push {r3,lr}
 920              	.LCFI13:
 921              	 .cfi_def_cfa_offset 8
 922              	 .cfi_offset 3,-8
 923              	 .cfi_offset 14,-4
 924              	.LVL102:
 504:../FreeRTOS/Source/stream_buffer.c **** 
 925              	 .loc 1 504 0
 926 0002 40B9     	 cbnz r0,.L72
 927              	.LBB114:
 928              	.LBB115:
 929              	 .loc 2 197 0
 930              	
 931 0004 4FF01403 	 mov r3,#20
 932 0008 83F31188 	 msr basepri,r3
 933 000c BFF36F8F 	 isb 
 934 0010 BFF34F8F 	 dsb 
 935              	
 936              	
 937              	.LVL103:
 938              	 .thumb
 939              	.L73:
 940              	.LBE115:
 941              	.LBE114:
 504:../FreeRTOS/Source/stream_buffer.c **** 
 942              	 .loc 1 504 0 discriminator 1
 943 0014 FEE7     	 b .L73
 944              	.L72:
 506:../FreeRTOS/Source/stream_buffer.c ****     return xReturn;
 945              	 .loc 1 506 0
 946 0016 FFF7FEFF 	 bl prvBytesInBuffer
 947              	.LVL104:
 508:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
 948              	 .loc 1 508 0
 949 001a 08BD     	 pop {r3,pc}
 950              	 .cfi_endproc
 951              	.LFE10:
 953              	 .section .text.xStreamBufferSend,"ax",%progbits
 954              	 .align 2
 955              	 .global xStreamBufferSend
 956              	 .thumb
 957              	 .thumb_func
 959              	xStreamBufferSend:
 960              	.LFB11:
 515:../FreeRTOS/Source/stream_buffer.c ****     StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 961              	 .loc 1 515 0
 962              	 .cfi_startproc
 963              	 
 964              	 
 965              	.LVL105:
 966 0000 2DE9F043 	 push {r4,r5,r6,r7,r8,r9,lr}
 967              	.LCFI14:
 968              	 .cfi_def_cfa_offset 28
 969              	 .cfi_offset 4,-28
 970              	 .cfi_offset 5,-24
 971              	 .cfi_offset 6,-20
 972              	 .cfi_offset 7,-16
 973              	 .cfi_offset 8,-12
 974              	 .cfi_offset 9,-8
 975              	 .cfi_offset 14,-4
 976 0004 87B0     	 sub sp,sp,#28
 977              	.LCFI15:
 978              	 .cfi_def_cfa_offset 56
 979 0006 0393     	 str r3,[sp,#12]
 980              	.LVL106:
 525:../FreeRTOS/Source/stream_buffer.c ****     configASSERT( pxStreamBuffer );
 981              	 .loc 1 525 0
 982 0008 41B9     	 cbnz r1,.L76
 983              	.LBB116:
 984              	.LBB117:
 985              	 .loc 2 197 0
 986              	
 987 000a 4FF01403 	 mov r3,#20
 988 000e 83F31188 	 msr basepri,r3
 989 0012 BFF36F8F 	 isb 
 990 0016 BFF34F8F 	 dsb 
 991              	
 992              	
 993              	.LVL107:
 994              	 .thumb
 995              	.L77:
 996              	.LBE117:
 997              	.LBE116:
 525:../FreeRTOS/Source/stream_buffer.c ****     configASSERT( pxStreamBuffer );
 998              	 .loc 1 525 0 discriminator 1
 999 001a FEE7     	 b .L77
 1000              	.LVL108:
 1001              	.L76:
 1002 001c 8846     	 mov r8,r1
 526:../FreeRTOS/Source/stream_buffer.c **** 
 1003              	 .loc 1 526 0
 1004 001e 40B9     	 cbnz r0,.L78
 1005              	.LBB118:
 1006              	.LBB119:
 1007              	 .loc 2 197 0
 1008              	
 1009 0020 4FF01403 	 mov r3,#20
 1010 0024 83F31188 	 msr basepri,r3
 1011 0028 BFF36F8F 	 isb 
 1012 002c BFF34F8F 	 dsb 
 1013              	
 1014              	
 1015              	.LVL109:
 1016              	 .thumb
 1017              	.L79:
 1018              	.LBE119:
 1019              	.LBE118:
 526:../FreeRTOS/Source/stream_buffer.c **** 
 1020              	 .loc 1 526 0 discriminator 2
 1021 0030 FEE7     	 b .L79
 1022              	.LVL110:
 1023              	.L78:
 1024 0032 1646     	 mov r6,r2
 1025 0034 0446     	 mov r4,r0
 532:../FreeRTOS/Source/stream_buffer.c ****     {
 1026              	 .loc 1 532 0
 1027 0036 037F     	 ldrb r3,[r0,#28]
 1028              	.LVL111:
 1029 0038 13F0010F 	 tst r3,#1
 1030 003c 0FD0     	 beq .L80
 534:../FreeRTOS/Source/stream_buffer.c **** 
 1031              	 .loc 1 534 0
 1032 003e 151D     	 adds r5,r2,#4
 1033              	.LVL112:
 537:../FreeRTOS/Source/stream_buffer.c **** 
 1034              	 .loc 1 537 0
 1035 0040 AA42     	 cmp r2,r5
 1036 0042 08D3     	 bcc .L81
 1037              	.LBB120:
 1038              	.LBB121:
 1039              	 .loc 2 197 0
 1040              	
 1041 0044 4FF01403 	 mov r3,#20
 1042 0048 83F31188 	 msr basepri,r3
 1043 004c BFF36F8F 	 isb 
 1044 0050 BFF34F8F 	 dsb 
 1045              	
 1046              	
 1047              	.LVL113:
 1048              	 .thumb
 1049              	.L82:
 1050              	.LBE121:
 1051              	.LBE120:
 537:../FreeRTOS/Source/stream_buffer.c **** 
 1052              	 .loc 1 537 0 discriminator 3
 1053 0054 FEE7     	 b .L82
 1054              	.L81:
 542:../FreeRTOS/Source/stream_buffer.c ****         {
 1055              	 .loc 1 542 0
 1056 0056 8368     	 ldr r3,[r0,#8]
 1057              	.LVL114:
 587:../FreeRTOS/Source/stream_buffer.c ****     {
 1058              	 .loc 1 587 0
 1059 0058 039A     	 ldr r2,[sp,#12]
 1060              	.LVL115:
 1061 005a 3AB9     	 cbnz r2,.L83
 1062 005c 3DE0     	 b .L84
 1063              	.LVL116:
 1064              	.L80:
 566:../FreeRTOS/Source/stream_buffer.c ****         {
 1065              	 .loc 1 566 0
 1066 005e 8568     	 ldr r5,[r0,#8]
 1067 0060 9542     	 cmp r5,r2
 1068 0062 28BF     	 it cs
 1069 0064 1546     	 movcs r5,r2
 1070              	.LVL117:
 587:../FreeRTOS/Source/stream_buffer.c ****     {
 1071              	 .loc 1 587 0
 1072 0066 039B     	 ldr r3,[sp,#12]
 1073 0068 13B9     	 cbnz r3,.L85
 1074 006a 36E0     	 b .L84
 1075              	.LVL118:
 1076              	.L83:
 587:../FreeRTOS/Source/stream_buffer.c ****     {
 1077              	 .loc 1 587 0 is_stmt 0 discriminator 1
 1078 006c 9D42     	 cmp r5,r3
 1079 006e 34D8     	 bhi .L84
 1080              	.LVL119:
 1081              	.L85:
 589:../FreeRTOS/Source/stream_buffer.c **** 
 1082              	 .loc 1 589 0 is_stmt 1
 1083 0070 04A8     	 add r0,sp,#16
 1084              	.LVL120:
 1085 0072 FFF7FEFF 	 bl vTaskSetTimeOutState
 1086              	.LVL121:
 602:../FreeRTOS/Source/stream_buffer.c **** 
 1087              	 .loc 1 602 0
 1088 0076 4FF00009 	 mov r9,#0
 1089              	.LVL122:
 1090              	.L89:
 595:../FreeRTOS/Source/stream_buffer.c ****             {
 1091              	 .loc 1 595 0
 1092 007a FFF7FEFF 	 bl vPortEnterCritical
 1093              	.LVL123:
 597:../FreeRTOS/Source/stream_buffer.c **** 
 1094              	 .loc 1 597 0
 1095 007e 2046     	 mov r0,r4
 1096 0080 FFF7FEFF 	 bl xStreamBufferSpacesAvailable
 1097              	.LVL124:
 1098 0084 0746     	 mov r7,r0
 1099              	.LVL125:
 599:../FreeRTOS/Source/stream_buffer.c ****                 {
 1100              	 .loc 1 599 0
 1101 0086 A842     	 cmp r0,r5
 1102 0088 24D2     	 bcs .L86
 602:../FreeRTOS/Source/stream_buffer.c **** 
 1103              	 .loc 1 602 0
 1104 008a 4846     	 mov r0,r9
 1105              	.LVL126:
 1106 008c 4946     	 mov r1,r9
 1107 008e FFF7FEFF 	 bl xTaskGenericNotifyStateClear
 1108              	.LVL127:
 605:../FreeRTOS/Source/stream_buffer.c ****                     pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
 1109              	 .loc 1 605 0
 1110 0092 6369     	 ldr r3,[r4,#20]
 1111 0094 43B1     	 cbz r3,.L87
 1112              	.LBB122:
 1113              	.LBB123:
 1114              	 .loc 2 197 0
 1115              	
 1116 0096 4FF01403 	 mov r3,#20
 1117 009a 83F31188 	 msr basepri,r3
 1118 009e BFF36F8F 	 isb 
 1119 00a2 BFF34F8F 	 dsb 
 1120              	
 1121              	
 1122              	.LVL128:
 1123              	 .thumb
 1124              	.L88:
 1125              	.LBE123:
 1126              	.LBE122:
 605:../FreeRTOS/Source/stream_buffer.c ****                     pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
 1127              	 .loc 1 605 0 discriminator 4
 1128 00a6 FEE7     	 b .L88
 1129              	.L87:
 606:../FreeRTOS/Source/stream_buffer.c ****                 }
 1130              	 .loc 1 606 0
 1131 00a8 FFF7FEFF 	 bl xTaskGetCurrentTaskHandle
 1132              	.LVL129:
 1133 00ac 6061     	 str r0,[r4,#20]
 614:../FreeRTOS/Source/stream_buffer.c **** 
 1134              	 .loc 1 614 0
 1135 00ae FFF7FEFF 	 bl vPortExitCritical
 1136              	.LVL130:
 617:../FreeRTOS/Source/stream_buffer.c ****             pxStreamBuffer->xTaskWaitingToSend = NULL;
 1137              	 .loc 1 617 0
 1138 00b2 039B     	 ldr r3,[sp,#12]
 1139 00b4 0093     	 str r3,[sp]
 1140 00b6 4846     	 mov r0,r9
 1141 00b8 4946     	 mov r1,r9
 1142 00ba 4A46     	 mov r2,r9
 1143 00bc 4B46     	 mov r3,r9
 1144 00be FFF7FEFF 	 bl xTaskGenericNotifyWait
 1145              	.LVL131:
 618:../FreeRTOS/Source/stream_buffer.c ****         } while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
 1146              	 .loc 1 618 0
 1147 00c2 C4F81490 	 str r9,[r4,#20]
 619:../FreeRTOS/Source/stream_buffer.c ****     }
 1148              	 .loc 1 619 0
 1149 00c6 04A8     	 add r0,sp,#16
 1150 00c8 03A9     	 add r1,sp,#12
 1151              	.LVL132:
 1152 00ca FFF7FEFF 	 bl xTaskCheckForTimeOut
 1153              	.LVL133:
 1154 00ce 0028     	 cmp r0,#0
 1155 00d0 D3D0     	 beq .L89
 1156 00d2 01E0     	 b .L90
 1157              	.LVL134:
 1158              	.L86:
 610:../FreeRTOS/Source/stream_buffer.c ****                     break;
 1159              	 .loc 1 610 0
 1160 00d4 FFF7FEFF 	 bl vPortExitCritical
 1161              	.LVL135:
 1162              	.L90:
 626:../FreeRTOS/Source/stream_buffer.c ****     {
 1163              	 .loc 1 626 0
 1164 00d8 1FB9     	 cbnz r7,.L91
 1165              	.LVL136:
 1166              	.L84:
 628:../FreeRTOS/Source/stream_buffer.c ****     }
 1167              	 .loc 1 628 0
 1168 00da 2046     	 mov r0,r4
 1169 00dc FFF7FEFF 	 bl xStreamBufferSpacesAvailable
 1170              	.LVL137:
 1171 00e0 0746     	 mov r7,r0
 1172              	.LVL138:
 1173              	.L91:
 635:../FreeRTOS/Source/stream_buffer.c **** 
 1174              	 .loc 1 635 0
 1175 00e2 0095     	 str r5,[sp]
 1176 00e4 2046     	 mov r0,r4
 1177 00e6 4146     	 mov r1,r8
 1178 00e8 3246     	 mov r2,r6
 1179 00ea 3B46     	 mov r3,r7
 1180 00ec FFF7FEFF 	 bl prvWriteMessageToBuffer
 1181              	.LVL139:
 637:../FreeRTOS/Source/stream_buffer.c ****     {
 1182              	 .loc 1 637 0
 1183 00f0 0646     	 mov r6,r0
 1184              	.LVL140:
 1185 00f2 A0B1     	 cbz r0,.L92
 642:../FreeRTOS/Source/stream_buffer.c ****         {
 1186              	 .loc 1 642 0
 1187 00f4 2046     	 mov r0,r4
 1188              	.LVL141:
 1189 00f6 FFF7FEFF 	 bl prvBytesInBuffer
 1190              	.LVL142:
 1191 00fa E368     	 ldr r3,[r4,#12]
 1192 00fc 9842     	 cmp r0,r3
 1193 00fe 0ED3     	 bcc .L92
 644:../FreeRTOS/Source/stream_buffer.c ****         }
 1194              	 .loc 1 644 0
 1195 0100 FFF7FEFF 	 bl vTaskSuspendAll
 1196              	.LVL143:
 1197 0104 2369     	 ldr r3,[r4,#16]
 1198 0106 43B1     	 cbz r3,.L93
 644:../FreeRTOS/Source/stream_buffer.c ****         }
 1199              	 .loc 1 644 0 is_stmt 0 discriminator 1
 1200 0108 2069     	 ldr r0,[r4,#16]
 1201 010a 0025     	 movs r5,#0
 1202              	.LVL144:
 1203 010c 0095     	 str r5,[sp]
 1204 010e 2946     	 mov r1,r5
 1205 0110 2A46     	 mov r2,r5
 1206 0112 2B46     	 mov r3,r5
 1207 0114 FFF7FEFF 	 bl xTaskGenericNotify
 1208              	.LVL145:
 1209 0118 2561     	 str r5,[r4,#16]
 1210              	.L93:
 644:../FreeRTOS/Source/stream_buffer.c ****         }
 1211              	 .loc 1 644 0 discriminator 3
 1212 011a FFF7FEFF 	 bl xTaskResumeAll
 1213              	.LVL146:
 1214              	.L92:
 658:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
 1215              	 .loc 1 658 0 is_stmt 1
 1216 011e 3046     	 mov r0,r6
 1217 0120 07B0     	 add sp,sp,#28
 1218              	.LCFI16:
 1219              	 .cfi_def_cfa_offset 28
 1220              	 
 1221 0122 BDE8F083 	 pop {r4,r5,r6,r7,r8,r9,pc}
 1222              	 .cfi_endproc
 1223              	.LFE11:
 1225 0126 00BF     	 .section .text.xStreamBufferSendFromISR,"ax",%progbits
 1226              	 .align 2
 1227              	 .global xStreamBufferSendFromISR
 1228              	 .thumb
 1229              	 .thumb_func
 1231              	xStreamBufferSendFromISR:
 1232              	.LFB12:
 665:../FreeRTOS/Source/stream_buffer.c ****     StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 1233              	 .loc 1 665 0
 1234              	 .cfi_startproc
 1235              	 
 1236              	 
 1237              	.LVL147:
 670:../FreeRTOS/Source/stream_buffer.c ****     configASSERT( pxStreamBuffer );
 1238              	 .loc 1 670 0
 1239 0000 41B9     	 cbnz r1,.L97
 1240              	.LBB124:
 1241              	.LBB125:
 1242              	 .loc 2 197 0
 1243              	
 1244 0002 4FF01403 	 mov r3,#20
 1245 0006 83F31188 	 msr basepri,r3
 1246 000a BFF36F8F 	 isb 
 1247 000e BFF34F8F 	 dsb 
 1248              	
 1249              	
 1250              	.LVL148:
 1251              	 .thumb
 1252              	.L98:
 1253              	.LBE125:
 1254              	.LBE124:
 670:../FreeRTOS/Source/stream_buffer.c ****     configASSERT( pxStreamBuffer );
 1255              	 .loc 1 670 0 discriminator 1
 1256 0012 FEE7     	 b .L98
 1257              	.LVL149:
 1258              	.L97:
 665:../FreeRTOS/Source/stream_buffer.c ****     StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 1259              	 .loc 1 665 0
 1260 0014 2DE9F041 	 push {r4,r5,r6,r7,r8,lr}
 1261              	.LCFI17:
 1262              	 .cfi_def_cfa_offset 24
 1263              	 .cfi_offset 4,-24
 1264              	 .cfi_offset 5,-20
 1265              	 .cfi_offset 6,-16
 1266              	 .cfi_offset 7,-12
 1267              	 .cfi_offset 8,-8
 1268              	 .cfi_offset 14,-4
 1269 0018 82B0     	 sub sp,sp,#8
 1270              	.LCFI18:
 1271              	 .cfi_def_cfa_offset 32
 1272 001a 0E46     	 mov r6,r1
 671:../FreeRTOS/Source/stream_buffer.c **** 
 1273              	 .loc 1 671 0
 1274 001c 40B9     	 cbnz r0,.L99
 1275              	.LBB126:
 1276              	.LBB127:
 1277              	 .loc 2 197 0
 1278              	
 1279 001e 4FF01403 	 mov r3,#20
 1280 0022 83F31188 	 msr basepri,r3
 1281 0026 BFF36F8F 	 isb 
 1282 002a BFF34F8F 	 dsb 
 1283              	
 1284              	
 1285              	.LVL150:
 1286              	 .thumb
 1287              	.L100:
 1288              	.LBE127:
 1289              	.LBE126:
 671:../FreeRTOS/Source/stream_buffer.c **** 
 1290              	 .loc 1 671 0 discriminator 2
 1291 002e FEE7     	 b .L100
 1292              	.LVL151:
 1293              	.L99:
 677:../FreeRTOS/Source/stream_buffer.c ****     {
 1294              	 .loc 1 677 0
 1295 0030 017F     	 ldrb r1,[r0,#28]
 1296              	.LVL152:
 1297 0032 11F0010F 	 tst r1,#1
 679:../FreeRTOS/Source/stream_buffer.c ****     }
 1298              	 .loc 1 679 0
 1299 0036 14BF     	 ite ne
 1300 0038 02F10408 	 addne r8,r2,#4
 1301              	.LVL153:
 668:../FreeRTOS/Source/stream_buffer.c **** 
 1302              	 .loc 1 668 0
 1303 003c 9046     	 moveq r8,r2
 1304              	.LVL154:
 1305 003e 1F46     	 mov r7,r3
 1306 0040 1546     	 mov r5,r2
 1307 0042 0446     	 mov r4,r0
 1308              	.LVL155:
 686:../FreeRTOS/Source/stream_buffer.c ****     xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequire
 1309              	 .loc 1 686 0
 1310 0044 FFF7FEFF 	 bl xStreamBufferSpacesAvailable
 1311              	.LVL156:
 1312 0048 0346     	 mov r3,r0
 1313              	.LVL157:
 687:../FreeRTOS/Source/stream_buffer.c **** 
 1314              	 .loc 1 687 0
 1315 004a CDF80080 	 str r8,[sp]
 1316 004e 2046     	 mov r0,r4
 1317              	.LVL158:
 1318 0050 3146     	 mov r1,r6
 1319 0052 2A46     	 mov r2,r5
 1320 0054 FFF7FEFF 	 bl prvWriteMessageToBuffer
 1321              	.LVL159:
 689:../FreeRTOS/Source/stream_buffer.c ****     {
 1322              	 .loc 1 689 0
 1323 0058 0646     	 mov r6,r0
 1324              	.LVL160:
 1325 005a E8B1     	 cbz r0,.L102
 692:../FreeRTOS/Source/stream_buffer.c ****         {
 1326              	 .loc 1 692 0
 1327 005c 2046     	 mov r0,r4
 1328              	.LVL161:
 1329 005e FFF7FEFF 	 bl prvBytesInBuffer
 1330              	.LVL162:
 1331 0062 E368     	 ldr r3,[r4,#12]
 1332 0064 9842     	 cmp r0,r3
 1333 0066 17D3     	 bcc .L102
 1334              	.LBB128:
 1335              	.LBB129:
 1336              	.LBB130:
 198:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 199:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             "	mov %0, %1												\n"\
 200:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             "	msr basepri, %0											\n"\
 201:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             "	isb														\n"\
 202:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             "	dsb														\n"\
 203:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             : "=r" ( ulNewBASEPRI ) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
 204:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         );
 205:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     }
 206:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 207:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 208:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 209:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
 210:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     {
 211:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         uint32_t ulOriginalBASEPRI, ulNewBASEPRI;
 212:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 213:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile
 1337              	 .loc 2 213 0
 1338              	
 1339 0068 EFF31188 	 mrs r8,basepri
 1340 006c 4FF01403 	 mov r3,#20
 1341 0070 83F31188 	 msr basepri,r3
 1342 0074 BFF36F8F 	 isb 
 1343 0078 BFF34F8F 	 dsb 
 1344              	
 1345              	
 1346              	.LVL163:
 1347              	 .thumb
 1348              	.LBE130:
 1349              	.LBE129:
 694:../FreeRTOS/Source/stream_buffer.c ****         }
 1350              	 .loc 1 694 0
 1351 007c 2369     	 ldr r3,[r4,#16]
 1352 007e 4BB1     	 cbz r3,.L103
 694:../FreeRTOS/Source/stream_buffer.c ****         }
 1353              	 .loc 1 694 0 is_stmt 0 discriminator 1
 1354 0080 2069     	 ldr r0,[r4,#16]
 1355 0082 0025     	 movs r5,#0
 1356              	.LVL164:
 1357 0084 0095     	 str r5,[sp]
 1358 0086 0197     	 str r7,[sp,#4]
 1359 0088 2946     	 mov r1,r5
 1360 008a 2A46     	 mov r2,r5
 1361 008c 2B46     	 mov r3,r5
 1362 008e FFF7FEFF 	 bl xTaskGenericNotifyFromISR
 1363              	.LVL165:
 1364 0092 2561     	 str r5,[r4,#16]
 1365              	.L103:
 1366              	.LVL166:
 1367              	.LBB131:
 1368              	.LBB132:
 214:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 215:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             "	mrs %0, basepri											\n"\
 216:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             "	mov %1, %2												\n"\
 217:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             "	msr basepri, %1											\n"\
 218:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             "	isb														\n"\
 219:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             "	dsb														\n"\
 220:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             : "=r" ( ulOriginalBASEPRI ), "=r" ( ulNewBASEPRI ) : "i" ( configMAX_SYSCALL_INTERRUPT
 221:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         );
 222:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 223:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         /* This return will not be reached but is necessary to prevent compiler
 224:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****          * warnings. */
 225:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         return ulOriginalBASEPRI;
 226:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     }
 227:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 228:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 229:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
 230:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     {
 231:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile
 1369              	 .loc 2 231 0 is_stmt 1 discriminator 3
 1370              	
 1371 0094 88F31188 	 msr basepri,r8
 1372              	
 1373              	.LVL167:
 1374              	 .thumb
 1375              	.L102:
 1376              	.LBE132:
 1377              	.LBE131:
 1378              	.LBE128:
 709:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
 1379              	 .loc 1 709 0
 1380 0098 3046     	 mov r0,r6
 1381 009a 02B0     	 add sp,sp,#8
 1382              	.LCFI19:
 1383              	 .cfi_def_cfa_offset 24
 1384              	 
 1385 009c BDE8F081 	 pop {r4,r5,r6,r7,r8,pc}
 1386              	 .cfi_endproc
 1387              	.LFE12:
 1389              	 .section .text.xStreamBufferReceive,"ax",%progbits
 1390              	 .align 2
 1391              	 .global xStreamBufferReceive
 1392              	 .thumb
 1393              	 .thumb_func
 1395              	xStreamBufferReceive:
 1396              	.LFB14:
 768:../FreeRTOS/Source/stream_buffer.c ****     StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 1397              	 .loc 1 768 0
 1398              	 .cfi_startproc
 1399              	 
 1400              	 
 1401              	.LVL168:
 772:../FreeRTOS/Source/stream_buffer.c ****     configASSERT( pxStreamBuffer );
 1402              	 .loc 1 772 0
 1403 0000 41B9     	 cbnz r1,.L107
 1404              	.LBB141:
 1405              	.LBB142:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 1406              	 .loc 2 197 0
 1407              	
 1408 0002 4FF01403 	 mov r3,#20
 1409 0006 83F31188 	 msr basepri,r3
 1410 000a BFF36F8F 	 isb 
 1411 000e BFF34F8F 	 dsb 
 1412              	
 1413              	
 1414              	.LVL169:
 1415              	 .thumb
 1416              	.L108:
 1417              	.LBE142:
 1418              	.LBE141:
 772:../FreeRTOS/Source/stream_buffer.c ****     configASSERT( pxStreamBuffer );
 1419              	 .loc 1 772 0 discriminator 1
 1420 0012 FEE7     	 b .L108
 1421              	.LVL170:
 1422              	.L107:
 768:../FreeRTOS/Source/stream_buffer.c ****     StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 1423              	 .loc 1 768 0
 1424 0014 2DE9F043 	 push {r4,r5,r6,r7,r8,r9,lr}
 1425              	.LCFI20:
 1426              	 .cfi_def_cfa_offset 28
 1427              	 .cfi_offset 4,-28
 1428              	 .cfi_offset 5,-24
 1429              	 .cfi_offset 6,-20
 1430              	 .cfi_offset 7,-16
 1431              	 .cfi_offset 8,-12
 1432              	 .cfi_offset 9,-8
 1433              	 .cfi_offset 14,-4
 1434 0018 85B0     	 sub sp,sp,#20
 1435              	.LCFI21:
 1436              	 .cfi_def_cfa_offset 48
 1437 001a 0446     	 mov r4,r0
 1438              	.LVL171:
 1439 001c 1746     	 mov r7,r2
 1440 001e 9846     	 mov r8,r3
 1441 0020 8946     	 mov r9,r1
 773:../FreeRTOS/Source/stream_buffer.c **** 
 1442              	 .loc 1 773 0
 1443 0022 40B9     	 cbnz r0,.L109
 1444              	.LBB143:
 1445              	.LBB144:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 1446              	 .loc 2 197 0
 1447              	
 1448 0024 4FF01403 	 mov r3,#20
 1449 0028 83F31188 	 msr basepri,r3
 1450 002c BFF36F8F 	 isb 
 1451 0030 BFF34F8F 	 dsb 
 1452              	
 1453              	
 1454              	.LVL172:
 1455              	 .thumb
 1456              	.L110:
 1457              	.LBE144:
 1458              	.LBE143:
 773:../FreeRTOS/Source/stream_buffer.c **** 
 1459              	 .loc 1 773 0 discriminator 2
 1460 0034 FEE7     	 b .L110
 1461              	.LVL173:
 1462              	.L109:
 780:../FreeRTOS/Source/stream_buffer.c ****     {
 1463              	 .loc 1 780 0
 1464 0036 057F     	 ldrb r5,[r0,#28]
 1465 0038 05F00105 	 and r5,r5,#1
 786:../FreeRTOS/Source/stream_buffer.c ****     }
 1466              	 .loc 1 786 0
 1467 003c AD00     	 lsls r5,r5,#2
 1468              	.LVL174:
 789:../FreeRTOS/Source/stream_buffer.c ****     {
 1469              	 .loc 1 789 0
 1470 003e 53B3     	 cbz r3,.L112
 793:../FreeRTOS/Source/stream_buffer.c ****         {
 1471              	 .loc 1 793 0
 1472 0040 FFF7FEFF 	 bl vPortEnterCritical
 1473              	.LVL175:
 795:../FreeRTOS/Source/stream_buffer.c **** 
 1474              	 .loc 1 795 0
 1475 0044 2046     	 mov r0,r4
 1476 0046 FFF7FEFF 	 bl prvBytesInBuffer
 1477              	.LVL176:
 1478 004a 0646     	 mov r6,r0
 1479              	.LVL177:
 802:../FreeRTOS/Source/stream_buffer.c ****             {
 1480              	 .loc 1 802 0
 1481 004c 8542     	 cmp r5,r0
 1482 004e 52D3     	 bcc .L113
 805:../FreeRTOS/Source/stream_buffer.c **** 
 1483              	 .loc 1 805 0
 1484 0050 0020     	 movs r0,#0
 1485              	.LVL178:
 1486 0052 0146     	 mov r1,r0
 1487 0054 FFF7FEFF 	 bl xTaskGenericNotifyStateClear
 1488              	.LVL179:
 808:../FreeRTOS/Source/stream_buffer.c ****                 pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
 1489              	 .loc 1 808 0
 1490 0058 2369     	 ldr r3,[r4,#16]
 1491 005a 43B1     	 cbz r3,.L114
 1492              	.LBB145:
 1493              	.LBB146:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 1494              	 .loc 2 197 0
 1495              	
 1496 005c 4FF01403 	 mov r3,#20
 1497 0060 83F31188 	 msr basepri,r3
 1498 0064 BFF36F8F 	 isb 
 1499 0068 BFF34F8F 	 dsb 
 1500              	
 1501              	
 1502              	.LVL180:
 1503              	 .thumb
 1504              	.L115:
 1505              	.LBE146:
 1506              	.LBE145:
 808:../FreeRTOS/Source/stream_buffer.c ****                 pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
 1507              	 .loc 1 808 0 discriminator 3
 1508 006c FEE7     	 b .L115
 1509              	.L114:
 809:../FreeRTOS/Source/stream_buffer.c ****             }
 1510              	 .loc 1 809 0
 1511 006e FFF7FEFF 	 bl xTaskGetCurrentTaskHandle
 1512              	.LVL181:
 1513 0072 2061     	 str r0,[r4,#16]
 816:../FreeRTOS/Source/stream_buffer.c **** 
 1514              	 .loc 1 816 0
 1515 0074 FFF7FEFF 	 bl vPortExitCritical
 1516              	.LVL182:
 822:../FreeRTOS/Source/stream_buffer.c ****             pxStreamBuffer->xTaskWaitingToReceive = NULL;
 1517              	 .loc 1 822 0
 1518 0078 CDF80080 	 str r8,[sp]
 1519 007c 0020     	 movs r0,#0
 1520 007e 0146     	 mov r1,r0
 1521 0080 0246     	 mov r2,r0
 1522 0082 0346     	 mov r3,r0
 1523 0084 FFF7FEFF 	 bl xTaskGenericNotifyWait
 1524              	.LVL183:
 823:../FreeRTOS/Source/stream_buffer.c **** 
 1525              	 .loc 1 823 0
 1526 0088 0023     	 movs r3,#0
 1527 008a 2361     	 str r3,[r4,#16]
 826:../FreeRTOS/Source/stream_buffer.c ****         }
 1528              	 .loc 1 826 0
 1529 008c 2046     	 mov r0,r4
 1530 008e FFF7FEFF 	 bl prvBytesInBuffer
 1531              	.LVL184:
 1532 0092 0646     	 mov r6,r0
 1533              	.LVL185:
 1534 0094 02E0     	 b .L116
 1535              	.LVL186:
 1536              	.L112:
 835:../FreeRTOS/Source/stream_buffer.c ****     }
 1537              	 .loc 1 835 0
 1538 0096 FFF7FEFF 	 bl prvBytesInBuffer
 1539              	.LVL187:
 1540 009a 0646     	 mov r6,r0
 1541              	.LVL188:
 1542              	.L116:
 843:../FreeRTOS/Source/stream_buffer.c ****     {
 1543              	 .loc 1 843 0
 1544 009c AE42     	 cmp r6,r5
 770:../FreeRTOS/Source/stream_buffer.c **** 
 1545              	 .loc 1 770 0
 1546 009e 98BF     	 it ls
 1547 00a0 0026     	 movls r6,#0
 843:../FreeRTOS/Source/stream_buffer.c ****     {
 1548              	 .loc 1 843 0
 1549 00a2 2BD9     	 bls .L124
 1550              	.LVL189:
 1551              	.L120:
 1552              	.LBB147:
 1553              	.LBB148:
 979:../FreeRTOS/Source/stream_buffer.c ****     {
 1554              	 .loc 1 979 0
 1555 00a4 7DB1     	 cbz r5,.L118
 985:../FreeRTOS/Source/stream_buffer.c ****         ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBy
 1556              	 .loc 1 985 0
 1557 00a6 D4F80080 	 ldr r8,[r4]
 1558              	.LVL190:
 986:../FreeRTOS/Source/stream_buffer.c ****         xNextMessageLength = ( size_t ) xTempNextMessageLength;
 1559              	 .loc 1 986 0
 1560 00aa 2046     	 mov r0,r4
 1561 00ac 03A9     	 add r1,sp,#12
 1562 00ae 2A46     	 mov r2,r5
 1563 00b0 3346     	 mov r3,r6
 1564 00b2 FFF7FEFF 	 bl prvReadBytesFromBuffer
 1565              	.LVL191:
 987:../FreeRTOS/Source/stream_buffer.c **** 
 1566              	 .loc 1 987 0
 1567 00b6 039B     	 ldr r3,[sp,#12]
 1568              	.LVL192:
 991:../FreeRTOS/Source/stream_buffer.c **** 
 1569              	 .loc 1 991 0
 1570 00b8 761B     	 subs r6,r6,r5
 1571              	.LVL193:
 995:../FreeRTOS/Source/stream_buffer.c ****         {
 1572              	 .loc 1 995 0
 1573 00ba 9F42     	 cmp r7,r3
1000:../FreeRTOS/Source/stream_buffer.c ****             xNextMessageLength = 0;
 1574              	 .loc 1 1000 0
 1575 00bc 3ABF     	 itte cc
 1576 00be C4F80080 	 strcc r8,[r4]
 1577              	.LVL194:
1001:../FreeRTOS/Source/stream_buffer.c ****         }
 1578              	 .loc 1 1001 0
 1579 00c2 0027     	 movcc r7,#0
 1580              	.LVL195:
 987:../FreeRTOS/Source/stream_buffer.c **** 
 1581              	 .loc 1 987 0
 1582 00c4 1F46     	 movcs r7,r3
 1583              	.LVL196:
 1584              	.L118:
1016:../FreeRTOS/Source/stream_buffer.c **** 
 1585              	 .loc 1 1016 0
 1586 00c6 2046     	 mov r0,r4
 1587 00c8 4946     	 mov r1,r9
 1588 00ca 3A46     	 mov r2,r7
 1589 00cc 3346     	 mov r3,r6
 1590 00ce FFF7FEFF 	 bl prvReadBytesFromBuffer
 1591              	.LVL197:
 1592              	.LBE148:
 1593              	.LBE147:
 848:../FreeRTOS/Source/stream_buffer.c ****         {
 1594              	 .loc 1 848 0
 1595 00d2 0646     	 mov r6,r0
 1596              	.LVL198:
 1597 00d4 90B1     	 cbz r0,.L124
 851:../FreeRTOS/Source/stream_buffer.c ****         }
 1598              	 .loc 1 851 0
 1599 00d6 FFF7FEFF 	 bl vTaskSuspendAll
 1600              	.LVL199:
 1601 00da 6369     	 ldr r3,[r4,#20]
 1602 00dc 43B1     	 cbz r3,.L119
 851:../FreeRTOS/Source/stream_buffer.c ****         }
 1603              	 .loc 1 851 0 is_stmt 0 discriminator 1
 1604 00de 6069     	 ldr r0,[r4,#20]
 1605 00e0 0025     	 movs r5,#0
 1606              	.LVL200:
 1607 00e2 0095     	 str r5,[sp]
 1608 00e4 2946     	 mov r1,r5
 1609 00e6 2A46     	 mov r2,r5
 1610 00e8 2B46     	 mov r3,r5
 1611 00ea FFF7FEFF 	 bl xTaskGenericNotify
 1612              	.LVL201:
 1613 00ee 6561     	 str r5,[r4,#20]
 1614              	.L119:
 851:../FreeRTOS/Source/stream_buffer.c ****         }
 1615              	 .loc 1 851 0 discriminator 3
 1616 00f0 FFF7FEFF 	 bl xTaskResumeAll
 1617              	.LVL202:
 1618 00f4 02E0     	 b .L124
 1619              	.LVL203:
 1620              	.L113:
 816:../FreeRTOS/Source/stream_buffer.c **** 
 1621              	 .loc 1 816 0 is_stmt 1
 1622 00f6 FFF7FEFF 	 bl vPortExitCritical
 1623              	.LVL204:
 1624 00fa D3E7     	 b .L120
 1625              	.LVL205:
 1626              	.L124:
 865:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
 1627              	 .loc 1 865 0
 1628 00fc 3046     	 mov r0,r6
 1629 00fe 05B0     	 add sp,sp,#20
 1630              	.LCFI22:
 1631              	 .cfi_def_cfa_offset 28
 1632              	 
 1633 0100 BDE8F083 	 pop {r4,r5,r6,r7,r8,r9,pc}
 1634              	 .cfi_endproc
 1635              	.LFE14:
 1637              	 .section .text.xStreamBufferNextMessageLengthBytes,"ax",%progbits
 1638              	 .align 2
 1639              	 .global xStreamBufferNextMessageLengthBytes
 1640              	 .thumb
 1641              	 .thumb_func
 1643              	xStreamBufferNextMessageLengthBytes:
 1644              	.LFB15:
 869:../FreeRTOS/Source/stream_buffer.c ****     StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 1645              	 .loc 1 869 0
 1646              	 .cfi_startproc
 1647              	 
 1648              	 
 1649              	.LVL206:
 874:../FreeRTOS/Source/stream_buffer.c **** 
 1650              	 .loc 1 874 0
 1651 0000 40B9     	 cbnz r0,.L127
 1652              	.LBB149:
 1653              	.LBB150:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 1654              	 .loc 2 197 0
 1655              	
 1656 0002 4FF01403 	 mov r3,#20
 1657 0006 83F31188 	 msr basepri,r3
 1658 000a BFF36F8F 	 isb 
 1659 000e BFF34F8F 	 dsb 
 1660              	
 1661              	
 1662              	.LVL207:
 1663              	 .thumb
 1664              	.L128:
 1665              	.LBE150:
 1666              	.LBE149:
 874:../FreeRTOS/Source/stream_buffer.c **** 
 1667              	 .loc 1 874 0 discriminator 1
 1668 0012 FEE7     	 b .L128
 1669              	.L127:
 869:../FreeRTOS/Source/stream_buffer.c ****     StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 1670              	 .loc 1 869 0
 1671 0014 30B5     	 push {r4,r5,lr}
 1672              	.LCFI23:
 1673              	 .cfi_def_cfa_offset 12
 1674              	 .cfi_offset 4,-12
 1675              	 .cfi_offset 5,-8
 1676              	 .cfi_offset 14,-4
 1677 0016 83B0     	 sub sp,sp,#12
 1678              	.LCFI24:
 1679              	 .cfi_def_cfa_offset 24
 1680 0018 0446     	 mov r4,r0
 877:../FreeRTOS/Source/stream_buffer.c ****     {
 1681              	 .loc 1 877 0
 1682 001a 037F     	 ldrb r3,[r0,#28]
 1683 001c 13F0010F 	 tst r3,#1
 1684 0020 17D0     	 beq .L132
 879:../FreeRTOS/Source/stream_buffer.c **** 
 1685              	 .loc 1 879 0
 1686 0022 FFF7FEFF 	 bl prvBytesInBuffer
 1687              	.LVL208:
 1688 0026 0346     	 mov r3,r0
 1689              	.LVL209:
 881:../FreeRTOS/Source/stream_buffer.c ****         {
 1690              	 .loc 1 881 0
 1691 0028 0428     	 cmp r0,#4
 1692 002a 08D9     	 bls .L130
 889:../FreeRTOS/Source/stream_buffer.c ****             ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO
 1693              	 .loc 1 889 0
 1694 002c 2568     	 ldr r5,[r4]
 1695              	.LVL210:
 890:../FreeRTOS/Source/stream_buffer.c ****             xReturn = ( size_t ) xTempReturn;
 1696              	 .loc 1 890 0
 1697 002e 2046     	 mov r0,r4
 1698              	.LVL211:
 1699 0030 01A9     	 add r1,sp,#4
 1700 0032 0422     	 movs r2,#4
 1701 0034 FFF7FEFF 	 bl prvReadBytesFromBuffer
 1702              	.LVL212:
 891:../FreeRTOS/Source/stream_buffer.c ****             pxStreamBuffer->xTail = xOriginalTail;
 1703              	 .loc 1 891 0
 1704 0038 0198     	 ldr r0,[sp,#4]
 1705              	.LVL213:
 892:../FreeRTOS/Source/stream_buffer.c ****         }
 1706              	 .loc 1 892 0
 1707 003a 2560     	 str r5,[r4]
 1708 003c 0CE0     	 b .L129
 1709              	.LVL214:
 1710              	.L130:
 900:../FreeRTOS/Source/stream_buffer.c ****             xReturn = 0;
 1711              	 .loc 1 900 0
 1712 003e 50B1     	 cbz r0,.L133
 1713              	.LBB151:
 1714              	.LBB152:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 1715              	 .loc 2 197 0
 1716              	
 1717 0040 4FF01403 	 mov r3,#20
 1718 0044 83F31188 	 msr basepri,r3
 1719 0048 BFF36F8F 	 isb 
 1720 004c BFF34F8F 	 dsb 
 1721              	
 1722              	
 1723              	.LVL215:
 1724              	 .thumb
 1725              	.L131:
 1726              	.LBE152:
 1727              	.LBE151:
 900:../FreeRTOS/Source/stream_buffer.c ****             xReturn = 0;
 1728              	 .loc 1 900 0 discriminator 2
 1729 0050 FEE7     	 b .L131
 1730              	.LVL216:
 1731              	.L132:
 906:../FreeRTOS/Source/stream_buffer.c ****     }
 1732              	 .loc 1 906 0
 1733 0052 0020     	 movs r0,#0
 1734              	.LVL217:
 1735 0054 00E0     	 b .L129
 1736              	.LVL218:
 1737              	.L133:
 901:../FreeRTOS/Source/stream_buffer.c ****         }
 1738              	 .loc 1 901 0
 1739 0056 0020     	 movs r0,#0
 1740              	.LVL219:
 1741              	.L129:
 910:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
 1742              	 .loc 1 910 0
 1743 0058 03B0     	 add sp,sp,#12
 1744              	.LCFI25:
 1745              	 .cfi_def_cfa_offset 12
 1746              	 
 1747 005a 30BD     	 pop {r4,r5,pc}
 1748              	 .cfi_endproc
 1749              	.LFE15:
 1751              	 .section .text.xStreamBufferReceiveFromISR,"ax",%progbits
 1752              	 .align 2
 1753              	 .global xStreamBufferReceiveFromISR
 1754              	 .thumb
 1755              	 .thumb_func
 1757              	xStreamBufferReceiveFromISR:
 1758              	.LFB16:
 917:../FreeRTOS/Source/stream_buffer.c ****     StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 1759              	 .loc 1 917 0
 1760              	 .cfi_startproc
 1761              	 
 1762              	 
 1763              	.LVL220:
 921:../FreeRTOS/Source/stream_buffer.c ****     configASSERT( pxStreamBuffer );
 1764              	 .loc 1 921 0
 1765 0000 41B9     	 cbnz r1,.L136
 1766              	.LBB164:
 1767              	.LBB165:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 1768              	 .loc 2 197 0
 1769              	
 1770 0002 4FF01403 	 mov r3,#20
 1771 0006 83F31188 	 msr basepri,r3
 1772 000a BFF36F8F 	 isb 
 1773 000e BFF34F8F 	 dsb 
 1774              	
 1775              	
 1776              	.LVL221:
 1777              	 .thumb
 1778              	.L137:
 1779              	.LBE165:
 1780              	.LBE164:
 921:../FreeRTOS/Source/stream_buffer.c ****     configASSERT( pxStreamBuffer );
 1781              	 .loc 1 921 0 discriminator 1
 1782 0012 FEE7     	 b .L137
 1783              	.LVL222:
 1784              	.L136:
 917:../FreeRTOS/Source/stream_buffer.c ****     StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 1785              	 .loc 1 917 0
 1786 0014 2DE9F043 	 push {r4,r5,r6,r7,r8,r9,lr}
 1787              	.LCFI26:
 1788              	 .cfi_def_cfa_offset 28
 1789              	 .cfi_offset 4,-28
 1790              	 .cfi_offset 5,-24
 1791              	 .cfi_offset 6,-20
 1792              	 .cfi_offset 7,-16
 1793              	 .cfi_offset 8,-12
 1794              	 .cfi_offset 9,-8
 1795              	 .cfi_offset 14,-4
 1796 0018 85B0     	 sub sp,sp,#20
 1797              	.LCFI27:
 1798              	 .cfi_def_cfa_offset 48
 1799 001a 0446     	 mov r4,r0
 1800              	.LVL223:
 1801 001c 1646     	 mov r6,r2
 1802 001e 1F46     	 mov r7,r3
 1803 0020 8846     	 mov r8,r1
 922:../FreeRTOS/Source/stream_buffer.c **** 
 1804              	 .loc 1 922 0
 1805 0022 40B9     	 cbnz r0,.L138
 1806              	.LBB166:
 1807              	.LBB167:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 1808              	 .loc 2 197 0
 1809              	
 1810 0024 4FF01403 	 mov r3,#20
 1811 0028 83F31188 	 msr basepri,r3
 1812 002c BFF36F8F 	 isb 
 1813 0030 BFF34F8F 	 dsb 
 1814              	
 1815              	
 1816              	.LVL224:
 1817              	 .thumb
 1818              	.L139:
 1819              	.LBE167:
 1820              	.LBE166:
 922:../FreeRTOS/Source/stream_buffer.c **** 
 1821              	 .loc 1 922 0 discriminator 2
 1822 0034 FEE7     	 b .L139
 1823              	.LVL225:
 1824              	.L138:
 929:../FreeRTOS/Source/stream_buffer.c ****     {
 1825              	 .loc 1 929 0
 1826 0036 037F     	 ldrb r3,[r0,#28]
 1827              	.LVL226:
 1828 0038 13F0010F 	 tst r3,#1
 1829 003c 37D1     	 bne .L140
 1830 003e 2FE0     	 b .L148
 1831              	.LVL227:
 1832              	.L145:
 1833              	.LBB168:
 1834              	.LBB169:
 985:../FreeRTOS/Source/stream_buffer.c ****         ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBy
 1835              	 .loc 1 985 0
 1836 0040 D4F80090 	 ldr r9,[r4]
 1837              	.LVL228:
 986:../FreeRTOS/Source/stream_buffer.c ****         xNextMessageLength = ( size_t ) xTempNextMessageLength;
 1838              	 .loc 1 986 0
 1839 0044 2046     	 mov r0,r4
 1840              	.LVL229:
 1841 0046 03A9     	 add r1,sp,#12
 1842 0048 0422     	 movs r2,#4
 1843 004a 2B46     	 mov r3,r5
 1844 004c FFF7FEFF 	 bl prvReadBytesFromBuffer
 1845              	.LVL230:
 987:../FreeRTOS/Source/stream_buffer.c **** 
 1846              	 .loc 1 987 0
 1847 0050 039A     	 ldr r2,[sp,#12]
 1848              	.LVL231:
 991:../FreeRTOS/Source/stream_buffer.c **** 
 1849              	 .loc 1 991 0
 1850 0052 2B1F     	 subs r3,r5,#4
 1851              	.LVL232:
 995:../FreeRTOS/Source/stream_buffer.c ****         {
 1852              	 .loc 1 995 0
 1853 0054 9642     	 cmp r6,r2
1000:../FreeRTOS/Source/stream_buffer.c ****             xNextMessageLength = 0;
 1854              	 .loc 1 1000 0
 1855 0056 3ABF     	 itte cc
 1856 0058 C4F80090 	 strcc r9,[r4]
 1857              	.LVL233:
1001:../FreeRTOS/Source/stream_buffer.c ****         }
 1858              	 .loc 1 1001 0
 1859 005c 0026     	 movcc r6,#0
 1860              	.LVL234:
 987:../FreeRTOS/Source/stream_buffer.c **** 
 1861              	 .loc 1 987 0
 1862 005e 1646     	 movcs r6,r2
 1863              	.LVL235:
 1864              	.L142:
1016:../FreeRTOS/Source/stream_buffer.c **** 
 1865              	 .loc 1 1016 0
 1866 0060 2046     	 mov r0,r4
 1867 0062 4146     	 mov r1,r8
 1868 0064 3246     	 mov r2,r6
 1869 0066 FFF7FEFF 	 bl prvReadBytesFromBuffer
 1870              	.LVL236:
 1871              	.LBE169:
 1872              	.LBE168:
 950:../FreeRTOS/Source/stream_buffer.c ****         {
 1873              	 .loc 1 950 0
 1874 006a 0646     	 mov r6,r0
 1875              	.LVL237:
 1876 006c 28B3     	 cbz r0,.L147
 1877              	.LBB170:
 1878              	.LBB171:
 1879              	.LBB172:
 213:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 1880              	 .loc 2 213 0
 1881              	
 1882 006e EFF31188 	 mrs r8,basepri
 1883 0072 4FF01403 	 mov r3,#20
 1884 0076 83F31188 	 msr basepri,r3
 1885 007a BFF36F8F 	 isb 
 1886 007e BFF34F8F 	 dsb 
 1887              	
 1888              	
 1889              	.LVL238:
 1890              	 .thumb
 1891              	.LBE172:
 1892              	.LBE171:
 952:../FreeRTOS/Source/stream_buffer.c ****         }
 1893              	 .loc 1 952 0
 1894 0082 6369     	 ldr r3,[r4,#20]
 1895 0084 4BB1     	 cbz r3,.L144
 952:../FreeRTOS/Source/stream_buffer.c ****         }
 1896              	 .loc 1 952 0 is_stmt 0 discriminator 1
 1897 0086 6069     	 ldr r0,[r4,#20]
 1898              	.LVL239:
 1899 0088 0025     	 movs r5,#0
 1900 008a 0095     	 str r5,[sp]
 1901 008c 0197     	 str r7,[sp,#4]
 1902 008e 2946     	 mov r1,r5
 1903 0090 2A46     	 mov r2,r5
 1904 0092 2B46     	 mov r3,r5
 1905 0094 FFF7FEFF 	 bl xTaskGenericNotifyFromISR
 1906              	.LVL240:
 1907 0098 6561     	 str r5,[r4,#20]
 1908              	.L144:
 1909              	.LVL241:
 1910              	.LBB173:
 1911              	.LBB174:
 1912              	 .loc 2 231 0 is_stmt 1 discriminator 3
 1913              	
 1914 009a 88F31188 	 msr basepri,r8
 1915              	
 1916              	 .thumb
 1917 009e 0CE0     	 b .L147
 1918              	.LVL242:
 1919              	.L148:
 1920              	.LBE174:
 1921              	.LBE173:
 1922              	.LBE170:
 938:../FreeRTOS/Source/stream_buffer.c **** 
 1923              	 .loc 1 938 0
 1924 00a0 FFF7FEFF 	 bl prvBytesInBuffer
 1925              	.LVL243:
 945:../FreeRTOS/Source/stream_buffer.c ****     {
 1926              	 .loc 1 945 0
 1927 00a4 0346     	 mov r3,r0
 1928 00a6 0028     	 cmp r0,#0
 1929 00a8 DAD1     	 bne .L142
 919:../FreeRTOS/Source/stream_buffer.c **** 
 1930              	 .loc 1 919 0
 1931 00aa 0026     	 movs r6,#0
 1932              	.LVL244:
 1933 00ac 05E0     	 b .L147
 1934              	.LVL245:
 1935              	.L140:
 938:../FreeRTOS/Source/stream_buffer.c **** 
 1936              	 .loc 1 938 0
 1937 00ae FFF7FEFF 	 bl prvBytesInBuffer
 1938              	.LVL246:
 1939 00b2 0546     	 mov r5,r0
 1940              	.LVL247:
 945:../FreeRTOS/Source/stream_buffer.c ****     {
 1941              	 .loc 1 945 0
 1942 00b4 0428     	 cmp r0,#4
 1943 00b6 C3D8     	 bhi .L145
 919:../FreeRTOS/Source/stream_buffer.c **** 
 1944              	 .loc 1 919 0
 1945 00b8 0026     	 movs r6,#0
 1946              	.LVL248:
 1947              	.L147:
 967:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
 1948              	 .loc 1 967 0
 1949 00ba 3046     	 mov r0,r6
 1950 00bc 05B0     	 add sp,sp,#20
 1951              	.LCFI28:
 1952              	 .cfi_def_cfa_offset 28
 1953              	 
 1954 00be BDE8F083 	 pop {r4,r5,r6,r7,r8,r9,pc}
 1955              	 .cfi_endproc
 1956              	.LFE16:
 1958 00c2 00BF     	 .section .text.xStreamBufferIsEmpty,"ax",%progbits
 1959              	 .align 2
 1960              	 .global xStreamBufferIsEmpty
 1961              	 .thumb
 1962              	 .thumb_func
 1964              	xStreamBufferIsEmpty:
 1965              	.LFB18:
1023:../FreeRTOS/Source/stream_buffer.c ****     const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 1966              	 .loc 1 1023 0
 1967              	 .cfi_startproc
 1968              	 
 1969              	 
 1970              	 
 1971              	.LVL249:
1028:../FreeRTOS/Source/stream_buffer.c **** 
 1972              	 .loc 1 1028 0
 1973 0000 0346     	 mov r3,r0
 1974 0002 40B9     	 cbnz r0,.L151
 1975              	.LBB175:
 1976              	.LBB176:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 1977              	 .loc 2 197 0
 1978              	
 1979 0004 4FF01403 	 mov r3,#20
 1980 0008 83F31188 	 msr basepri,r3
 1981 000c BFF36F8F 	 isb 
 1982 0010 BFF34F8F 	 dsb 
 1983              	
 1984              	
 1985              	.LVL250:
 1986              	 .thumb
 1987              	.L152:
 1988              	.LBE176:
 1989              	.LBE175:
1028:../FreeRTOS/Source/stream_buffer.c **** 
 1990              	 .loc 1 1028 0 discriminator 1
 1991 0014 FEE7     	 b .L152
 1992              	.L151:
1031:../FreeRTOS/Source/stream_buffer.c **** 
 1993              	 .loc 1 1031 0
 1994 0016 0068     	 ldr r0,[r0]
 1995              	.LVL251:
1033:../FreeRTOS/Source/stream_buffer.c ****     {
 1996              	 .loc 1 1033 0
 1997 0018 5B68     	 ldr r3,[r3,#4]
 1998              	.LVL252:
1043:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
 1999              	 .loc 1 1043 0
 2000 001a 9842     	 cmp r0,r3
 2001 001c 14BF     	 ite ne
 2002 001e 0020     	 movne r0,#0
 2003              	.LVL253:
 2004 0020 0120     	 moveq r0,#1
 2005 0022 7047     	 bx lr
 2006              	 .cfi_endproc
 2007              	.LFE18:
 2009              	 .section .text.xStreamBufferIsFull,"ax",%progbits
 2010              	 .align 2
 2011              	 .global xStreamBufferIsFull
 2012              	 .thumb
 2013              	 .thumb_func
 2015              	xStreamBufferIsFull:
 2016              	.LFB19:
1047:../FreeRTOS/Source/stream_buffer.c ****     BaseType_t xReturn;
 2017              	 .loc 1 1047 0
 2018              	 .cfi_startproc
 2019              	 
 2020              	 
 2021              	.LVL254:
1052:../FreeRTOS/Source/stream_buffer.c **** 
 2022              	 .loc 1 1052 0
 2023 0000 40B9     	 cbnz r0,.L154
 2024              	.LBB177:
 2025              	.LBB178:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 2026              	 .loc 2 197 0
 2027              	
 2028 0002 4FF01403 	 mov r3,#20
 2029 0006 83F31188 	 msr basepri,r3
 2030 000a BFF36F8F 	 isb 
 2031 000e BFF34F8F 	 dsb 
 2032              	
 2033              	
 2034              	.LVL255:
 2035              	 .thumb
 2036              	.L155:
 2037              	.LBE178:
 2038              	.LBE177:
1052:../FreeRTOS/Source/stream_buffer.c **** 
 2039              	 .loc 1 1052 0 discriminator 1
 2040 0012 FEE7     	 b .L155
 2041              	.L154:
1047:../FreeRTOS/Source/stream_buffer.c ****     BaseType_t xReturn;
 2042              	 .loc 1 1047 0
 2043 0014 10B5     	 push {r4,lr}
 2044              	.LCFI29:
 2045              	 .cfi_def_cfa_offset 8
 2046              	 .cfi_offset 4,-8
 2047              	 .cfi_offset 14,-4
1058:../FreeRTOS/Source/stream_buffer.c ****     {
 2048              	 .loc 1 1058 0
 2049 0016 037F     	 ldrb r3,[r0,#28]
 2050 0018 03F00103 	 and r3,r3,#1
1064:../FreeRTOS/Source/stream_buffer.c ****     }
 2051              	 .loc 1 1064 0
 2052 001c 9C00     	 lsls r4,r3,#2
 2053              	.LVL256:
1068:../FreeRTOS/Source/stream_buffer.c ****     {
 2054              	 .loc 1 1068 0
 2055 001e FFF7FEFF 	 bl xStreamBufferSpacesAvailable
 2056              	.LVL257:
1078:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
 2057              	 .loc 1 1078 0
 2058 0022 8442     	 cmp r4,r0
 2059 0024 34BF     	 ite cc
 2060 0026 0020     	 movcc r0,#0
 2061              	.LVL258:
 2062 0028 0120     	 movcs r0,#1
 2063 002a 10BD     	 pop {r4,pc}
 2064              	 .cfi_endproc
 2065              	.LFE19:
 2067              	 .section .text.xStreamBufferSendCompletedFromISR,"ax",%progbits
 2068              	 .align 2
 2069              	 .global xStreamBufferSendCompletedFromISR
 2070              	 .thumb
 2071              	 .thumb_func
 2073              	xStreamBufferSendCompletedFromISR:
 2074              	.LFB20:
1083:../FreeRTOS/Source/stream_buffer.c ****     StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 2075              	 .loc 1 1083 0
 2076              	 .cfi_startproc
 2077              	 
 2078              	 
 2079              	.LVL259:
1088:../FreeRTOS/Source/stream_buffer.c **** 
 2080              	 .loc 1 1088 0
 2081 0000 40B9     	 cbnz r0,.L160
 2082              	.LBB179:
 2083              	.LBB180:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 2084              	 .loc 2 197 0
 2085              	
 2086 0002 4FF01403 	 mov r3,#20
 2087 0006 83F31188 	 msr basepri,r3
 2088 000a BFF36F8F 	 isb 
 2089 000e BFF34F8F 	 dsb 
 2090              	
 2091              	
 2092              	.LVL260:
 2093              	 .thumb
 2094              	.L161:
 2095              	.LBE180:
 2096              	.LBE179:
1088:../FreeRTOS/Source/stream_buffer.c **** 
 2097              	 .loc 1 1088 0 discriminator 1
 2098 0012 FEE7     	 b .L161
 2099              	.L160:
1083:../FreeRTOS/Source/stream_buffer.c ****     StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 2100              	 .loc 1 1083 0
 2101 0014 70B5     	 push {r4,r5,r6,lr}
 2102              	.LCFI30:
 2103              	 .cfi_def_cfa_offset 16
 2104              	 .cfi_offset 4,-16
 2105              	 .cfi_offset 5,-12
 2106              	 .cfi_offset 6,-8
 2107              	 .cfi_offset 14,-4
 2108 0016 82B0     	 sub sp,sp,#8
 2109              	.LCFI31:
 2110              	 .cfi_def_cfa_offset 24
 2111 0018 0446     	 mov r4,r0
 2112              	.LBB181:
 2113              	.LBB182:
 213:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 2114              	 .loc 2 213 0
 2115              	
 2116 001a EFF31186 	 mrs r6,basepri
 2117 001e 4FF01403 	 mov r3,#20
 2118 0022 83F31188 	 msr basepri,r3
 2119 0026 BFF36F8F 	 isb 
 2120 002a BFF34F8F 	 dsb 
 2121              	
 2122              	
 2123              	.LVL261:
 2124              	 .thumb
 2125              	.LBE182:
 2126              	.LBE181:
1092:../FreeRTOS/Source/stream_buffer.c ****         {
 2127              	 .loc 1 1092 0
 2128 002e 0369     	 ldr r3,[r0,#16]
 2129 0030 5BB1     	 cbz r3,.L163
1094:../FreeRTOS/Source/stream_buffer.c ****                                          ( uint32_t ) 0,
 2130              	 .loc 1 1094 0
 2131 0032 0069     	 ldr r0,[r0,#16]
 2132              	.LVL262:
 2133 0034 0025     	 movs r5,#0
 2134 0036 0095     	 str r5,[sp]
 2135 0038 0191     	 str r1,[sp,#4]
 2136 003a 2946     	 mov r1,r5
 2137              	.LVL263:
 2138 003c 2A46     	 mov r2,r5
 2139 003e 2B46     	 mov r3,r5
 2140 0040 FFF7FEFF 	 bl xTaskGenericNotifyFromISR
 2141              	.LVL264:
1098:../FreeRTOS/Source/stream_buffer.c ****             xReturn = pdTRUE;
 2142              	 .loc 1 1098 0
 2143 0044 2561     	 str r5,[r4,#16]
 2144              	.LVL265:
1099:../FreeRTOS/Source/stream_buffer.c ****         }
 2145              	 .loc 1 1099 0
 2146 0046 0120     	 movs r0,#1
 2147 0048 00E0     	 b .L162
 2148              	.LVL266:
 2149              	.L163:
1103:../FreeRTOS/Source/stream_buffer.c ****         }
 2150              	 .loc 1 1103 0
 2151 004a 0020     	 movs r0,#0
 2152              	.LVL267:
 2153              	.L162:
 2154              	.LBB183:
 2155              	.LBB184:
 2156              	 .loc 2 231 0
 2157              	
 2158 004c 86F31188 	 msr basepri,r6
 2159              	
 2160              	 .thumb
 2161              	.LBE184:
 2162              	.LBE183:
1109:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
 2163              	 .loc 1 1109 0
 2164 0050 02B0     	 add sp,sp,#8
 2165              	.LCFI32:
 2166              	 .cfi_def_cfa_offset 16
 2167              	 
 2168 0052 70BD     	 pop {r4,r5,r6,pc}
 2169              	 .cfi_endproc
 2170              	.LFE20:
 2172              	 .section .text.xStreamBufferReceiveCompletedFromISR,"ax",%progbits
 2173              	 .align 2
 2174              	 .global xStreamBufferReceiveCompletedFromISR
 2175              	 .thumb
 2176              	 .thumb_func
 2178              	xStreamBufferReceiveCompletedFromISR:
 2179              	.LFB21:
1114:../FreeRTOS/Source/stream_buffer.c ****     StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 2180              	 .loc 1 1114 0
 2181              	 .cfi_startproc
 2182              	 
 2183              	 
 2184              	.LVL268:
1119:../FreeRTOS/Source/stream_buffer.c **** 
 2185              	 .loc 1 1119 0
 2186 0000 40B9     	 cbnz r0,.L166
 2187              	.LBB185:
 2188              	.LBB186:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 2189              	 .loc 2 197 0
 2190              	
 2191 0002 4FF01403 	 mov r3,#20
 2192 0006 83F31188 	 msr basepri,r3
 2193 000a BFF36F8F 	 isb 
 2194 000e BFF34F8F 	 dsb 
 2195              	
 2196              	
 2197              	.LVL269:
 2198              	 .thumb
 2199              	.L167:
 2200              	.LBE186:
 2201              	.LBE185:
1119:../FreeRTOS/Source/stream_buffer.c **** 
 2202              	 .loc 1 1119 0 discriminator 1
 2203 0012 FEE7     	 b .L167
 2204              	.L166:
1114:../FreeRTOS/Source/stream_buffer.c ****     StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 2205              	 .loc 1 1114 0
 2206 0014 70B5     	 push {r4,r5,r6,lr}
 2207              	.LCFI33:
 2208              	 .cfi_def_cfa_offset 16
 2209              	 .cfi_offset 4,-16
 2210              	 .cfi_offset 5,-12
 2211              	 .cfi_offset 6,-8
 2212              	 .cfi_offset 14,-4
 2213 0016 82B0     	 sub sp,sp,#8
 2214              	.LCFI34:
 2215              	 .cfi_def_cfa_offset 24
 2216 0018 0446     	 mov r4,r0
 2217              	.LBB187:
 2218              	.LBB188:
 213:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 2219              	 .loc 2 213 0
 2220              	
 2221 001a EFF31186 	 mrs r6,basepri
 2222 001e 4FF01403 	 mov r3,#20
 2223 0022 83F31188 	 msr basepri,r3
 2224 0026 BFF36F8F 	 isb 
 2225 002a BFF34F8F 	 dsb 
 2226              	
 2227              	
 2228              	.LVL270:
 2229              	 .thumb
 2230              	.LBE188:
 2231              	.LBE187:
1123:../FreeRTOS/Source/stream_buffer.c ****         {
 2232              	 .loc 1 1123 0
 2233 002e 4369     	 ldr r3,[r0,#20]
 2234 0030 5BB1     	 cbz r3,.L169
1125:../FreeRTOS/Source/stream_buffer.c ****                                          ( uint32_t ) 0,
 2235              	 .loc 1 1125 0
 2236 0032 4069     	 ldr r0,[r0,#20]
 2237              	.LVL271:
 2238 0034 0025     	 movs r5,#0
 2239 0036 0095     	 str r5,[sp]
 2240 0038 0191     	 str r1,[sp,#4]
 2241 003a 2946     	 mov r1,r5
 2242              	.LVL272:
 2243 003c 2A46     	 mov r2,r5
 2244 003e 2B46     	 mov r3,r5
 2245 0040 FFF7FEFF 	 bl xTaskGenericNotifyFromISR
 2246              	.LVL273:
1129:../FreeRTOS/Source/stream_buffer.c ****             xReturn = pdTRUE;
 2247              	 .loc 1 1129 0
 2248 0044 6561     	 str r5,[r4,#20]
 2249              	.LVL274:
1130:../FreeRTOS/Source/stream_buffer.c ****         }
 2250              	 .loc 1 1130 0
 2251 0046 0120     	 movs r0,#1
 2252 0048 00E0     	 b .L168
 2253              	.LVL275:
 2254              	.L169:
1134:../FreeRTOS/Source/stream_buffer.c ****         }
 2255              	 .loc 1 1134 0
 2256 004a 0020     	 movs r0,#0
 2257              	.LVL276:
 2258              	.L168:
 2259              	.LBB189:
 2260              	.LBB190:
 2261              	 .loc 2 231 0
 2262              	
 2263 004c 86F31188 	 msr basepri,r6
 2264              	
 2265              	 .thumb
 2266              	.LBE190:
 2267              	.LBE189:
1140:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
 2268              	 .loc 1 1140 0
 2269 0050 02B0     	 add sp,sp,#8
 2270              	.LCFI35:
 2271              	 .cfi_def_cfa_offset 16
 2272              	 
 2273 0052 70BD     	 pop {r4,r5,r6,pc}
 2274              	 .cfi_endproc
 2275              	.LFE21:
 2277              	 .section .text.uxStreamBufferGetStreamBufferNumber,"ax",%progbits
 2278              	 .align 2
 2279              	 .global uxStreamBufferGetStreamBufferNumber
 2280              	 .thumb
 2281              	 .thumb_func
 2283              	uxStreamBufferGetStreamBufferNumber:
 2284              	.LFB26:
1295:../FreeRTOS/Source/stream_buffer.c **** }
1296:../FreeRTOS/Source/stream_buffer.c **** 
1297:../FreeRTOS/Source/stream_buffer.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1298:../FreeRTOS/Source/stream_buffer.c **** 
1299:../FreeRTOS/Source/stream_buffer.c ****     UBaseType_t uxStreamBufferGetStreamBufferNumber( StreamBufferHandle_t xStreamBuffer )
1300:../FreeRTOS/Source/stream_buffer.c ****     {
 2285              	 .loc 1 1300 0
 2286              	 .cfi_startproc
 2287              	 
 2288              	 
 2289              	 
 2290              	.LVL277:
1301:../FreeRTOS/Source/stream_buffer.c ****         return xStreamBuffer->uxStreamBufferNumber;
1302:../FreeRTOS/Source/stream_buffer.c ****     }
 2291              	 .loc 1 1302 0
 2292 0000 006A     	 ldr r0,[r0,#32]
 2293              	.LVL278:
 2294 0002 7047     	 bx lr
 2295              	 .cfi_endproc
 2296              	.LFE26:
 2298              	 .section .text.vStreamBufferSetStreamBufferNumber,"ax",%progbits
 2299              	 .align 2
 2300              	 .global vStreamBufferSetStreamBufferNumber
 2301              	 .thumb
 2302              	 .thumb_func
 2304              	vStreamBufferSetStreamBufferNumber:
 2305              	.LFB27:
1303:../FreeRTOS/Source/stream_buffer.c **** 
1304:../FreeRTOS/Source/stream_buffer.c **** #endif /* configUSE_TRACE_FACILITY */
1305:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
1306:../FreeRTOS/Source/stream_buffer.c **** 
1307:../FreeRTOS/Source/stream_buffer.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1308:../FreeRTOS/Source/stream_buffer.c **** 
1309:../FreeRTOS/Source/stream_buffer.c ****     void vStreamBufferSetStreamBufferNumber( StreamBufferHandle_t xStreamBuffer,
1310:../FreeRTOS/Source/stream_buffer.c ****                                              UBaseType_t uxStreamBufferNumber )
1311:../FreeRTOS/Source/stream_buffer.c ****     {
 2306              	 .loc 1 1311 0
 2307              	 .cfi_startproc
 2308              	 
 2309              	 
 2310              	 
 2311              	.LVL279:
1312:../FreeRTOS/Source/stream_buffer.c ****         xStreamBuffer->uxStreamBufferNumber = uxStreamBufferNumber;
 2312              	 .loc 1 1312 0
 2313 0000 0162     	 str r1,[r0,#32]
 2314 0002 7047     	 bx lr
 2315              	 .cfi_endproc
 2316              	.LFE27:
 2318              	 .section .text.ucStreamBufferGetStreamBufferType,"ax",%progbits
 2319              	 .align 2
 2320              	 .global ucStreamBufferGetStreamBufferType
 2321              	 .thumb
 2322              	 .thumb_func
 2324              	ucStreamBufferGetStreamBufferType:
 2325              	.LFB28:
1313:../FreeRTOS/Source/stream_buffer.c ****     }
1314:../FreeRTOS/Source/stream_buffer.c **** 
1315:../FreeRTOS/Source/stream_buffer.c **** #endif /* configUSE_TRACE_FACILITY */
1316:../FreeRTOS/Source/stream_buffer.c **** /*-----------------------------------------------------------*/
1317:../FreeRTOS/Source/stream_buffer.c **** 
1318:../FreeRTOS/Source/stream_buffer.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1319:../FreeRTOS/Source/stream_buffer.c **** 
1320:../FreeRTOS/Source/stream_buffer.c ****     uint8_t ucStreamBufferGetStreamBufferType( StreamBufferHandle_t xStreamBuffer )
1321:../FreeRTOS/Source/stream_buffer.c ****     {
 2326              	 .loc 1 1321 0
 2327              	 .cfi_startproc
 2328              	 
 2329              	 
 2330              	 
 2331              	.LVL280:
1322:../FreeRTOS/Source/stream_buffer.c ****         return( xStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER );
 2332              	 .loc 1 1322 0
 2333 0000 007F     	 ldrb r0,[r0,#28]
 2334              	.LVL281:
1323:../FreeRTOS/Source/stream_buffer.c ****     }
 2335              	 .loc 1 1323 0
 2336 0002 00F00100 	 and r0,r0,#1
 2337 0006 7047     	 bx lr
 2338              	 .cfi_endproc
 2339              	.LFE28:
 2341              	 .text
 2342              	.Letext0:
 2343              	 .file 3 "e:\\embedded\\dave_4-4-2_64bit_2018-02-23\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 2344              	 .file 4 "e:\\embedded\\dave_4-4-2_64bit_2018-02-23\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 2345              	 .file 5 "e:\\embedded\\dave_4-4-2_64bit_2018-02-23\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\lib\\gcc\\arm-none-eabi\\4.9.3\\include\\stddef.h"
 2346              	 .file 6 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/include/task.h"
 2347              	 .file 7 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/include/stream_buffer.h"
 2348              	 .file 8 "e:\\embedded\\dave_4-4-2_64bit_2018-02-23\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\string.h"
 2349              	 .file 9 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/include/portable.h"
DEFINED SYMBOLS
                            *ABS*:00000000 stream_buffer.c
    {standard input}:19     .text.prvBytesInBuffer:00000000 $t
    {standard input}:23     .text.prvBytesInBuffer:00000000 prvBytesInBuffer
    {standard input}:54     .text.prvInitialiseNewStreamBuffer:00000000 $t
    {standard input}:58     .text.prvInitialiseNewStreamBuffer:00000000 prvInitialiseNewStreamBuffer
    {standard input}:130    .text.prvWriteBytesToBuffer:00000000 $t
    {standard input}:134    .text.prvWriteBytesToBuffer:00000000 prvWriteBytesToBuffer
    {standard input}:265    .text.prvWriteMessageToBuffer:00000000 $t
    {standard input}:269    .text.prvWriteMessageToBuffer:00000000 prvWriteMessageToBuffer
    {standard input}:352    .text.prvReadBytesFromBuffer:00000000 $t
    {standard input}:356    .text.prvReadBytesFromBuffer:00000000 prvReadBytesFromBuffer
    {standard input}:502    .text.xStreamBufferGenericCreate:00000000 $t
    {standard input}:507    .text.xStreamBufferGenericCreate:00000000 xStreamBufferGenericCreate
    {standard input}:637    .text.vStreamBufferDelete:00000000 $t
    {standard input}:642    .text.vStreamBufferDelete:00000000 vStreamBufferDelete
    {standard input}:695    .text.xStreamBufferReset:00000000 $t
    {standard input}:700    .text.xStreamBufferReset:00000000 xStreamBufferReset
    {standard input}:790    .text.xStreamBufferSetTriggerLevel:00000000 $t
    {standard input}:795    .text.xStreamBufferSetTriggerLevel:00000000 xStreamBufferSetTriggerLevel
    {standard input}:847    .text.xStreamBufferSpacesAvailable:00000000 $t
    {standard input}:852    .text.xStreamBufferSpacesAvailable:00000000 xStreamBufferSpacesAvailable
    {standard input}:907    .text.xStreamBufferBytesAvailable:00000000 $t
    {standard input}:912    .text.xStreamBufferBytesAvailable:00000000 xStreamBufferBytesAvailable
    {standard input}:954    .text.xStreamBufferSend:00000000 $t
    {standard input}:959    .text.xStreamBufferSend:00000000 xStreamBufferSend
    {standard input}:1226   .text.xStreamBufferSendFromISR:00000000 $t
    {standard input}:1231   .text.xStreamBufferSendFromISR:00000000 xStreamBufferSendFromISR
    {standard input}:1390   .text.xStreamBufferReceive:00000000 $t
    {standard input}:1395   .text.xStreamBufferReceive:00000000 xStreamBufferReceive
    {standard input}:1638   .text.xStreamBufferNextMessageLengthBytes:00000000 $t
    {standard input}:1643   .text.xStreamBufferNextMessageLengthBytes:00000000 xStreamBufferNextMessageLengthBytes
    {standard input}:1752   .text.xStreamBufferReceiveFromISR:00000000 $t
    {standard input}:1757   .text.xStreamBufferReceiveFromISR:00000000 xStreamBufferReceiveFromISR
    {standard input}:1959   .text.xStreamBufferIsEmpty:00000000 $t
    {standard input}:1964   .text.xStreamBufferIsEmpty:00000000 xStreamBufferIsEmpty
    {standard input}:2010   .text.xStreamBufferIsFull:00000000 $t
    {standard input}:2015   .text.xStreamBufferIsFull:00000000 xStreamBufferIsFull
    {standard input}:2068   .text.xStreamBufferSendCompletedFromISR:00000000 $t
    {standard input}:2073   .text.xStreamBufferSendCompletedFromISR:00000000 xStreamBufferSendCompletedFromISR
    {standard input}:2173   .text.xStreamBufferReceiveCompletedFromISR:00000000 $t
    {standard input}:2178   .text.xStreamBufferReceiveCompletedFromISR:00000000 xStreamBufferReceiveCompletedFromISR
    {standard input}:2278   .text.uxStreamBufferGetStreamBufferNumber:00000000 $t
    {standard input}:2283   .text.uxStreamBufferGetStreamBufferNumber:00000000 uxStreamBufferGetStreamBufferNumber
    {standard input}:2299   .text.vStreamBufferSetStreamBufferNumber:00000000 $t
    {standard input}:2304   .text.vStreamBufferSetStreamBufferNumber:00000000 vStreamBufferSetStreamBufferNumber
    {standard input}:2319   .text.ucStreamBufferGetStreamBufferType:00000000 $t
    {standard input}:2324   .text.ucStreamBufferGetStreamBufferType:00000000 ucStreamBufferGetStreamBufferType
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.0.3466fc6a3db32493c997d085de4c7a28
                           .group:00000000 wm4.features.h.22.bee0aee4a3878f51861c775df98fa3ea
                           .group:00000000 wm4._default_types.h.15.933e8edd27a65e0b69af4a865eb623d2
                           .group:00000000 wm4._intsup.h.10.ca9f32a61b410c270a48d1161ca2c217
                           .group:00000000 wm4.stdint.h.22.f4a337c398d8b6d821a97202448bc0d0
                           .group:00000000 wm4.newlib.h.8.fe7d912fc917043c98742c35eddd8cff
                           .group:00000000 wm4.config.h.216.aad1ef7bee4fb69981cb38ce62f84d9c
                           .group:00000000 wm4._ansi.h.23.9f8fcfa20193763fcf364fb91705c94b
                           .group:00000000 wm4.stddef.h.39.c744ceb84abf2f8351653f0e2622da1c
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4._types.h.54.d3d34a3b7f3cc230cd159baf022b4b08
                           .group:00000000 wm4.stddef.h.158.61317cdbfb4026324507d123a50b0fd6
                           .group:00000000 wm4.reent.h.17.8bd9e4098e0428508c282cad794fae43
                           .group:00000000 wm4.cdefs.h.47.4002528de975c0fcce6c551c15d87b8c
                           .group:00000000 wm4.string.h.15.dab3980bf35408a4c507182805e2de3a
                           .group:00000000 wm4.stddef.h.158.a7efb00f6cbc6f43213b50e183c9830c
                           .group:00000000 wm4.FreeRTOSConfig.h.30.aa43eb1cb33228d5c7e359a94d48589b
                           .group:00000000 wm4.projdefs.h.28.d6a7c9061b707820f2fcf4c2ff5d9f24
                           .group:00000000 wm4.portmacro.h.30.2ddc2eaf2e032c76c597fb78c4365041
                           .group:00000000 wm4.portable.h.63.e9cc508c3850f44ce542149380c67812
                           .group:00000000 wm4.mpu_wrappers.h.28.163fb40577cf8d1578015ea3f2ff4cdb
                           .group:00000000 wm4.FreeRTOS.h.67.9945f39eea4ddeb224c0782392206292
                           .group:00000000 wm4.list.h.57.02ec67e07eacffe5ca7cfb7326896236
                           .group:00000000 wm4.task.h.47.2d3fe49a094b8ec1e3e6aac441e8db21
                           .group:00000000 wm4.stream_buffer.h.51.c86ec0f31498dd4967228969a7042057

UNDEFINED SYMBOLS
memset
memcpy
pvPortMalloc
vPortFree
vPortEnterCritical
vPortExitCritical
vTaskSetTimeOutState
xTaskGenericNotifyStateClear
xTaskGetCurrentTaskHandle
xTaskGenericNotifyWait
xTaskCheckForTimeOut
vTaskSuspendAll
xTaskGenericNotify
xTaskResumeAll
xTaskGenericNotifyFromISR
