   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .eabi_attribute 28,1
   5              	 .fpu fpv4-sp-d16
   6              	 .eabi_attribute 23,1
   7              	 .eabi_attribute 24,1
   8              	 .eabi_attribute 25,1
   9              	 .eabi_attribute 26,1
  10              	 .eabi_attribute 30,1
  11              	 .eabi_attribute 34,1
  12              	 .eabi_attribute 18,4
  13              	 .thumb
  14              	 .file "queue.c"
  15              	 .text
  16              	.Ltext0:
  17              	 .cfi_sections .debug_frame
  18              	 .section .text.prvIsQueueEmpty,"ax",%progbits
  19              	 .align 2
  20              	 .thumb
  21              	 .thumb_func
  23              	prvIsQueueEmpty:
  24              	.LFB32:
  25              	 .file 1 "../FreeRTOS/Source/queue.c"
   1:../FreeRTOS/Source/queue.c **** /*
   2:../FreeRTOS/Source/queue.c ****  * FreeRTOS Kernel V10.4.1
   3:../FreeRTOS/Source/queue.c ****  * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:../FreeRTOS/Source/queue.c ****  *
   5:../FreeRTOS/Source/queue.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:../FreeRTOS/Source/queue.c ****  * this software and associated documentation files (the "Software"), to deal in
   7:../FreeRTOS/Source/queue.c ****  * the Software without restriction, including without limitation the rights to
   8:../FreeRTOS/Source/queue.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:../FreeRTOS/Source/queue.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:../FreeRTOS/Source/queue.c ****  * subject to the following conditions:
  11:../FreeRTOS/Source/queue.c ****  *
  12:../FreeRTOS/Source/queue.c ****  * The above copyright notice and this permission notice shall be included in all
  13:../FreeRTOS/Source/queue.c ****  * copies or substantial portions of the Software.
  14:../FreeRTOS/Source/queue.c ****  *
  15:../FreeRTOS/Source/queue.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:../FreeRTOS/Source/queue.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:../FreeRTOS/Source/queue.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:../FreeRTOS/Source/queue.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:../FreeRTOS/Source/queue.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:../FreeRTOS/Source/queue.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:../FreeRTOS/Source/queue.c ****  *
  22:../FreeRTOS/Source/queue.c ****  * https://www.FreeRTOS.org
  23:../FreeRTOS/Source/queue.c ****  * https://github.com/FreeRTOS
  24:../FreeRTOS/Source/queue.c ****  *
  25:../FreeRTOS/Source/queue.c ****  */
  26:../FreeRTOS/Source/queue.c **** 
  27:../FreeRTOS/Source/queue.c **** #include <stdlib.h>
  28:../FreeRTOS/Source/queue.c **** #include <string.h>
  29:../FreeRTOS/Source/queue.c **** 
  30:../FreeRTOS/Source/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  31:../FreeRTOS/Source/queue.c ****  * all the API functions to use the MPU wrappers.  That should only be done when
  32:../FreeRTOS/Source/queue.c ****  * task.h is included from an application file. */
  33:../FreeRTOS/Source/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  34:../FreeRTOS/Source/queue.c **** 
  35:../FreeRTOS/Source/queue.c **** #include "FreeRTOS.h"
  36:../FreeRTOS/Source/queue.c **** #include "task.h"
  37:../FreeRTOS/Source/queue.c **** #include "queue.h"
  38:../FreeRTOS/Source/queue.c **** 
  39:../FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  40:../FreeRTOS/Source/queue.c ****     #include "croutine.h"
  41:../FreeRTOS/Source/queue.c **** #endif
  42:../FreeRTOS/Source/queue.c **** 
  43:../FreeRTOS/Source/queue.c **** /* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
  44:../FreeRTOS/Source/queue.c ****  * because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
  45:../FreeRTOS/Source/queue.c ****  * for the header files above, but not in this file, in order to generate the
  46:../FreeRTOS/Source/queue.c ****  * correct privileged Vs unprivileged linkage and placement. */
  47:../FreeRTOS/Source/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
  48:../FreeRTOS/Source/queue.c **** 
  49:../FreeRTOS/Source/queue.c **** 
  50:../FreeRTOS/Source/queue.c **** /* Constants used with the cRxLock and cTxLock structure members. */
  51:../FreeRTOS/Source/queue.c **** #define queueUNLOCKED             ( ( int8_t ) -1 )
  52:../FreeRTOS/Source/queue.c **** #define queueLOCKED_UNMODIFIED    ( ( int8_t ) 0 )
  53:../FreeRTOS/Source/queue.c **** #define queueINT8_MAX             ( ( int8_t ) 127 )
  54:../FreeRTOS/Source/queue.c **** 
  55:../FreeRTOS/Source/queue.c **** /* When the Queue_t structure is used to represent a base queue its pcHead and
  56:../FreeRTOS/Source/queue.c ****  * pcTail members are used as pointers into the queue storage area.  When the
  57:../FreeRTOS/Source/queue.c ****  * Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
  58:../FreeRTOS/Source/queue.c ****  * not necessary, and the pcHead pointer is set to NULL to indicate that the
  59:../FreeRTOS/Source/queue.c ****  * structure instead holds a pointer to the mutex holder (if any).  Map alternative
  60:../FreeRTOS/Source/queue.c ****  * names to the pcHead and structure member to ensure the readability of the code
  61:../FreeRTOS/Source/queue.c ****  * is maintained.  The QueuePointers_t and SemaphoreData_t types are used to form
  62:../FreeRTOS/Source/queue.c ****  * a union as their usage is mutually exclusive dependent on what the queue is
  63:../FreeRTOS/Source/queue.c ****  * being used for. */
  64:../FreeRTOS/Source/queue.c **** #define uxQueueType               pcHead
  65:../FreeRTOS/Source/queue.c **** #define queueQUEUE_IS_MUTEX       NULL
  66:../FreeRTOS/Source/queue.c **** 
  67:../FreeRTOS/Source/queue.c **** typedef struct QueuePointers
  68:../FreeRTOS/Source/queue.c **** {
  69:../FreeRTOS/Source/queue.c ****     int8_t * pcTail;     /*< Points to the byte at the end of the queue storage area.  Once more by
  70:../FreeRTOS/Source/queue.c ****     int8_t * pcReadFrom; /*< Points to the last place that a queued item was read from when the str
  71:../FreeRTOS/Source/queue.c **** } QueuePointers_t;
  72:../FreeRTOS/Source/queue.c **** 
  73:../FreeRTOS/Source/queue.c **** typedef struct SemaphoreData
  74:../FreeRTOS/Source/queue.c **** {
  75:../FreeRTOS/Source/queue.c ****     TaskHandle_t xMutexHolder;        /*< The handle of the task that holds the mutex. */
  76:../FreeRTOS/Source/queue.c ****     UBaseType_t uxRecursiveCallCount; /*< Maintains a count of the number of times a recursive mute
  77:../FreeRTOS/Source/queue.c **** } SemaphoreData_t;
  78:../FreeRTOS/Source/queue.c **** 
  79:../FreeRTOS/Source/queue.c **** /* Semaphores do not actually store or copy data, so have an item size of
  80:../FreeRTOS/Source/queue.c ****  * zero. */
  81:../FreeRTOS/Source/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH    ( ( UBaseType_t ) 0 )
  82:../FreeRTOS/Source/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME          ( ( TickType_t ) 0U )
  83:../FreeRTOS/Source/queue.c **** 
  84:../FreeRTOS/Source/queue.c **** #if ( configUSE_PREEMPTION == 0 )
  85:../FreeRTOS/Source/queue.c **** 
  86:../FreeRTOS/Source/queue.c **** /* If the cooperative scheduler is being used then a yield should not be
  87:../FreeRTOS/Source/queue.c ****  * performed just because a higher priority task has been woken. */
  88:../FreeRTOS/Source/queue.c ****     #define queueYIELD_IF_USING_PREEMPTION()
  89:../FreeRTOS/Source/queue.c **** #else
  90:../FreeRTOS/Source/queue.c ****     #define queueYIELD_IF_USING_PREEMPTION()    portYIELD_WITHIN_API()
  91:../FreeRTOS/Source/queue.c **** #endif
  92:../FreeRTOS/Source/queue.c **** 
  93:../FreeRTOS/Source/queue.c **** /*
  94:../FreeRTOS/Source/queue.c ****  * Definition of the queue used by the scheduler.
  95:../FreeRTOS/Source/queue.c ****  * Items are queued by copy, not reference.  See the following link for the
  96:../FreeRTOS/Source/queue.c ****  * rationale: https://www.FreeRTOS.org/Embedded-RTOS-Queues.html
  97:../FreeRTOS/Source/queue.c ****  */
  98:../FreeRTOS/Source/queue.c **** typedef struct QueueDefinition /* The old naming convention is used to prevent breaking kernel awar
  99:../FreeRTOS/Source/queue.c **** {
 100:../FreeRTOS/Source/queue.c ****     int8_t * pcHead;           /*< Points to the beginning of the queue storage area. */
 101:../FreeRTOS/Source/queue.c ****     int8_t * pcWriteTo;        /*< Points to the free next place in the storage area. */
 102:../FreeRTOS/Source/queue.c **** 
 103:../FreeRTOS/Source/queue.c ****     union
 104:../FreeRTOS/Source/queue.c ****     {
 105:../FreeRTOS/Source/queue.c ****         QueuePointers_t xQueue;     /*< Data required exclusively when this structure is used as a 
 106:../FreeRTOS/Source/queue.c ****         SemaphoreData_t xSemaphore; /*< Data required exclusively when this structure is used as a 
 107:../FreeRTOS/Source/queue.c ****     } u;
 108:../FreeRTOS/Source/queue.c **** 
 109:../FreeRTOS/Source/queue.c ****     List_t xTasksWaitingToSend;             /*< List of tasks that are blocked waiting to post onto
 110:../FreeRTOS/Source/queue.c ****     List_t xTasksWaitingToReceive;          /*< List of tasks that are blocked waiting to read from
 111:../FreeRTOS/Source/queue.c **** 
 112:../FreeRTOS/Source/queue.c ****     volatile UBaseType_t uxMessagesWaiting; /*< The number of items currently in the queue. */
 113:../FreeRTOS/Source/queue.c ****     UBaseType_t uxLength;                   /*< The length of the queue defined as the number of it
 114:../FreeRTOS/Source/queue.c ****     UBaseType_t uxItemSize;                 /*< The size of each items that the queue will hold. */
 115:../FreeRTOS/Source/queue.c **** 
 116:../FreeRTOS/Source/queue.c ****     volatile int8_t cRxLock;                /*< Stores the number of items received from the queue 
 117:../FreeRTOS/Source/queue.c ****     volatile int8_t cTxLock;                /*< Stores the number of items transmitted to the queue
 118:../FreeRTOS/Source/queue.c **** 
 119:../FreeRTOS/Source/queue.c ****     #if ( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 120:../FreeRTOS/Source/queue.c ****         uint8_t ucStaticallyAllocated; /*< Set to pdTRUE if the memory used by the queue was static
 121:../FreeRTOS/Source/queue.c ****     #endif
 122:../FreeRTOS/Source/queue.c **** 
 123:../FreeRTOS/Source/queue.c ****     #if ( configUSE_QUEUE_SETS == 1 )
 124:../FreeRTOS/Source/queue.c ****         struct QueueDefinition * pxQueueSetContainer;
 125:../FreeRTOS/Source/queue.c ****     #endif
 126:../FreeRTOS/Source/queue.c **** 
 127:../FreeRTOS/Source/queue.c ****     #if ( configUSE_TRACE_FACILITY == 1 )
 128:../FreeRTOS/Source/queue.c ****         UBaseType_t uxQueueNumber;
 129:../FreeRTOS/Source/queue.c ****         uint8_t ucQueueType;
 130:../FreeRTOS/Source/queue.c ****     #endif
 131:../FreeRTOS/Source/queue.c **** } xQUEUE;
 132:../FreeRTOS/Source/queue.c **** 
 133:../FreeRTOS/Source/queue.c **** /* The old xQUEUE name is maintained above then typedefed to the new Queue_t
 134:../FreeRTOS/Source/queue.c ****  * name below to enable the use of older kernel aware debuggers. */
 135:../FreeRTOS/Source/queue.c **** typedef xQUEUE Queue_t;
 136:../FreeRTOS/Source/queue.c **** 
 137:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 138:../FreeRTOS/Source/queue.c **** 
 139:../FreeRTOS/Source/queue.c **** /*
 140:../FreeRTOS/Source/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 141:../FreeRTOS/Source/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 142:../FreeRTOS/Source/queue.c ****  */
 143:../FreeRTOS/Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
 144:../FreeRTOS/Source/queue.c **** 
 145:../FreeRTOS/Source/queue.c **** /* The type stored within the queue registry array.  This allows a name
 146:../FreeRTOS/Source/queue.c ****  * to be assigned to each queue making kernel aware debugging a little
 147:../FreeRTOS/Source/queue.c ****  * more user friendly. */
 148:../FreeRTOS/Source/queue.c ****     typedef struct QUEUE_REGISTRY_ITEM
 149:../FreeRTOS/Source/queue.c ****     {
 150:../FreeRTOS/Source/queue.c ****         const char * pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and s
 151:../FreeRTOS/Source/queue.c ****         QueueHandle_t xHandle;
 152:../FreeRTOS/Source/queue.c ****     } xQueueRegistryItem;
 153:../FreeRTOS/Source/queue.c **** 
 154:../FreeRTOS/Source/queue.c **** /* The old xQueueRegistryItem name is maintained above then typedefed to the
 155:../FreeRTOS/Source/queue.c ****  * new xQueueRegistryItem name below to enable the use of older kernel aware
 156:../FreeRTOS/Source/queue.c ****  * debuggers. */
 157:../FreeRTOS/Source/queue.c ****     typedef xQueueRegistryItem QueueRegistryItem_t;
 158:../FreeRTOS/Source/queue.c **** 
 159:../FreeRTOS/Source/queue.c **** /* The queue registry is simply an array of QueueRegistryItem_t structures.
 160:../FreeRTOS/Source/queue.c ****  * The pcQueueName member of a structure being NULL is indicative of the
 161:../FreeRTOS/Source/queue.c ****  * array position being vacant. */
 162:../FreeRTOS/Source/queue.c ****     PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 163:../FreeRTOS/Source/queue.c **** 
 164:../FreeRTOS/Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
 165:../FreeRTOS/Source/queue.c **** 
 166:../FreeRTOS/Source/queue.c **** /*
 167:../FreeRTOS/Source/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 168:../FreeRTOS/Source/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 169:../FreeRTOS/Source/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 170:../FreeRTOS/Source/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 171:../FreeRTOS/Source/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 172:../FreeRTOS/Source/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 173:../FreeRTOS/Source/queue.c ****  */
 174:../FreeRTOS/Source/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
 175:../FreeRTOS/Source/queue.c **** 
 176:../FreeRTOS/Source/queue.c **** /*
 177:../FreeRTOS/Source/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 178:../FreeRTOS/Source/queue.c ****  *
 179:../FreeRTOS/Source/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 180:../FreeRTOS/Source/queue.c ****  */
 181:../FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue ) PRIVILEGED_FUNCTION;
 182:../FreeRTOS/Source/queue.c **** 
 183:../FreeRTOS/Source/queue.c **** /*
 184:../FreeRTOS/Source/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 185:../FreeRTOS/Source/queue.c ****  *
 186:../FreeRTOS/Source/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 187:../FreeRTOS/Source/queue.c ****  */
 188:../FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t * pxQueue ) PRIVILEGED_FUNCTION;
 189:../FreeRTOS/Source/queue.c **** 
 190:../FreeRTOS/Source/queue.c **** /*
 191:../FreeRTOS/Source/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 192:../FreeRTOS/Source/queue.c ****  * back of the queue.
 193:../FreeRTOS/Source/queue.c ****  */
 194:../FreeRTOS/Source/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
 195:../FreeRTOS/Source/queue.c ****                                       const void * pvItemToQueue,
 196:../FreeRTOS/Source/queue.c ****                                       const BaseType_t xPosition ) PRIVILEGED_FUNCTION;
 197:../FreeRTOS/Source/queue.c **** 
 198:../FreeRTOS/Source/queue.c **** /*
 199:../FreeRTOS/Source/queue.c ****  * Copies an item out of a queue.
 200:../FreeRTOS/Source/queue.c ****  */
 201:../FreeRTOS/Source/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue,
 202:../FreeRTOS/Source/queue.c ****                                   void * const pvBuffer ) PRIVILEGED_FUNCTION;
 203:../FreeRTOS/Source/queue.c **** 
 204:../FreeRTOS/Source/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
 205:../FreeRTOS/Source/queue.c **** 
 206:../FreeRTOS/Source/queue.c **** /*
 207:../FreeRTOS/Source/queue.c ****  * Checks to see if a queue is a member of a queue set, and if so, notifies
 208:../FreeRTOS/Source/queue.c ****  * the queue set that the queue contains data.
 209:../FreeRTOS/Source/queue.c ****  */
 210:../FreeRTOS/Source/queue.c ****     static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue ) PRIVILEGED_FUNCTI
 211:../FreeRTOS/Source/queue.c **** #endif
 212:../FreeRTOS/Source/queue.c **** 
 213:../FreeRTOS/Source/queue.c **** /*
 214:../FreeRTOS/Source/queue.c ****  * Called after a Queue_t structure has been allocated either statically or
 215:../FreeRTOS/Source/queue.c ****  * dynamically to fill in the structure's members.
 216:../FreeRTOS/Source/queue.c ****  */
 217:../FreeRTOS/Source/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
 218:../FreeRTOS/Source/queue.c ****                                    const UBaseType_t uxItemSize,
 219:../FreeRTOS/Source/queue.c ****                                    uint8_t * pucQueueStorage,
 220:../FreeRTOS/Source/queue.c ****                                    const uint8_t ucQueueType,
 221:../FreeRTOS/Source/queue.c ****                                    Queue_t * pxNewQueue ) PRIVILEGED_FUNCTION;
 222:../FreeRTOS/Source/queue.c **** 
 223:../FreeRTOS/Source/queue.c **** /*
 224:../FreeRTOS/Source/queue.c ****  * Mutexes are a special type of queue.  When a mutex is created, first the
 225:../FreeRTOS/Source/queue.c ****  * queue is created, then prvInitialiseMutex() is called to configure the queue
 226:../FreeRTOS/Source/queue.c ****  * as a mutex.
 227:../FreeRTOS/Source/queue.c ****  */
 228:../FreeRTOS/Source/queue.c **** #if ( configUSE_MUTEXES == 1 )
 229:../FreeRTOS/Source/queue.c ****     static void prvInitialiseMutex( Queue_t * pxNewQueue ) PRIVILEGED_FUNCTION;
 230:../FreeRTOS/Source/queue.c **** #endif
 231:../FreeRTOS/Source/queue.c **** 
 232:../FreeRTOS/Source/queue.c **** #if ( configUSE_MUTEXES == 1 )
 233:../FreeRTOS/Source/queue.c **** 
 234:../FreeRTOS/Source/queue.c **** /*
 235:../FreeRTOS/Source/queue.c ****  * If a task waiting for a mutex causes the mutex holder to inherit a
 236:../FreeRTOS/Source/queue.c ****  * priority, but the waiting task times out, then the holder should
 237:../FreeRTOS/Source/queue.c ****  * disinherit the priority - but only down to the highest priority of any
 238:../FreeRTOS/Source/queue.c ****  * other tasks that are waiting for the same mutex.  This function returns
 239:../FreeRTOS/Source/queue.c ****  * that priority.
 240:../FreeRTOS/Source/queue.c ****  */
 241:../FreeRTOS/Source/queue.c ****     static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue ) PRIVIL
 242:../FreeRTOS/Source/queue.c **** #endif
 243:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 244:../FreeRTOS/Source/queue.c **** 
 245:../FreeRTOS/Source/queue.c **** /*
 246:../FreeRTOS/Source/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 247:../FreeRTOS/Source/queue.c ****  * accessing the queue event lists.
 248:../FreeRTOS/Source/queue.c ****  */
 249:../FreeRTOS/Source/queue.c **** #define prvLockQueue( pxQueue )                            \
 250:../FreeRTOS/Source/queue.c ****     taskENTER_CRITICAL();                                  \
 251:../FreeRTOS/Source/queue.c ****     {                                                      \
 252:../FreeRTOS/Source/queue.c ****         if( ( pxQueue )->cRxLock == queueUNLOCKED )        \
 253:../FreeRTOS/Source/queue.c ****         {                                                  \
 254:../FreeRTOS/Source/queue.c ****             ( pxQueue )->cRxLock = queueLOCKED_UNMODIFIED; \
 255:../FreeRTOS/Source/queue.c ****         }                                                  \
 256:../FreeRTOS/Source/queue.c ****         if( ( pxQueue )->cTxLock == queueUNLOCKED )        \
 257:../FreeRTOS/Source/queue.c ****         {                                                  \
 258:../FreeRTOS/Source/queue.c ****             ( pxQueue )->cTxLock = queueLOCKED_UNMODIFIED; \
 259:../FreeRTOS/Source/queue.c ****         }                                                  \
 260:../FreeRTOS/Source/queue.c ****     }                                                      \
 261:../FreeRTOS/Source/queue.c ****     taskEXIT_CRITICAL()
 262:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 263:../FreeRTOS/Source/queue.c **** 
 264:../FreeRTOS/Source/queue.c **** BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
 265:../FreeRTOS/Source/queue.c ****                                BaseType_t xNewQueue )
 266:../FreeRTOS/Source/queue.c **** {
 267:../FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 268:../FreeRTOS/Source/queue.c **** 
 269:../FreeRTOS/Source/queue.c ****     configASSERT( pxQueue );
 270:../FreeRTOS/Source/queue.c **** 
 271:../FreeRTOS/Source/queue.c ****     taskENTER_CRITICAL();
 272:../FreeRTOS/Source/queue.c ****     {
 273:../FreeRTOS/Source/queue.c ****         pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /
 274:../FreeRTOS/Source/queue.c ****         pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 275:../FreeRTOS/Source/queue.c ****         pxQueue->pcWriteTo = pxQueue->pcHead;
 276:../FreeRTOS/Source/queue.c ****         pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->ux
 277:../FreeRTOS/Source/queue.c ****         pxQueue->cRxLock = queueUNLOCKED;
 278:../FreeRTOS/Source/queue.c ****         pxQueue->cTxLock = queueUNLOCKED;
 279:../FreeRTOS/Source/queue.c **** 
 280:../FreeRTOS/Source/queue.c ****         if( xNewQueue == pdFALSE )
 281:../FreeRTOS/Source/queue.c ****         {
 282:../FreeRTOS/Source/queue.c ****             /* If there are tasks blocked waiting to read from the queue, then
 283:../FreeRTOS/Source/queue.c ****              * the tasks will remain blocked as after this function exits the queue
 284:../FreeRTOS/Source/queue.c ****              * will still be empty.  If there are tasks blocked waiting to write to
 285:../FreeRTOS/Source/queue.c ****              * the queue, then one should be unblocked as after this function exits
 286:../FreeRTOS/Source/queue.c ****              * it will be possible to write to it. */
 287:../FreeRTOS/Source/queue.c ****             if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 288:../FreeRTOS/Source/queue.c ****             {
 289:../FreeRTOS/Source/queue.c ****                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 290:../FreeRTOS/Source/queue.c ****                 {
 291:../FreeRTOS/Source/queue.c ****                     queueYIELD_IF_USING_PREEMPTION();
 292:../FreeRTOS/Source/queue.c ****                 }
 293:../FreeRTOS/Source/queue.c ****                 else
 294:../FreeRTOS/Source/queue.c ****                 {
 295:../FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
 296:../FreeRTOS/Source/queue.c ****                 }
 297:../FreeRTOS/Source/queue.c ****             }
 298:../FreeRTOS/Source/queue.c ****             else
 299:../FreeRTOS/Source/queue.c ****             {
 300:../FreeRTOS/Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
 301:../FreeRTOS/Source/queue.c ****             }
 302:../FreeRTOS/Source/queue.c ****         }
 303:../FreeRTOS/Source/queue.c ****         else
 304:../FreeRTOS/Source/queue.c ****         {
 305:../FreeRTOS/Source/queue.c ****             /* Ensure the event queues start in the correct state. */
 306:../FreeRTOS/Source/queue.c ****             vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 307:../FreeRTOS/Source/queue.c ****             vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 308:../FreeRTOS/Source/queue.c ****         }
 309:../FreeRTOS/Source/queue.c ****     }
 310:../FreeRTOS/Source/queue.c ****     taskEXIT_CRITICAL();
 311:../FreeRTOS/Source/queue.c **** 
 312:../FreeRTOS/Source/queue.c ****     /* A value is returned for calling semantic consistency with previous
 313:../FreeRTOS/Source/queue.c ****      * versions. */
 314:../FreeRTOS/Source/queue.c ****     return pdPASS;
 315:../FreeRTOS/Source/queue.c **** }
 316:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 317:../FreeRTOS/Source/queue.c **** 
 318:../FreeRTOS/Source/queue.c **** #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
 319:../FreeRTOS/Source/queue.c **** 
 320:../FreeRTOS/Source/queue.c ****     QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength,
 321:../FreeRTOS/Source/queue.c ****                                              const UBaseType_t uxItemSize,
 322:../FreeRTOS/Source/queue.c ****                                              uint8_t * pucQueueStorage,
 323:../FreeRTOS/Source/queue.c ****                                              StaticQueue_t * pxStaticQueue,
 324:../FreeRTOS/Source/queue.c ****                                              const uint8_t ucQueueType )
 325:../FreeRTOS/Source/queue.c ****     {
 326:../FreeRTOS/Source/queue.c ****         Queue_t * pxNewQueue;
 327:../FreeRTOS/Source/queue.c **** 
 328:../FreeRTOS/Source/queue.c ****         configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 329:../FreeRTOS/Source/queue.c **** 
 330:../FreeRTOS/Source/queue.c ****         /* The StaticQueue_t structure and the queue storage area must be
 331:../FreeRTOS/Source/queue.c ****          * supplied. */
 332:../FreeRTOS/Source/queue.c ****         configASSERT( pxStaticQueue != NULL );
 333:../FreeRTOS/Source/queue.c **** 
 334:../FreeRTOS/Source/queue.c ****         /* A queue storage area should be provided if the item size is not 0, and
 335:../FreeRTOS/Source/queue.c ****          * should not be provided if the item size is 0. */
 336:../FreeRTOS/Source/queue.c ****         configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
 337:../FreeRTOS/Source/queue.c ****         configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
 338:../FreeRTOS/Source/queue.c **** 
 339:../FreeRTOS/Source/queue.c ****         #if ( configASSERT_DEFINED == 1 )
 340:../FreeRTOS/Source/queue.c ****             {
 341:../FreeRTOS/Source/queue.c ****                 /* Sanity check that the size of the structure used to declare a
 342:../FreeRTOS/Source/queue.c ****                  * variable of type StaticQueue_t or StaticSemaphore_t equals the size of
 343:../FreeRTOS/Source/queue.c ****                  * the real queue and semaphore structures. */
 344:../FreeRTOS/Source/queue.c ****                 volatile size_t xSize = sizeof( StaticQueue_t );
 345:../FreeRTOS/Source/queue.c ****                 configASSERT( xSize == sizeof( Queue_t ) );
 346:../FreeRTOS/Source/queue.c ****                 ( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
 347:../FreeRTOS/Source/queue.c ****             }
 348:../FreeRTOS/Source/queue.c ****         #endif /* configASSERT_DEFINED */
 349:../FreeRTOS/Source/queue.c **** 
 350:../FreeRTOS/Source/queue.c ****         /* The address of a statically allocated queue was passed in, use it.
 351:../FreeRTOS/Source/queue.c ****          * The address of a statically allocated storage area was also passed in
 352:../FreeRTOS/Source/queue.c ****          * but is already set. */
 353:../FreeRTOS/Source/queue.c ****         pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 !e9087 Unusual cast is ok as the str
 354:../FreeRTOS/Source/queue.c **** 
 355:../FreeRTOS/Source/queue.c ****         if( pxNewQueue != NULL )
 356:../FreeRTOS/Source/queue.c ****         {
 357:../FreeRTOS/Source/queue.c ****             #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 358:../FreeRTOS/Source/queue.c ****                 {
 359:../FreeRTOS/Source/queue.c ****                     /* Queues can be allocated wither statically or dynamically, so
 360:../FreeRTOS/Source/queue.c ****                      * note this queue was allocated statically in case the queue is
 361:../FreeRTOS/Source/queue.c ****                      * later deleted. */
 362:../FreeRTOS/Source/queue.c ****                     pxNewQueue->ucStaticallyAllocated = pdTRUE;
 363:../FreeRTOS/Source/queue.c ****                 }
 364:../FreeRTOS/Source/queue.c ****             #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 365:../FreeRTOS/Source/queue.c **** 
 366:../FreeRTOS/Source/queue.c ****             prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQu
 367:../FreeRTOS/Source/queue.c ****         }
 368:../FreeRTOS/Source/queue.c ****         else
 369:../FreeRTOS/Source/queue.c ****         {
 370:../FreeRTOS/Source/queue.c ****             traceQUEUE_CREATE_FAILED( ucQueueType );
 371:../FreeRTOS/Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
 372:../FreeRTOS/Source/queue.c ****         }
 373:../FreeRTOS/Source/queue.c **** 
 374:../FreeRTOS/Source/queue.c ****         return pxNewQueue;
 375:../FreeRTOS/Source/queue.c ****     }
 376:../FreeRTOS/Source/queue.c **** 
 377:../FreeRTOS/Source/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 378:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 379:../FreeRTOS/Source/queue.c **** 
 380:../FreeRTOS/Source/queue.c **** #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 381:../FreeRTOS/Source/queue.c **** 
 382:../FreeRTOS/Source/queue.c ****     QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
 383:../FreeRTOS/Source/queue.c ****                                        const UBaseType_t uxItemSize,
 384:../FreeRTOS/Source/queue.c ****                                        const uint8_t ucQueueType )
 385:../FreeRTOS/Source/queue.c ****     {
 386:../FreeRTOS/Source/queue.c ****         Queue_t * pxNewQueue;
 387:../FreeRTOS/Source/queue.c ****         size_t xQueueSizeInBytes;
 388:../FreeRTOS/Source/queue.c ****         uint8_t * pucQueueStorage;
 389:../FreeRTOS/Source/queue.c **** 
 390:../FreeRTOS/Source/queue.c ****         configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 391:../FreeRTOS/Source/queue.c **** 
 392:../FreeRTOS/Source/queue.c ****         /* Allocate enough space to hold the maximum number of items that
 393:../FreeRTOS/Source/queue.c ****          * can be in the queue at any time.  It is valid for uxItemSize to be
 394:../FreeRTOS/Source/queue.c ****          * zero in the case the queue is used as a semaphore. */
 395:../FreeRTOS/Source/queue.c ****         xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception
 396:../FreeRTOS/Source/queue.c **** 
 397:../FreeRTOS/Source/queue.c ****         /* Check for multiplication overflow. */
 398:../FreeRTOS/Source/queue.c ****         configASSERT( ( uxItemSize == 0 ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) 
 399:../FreeRTOS/Source/queue.c **** 
 400:../FreeRTOS/Source/queue.c ****         /* Allocate the queue and storage area.  Justification for MISRA
 401:../FreeRTOS/Source/queue.c ****          * deviation as follows:  pvPortMalloc() always ensures returned memory
 402:../FreeRTOS/Source/queue.c ****          * blocks are aligned per the requirements of the MCU stack.  In this case
 403:../FreeRTOS/Source/queue.c ****          * pvPortMalloc() must return a pointer that is guaranteed to meet the
 404:../FreeRTOS/Source/queue.c ****          * alignment requirements of the Queue_t structure - which in this case
 405:../FreeRTOS/Source/queue.c ****          * is an int8_t *.  Therefore, whenever the stack alignment requirements
 406:../FreeRTOS/Source/queue.c ****          * are greater than or equal to the pointer to char requirements the cast
 407:../FreeRTOS/Source/queue.c ****          * is safe.  In other cases alignment requirements are not strict (one or
 408:../FreeRTOS/Source/queue.c ****          * two bytes). */
 409:../FreeRTOS/Source/queue.c ****         pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e
 410:../FreeRTOS/Source/queue.c **** 
 411:../FreeRTOS/Source/queue.c ****         if( pxNewQueue != NULL )
 412:../FreeRTOS/Source/queue.c ****         {
 413:../FreeRTOS/Source/queue.c ****             /* Jump past the queue structure to find the location of the queue
 414:../FreeRTOS/Source/queue.c ****              * storage area. */
 415:../FreeRTOS/Source/queue.c ****             pucQueueStorage = ( uint8_t * ) pxNewQueue;
 416:../FreeRTOS/Source/queue.c ****             pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char 
 417:../FreeRTOS/Source/queue.c **** 
 418:../FreeRTOS/Source/queue.c ****             #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
 419:../FreeRTOS/Source/queue.c ****                 {
 420:../FreeRTOS/Source/queue.c ****                     /* Queues can be created either statically or dynamically, so
 421:../FreeRTOS/Source/queue.c ****                      * note this task was created dynamically in case it is later
 422:../FreeRTOS/Source/queue.c ****                      * deleted. */
 423:../FreeRTOS/Source/queue.c ****                     pxNewQueue->ucStaticallyAllocated = pdFALSE;
 424:../FreeRTOS/Source/queue.c ****                 }
 425:../FreeRTOS/Source/queue.c ****             #endif /* configSUPPORT_STATIC_ALLOCATION */
 426:../FreeRTOS/Source/queue.c **** 
 427:../FreeRTOS/Source/queue.c ****             prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQu
 428:../FreeRTOS/Source/queue.c ****         }
 429:../FreeRTOS/Source/queue.c ****         else
 430:../FreeRTOS/Source/queue.c ****         {
 431:../FreeRTOS/Source/queue.c ****             traceQUEUE_CREATE_FAILED( ucQueueType );
 432:../FreeRTOS/Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
 433:../FreeRTOS/Source/queue.c ****         }
 434:../FreeRTOS/Source/queue.c **** 
 435:../FreeRTOS/Source/queue.c ****         return pxNewQueue;
 436:../FreeRTOS/Source/queue.c ****     }
 437:../FreeRTOS/Source/queue.c **** 
 438:../FreeRTOS/Source/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 439:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 440:../FreeRTOS/Source/queue.c **** 
 441:../FreeRTOS/Source/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
 442:../FreeRTOS/Source/queue.c ****                                    const UBaseType_t uxItemSize,
 443:../FreeRTOS/Source/queue.c ****                                    uint8_t * pucQueueStorage,
 444:../FreeRTOS/Source/queue.c ****                                    const uint8_t ucQueueType,
 445:../FreeRTOS/Source/queue.c ****                                    Queue_t * pxNewQueue )
 446:../FreeRTOS/Source/queue.c **** {
 447:../FreeRTOS/Source/queue.c ****     /* Remove compiler warnings about unused parameters should
 448:../FreeRTOS/Source/queue.c ****      * configUSE_TRACE_FACILITY not be set to 1. */
 449:../FreeRTOS/Source/queue.c ****     ( void ) ucQueueType;
 450:../FreeRTOS/Source/queue.c **** 
 451:../FreeRTOS/Source/queue.c ****     if( uxItemSize == ( UBaseType_t ) 0 )
 452:../FreeRTOS/Source/queue.c ****     {
 453:../FreeRTOS/Source/queue.c ****         /* No RAM was allocated for the queue storage area, but PC head cannot
 454:../FreeRTOS/Source/queue.c ****          * be set to NULL because NULL is used as a key to say the queue is used as
 455:../FreeRTOS/Source/queue.c ****          * a mutex.  Therefore just set pcHead to point to the queue as a benign
 456:../FreeRTOS/Source/queue.c ****          * value that is known to be within the memory map. */
 457:../FreeRTOS/Source/queue.c ****         pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 458:../FreeRTOS/Source/queue.c ****     }
 459:../FreeRTOS/Source/queue.c ****     else
 460:../FreeRTOS/Source/queue.c ****     {
 461:../FreeRTOS/Source/queue.c ****         /* Set the head to the start of the queue storage area. */
 462:../FreeRTOS/Source/queue.c ****         pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 463:../FreeRTOS/Source/queue.c ****     }
 464:../FreeRTOS/Source/queue.c **** 
 465:../FreeRTOS/Source/queue.c ****     /* Initialise the queue members as described where the queue type is
 466:../FreeRTOS/Source/queue.c ****      * defined. */
 467:../FreeRTOS/Source/queue.c ****     pxNewQueue->uxLength = uxQueueLength;
 468:../FreeRTOS/Source/queue.c ****     pxNewQueue->uxItemSize = uxItemSize;
 469:../FreeRTOS/Source/queue.c ****     ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 470:../FreeRTOS/Source/queue.c **** 
 471:../FreeRTOS/Source/queue.c ****     #if ( configUSE_TRACE_FACILITY == 1 )
 472:../FreeRTOS/Source/queue.c ****         {
 473:../FreeRTOS/Source/queue.c ****             pxNewQueue->ucQueueType = ucQueueType;
 474:../FreeRTOS/Source/queue.c ****         }
 475:../FreeRTOS/Source/queue.c ****     #endif /* configUSE_TRACE_FACILITY */
 476:../FreeRTOS/Source/queue.c **** 
 477:../FreeRTOS/Source/queue.c ****     #if ( configUSE_QUEUE_SETS == 1 )
 478:../FreeRTOS/Source/queue.c ****         {
 479:../FreeRTOS/Source/queue.c ****             pxNewQueue->pxQueueSetContainer = NULL;
 480:../FreeRTOS/Source/queue.c ****         }
 481:../FreeRTOS/Source/queue.c ****     #endif /* configUSE_QUEUE_SETS */
 482:../FreeRTOS/Source/queue.c **** 
 483:../FreeRTOS/Source/queue.c ****     traceQUEUE_CREATE( pxNewQueue );
 484:../FreeRTOS/Source/queue.c **** }
 485:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 486:../FreeRTOS/Source/queue.c **** 
 487:../FreeRTOS/Source/queue.c **** #if ( configUSE_MUTEXES == 1 )
 488:../FreeRTOS/Source/queue.c **** 
 489:../FreeRTOS/Source/queue.c ****     static void prvInitialiseMutex( Queue_t * pxNewQueue )
 490:../FreeRTOS/Source/queue.c ****     {
 491:../FreeRTOS/Source/queue.c ****         if( pxNewQueue != NULL )
 492:../FreeRTOS/Source/queue.c ****         {
 493:../FreeRTOS/Source/queue.c ****             /* The queue create function will set all the queue structure members
 494:../FreeRTOS/Source/queue.c ****             * correctly for a generic queue, but this function is creating a
 495:../FreeRTOS/Source/queue.c ****             * mutex.  Overwrite those members that need to be set differently -
 496:../FreeRTOS/Source/queue.c ****             * in particular the information required for priority inheritance. */
 497:../FreeRTOS/Source/queue.c ****             pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 498:../FreeRTOS/Source/queue.c ****             pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 499:../FreeRTOS/Source/queue.c **** 
 500:../FreeRTOS/Source/queue.c ****             /* In case this is a recursive mutex. */
 501:../FreeRTOS/Source/queue.c ****             pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
 502:../FreeRTOS/Source/queue.c **** 
 503:../FreeRTOS/Source/queue.c ****             traceCREATE_MUTEX( pxNewQueue );
 504:../FreeRTOS/Source/queue.c **** 
 505:../FreeRTOS/Source/queue.c ****             /* Start with the semaphore in the expected state. */
 506:../FreeRTOS/Source/queue.c ****             ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 507:../FreeRTOS/Source/queue.c ****         }
 508:../FreeRTOS/Source/queue.c ****         else
 509:../FreeRTOS/Source/queue.c ****         {
 510:../FreeRTOS/Source/queue.c ****             traceCREATE_MUTEX_FAILED();
 511:../FreeRTOS/Source/queue.c ****         }
 512:../FreeRTOS/Source/queue.c ****     }
 513:../FreeRTOS/Source/queue.c **** 
 514:../FreeRTOS/Source/queue.c **** #endif /* configUSE_MUTEXES */
 515:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 516:../FreeRTOS/Source/queue.c **** 
 517:../FreeRTOS/Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 518:../FreeRTOS/Source/queue.c **** 
 519:../FreeRTOS/Source/queue.c ****     QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
 520:../FreeRTOS/Source/queue.c ****     {
 521:../FreeRTOS/Source/queue.c ****         QueueHandle_t xNewQueue;
 522:../FreeRTOS/Source/queue.c ****         const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 523:../FreeRTOS/Source/queue.c **** 
 524:../FreeRTOS/Source/queue.c ****         xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 525:../FreeRTOS/Source/queue.c ****         prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 526:../FreeRTOS/Source/queue.c **** 
 527:../FreeRTOS/Source/queue.c ****         return xNewQueue;
 528:../FreeRTOS/Source/queue.c ****     }
 529:../FreeRTOS/Source/queue.c **** 
 530:../FreeRTOS/Source/queue.c **** #endif /* configUSE_MUTEXES */
 531:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 532:../FreeRTOS/Source/queue.c **** 
 533:../FreeRTOS/Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 534:../FreeRTOS/Source/queue.c **** 
 535:../FreeRTOS/Source/queue.c ****     QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType,
 536:../FreeRTOS/Source/queue.c ****                                            StaticQueue_t * pxStaticQueue )
 537:../FreeRTOS/Source/queue.c ****     {
 538:../FreeRTOS/Source/queue.c ****         QueueHandle_t xNewQueue;
 539:../FreeRTOS/Source/queue.c ****         const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 540:../FreeRTOS/Source/queue.c **** 
 541:../FreeRTOS/Source/queue.c ****         /* Prevent compiler warnings about unused parameters if
 542:../FreeRTOS/Source/queue.c ****          * configUSE_TRACE_FACILITY does not equal 1. */
 543:../FreeRTOS/Source/queue.c ****         ( void ) ucQueueType;
 544:../FreeRTOS/Source/queue.c **** 
 545:../FreeRTOS/Source/queue.c ****         xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQ
 546:../FreeRTOS/Source/queue.c ****         prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 547:../FreeRTOS/Source/queue.c **** 
 548:../FreeRTOS/Source/queue.c ****         return xNewQueue;
 549:../FreeRTOS/Source/queue.c ****     }
 550:../FreeRTOS/Source/queue.c **** 
 551:../FreeRTOS/Source/queue.c **** #endif /* configUSE_MUTEXES */
 552:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 553:../FreeRTOS/Source/queue.c **** 
 554:../FreeRTOS/Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 555:../FreeRTOS/Source/queue.c **** 
 556:../FreeRTOS/Source/queue.c ****     TaskHandle_t xQueueGetMutexHolder( QueueHandle_t xSemaphore )
 557:../FreeRTOS/Source/queue.c ****     {
 558:../FreeRTOS/Source/queue.c ****         TaskHandle_t pxReturn;
 559:../FreeRTOS/Source/queue.c ****         Queue_t * const pxSemaphore = ( Queue_t * ) xSemaphore;
 560:../FreeRTOS/Source/queue.c **** 
 561:../FreeRTOS/Source/queue.c ****         /* This function is called by xSemaphoreGetMutexHolder(), and should not
 562:../FreeRTOS/Source/queue.c ****          * be called directly.  Note:  This is a good way of determining if the
 563:../FreeRTOS/Source/queue.c ****          * calling task is the mutex holder, but not a good way of determining the
 564:../FreeRTOS/Source/queue.c ****          * identity of the mutex holder, as the holder may change between the
 565:../FreeRTOS/Source/queue.c ****          * following critical section exiting and the function returning. */
 566:../FreeRTOS/Source/queue.c ****         taskENTER_CRITICAL();
 567:../FreeRTOS/Source/queue.c ****         {
 568:../FreeRTOS/Source/queue.c ****             if( pxSemaphore->uxQueueType == queueQUEUE_IS_MUTEX )
 569:../FreeRTOS/Source/queue.c ****             {
 570:../FreeRTOS/Source/queue.c ****                 pxReturn = pxSemaphore->u.xSemaphore.xMutexHolder;
 571:../FreeRTOS/Source/queue.c ****             }
 572:../FreeRTOS/Source/queue.c ****             else
 573:../FreeRTOS/Source/queue.c ****             {
 574:../FreeRTOS/Source/queue.c ****                 pxReturn = NULL;
 575:../FreeRTOS/Source/queue.c ****             }
 576:../FreeRTOS/Source/queue.c ****         }
 577:../FreeRTOS/Source/queue.c ****         taskEXIT_CRITICAL();
 578:../FreeRTOS/Source/queue.c **** 
 579:../FreeRTOS/Source/queue.c ****         return pxReturn;
 580:../FreeRTOS/Source/queue.c ****     } /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 581:../FreeRTOS/Source/queue.c **** 
 582:../FreeRTOS/Source/queue.c **** #endif /* if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) ) */
 583:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 584:../FreeRTOS/Source/queue.c **** 
 585:../FreeRTOS/Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 586:../FreeRTOS/Source/queue.c **** 
 587:../FreeRTOS/Source/queue.c ****     TaskHandle_t xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore )
 588:../FreeRTOS/Source/queue.c ****     {
 589:../FreeRTOS/Source/queue.c ****         TaskHandle_t pxReturn;
 590:../FreeRTOS/Source/queue.c **** 
 591:../FreeRTOS/Source/queue.c ****         configASSERT( xSemaphore );
 592:../FreeRTOS/Source/queue.c **** 
 593:../FreeRTOS/Source/queue.c ****         /* Mutexes cannot be used in interrupt service routines, so the mutex
 594:../FreeRTOS/Source/queue.c ****          * holder should not change in an ISR, and therefore a critical section is
 595:../FreeRTOS/Source/queue.c ****          * not required here. */
 596:../FreeRTOS/Source/queue.c ****         if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
 597:../FreeRTOS/Source/queue.c ****         {
 598:../FreeRTOS/Source/queue.c ****             pxReturn = ( ( Queue_t * ) xSemaphore )->u.xSemaphore.xMutexHolder;
 599:../FreeRTOS/Source/queue.c ****         }
 600:../FreeRTOS/Source/queue.c ****         else
 601:../FreeRTOS/Source/queue.c ****         {
 602:../FreeRTOS/Source/queue.c ****             pxReturn = NULL;
 603:../FreeRTOS/Source/queue.c ****         }
 604:../FreeRTOS/Source/queue.c **** 
 605:../FreeRTOS/Source/queue.c ****         return pxReturn;
 606:../FreeRTOS/Source/queue.c ****     } /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 607:../FreeRTOS/Source/queue.c **** 
 608:../FreeRTOS/Source/queue.c **** #endif /* if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) ) */
 609:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 610:../FreeRTOS/Source/queue.c **** 
 611:../FreeRTOS/Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 612:../FreeRTOS/Source/queue.c **** 
 613:../FreeRTOS/Source/queue.c ****     BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
 614:../FreeRTOS/Source/queue.c ****     {
 615:../FreeRTOS/Source/queue.c ****         BaseType_t xReturn;
 616:../FreeRTOS/Source/queue.c ****         Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 617:../FreeRTOS/Source/queue.c **** 
 618:../FreeRTOS/Source/queue.c ****         configASSERT( pxMutex );
 619:../FreeRTOS/Source/queue.c **** 
 620:../FreeRTOS/Source/queue.c ****         /* If this is the task that holds the mutex then xMutexHolder will not
 621:../FreeRTOS/Source/queue.c ****          * change outside of this task.  If this task does not hold the mutex then
 622:../FreeRTOS/Source/queue.c ****          * pxMutexHolder can never coincidentally equal the tasks handle, and as
 623:../FreeRTOS/Source/queue.c ****          * this is the only condition we are interested in it does not matter if
 624:../FreeRTOS/Source/queue.c ****          * pxMutexHolder is accessed simultaneously by another task.  Therefore no
 625:../FreeRTOS/Source/queue.c ****          * mutual exclusion is required to test the pxMutexHolder variable. */
 626:../FreeRTOS/Source/queue.c ****         if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 627:../FreeRTOS/Source/queue.c ****         {
 628:../FreeRTOS/Source/queue.c ****             traceGIVE_MUTEX_RECURSIVE( pxMutex );
 629:../FreeRTOS/Source/queue.c **** 
 630:../FreeRTOS/Source/queue.c ****             /* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
 631:../FreeRTOS/Source/queue.c ****              * the task handle, therefore no underflow check is required.  Also,
 632:../FreeRTOS/Source/queue.c ****              * uxRecursiveCallCount is only modified by the mutex holder, and as
 633:../FreeRTOS/Source/queue.c ****              * there can only be one, no mutual exclusion is required to modify the
 634:../FreeRTOS/Source/queue.c ****              * uxRecursiveCallCount member. */
 635:../FreeRTOS/Source/queue.c ****             ( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
 636:../FreeRTOS/Source/queue.c **** 
 637:../FreeRTOS/Source/queue.c ****             /* Has the recursive call count unwound to 0? */
 638:../FreeRTOS/Source/queue.c ****             if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 639:../FreeRTOS/Source/queue.c ****             {
 640:../FreeRTOS/Source/queue.c ****                 /* Return the mutex.  This will automatically unblock any other
 641:../FreeRTOS/Source/queue.c ****                  * task that might be waiting to access the mutex. */
 642:../FreeRTOS/Source/queue.c ****                 ( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO
 643:../FreeRTOS/Source/queue.c ****             }
 644:../FreeRTOS/Source/queue.c ****             else
 645:../FreeRTOS/Source/queue.c ****             {
 646:../FreeRTOS/Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
 647:../FreeRTOS/Source/queue.c ****             }
 648:../FreeRTOS/Source/queue.c **** 
 649:../FreeRTOS/Source/queue.c ****             xReturn = pdPASS;
 650:../FreeRTOS/Source/queue.c ****         }
 651:../FreeRTOS/Source/queue.c ****         else
 652:../FreeRTOS/Source/queue.c ****         {
 653:../FreeRTOS/Source/queue.c ****             /* The mutex cannot be given because the calling task is not the
 654:../FreeRTOS/Source/queue.c ****              * holder. */
 655:../FreeRTOS/Source/queue.c ****             xReturn = pdFAIL;
 656:../FreeRTOS/Source/queue.c **** 
 657:../FreeRTOS/Source/queue.c ****             traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 658:../FreeRTOS/Source/queue.c ****         }
 659:../FreeRTOS/Source/queue.c **** 
 660:../FreeRTOS/Source/queue.c ****         return xReturn;
 661:../FreeRTOS/Source/queue.c ****     }
 662:../FreeRTOS/Source/queue.c **** 
 663:../FreeRTOS/Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 664:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 665:../FreeRTOS/Source/queue.c **** 
 666:../FreeRTOS/Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 667:../FreeRTOS/Source/queue.c **** 
 668:../FreeRTOS/Source/queue.c ****     BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex,
 669:../FreeRTOS/Source/queue.c ****                                          TickType_t xTicksToWait )
 670:../FreeRTOS/Source/queue.c ****     {
 671:../FreeRTOS/Source/queue.c ****         BaseType_t xReturn;
 672:../FreeRTOS/Source/queue.c ****         Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 673:../FreeRTOS/Source/queue.c **** 
 674:../FreeRTOS/Source/queue.c ****         configASSERT( pxMutex );
 675:../FreeRTOS/Source/queue.c **** 
 676:../FreeRTOS/Source/queue.c ****         /* Comments regarding mutual exclusion as per those within
 677:../FreeRTOS/Source/queue.c ****          * xQueueGiveMutexRecursive(). */
 678:../FreeRTOS/Source/queue.c **** 
 679:../FreeRTOS/Source/queue.c ****         traceTAKE_MUTEX_RECURSIVE( pxMutex );
 680:../FreeRTOS/Source/queue.c **** 
 681:../FreeRTOS/Source/queue.c ****         if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 682:../FreeRTOS/Source/queue.c ****         {
 683:../FreeRTOS/Source/queue.c ****             ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 684:../FreeRTOS/Source/queue.c ****             xReturn = pdPASS;
 685:../FreeRTOS/Source/queue.c ****         }
 686:../FreeRTOS/Source/queue.c ****         else
 687:../FreeRTOS/Source/queue.c ****         {
 688:../FreeRTOS/Source/queue.c ****             xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
 689:../FreeRTOS/Source/queue.c **** 
 690:../FreeRTOS/Source/queue.c ****             /* pdPASS will only be returned if the mutex was successfully
 691:../FreeRTOS/Source/queue.c ****              * obtained.  The calling task may have entered the Blocked state
 692:../FreeRTOS/Source/queue.c ****              * before reaching here. */
 693:../FreeRTOS/Source/queue.c ****             if( xReturn != pdFAIL )
 694:../FreeRTOS/Source/queue.c ****             {
 695:../FreeRTOS/Source/queue.c ****                 ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 696:../FreeRTOS/Source/queue.c ****             }
 697:../FreeRTOS/Source/queue.c ****             else
 698:../FreeRTOS/Source/queue.c ****             {
 699:../FreeRTOS/Source/queue.c ****                 traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
 700:../FreeRTOS/Source/queue.c ****             }
 701:../FreeRTOS/Source/queue.c ****         }
 702:../FreeRTOS/Source/queue.c **** 
 703:../FreeRTOS/Source/queue.c ****         return xReturn;
 704:../FreeRTOS/Source/queue.c ****     }
 705:../FreeRTOS/Source/queue.c **** 
 706:../FreeRTOS/Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 707:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 708:../FreeRTOS/Source/queue.c **** 
 709:../FreeRTOS/Source/queue.c **** #if ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 710:../FreeRTOS/Source/queue.c **** 
 711:../FreeRTOS/Source/queue.c ****     QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount,
 712:../FreeRTOS/Source/queue.c ****                                                        const UBaseType_t uxInitialCount,
 713:../FreeRTOS/Source/queue.c ****                                                        StaticQueue_t * pxStaticQueue )
 714:../FreeRTOS/Source/queue.c ****     {
 715:../FreeRTOS/Source/queue.c ****         QueueHandle_t xHandle;
 716:../FreeRTOS/Source/queue.c **** 
 717:../FreeRTOS/Source/queue.c ****         configASSERT( uxMaxCount != 0 );
 718:../FreeRTOS/Source/queue.c ****         configASSERT( uxInitialCount <= uxMaxCount );
 719:../FreeRTOS/Source/queue.c **** 
 720:../FreeRTOS/Source/queue.c ****         xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, px
 721:../FreeRTOS/Source/queue.c **** 
 722:../FreeRTOS/Source/queue.c ****         if( xHandle != NULL )
 723:../FreeRTOS/Source/queue.c ****         {
 724:../FreeRTOS/Source/queue.c ****             ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 725:../FreeRTOS/Source/queue.c **** 
 726:../FreeRTOS/Source/queue.c ****             traceCREATE_COUNTING_SEMAPHORE();
 727:../FreeRTOS/Source/queue.c ****         }
 728:../FreeRTOS/Source/queue.c ****         else
 729:../FreeRTOS/Source/queue.c ****         {
 730:../FreeRTOS/Source/queue.c ****             traceCREATE_COUNTING_SEMAPHORE_FAILED();
 731:../FreeRTOS/Source/queue.c ****         }
 732:../FreeRTOS/Source/queue.c **** 
 733:../FreeRTOS/Source/queue.c ****         return xHandle;
 734:../FreeRTOS/Source/queue.c ****     }
 735:../FreeRTOS/Source/queue.c **** 
 736:../FreeRTOS/Source/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 737:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 738:../FreeRTOS/Source/queue.c **** 
 739:../FreeRTOS/Source/queue.c **** #if ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 740:../FreeRTOS/Source/queue.c **** 
 741:../FreeRTOS/Source/queue.c ****     QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount,
 742:../FreeRTOS/Source/queue.c ****                                                  const UBaseType_t uxInitialCount )
 743:../FreeRTOS/Source/queue.c ****     {
 744:../FreeRTOS/Source/queue.c ****         QueueHandle_t xHandle;
 745:../FreeRTOS/Source/queue.c **** 
 746:../FreeRTOS/Source/queue.c ****         configASSERT( uxMaxCount != 0 );
 747:../FreeRTOS/Source/queue.c ****         configASSERT( uxInitialCount <= uxMaxCount );
 748:../FreeRTOS/Source/queue.c **** 
 749:../FreeRTOS/Source/queue.c ****         xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYP
 750:../FreeRTOS/Source/queue.c **** 
 751:../FreeRTOS/Source/queue.c ****         if( xHandle != NULL )
 752:../FreeRTOS/Source/queue.c ****         {
 753:../FreeRTOS/Source/queue.c ****             ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 754:../FreeRTOS/Source/queue.c **** 
 755:../FreeRTOS/Source/queue.c ****             traceCREATE_COUNTING_SEMAPHORE();
 756:../FreeRTOS/Source/queue.c ****         }
 757:../FreeRTOS/Source/queue.c ****         else
 758:../FreeRTOS/Source/queue.c ****         {
 759:../FreeRTOS/Source/queue.c ****             traceCREATE_COUNTING_SEMAPHORE_FAILED();
 760:../FreeRTOS/Source/queue.c ****         }
 761:../FreeRTOS/Source/queue.c **** 
 762:../FreeRTOS/Source/queue.c ****         return xHandle;
 763:../FreeRTOS/Source/queue.c ****     }
 764:../FreeRTOS/Source/queue.c **** 
 765:../FreeRTOS/Source/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 766:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 767:../FreeRTOS/Source/queue.c **** 
 768:../FreeRTOS/Source/queue.c **** BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
 769:../FreeRTOS/Source/queue.c ****                               const void * const pvItemToQueue,
 770:../FreeRTOS/Source/queue.c ****                               TickType_t xTicksToWait,
 771:../FreeRTOS/Source/queue.c ****                               const BaseType_t xCopyPosition )
 772:../FreeRTOS/Source/queue.c **** {
 773:../FreeRTOS/Source/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 774:../FreeRTOS/Source/queue.c ****     TimeOut_t xTimeOut;
 775:../FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 776:../FreeRTOS/Source/queue.c **** 
 777:../FreeRTOS/Source/queue.c ****     configASSERT( pxQueue );
 778:../FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
 779:../FreeRTOS/Source/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 780:../FreeRTOS/Source/queue.c ****     #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 781:../FreeRTOS/Source/queue.c ****         {
 782:../FreeRTOS/Source/queue.c ****             configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToW
 783:../FreeRTOS/Source/queue.c ****         }
 784:../FreeRTOS/Source/queue.c ****     #endif
 785:../FreeRTOS/Source/queue.c **** 
 786:../FreeRTOS/Source/queue.c ****     /*lint -save -e904 This function relaxes the coding standard somewhat to
 787:../FreeRTOS/Source/queue.c ****      * allow return statements within the function itself.  This is done in the
 788:../FreeRTOS/Source/queue.c ****      * interest of execution time efficiency. */
 789:../FreeRTOS/Source/queue.c ****     for( ; ; )
 790:../FreeRTOS/Source/queue.c ****     {
 791:../FreeRTOS/Source/queue.c ****         taskENTER_CRITICAL();
 792:../FreeRTOS/Source/queue.c ****         {
 793:../FreeRTOS/Source/queue.c ****             /* Is there room on the queue now?  The running task must be the
 794:../FreeRTOS/Source/queue.c ****              * highest priority task wanting to access the queue.  If the head item
 795:../FreeRTOS/Source/queue.c ****              * in the queue is to be overwritten then it does not matter if the
 796:../FreeRTOS/Source/queue.c ****              * queue is full. */
 797:../FreeRTOS/Source/queue.c ****             if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERW
 798:../FreeRTOS/Source/queue.c ****             {
 799:../FreeRTOS/Source/queue.c ****                 traceQUEUE_SEND( pxQueue );
 800:../FreeRTOS/Source/queue.c **** 
 801:../FreeRTOS/Source/queue.c ****                 #if ( configUSE_QUEUE_SETS == 1 )
 802:../FreeRTOS/Source/queue.c ****                     {
 803:../FreeRTOS/Source/queue.c ****                         const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 804:../FreeRTOS/Source/queue.c **** 
 805:../FreeRTOS/Source/queue.c ****                         xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition 
 806:../FreeRTOS/Source/queue.c **** 
 807:../FreeRTOS/Source/queue.c ****                         if( pxQueue->pxQueueSetContainer != NULL )
 808:../FreeRTOS/Source/queue.c ****                         {
 809:../FreeRTOS/Source/queue.c ****                             if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting 
 810:../FreeRTOS/Source/queue.c ****                             {
 811:../FreeRTOS/Source/queue.c ****                                 /* Do not notify the queue set as an existing item
 812:../FreeRTOS/Source/queue.c ****                                  * was overwritten in the queue so the number of items
 813:../FreeRTOS/Source/queue.c ****                                  * in the queue has not changed. */
 814:../FreeRTOS/Source/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
 815:../FreeRTOS/Source/queue.c ****                             }
 816:../FreeRTOS/Source/queue.c ****                             else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
 817:../FreeRTOS/Source/queue.c ****                             {
 818:../FreeRTOS/Source/queue.c ****                                 /* The queue is a member of a queue set, and posting
 819:../FreeRTOS/Source/queue.c ****                                  * to the queue set caused a higher priority task to
 820:../FreeRTOS/Source/queue.c ****                                  * unblock. A context switch is required. */
 821:../FreeRTOS/Source/queue.c ****                                 queueYIELD_IF_USING_PREEMPTION();
 822:../FreeRTOS/Source/queue.c ****                             }
 823:../FreeRTOS/Source/queue.c ****                             else
 824:../FreeRTOS/Source/queue.c ****                             {
 825:../FreeRTOS/Source/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
 826:../FreeRTOS/Source/queue.c ****                             }
 827:../FreeRTOS/Source/queue.c ****                         }
 828:../FreeRTOS/Source/queue.c ****                         else
 829:../FreeRTOS/Source/queue.c ****                         {
 830:../FreeRTOS/Source/queue.c ****                             /* If there was a task waiting for data to arrive on the
 831:../FreeRTOS/Source/queue.c ****                              * queue then unblock it now. */
 832:../FreeRTOS/Source/queue.c ****                             if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALS
 833:../FreeRTOS/Source/queue.c ****                             {
 834:../FreeRTOS/Source/queue.c ****                                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) 
 835:../FreeRTOS/Source/queue.c ****                                 {
 836:../FreeRTOS/Source/queue.c ****                                     /* The unblocked task has a priority higher than
 837:../FreeRTOS/Source/queue.c ****                                      * our own so yield immediately.  Yes it is ok to
 838:../FreeRTOS/Source/queue.c ****                                      * do this from within the critical section - the
 839:../FreeRTOS/Source/queue.c ****                                      * kernel takes care of that. */
 840:../FreeRTOS/Source/queue.c ****                                     queueYIELD_IF_USING_PREEMPTION();
 841:../FreeRTOS/Source/queue.c ****                                 }
 842:../FreeRTOS/Source/queue.c ****                                 else
 843:../FreeRTOS/Source/queue.c ****                                 {
 844:../FreeRTOS/Source/queue.c ****                                     mtCOVERAGE_TEST_MARKER();
 845:../FreeRTOS/Source/queue.c ****                                 }
 846:../FreeRTOS/Source/queue.c ****                             }
 847:../FreeRTOS/Source/queue.c ****                             else if( xYieldRequired != pdFALSE )
 848:../FreeRTOS/Source/queue.c ****                             {
 849:../FreeRTOS/Source/queue.c ****                                 /* This path is a special case that will only get
 850:../FreeRTOS/Source/queue.c ****                                  * executed if the task was holding multiple mutexes
 851:../FreeRTOS/Source/queue.c ****                                  * and the mutexes were given back in an order that is
 852:../FreeRTOS/Source/queue.c ****                                  * different to that in which they were taken. */
 853:../FreeRTOS/Source/queue.c ****                                 queueYIELD_IF_USING_PREEMPTION();
 854:../FreeRTOS/Source/queue.c ****                             }
 855:../FreeRTOS/Source/queue.c ****                             else
 856:../FreeRTOS/Source/queue.c ****                             {
 857:../FreeRTOS/Source/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
 858:../FreeRTOS/Source/queue.c ****                             }
 859:../FreeRTOS/Source/queue.c ****                         }
 860:../FreeRTOS/Source/queue.c ****                     }
 861:../FreeRTOS/Source/queue.c ****                 #else /* configUSE_QUEUE_SETS */
 862:../FreeRTOS/Source/queue.c ****                     {
 863:../FreeRTOS/Source/queue.c ****                         xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition 
 864:../FreeRTOS/Source/queue.c **** 
 865:../FreeRTOS/Source/queue.c ****                         /* If there was a task waiting for data to arrive on the
 866:../FreeRTOS/Source/queue.c ****                          * queue then unblock it now. */
 867:../FreeRTOS/Source/queue.c ****                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 868:../FreeRTOS/Source/queue.c ****                         {
 869:../FreeRTOS/Source/queue.c ****                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) !=
 870:../FreeRTOS/Source/queue.c ****                             {
 871:../FreeRTOS/Source/queue.c ****                                 /* The unblocked task has a priority higher than
 872:../FreeRTOS/Source/queue.c ****                                  * our own so yield immediately.  Yes it is ok to do
 873:../FreeRTOS/Source/queue.c ****                                  * this from within the critical section - the kernel
 874:../FreeRTOS/Source/queue.c ****                                  * takes care of that. */
 875:../FreeRTOS/Source/queue.c ****                                 queueYIELD_IF_USING_PREEMPTION();
 876:../FreeRTOS/Source/queue.c ****                             }
 877:../FreeRTOS/Source/queue.c ****                             else
 878:../FreeRTOS/Source/queue.c ****                             {
 879:../FreeRTOS/Source/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
 880:../FreeRTOS/Source/queue.c ****                             }
 881:../FreeRTOS/Source/queue.c ****                         }
 882:../FreeRTOS/Source/queue.c ****                         else if( xYieldRequired != pdFALSE )
 883:../FreeRTOS/Source/queue.c ****                         {
 884:../FreeRTOS/Source/queue.c ****                             /* This path is a special case that will only get
 885:../FreeRTOS/Source/queue.c ****                              * executed if the task was holding multiple mutexes and
 886:../FreeRTOS/Source/queue.c ****                              * the mutexes were given back in an order that is
 887:../FreeRTOS/Source/queue.c ****                              * different to that in which they were taken. */
 888:../FreeRTOS/Source/queue.c ****                             queueYIELD_IF_USING_PREEMPTION();
 889:../FreeRTOS/Source/queue.c ****                         }
 890:../FreeRTOS/Source/queue.c ****                         else
 891:../FreeRTOS/Source/queue.c ****                         {
 892:../FreeRTOS/Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
 893:../FreeRTOS/Source/queue.c ****                         }
 894:../FreeRTOS/Source/queue.c ****                     }
 895:../FreeRTOS/Source/queue.c ****                 #endif /* configUSE_QUEUE_SETS */
 896:../FreeRTOS/Source/queue.c **** 
 897:../FreeRTOS/Source/queue.c ****                 taskEXIT_CRITICAL();
 898:../FreeRTOS/Source/queue.c ****                 return pdPASS;
 899:../FreeRTOS/Source/queue.c ****             }
 900:../FreeRTOS/Source/queue.c ****             else
 901:../FreeRTOS/Source/queue.c ****             {
 902:../FreeRTOS/Source/queue.c ****                 if( xTicksToWait == ( TickType_t ) 0 )
 903:../FreeRTOS/Source/queue.c ****                 {
 904:../FreeRTOS/Source/queue.c ****                     /* The queue was full and no block time is specified (or
 905:../FreeRTOS/Source/queue.c ****                      * the block time has expired) so leave now. */
 906:../FreeRTOS/Source/queue.c ****                     taskEXIT_CRITICAL();
 907:../FreeRTOS/Source/queue.c **** 
 908:../FreeRTOS/Source/queue.c ****                     /* Return to the original privilege level before exiting
 909:../FreeRTOS/Source/queue.c ****                      * the function. */
 910:../FreeRTOS/Source/queue.c ****                     traceQUEUE_SEND_FAILED( pxQueue );
 911:../FreeRTOS/Source/queue.c ****                     return errQUEUE_FULL;
 912:../FreeRTOS/Source/queue.c ****                 }
 913:../FreeRTOS/Source/queue.c ****                 else if( xEntryTimeSet == pdFALSE )
 914:../FreeRTOS/Source/queue.c ****                 {
 915:../FreeRTOS/Source/queue.c ****                     /* The queue was full and a block time was specified so
 916:../FreeRTOS/Source/queue.c ****                      * configure the timeout structure. */
 917:../FreeRTOS/Source/queue.c ****                     vTaskInternalSetTimeOutState( &xTimeOut );
 918:../FreeRTOS/Source/queue.c ****                     xEntryTimeSet = pdTRUE;
 919:../FreeRTOS/Source/queue.c ****                 }
 920:../FreeRTOS/Source/queue.c ****                 else
 921:../FreeRTOS/Source/queue.c ****                 {
 922:../FreeRTOS/Source/queue.c ****                     /* Entry time was already set. */
 923:../FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
 924:../FreeRTOS/Source/queue.c ****                 }
 925:../FreeRTOS/Source/queue.c ****             }
 926:../FreeRTOS/Source/queue.c ****         }
 927:../FreeRTOS/Source/queue.c ****         taskEXIT_CRITICAL();
 928:../FreeRTOS/Source/queue.c **** 
 929:../FreeRTOS/Source/queue.c ****         /* Interrupts and other tasks can send to and receive from the queue
 930:../FreeRTOS/Source/queue.c ****          * now the critical section has been exited. */
 931:../FreeRTOS/Source/queue.c **** 
 932:../FreeRTOS/Source/queue.c ****         vTaskSuspendAll();
 933:../FreeRTOS/Source/queue.c ****         prvLockQueue( pxQueue );
 934:../FreeRTOS/Source/queue.c **** 
 935:../FreeRTOS/Source/queue.c ****         /* Update the timeout state to see if it has expired yet. */
 936:../FreeRTOS/Source/queue.c ****         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 937:../FreeRTOS/Source/queue.c ****         {
 938:../FreeRTOS/Source/queue.c ****             if( prvIsQueueFull( pxQueue ) != pdFALSE )
 939:../FreeRTOS/Source/queue.c ****             {
 940:../FreeRTOS/Source/queue.c ****                 traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 941:../FreeRTOS/Source/queue.c ****                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 942:../FreeRTOS/Source/queue.c **** 
 943:../FreeRTOS/Source/queue.c ****                 /* Unlocking the queue means queue events can effect the
 944:../FreeRTOS/Source/queue.c ****                  * event list.  It is possible that interrupts occurring now
 945:../FreeRTOS/Source/queue.c ****                  * remove this task from the event list again - but as the
 946:../FreeRTOS/Source/queue.c ****                  * scheduler is suspended the task will go onto the pending
 947:../FreeRTOS/Source/queue.c ****                  * ready last instead of the actual ready list. */
 948:../FreeRTOS/Source/queue.c ****                 prvUnlockQueue( pxQueue );
 949:../FreeRTOS/Source/queue.c **** 
 950:../FreeRTOS/Source/queue.c ****                 /* Resuming the scheduler will move tasks from the pending
 951:../FreeRTOS/Source/queue.c ****                  * ready list into the ready list - so it is feasible that this
 952:../FreeRTOS/Source/queue.c ****                  * task is already in a ready list before it yields - in which
 953:../FreeRTOS/Source/queue.c ****                  * case the yield will not cause a context switch unless there
 954:../FreeRTOS/Source/queue.c ****                  * is also a higher priority task in the pending ready list. */
 955:../FreeRTOS/Source/queue.c ****                 if( xTaskResumeAll() == pdFALSE )
 956:../FreeRTOS/Source/queue.c ****                 {
 957:../FreeRTOS/Source/queue.c ****                     portYIELD_WITHIN_API();
 958:../FreeRTOS/Source/queue.c ****                 }
 959:../FreeRTOS/Source/queue.c ****             }
 960:../FreeRTOS/Source/queue.c ****             else
 961:../FreeRTOS/Source/queue.c ****             {
 962:../FreeRTOS/Source/queue.c ****                 /* Try again. */
 963:../FreeRTOS/Source/queue.c ****                 prvUnlockQueue( pxQueue );
 964:../FreeRTOS/Source/queue.c ****                 ( void ) xTaskResumeAll();
 965:../FreeRTOS/Source/queue.c ****             }
 966:../FreeRTOS/Source/queue.c ****         }
 967:../FreeRTOS/Source/queue.c ****         else
 968:../FreeRTOS/Source/queue.c ****         {
 969:../FreeRTOS/Source/queue.c ****             /* The timeout has expired. */
 970:../FreeRTOS/Source/queue.c ****             prvUnlockQueue( pxQueue );
 971:../FreeRTOS/Source/queue.c ****             ( void ) xTaskResumeAll();
 972:../FreeRTOS/Source/queue.c **** 
 973:../FreeRTOS/Source/queue.c ****             traceQUEUE_SEND_FAILED( pxQueue );
 974:../FreeRTOS/Source/queue.c ****             return errQUEUE_FULL;
 975:../FreeRTOS/Source/queue.c ****         }
 976:../FreeRTOS/Source/queue.c ****     } /*lint -restore */
 977:../FreeRTOS/Source/queue.c **** }
 978:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 979:../FreeRTOS/Source/queue.c **** 
 980:../FreeRTOS/Source/queue.c **** BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
 981:../FreeRTOS/Source/queue.c ****                                      const void * const pvItemToQueue,
 982:../FreeRTOS/Source/queue.c ****                                      BaseType_t * const pxHigherPriorityTaskWoken,
 983:../FreeRTOS/Source/queue.c ****                                      const BaseType_t xCopyPosition )
 984:../FreeRTOS/Source/queue.c **** {
 985:../FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
 986:../FreeRTOS/Source/queue.c ****     UBaseType_t uxSavedInterruptStatus;
 987:../FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 988:../FreeRTOS/Source/queue.c **** 
 989:../FreeRTOS/Source/queue.c ****     configASSERT( pxQueue );
 990:../FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
 991:../FreeRTOS/Source/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 992:../FreeRTOS/Source/queue.c **** 
 993:../FreeRTOS/Source/queue.c ****     /* RTOS ports that support interrupt nesting have the concept of a maximum
 994:../FreeRTOS/Source/queue.c ****      * system call (or maximum API call) interrupt priority.  Interrupts that are
 995:../FreeRTOS/Source/queue.c ****      * above the maximum system call priority are kept permanently enabled, even
 996:../FreeRTOS/Source/queue.c ****      * when the RTOS kernel is in a critical section, but cannot make any calls to
 997:../FreeRTOS/Source/queue.c ****      * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
 998:../FreeRTOS/Source/queue.c ****      * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
 999:../FreeRTOS/Source/queue.c ****      * failure if a FreeRTOS API function is called from an interrupt that has been
1000:../FreeRTOS/Source/queue.c ****      * assigned a priority above the configured maximum system call priority.
1001:../FreeRTOS/Source/queue.c ****      * Only FreeRTOS functions that end in FromISR can be called from interrupts
1002:../FreeRTOS/Source/queue.c ****      * that have been assigned a priority at or (logically) below the maximum
1003:../FreeRTOS/Source/queue.c ****      * system call interrupt priority.  FreeRTOS maintains a separate interrupt
1004:../FreeRTOS/Source/queue.c ****      * safe API to ensure interrupt entry is as fast and as simple as possible.
1005:../FreeRTOS/Source/queue.c ****      * More information (albeit Cortex-M specific) is provided on the following
1006:../FreeRTOS/Source/queue.c ****      * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
1007:../FreeRTOS/Source/queue.c ****     portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1008:../FreeRTOS/Source/queue.c **** 
1009:../FreeRTOS/Source/queue.c ****     /* Similar to xQueueGenericSend, except without blocking if there is no room
1010:../FreeRTOS/Source/queue.c ****      * in the queue.  Also don't directly wake a task that was blocked on a queue
1011:../FreeRTOS/Source/queue.c ****      * read, instead return a flag to say whether a context switch is required or
1012:../FreeRTOS/Source/queue.c ****      * not (i.e. has a task with a higher priority than us been woken by this
1013:../FreeRTOS/Source/queue.c ****      * post). */
1014:../FreeRTOS/Source/queue.c ****     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1015:../FreeRTOS/Source/queue.c ****     {
1016:../FreeRTOS/Source/queue.c ****         if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE
1017:../FreeRTOS/Source/queue.c ****         {
1018:../FreeRTOS/Source/queue.c ****             const int8_t cTxLock = pxQueue->cTxLock;
1019:../FreeRTOS/Source/queue.c ****             const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
1020:../FreeRTOS/Source/queue.c **** 
1021:../FreeRTOS/Source/queue.c ****             traceQUEUE_SEND_FROM_ISR( pxQueue );
1022:../FreeRTOS/Source/queue.c **** 
1023:../FreeRTOS/Source/queue.c ****             /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
1024:../FreeRTOS/Source/queue.c ****              *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
1025:../FreeRTOS/Source/queue.c ****              *  in a task disinheriting a priority and prvCopyDataToQueue() can be
1026:../FreeRTOS/Source/queue.c ****              *  called here even though the disinherit function does not check if
1027:../FreeRTOS/Source/queue.c ****              *  the scheduler is suspended before accessing the ready lists. */
1028:../FreeRTOS/Source/queue.c ****             ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
1029:../FreeRTOS/Source/queue.c **** 
1030:../FreeRTOS/Source/queue.c ****             /* The event list is not altered if the queue is locked.  This will
1031:../FreeRTOS/Source/queue.c ****              * be done when the queue is unlocked later. */
1032:../FreeRTOS/Source/queue.c ****             if( cTxLock == queueUNLOCKED )
1033:../FreeRTOS/Source/queue.c ****             {
1034:../FreeRTOS/Source/queue.c ****                 #if ( configUSE_QUEUE_SETS == 1 )
1035:../FreeRTOS/Source/queue.c ****                     {
1036:../FreeRTOS/Source/queue.c ****                         if( pxQueue->pxQueueSetContainer != NULL )
1037:../FreeRTOS/Source/queue.c ****                         {
1038:../FreeRTOS/Source/queue.c ****                             if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting 
1039:../FreeRTOS/Source/queue.c ****                             {
1040:../FreeRTOS/Source/queue.c ****                                 /* Do not notify the queue set as an existing item
1041:../FreeRTOS/Source/queue.c ****                                  * was overwritten in the queue so the number of items
1042:../FreeRTOS/Source/queue.c ****                                  * in the queue has not changed. */
1043:../FreeRTOS/Source/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
1044:../FreeRTOS/Source/queue.c ****                             }
1045:../FreeRTOS/Source/queue.c ****                             else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
1046:../FreeRTOS/Source/queue.c ****                             {
1047:../FreeRTOS/Source/queue.c ****                                 /* The queue is a member of a queue set, and posting
1048:../FreeRTOS/Source/queue.c ****                                  * to the queue set caused a higher priority task to
1049:../FreeRTOS/Source/queue.c ****                                  * unblock.  A context switch is required. */
1050:../FreeRTOS/Source/queue.c ****                                 if( pxHigherPriorityTaskWoken != NULL )
1051:../FreeRTOS/Source/queue.c ****                                 {
1052:../FreeRTOS/Source/queue.c ****                                     *pxHigherPriorityTaskWoken = pdTRUE;
1053:../FreeRTOS/Source/queue.c ****                                 }
1054:../FreeRTOS/Source/queue.c ****                                 else
1055:../FreeRTOS/Source/queue.c ****                                 {
1056:../FreeRTOS/Source/queue.c ****                                     mtCOVERAGE_TEST_MARKER();
1057:../FreeRTOS/Source/queue.c ****                                 }
1058:../FreeRTOS/Source/queue.c ****                             }
1059:../FreeRTOS/Source/queue.c ****                             else
1060:../FreeRTOS/Source/queue.c ****                             {
1061:../FreeRTOS/Source/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
1062:../FreeRTOS/Source/queue.c ****                             }
1063:../FreeRTOS/Source/queue.c ****                         }
1064:../FreeRTOS/Source/queue.c ****                         else
1065:../FreeRTOS/Source/queue.c ****                         {
1066:../FreeRTOS/Source/queue.c ****                             if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALS
1067:../FreeRTOS/Source/queue.c ****                             {
1068:../FreeRTOS/Source/queue.c ****                                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) 
1069:../FreeRTOS/Source/queue.c ****                                 {
1070:../FreeRTOS/Source/queue.c ****                                     /* The task waiting has a higher priority so
1071:../FreeRTOS/Source/queue.c ****                                      *  record that a context switch is required. */
1072:../FreeRTOS/Source/queue.c ****                                     if( pxHigherPriorityTaskWoken != NULL )
1073:../FreeRTOS/Source/queue.c ****                                     {
1074:../FreeRTOS/Source/queue.c ****                                         *pxHigherPriorityTaskWoken = pdTRUE;
1075:../FreeRTOS/Source/queue.c ****                                     }
1076:../FreeRTOS/Source/queue.c ****                                     else
1077:../FreeRTOS/Source/queue.c ****                                     {
1078:../FreeRTOS/Source/queue.c ****                                         mtCOVERAGE_TEST_MARKER();
1079:../FreeRTOS/Source/queue.c ****                                     }
1080:../FreeRTOS/Source/queue.c ****                                 }
1081:../FreeRTOS/Source/queue.c ****                                 else
1082:../FreeRTOS/Source/queue.c ****                                 {
1083:../FreeRTOS/Source/queue.c ****                                     mtCOVERAGE_TEST_MARKER();
1084:../FreeRTOS/Source/queue.c ****                                 }
1085:../FreeRTOS/Source/queue.c ****                             }
1086:../FreeRTOS/Source/queue.c ****                             else
1087:../FreeRTOS/Source/queue.c ****                             {
1088:../FreeRTOS/Source/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
1089:../FreeRTOS/Source/queue.c ****                             }
1090:../FreeRTOS/Source/queue.c ****                         }
1091:../FreeRTOS/Source/queue.c ****                     }
1092:../FreeRTOS/Source/queue.c ****                 #else /* configUSE_QUEUE_SETS */
1093:../FreeRTOS/Source/queue.c ****                     {
1094:../FreeRTOS/Source/queue.c ****                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1095:../FreeRTOS/Source/queue.c ****                         {
1096:../FreeRTOS/Source/queue.c ****                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) !=
1097:../FreeRTOS/Source/queue.c ****                             {
1098:../FreeRTOS/Source/queue.c ****                                 /* The task waiting has a higher priority so record that a
1099:../FreeRTOS/Source/queue.c ****                                  * context switch is required. */
1100:../FreeRTOS/Source/queue.c ****                                 if( pxHigherPriorityTaskWoken != NULL )
1101:../FreeRTOS/Source/queue.c ****                                 {
1102:../FreeRTOS/Source/queue.c ****                                     *pxHigherPriorityTaskWoken = pdTRUE;
1103:../FreeRTOS/Source/queue.c ****                                 }
1104:../FreeRTOS/Source/queue.c ****                                 else
1105:../FreeRTOS/Source/queue.c ****                                 {
1106:../FreeRTOS/Source/queue.c ****                                     mtCOVERAGE_TEST_MARKER();
1107:../FreeRTOS/Source/queue.c ****                                 }
1108:../FreeRTOS/Source/queue.c ****                             }
1109:../FreeRTOS/Source/queue.c ****                             else
1110:../FreeRTOS/Source/queue.c ****                             {
1111:../FreeRTOS/Source/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
1112:../FreeRTOS/Source/queue.c ****                             }
1113:../FreeRTOS/Source/queue.c ****                         }
1114:../FreeRTOS/Source/queue.c ****                         else
1115:../FreeRTOS/Source/queue.c ****                         {
1116:../FreeRTOS/Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
1117:../FreeRTOS/Source/queue.c ****                         }
1118:../FreeRTOS/Source/queue.c **** 
1119:../FreeRTOS/Source/queue.c ****                         /* Not used in this path. */
1120:../FreeRTOS/Source/queue.c ****                         ( void ) uxPreviousMessagesWaiting;
1121:../FreeRTOS/Source/queue.c ****                     }
1122:../FreeRTOS/Source/queue.c ****                 #endif /* configUSE_QUEUE_SETS */
1123:../FreeRTOS/Source/queue.c ****             }
1124:../FreeRTOS/Source/queue.c ****             else
1125:../FreeRTOS/Source/queue.c ****             {
1126:../FreeRTOS/Source/queue.c ****                 /* Increment the lock count so the task that unlocks the queue
1127:../FreeRTOS/Source/queue.c ****                  * knows that data was posted while it was locked. */
1128:../FreeRTOS/Source/queue.c ****                 configASSERT( cTxLock != queueINT8_MAX );
1129:../FreeRTOS/Source/queue.c **** 
1130:../FreeRTOS/Source/queue.c ****                 pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
1131:../FreeRTOS/Source/queue.c ****             }
1132:../FreeRTOS/Source/queue.c **** 
1133:../FreeRTOS/Source/queue.c ****             xReturn = pdPASS;
1134:../FreeRTOS/Source/queue.c ****         }
1135:../FreeRTOS/Source/queue.c ****         else
1136:../FreeRTOS/Source/queue.c ****         {
1137:../FreeRTOS/Source/queue.c ****             traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1138:../FreeRTOS/Source/queue.c ****             xReturn = errQUEUE_FULL;
1139:../FreeRTOS/Source/queue.c ****         }
1140:../FreeRTOS/Source/queue.c ****     }
1141:../FreeRTOS/Source/queue.c ****     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1142:../FreeRTOS/Source/queue.c **** 
1143:../FreeRTOS/Source/queue.c ****     return xReturn;
1144:../FreeRTOS/Source/queue.c **** }
1145:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1146:../FreeRTOS/Source/queue.c **** 
1147:../FreeRTOS/Source/queue.c **** BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
1148:../FreeRTOS/Source/queue.c ****                               BaseType_t * const pxHigherPriorityTaskWoken )
1149:../FreeRTOS/Source/queue.c **** {
1150:../FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
1151:../FreeRTOS/Source/queue.c ****     UBaseType_t uxSavedInterruptStatus;
1152:../FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
1153:../FreeRTOS/Source/queue.c **** 
1154:../FreeRTOS/Source/queue.c ****     /* Similar to xQueueGenericSendFromISR() but used with semaphores where the
1155:../FreeRTOS/Source/queue.c ****      * item size is 0.  Don't directly wake a task that was blocked on a queue
1156:../FreeRTOS/Source/queue.c ****      * read, instead return a flag to say whether a context switch is required or
1157:../FreeRTOS/Source/queue.c ****      * not (i.e. has a task with a higher priority than us been woken by this
1158:../FreeRTOS/Source/queue.c ****      * post). */
1159:../FreeRTOS/Source/queue.c **** 
1160:../FreeRTOS/Source/queue.c ****     configASSERT( pxQueue );
1161:../FreeRTOS/Source/queue.c **** 
1162:../FreeRTOS/Source/queue.c ****     /* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
1163:../FreeRTOS/Source/queue.c ****      * if the item size is not 0. */
1164:../FreeRTOS/Source/queue.c ****     configASSERT( pxQueue->uxItemSize == 0 );
1165:../FreeRTOS/Source/queue.c **** 
1166:../FreeRTOS/Source/queue.c ****     /* Normally a mutex would not be given from an interrupt, especially if
1167:../FreeRTOS/Source/queue.c ****      * there is a mutex holder, as priority inheritance makes no sense for an
1168:../FreeRTOS/Source/queue.c ****      * interrupts, only tasks. */
1169:../FreeRTOS/Source/queue.c ****     configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMu
1170:../FreeRTOS/Source/queue.c **** 
1171:../FreeRTOS/Source/queue.c ****     /* RTOS ports that support interrupt nesting have the concept of a maximum
1172:../FreeRTOS/Source/queue.c ****      * system call (or maximum API call) interrupt priority.  Interrupts that are
1173:../FreeRTOS/Source/queue.c ****      * above the maximum system call priority are kept permanently enabled, even
1174:../FreeRTOS/Source/queue.c ****      * when the RTOS kernel is in a critical section, but cannot make any calls to
1175:../FreeRTOS/Source/queue.c ****      * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1176:../FreeRTOS/Source/queue.c ****      * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1177:../FreeRTOS/Source/queue.c ****      * failure if a FreeRTOS API function is called from an interrupt that has been
1178:../FreeRTOS/Source/queue.c ****      * assigned a priority above the configured maximum system call priority.
1179:../FreeRTOS/Source/queue.c ****      * Only FreeRTOS functions that end in FromISR can be called from interrupts
1180:../FreeRTOS/Source/queue.c ****      * that have been assigned a priority at or (logically) below the maximum
1181:../FreeRTOS/Source/queue.c ****      * system call interrupt priority.  FreeRTOS maintains a separate interrupt
1182:../FreeRTOS/Source/queue.c ****      * safe API to ensure interrupt entry is as fast and as simple as possible.
1183:../FreeRTOS/Source/queue.c ****      * More information (albeit Cortex-M specific) is provided on the following
1184:../FreeRTOS/Source/queue.c ****      * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
1185:../FreeRTOS/Source/queue.c ****     portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1186:../FreeRTOS/Source/queue.c **** 
1187:../FreeRTOS/Source/queue.c ****     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1188:../FreeRTOS/Source/queue.c ****     {
1189:../FreeRTOS/Source/queue.c ****         const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1190:../FreeRTOS/Source/queue.c **** 
1191:../FreeRTOS/Source/queue.c ****         /* When the queue is used to implement a semaphore no data is ever
1192:../FreeRTOS/Source/queue.c ****          * moved through the queue but it is still valid to see if the queue 'has
1193:../FreeRTOS/Source/queue.c ****          * space'. */
1194:../FreeRTOS/Source/queue.c ****         if( uxMessagesWaiting < pxQueue->uxLength )
1195:../FreeRTOS/Source/queue.c ****         {
1196:../FreeRTOS/Source/queue.c ****             const int8_t cTxLock = pxQueue->cTxLock;
1197:../FreeRTOS/Source/queue.c **** 
1198:../FreeRTOS/Source/queue.c ****             traceQUEUE_SEND_FROM_ISR( pxQueue );
1199:../FreeRTOS/Source/queue.c **** 
1200:../FreeRTOS/Source/queue.c ****             /* A task can only have an inherited priority if it is a mutex
1201:../FreeRTOS/Source/queue.c ****              * holder - and if there is a mutex holder then the mutex cannot be
1202:../FreeRTOS/Source/queue.c ****              * given from an ISR.  As this is the ISR version of the function it
1203:../FreeRTOS/Source/queue.c ****              * can be assumed there is no mutex holder and no need to determine if
1204:../FreeRTOS/Source/queue.c ****              * priority disinheritance is needed.  Simply increase the count of
1205:../FreeRTOS/Source/queue.c ****              * messages (semaphores) available. */
1206:../FreeRTOS/Source/queue.c ****             pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
1207:../FreeRTOS/Source/queue.c **** 
1208:../FreeRTOS/Source/queue.c ****             /* The event list is not altered if the queue is locked.  This will
1209:../FreeRTOS/Source/queue.c ****              * be done when the queue is unlocked later. */
1210:../FreeRTOS/Source/queue.c ****             if( cTxLock == queueUNLOCKED )
1211:../FreeRTOS/Source/queue.c ****             {
1212:../FreeRTOS/Source/queue.c ****                 #if ( configUSE_QUEUE_SETS == 1 )
1213:../FreeRTOS/Source/queue.c ****                     {
1214:../FreeRTOS/Source/queue.c ****                         if( pxQueue->pxQueueSetContainer != NULL )
1215:../FreeRTOS/Source/queue.c ****                         {
1216:../FreeRTOS/Source/queue.c ****                             if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
1217:../FreeRTOS/Source/queue.c ****                             {
1218:../FreeRTOS/Source/queue.c ****                                 /* The semaphore is a member of a queue set, and
1219:../FreeRTOS/Source/queue.c ****                                  * posting to the queue set caused a higher priority
1220:../FreeRTOS/Source/queue.c ****                                  * task to unblock.  A context switch is required. */
1221:../FreeRTOS/Source/queue.c ****                                 if( pxHigherPriorityTaskWoken != NULL )
1222:../FreeRTOS/Source/queue.c ****                                 {
1223:../FreeRTOS/Source/queue.c ****                                     *pxHigherPriorityTaskWoken = pdTRUE;
1224:../FreeRTOS/Source/queue.c ****                                 }
1225:../FreeRTOS/Source/queue.c ****                                 else
1226:../FreeRTOS/Source/queue.c ****                                 {
1227:../FreeRTOS/Source/queue.c ****                                     mtCOVERAGE_TEST_MARKER();
1228:../FreeRTOS/Source/queue.c ****                                 }
1229:../FreeRTOS/Source/queue.c ****                             }
1230:../FreeRTOS/Source/queue.c ****                             else
1231:../FreeRTOS/Source/queue.c ****                             {
1232:../FreeRTOS/Source/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
1233:../FreeRTOS/Source/queue.c ****                             }
1234:../FreeRTOS/Source/queue.c ****                         }
1235:../FreeRTOS/Source/queue.c ****                         else
1236:../FreeRTOS/Source/queue.c ****                         {
1237:../FreeRTOS/Source/queue.c ****                             if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALS
1238:../FreeRTOS/Source/queue.c ****                             {
1239:../FreeRTOS/Source/queue.c ****                                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) 
1240:../FreeRTOS/Source/queue.c ****                                 {
1241:../FreeRTOS/Source/queue.c ****                                     /* The task waiting has a higher priority so
1242:../FreeRTOS/Source/queue.c ****                                      *  record that a context switch is required. */
1243:../FreeRTOS/Source/queue.c ****                                     if( pxHigherPriorityTaskWoken != NULL )
1244:../FreeRTOS/Source/queue.c ****                                     {
1245:../FreeRTOS/Source/queue.c ****                                         *pxHigherPriorityTaskWoken = pdTRUE;
1246:../FreeRTOS/Source/queue.c ****                                     }
1247:../FreeRTOS/Source/queue.c ****                                     else
1248:../FreeRTOS/Source/queue.c ****                                     {
1249:../FreeRTOS/Source/queue.c ****                                         mtCOVERAGE_TEST_MARKER();
1250:../FreeRTOS/Source/queue.c ****                                     }
1251:../FreeRTOS/Source/queue.c ****                                 }
1252:../FreeRTOS/Source/queue.c ****                                 else
1253:../FreeRTOS/Source/queue.c ****                                 {
1254:../FreeRTOS/Source/queue.c ****                                     mtCOVERAGE_TEST_MARKER();
1255:../FreeRTOS/Source/queue.c ****                                 }
1256:../FreeRTOS/Source/queue.c ****                             }
1257:../FreeRTOS/Source/queue.c ****                             else
1258:../FreeRTOS/Source/queue.c ****                             {
1259:../FreeRTOS/Source/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
1260:../FreeRTOS/Source/queue.c ****                             }
1261:../FreeRTOS/Source/queue.c ****                         }
1262:../FreeRTOS/Source/queue.c ****                     }
1263:../FreeRTOS/Source/queue.c ****                 #else /* configUSE_QUEUE_SETS */
1264:../FreeRTOS/Source/queue.c ****                     {
1265:../FreeRTOS/Source/queue.c ****                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1266:../FreeRTOS/Source/queue.c ****                         {
1267:../FreeRTOS/Source/queue.c ****                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) !=
1268:../FreeRTOS/Source/queue.c ****                             {
1269:../FreeRTOS/Source/queue.c ****                                 /* The task waiting has a higher priority so record that a
1270:../FreeRTOS/Source/queue.c ****                                  * context switch is required. */
1271:../FreeRTOS/Source/queue.c ****                                 if( pxHigherPriorityTaskWoken != NULL )
1272:../FreeRTOS/Source/queue.c ****                                 {
1273:../FreeRTOS/Source/queue.c ****                                     *pxHigherPriorityTaskWoken = pdTRUE;
1274:../FreeRTOS/Source/queue.c ****                                 }
1275:../FreeRTOS/Source/queue.c ****                                 else
1276:../FreeRTOS/Source/queue.c ****                                 {
1277:../FreeRTOS/Source/queue.c ****                                     mtCOVERAGE_TEST_MARKER();
1278:../FreeRTOS/Source/queue.c ****                                 }
1279:../FreeRTOS/Source/queue.c ****                             }
1280:../FreeRTOS/Source/queue.c ****                             else
1281:../FreeRTOS/Source/queue.c ****                             {
1282:../FreeRTOS/Source/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
1283:../FreeRTOS/Source/queue.c ****                             }
1284:../FreeRTOS/Source/queue.c ****                         }
1285:../FreeRTOS/Source/queue.c ****                         else
1286:../FreeRTOS/Source/queue.c ****                         {
1287:../FreeRTOS/Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
1288:../FreeRTOS/Source/queue.c ****                         }
1289:../FreeRTOS/Source/queue.c ****                     }
1290:../FreeRTOS/Source/queue.c ****                 #endif /* configUSE_QUEUE_SETS */
1291:../FreeRTOS/Source/queue.c ****             }
1292:../FreeRTOS/Source/queue.c ****             else
1293:../FreeRTOS/Source/queue.c ****             {
1294:../FreeRTOS/Source/queue.c ****                 /* Increment the lock count so the task that unlocks the queue
1295:../FreeRTOS/Source/queue.c ****                  * knows that data was posted while it was locked. */
1296:../FreeRTOS/Source/queue.c ****                 configASSERT( cTxLock != queueINT8_MAX );
1297:../FreeRTOS/Source/queue.c **** 
1298:../FreeRTOS/Source/queue.c ****                 pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
1299:../FreeRTOS/Source/queue.c ****             }
1300:../FreeRTOS/Source/queue.c **** 
1301:../FreeRTOS/Source/queue.c ****             xReturn = pdPASS;
1302:../FreeRTOS/Source/queue.c ****         }
1303:../FreeRTOS/Source/queue.c ****         else
1304:../FreeRTOS/Source/queue.c ****         {
1305:../FreeRTOS/Source/queue.c ****             traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1306:../FreeRTOS/Source/queue.c ****             xReturn = errQUEUE_FULL;
1307:../FreeRTOS/Source/queue.c ****         }
1308:../FreeRTOS/Source/queue.c ****     }
1309:../FreeRTOS/Source/queue.c ****     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1310:../FreeRTOS/Source/queue.c **** 
1311:../FreeRTOS/Source/queue.c ****     return xReturn;
1312:../FreeRTOS/Source/queue.c **** }
1313:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1314:../FreeRTOS/Source/queue.c **** 
1315:../FreeRTOS/Source/queue.c **** BaseType_t xQueueReceive( QueueHandle_t xQueue,
1316:../FreeRTOS/Source/queue.c ****                           void * const pvBuffer,
1317:../FreeRTOS/Source/queue.c ****                           TickType_t xTicksToWait )
1318:../FreeRTOS/Source/queue.c **** {
1319:../FreeRTOS/Source/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
1320:../FreeRTOS/Source/queue.c ****     TimeOut_t xTimeOut;
1321:../FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
1322:../FreeRTOS/Source/queue.c **** 
1323:../FreeRTOS/Source/queue.c ****     /* Check the pointer is not NULL. */
1324:../FreeRTOS/Source/queue.c ****     configASSERT( ( pxQueue ) );
1325:../FreeRTOS/Source/queue.c **** 
1326:../FreeRTOS/Source/queue.c ****     /* The buffer into which data is received can only be NULL if the data size
1327:../FreeRTOS/Source/queue.c ****      * is zero (so no data is copied into the buffer). */
1328:../FreeRTOS/Source/queue.c ****     configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) 
1329:../FreeRTOS/Source/queue.c **** 
1330:../FreeRTOS/Source/queue.c ****     /* Cannot block if the scheduler is suspended. */
1331:../FreeRTOS/Source/queue.c ****     #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1332:../FreeRTOS/Source/queue.c ****         {
1333:../FreeRTOS/Source/queue.c ****             configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToW
1334:../FreeRTOS/Source/queue.c ****         }
1335:../FreeRTOS/Source/queue.c ****     #endif
1336:../FreeRTOS/Source/queue.c **** 
1337:../FreeRTOS/Source/queue.c ****     /*lint -save -e904  This function relaxes the coding standard somewhat to
1338:../FreeRTOS/Source/queue.c ****      * allow return statements within the function itself.  This is done in the
1339:../FreeRTOS/Source/queue.c ****      * interest of execution time efficiency. */
1340:../FreeRTOS/Source/queue.c ****     for( ; ; )
1341:../FreeRTOS/Source/queue.c ****     {
1342:../FreeRTOS/Source/queue.c ****         taskENTER_CRITICAL();
1343:../FreeRTOS/Source/queue.c ****         {
1344:../FreeRTOS/Source/queue.c ****             const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1345:../FreeRTOS/Source/queue.c **** 
1346:../FreeRTOS/Source/queue.c ****             /* Is there data in the queue now?  To be running the calling task
1347:../FreeRTOS/Source/queue.c ****              * must be the highest priority task wanting to access the queue. */
1348:../FreeRTOS/Source/queue.c ****             if( uxMessagesWaiting > ( UBaseType_t ) 0 )
1349:../FreeRTOS/Source/queue.c ****             {
1350:../FreeRTOS/Source/queue.c ****                 /* Data available, remove one item. */
1351:../FreeRTOS/Source/queue.c ****                 prvCopyDataFromQueue( pxQueue, pvBuffer );
1352:../FreeRTOS/Source/queue.c ****                 traceQUEUE_RECEIVE( pxQueue );
1353:../FreeRTOS/Source/queue.c ****                 pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
1354:../FreeRTOS/Source/queue.c **** 
1355:../FreeRTOS/Source/queue.c ****                 /* There is now space in the queue, were any tasks waiting to
1356:../FreeRTOS/Source/queue.c ****                  * post to the queue?  If so, unblock the highest priority waiting
1357:../FreeRTOS/Source/queue.c ****                  * task. */
1358:../FreeRTOS/Source/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1359:../FreeRTOS/Source/queue.c ****                 {
1360:../FreeRTOS/Source/queue.c ****                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1361:../FreeRTOS/Source/queue.c ****                     {
1362:../FreeRTOS/Source/queue.c ****                         queueYIELD_IF_USING_PREEMPTION();
1363:../FreeRTOS/Source/queue.c ****                     }
1364:../FreeRTOS/Source/queue.c ****                     else
1365:../FreeRTOS/Source/queue.c ****                     {
1366:../FreeRTOS/Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1367:../FreeRTOS/Source/queue.c ****                     }
1368:../FreeRTOS/Source/queue.c ****                 }
1369:../FreeRTOS/Source/queue.c ****                 else
1370:../FreeRTOS/Source/queue.c ****                 {
1371:../FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1372:../FreeRTOS/Source/queue.c ****                 }
1373:../FreeRTOS/Source/queue.c **** 
1374:../FreeRTOS/Source/queue.c ****                 taskEXIT_CRITICAL();
1375:../FreeRTOS/Source/queue.c ****                 return pdPASS;
1376:../FreeRTOS/Source/queue.c ****             }
1377:../FreeRTOS/Source/queue.c ****             else
1378:../FreeRTOS/Source/queue.c ****             {
1379:../FreeRTOS/Source/queue.c ****                 if( xTicksToWait == ( TickType_t ) 0 )
1380:../FreeRTOS/Source/queue.c ****                 {
1381:../FreeRTOS/Source/queue.c ****                     /* The queue was empty and no block time is specified (or
1382:../FreeRTOS/Source/queue.c ****                      * the block time has expired) so leave now. */
1383:../FreeRTOS/Source/queue.c ****                     taskEXIT_CRITICAL();
1384:../FreeRTOS/Source/queue.c ****                     traceQUEUE_RECEIVE_FAILED( pxQueue );
1385:../FreeRTOS/Source/queue.c ****                     return errQUEUE_EMPTY;
1386:../FreeRTOS/Source/queue.c ****                 }
1387:../FreeRTOS/Source/queue.c ****                 else if( xEntryTimeSet == pdFALSE )
1388:../FreeRTOS/Source/queue.c ****                 {
1389:../FreeRTOS/Source/queue.c ****                     /* The queue was empty and a block time was specified so
1390:../FreeRTOS/Source/queue.c ****                      * configure the timeout structure. */
1391:../FreeRTOS/Source/queue.c ****                     vTaskInternalSetTimeOutState( &xTimeOut );
1392:../FreeRTOS/Source/queue.c ****                     xEntryTimeSet = pdTRUE;
1393:../FreeRTOS/Source/queue.c ****                 }
1394:../FreeRTOS/Source/queue.c ****                 else
1395:../FreeRTOS/Source/queue.c ****                 {
1396:../FreeRTOS/Source/queue.c ****                     /* Entry time was already set. */
1397:../FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1398:../FreeRTOS/Source/queue.c ****                 }
1399:../FreeRTOS/Source/queue.c ****             }
1400:../FreeRTOS/Source/queue.c ****         }
1401:../FreeRTOS/Source/queue.c ****         taskEXIT_CRITICAL();
1402:../FreeRTOS/Source/queue.c **** 
1403:../FreeRTOS/Source/queue.c ****         /* Interrupts and other tasks can send to and receive from the queue
1404:../FreeRTOS/Source/queue.c ****          * now the critical section has been exited. */
1405:../FreeRTOS/Source/queue.c **** 
1406:../FreeRTOS/Source/queue.c ****         vTaskSuspendAll();
1407:../FreeRTOS/Source/queue.c ****         prvLockQueue( pxQueue );
1408:../FreeRTOS/Source/queue.c **** 
1409:../FreeRTOS/Source/queue.c ****         /* Update the timeout state to see if it has expired yet. */
1410:../FreeRTOS/Source/queue.c ****         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1411:../FreeRTOS/Source/queue.c ****         {
1412:../FreeRTOS/Source/queue.c ****             /* The timeout has not expired.  If the queue is still empty place
1413:../FreeRTOS/Source/queue.c ****              * the task on the list of tasks waiting to receive from the queue. */
1414:../FreeRTOS/Source/queue.c ****             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1415:../FreeRTOS/Source/queue.c ****             {
1416:../FreeRTOS/Source/queue.c ****                 traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1417:../FreeRTOS/Source/queue.c ****                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1418:../FreeRTOS/Source/queue.c ****                 prvUnlockQueue( pxQueue );
1419:../FreeRTOS/Source/queue.c **** 
1420:../FreeRTOS/Source/queue.c ****                 if( xTaskResumeAll() == pdFALSE )
1421:../FreeRTOS/Source/queue.c ****                 {
1422:../FreeRTOS/Source/queue.c ****                     portYIELD_WITHIN_API();
1423:../FreeRTOS/Source/queue.c ****                 }
1424:../FreeRTOS/Source/queue.c ****                 else
1425:../FreeRTOS/Source/queue.c ****                 {
1426:../FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1427:../FreeRTOS/Source/queue.c ****                 }
1428:../FreeRTOS/Source/queue.c ****             }
1429:../FreeRTOS/Source/queue.c ****             else
1430:../FreeRTOS/Source/queue.c ****             {
1431:../FreeRTOS/Source/queue.c ****                 /* The queue contains data again.  Loop back to try and read the
1432:../FreeRTOS/Source/queue.c ****                  * data. */
1433:../FreeRTOS/Source/queue.c ****                 prvUnlockQueue( pxQueue );
1434:../FreeRTOS/Source/queue.c ****                 ( void ) xTaskResumeAll();
1435:../FreeRTOS/Source/queue.c ****             }
1436:../FreeRTOS/Source/queue.c ****         }
1437:../FreeRTOS/Source/queue.c ****         else
1438:../FreeRTOS/Source/queue.c ****         {
1439:../FreeRTOS/Source/queue.c ****             /* Timed out.  If there is no data in the queue exit, otherwise loop
1440:../FreeRTOS/Source/queue.c ****              * back and attempt to read the data. */
1441:../FreeRTOS/Source/queue.c ****             prvUnlockQueue( pxQueue );
1442:../FreeRTOS/Source/queue.c ****             ( void ) xTaskResumeAll();
1443:../FreeRTOS/Source/queue.c **** 
1444:../FreeRTOS/Source/queue.c ****             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1445:../FreeRTOS/Source/queue.c ****             {
1446:../FreeRTOS/Source/queue.c ****                 traceQUEUE_RECEIVE_FAILED( pxQueue );
1447:../FreeRTOS/Source/queue.c ****                 return errQUEUE_EMPTY;
1448:../FreeRTOS/Source/queue.c ****             }
1449:../FreeRTOS/Source/queue.c ****             else
1450:../FreeRTOS/Source/queue.c ****             {
1451:../FreeRTOS/Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
1452:../FreeRTOS/Source/queue.c ****             }
1453:../FreeRTOS/Source/queue.c ****         }
1454:../FreeRTOS/Source/queue.c ****     } /*lint -restore */
1455:../FreeRTOS/Source/queue.c **** }
1456:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1457:../FreeRTOS/Source/queue.c **** 
1458:../FreeRTOS/Source/queue.c **** BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
1459:../FreeRTOS/Source/queue.c ****                                 TickType_t xTicksToWait )
1460:../FreeRTOS/Source/queue.c **** {
1461:../FreeRTOS/Source/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
1462:../FreeRTOS/Source/queue.c ****     TimeOut_t xTimeOut;
1463:../FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
1464:../FreeRTOS/Source/queue.c **** 
1465:../FreeRTOS/Source/queue.c ****     #if ( configUSE_MUTEXES == 1 )
1466:../FreeRTOS/Source/queue.c ****         BaseType_t xInheritanceOccurred = pdFALSE;
1467:../FreeRTOS/Source/queue.c ****     #endif
1468:../FreeRTOS/Source/queue.c **** 
1469:../FreeRTOS/Source/queue.c ****     /* Check the queue pointer is not NULL. */
1470:../FreeRTOS/Source/queue.c ****     configASSERT( ( pxQueue ) );
1471:../FreeRTOS/Source/queue.c **** 
1472:../FreeRTOS/Source/queue.c ****     /* Check this really is a semaphore, in which case the item size will be
1473:../FreeRTOS/Source/queue.c ****      * 0. */
1474:../FreeRTOS/Source/queue.c ****     configASSERT( pxQueue->uxItemSize == 0 );
1475:../FreeRTOS/Source/queue.c **** 
1476:../FreeRTOS/Source/queue.c ****     /* Cannot block if the scheduler is suspended. */
1477:../FreeRTOS/Source/queue.c ****     #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1478:../FreeRTOS/Source/queue.c ****         {
1479:../FreeRTOS/Source/queue.c ****             configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToW
1480:../FreeRTOS/Source/queue.c ****         }
1481:../FreeRTOS/Source/queue.c ****     #endif
1482:../FreeRTOS/Source/queue.c **** 
1483:../FreeRTOS/Source/queue.c ****     /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
1484:../FreeRTOS/Source/queue.c ****      * statements within the function itself.  This is done in the interest
1485:../FreeRTOS/Source/queue.c ****      * of execution time efficiency. */
1486:../FreeRTOS/Source/queue.c ****     for( ; ; )
1487:../FreeRTOS/Source/queue.c ****     {
1488:../FreeRTOS/Source/queue.c ****         taskENTER_CRITICAL();
1489:../FreeRTOS/Source/queue.c ****         {
1490:../FreeRTOS/Source/queue.c ****             /* Semaphores are queues with an item size of 0, and where the
1491:../FreeRTOS/Source/queue.c ****              * number of messages in the queue is the semaphore's count value. */
1492:../FreeRTOS/Source/queue.c ****             const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
1493:../FreeRTOS/Source/queue.c **** 
1494:../FreeRTOS/Source/queue.c ****             /* Is there data in the queue now?  To be running the calling task
1495:../FreeRTOS/Source/queue.c ****              * must be the highest priority task wanting to access the queue. */
1496:../FreeRTOS/Source/queue.c ****             if( uxSemaphoreCount > ( UBaseType_t ) 0 )
1497:../FreeRTOS/Source/queue.c ****             {
1498:../FreeRTOS/Source/queue.c ****                 traceQUEUE_RECEIVE( pxQueue );
1499:../FreeRTOS/Source/queue.c **** 
1500:../FreeRTOS/Source/queue.c ****                 /* Semaphores are queues with a data size of zero and where the
1501:../FreeRTOS/Source/queue.c ****                  * messages waiting is the semaphore's count.  Reduce the count. */
1502:../FreeRTOS/Source/queue.c ****                 pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
1503:../FreeRTOS/Source/queue.c **** 
1504:../FreeRTOS/Source/queue.c ****                 #if ( configUSE_MUTEXES == 1 )
1505:../FreeRTOS/Source/queue.c ****                     {
1506:../FreeRTOS/Source/queue.c ****                         if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1507:../FreeRTOS/Source/queue.c ****                         {
1508:../FreeRTOS/Source/queue.c ****                             /* Record the information required to implement
1509:../FreeRTOS/Source/queue.c ****                              * priority inheritance should it become necessary. */
1510:../FreeRTOS/Source/queue.c ****                             pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
1511:../FreeRTOS/Source/queue.c ****                         }
1512:../FreeRTOS/Source/queue.c ****                         else
1513:../FreeRTOS/Source/queue.c ****                         {
1514:../FreeRTOS/Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
1515:../FreeRTOS/Source/queue.c ****                         }
1516:../FreeRTOS/Source/queue.c ****                     }
1517:../FreeRTOS/Source/queue.c ****                 #endif /* configUSE_MUTEXES */
1518:../FreeRTOS/Source/queue.c **** 
1519:../FreeRTOS/Source/queue.c ****                 /* Check to see if other tasks are blocked waiting to give the
1520:../FreeRTOS/Source/queue.c ****                  * semaphore, and if so, unblock the highest priority such task. */
1521:../FreeRTOS/Source/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1522:../FreeRTOS/Source/queue.c ****                 {
1523:../FreeRTOS/Source/queue.c ****                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1524:../FreeRTOS/Source/queue.c ****                     {
1525:../FreeRTOS/Source/queue.c ****                         queueYIELD_IF_USING_PREEMPTION();
1526:../FreeRTOS/Source/queue.c ****                     }
1527:../FreeRTOS/Source/queue.c ****                     else
1528:../FreeRTOS/Source/queue.c ****                     {
1529:../FreeRTOS/Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1530:../FreeRTOS/Source/queue.c ****                     }
1531:../FreeRTOS/Source/queue.c ****                 }
1532:../FreeRTOS/Source/queue.c ****                 else
1533:../FreeRTOS/Source/queue.c ****                 {
1534:../FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1535:../FreeRTOS/Source/queue.c ****                 }
1536:../FreeRTOS/Source/queue.c **** 
1537:../FreeRTOS/Source/queue.c ****                 taskEXIT_CRITICAL();
1538:../FreeRTOS/Source/queue.c ****                 return pdPASS;
1539:../FreeRTOS/Source/queue.c ****             }
1540:../FreeRTOS/Source/queue.c ****             else
1541:../FreeRTOS/Source/queue.c ****             {
1542:../FreeRTOS/Source/queue.c ****                 if( xTicksToWait == ( TickType_t ) 0 )
1543:../FreeRTOS/Source/queue.c ****                 {
1544:../FreeRTOS/Source/queue.c ****                     /* For inheritance to have occurred there must have been an
1545:../FreeRTOS/Source/queue.c ****                      * initial timeout, and an adjusted timeout cannot become 0, as
1546:../FreeRTOS/Source/queue.c ****                      * if it were 0 the function would have exited. */
1547:../FreeRTOS/Source/queue.c ****                     #if ( configUSE_MUTEXES == 1 )
1548:../FreeRTOS/Source/queue.c ****                         {
1549:../FreeRTOS/Source/queue.c ****                             configASSERT( xInheritanceOccurred == pdFALSE );
1550:../FreeRTOS/Source/queue.c ****                         }
1551:../FreeRTOS/Source/queue.c ****                     #endif /* configUSE_MUTEXES */
1552:../FreeRTOS/Source/queue.c **** 
1553:../FreeRTOS/Source/queue.c ****                     /* The semaphore count was 0 and no block time is specified
1554:../FreeRTOS/Source/queue.c ****                      * (or the block time has expired) so exit now. */
1555:../FreeRTOS/Source/queue.c ****                     taskEXIT_CRITICAL();
1556:../FreeRTOS/Source/queue.c ****                     traceQUEUE_RECEIVE_FAILED( pxQueue );
1557:../FreeRTOS/Source/queue.c ****                     return errQUEUE_EMPTY;
1558:../FreeRTOS/Source/queue.c ****                 }
1559:../FreeRTOS/Source/queue.c ****                 else if( xEntryTimeSet == pdFALSE )
1560:../FreeRTOS/Source/queue.c ****                 {
1561:../FreeRTOS/Source/queue.c ****                     /* The semaphore count was 0 and a block time was specified
1562:../FreeRTOS/Source/queue.c ****                      * so configure the timeout structure ready to block. */
1563:../FreeRTOS/Source/queue.c ****                     vTaskInternalSetTimeOutState( &xTimeOut );
1564:../FreeRTOS/Source/queue.c ****                     xEntryTimeSet = pdTRUE;
1565:../FreeRTOS/Source/queue.c ****                 }
1566:../FreeRTOS/Source/queue.c ****                 else
1567:../FreeRTOS/Source/queue.c ****                 {
1568:../FreeRTOS/Source/queue.c ****                     /* Entry time was already set. */
1569:../FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1570:../FreeRTOS/Source/queue.c ****                 }
1571:../FreeRTOS/Source/queue.c ****             }
1572:../FreeRTOS/Source/queue.c ****         }
1573:../FreeRTOS/Source/queue.c ****         taskEXIT_CRITICAL();
1574:../FreeRTOS/Source/queue.c **** 
1575:../FreeRTOS/Source/queue.c ****         /* Interrupts and other tasks can give to and take from the semaphore
1576:../FreeRTOS/Source/queue.c ****          * now the critical section has been exited. */
1577:../FreeRTOS/Source/queue.c **** 
1578:../FreeRTOS/Source/queue.c ****         vTaskSuspendAll();
1579:../FreeRTOS/Source/queue.c ****         prvLockQueue( pxQueue );
1580:../FreeRTOS/Source/queue.c **** 
1581:../FreeRTOS/Source/queue.c ****         /* Update the timeout state to see if it has expired yet. */
1582:../FreeRTOS/Source/queue.c ****         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1583:../FreeRTOS/Source/queue.c ****         {
1584:../FreeRTOS/Source/queue.c ****             /* A block time is specified and not expired.  If the semaphore
1585:../FreeRTOS/Source/queue.c ****              * count is 0 then enter the Blocked state to wait for a semaphore to
1586:../FreeRTOS/Source/queue.c ****              * become available.  As semaphores are implemented with queues the
1587:../FreeRTOS/Source/queue.c ****              * queue being empty is equivalent to the semaphore count being 0. */
1588:../FreeRTOS/Source/queue.c ****             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1589:../FreeRTOS/Source/queue.c ****             {
1590:../FreeRTOS/Source/queue.c ****                 traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1591:../FreeRTOS/Source/queue.c **** 
1592:../FreeRTOS/Source/queue.c ****                 #if ( configUSE_MUTEXES == 1 )
1593:../FreeRTOS/Source/queue.c ****                     {
1594:../FreeRTOS/Source/queue.c ****                         if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1595:../FreeRTOS/Source/queue.c ****                         {
1596:../FreeRTOS/Source/queue.c ****                             taskENTER_CRITICAL();
1597:../FreeRTOS/Source/queue.c ****                             {
1598:../FreeRTOS/Source/queue.c ****                                 xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.
1599:../FreeRTOS/Source/queue.c ****                             }
1600:../FreeRTOS/Source/queue.c ****                             taskEXIT_CRITICAL();
1601:../FreeRTOS/Source/queue.c ****                         }
1602:../FreeRTOS/Source/queue.c ****                         else
1603:../FreeRTOS/Source/queue.c ****                         {
1604:../FreeRTOS/Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
1605:../FreeRTOS/Source/queue.c ****                         }
1606:../FreeRTOS/Source/queue.c ****                     }
1607:../FreeRTOS/Source/queue.c ****                 #endif /* if ( configUSE_MUTEXES == 1 ) */
1608:../FreeRTOS/Source/queue.c **** 
1609:../FreeRTOS/Source/queue.c ****                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1610:../FreeRTOS/Source/queue.c ****                 prvUnlockQueue( pxQueue );
1611:../FreeRTOS/Source/queue.c **** 
1612:../FreeRTOS/Source/queue.c ****                 if( xTaskResumeAll() == pdFALSE )
1613:../FreeRTOS/Source/queue.c ****                 {
1614:../FreeRTOS/Source/queue.c ****                     portYIELD_WITHIN_API();
1615:../FreeRTOS/Source/queue.c ****                 }
1616:../FreeRTOS/Source/queue.c ****                 else
1617:../FreeRTOS/Source/queue.c ****                 {
1618:../FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1619:../FreeRTOS/Source/queue.c ****                 }
1620:../FreeRTOS/Source/queue.c ****             }
1621:../FreeRTOS/Source/queue.c ****             else
1622:../FreeRTOS/Source/queue.c ****             {
1623:../FreeRTOS/Source/queue.c ****                 /* There was no timeout and the semaphore count was not 0, so
1624:../FreeRTOS/Source/queue.c ****                  * attempt to take the semaphore again. */
1625:../FreeRTOS/Source/queue.c ****                 prvUnlockQueue( pxQueue );
1626:../FreeRTOS/Source/queue.c ****                 ( void ) xTaskResumeAll();
1627:../FreeRTOS/Source/queue.c ****             }
1628:../FreeRTOS/Source/queue.c ****         }
1629:../FreeRTOS/Source/queue.c ****         else
1630:../FreeRTOS/Source/queue.c ****         {
1631:../FreeRTOS/Source/queue.c ****             /* Timed out. */
1632:../FreeRTOS/Source/queue.c ****             prvUnlockQueue( pxQueue );
1633:../FreeRTOS/Source/queue.c ****             ( void ) xTaskResumeAll();
1634:../FreeRTOS/Source/queue.c **** 
1635:../FreeRTOS/Source/queue.c ****             /* If the semaphore count is 0 exit now as the timeout has
1636:../FreeRTOS/Source/queue.c ****              * expired.  Otherwise return to attempt to take the semaphore that is
1637:../FreeRTOS/Source/queue.c ****              * known to be available.  As semaphores are implemented by queues the
1638:../FreeRTOS/Source/queue.c ****              * queue being empty is equivalent to the semaphore count being 0. */
1639:../FreeRTOS/Source/queue.c ****             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1640:../FreeRTOS/Source/queue.c ****             {
1641:../FreeRTOS/Source/queue.c ****                 #if ( configUSE_MUTEXES == 1 )
1642:../FreeRTOS/Source/queue.c ****                     {
1643:../FreeRTOS/Source/queue.c ****                         /* xInheritanceOccurred could only have be set if
1644:../FreeRTOS/Source/queue.c ****                          * pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
1645:../FreeRTOS/Source/queue.c ****                          * test the mutex type again to check it is actually a mutex. */
1646:../FreeRTOS/Source/queue.c ****                         if( xInheritanceOccurred != pdFALSE )
1647:../FreeRTOS/Source/queue.c ****                         {
1648:../FreeRTOS/Source/queue.c ****                             taskENTER_CRITICAL();
1649:../FreeRTOS/Source/queue.c ****                             {
1650:../FreeRTOS/Source/queue.c ****                                 UBaseType_t uxHighestWaitingPriority;
1651:../FreeRTOS/Source/queue.c **** 
1652:../FreeRTOS/Source/queue.c ****                                 /* This task blocking on the mutex caused another
1653:../FreeRTOS/Source/queue.c ****                                  * task to inherit this task's priority.  Now this task
1654:../FreeRTOS/Source/queue.c ****                                  * has timed out the priority should be disinherited
1655:../FreeRTOS/Source/queue.c ****                                  * again, but only as low as the next highest priority
1656:../FreeRTOS/Source/queue.c ****                                  * task that is waiting for the same mutex. */
1657:../FreeRTOS/Source/queue.c ****                                 uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( px
1658:../FreeRTOS/Source/queue.c ****                                 vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHo
1659:../FreeRTOS/Source/queue.c ****                             }
1660:../FreeRTOS/Source/queue.c ****                             taskEXIT_CRITICAL();
1661:../FreeRTOS/Source/queue.c ****                         }
1662:../FreeRTOS/Source/queue.c ****                     }
1663:../FreeRTOS/Source/queue.c ****                 #endif /* configUSE_MUTEXES */
1664:../FreeRTOS/Source/queue.c **** 
1665:../FreeRTOS/Source/queue.c ****                 traceQUEUE_RECEIVE_FAILED( pxQueue );
1666:../FreeRTOS/Source/queue.c ****                 return errQUEUE_EMPTY;
1667:../FreeRTOS/Source/queue.c ****             }
1668:../FreeRTOS/Source/queue.c ****             else
1669:../FreeRTOS/Source/queue.c ****             {
1670:../FreeRTOS/Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
1671:../FreeRTOS/Source/queue.c ****             }
1672:../FreeRTOS/Source/queue.c ****         }
1673:../FreeRTOS/Source/queue.c ****     } /*lint -restore */
1674:../FreeRTOS/Source/queue.c **** }
1675:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1676:../FreeRTOS/Source/queue.c **** 
1677:../FreeRTOS/Source/queue.c **** BaseType_t xQueuePeek( QueueHandle_t xQueue,
1678:../FreeRTOS/Source/queue.c ****                        void * const pvBuffer,
1679:../FreeRTOS/Source/queue.c ****                        TickType_t xTicksToWait )
1680:../FreeRTOS/Source/queue.c **** {
1681:../FreeRTOS/Source/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
1682:../FreeRTOS/Source/queue.c ****     TimeOut_t xTimeOut;
1683:../FreeRTOS/Source/queue.c ****     int8_t * pcOriginalReadPosition;
1684:../FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
1685:../FreeRTOS/Source/queue.c **** 
1686:../FreeRTOS/Source/queue.c ****     /* Check the pointer is not NULL. */
1687:../FreeRTOS/Source/queue.c ****     configASSERT( ( pxQueue ) );
1688:../FreeRTOS/Source/queue.c **** 
1689:../FreeRTOS/Source/queue.c ****     /* The buffer into which data is received can only be NULL if the data size
1690:../FreeRTOS/Source/queue.c ****      * is zero (so no data is copied into the buffer. */
1691:../FreeRTOS/Source/queue.c ****     configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) 
1692:../FreeRTOS/Source/queue.c **** 
1693:../FreeRTOS/Source/queue.c ****     /* Cannot block if the scheduler is suspended. */
1694:../FreeRTOS/Source/queue.c ****     #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1695:../FreeRTOS/Source/queue.c ****         {
1696:../FreeRTOS/Source/queue.c ****             configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToW
1697:../FreeRTOS/Source/queue.c ****         }
1698:../FreeRTOS/Source/queue.c ****     #endif
1699:../FreeRTOS/Source/queue.c **** 
1700:../FreeRTOS/Source/queue.c ****     /*lint -save -e904  This function relaxes the coding standard somewhat to
1701:../FreeRTOS/Source/queue.c ****      * allow return statements within the function itself.  This is done in the
1702:../FreeRTOS/Source/queue.c ****      * interest of execution time efficiency. */
1703:../FreeRTOS/Source/queue.c ****     for( ; ; )
1704:../FreeRTOS/Source/queue.c ****     {
1705:../FreeRTOS/Source/queue.c ****         taskENTER_CRITICAL();
1706:../FreeRTOS/Source/queue.c ****         {
1707:../FreeRTOS/Source/queue.c ****             const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1708:../FreeRTOS/Source/queue.c **** 
1709:../FreeRTOS/Source/queue.c ****             /* Is there data in the queue now?  To be running the calling task
1710:../FreeRTOS/Source/queue.c ****              * must be the highest priority task wanting to access the queue. */
1711:../FreeRTOS/Source/queue.c ****             if( uxMessagesWaiting > ( UBaseType_t ) 0 )
1712:../FreeRTOS/Source/queue.c ****             {
1713:../FreeRTOS/Source/queue.c ****                 /* Remember the read position so it can be reset after the data
1714:../FreeRTOS/Source/queue.c ****                  * is read from the queue as this function is only peeking the
1715:../FreeRTOS/Source/queue.c ****                  * data, not removing it. */
1716:../FreeRTOS/Source/queue.c ****                 pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
1717:../FreeRTOS/Source/queue.c **** 
1718:../FreeRTOS/Source/queue.c ****                 prvCopyDataFromQueue( pxQueue, pvBuffer );
1719:../FreeRTOS/Source/queue.c ****                 traceQUEUE_PEEK( pxQueue );
1720:../FreeRTOS/Source/queue.c **** 
1721:../FreeRTOS/Source/queue.c ****                 /* The data is not being removed, so reset the read pointer. */
1722:../FreeRTOS/Source/queue.c ****                 pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
1723:../FreeRTOS/Source/queue.c **** 
1724:../FreeRTOS/Source/queue.c ****                 /* The data is being left in the queue, so see if there are
1725:../FreeRTOS/Source/queue.c ****                  * any other tasks waiting for the data. */
1726:../FreeRTOS/Source/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1727:../FreeRTOS/Source/queue.c ****                 {
1728:../FreeRTOS/Source/queue.c ****                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE
1729:../FreeRTOS/Source/queue.c ****                     {
1730:../FreeRTOS/Source/queue.c ****                         /* The task waiting has a higher priority than this task. */
1731:../FreeRTOS/Source/queue.c ****                         queueYIELD_IF_USING_PREEMPTION();
1732:../FreeRTOS/Source/queue.c ****                     }
1733:../FreeRTOS/Source/queue.c ****                     else
1734:../FreeRTOS/Source/queue.c ****                     {
1735:../FreeRTOS/Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1736:../FreeRTOS/Source/queue.c ****                     }
1737:../FreeRTOS/Source/queue.c ****                 }
1738:../FreeRTOS/Source/queue.c ****                 else
1739:../FreeRTOS/Source/queue.c ****                 {
1740:../FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1741:../FreeRTOS/Source/queue.c ****                 }
1742:../FreeRTOS/Source/queue.c **** 
1743:../FreeRTOS/Source/queue.c ****                 taskEXIT_CRITICAL();
1744:../FreeRTOS/Source/queue.c ****                 return pdPASS;
1745:../FreeRTOS/Source/queue.c ****             }
1746:../FreeRTOS/Source/queue.c ****             else
1747:../FreeRTOS/Source/queue.c ****             {
1748:../FreeRTOS/Source/queue.c ****                 if( xTicksToWait == ( TickType_t ) 0 )
1749:../FreeRTOS/Source/queue.c ****                 {
1750:../FreeRTOS/Source/queue.c ****                     /* The queue was empty and no block time is specified (or
1751:../FreeRTOS/Source/queue.c ****                      * the block time has expired) so leave now. */
1752:../FreeRTOS/Source/queue.c ****                     taskEXIT_CRITICAL();
1753:../FreeRTOS/Source/queue.c ****                     traceQUEUE_PEEK_FAILED( pxQueue );
1754:../FreeRTOS/Source/queue.c ****                     return errQUEUE_EMPTY;
1755:../FreeRTOS/Source/queue.c ****                 }
1756:../FreeRTOS/Source/queue.c ****                 else if( xEntryTimeSet == pdFALSE )
1757:../FreeRTOS/Source/queue.c ****                 {
1758:../FreeRTOS/Source/queue.c ****                     /* The queue was empty and a block time was specified so
1759:../FreeRTOS/Source/queue.c ****                      * configure the timeout structure ready to enter the blocked
1760:../FreeRTOS/Source/queue.c ****                      * state. */
1761:../FreeRTOS/Source/queue.c ****                     vTaskInternalSetTimeOutState( &xTimeOut );
1762:../FreeRTOS/Source/queue.c ****                     xEntryTimeSet = pdTRUE;
1763:../FreeRTOS/Source/queue.c ****                 }
1764:../FreeRTOS/Source/queue.c ****                 else
1765:../FreeRTOS/Source/queue.c ****                 {
1766:../FreeRTOS/Source/queue.c ****                     /* Entry time was already set. */
1767:../FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1768:../FreeRTOS/Source/queue.c ****                 }
1769:../FreeRTOS/Source/queue.c ****             }
1770:../FreeRTOS/Source/queue.c ****         }
1771:../FreeRTOS/Source/queue.c ****         taskEXIT_CRITICAL();
1772:../FreeRTOS/Source/queue.c **** 
1773:../FreeRTOS/Source/queue.c ****         /* Interrupts and other tasks can send to and receive from the queue
1774:../FreeRTOS/Source/queue.c ****          * now the critical section has been exited. */
1775:../FreeRTOS/Source/queue.c **** 
1776:../FreeRTOS/Source/queue.c ****         vTaskSuspendAll();
1777:../FreeRTOS/Source/queue.c ****         prvLockQueue( pxQueue );
1778:../FreeRTOS/Source/queue.c **** 
1779:../FreeRTOS/Source/queue.c ****         /* Update the timeout state to see if it has expired yet. */
1780:../FreeRTOS/Source/queue.c ****         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1781:../FreeRTOS/Source/queue.c ****         {
1782:../FreeRTOS/Source/queue.c ****             /* Timeout has not expired yet, check to see if there is data in the
1783:../FreeRTOS/Source/queue.c ****             * queue now, and if not enter the Blocked state to wait for data. */
1784:../FreeRTOS/Source/queue.c ****             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1785:../FreeRTOS/Source/queue.c ****             {
1786:../FreeRTOS/Source/queue.c ****                 traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
1787:../FreeRTOS/Source/queue.c ****                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1788:../FreeRTOS/Source/queue.c ****                 prvUnlockQueue( pxQueue );
1789:../FreeRTOS/Source/queue.c **** 
1790:../FreeRTOS/Source/queue.c ****                 if( xTaskResumeAll() == pdFALSE )
1791:../FreeRTOS/Source/queue.c ****                 {
1792:../FreeRTOS/Source/queue.c ****                     portYIELD_WITHIN_API();
1793:../FreeRTOS/Source/queue.c ****                 }
1794:../FreeRTOS/Source/queue.c ****                 else
1795:../FreeRTOS/Source/queue.c ****                 {
1796:../FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1797:../FreeRTOS/Source/queue.c ****                 }
1798:../FreeRTOS/Source/queue.c ****             }
1799:../FreeRTOS/Source/queue.c ****             else
1800:../FreeRTOS/Source/queue.c ****             {
1801:../FreeRTOS/Source/queue.c ****                 /* There is data in the queue now, so don't enter the blocked
1802:../FreeRTOS/Source/queue.c ****                  * state, instead return to try and obtain the data. */
1803:../FreeRTOS/Source/queue.c ****                 prvUnlockQueue( pxQueue );
1804:../FreeRTOS/Source/queue.c ****                 ( void ) xTaskResumeAll();
1805:../FreeRTOS/Source/queue.c ****             }
1806:../FreeRTOS/Source/queue.c ****         }
1807:../FreeRTOS/Source/queue.c ****         else
1808:../FreeRTOS/Source/queue.c ****         {
1809:../FreeRTOS/Source/queue.c ****             /* The timeout has expired.  If there is still no data in the queue
1810:../FreeRTOS/Source/queue.c ****              * exit, otherwise go back and try to read the data again. */
1811:../FreeRTOS/Source/queue.c ****             prvUnlockQueue( pxQueue );
1812:../FreeRTOS/Source/queue.c ****             ( void ) xTaskResumeAll();
1813:../FreeRTOS/Source/queue.c **** 
1814:../FreeRTOS/Source/queue.c ****             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1815:../FreeRTOS/Source/queue.c ****             {
1816:../FreeRTOS/Source/queue.c ****                 traceQUEUE_PEEK_FAILED( pxQueue );
1817:../FreeRTOS/Source/queue.c ****                 return errQUEUE_EMPTY;
1818:../FreeRTOS/Source/queue.c ****             }
1819:../FreeRTOS/Source/queue.c ****             else
1820:../FreeRTOS/Source/queue.c ****             {
1821:../FreeRTOS/Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
1822:../FreeRTOS/Source/queue.c ****             }
1823:../FreeRTOS/Source/queue.c ****         }
1824:../FreeRTOS/Source/queue.c ****     } /*lint -restore */
1825:../FreeRTOS/Source/queue.c **** }
1826:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1827:../FreeRTOS/Source/queue.c **** 
1828:../FreeRTOS/Source/queue.c **** BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
1829:../FreeRTOS/Source/queue.c ****                                  void * const pvBuffer,
1830:../FreeRTOS/Source/queue.c ****                                  BaseType_t * const pxHigherPriorityTaskWoken )
1831:../FreeRTOS/Source/queue.c **** {
1832:../FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
1833:../FreeRTOS/Source/queue.c ****     UBaseType_t uxSavedInterruptStatus;
1834:../FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
1835:../FreeRTOS/Source/queue.c **** 
1836:../FreeRTOS/Source/queue.c ****     configASSERT( pxQueue );
1837:../FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1838:../FreeRTOS/Source/queue.c **** 
1839:../FreeRTOS/Source/queue.c ****     /* RTOS ports that support interrupt nesting have the concept of a maximum
1840:../FreeRTOS/Source/queue.c ****      * system call (or maximum API call) interrupt priority.  Interrupts that are
1841:../FreeRTOS/Source/queue.c ****      * above the maximum system call priority are kept permanently enabled, even
1842:../FreeRTOS/Source/queue.c ****      * when the RTOS kernel is in a critical section, but cannot make any calls to
1843:../FreeRTOS/Source/queue.c ****      * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1844:../FreeRTOS/Source/queue.c ****      * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1845:../FreeRTOS/Source/queue.c ****      * failure if a FreeRTOS API function is called from an interrupt that has been
1846:../FreeRTOS/Source/queue.c ****      * assigned a priority above the configured maximum system call priority.
1847:../FreeRTOS/Source/queue.c ****      * Only FreeRTOS functions that end in FromISR can be called from interrupts
1848:../FreeRTOS/Source/queue.c ****      * that have been assigned a priority at or (logically) below the maximum
1849:../FreeRTOS/Source/queue.c ****      * system call interrupt priority.  FreeRTOS maintains a separate interrupt
1850:../FreeRTOS/Source/queue.c ****      * safe API to ensure interrupt entry is as fast and as simple as possible.
1851:../FreeRTOS/Source/queue.c ****      * More information (albeit Cortex-M specific) is provided on the following
1852:../FreeRTOS/Source/queue.c ****      * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
1853:../FreeRTOS/Source/queue.c ****     portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1854:../FreeRTOS/Source/queue.c **** 
1855:../FreeRTOS/Source/queue.c ****     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1856:../FreeRTOS/Source/queue.c ****     {
1857:../FreeRTOS/Source/queue.c ****         const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1858:../FreeRTOS/Source/queue.c **** 
1859:../FreeRTOS/Source/queue.c ****         /* Cannot block in an ISR, so check there is data available. */
1860:../FreeRTOS/Source/queue.c ****         if( uxMessagesWaiting > ( UBaseType_t ) 0 )
1861:../FreeRTOS/Source/queue.c ****         {
1862:../FreeRTOS/Source/queue.c ****             const int8_t cRxLock = pxQueue->cRxLock;
1863:../FreeRTOS/Source/queue.c **** 
1864:../FreeRTOS/Source/queue.c ****             traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1865:../FreeRTOS/Source/queue.c **** 
1866:../FreeRTOS/Source/queue.c ****             prvCopyDataFromQueue( pxQueue, pvBuffer );
1867:../FreeRTOS/Source/queue.c ****             pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
1868:../FreeRTOS/Source/queue.c **** 
1869:../FreeRTOS/Source/queue.c ****             /* If the queue is locked the event list will not be modified.
1870:../FreeRTOS/Source/queue.c ****              * Instead update the lock count so the task that unlocks the queue
1871:../FreeRTOS/Source/queue.c ****              * will know that an ISR has removed data while the queue was
1872:../FreeRTOS/Source/queue.c ****              * locked. */
1873:../FreeRTOS/Source/queue.c ****             if( cRxLock == queueUNLOCKED )
1874:../FreeRTOS/Source/queue.c ****             {
1875:../FreeRTOS/Source/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1876:../FreeRTOS/Source/queue.c ****                 {
1877:../FreeRTOS/Source/queue.c ****                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1878:../FreeRTOS/Source/queue.c ****                     {
1879:../FreeRTOS/Source/queue.c ****                         /* The task waiting has a higher priority than us so
1880:../FreeRTOS/Source/queue.c ****                          * force a context switch. */
1881:../FreeRTOS/Source/queue.c ****                         if( pxHigherPriorityTaskWoken != NULL )
1882:../FreeRTOS/Source/queue.c ****                         {
1883:../FreeRTOS/Source/queue.c ****                             *pxHigherPriorityTaskWoken = pdTRUE;
1884:../FreeRTOS/Source/queue.c ****                         }
1885:../FreeRTOS/Source/queue.c ****                         else
1886:../FreeRTOS/Source/queue.c ****                         {
1887:../FreeRTOS/Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
1888:../FreeRTOS/Source/queue.c ****                         }
1889:../FreeRTOS/Source/queue.c ****                     }
1890:../FreeRTOS/Source/queue.c ****                     else
1891:../FreeRTOS/Source/queue.c ****                     {
1892:../FreeRTOS/Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1893:../FreeRTOS/Source/queue.c ****                     }
1894:../FreeRTOS/Source/queue.c ****                 }
1895:../FreeRTOS/Source/queue.c ****                 else
1896:../FreeRTOS/Source/queue.c ****                 {
1897:../FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1898:../FreeRTOS/Source/queue.c ****                 }
1899:../FreeRTOS/Source/queue.c ****             }
1900:../FreeRTOS/Source/queue.c ****             else
1901:../FreeRTOS/Source/queue.c ****             {
1902:../FreeRTOS/Source/queue.c ****                 /* Increment the lock count so the task that unlocks the queue
1903:../FreeRTOS/Source/queue.c ****                  * knows that data was removed while it was locked. */
1904:../FreeRTOS/Source/queue.c ****                 configASSERT( cRxLock != queueINT8_MAX );
1905:../FreeRTOS/Source/queue.c **** 
1906:../FreeRTOS/Source/queue.c ****                 pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
1907:../FreeRTOS/Source/queue.c ****             }
1908:../FreeRTOS/Source/queue.c **** 
1909:../FreeRTOS/Source/queue.c ****             xReturn = pdPASS;
1910:../FreeRTOS/Source/queue.c ****         }
1911:../FreeRTOS/Source/queue.c ****         else
1912:../FreeRTOS/Source/queue.c ****         {
1913:../FreeRTOS/Source/queue.c ****             xReturn = pdFAIL;
1914:../FreeRTOS/Source/queue.c ****             traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1915:../FreeRTOS/Source/queue.c ****         }
1916:../FreeRTOS/Source/queue.c ****     }
1917:../FreeRTOS/Source/queue.c ****     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1918:../FreeRTOS/Source/queue.c **** 
1919:../FreeRTOS/Source/queue.c ****     return xReturn;
1920:../FreeRTOS/Source/queue.c **** }
1921:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1922:../FreeRTOS/Source/queue.c **** 
1923:../FreeRTOS/Source/queue.c **** BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
1924:../FreeRTOS/Source/queue.c ****                               void * const pvBuffer )
1925:../FreeRTOS/Source/queue.c **** {
1926:../FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
1927:../FreeRTOS/Source/queue.c ****     UBaseType_t uxSavedInterruptStatus;
1928:../FreeRTOS/Source/queue.c ****     int8_t * pcOriginalReadPosition;
1929:../FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
1930:../FreeRTOS/Source/queue.c **** 
1931:../FreeRTOS/Source/queue.c ****     configASSERT( pxQueue );
1932:../FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1933:../FreeRTOS/Source/queue.c ****     configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
1934:../FreeRTOS/Source/queue.c **** 
1935:../FreeRTOS/Source/queue.c ****     /* RTOS ports that support interrupt nesting have the concept of a maximum
1936:../FreeRTOS/Source/queue.c ****      * system call (or maximum API call) interrupt priority.  Interrupts that are
1937:../FreeRTOS/Source/queue.c ****      * above the maximum system call priority are kept permanently enabled, even
1938:../FreeRTOS/Source/queue.c ****      * when the RTOS kernel is in a critical section, but cannot make any calls to
1939:../FreeRTOS/Source/queue.c ****      * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1940:../FreeRTOS/Source/queue.c ****      * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1941:../FreeRTOS/Source/queue.c ****      * failure if a FreeRTOS API function is called from an interrupt that has been
1942:../FreeRTOS/Source/queue.c ****      * assigned a priority above the configured maximum system call priority.
1943:../FreeRTOS/Source/queue.c ****      * Only FreeRTOS functions that end in FromISR can be called from interrupts
1944:../FreeRTOS/Source/queue.c ****      * that have been assigned a priority at or (logically) below the maximum
1945:../FreeRTOS/Source/queue.c ****      * system call interrupt priority.  FreeRTOS maintains a separate interrupt
1946:../FreeRTOS/Source/queue.c ****      * safe API to ensure interrupt entry is as fast and as simple as possible.
1947:../FreeRTOS/Source/queue.c ****      * More information (albeit Cortex-M specific) is provided on the following
1948:../FreeRTOS/Source/queue.c ****      * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
1949:../FreeRTOS/Source/queue.c ****     portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1950:../FreeRTOS/Source/queue.c **** 
1951:../FreeRTOS/Source/queue.c ****     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1952:../FreeRTOS/Source/queue.c ****     {
1953:../FreeRTOS/Source/queue.c ****         /* Cannot block in an ISR, so check there is data available. */
1954:../FreeRTOS/Source/queue.c ****         if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
1955:../FreeRTOS/Source/queue.c ****         {
1956:../FreeRTOS/Source/queue.c ****             traceQUEUE_PEEK_FROM_ISR( pxQueue );
1957:../FreeRTOS/Source/queue.c **** 
1958:../FreeRTOS/Source/queue.c ****             /* Remember the read position so it can be reset as nothing is
1959:../FreeRTOS/Source/queue.c ****              * actually being removed from the queue. */
1960:../FreeRTOS/Source/queue.c ****             pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
1961:../FreeRTOS/Source/queue.c ****             prvCopyDataFromQueue( pxQueue, pvBuffer );
1962:../FreeRTOS/Source/queue.c ****             pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
1963:../FreeRTOS/Source/queue.c **** 
1964:../FreeRTOS/Source/queue.c ****             xReturn = pdPASS;
1965:../FreeRTOS/Source/queue.c ****         }
1966:../FreeRTOS/Source/queue.c ****         else
1967:../FreeRTOS/Source/queue.c ****         {
1968:../FreeRTOS/Source/queue.c ****             xReturn = pdFAIL;
1969:../FreeRTOS/Source/queue.c ****             traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
1970:../FreeRTOS/Source/queue.c ****         }
1971:../FreeRTOS/Source/queue.c ****     }
1972:../FreeRTOS/Source/queue.c ****     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1973:../FreeRTOS/Source/queue.c **** 
1974:../FreeRTOS/Source/queue.c ****     return xReturn;
1975:../FreeRTOS/Source/queue.c **** }
1976:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1977:../FreeRTOS/Source/queue.c **** 
1978:../FreeRTOS/Source/queue.c **** UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
1979:../FreeRTOS/Source/queue.c **** {
1980:../FreeRTOS/Source/queue.c ****     UBaseType_t uxReturn;
1981:../FreeRTOS/Source/queue.c **** 
1982:../FreeRTOS/Source/queue.c ****     configASSERT( xQueue );
1983:../FreeRTOS/Source/queue.c **** 
1984:../FreeRTOS/Source/queue.c ****     taskENTER_CRITICAL();
1985:../FreeRTOS/Source/queue.c ****     {
1986:../FreeRTOS/Source/queue.c ****         uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
1987:../FreeRTOS/Source/queue.c ****     }
1988:../FreeRTOS/Source/queue.c ****     taskEXIT_CRITICAL();
1989:../FreeRTOS/Source/queue.c **** 
1990:../FreeRTOS/Source/queue.c ****     return uxReturn;
1991:../FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
1992:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1993:../FreeRTOS/Source/queue.c **** 
1994:../FreeRTOS/Source/queue.c **** UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
1995:../FreeRTOS/Source/queue.c **** {
1996:../FreeRTOS/Source/queue.c ****     UBaseType_t uxReturn;
1997:../FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
1998:../FreeRTOS/Source/queue.c **** 
1999:../FreeRTOS/Source/queue.c ****     configASSERT( pxQueue );
2000:../FreeRTOS/Source/queue.c **** 
2001:../FreeRTOS/Source/queue.c ****     taskENTER_CRITICAL();
2002:../FreeRTOS/Source/queue.c ****     {
2003:../FreeRTOS/Source/queue.c ****         uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
2004:../FreeRTOS/Source/queue.c ****     }
2005:../FreeRTOS/Source/queue.c ****     taskEXIT_CRITICAL();
2006:../FreeRTOS/Source/queue.c **** 
2007:../FreeRTOS/Source/queue.c ****     return uxReturn;
2008:../FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
2009:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2010:../FreeRTOS/Source/queue.c **** 
2011:../FreeRTOS/Source/queue.c **** UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
2012:../FreeRTOS/Source/queue.c **** {
2013:../FreeRTOS/Source/queue.c ****     UBaseType_t uxReturn;
2014:../FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
2015:../FreeRTOS/Source/queue.c **** 
2016:../FreeRTOS/Source/queue.c ****     configASSERT( pxQueue );
2017:../FreeRTOS/Source/queue.c ****     uxReturn = pxQueue->uxMessagesWaiting;
2018:../FreeRTOS/Source/queue.c **** 
2019:../FreeRTOS/Source/queue.c ****     return uxReturn;
2020:../FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
2021:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2022:../FreeRTOS/Source/queue.c **** 
2023:../FreeRTOS/Source/queue.c **** void vQueueDelete( QueueHandle_t xQueue )
2024:../FreeRTOS/Source/queue.c **** {
2025:../FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
2026:../FreeRTOS/Source/queue.c **** 
2027:../FreeRTOS/Source/queue.c ****     configASSERT( pxQueue );
2028:../FreeRTOS/Source/queue.c ****     traceQUEUE_DELETE( pxQueue );
2029:../FreeRTOS/Source/queue.c **** 
2030:../FreeRTOS/Source/queue.c ****     #if ( configQUEUE_REGISTRY_SIZE > 0 )
2031:../FreeRTOS/Source/queue.c ****         {
2032:../FreeRTOS/Source/queue.c ****             vQueueUnregisterQueue( pxQueue );
2033:../FreeRTOS/Source/queue.c ****         }
2034:../FreeRTOS/Source/queue.c ****     #endif
2035:../FreeRTOS/Source/queue.c **** 
2036:../FreeRTOS/Source/queue.c ****     #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
2037:../FreeRTOS/Source/queue.c ****         {
2038:../FreeRTOS/Source/queue.c ****             /* The queue can only have been allocated dynamically - free it
2039:../FreeRTOS/Source/queue.c ****              * again. */
2040:../FreeRTOS/Source/queue.c ****             vPortFree( pxQueue );
2041:../FreeRTOS/Source/queue.c ****         }
2042:../FreeRTOS/Source/queue.c ****     #elif ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
2043:../FreeRTOS/Source/queue.c ****         {
2044:../FreeRTOS/Source/queue.c ****             /* The queue could have been allocated statically or dynamically, so
2045:../FreeRTOS/Source/queue.c ****              * check before attempting to free the memory. */
2046:../FreeRTOS/Source/queue.c ****             if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
2047:../FreeRTOS/Source/queue.c ****             {
2048:../FreeRTOS/Source/queue.c ****                 vPortFree( pxQueue );
2049:../FreeRTOS/Source/queue.c ****             }
2050:../FreeRTOS/Source/queue.c ****             else
2051:../FreeRTOS/Source/queue.c ****             {
2052:../FreeRTOS/Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2053:../FreeRTOS/Source/queue.c ****             }
2054:../FreeRTOS/Source/queue.c ****         }
2055:../FreeRTOS/Source/queue.c ****     #else /* if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION ==
2056:../FreeRTOS/Source/queue.c ****         {
2057:../FreeRTOS/Source/queue.c ****             /* The queue must have been statically allocated, so is not going to be
2058:../FreeRTOS/Source/queue.c ****              * deleted.  Avoid compiler warnings about the unused parameter. */
2059:../FreeRTOS/Source/queue.c ****             ( void ) pxQueue;
2060:../FreeRTOS/Source/queue.c ****         }
2061:../FreeRTOS/Source/queue.c ****     #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
2062:../FreeRTOS/Source/queue.c **** }
2063:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2064:../FreeRTOS/Source/queue.c **** 
2065:../FreeRTOS/Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2066:../FreeRTOS/Source/queue.c **** 
2067:../FreeRTOS/Source/queue.c ****     UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
2068:../FreeRTOS/Source/queue.c ****     {
2069:../FreeRTOS/Source/queue.c ****         return ( ( Queue_t * ) xQueue )->uxQueueNumber;
2070:../FreeRTOS/Source/queue.c ****     }
2071:../FreeRTOS/Source/queue.c **** 
2072:../FreeRTOS/Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2073:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2074:../FreeRTOS/Source/queue.c **** 
2075:../FreeRTOS/Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2076:../FreeRTOS/Source/queue.c **** 
2077:../FreeRTOS/Source/queue.c ****     void vQueueSetQueueNumber( QueueHandle_t xQueue,
2078:../FreeRTOS/Source/queue.c ****                                UBaseType_t uxQueueNumber )
2079:../FreeRTOS/Source/queue.c ****     {
2080:../FreeRTOS/Source/queue.c ****         ( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
2081:../FreeRTOS/Source/queue.c ****     }
2082:../FreeRTOS/Source/queue.c **** 
2083:../FreeRTOS/Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2084:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2085:../FreeRTOS/Source/queue.c **** 
2086:../FreeRTOS/Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2087:../FreeRTOS/Source/queue.c **** 
2088:../FreeRTOS/Source/queue.c ****     uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
2089:../FreeRTOS/Source/queue.c ****     {
2090:../FreeRTOS/Source/queue.c ****         return ( ( Queue_t * ) xQueue )->ucQueueType;
2091:../FreeRTOS/Source/queue.c ****     }
2092:../FreeRTOS/Source/queue.c **** 
2093:../FreeRTOS/Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2094:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2095:../FreeRTOS/Source/queue.c **** 
2096:../FreeRTOS/Source/queue.c **** #if ( configUSE_MUTEXES == 1 )
2097:../FreeRTOS/Source/queue.c **** 
2098:../FreeRTOS/Source/queue.c ****     static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
2099:../FreeRTOS/Source/queue.c ****     {
2100:../FreeRTOS/Source/queue.c ****         UBaseType_t uxHighestPriorityOfWaitingTasks;
2101:../FreeRTOS/Source/queue.c **** 
2102:../FreeRTOS/Source/queue.c ****         /* If a task waiting for a mutex causes the mutex holder to inherit a
2103:../FreeRTOS/Source/queue.c ****          * priority, but the waiting task times out, then the holder should
2104:../FreeRTOS/Source/queue.c ****          * disinherit the priority - but only down to the highest priority of any
2105:../FreeRTOS/Source/queue.c ****          * other tasks that are waiting for the same mutex.  For this purpose,
2106:../FreeRTOS/Source/queue.c ****          * return the priority of the highest priority task that is waiting for the
2107:../FreeRTOS/Source/queue.c ****          * mutex. */
2108:../FreeRTOS/Source/queue.c ****         if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
2109:../FreeRTOS/Source/queue.c ****         {
2110:../FreeRTOS/Source/queue.c ****             uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t 
2111:../FreeRTOS/Source/queue.c ****         }
2112:../FreeRTOS/Source/queue.c ****         else
2113:../FreeRTOS/Source/queue.c ****         {
2114:../FreeRTOS/Source/queue.c ****             uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
2115:../FreeRTOS/Source/queue.c ****         }
2116:../FreeRTOS/Source/queue.c **** 
2117:../FreeRTOS/Source/queue.c ****         return uxHighestPriorityOfWaitingTasks;
2118:../FreeRTOS/Source/queue.c ****     }
2119:../FreeRTOS/Source/queue.c **** 
2120:../FreeRTOS/Source/queue.c **** #endif /* configUSE_MUTEXES */
2121:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2122:../FreeRTOS/Source/queue.c **** 
2123:../FreeRTOS/Source/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
2124:../FreeRTOS/Source/queue.c ****                                       const void * pvItemToQueue,
2125:../FreeRTOS/Source/queue.c ****                                       const BaseType_t xPosition )
2126:../FreeRTOS/Source/queue.c **** {
2127:../FreeRTOS/Source/queue.c ****     BaseType_t xReturn = pdFALSE;
2128:../FreeRTOS/Source/queue.c ****     UBaseType_t uxMessagesWaiting;
2129:../FreeRTOS/Source/queue.c **** 
2130:../FreeRTOS/Source/queue.c ****     /* This function is called from a critical section. */
2131:../FreeRTOS/Source/queue.c **** 
2132:../FreeRTOS/Source/queue.c ****     uxMessagesWaiting = pxQueue->uxMessagesWaiting;
2133:../FreeRTOS/Source/queue.c **** 
2134:../FreeRTOS/Source/queue.c ****     if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
2135:../FreeRTOS/Source/queue.c ****     {
2136:../FreeRTOS/Source/queue.c ****         #if ( configUSE_MUTEXES == 1 )
2137:../FreeRTOS/Source/queue.c ****             {
2138:../FreeRTOS/Source/queue.c ****                 if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
2139:../FreeRTOS/Source/queue.c ****                 {
2140:../FreeRTOS/Source/queue.c ****                     /* The mutex is no longer being held. */
2141:../FreeRTOS/Source/queue.c ****                     xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
2142:../FreeRTOS/Source/queue.c ****                     pxQueue->u.xSemaphore.xMutexHolder = NULL;
2143:../FreeRTOS/Source/queue.c ****                 }
2144:../FreeRTOS/Source/queue.c ****                 else
2145:../FreeRTOS/Source/queue.c ****                 {
2146:../FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2147:../FreeRTOS/Source/queue.c ****                 }
2148:../FreeRTOS/Source/queue.c ****             }
2149:../FreeRTOS/Source/queue.c ****         #endif /* configUSE_MUTEXES */
2150:../FreeRTOS/Source/queue.c ****     }
2151:../FreeRTOS/Source/queue.c ****     else if( xPosition == queueSEND_TO_BACK )
2152:../FreeRTOS/Source/queue.c ****     {
2153:../FreeRTOS/Source/queue.c ****         ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSi
2154:../FreeRTOS/Source/queue.c ****         pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                 
2155:../FreeRTOS/Source/queue.c **** 
2156:../FreeRTOS/Source/queue.c ****         if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                       
2157:../FreeRTOS/Source/queue.c ****         {
2158:../FreeRTOS/Source/queue.c ****             pxQueue->pcWriteTo = pxQueue->pcHead;
2159:../FreeRTOS/Source/queue.c ****         }
2160:../FreeRTOS/Source/queue.c ****         else
2161:../FreeRTOS/Source/queue.c ****         {
2162:../FreeRTOS/Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
2163:../FreeRTOS/Source/queue.c ****         }
2164:../FreeRTOS/Source/queue.c ****     }
2165:../FreeRTOS/Source/queue.c ****     else
2166:../FreeRTOS/Source/queue.c ****     {
2167:../FreeRTOS/Source/queue.c ****         ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue
2168:../FreeRTOS/Source/queue.c ****         pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
2169:../FreeRTOS/Source/queue.c **** 
2170:../FreeRTOS/Source/queue.c ****         if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified
2171:../FreeRTOS/Source/queue.c ****         {
2172:../FreeRTOS/Source/queue.c ****             pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
2173:../FreeRTOS/Source/queue.c ****         }
2174:../FreeRTOS/Source/queue.c ****         else
2175:../FreeRTOS/Source/queue.c ****         {
2176:../FreeRTOS/Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
2177:../FreeRTOS/Source/queue.c ****         }
2178:../FreeRTOS/Source/queue.c **** 
2179:../FreeRTOS/Source/queue.c ****         if( xPosition == queueOVERWRITE )
2180:../FreeRTOS/Source/queue.c ****         {
2181:../FreeRTOS/Source/queue.c ****             if( uxMessagesWaiting > ( UBaseType_t ) 0 )
2182:../FreeRTOS/Source/queue.c ****             {
2183:../FreeRTOS/Source/queue.c ****                 /* An item is not being added but overwritten, so subtract
2184:../FreeRTOS/Source/queue.c ****                  * one from the recorded number of items in the queue so when
2185:../FreeRTOS/Source/queue.c ****                  * one is added again below the number of recorded items remains
2186:../FreeRTOS/Source/queue.c ****                  * correct. */
2187:../FreeRTOS/Source/queue.c ****                 --uxMessagesWaiting;
2188:../FreeRTOS/Source/queue.c ****             }
2189:../FreeRTOS/Source/queue.c ****             else
2190:../FreeRTOS/Source/queue.c ****             {
2191:../FreeRTOS/Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2192:../FreeRTOS/Source/queue.c ****             }
2193:../FreeRTOS/Source/queue.c ****         }
2194:../FreeRTOS/Source/queue.c ****         else
2195:../FreeRTOS/Source/queue.c ****         {
2196:../FreeRTOS/Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
2197:../FreeRTOS/Source/queue.c ****         }
2198:../FreeRTOS/Source/queue.c ****     }
2199:../FreeRTOS/Source/queue.c **** 
2200:../FreeRTOS/Source/queue.c ****     pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
2201:../FreeRTOS/Source/queue.c **** 
2202:../FreeRTOS/Source/queue.c ****     return xReturn;
2203:../FreeRTOS/Source/queue.c **** }
2204:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2205:../FreeRTOS/Source/queue.c **** 
2206:../FreeRTOS/Source/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue,
2207:../FreeRTOS/Source/queue.c ****                                   void * const pvBuffer )
2208:../FreeRTOS/Source/queue.c **** {
2209:../FreeRTOS/Source/queue.c ****     if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
2210:../FreeRTOS/Source/queue.c ****     {
2211:../FreeRTOS/Source/queue.c ****         pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithm
2212:../FreeRTOS/Source/queue.c **** 
2213:../FreeRTOS/Source/queue.c ****         if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception
2214:../FreeRTOS/Source/queue.c ****         {
2215:../FreeRTOS/Source/queue.c ****             pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
2216:../FreeRTOS/Source/queue.c ****         }
2217:../FreeRTOS/Source/queue.c ****         else
2218:../FreeRTOS/Source/queue.c ****         {
2219:../FreeRTOS/Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
2220:../FreeRTOS/Source/queue.c ****         }
2221:../FreeRTOS/Source/queue.c **** 
2222:../FreeRTOS/Source/queue.c ****         ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) p
2223:../FreeRTOS/Source/queue.c ****     }
2224:../FreeRTOS/Source/queue.c **** }
2225:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2226:../FreeRTOS/Source/queue.c **** 
2227:../FreeRTOS/Source/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue )
2228:../FreeRTOS/Source/queue.c **** {
2229:../FreeRTOS/Source/queue.c ****     /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
2230:../FreeRTOS/Source/queue.c **** 
2231:../FreeRTOS/Source/queue.c ****     /* The lock counts contains the number of extra data items placed or
2232:../FreeRTOS/Source/queue.c ****      * removed from the queue while the queue was locked.  When a queue is
2233:../FreeRTOS/Source/queue.c ****      * locked items can be added or removed, but the event lists cannot be
2234:../FreeRTOS/Source/queue.c ****      * updated. */
2235:../FreeRTOS/Source/queue.c ****     taskENTER_CRITICAL();
2236:../FreeRTOS/Source/queue.c ****     {
2237:../FreeRTOS/Source/queue.c ****         int8_t cTxLock = pxQueue->cTxLock;
2238:../FreeRTOS/Source/queue.c **** 
2239:../FreeRTOS/Source/queue.c ****         /* See if data was added to the queue while it was locked. */
2240:../FreeRTOS/Source/queue.c ****         while( cTxLock > queueLOCKED_UNMODIFIED )
2241:../FreeRTOS/Source/queue.c ****         {
2242:../FreeRTOS/Source/queue.c ****             /* Data was posted while the queue was locked.  Are any tasks
2243:../FreeRTOS/Source/queue.c ****              * blocked waiting for data to become available? */
2244:../FreeRTOS/Source/queue.c ****             #if ( configUSE_QUEUE_SETS == 1 )
2245:../FreeRTOS/Source/queue.c ****                 {
2246:../FreeRTOS/Source/queue.c ****                     if( pxQueue->pxQueueSetContainer != NULL )
2247:../FreeRTOS/Source/queue.c ****                     {
2248:../FreeRTOS/Source/queue.c ****                         if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
2249:../FreeRTOS/Source/queue.c ****                         {
2250:../FreeRTOS/Source/queue.c ****                             /* The queue is a member of a queue set, and posting to
2251:../FreeRTOS/Source/queue.c ****                              * the queue set caused a higher priority task to unblock.
2252:../FreeRTOS/Source/queue.c ****                              * A context switch is required. */
2253:../FreeRTOS/Source/queue.c ****                             vTaskMissedYield();
2254:../FreeRTOS/Source/queue.c ****                         }
2255:../FreeRTOS/Source/queue.c ****                         else
2256:../FreeRTOS/Source/queue.c ****                         {
2257:../FreeRTOS/Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
2258:../FreeRTOS/Source/queue.c ****                         }
2259:../FreeRTOS/Source/queue.c ****                     }
2260:../FreeRTOS/Source/queue.c ****                     else
2261:../FreeRTOS/Source/queue.c ****                     {
2262:../FreeRTOS/Source/queue.c ****                         /* Tasks that are removed from the event list will get
2263:../FreeRTOS/Source/queue.c ****                          * added to the pending ready list as the scheduler is still
2264:../FreeRTOS/Source/queue.c ****                          * suspended. */
2265:../FreeRTOS/Source/queue.c ****                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2266:../FreeRTOS/Source/queue.c ****                         {
2267:../FreeRTOS/Source/queue.c ****                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) !=
2268:../FreeRTOS/Source/queue.c ****                             {
2269:../FreeRTOS/Source/queue.c ****                                 /* The task waiting has a higher priority so record that a
2270:../FreeRTOS/Source/queue.c ****                                  * context switch is required. */
2271:../FreeRTOS/Source/queue.c ****                                 vTaskMissedYield();
2272:../FreeRTOS/Source/queue.c ****                             }
2273:../FreeRTOS/Source/queue.c ****                             else
2274:../FreeRTOS/Source/queue.c ****                             {
2275:../FreeRTOS/Source/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
2276:../FreeRTOS/Source/queue.c ****                             }
2277:../FreeRTOS/Source/queue.c ****                         }
2278:../FreeRTOS/Source/queue.c ****                         else
2279:../FreeRTOS/Source/queue.c ****                         {
2280:../FreeRTOS/Source/queue.c ****                             break;
2281:../FreeRTOS/Source/queue.c ****                         }
2282:../FreeRTOS/Source/queue.c ****                     }
2283:../FreeRTOS/Source/queue.c ****                 }
2284:../FreeRTOS/Source/queue.c ****             #else /* configUSE_QUEUE_SETS */
2285:../FreeRTOS/Source/queue.c ****                 {
2286:../FreeRTOS/Source/queue.c ****                     /* Tasks that are removed from the event list will get added to
2287:../FreeRTOS/Source/queue.c ****                      * the pending ready list as the scheduler is still suspended. */
2288:../FreeRTOS/Source/queue.c ****                     if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2289:../FreeRTOS/Source/queue.c ****                     {
2290:../FreeRTOS/Source/queue.c ****                         if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdF
2291:../FreeRTOS/Source/queue.c ****                         {
2292:../FreeRTOS/Source/queue.c ****                             /* The task waiting has a higher priority so record that
2293:../FreeRTOS/Source/queue.c ****                              * a context switch is required. */
2294:../FreeRTOS/Source/queue.c ****                             vTaskMissedYield();
2295:../FreeRTOS/Source/queue.c ****                         }
2296:../FreeRTOS/Source/queue.c ****                         else
2297:../FreeRTOS/Source/queue.c ****                         {
2298:../FreeRTOS/Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
2299:../FreeRTOS/Source/queue.c ****                         }
2300:../FreeRTOS/Source/queue.c ****                     }
2301:../FreeRTOS/Source/queue.c ****                     else
2302:../FreeRTOS/Source/queue.c ****                     {
2303:../FreeRTOS/Source/queue.c ****                         break;
2304:../FreeRTOS/Source/queue.c ****                     }
2305:../FreeRTOS/Source/queue.c ****                 }
2306:../FreeRTOS/Source/queue.c ****             #endif /* configUSE_QUEUE_SETS */
2307:../FreeRTOS/Source/queue.c **** 
2308:../FreeRTOS/Source/queue.c ****             --cTxLock;
2309:../FreeRTOS/Source/queue.c ****         }
2310:../FreeRTOS/Source/queue.c **** 
2311:../FreeRTOS/Source/queue.c ****         pxQueue->cTxLock = queueUNLOCKED;
2312:../FreeRTOS/Source/queue.c ****     }
2313:../FreeRTOS/Source/queue.c ****     taskEXIT_CRITICAL();
2314:../FreeRTOS/Source/queue.c **** 
2315:../FreeRTOS/Source/queue.c ****     /* Do the same for the Rx lock. */
2316:../FreeRTOS/Source/queue.c ****     taskENTER_CRITICAL();
2317:../FreeRTOS/Source/queue.c ****     {
2318:../FreeRTOS/Source/queue.c ****         int8_t cRxLock = pxQueue->cRxLock;
2319:../FreeRTOS/Source/queue.c **** 
2320:../FreeRTOS/Source/queue.c ****         while( cRxLock > queueLOCKED_UNMODIFIED )
2321:../FreeRTOS/Source/queue.c ****         {
2322:../FreeRTOS/Source/queue.c ****             if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2323:../FreeRTOS/Source/queue.c ****             {
2324:../FreeRTOS/Source/queue.c ****                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2325:../FreeRTOS/Source/queue.c ****                 {
2326:../FreeRTOS/Source/queue.c ****                     vTaskMissedYield();
2327:../FreeRTOS/Source/queue.c ****                 }
2328:../FreeRTOS/Source/queue.c ****                 else
2329:../FreeRTOS/Source/queue.c ****                 {
2330:../FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2331:../FreeRTOS/Source/queue.c ****                 }
2332:../FreeRTOS/Source/queue.c **** 
2333:../FreeRTOS/Source/queue.c ****                 --cRxLock;
2334:../FreeRTOS/Source/queue.c ****             }
2335:../FreeRTOS/Source/queue.c ****             else
2336:../FreeRTOS/Source/queue.c ****             {
2337:../FreeRTOS/Source/queue.c ****                 break;
2338:../FreeRTOS/Source/queue.c ****             }
2339:../FreeRTOS/Source/queue.c ****         }
2340:../FreeRTOS/Source/queue.c **** 
2341:../FreeRTOS/Source/queue.c ****         pxQueue->cRxLock = queueUNLOCKED;
2342:../FreeRTOS/Source/queue.c ****     }
2343:../FreeRTOS/Source/queue.c ****     taskEXIT_CRITICAL();
2344:../FreeRTOS/Source/queue.c **** }
2345:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2346:../FreeRTOS/Source/queue.c **** 
2347:../FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
2348:../FreeRTOS/Source/queue.c **** {
  26              	 .loc 1 2348 0
  27              	 .cfi_startproc
  28              	 
  29              	 
  30              	.LVL0:
  31 0000 10B5     	 push {r4,lr}
  32              	.LCFI0:
  33              	 .cfi_def_cfa_offset 8
  34              	 .cfi_offset 4,-8
  35              	 .cfi_offset 14,-4
  36 0002 0446     	 mov r4,r0
2349:../FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
2350:../FreeRTOS/Source/queue.c **** 
2351:../FreeRTOS/Source/queue.c ****     taskENTER_CRITICAL();
  37              	 .loc 1 2351 0
  38 0004 FFF7FEFF 	 bl vPortEnterCritical
  39              	.LVL1:
2352:../FreeRTOS/Source/queue.c ****     {
2353:../FreeRTOS/Source/queue.c ****         if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
  40              	 .loc 1 2353 0
  41 0008 A46B     	 ldr r4,[r4,#56]
  42              	.LVL2:
2354:../FreeRTOS/Source/queue.c ****         {
2355:../FreeRTOS/Source/queue.c ****             xReturn = pdTRUE;
2356:../FreeRTOS/Source/queue.c ****         }
2357:../FreeRTOS/Source/queue.c ****         else
2358:../FreeRTOS/Source/queue.c ****         {
2359:../FreeRTOS/Source/queue.c ****             xReturn = pdFALSE;
2360:../FreeRTOS/Source/queue.c ****         }
2361:../FreeRTOS/Source/queue.c ****     }
2362:../FreeRTOS/Source/queue.c ****     taskEXIT_CRITICAL();
  43              	 .loc 1 2362 0
  44 000a FFF7FEFF 	 bl vPortExitCritical
  45              	.LVL3:
2363:../FreeRTOS/Source/queue.c **** 
2364:../FreeRTOS/Source/queue.c ****     return xReturn;
2365:../FreeRTOS/Source/queue.c **** }
  46              	 .loc 1 2365 0
  47 000e B4FA84F0 	 clz r0,r4
  48 0012 4009     	 lsrs r0,r0,#5
  49 0014 10BD     	 pop {r4,pc}
  50              	 .cfi_endproc
  51              	.LFE32:
  53 0016 00BF     	 .section .text.prvCopyDataToQueue,"ax",%progbits
  54              	 .align 2
  55              	 .thumb
  56              	 .thumb_func
  58              	prvCopyDataToQueue:
  59              	.LFB29:
2126:../FreeRTOS/Source/queue.c ****     BaseType_t xReturn = pdFALSE;
  60              	 .loc 1 2126 0
  61              	 .cfi_startproc
  62              	 
  63              	 
  64              	.LVL4:
  65 0000 70B5     	 push {r4,r5,r6,lr}
  66              	.LCFI1:
  67              	 .cfi_def_cfa_offset 16
  68              	 .cfi_offset 4,-16
  69              	 .cfi_offset 5,-12
  70              	 .cfi_offset 6,-8
  71              	 .cfi_offset 14,-4
  72 0002 0446     	 mov r4,r0
  73 0004 1646     	 mov r6,r2
  74              	.LVL5:
2132:../FreeRTOS/Source/queue.c **** 
  75              	 .loc 1 2132 0
  76 0006 856B     	 ldr r5,[r0,#56]
  77              	.LVL6:
2134:../FreeRTOS/Source/queue.c ****     {
  78              	 .loc 1 2134 0
  79 0008 026C     	 ldr r2,[r0,#64]
  80              	.LVL7:
  81 000a 3AB9     	 cbnz r2,.L4
2138:../FreeRTOS/Source/queue.c ****                 {
  82              	 .loc 1 2138 0
  83 000c 0368     	 ldr r3,[r0]
  84 000e 43BB     	 cbnz r3,.L8
2141:../FreeRTOS/Source/queue.c ****                     pxQueue->u.xSemaphore.xMutexHolder = NULL;
  85              	 .loc 1 2141 0
  86 0010 8068     	 ldr r0,[r0,#8]
  87              	.LVL8:
  88 0012 FFF7FEFF 	 bl xTaskPriorityDisinherit
  89              	.LVL9:
2142:../FreeRTOS/Source/queue.c ****                 }
  90              	 .loc 1 2142 0
  91 0016 0023     	 movs r3,#0
  92 0018 A360     	 str r3,[r4,#8]
  93 001a 29E0     	 b .L5
  94              	.LVL10:
  95              	.L4:
2151:../FreeRTOS/Source/queue.c ****     {
  96              	 .loc 1 2151 0
  97 001c 6EB9     	 cbnz r6,.L6
2153:../FreeRTOS/Source/queue.c ****         pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                 
  98              	 .loc 1 2153 0
  99 001e 4068     	 ldr r0,[r0,#4]
 100              	.LVL11:
 101 0020 FFF7FEFF 	 bl memcpy
 102              	.LVL12:
2154:../FreeRTOS/Source/queue.c **** 
 103              	 .loc 1 2154 0
 104 0024 6268     	 ldr r2,[r4,#4]
 105 0026 236C     	 ldr r3,[r4,#64]
 106 0028 1344     	 add r3,r3,r2
 107 002a 6360     	 str r3,[r4,#4]
2156:../FreeRTOS/Source/queue.c ****         {
 108              	 .loc 1 2156 0
 109 002c A268     	 ldr r2,[r4,#8]
 110 002e 9342     	 cmp r3,r2
 111 0030 19D3     	 bcc .L9
2158:../FreeRTOS/Source/queue.c ****         }
 112              	 .loc 1 2158 0
 113 0032 2368     	 ldr r3,[r4]
 114 0034 6360     	 str r3,[r4,#4]
2127:../FreeRTOS/Source/queue.c ****     UBaseType_t uxMessagesWaiting;
 115              	 .loc 1 2127 0
 116 0036 0020     	 movs r0,#0
 117 0038 1AE0     	 b .L5
 118              	.LVL13:
 119              	.L6:
2167:../FreeRTOS/Source/queue.c ****         pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 120              	 .loc 1 2167 0
 121 003a C068     	 ldr r0,[r0,#12]
 122              	.LVL14:
 123 003c FFF7FEFF 	 bl memcpy
 124              	.LVL15:
2168:../FreeRTOS/Source/queue.c **** 
 125              	 .loc 1 2168 0
 126 0040 236C     	 ldr r3,[r4,#64]
 127 0042 5B42     	 negs r3,r3
 128 0044 E268     	 ldr r2,[r4,#12]
 129 0046 1A44     	 add r2,r2,r3
 130 0048 E260     	 str r2,[r4,#12]
2170:../FreeRTOS/Source/queue.c ****         {
 131              	 .loc 1 2170 0
 132 004a 2168     	 ldr r1,[r4]
 133 004c 8A42     	 cmp r2,r1
 134 004e 02D2     	 bcs .L7
2172:../FreeRTOS/Source/queue.c ****         }
 135              	 .loc 1 2172 0
 136 0050 A268     	 ldr r2,[r4,#8]
 137 0052 1344     	 add r3,r3,r2
 138 0054 E360     	 str r3,[r4,#12]
 139              	.L7:
2179:../FreeRTOS/Source/queue.c ****         {
 140              	 .loc 1 2179 0
 141 0056 022E     	 cmp r6,#2
 142 0058 07D1     	 bne .L10
2181:../FreeRTOS/Source/queue.c ****             {
 143              	 .loc 1 2181 0
 144 005a 45B1     	 cbz r5,.L11
2187:../FreeRTOS/Source/queue.c ****             }
 145              	 .loc 1 2187 0
 146 005c 013D     	 subs r5,r5,#1
 147              	.LVL16:
2127:../FreeRTOS/Source/queue.c ****     UBaseType_t uxMessagesWaiting;
 148              	 .loc 1 2127 0
 149 005e 0020     	 movs r0,#0
 150 0060 06E0     	 b .L5
 151              	.LVL17:
 152              	.L8:
 153 0062 0020     	 movs r0,#0
 154              	.LVL18:
 155 0064 04E0     	 b .L5
 156              	.LVL19:
 157              	.L9:
 158 0066 0020     	 movs r0,#0
 159 0068 02E0     	 b .L5
 160              	.L10:
 161 006a 0020     	 movs r0,#0
 162 006c 00E0     	 b .L5
 163              	.L11:
 164 006e 0020     	 movs r0,#0
 165              	.LVL20:
 166              	.L5:
2200:../FreeRTOS/Source/queue.c **** 
 167              	 .loc 1 2200 0
 168 0070 0135     	 adds r5,r5,#1
 169              	.LVL21:
 170 0072 A563     	 str r5,[r4,#56]
2203:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 171              	 .loc 1 2203 0
 172 0074 70BD     	 pop {r4,r5,r6,pc}
 173              	 .cfi_endproc
 174              	.LFE29:
 176 0076 00BF     	 .section .text.prvCopyDataFromQueue,"ax",%progbits
 177              	 .align 2
 178              	 .thumb
 179              	 .thumb_func
 181              	prvCopyDataFromQueue:
 182              	.LFB30:
2208:../FreeRTOS/Source/queue.c ****     if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 183              	 .loc 1 2208 0
 184              	 .cfi_startproc
 185              	 
 186              	 
 187              	.LVL22:
2209:../FreeRTOS/Source/queue.c ****     {
 188              	 .loc 1 2209 0
 189 0000 026C     	 ldr r2,[r0,#64]
 190 0002 72B1     	 cbz r2,.L17
2208:../FreeRTOS/Source/queue.c ****     if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 191              	 .loc 1 2208 0
 192 0004 10B5     	 push {r4,lr}
 193              	.LCFI2:
 194              	 .cfi_def_cfa_offset 8
 195              	 .cfi_offset 4,-8
 196              	 .cfi_offset 14,-4
2211:../FreeRTOS/Source/queue.c **** 
 197              	 .loc 1 2211 0
 198 0006 C368     	 ldr r3,[r0,#12]
 199 0008 1344     	 add r3,r3,r2
 200 000a C360     	 str r3,[r0,#12]
2213:../FreeRTOS/Source/queue.c ****         {
 201              	 .loc 1 2213 0
 202 000c 8468     	 ldr r4,[r0,#8]
 203 000e A342     	 cmp r3,r4
2215:../FreeRTOS/Source/queue.c ****         }
 204              	 .loc 1 2215 0
 205 0010 24BF     	 itt cs
 206 0012 0368     	 ldrcs r3,[r0]
 207 0014 C360     	 strcs r3,[r0,#12]
 208 0016 0346     	 mov r3,r0
2222:../FreeRTOS/Source/queue.c ****     }
 209              	 .loc 1 2222 0
 210 0018 0846     	 mov r0,r1
 211              	.LVL23:
 212 001a D968     	 ldr r1,[r3,#12]
 213              	.LVL24:
 214 001c FFF7FEFF 	 bl memcpy
 215              	.LVL25:
 216 0020 10BD     	 pop {r4,pc}
 217              	.LVL26:
 218              	.L17:
 219              	.LCFI3:
 220              	 .cfi_def_cfa_offset 0
 221              	 .cfi_restore 4
 222              	 .cfi_restore 14
 223 0022 7047     	 bx lr
 224              	 .cfi_endproc
 225              	.LFE30:
 227              	 .section .text.prvUnlockQueue,"ax",%progbits
 228              	 .align 2
 229              	 .thumb
 230              	 .thumb_func
 232              	prvUnlockQueue:
 233              	.LFB31:
2228:../FreeRTOS/Source/queue.c ****     /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
 234              	 .loc 1 2228 0
 235              	 .cfi_startproc
 236              	 
 237              	 
 238              	.LVL27:
 239 0000 70B5     	 push {r4,r5,r6,lr}
 240              	.LCFI4:
 241              	 .cfi_def_cfa_offset 16
 242              	 .cfi_offset 4,-16
 243              	 .cfi_offset 5,-12
 244              	 .cfi_offset 6,-8
 245              	 .cfi_offset 14,-4
 246 0002 0546     	 mov r5,r0
2235:../FreeRTOS/Source/queue.c ****     {
 247              	 .loc 1 2235 0
 248 0004 FFF7FEFF 	 bl vPortEnterCritical
 249              	.LVL28:
 250              	.LBB109:
2237:../FreeRTOS/Source/queue.c **** 
 251              	 .loc 1 2237 0
 252 0008 95F84530 	 ldrb r3,[r5,#69]
 253 000c DCB2     	 uxtb r4,r3
 254              	.LVL29:
2240:../FreeRTOS/Source/queue.c ****         {
 255              	 .loc 1 2240 0
 256 000e 63B2     	 sxtb r3,r4
 257 0010 002B     	 cmp r3,#0
 258 0012 11DD     	 ble .L19
2288:../FreeRTOS/Source/queue.c ****                     {
 259              	 .loc 1 2288 0
 260 0014 6B6A     	 ldr r3,[r5,#36]
2290:../FreeRTOS/Source/queue.c ****                         {
 261              	 .loc 1 2290 0
 262 0016 05F12406 	 add r6,r5,#36
2288:../FreeRTOS/Source/queue.c ****                     {
 263              	 .loc 1 2288 0
 264 001a 1BB9     	 cbnz r3,.L27
 265 001c 0CE0     	 b .L19
 266              	.LVL30:
 267              	.L22:
 268 001e 6B6A     	 ldr r3,[r5,#36]
 269              	.LVL31:
 270 0020 03B9     	 cbnz r3,.L27
 271 0022 09E0     	 b .L19
 272              	.L27:
 273              	.LVL32:
2290:../FreeRTOS/Source/queue.c ****                         {
 274              	 .loc 1 2290 0
 275 0024 3046     	 mov r0,r6
 276 0026 FFF7FEFF 	 bl xTaskRemoveFromEventList
 277              	.LVL33:
 278 002a 08B1     	 cbz r0,.L21
2294:../FreeRTOS/Source/queue.c ****                         }
 279              	 .loc 1 2294 0
 280 002c FFF7FEFF 	 bl vTaskMissedYield
 281              	.LVL34:
 282              	.L21:
 283 0030 631E     	 subs r3,r4,#1
 284              	.LVL35:
2240:../FreeRTOS/Source/queue.c ****         {
 285              	 .loc 1 2240 0
 286 0032 13F0FF04 	 ands r4,r3,#255
 287 0036 F2D1     	 bne .L22
 288              	.LVL36:
 289              	.L19:
2311:../FreeRTOS/Source/queue.c ****     }
 290              	 .loc 1 2311 0
 291 0038 FF23     	 movs r3,#255
 292 003a 85F84530 	 strb r3,[r5,#69]
 293              	.LBE109:
2313:../FreeRTOS/Source/queue.c **** 
 294              	 .loc 1 2313 0
 295 003e FFF7FEFF 	 bl vPortExitCritical
 296              	.LVL37:
2316:../FreeRTOS/Source/queue.c ****     {
 297              	 .loc 1 2316 0
 298 0042 FFF7FEFF 	 bl vPortEnterCritical
 299              	.LVL38:
 300              	.LBB110:
2318:../FreeRTOS/Source/queue.c **** 
 301              	 .loc 1 2318 0
 302 0046 95F84430 	 ldrb r3,[r5,#68]
 303 004a DCB2     	 uxtb r4,r3
 304              	.LVL39:
2320:../FreeRTOS/Source/queue.c ****         {
 305              	 .loc 1 2320 0
 306 004c 63B2     	 sxtb r3,r4
 307 004e 002B     	 cmp r3,#0
 308 0050 11DD     	 ble .L23
2322:../FreeRTOS/Source/queue.c ****             {
 309              	 .loc 1 2322 0
 310 0052 2B69     	 ldr r3,[r5,#16]
2324:../FreeRTOS/Source/queue.c ****                 {
 311              	 .loc 1 2324 0
 312 0054 05F11006 	 add r6,r5,#16
2322:../FreeRTOS/Source/queue.c ****             {
 313              	 .loc 1 2322 0
 314 0058 1BB9     	 cbnz r3,.L28
 315 005a 0CE0     	 b .L23
 316              	.LVL40:
 317              	.L26:
 318 005c 2B69     	 ldr r3,[r5,#16]
 319              	.LVL41:
 320 005e 03B9     	 cbnz r3,.L28
 321 0060 09E0     	 b .L23
 322              	.L28:
 323              	.LVL42:
2324:../FreeRTOS/Source/queue.c ****                 {
 324              	 .loc 1 2324 0
 325 0062 3046     	 mov r0,r6
 326 0064 FFF7FEFF 	 bl xTaskRemoveFromEventList
 327              	.LVL43:
 328 0068 08B1     	 cbz r0,.L25
2326:../FreeRTOS/Source/queue.c ****                 }
 329              	 .loc 1 2326 0
 330 006a FFF7FEFF 	 bl vTaskMissedYield
 331              	.LVL44:
 332              	.L25:
 333 006e 631E     	 subs r3,r4,#1
 334              	.LVL45:
2320:../FreeRTOS/Source/queue.c ****         {
 335              	 .loc 1 2320 0
 336 0070 13F0FF04 	 ands r4,r3,#255
 337 0074 F2D1     	 bne .L26
 338              	.LVL46:
 339              	.L23:
2341:../FreeRTOS/Source/queue.c ****     }
 340              	 .loc 1 2341 0
 341 0076 FF23     	 movs r3,#255
 342 0078 85F84430 	 strb r3,[r5,#68]
 343              	.LBE110:
2343:../FreeRTOS/Source/queue.c **** }
 344              	 .loc 1 2343 0
 345 007c FFF7FEFF 	 bl vPortExitCritical
 346              	.LVL47:
 347 0080 70BD     	 pop {r4,r5,r6,pc}
 348              	 .cfi_endproc
 349              	.LFE31:
 351 0082 00BF     	 .section .text.xQueueGenericReset,"ax",%progbits
 352              	 .align 2
 353              	 .global xQueueGenericReset
 354              	 .thumb
 355              	 .thumb_func
 357              	xQueueGenericReset:
 358              	.LFB5:
 266:../FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 359              	 .loc 1 266 0
 360              	 .cfi_startproc
 361              	 
 362              	 
 363              	.LVL48:
 364 0000 38B5     	 push {r3,r4,r5,lr}
 365              	.LCFI5:
 366              	 .cfi_def_cfa_offset 16
 367              	 .cfi_offset 3,-16
 368              	 .cfi_offset 4,-12
 369              	 .cfi_offset 5,-8
 370              	 .cfi_offset 14,-4
 371              	.LVL49:
 269:../FreeRTOS/Source/queue.c **** 
 372              	 .loc 1 269 0
 373 0002 40B9     	 cbnz r0,.L31
 374              	.LBB111:
 375              	.LBB112:
 376              	 .file 2 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h"
   1:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*
   2:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * FreeRTOS Kernel V10.4.1
   3:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
   5:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * this software and associated documentation files (the "Software"), to deal in
   7:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * the Software without restriction, including without limitation the rights to
   8:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * subject to the following conditions:
  11:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  12:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * The above copyright notice and this permission notice shall be included in all
  13:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * copies or substantial portions of the Software.
  14:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  15:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  22:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * https://www.FreeRTOS.org
  23:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * https://github.com/FreeRTOS
  24:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  25:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * 1 tab == 4 spaces!
  26:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  */
  27:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  28:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  29:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** #ifndef PORTMACRO_H
  30:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define PORTMACRO_H
  31:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  32:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifdef __cplusplus
  33:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         extern "C" {
  34:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
  35:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  36:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------
  37:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * Port specific definitions.
  38:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  39:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * The settings in this file configure FreeRTOS correctly for the
  40:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * given hardware and compiler.
  41:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  42:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * These settings should not be altered.
  43:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *-----------------------------------------------------------
  44:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  */
  45:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  46:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Type definitions. */
  47:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portCHAR          char
  48:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portFLOAT         float
  49:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portDOUBLE        double
  50:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portLONG          long
  51:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portSHORT         short
  52:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portSTACK_TYPE    uint32_t
  53:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portBASE_TYPE     long
  54:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  55:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     typedef portSTACK_TYPE   StackType_t;
  56:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     typedef long             BaseType_t;
  57:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     typedef unsigned long    UBaseType_t;
  58:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  59:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #if ( configUSE_16_BIT_TICKS == 1 )
  60:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         typedef uint16_t     TickType_t;
  61:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portMAX_DELAY              ( TickType_t ) 0xffff
  62:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #else
  63:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         typedef uint32_t     TickType_t;
  64:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portMAX_DELAY              ( TickType_t ) 0xffffffffUL
  65:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  66:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
  67:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * not need to be guarded with a critical section. */
  68:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portTICK_TYPE_IS_ATOMIC    1
  69:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
  70:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
  71:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  72:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Architecture specifics. */
  73:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portSTACK_GROWTH      ( -1 )
  74:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portTICK_PERIOD_MS    ( ( TickType_t ) 1000 / configTICK_RATE_HZ )
  75:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portBYTE_ALIGNMENT    8
  76:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portDONT_DISCARD      __attribute__( ( used ) )
  77:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
  78:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  79:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Scheduler utilities. */
  80:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portYIELD()                                 \
  81:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     {                                                   \
  82:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         /* Set a PendSV to request a context switch. */ \
  83:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT; \
  84:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****                                                         \
  85:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         /* Barriers are normally not required but do ensure the code is completely \
  86:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****          * within the specified behaviour for the architecture. */ \
  87:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile ( "dsb" ::: "memory" );                     \
  88:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile ( "isb" );                                  \
  89:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     }
  90:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  91:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portNVIC_INT_CTRL_REG     ( *( ( volatile uint32_t * ) 0xe000ed04 ) )
  92:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portNVIC_PENDSVSET_BIT    ( 1UL << 28UL )
  93:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portEND_SWITCHING_ISR( xSwitchRequired )    if( xSwitchRequired != pdFALSE ) portYIELD(
  94:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portYIELD_FROM_ISR( x )                     portEND_SWITCHING_ISR( x )
  95:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
  96:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  97:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Critical section management. */
  98:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     extern void vPortEnterCritical( void );
  99:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     extern void vPortExitCritical( void );
 100:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portSET_INTERRUPT_MASK_FROM_ISR()         ulPortRaiseBASEPRI()
 101:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portCLEAR_INTERRUPT_MASK_FROM_ISR( x )    vPortSetBASEPRI( x )
 102:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portDISABLE_INTERRUPTS()                  vPortRaiseBASEPRI()
 103:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portENABLE_INTERRUPTS()                   vPortSetBASEPRI( 0 )
 104:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portENTER_CRITICAL()                      vPortEnterCritical()
 105:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portEXIT_CRITICAL()                       vPortExitCritical()
 106:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 107:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 108:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 109:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Task function macros as described on the FreeRTOS.org WEB site.  These are
 110:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * not necessary for to use this port.  They are defined so the common demo files
 111:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * (which build with all the ports) will build. */
 112:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portTASK_FUNCTION_PROTO( vFunction, pvParameters )    void vFunction( void * pvParamete
 113:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portTASK_FUNCTION( vFunction, pvParameters )          void vFunction( void * pvParamete
 114:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 115:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 116:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Tickless idle/low power functionality. */
 117:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifndef portSUPPRESS_TICKS_AND_SLEEP
 118:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
 119:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime )    vPortSuppressTicksAndSleep( xE
 120:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
 121:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 122:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 123:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Architecture specific optimisations. */
 124:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
 125:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define configUSE_PORT_OPTIMISED_TASK_SELECTION    1
 126:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
 127:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 128:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
 129:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 130:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Generic helper function. */
 131:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t 
 132:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         {
 133:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             uint8_t ucReturn;
 134:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 135:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             __asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 136:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 137:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             return ucReturn;
 138:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         }
 139:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 140:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Check the configuration. */
 141:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #if ( configMAX_PRIORITIES > 32 )
 142:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             #error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIO
 143:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #endif
 144:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 145:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Store/clear the ready priorities in a bit map. */
 146:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities )    ( uxReadyPriorities )
 147:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities )     ( uxReadyPriorities )
 148:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 149:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 150:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 151:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities )    uxTopPriority = ( 3
 152:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 153:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 154:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 155:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 156:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 157:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifdef configASSERT
 158:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         void vPortValidateInterruptPriority( void );
 159:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portASSERT_IF_INTERRUPT_PRIORITY_INVALID()    vPortValidateInterruptPriority()
 160:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
 161:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 162:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* portNOP() is not required by this port. */
 163:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portNOP()
 164:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 165:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portINLINE              __inline
 166:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 167:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifndef portFORCE_INLINE
 168:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portFORCE_INLINE    inline __attribute__( ( always_inline ) )
 169:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
 170:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 171:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     portFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )
 172:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     {
 173:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         uint32_t ulCurrentInterrupt;
 174:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         BaseType_t xReturn;
 175:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 176:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         /* Obtain the number of the currently executing interrupt. */
 177:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile ( "mrs %0, ipsr" : "=r" ( ulCurrentInterrupt )::"memory" );
 178:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 179:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         if( ulCurrentInterrupt == 0 )
 180:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         {
 181:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             xReturn = pdFALSE;
 182:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         }
 183:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         else
 184:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         {
 185:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             xReturn = pdTRUE;
 186:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         }
 187:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 188:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         return xReturn;
 189:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     }
 190:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 191:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 192:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 193:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     portFORCE_INLINE static void vPortRaiseBASEPRI( void )
 194:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     {
 195:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         uint32_t ulNewBASEPRI;
 196:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile
 377              	 .loc 2 197 0
 378              	
 379 0004 4FF01403 	 mov r3,#20
 380 0008 83F31188 	 msr basepri,r3
 381 000c BFF36F8F 	 isb 
 382 0010 BFF34F8F 	 dsb 
 383              	
 384              	
 385              	.LVL50:
 386              	 .thumb
 387              	.L32:
 388              	.LBE112:
 389              	.LBE111:
 269:../FreeRTOS/Source/queue.c **** 
 390              	 .loc 1 269 0 discriminator 1
 391 0014 FEE7     	 b .L32
 392              	.L31:
 393 0016 0446     	 mov r4,r0
 394 0018 0D46     	 mov r5,r1
 271:../FreeRTOS/Source/queue.c ****     {
 395              	 .loc 1 271 0
 396 001a FFF7FEFF 	 bl vPortEnterCritical
 397              	.LVL51:
 273:../FreeRTOS/Source/queue.c ****         pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 398              	 .loc 1 273 0
 399 001e 2268     	 ldr r2,[r4]
 400 0020 216C     	 ldr r1,[r4,#64]
 401 0022 E36B     	 ldr r3,[r4,#60]
 402 0024 03FB01F3 	 mul r3,r3,r1
 403 0028 D018     	 adds r0,r2,r3
 404 002a A060     	 str r0,[r4,#8]
 274:../FreeRTOS/Source/queue.c ****         pxQueue->pcWriteTo = pxQueue->pcHead;
 405              	 .loc 1 274 0
 406 002c 0020     	 movs r0,#0
 407 002e A063     	 str r0,[r4,#56]
 275:../FreeRTOS/Source/queue.c ****         pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->ux
 408              	 .loc 1 275 0
 409 0030 6260     	 str r2,[r4,#4]
 276:../FreeRTOS/Source/queue.c ****         pxQueue->cRxLock = queueUNLOCKED;
 410              	 .loc 1 276 0
 411 0032 5B1A     	 subs r3,r3,r1
 412 0034 1344     	 add r3,r3,r2
 413 0036 E360     	 str r3,[r4,#12]
 277:../FreeRTOS/Source/queue.c ****         pxQueue->cTxLock = queueUNLOCKED;
 414              	 .loc 1 277 0
 415 0038 FF23     	 movs r3,#255
 416 003a 84F84430 	 strb r3,[r4,#68]
 278:../FreeRTOS/Source/queue.c **** 
 417              	 .loc 1 278 0
 418 003e 84F84530 	 strb r3,[r4,#69]
 280:../FreeRTOS/Source/queue.c ****         {
 419              	 .loc 1 280 0
 420 0042 7DB9     	 cbnz r5,.L33
 287:../FreeRTOS/Source/queue.c ****             {
 421              	 .loc 1 287 0
 422 0044 2369     	 ldr r3,[r4,#16]
 423 0046 ABB1     	 cbz r3,.L34
 289:../FreeRTOS/Source/queue.c ****                 {
 424              	 .loc 1 289 0
 425 0048 04F11000 	 add r0,r4,#16
 426 004c FFF7FEFF 	 bl xTaskRemoveFromEventList
 427              	.LVL52:
 428 0050 80B1     	 cbz r0,.L34
 291:../FreeRTOS/Source/queue.c ****                 }
 429              	 .loc 1 291 0
 430 0052 4FF08052 	 mov r2,#268435456
 431 0056 094B     	 ldr r3,.L36
 432 0058 1A60     	 str r2,[r3]
 433              	
 434 005a BFF34F8F 	 dsb
 435              	
 436              	
 437 005e BFF36F8F 	 isb
 438              	
 439              	 .thumb
 440 0062 07E0     	 b .L34
 441              	.L33:
 306:../FreeRTOS/Source/queue.c ****             vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 442              	 .loc 1 306 0
 443 0064 04F11000 	 add r0,r4,#16
 444 0068 FFF7FEFF 	 bl vListInitialise
 445              	.LVL53:
 307:../FreeRTOS/Source/queue.c ****         }
 446              	 .loc 1 307 0
 447 006c 04F12400 	 add r0,r4,#36
 448 0070 FFF7FEFF 	 bl vListInitialise
 449              	.LVL54:
 450              	.L34:
 310:../FreeRTOS/Source/queue.c **** 
 451              	 .loc 1 310 0
 452 0074 FFF7FEFF 	 bl vPortExitCritical
 453              	.LVL55:
 315:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 454              	 .loc 1 315 0
 455 0078 0120     	 movs r0,#1
 456 007a 38BD     	 pop {r3,r4,r5,pc}
 457              	.LVL56:
 458              	.L37:
 459              	 .align 2
 460              	.L36:
 461 007c 04ED00E0 	 .word -536810236
 462              	 .cfi_endproc
 463              	.LFE5:
 465              	 .section .text.xQueueGenericCreate,"ax",%progbits
 466              	 .align 2
 467              	 .global xQueueGenericCreate
 468              	 .thumb
 469              	 .thumb_func
 471              	xQueueGenericCreate:
 472              	.LFB6:
 385:../FreeRTOS/Source/queue.c ****         Queue_t * pxNewQueue;
 473              	 .loc 1 385 0
 474              	 .cfi_startproc
 475              	 
 476              	 
 477              	.LVL57:
 478 0000 F8B5     	 push {r3,r4,r5,r6,r7,lr}
 479              	.LCFI6:
 480              	 .cfi_def_cfa_offset 24
 481              	 .cfi_offset 3,-24
 482              	 .cfi_offset 4,-20
 483              	 .cfi_offset 5,-16
 484              	 .cfi_offset 6,-12
 485              	 .cfi_offset 7,-8
 486              	 .cfi_offset 14,-4
 390:../FreeRTOS/Source/queue.c **** 
 487              	 .loc 1 390 0
 488 0002 40B9     	 cbnz r0,.L39
 489              	.LBB119:
 490              	.LBB120:
 491              	 .loc 2 197 0
 492              	
 493 0004 4FF01403 	 mov r3,#20
 494 0008 83F31188 	 msr basepri,r3
 495 000c BFF36F8F 	 isb 
 496 0010 BFF34F8F 	 dsb 
 497              	
 498              	
 499              	.LVL58:
 500              	 .thumb
 501              	.L40:
 502              	.LBE120:
 503              	.LBE119:
 390:../FreeRTOS/Source/queue.c **** 
 504              	 .loc 1 390 0 discriminator 1
 505 0014 FEE7     	 b .L40
 506              	.L39:
 507 0016 0D46     	 mov r5,r1
 508 0018 1746     	 mov r7,r2
 509 001a 0646     	 mov r6,r0
 395:../FreeRTOS/Source/queue.c **** 
 510              	 .loc 1 395 0
 511 001c 01FB00F0 	 mul r0,r1,r0
 512              	.LVL59:
 398:../FreeRTOS/Source/queue.c **** 
 513              	 .loc 1 398 0
 514 0020 B9B1     	 cbz r1,.L41
 398:../FreeRTOS/Source/queue.c **** 
 515              	 .loc 1 398 0 is_stmt 0 discriminator 2
 516 0022 B0FBF1F3 	 udiv r3,r0,r1
 517 0026 9E42     	 cmp r6,r3
 518 0028 1ED0     	 beq .L42
 519              	.LBB121:
 520              	.LBB122:
 521              	 .loc 2 197 0 is_stmt 1
 522              	
 523 002a 4FF01403 	 mov r3,#20
 524 002e 83F31188 	 msr basepri,r3
 525 0032 BFF36F8F 	 isb 
 526 0036 BFF34F8F 	 dsb 
 527              	
 528              	
 529              	.LVL60:
 530              	 .thumb
 531              	.L43:
 532              	.LBE122:
 533              	.LBE121:
 398:../FreeRTOS/Source/queue.c **** 
 534              	 .loc 1 398 0 discriminator 2
 535 003a FEE7     	 b .L43
 536              	.LVL61:
 537              	.L44:
 538              	.LBB123:
 539              	.LBB124:
 467:../FreeRTOS/Source/queue.c ****     pxNewQueue->uxItemSize = uxItemSize;
 540              	 .loc 1 467 0
 541 003c E663     	 str r6,[r4,#60]
 468:../FreeRTOS/Source/queue.c ****     ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 542              	 .loc 1 468 0
 543 003e 2564     	 str r5,[r4,#64]
 469:../FreeRTOS/Source/queue.c **** 
 544              	 .loc 1 469 0
 545 0040 2046     	 mov r0,r4
 546              	.LVL62:
 547 0042 0121     	 movs r1,#1
 548 0044 FFF7FEFF 	 bl xQueueGenericReset
 549              	.LVL63:
 473:../FreeRTOS/Source/queue.c ****         }
 550              	 .loc 1 473 0
 551 0048 84F84C70 	 strb r7,[r4,#76]
 552 004c 12E0     	 b .L48
 553              	.LVL64:
 554              	.L45:
 457:../FreeRTOS/Source/queue.c ****     }
 555              	 .loc 1 457 0
 556 004e 2460     	 str r4,[r4]
 557 0050 F4E7     	 b .L44
 558              	.LVL65:
 559              	.L41:
 560              	.LBE124:
 561              	.LBE123:
 409:../FreeRTOS/Source/queue.c **** 
 562              	 .loc 1 409 0
 563 0052 5030     	 adds r0,r0,#80
 564              	.LVL66:
 565 0054 FFF7FEFF 	 bl pvPortMalloc
 566              	.LVL67:
 411:../FreeRTOS/Source/queue.c ****         {
 567              	 .loc 1 411 0
 568 0058 0446     	 mov r4,r0
 569 005a 0028     	 cmp r0,#0
 570 005c F7D1     	 bne .L45
 571 005e 09E0     	 b .L48
 572              	.L47:
 573              	.LVL68:
 416:../FreeRTOS/Source/queue.c **** 
 574              	 .loc 1 416 0
 575 0060 04F15003 	 add r3,r4,#80
 576              	.LVL69:
 577              	.LBB126:
 578              	.LBB125:
 462:../FreeRTOS/Source/queue.c ****     }
 579              	 .loc 1 462 0
 580 0064 2360     	 str r3,[r4]
 581 0066 E9E7     	 b .L44
 582              	.LVL70:
 583              	.L42:
 584              	.LBE125:
 585              	.LBE126:
 409:../FreeRTOS/Source/queue.c **** 
 586              	 .loc 1 409 0
 587 0068 5030     	 adds r0,r0,#80
 588              	.LVL71:
 589 006a FFF7FEFF 	 bl pvPortMalloc
 590              	.LVL72:
 411:../FreeRTOS/Source/queue.c ****         {
 591              	 .loc 1 411 0
 592 006e 0446     	 mov r4,r0
 593 0070 0028     	 cmp r0,#0
 594 0072 F5D1     	 bne .L47
 595              	.LVL73:
 596              	.L48:
 436:../FreeRTOS/Source/queue.c **** 
 597              	 .loc 1 436 0
 598 0074 2046     	 mov r0,r4
 599 0076 F8BD     	 pop {r3,r4,r5,r6,r7,pc}
 600              	 .cfi_endproc
 601              	.LFE6:
 603              	 .section .text.xQueueCreateCountingSemaphore,"ax",%progbits
 604              	 .align 2
 605              	 .global xQueueCreateCountingSemaphore
 606              	 .thumb
 607              	 .thumb_func
 609              	xQueueCreateCountingSemaphore:
 610              	.LFB12:
 743:../FreeRTOS/Source/queue.c ****         QueueHandle_t xHandle;
 611              	 .loc 1 743 0
 612              	 .cfi_startproc
 613              	 
 614              	 
 615              	.LVL74:
 746:../FreeRTOS/Source/queue.c ****         configASSERT( uxInitialCount <= uxMaxCount );
 616              	 .loc 1 746 0
 617 0000 40B9     	 cbnz r0,.L51
 618              	.LBB127:
 619              	.LBB128:
 620              	 .loc 2 197 0
 621              	
 622 0002 4FF01403 	 mov r3,#20
 623 0006 83F31188 	 msr basepri,r3
 624 000a BFF36F8F 	 isb 
 625 000e BFF34F8F 	 dsb 
 626              	
 627              	
 628              	.LVL75:
 629              	 .thumb
 630              	.L52:
 631              	.LBE128:
 632              	.LBE127:
 746:../FreeRTOS/Source/queue.c ****         configASSERT( uxInitialCount <= uxMaxCount );
 633              	 .loc 1 746 0 discriminator 1
 634 0012 FEE7     	 b .L52
 635              	.L51:
 747:../FreeRTOS/Source/queue.c **** 
 636              	 .loc 1 747 0
 637 0014 8842     	 cmp r0,r1
 638 0016 08D2     	 bcs .L53
 639              	.LBB129:
 640              	.LBB130:
 641              	 .loc 2 197 0
 642              	
 643 0018 4FF01403 	 mov r3,#20
 644 001c 83F31188 	 msr basepri,r3
 645 0020 BFF36F8F 	 isb 
 646 0024 BFF34F8F 	 dsb 
 647              	
 648              	
 649              	.LVL76:
 650              	 .thumb
 651              	.L54:
 652              	.LBE130:
 653              	.LBE129:
 747:../FreeRTOS/Source/queue.c **** 
 654              	 .loc 1 747 0 discriminator 2
 655 0028 FEE7     	 b .L54
 656              	.L53:
 743:../FreeRTOS/Source/queue.c ****         QueueHandle_t xHandle;
 657              	 .loc 1 743 0
 658 002a 10B5     	 push {r4,lr}
 659              	.LCFI7:
 660              	 .cfi_def_cfa_offset 8
 661              	 .cfi_offset 4,-8
 662              	 .cfi_offset 14,-4
 663 002c 0C46     	 mov r4,r1
 749:../FreeRTOS/Source/queue.c **** 
 664              	 .loc 1 749 0
 665 002e 0021     	 movs r1,#0
 666              	.LVL77:
 667 0030 0222     	 movs r2,#2
 668 0032 FFF7FEFF 	 bl xQueueGenericCreate
 669              	.LVL78:
 751:../FreeRTOS/Source/queue.c ****         {
 670              	 .loc 1 751 0
 671 0036 0346     	 mov r3,r0
 672 0038 00B1     	 cbz r0,.L55
 753:../FreeRTOS/Source/queue.c **** 
 673              	 .loc 1 753 0
 674 003a 8463     	 str r4,[r0,#56]
 675              	.L55:
 763:../FreeRTOS/Source/queue.c **** 
 676              	 .loc 1 763 0
 677 003c 1846     	 mov r0,r3
 678              	.LVL79:
 679 003e 10BD     	 pop {r4,pc}
 680              	 .cfi_endproc
 681              	.LFE12:
 683              	 .section .text.xQueueGenericSend,"ax",%progbits
 684              	 .align 2
 685              	 .global xQueueGenericSend
 686              	 .thumb
 687              	 .thumb_func
 689              	xQueueGenericSend:
 690              	.LFB13:
 772:../FreeRTOS/Source/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 691              	 .loc 1 772 0
 692              	 .cfi_startproc
 693              	 
 694              	 
 695              	.LVL80:
 696 0000 2DE9F04F 	 push {r4,r5,r6,r7,r8,r9,r10,fp,lr}
 697              	.LCFI8:
 698              	 .cfi_def_cfa_offset 36
 699              	 .cfi_offset 4,-36
 700              	 .cfi_offset 5,-32
 701              	 .cfi_offset 6,-28
 702              	 .cfi_offset 7,-24
 703              	 .cfi_offset 8,-20
 704              	 .cfi_offset 9,-16
 705              	 .cfi_offset 10,-12
 706              	 .cfi_offset 11,-8
 707              	 .cfi_offset 14,-4
 708 0004 85B0     	 sub sp,sp,#20
 709              	.LCFI9:
 710              	 .cfi_def_cfa_offset 56
 711 0006 0192     	 str r2,[sp,#4]
 712              	.LVL81:
 777:../FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
 713              	 .loc 1 777 0
 714 0008 40B9     	 cbnz r0,.L58
 715              	.LBB141:
 716              	.LBB142:
 717              	 .loc 2 197 0
 718              	
 719 000a 4FF01403 	 mov r3,#20
 720 000e 83F31188 	 msr basepri,r3
 721 0012 BFF36F8F 	 isb 
 722 0016 BFF34F8F 	 dsb 
 723              	
 724              	
 725              	.LVL82:
 726              	 .thumb
 727              	.L59:
 728              	.LBE142:
 729              	.LBE141:
 777:../FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
 730              	 .loc 1 777 0 discriminator 1
 731 001a FEE7     	 b .L59
 732              	.LVL83:
 733              	.L58:
 734 001c 0446     	 mov r4,r0
 778:../FreeRTOS/Source/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 735              	 .loc 1 778 0
 736 001e 51B9     	 cbnz r1,.L60
 778:../FreeRTOS/Source/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 737              	 .loc 1 778 0 is_stmt 0 discriminator 2
 738 0020 026C     	 ldr r2,[r0,#64]
 739              	.LVL84:
 740 0022 42B1     	 cbz r2,.L60
 741              	.LBB143:
 742              	.LBB144:
 743              	 .loc 2 197 0 is_stmt 1
 744              	
 745 0024 4FF01403 	 mov r3,#20
 746 0028 83F31188 	 msr basepri,r3
 747 002c BFF36F8F 	 isb 
 748 0030 BFF34F8F 	 dsb 
 749              	
 750              	
 751              	.LVL85:
 752              	 .thumb
 753              	.L61:
 754              	.LBE144:
 755              	.LBE143:
 778:../FreeRTOS/Source/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 756              	 .loc 1 778 0 discriminator 2
 757 0034 FEE7     	 b .L61
 758              	.LVL86:
 759              	.L60:
 779:../FreeRTOS/Source/queue.c ****     #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 760              	 .loc 1 779 0
 761 0036 022B     	 cmp r3,#2
 762 0038 0BD1     	 bne .L62
 779:../FreeRTOS/Source/queue.c ****     #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 763              	 .loc 1 779 0 is_stmt 0 discriminator 2
 764 003a E26B     	 ldr r2,[r4,#60]
 765 003c 012A     	 cmp r2,#1
 766 003e 08D0     	 beq .L62
 767              	.LBB145:
 768              	.LBB146:
 769              	 .loc 2 197 0 is_stmt 1
 770              	
 771 0040 4FF01403 	 mov r3,#20
 772 0044 83F31188 	 msr basepri,r3
 773 0048 BFF36F8F 	 isb 
 774 004c BFF34F8F 	 dsb 
 775              	
 776              	
 777              	.LVL87:
 778              	 .thumb
 779              	.L63:
 780              	.LBE146:
 781              	.LBE145:
 779:../FreeRTOS/Source/queue.c ****     #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 782              	 .loc 1 779 0 discriminator 3
 783 0050 FEE7     	 b .L63
 784              	.LVL88:
 785              	.L62:
 786 0052 1D46     	 mov r5,r3
 787 0054 0E46     	 mov r6,r1
 782:../FreeRTOS/Source/queue.c ****         }
 788              	 .loc 1 782 0
 789 0056 FFF7FEFF 	 bl xTaskGetSchedulerState
 790              	.LVL89:
 791 005a 50B9     	 cbnz r0,.L78
 782:../FreeRTOS/Source/queue.c ****         }
 792              	 .loc 1 782 0 is_stmt 0 discriminator 2
 793 005c 019B     	 ldr r3,[sp,#4]
 794 005e 53B1     	 cbz r3,.L79
 795              	.LBB147:
 796              	.LBB148:
 797              	 .loc 2 197 0 is_stmt 1
 798              	
 799 0060 4FF01403 	 mov r3,#20
 800 0064 83F31188 	 msr basepri,r3
 801 0068 BFF36F8F 	 isb 
 802 006c BFF34F8F 	 dsb 
 803              	
 804              	
 805              	.LVL90:
 806              	 .thumb
 807              	.L65:
 808              	.LBE148:
 809              	.LBE147:
 782:../FreeRTOS/Source/queue.c ****         }
 810              	 .loc 1 782 0 discriminator 4
 811 0070 FEE7     	 b .L65
 812              	.L78:
 813 0072 0027     	 movs r7,#0
 814 0074 00E0     	 b .L64
 815              	.L79:
 816 0076 0027     	 movs r7,#0
 817              	.L64:
 918:../FreeRTOS/Source/queue.c ****                 }
 818              	 .loc 1 918 0
 819 0078 4FF00109 	 mov r9,#1
 957:../FreeRTOS/Source/queue.c ****                 }
 820              	 .loc 1 957 0
 821 007c DFF80481 	 ldr r8,.L82
 822              	.LVL91:
 823              	.L80:
 791:../FreeRTOS/Source/queue.c ****         {
 824              	 .loc 1 791 0
 825 0080 FFF7FEFF 	 bl vPortEnterCritical
 826              	.LVL92:
 797:../FreeRTOS/Source/queue.c ****             {
 827              	 .loc 1 797 0
 828 0084 A26B     	 ldr r2,[r4,#56]
 829 0086 E36B     	 ldr r3,[r4,#60]
 830 0088 9A42     	 cmp r2,r3
 831 008a 01D3     	 bcc .L66
 797:../FreeRTOS/Source/queue.c ****             {
 832              	 .loc 1 797 0 is_stmt 0 discriminator 1
 833 008c 022D     	 cmp r5,#2
 834 008e 21D1     	 bne .L67
 835              	.L66:
 863:../FreeRTOS/Source/queue.c **** 
 836              	 .loc 1 863 0 is_stmt 1
 837 0090 2046     	 mov r0,r4
 838 0092 3146     	 mov r1,r6
 839 0094 2A46     	 mov r2,r5
 840 0096 FFF7FEFF 	 bl prvCopyDataToQueue
 841              	.LVL93:
 867:../FreeRTOS/Source/queue.c ****                         {
 842              	 .loc 1 867 0
 843 009a 636A     	 ldr r3,[r4,#36]
 844 009c 6BB1     	 cbz r3,.L68
 869:../FreeRTOS/Source/queue.c ****                             {
 845              	 .loc 1 869 0
 846 009e 04F12400 	 add r0,r4,#36
 847              	.LVL94:
 848 00a2 FFF7FEFF 	 bl xTaskRemoveFromEventList
 849              	.LVL95:
 850 00a6 88B1     	 cbz r0,.L69
 875:../FreeRTOS/Source/queue.c ****                             }
 851              	 .loc 1 875 0
 852 00a8 4FF08052 	 mov r2,#268435456
 853 00ac 354B     	 ldr r3,.L82
 854 00ae 1A60     	 str r2,[r3]
 855              	
 856 00b0 BFF34F8F 	 dsb
 857              	
 858              	
 859 00b4 BFF36F8F 	 isb
 860              	
 861              	 .thumb
 862 00b8 08E0     	 b .L69
 863              	.LVL96:
 864              	.L68:
 882:../FreeRTOS/Source/queue.c ****                         {
 865              	 .loc 1 882 0
 866 00ba 38B1     	 cbz r0,.L69
 888:../FreeRTOS/Source/queue.c ****                         }
 867              	 .loc 1 888 0
 868 00bc 4FF08052 	 mov r2,#268435456
 869 00c0 304B     	 ldr r3,.L82
 870 00c2 1A60     	 str r2,[r3]
 871              	
 872 00c4 BFF34F8F 	 dsb
 873              	
 874              	
 875 00c8 BFF36F8F 	 isb
 876              	
 877              	.LVL97:
 878              	 .thumb
 879              	.L69:
 897:../FreeRTOS/Source/queue.c ****                 return pdPASS;
 880              	 .loc 1 897 0
 881 00cc FFF7FEFF 	 bl vPortExitCritical
 882              	.LVL98:
 898:../FreeRTOS/Source/queue.c ****             }
 883              	 .loc 1 898 0
 884 00d0 0120     	 movs r0,#1
 885 00d2 54E0     	 b .L70
 886              	.L67:
 902:../FreeRTOS/Source/queue.c ****                 {
 887              	 .loc 1 902 0
 888 00d4 019B     	 ldr r3,[sp,#4]
 889 00d6 1BB9     	 cbnz r3,.L71
 906:../FreeRTOS/Source/queue.c **** 
 890              	 .loc 1 906 0
 891 00d8 FFF7FEFF 	 bl vPortExitCritical
 892              	.LVL99:
 911:../FreeRTOS/Source/queue.c ****                 }
 893              	 .loc 1 911 0
 894 00dc 0020     	 movs r0,#0
 895 00de 4EE0     	 b .L70
 896              	.L71:
 913:../FreeRTOS/Source/queue.c ****                 {
 897              	 .loc 1 913 0
 898 00e0 1FB9     	 cbnz r7,.L72
 917:../FreeRTOS/Source/queue.c ****                     xEntryTimeSet = pdTRUE;
 899              	 .loc 1 917 0
 900 00e2 02A8     	 add r0,sp,#8
 901 00e4 FFF7FEFF 	 bl vTaskInternalSetTimeOutState
 902              	.LVL100:
 918:../FreeRTOS/Source/queue.c ****                 }
 903              	 .loc 1 918 0
 904 00e8 4F46     	 mov r7,r9
 905              	.LVL101:
 906              	.L72:
 927:../FreeRTOS/Source/queue.c **** 
 907              	 .loc 1 927 0
 908 00ea FFF7FEFF 	 bl vPortExitCritical
 909              	.LVL102:
 932:../FreeRTOS/Source/queue.c ****         prvLockQueue( pxQueue );
 910              	 .loc 1 932 0
 911 00ee FFF7FEFF 	 bl vTaskSuspendAll
 912              	.LVL103:
 933:../FreeRTOS/Source/queue.c **** 
 913              	 .loc 1 933 0
 914 00f2 FFF7FEFF 	 bl vPortEnterCritical
 915              	.LVL104:
 916 00f6 94F84430 	 ldrb r3,[r4,#68]
 917 00fa 5BB2     	 sxtb r3,r3
 918 00fc B3F1FF3F 	 cmp r3,#-1
 919 0100 04BF     	 itt eq
 920 0102 0023     	 moveq r3,#0
 921 0104 84F84430 	 strbeq r3,[r4,#68]
 922 0108 94F84530 	 ldrb r3,[r4,#69]
 923 010c 5BB2     	 sxtb r3,r3
 924 010e B3F1FF3F 	 cmp r3,#-1
 925 0112 04BF     	 itt eq
 926 0114 0023     	 moveq r3,#0
 927 0116 84F84530 	 strbeq r3,[r4,#69]
 928 011a FFF7FEFF 	 bl vPortExitCritical
 929              	.LVL105:
 936:../FreeRTOS/Source/queue.c ****         {
 930              	 .loc 1 936 0
 931 011e 02A8     	 add r0,sp,#8
 932 0120 01A9     	 add r1,sp,#4
 933              	.LVL106:
 934 0122 FFF7FEFF 	 bl xTaskCheckForTimeOut
 935              	.LVL107:
 936 0126 20BB     	 cbnz r0,.L75
 937              	.LVL108:
 938              	.LBB149:
 939              	.LBB150:
2366:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2367:../FreeRTOS/Source/queue.c **** 
2368:../FreeRTOS/Source/queue.c **** BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
2369:../FreeRTOS/Source/queue.c **** {
2370:../FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
2371:../FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
2372:../FreeRTOS/Source/queue.c **** 
2373:../FreeRTOS/Source/queue.c ****     configASSERT( pxQueue );
2374:../FreeRTOS/Source/queue.c **** 
2375:../FreeRTOS/Source/queue.c ****     if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
2376:../FreeRTOS/Source/queue.c ****     {
2377:../FreeRTOS/Source/queue.c ****         xReturn = pdTRUE;
2378:../FreeRTOS/Source/queue.c ****     }
2379:../FreeRTOS/Source/queue.c ****     else
2380:../FreeRTOS/Source/queue.c ****     {
2381:../FreeRTOS/Source/queue.c ****         xReturn = pdFALSE;
2382:../FreeRTOS/Source/queue.c ****     }
2383:../FreeRTOS/Source/queue.c **** 
2384:../FreeRTOS/Source/queue.c ****     return xReturn;
2385:../FreeRTOS/Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
2386:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2387:../FreeRTOS/Source/queue.c **** 
2388:../FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
2389:../FreeRTOS/Source/queue.c **** {
2390:../FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
2391:../FreeRTOS/Source/queue.c **** 
2392:../FreeRTOS/Source/queue.c ****     taskENTER_CRITICAL();
 940              	 .loc 1 2392 0
 941 0128 FFF7FEFF 	 bl vPortEnterCritical
 942              	.LVL109:
2393:../FreeRTOS/Source/queue.c ****     {
2394:../FreeRTOS/Source/queue.c ****         if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 943              	 .loc 1 2394 0
 944 012c D4F838B0 	 ldr fp,[r4,#56]
 945 0130 D4F83CA0 	 ldr r10,[r4,#60]
 946              	.LVL110:
2395:../FreeRTOS/Source/queue.c ****         {
2396:../FreeRTOS/Source/queue.c ****             xReturn = pdTRUE;
2397:../FreeRTOS/Source/queue.c ****         }
2398:../FreeRTOS/Source/queue.c ****         else
2399:../FreeRTOS/Source/queue.c ****         {
2400:../FreeRTOS/Source/queue.c ****             xReturn = pdFALSE;
2401:../FreeRTOS/Source/queue.c ****         }
2402:../FreeRTOS/Source/queue.c ****     }
2403:../FreeRTOS/Source/queue.c ****     taskEXIT_CRITICAL();
 947              	 .loc 1 2403 0
 948 0134 FFF7FEFF 	 bl vPortExitCritical
 949              	.LVL111:
 950              	.LBE150:
 951              	.LBE149:
 938:../FreeRTOS/Source/queue.c ****             {
 952              	 .loc 1 938 0
 953 0138 D345     	 cmp fp,r10
 954 013a 14D1     	 bne .L76
 941:../FreeRTOS/Source/queue.c **** 
 955              	 .loc 1 941 0
 956 013c 04F11000 	 add r0,r4,#16
 957 0140 0199     	 ldr r1,[sp,#4]
 958 0142 FFF7FEFF 	 bl vTaskPlaceOnEventList
 959              	.LVL112:
 948:../FreeRTOS/Source/queue.c **** 
 960              	 .loc 1 948 0
 961 0146 2046     	 mov r0,r4
 962 0148 FFF7FEFF 	 bl prvUnlockQueue
 963              	.LVL113:
 955:../FreeRTOS/Source/queue.c ****                 {
 964              	 .loc 1 955 0
 965 014c FFF7FEFF 	 bl xTaskResumeAll
 966              	.LVL114:
 967 0150 0028     	 cmp r0,#0
 968 0152 95D1     	 bne .L80
 957:../FreeRTOS/Source/queue.c ****                 }
 969              	 .loc 1 957 0
 970 0154 4FF08053 	 mov r3,#268435456
 971 0158 C8F80030 	 str r3,[r8]
 972              	
 973 015c BFF34F8F 	 dsb
 974              	
 975              	
 976 0160 BFF36F8F 	 isb
 977              	
 978              	 .thumb
 979 0164 8CE7     	 b .L80
 980              	.L76:
 963:../FreeRTOS/Source/queue.c ****                 ( void ) xTaskResumeAll();
 981              	 .loc 1 963 0
 982 0166 2046     	 mov r0,r4
 983 0168 FFF7FEFF 	 bl prvUnlockQueue
 984              	.LVL115:
 964:../FreeRTOS/Source/queue.c ****             }
 985              	 .loc 1 964 0
 986 016c FFF7FEFF 	 bl xTaskResumeAll
 987              	.LVL116:
 988 0170 86E7     	 b .L80
 989              	.LVL117:
 990              	.L75:
 970:../FreeRTOS/Source/queue.c ****             ( void ) xTaskResumeAll();
 991              	 .loc 1 970 0
 992 0172 2046     	 mov r0,r4
 993 0174 FFF7FEFF 	 bl prvUnlockQueue
 994              	.LVL118:
 971:../FreeRTOS/Source/queue.c **** 
 995              	 .loc 1 971 0
 996 0178 FFF7FEFF 	 bl xTaskResumeAll
 997              	.LVL119:
 974:../FreeRTOS/Source/queue.c ****         }
 998              	 .loc 1 974 0
 999 017c 0020     	 movs r0,#0
 1000              	.L70:
 977:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1001              	 .loc 1 977 0
 1002 017e 05B0     	 add sp,sp,#20
 1003              	.LCFI10:
 1004              	 .cfi_def_cfa_offset 36
 1005              	 
 1006 0180 BDE8F08F 	 pop {r4,r5,r6,r7,r8,r9,r10,fp,pc}
 1007              	.LVL120:
 1008              	.L83:
 1009              	 .align 2
 1010              	.L82:
 1011 0184 04ED00E0 	 .word -536810236
 1012              	 .cfi_endproc
 1013              	.LFE13:
 1015              	 .section .text.xQueueCreateMutex,"ax",%progbits
 1016              	 .align 2
 1017              	 .global xQueueCreateMutex
 1018              	 .thumb
 1019              	 .thumb_func
 1021              	xQueueCreateMutex:
 1022              	.LFB9:
 520:../FreeRTOS/Source/queue.c ****         QueueHandle_t xNewQueue;
 1023              	 .loc 1 520 0
 1024              	 .cfi_startproc
 1025              	 
 1026              	 
 1027              	.LVL121:
 1028 0000 10B5     	 push {r4,lr}
 1029              	.LCFI11:
 1030              	 .cfi_def_cfa_offset 8
 1031              	 .cfi_offset 4,-8
 1032              	 .cfi_offset 14,-4
 1033 0002 0246     	 mov r2,r0
 1034              	.LVL122:
 524:../FreeRTOS/Source/queue.c ****         prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 1035              	 .loc 1 524 0
 1036 0004 0120     	 movs r0,#1
 1037              	.LVL123:
 1038 0006 0021     	 movs r1,#0
 1039 0008 FFF7FEFF 	 bl xQueueGenericCreate
 1040              	.LVL124:
 1041              	.LBB153:
 1042              	.LBB154:
 491:../FreeRTOS/Source/queue.c ****         {
 1043              	 .loc 1 491 0
 1044 000c 0446     	 mov r4,r0
 1045 000e 38B1     	 cbz r0,.L85
 497:../FreeRTOS/Source/queue.c ****             pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 1046              	 .loc 1 497 0
 1047 0010 0023     	 movs r3,#0
 1048 0012 8360     	 str r3,[r0,#8]
 498:../FreeRTOS/Source/queue.c **** 
 1049              	 .loc 1 498 0
 1050 0014 0360     	 str r3,[r0]
 501:../FreeRTOS/Source/queue.c **** 
 1051              	 .loc 1 501 0
 1052 0016 C360     	 str r3,[r0,#12]
 506:../FreeRTOS/Source/queue.c ****         }
 1053              	 .loc 1 506 0
 1054 0018 1946     	 mov r1,r3
 1055 001a 1A46     	 mov r2,r3
 1056 001c FFF7FEFF 	 bl xQueueGenericSend
 1057              	.LVL125:
 1058              	.L85:
 1059              	.LBE154:
 1060              	.LBE153:
 528:../FreeRTOS/Source/queue.c **** 
 1061              	 .loc 1 528 0
 1062 0020 2046     	 mov r0,r4
 1063 0022 10BD     	 pop {r4,pc}
 1064              	 .cfi_endproc
 1065              	.LFE9:
 1067              	 .section .text.xQueueGiveMutexRecursive,"ax",%progbits
 1068              	 .align 2
 1069              	 .global xQueueGiveMutexRecursive
 1070              	 .thumb
 1071              	 .thumb_func
 1073              	xQueueGiveMutexRecursive:
 1074              	.LFB10:
 614:../FreeRTOS/Source/queue.c ****         BaseType_t xReturn;
 1075              	 .loc 1 614 0
 1076              	 .cfi_startproc
 1077              	 
 1078              	 
 1079              	.LVL126:
 1080 0000 38B5     	 push {r3,r4,r5,lr}
 1081              	.LCFI12:
 1082              	 .cfi_def_cfa_offset 16
 1083              	 .cfi_offset 3,-16
 1084              	 .cfi_offset 4,-12
 1085              	 .cfi_offset 5,-8
 1086              	 .cfi_offset 14,-4
 1087              	.LVL127:
 618:../FreeRTOS/Source/queue.c **** 
 1088              	 .loc 1 618 0
 1089 0002 40B9     	 cbnz r0,.L88
 1090              	.LBB155:
 1091              	.LBB156:
 1092              	 .loc 2 197 0
 1093              	
 1094 0004 4FF01403 	 mov r3,#20
 1095 0008 83F31188 	 msr basepri,r3
 1096 000c BFF36F8F 	 isb 
 1097 0010 BFF34F8F 	 dsb 
 1098              	
 1099              	
 1100              	.LVL128:
 1101              	 .thumb
 1102              	.L89:
 1103              	.LBE156:
 1104              	.LBE155:
 618:../FreeRTOS/Source/queue.c **** 
 1105              	 .loc 1 618 0 discriminator 1
 1106 0014 FEE7     	 b .L89
 1107              	.L88:
 1108 0016 0446     	 mov r4,r0
 626:../FreeRTOS/Source/queue.c ****         {
 1109              	 .loc 1 626 0
 1110 0018 8568     	 ldr r5,[r0,#8]
 1111 001a FFF7FEFF 	 bl xTaskGetCurrentTaskHandle
 1112              	.LVL129:
 1113 001e 8542     	 cmp r5,r0
 1114 0020 0BD1     	 bne .L91
 635:../FreeRTOS/Source/queue.c **** 
 1115              	 .loc 1 635 0
 1116 0022 E368     	 ldr r3,[r4,#12]
 1117 0024 013B     	 subs r3,r3,#1
 1118 0026 E360     	 str r3,[r4,#12]
 638:../FreeRTOS/Source/queue.c ****             {
 1119              	 .loc 1 638 0
 1120 0028 4BB9     	 cbnz r3,.L92
 642:../FreeRTOS/Source/queue.c ****             }
 1121              	 .loc 1 642 0
 1122 002a 2046     	 mov r0,r4
 1123 002c 0021     	 movs r1,#0
 1124 002e 0A46     	 mov r2,r1
 1125 0030 0B46     	 mov r3,r1
 1126 0032 FFF7FEFF 	 bl xQueueGenericSend
 1127              	.LVL130:
 649:../FreeRTOS/Source/queue.c ****         }
 1128              	 .loc 1 649 0
 1129 0036 0120     	 movs r0,#1
 1130 0038 38BD     	 pop {r3,r4,r5,pc}
 1131              	.LVL131:
 1132              	.L91:
 655:../FreeRTOS/Source/queue.c **** 
 1133              	 .loc 1 655 0
 1134 003a 0020     	 movs r0,#0
 1135 003c 38BD     	 pop {r3,r4,r5,pc}
 1136              	.LVL132:
 1137              	.L92:
 649:../FreeRTOS/Source/queue.c ****         }
 1138              	 .loc 1 649 0
 1139 003e 0120     	 movs r0,#1
 1140              	.LVL133:
 661:../FreeRTOS/Source/queue.c **** 
 1141              	 .loc 1 661 0
 1142 0040 38BD     	 pop {r3,r4,r5,pc}
 1143              	 .cfi_endproc
 1144              	.LFE10:
 1146 0042 00BF     	 .section .text.xQueueGenericSendFromISR,"ax",%progbits
 1147              	 .align 2
 1148              	 .global xQueueGenericSendFromISR
 1149              	 .thumb
 1150              	 .thumb_func
 1152              	xQueueGenericSendFromISR:
 1153              	.LFB14:
 984:../FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
 1154              	 .loc 1 984 0
 1155              	 .cfi_startproc
 1156              	 
 1157              	 
 1158              	.LVL134:
 1159 0000 2DE9F843 	 push {r3,r4,r5,r6,r7,r8,r9,lr}
 1160              	.LCFI13:
 1161              	 .cfi_def_cfa_offset 32
 1162              	 .cfi_offset 3,-32
 1163              	 .cfi_offset 4,-28
 1164              	 .cfi_offset 5,-24
 1165              	 .cfi_offset 6,-20
 1166              	 .cfi_offset 7,-16
 1167              	 .cfi_offset 8,-12
 1168              	 .cfi_offset 9,-8
 1169              	 .cfi_offset 14,-4
 1170              	.LVL135:
 989:../FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
 1171              	 .loc 1 989 0
 1172 0004 40B9     	 cbnz r0,.L95
 1173              	.LBB157:
 1174              	.LBB158:
 1175              	 .loc 2 197 0
 1176              	
 1177 0006 4FF01403 	 mov r3,#20
 1178 000a 83F31188 	 msr basepri,r3
 1179 000e BFF36F8F 	 isb 
 1180 0012 BFF34F8F 	 dsb 
 1181              	
 1182              	
 1183              	.LVL136:
 1184              	 .thumb
 1185              	.L96:
 1186              	.LBE158:
 1187              	.LBE157:
 989:../FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
 1188              	 .loc 1 989 0 discriminator 1
 1189 0016 FEE7     	 b .L96
 1190              	.LVL137:
 1191              	.L95:
 1192 0018 0446     	 mov r4,r0
 990:../FreeRTOS/Source/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 1193              	 .loc 1 990 0
 1194 001a 51B9     	 cbnz r1,.L97
 990:../FreeRTOS/Source/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 1195              	 .loc 1 990 0 is_stmt 0 discriminator 2
 1196 001c 006C     	 ldr r0,[r0,#64]
 1197              	.LVL138:
 1198 001e 40B1     	 cbz r0,.L97
 1199              	.LBB159:
 1200              	.LBB160:
 1201              	 .loc 2 197 0 is_stmt 1
 1202              	
 1203 0020 4FF01403 	 mov r3,#20
 1204 0024 83F31188 	 msr basepri,r3
 1205 0028 BFF36F8F 	 isb 
 1206 002c BFF34F8F 	 dsb 
 1207              	
 1208              	
 1209              	.LVL139:
 1210              	 .thumb
 1211              	.L98:
 1212              	.LBE160:
 1213              	.LBE159:
 990:../FreeRTOS/Source/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 1214              	 .loc 1 990 0 discriminator 2
 1215 0030 FEE7     	 b .L98
 1216              	.LVL140:
 1217              	.L97:
 991:../FreeRTOS/Source/queue.c **** 
 1218              	 .loc 1 991 0
 1219 0032 022B     	 cmp r3,#2
 1220 0034 0BD1     	 bne .L99
 991:../FreeRTOS/Source/queue.c **** 
 1221              	 .loc 1 991 0 is_stmt 0 discriminator 2
 1222 0036 E06B     	 ldr r0,[r4,#60]
 1223 0038 0128     	 cmp r0,#1
 1224 003a 08D0     	 beq .L99
 1225              	.LBB161:
 1226              	.LBB162:
 1227              	 .loc 2 197 0 is_stmt 1
 1228              	
 1229 003c 4FF01403 	 mov r3,#20
 1230 0040 83F31188 	 msr basepri,r3
 1231 0044 BFF36F8F 	 isb 
 1232 0048 BFF34F8F 	 dsb 
 1233              	
 1234              	
 1235              	.LVL141:
 1236              	 .thumb
 1237              	.L100:
 1238              	.LBE162:
 1239              	.LBE161:
 991:../FreeRTOS/Source/queue.c **** 
 1240              	 .loc 1 991 0 discriminator 3
 1241 004c FEE7     	 b .L100
 1242              	.LVL142:
 1243              	.L99:
 1244 004e 9846     	 mov r8,r3
 1245 0050 1646     	 mov r6,r2
 1246 0052 8946     	 mov r9,r1
1007:../FreeRTOS/Source/queue.c **** 
 1247              	 .loc 1 1007 0
 1248 0054 FFF7FEFF 	 bl vPortValidateInterruptPriority
 1249              	.LVL143:
 1250              	.LBB163:
 1251              	.LBB164:
 198:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 199:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             "	mov %0, %1												\n"\
 200:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             "	msr basepri, %0											\n"\
 201:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             "	isb														\n"\
 202:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             "	dsb														\n"\
 203:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             : "=r" ( ulNewBASEPRI ) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
 204:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         );
 205:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     }
 206:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 207:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 208:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 209:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
 210:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     {
 211:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         uint32_t ulOriginalBASEPRI, ulNewBASEPRI;
 212:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 213:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile
 1252              	 .loc 2 213 0
 1253              	
 1254 0058 EFF31187 	 mrs r7,basepri
 1255 005c 4FF01403 	 mov r3,#20
 1256 0060 83F31188 	 msr basepri,r3
 1257 0064 BFF36F8F 	 isb 
 1258 0068 BFF34F8F 	 dsb 
 1259              	
 1260              	
 1261              	.LVL144:
 1262              	 .thumb
 1263              	.LBE164:
 1264              	.LBE163:
1016:../FreeRTOS/Source/queue.c ****         {
 1265              	 .loc 1 1016 0
 1266 006c A26B     	 ldr r2,[r4,#56]
 1267 006e E36B     	 ldr r3,[r4,#60]
 1268 0070 9A42     	 cmp r2,r3
 1269 0072 02D3     	 bcc .L101
1016:../FreeRTOS/Source/queue.c ****         {
 1270              	 .loc 1 1016 0 is_stmt 0 discriminator 1
 1271 0074 B8F1020F 	 cmp r8,#2
 1272 0078 29D1     	 bne .L106
 1273              	.L101:
 1274              	.LBB165:
1018:../FreeRTOS/Source/queue.c ****             const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 1275              	 .loc 1 1018 0 is_stmt 1
 1276 007a 94F84550 	 ldrb r5,[r4,#69]
 1277 007e EDB2     	 uxtb r5,r5
 1278              	.LVL145:
1019:../FreeRTOS/Source/queue.c **** 
 1279              	 .loc 1 1019 0
 1280 0080 A36B     	 ldr r3,[r4,#56]
1028:../FreeRTOS/Source/queue.c **** 
 1281              	 .loc 1 1028 0
 1282 0082 2046     	 mov r0,r4
 1283 0084 4946     	 mov r1,r9
 1284 0086 4246     	 mov r2,r8
 1285 0088 FFF7FEFF 	 bl prvCopyDataToQueue
 1286              	.LVL146:
1032:../FreeRTOS/Source/queue.c ****             {
 1287              	 .loc 1 1032 0
 1288 008c 6BB2     	 sxtb r3,r5
 1289 008e B3F1FF3F 	 cmp r3,#-1
 1290 0092 0AD1     	 bne .L103
1094:../FreeRTOS/Source/queue.c ****                         {
 1291              	 .loc 1 1094 0
 1292 0094 636A     	 ldr r3,[r4,#36]
 1293 0096 E3B1     	 cbz r3,.L107
1096:../FreeRTOS/Source/queue.c ****                             {
 1294              	 .loc 1 1096 0
 1295 0098 04F12400 	 add r0,r4,#36
 1296 009c FFF7FEFF 	 bl xTaskRemoveFromEventList
 1297              	.LVL147:
 1298 00a0 C8B1     	 cbz r0,.L108
1100:../FreeRTOS/Source/queue.c ****                                 {
 1299              	 .loc 1 1100 0
 1300 00a2 D6B1     	 cbz r6,.L109
1102:../FreeRTOS/Source/queue.c ****                                 }
 1301              	 .loc 1 1102 0
 1302 00a4 0120     	 movs r0,#1
 1303 00a6 3060     	 str r0,[r6]
 1304 00a8 18E0     	 b .L102
 1305              	.L103:
1128:../FreeRTOS/Source/queue.c **** 
 1306              	 .loc 1 1128 0
 1307 00aa 6BB2     	 sxtb r3,r5
 1308 00ac 7F2B     	 cmp r3,#127
 1309 00ae 08D1     	 bne .L104
 1310              	.LBB166:
 1311              	.LBB167:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 1312              	 .loc 2 197 0
 1313              	
 1314 00b0 4FF01403 	 mov r3,#20
 1315 00b4 83F31188 	 msr basepri,r3
 1316 00b8 BFF36F8F 	 isb 
 1317 00bc BFF34F8F 	 dsb 
 1318              	
 1319              	
 1320              	.LVL148:
 1321              	 .thumb
 1322              	.L105:
 1323              	.LBE167:
 1324              	.LBE166:
1128:../FreeRTOS/Source/queue.c **** 
 1325              	 .loc 1 1128 0 discriminator 6
 1326 00c0 FEE7     	 b .L105
 1327              	.L104:
1130:../FreeRTOS/Source/queue.c ****             }
 1328              	 .loc 1 1130 0
 1329 00c2 6B1C     	 adds r3,r5,#1
 1330 00c4 DBB2     	 uxtb r3,r3
 1331 00c6 84F84530 	 strb r3,[r4,#69]
1133:../FreeRTOS/Source/queue.c ****         }
 1332              	 .loc 1 1133 0
 1333 00ca 0120     	 movs r0,#1
 1334 00cc 06E0     	 b .L102
 1335              	.LVL149:
 1336              	.L106:
 1337              	.LBE165:
1138:../FreeRTOS/Source/queue.c ****         }
 1338              	 .loc 1 1138 0
 1339 00ce 0020     	 movs r0,#0
 1340 00d0 04E0     	 b .L102
 1341              	.LVL150:
 1342              	.L107:
 1343              	.LBB168:
1133:../FreeRTOS/Source/queue.c ****         }
 1344              	 .loc 1 1133 0
 1345 00d2 0120     	 movs r0,#1
 1346 00d4 02E0     	 b .L102
 1347              	.L108:
 1348 00d6 0120     	 movs r0,#1
 1349 00d8 00E0     	 b .L102
 1350              	.L109:
 1351 00da 0120     	 movs r0,#1
 1352              	.LVL151:
 1353              	.L102:
 1354              	.LBE168:
 1355              	.LBB169:
 1356              	.LBB170:
 214:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 215:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             "	mrs %0, basepri											\n"\
 216:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             "	mov %1, %2												\n"\
 217:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             "	msr basepri, %1											\n"\
 218:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             "	isb														\n"\
 219:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             "	dsb														\n"\
 220:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             : "=r" ( ulOriginalBASEPRI ), "=r" ( ulNewBASEPRI ) : "i" ( configMAX_SYSCALL_INTERRUPT
 221:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         );
 222:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 223:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         /* This return will not be reached but is necessary to prevent compiler
 224:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****          * warnings. */
 225:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         return ulOriginalBASEPRI;
 226:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     }
 227:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 228:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 229:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
 230:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     {
 231:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile
 1357              	 .loc 2 231 0
 1358              	
 1359 00dc 87F31188 	 msr basepri,r7
 1360              	
 1361              	 .thumb
 1362              	.LBE170:
 1363              	.LBE169:
1144:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1364              	 .loc 1 1144 0
 1365 00e0 BDE8F883 	 pop {r3,r4,r5,r6,r7,r8,r9,pc}
 1366              	 .cfi_endproc
 1367              	.LFE14:
 1369              	 .section .text.xQueueGiveFromISR,"ax",%progbits
 1370              	 .align 2
 1371              	 .global xQueueGiveFromISR
 1372              	 .thumb
 1373              	 .thumb_func
 1375              	xQueueGiveFromISR:
 1376              	.LFB15:
1149:../FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
 1377              	 .loc 1 1149 0
 1378              	 .cfi_startproc
 1379              	 
 1380              	 
 1381              	.LVL152:
1160:../FreeRTOS/Source/queue.c **** 
 1382              	 .loc 1 1160 0
 1383 0000 40B9     	 cbnz r0,.L112
 1384              	.LBB171:
 1385              	.LBB172:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 1386              	 .loc 2 197 0
 1387              	
 1388 0002 4FF01403 	 mov r3,#20
 1389 0006 83F31188 	 msr basepri,r3
 1390 000a BFF36F8F 	 isb 
 1391 000e BFF34F8F 	 dsb 
 1392              	
 1393              	
 1394              	.LVL153:
 1395              	 .thumb
 1396              	.L113:
 1397              	.LBE172:
 1398              	.LBE171:
1160:../FreeRTOS/Source/queue.c **** 
 1399              	 .loc 1 1160 0 discriminator 1
 1400 0012 FEE7     	 b .L113
 1401              	.L112:
1149:../FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
 1402              	 .loc 1 1149 0
 1403 0014 70B5     	 push {r4,r5,r6,lr}
 1404              	.LCFI14:
 1405              	 .cfi_def_cfa_offset 16
 1406              	 .cfi_offset 4,-16
 1407              	 .cfi_offset 5,-12
 1408              	 .cfi_offset 6,-8
 1409              	 .cfi_offset 14,-4
 1410 0016 0446     	 mov r4,r0
1164:../FreeRTOS/Source/queue.c **** 
 1411              	 .loc 1 1164 0
 1412 0018 036C     	 ldr r3,[r0,#64]
 1413 001a 43B1     	 cbz r3,.L114
 1414              	.LBB173:
 1415              	.LBB174:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 1416              	 .loc 2 197 0
 1417              	
 1418 001c 4FF01403 	 mov r3,#20
 1419 0020 83F31188 	 msr basepri,r3
 1420 0024 BFF36F8F 	 isb 
 1421 0028 BFF34F8F 	 dsb 
 1422              	
 1423              	
 1424              	.LVL154:
 1425              	 .thumb
 1426              	.L115:
 1427              	.LBE174:
 1428              	.LBE173:
1164:../FreeRTOS/Source/queue.c **** 
 1429              	 .loc 1 1164 0 discriminator 2
 1430 002c FEE7     	 b .L115
 1431              	.L114:
1169:../FreeRTOS/Source/queue.c **** 
 1432              	 .loc 1 1169 0
 1433 002e 0368     	 ldr r3,[r0]
 1434 0030 53B9     	 cbnz r3,.L116
1169:../FreeRTOS/Source/queue.c **** 
 1435              	 .loc 1 1169 0 is_stmt 0 discriminator 2
 1436 0032 8368     	 ldr r3,[r0,#8]
 1437 0034 43B1     	 cbz r3,.L116
 1438              	.LBB175:
 1439              	.LBB176:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 1440              	 .loc 2 197 0 is_stmt 1
 1441              	
 1442 0036 4FF01403 	 mov r3,#20
 1443 003a 83F31188 	 msr basepri,r3
 1444 003e BFF36F8F 	 isb 
 1445 0042 BFF34F8F 	 dsb 
 1446              	
 1447              	
 1448              	.LVL155:
 1449              	 .thumb
 1450              	.L117:
 1451              	.LBE176:
 1452              	.LBE175:
1169:../FreeRTOS/Source/queue.c **** 
 1453              	 .loc 1 1169 0 discriminator 3
 1454 0046 FEE7     	 b .L117
 1455              	.L116:
 1456 0048 0D46     	 mov r5,r1
1185:../FreeRTOS/Source/queue.c **** 
 1457              	 .loc 1 1185 0
 1458 004a FFF7FEFF 	 bl vPortValidateInterruptPriority
 1459              	.LVL156:
 1460              	.LBB177:
 1461              	.LBB178:
 213:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 1462              	 .loc 2 213 0
 1463              	
 1464 004e EFF31186 	 mrs r6,basepri
 1465 0052 4FF01403 	 mov r3,#20
 1466 0056 83F31188 	 msr basepri,r3
 1467 005a BFF36F8F 	 isb 
 1468 005e BFF34F8F 	 dsb 
 1469              	
 1470              	
 1471              	.LVL157:
 1472              	 .thumb
 1473              	.LBE178:
 1474              	.LBE177:
 1475              	.LBB179:
1189:../FreeRTOS/Source/queue.c **** 
 1476              	 .loc 1 1189 0
 1477 0062 A36B     	 ldr r3,[r4,#56]
 1478              	.LVL158:
1194:../FreeRTOS/Source/queue.c ****         {
 1479              	 .loc 1 1194 0
 1480 0064 E26B     	 ldr r2,[r4,#60]
 1481 0066 9342     	 cmp r3,r2
 1482 0068 23D2     	 bcs .L122
 1483              	.LBB180:
1196:../FreeRTOS/Source/queue.c **** 
 1484              	 .loc 1 1196 0
 1485 006a 94F84520 	 ldrb r2,[r4,#69]
 1486              	.LVL159:
1206:../FreeRTOS/Source/queue.c **** 
 1487              	 .loc 1 1206 0
 1488 006e 0133     	 adds r3,r3,#1
 1489              	.LVL160:
 1490 0070 A363     	 str r3,[r4,#56]
1210:../FreeRTOS/Source/queue.c ****             {
 1491              	 .loc 1 1210 0
 1492 0072 D3B2     	 uxtb r3,r2
 1493              	.LVL161:
 1494 0074 FF2A     	 cmp r2,#255
 1495 0076 0AD1     	 bne .L119
1265:../FreeRTOS/Source/queue.c ****                         {
 1496              	 .loc 1 1265 0
 1497 0078 636A     	 ldr r3,[r4,#36]
 1498 007a E3B1     	 cbz r3,.L123
1267:../FreeRTOS/Source/queue.c ****                             {
 1499              	 .loc 1 1267 0
 1500 007c 04F12400 	 add r0,r4,#36
 1501 0080 FFF7FEFF 	 bl xTaskRemoveFromEventList
 1502              	.LVL162:
 1503 0084 C8B1     	 cbz r0,.L124
1271:../FreeRTOS/Source/queue.c ****                                 {
 1504              	 .loc 1 1271 0
 1505 0086 D5B1     	 cbz r5,.L125
1273:../FreeRTOS/Source/queue.c ****                                 }
 1506              	 .loc 1 1273 0
 1507 0088 0120     	 movs r0,#1
 1508 008a 2860     	 str r0,[r5]
 1509 008c 18E0     	 b .L118
 1510              	.LVL163:
 1511              	.L119:
1296:../FreeRTOS/Source/queue.c **** 
 1512              	 .loc 1 1296 0
 1513 008e 5AB2     	 sxtb r2,r3
 1514              	.LVL164:
 1515 0090 7F2A     	 cmp r2,#127
 1516 0092 08D1     	 bne .L120
 1517              	.LBB181:
 1518              	.LBB182:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 1519              	 .loc 2 197 0
 1520              	
 1521 0094 4FF01403 	 mov r3,#20
 1522 0098 83F31188 	 msr basepri,r3
 1523 009c BFF36F8F 	 isb 
 1524 00a0 BFF34F8F 	 dsb 
 1525              	
 1526              	
 1527              	.LVL165:
 1528              	 .thumb
 1529              	.L121:
 1530              	.LBE182:
 1531              	.LBE181:
1296:../FreeRTOS/Source/queue.c **** 
 1532              	 .loc 1 1296 0 discriminator 6
 1533 00a4 FEE7     	 b .L121
 1534              	.LVL166:
 1535              	.L120:
1298:../FreeRTOS/Source/queue.c ****             }
 1536              	 .loc 1 1298 0
 1537 00a6 0133     	 adds r3,r3,#1
 1538              	.LVL167:
 1539 00a8 DBB2     	 uxtb r3,r3
 1540              	.LVL168:
 1541 00aa 84F84530 	 strb r3,[r4,#69]
 1542              	.LVL169:
1301:../FreeRTOS/Source/queue.c ****         }
 1543              	 .loc 1 1301 0
 1544 00ae 0120     	 movs r0,#1
 1545 00b0 06E0     	 b .L118
 1546              	.LVL170:
 1547              	.L122:
 1548              	.LBE180:
1306:../FreeRTOS/Source/queue.c ****         }
 1549              	 .loc 1 1306 0
 1550 00b2 0020     	 movs r0,#0
 1551 00b4 04E0     	 b .L118
 1552              	.LVL171:
 1553              	.L123:
 1554              	.LBB183:
1301:../FreeRTOS/Source/queue.c ****         }
 1555              	 .loc 1 1301 0
 1556 00b6 0120     	 movs r0,#1
 1557 00b8 02E0     	 b .L118
 1558              	.LVL172:
 1559              	.L124:
 1560 00ba 0120     	 movs r0,#1
 1561 00bc 00E0     	 b .L118
 1562              	.L125:
 1563 00be 0120     	 movs r0,#1
 1564              	.L118:
 1565              	.LVL173:
 1566              	.LBE183:
 1567              	.LBE179:
 1568              	.LBB184:
 1569              	.LBB185:
 1570              	 .loc 2 231 0
 1571              	
 1572 00c0 86F31188 	 msr basepri,r6
 1573              	
 1574              	 .thumb
 1575              	.LBE185:
 1576              	.LBE184:
1312:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1577              	 .loc 1 1312 0
 1578 00c4 70BD     	 pop {r4,r5,r6,pc}
 1579              	 .cfi_endproc
 1580              	.LFE15:
 1582 00c6 00BF     	 .section .text.xQueueReceive,"ax",%progbits
 1583              	 .align 2
 1584              	 .global xQueueReceive
 1585              	 .thumb
 1586              	 .thumb_func
 1588              	xQueueReceive:
 1589              	.LFB16:
1318:../FreeRTOS/Source/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
 1590              	 .loc 1 1318 0
 1591              	 .cfi_startproc
 1592              	 
 1593              	 
 1594              	.LVL174:
 1595 0000 2DE9F043 	 push {r4,r5,r6,r7,r8,r9,lr}
 1596              	.LCFI15:
 1597              	 .cfi_def_cfa_offset 28
 1598              	 .cfi_offset 4,-28
 1599              	 .cfi_offset 5,-24
 1600              	 .cfi_offset 6,-20
 1601              	 .cfi_offset 7,-16
 1602              	 .cfi_offset 8,-12
 1603              	 .cfi_offset 9,-8
 1604              	 .cfi_offset 14,-4
 1605 0004 85B0     	 sub sp,sp,#20
 1606              	.LCFI16:
 1607              	 .cfi_def_cfa_offset 48
 1608 0006 0192     	 str r2,[sp,#4]
 1609              	.LVL175:
1324:../FreeRTOS/Source/queue.c **** 
 1610              	 .loc 1 1324 0
 1611 0008 40B9     	 cbnz r0,.L128
 1612              	.LBB186:
 1613              	.LBB187:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 1614              	 .loc 2 197 0
 1615              	
 1616 000a 4FF01403 	 mov r3,#20
 1617 000e 83F31188 	 msr basepri,r3
 1618 0012 BFF36F8F 	 isb 
 1619 0016 BFF34F8F 	 dsb 
 1620              	
 1621              	
 1622              	.LVL176:
 1623              	 .thumb
 1624              	.L129:
 1625              	.LBE187:
 1626              	.LBE186:
1324:../FreeRTOS/Source/queue.c **** 
 1627              	 .loc 1 1324 0 discriminator 1
 1628 001a FEE7     	 b .L129
 1629              	.L128:
 1630 001c 0446     	 mov r4,r0
1328:../FreeRTOS/Source/queue.c **** 
 1631              	 .loc 1 1328 0
 1632 001e 51B9     	 cbnz r1,.L130
1328:../FreeRTOS/Source/queue.c **** 
 1633              	 .loc 1 1328 0 is_stmt 0 discriminator 2
 1634 0020 036C     	 ldr r3,[r0,#64]
 1635 0022 43B1     	 cbz r3,.L130
 1636              	.LBB188:
 1637              	.LBB189:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 1638              	 .loc 2 197 0 is_stmt 1
 1639              	
 1640 0024 4FF01403 	 mov r3,#20
 1641 0028 83F31188 	 msr basepri,r3
 1642 002c BFF36F8F 	 isb 
 1643 0030 BFF34F8F 	 dsb 
 1644              	
 1645              	
 1646              	.LVL177:
 1647              	 .thumb
 1648              	.L131:
 1649              	.LBE189:
 1650              	.LBE188:
1328:../FreeRTOS/Source/queue.c **** 
 1651              	 .loc 1 1328 0 discriminator 2
 1652 0034 FEE7     	 b .L131
 1653              	.L130:
 1654 0036 0E46     	 mov r6,r1
1333:../FreeRTOS/Source/queue.c ****         }
 1655              	 .loc 1 1333 0
 1656 0038 FFF7FEFF 	 bl xTaskGetSchedulerState
 1657              	.LVL178:
 1658 003c 50B9     	 cbnz r0,.L144
1333:../FreeRTOS/Source/queue.c ****         }
 1659              	 .loc 1 1333 0 is_stmt 0 discriminator 2
 1660 003e 019B     	 ldr r3,[sp,#4]
 1661 0040 53B1     	 cbz r3,.L145
 1662              	.LBB190:
 1663              	.LBB191:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 1664              	 .loc 2 197 0 is_stmt 1
 1665              	
 1666 0042 4FF01403 	 mov r3,#20
 1667 0046 83F31188 	 msr basepri,r3
 1668 004a BFF36F8F 	 isb 
 1669 004e BFF34F8F 	 dsb 
 1670              	
 1671              	
 1672              	.LVL179:
 1673              	 .thumb
 1674              	.L133:
 1675              	.LBE191:
 1676              	.LBE190:
1333:../FreeRTOS/Source/queue.c ****         }
 1677              	 .loc 1 1333 0 discriminator 3
 1678 0052 FEE7     	 b .L133
 1679              	.L144:
 1680 0054 0027     	 movs r7,#0
 1681 0056 00E0     	 b .L132
 1682              	.L145:
 1683 0058 0027     	 movs r7,#0
 1684              	.L132:
 1685              	.LBB192:
1392:../FreeRTOS/Source/queue.c ****                 }
 1686              	 .loc 1 1392 0
 1687 005a 4FF00109 	 mov r9,#1
 1688              	.LBE192:
1422:../FreeRTOS/Source/queue.c ****                 }
 1689              	 .loc 1 1422 0
 1690 005e DFF8EC80 	 ldr r8,.L148
 1691              	.LVL180:
 1692              	.L146:
1342:../FreeRTOS/Source/queue.c ****         {
 1693              	 .loc 1 1342 0
 1694 0062 FFF7FEFF 	 bl vPortEnterCritical
 1695              	.LVL181:
 1696              	.LBB193:
1344:../FreeRTOS/Source/queue.c **** 
 1697              	 .loc 1 1344 0
 1698 0066 A56B     	 ldr r5,[r4,#56]
 1699              	.LVL182:
1348:../FreeRTOS/Source/queue.c ****             {
 1700              	 .loc 1 1348 0
 1701 0068 C5B1     	 cbz r5,.L134
1351:../FreeRTOS/Source/queue.c ****                 traceQUEUE_RECEIVE( pxQueue );
 1702              	 .loc 1 1351 0
 1703 006a 2046     	 mov r0,r4
 1704 006c 3146     	 mov r1,r6
 1705 006e FFF7FEFF 	 bl prvCopyDataFromQueue
 1706              	.LVL183:
1353:../FreeRTOS/Source/queue.c **** 
 1707              	 .loc 1 1353 0
 1708 0072 013D     	 subs r5,r5,#1
 1709              	.LVL184:
 1710 0074 A563     	 str r5,[r4,#56]
1358:../FreeRTOS/Source/queue.c ****                 {
 1711              	 .loc 1 1358 0
 1712 0076 2369     	 ldr r3,[r4,#16]
 1713 0078 63B1     	 cbz r3,.L135
1360:../FreeRTOS/Source/queue.c ****                     {
 1714              	 .loc 1 1360 0
 1715 007a 04F11000 	 add r0,r4,#16
 1716 007e FFF7FEFF 	 bl xTaskRemoveFromEventList
 1717              	.LVL185:
 1718 0082 38B1     	 cbz r0,.L135
1362:../FreeRTOS/Source/queue.c ****                     }
 1719              	 .loc 1 1362 0
 1720 0084 4FF08052 	 mov r2,#268435456
 1721 0088 304B     	 ldr r3,.L148
 1722 008a 1A60     	 str r2,[r3]
 1723              	
 1724 008c BFF34F8F 	 dsb
 1725              	
 1726              	
 1727 0090 BFF36F8F 	 isb
 1728              	
 1729              	 .thumb
 1730              	.L135:
1374:../FreeRTOS/Source/queue.c ****                 return pdPASS;
 1731              	 .loc 1 1374 0
 1732 0094 FFF7FEFF 	 bl vPortExitCritical
 1733              	.LVL186:
1375:../FreeRTOS/Source/queue.c ****             }
 1734              	 .loc 1 1375 0
 1735 0098 0120     	 movs r0,#1
 1736 009a 53E0     	 b .L136
 1737              	.LVL187:
 1738              	.L134:
1379:../FreeRTOS/Source/queue.c ****                 {
 1739              	 .loc 1 1379 0
 1740 009c 019B     	 ldr r3,[sp,#4]
 1741 009e 1BB9     	 cbnz r3,.L137
1383:../FreeRTOS/Source/queue.c ****                     traceQUEUE_RECEIVE_FAILED( pxQueue );
 1742              	 .loc 1 1383 0
 1743 00a0 FFF7FEFF 	 bl vPortExitCritical
 1744              	.LVL188:
1385:../FreeRTOS/Source/queue.c ****                 }
 1745              	 .loc 1 1385 0
 1746 00a4 0020     	 movs r0,#0
 1747 00a6 4DE0     	 b .L136
 1748              	.L137:
1387:../FreeRTOS/Source/queue.c ****                 {
 1749              	 .loc 1 1387 0
 1750 00a8 1FB9     	 cbnz r7,.L138
1391:../FreeRTOS/Source/queue.c ****                     xEntryTimeSet = pdTRUE;
 1751              	 .loc 1 1391 0
 1752 00aa 02A8     	 add r0,sp,#8
 1753 00ac FFF7FEFF 	 bl vTaskInternalSetTimeOutState
 1754              	.LVL189:
1392:../FreeRTOS/Source/queue.c ****                 }
 1755              	 .loc 1 1392 0
 1756 00b0 4F46     	 mov r7,r9
 1757              	.LVL190:
 1758              	.L138:
 1759              	.LBE193:
1401:../FreeRTOS/Source/queue.c **** 
 1760              	 .loc 1 1401 0
 1761 00b2 FFF7FEFF 	 bl vPortExitCritical
 1762              	.LVL191:
1406:../FreeRTOS/Source/queue.c ****         prvLockQueue( pxQueue );
 1763              	 .loc 1 1406 0
 1764 00b6 FFF7FEFF 	 bl vTaskSuspendAll
 1765              	.LVL192:
1407:../FreeRTOS/Source/queue.c **** 
 1766              	 .loc 1 1407 0
 1767 00ba FFF7FEFF 	 bl vPortEnterCritical
 1768              	.LVL193:
 1769 00be 94F84430 	 ldrb r3,[r4,#68]
 1770 00c2 5BB2     	 sxtb r3,r3
 1771 00c4 B3F1FF3F 	 cmp r3,#-1
 1772 00c8 04BF     	 itt eq
 1773 00ca 0023     	 moveq r3,#0
 1774 00cc 84F84430 	 strbeq r3,[r4,#68]
 1775 00d0 94F84530 	 ldrb r3,[r4,#69]
 1776 00d4 5BB2     	 sxtb r3,r3
 1777 00d6 B3F1FF3F 	 cmp r3,#-1
 1778 00da 04BF     	 itt eq
 1779 00dc 0023     	 moveq r3,#0
 1780 00de 84F84530 	 strbeq r3,[r4,#69]
 1781 00e2 FFF7FEFF 	 bl vPortExitCritical
 1782              	.LVL194:
1410:../FreeRTOS/Source/queue.c ****         {
 1783              	 .loc 1 1410 0
 1784 00e6 02A8     	 add r0,sp,#8
 1785 00e8 01A9     	 add r1,sp,#4
 1786              	.LVL195:
 1787 00ea FFF7FEFF 	 bl xTaskCheckForTimeOut
 1788              	.LVL196:
 1789 00ee F0B9     	 cbnz r0,.L141
1414:../FreeRTOS/Source/queue.c ****             {
 1790              	 .loc 1 1414 0
 1791 00f0 2046     	 mov r0,r4
 1792 00f2 FFF7FEFF 	 bl prvIsQueueEmpty
 1793              	.LVL197:
 1794 00f6 A0B1     	 cbz r0,.L142
1417:../FreeRTOS/Source/queue.c ****                 prvUnlockQueue( pxQueue );
 1795              	 .loc 1 1417 0
 1796 00f8 04F12400 	 add r0,r4,#36
 1797 00fc 0199     	 ldr r1,[sp,#4]
 1798 00fe FFF7FEFF 	 bl vTaskPlaceOnEventList
 1799              	.LVL198:
1418:../FreeRTOS/Source/queue.c **** 
 1800              	 .loc 1 1418 0
 1801 0102 2046     	 mov r0,r4
 1802 0104 FFF7FEFF 	 bl prvUnlockQueue
 1803              	.LVL199:
1420:../FreeRTOS/Source/queue.c ****                 {
 1804              	 .loc 1 1420 0
 1805 0108 FFF7FEFF 	 bl xTaskResumeAll
 1806              	.LVL200:
 1807 010c 0028     	 cmp r0,#0
 1808 010e A8D1     	 bne .L146
1422:../FreeRTOS/Source/queue.c ****                 }
 1809              	 .loc 1 1422 0
 1810 0110 4FF08053 	 mov r3,#268435456
 1811 0114 C8F80030 	 str r3,[r8]
 1812              	
 1813 0118 BFF34F8F 	 dsb
 1814              	
 1815              	
 1816 011c BFF36F8F 	 isb
 1817              	
 1818              	 .thumb
 1819 0120 9FE7     	 b .L146
 1820              	.L142:
1433:../FreeRTOS/Source/queue.c ****                 ( void ) xTaskResumeAll();
 1821              	 .loc 1 1433 0
 1822 0122 2046     	 mov r0,r4
 1823 0124 FFF7FEFF 	 bl prvUnlockQueue
 1824              	.LVL201:
1434:../FreeRTOS/Source/queue.c ****             }
 1825              	 .loc 1 1434 0
 1826 0128 FFF7FEFF 	 bl xTaskResumeAll
 1827              	.LVL202:
 1828 012c 99E7     	 b .L146
 1829              	.L141:
1441:../FreeRTOS/Source/queue.c ****             ( void ) xTaskResumeAll();
 1830              	 .loc 1 1441 0
 1831 012e 2046     	 mov r0,r4
 1832 0130 FFF7FEFF 	 bl prvUnlockQueue
 1833              	.LVL203:
1442:../FreeRTOS/Source/queue.c **** 
 1834              	 .loc 1 1442 0
 1835 0134 FFF7FEFF 	 bl xTaskResumeAll
 1836              	.LVL204:
1444:../FreeRTOS/Source/queue.c ****             {
 1837              	 .loc 1 1444 0
 1838 0138 2046     	 mov r0,r4
 1839 013a FFF7FEFF 	 bl prvIsQueueEmpty
 1840              	.LVL205:
 1841 013e 0028     	 cmp r0,#0
 1842 0140 8FD0     	 beq .L146
1447:../FreeRTOS/Source/queue.c ****             }
 1843              	 .loc 1 1447 0
 1844 0142 0020     	 movs r0,#0
 1845              	.LVL206:
 1846              	.L136:
1455:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1847              	 .loc 1 1455 0
 1848 0144 05B0     	 add sp,sp,#20
 1849              	.LCFI17:
 1850              	 .cfi_def_cfa_offset 28
 1851              	 
 1852 0146 BDE8F083 	 pop {r4,r5,r6,r7,r8,r9,pc}
 1853              	.LVL207:
 1854              	.L149:
 1855 014a 00BF     	 .align 2
 1856              	.L148:
 1857 014c 04ED00E0 	 .word -536810236
 1858              	 .cfi_endproc
 1859              	.LFE16:
 1861              	 .section .text.xQueueSemaphoreTake,"ax",%progbits
 1862              	 .align 2
 1863              	 .global xQueueSemaphoreTake
 1864              	 .thumb
 1865              	 .thumb_func
 1867              	xQueueSemaphoreTake:
 1868              	.LFB17:
1460:../FreeRTOS/Source/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
 1869              	 .loc 1 1460 0
 1870              	 .cfi_startproc
 1871              	 
 1872              	 
 1873              	.LVL208:
 1874 0000 2DE9F041 	 push {r4,r5,r6,r7,r8,lr}
 1875              	.LCFI18:
 1876              	 .cfi_def_cfa_offset 24
 1877              	 .cfi_offset 4,-24
 1878              	 .cfi_offset 5,-20
 1879              	 .cfi_offset 6,-16
 1880              	 .cfi_offset 7,-12
 1881              	 .cfi_offset 8,-8
 1882              	 .cfi_offset 14,-4
 1883 0004 84B0     	 sub sp,sp,#16
 1884              	.LCFI19:
 1885              	 .cfi_def_cfa_offset 40
 1886 0006 0191     	 str r1,[sp,#4]
 1887              	.LVL209:
1470:../FreeRTOS/Source/queue.c **** 
 1888              	 .loc 1 1470 0
 1889 0008 40B9     	 cbnz r0,.L151
 1890              	.LBB206:
 1891              	.LBB207:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 1892              	 .loc 2 197 0
 1893              	
 1894 000a 4FF01403 	 mov r3,#20
 1895 000e 83F31188 	 msr basepri,r3
 1896 0012 BFF36F8F 	 isb 
 1897 0016 BFF34F8F 	 dsb 
 1898              	
 1899              	
 1900              	.LVL210:
 1901              	 .thumb
 1902              	.L152:
 1903              	.LBE207:
 1904              	.LBE206:
1470:../FreeRTOS/Source/queue.c **** 
 1905              	 .loc 1 1470 0 discriminator 1
 1906 001a FEE7     	 b .L152
 1907              	.L151:
 1908 001c 0446     	 mov r4,r0
1474:../FreeRTOS/Source/queue.c **** 
 1909              	 .loc 1 1474 0
 1910 001e 036C     	 ldr r3,[r0,#64]
 1911 0020 43B1     	 cbz r3,.L153
 1912              	.LBB208:
 1913              	.LBB209:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 1914              	 .loc 2 197 0
 1915              	
 1916 0022 4FF01403 	 mov r3,#20
 1917 0026 83F31188 	 msr basepri,r3
 1918 002a BFF36F8F 	 isb 
 1919 002e BFF34F8F 	 dsb 
 1920              	
 1921              	
 1922              	.LVL211:
 1923              	 .thumb
 1924              	.L154:
 1925              	.LBE209:
 1926              	.LBE208:
1474:../FreeRTOS/Source/queue.c **** 
 1927              	 .loc 1 1474 0 discriminator 2
 1928 0032 FEE7     	 b .L154
 1929              	.L153:
1479:../FreeRTOS/Source/queue.c ****         }
 1930              	 .loc 1 1479 0
 1931 0034 FFF7FEFF 	 bl xTaskGetSchedulerState
 1932              	.LVL212:
 1933 0038 50B9     	 cbnz r0,.L172
1479:../FreeRTOS/Source/queue.c ****         }
 1934              	 .loc 1 1479 0 is_stmt 0 discriminator 2
 1935 003a 019B     	 ldr r3,[sp,#4]
 1936 003c 5BB1     	 cbz r3,.L173
 1937              	.LBB210:
 1938              	.LBB211:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 1939              	 .loc 2 197 0 is_stmt 1
 1940              	
 1941 003e 4FF01403 	 mov r3,#20
 1942 0042 83F31188 	 msr basepri,r3
 1943 0046 BFF36F8F 	 isb 
 1944 004a BFF34F8F 	 dsb 
 1945              	
 1946              	
 1947              	.LVL213:
 1948              	 .thumb
 1949              	.L156:
 1950              	.LBE211:
 1951              	.LBE210:
1479:../FreeRTOS/Source/queue.c ****         }
 1952              	 .loc 1 1479 0 discriminator 3
 1953 004e FEE7     	 b .L156
 1954              	.L172:
 1955 0050 0025     	 movs r5,#0
 1956 0052 2E46     	 mov r6,r5
 1957 0054 01E0     	 b .L155
 1958              	.L173:
 1959 0056 0025     	 movs r5,#0
 1960 0058 2E46     	 mov r6,r5
 1961              	.L155:
 1962              	.LBB212:
1564:../FreeRTOS/Source/queue.c ****                 }
 1963              	 .loc 1 1564 0
 1964 005a 4FF00108 	 mov r8,#1
 1965              	.LBE212:
1614:../FreeRTOS/Source/queue.c ****                 }
 1966              	 .loc 1 1614 0
 1967 005e 4E4F     	 ldr r7,.L178
 1968              	.LVL214:
 1969              	.L176:
1488:../FreeRTOS/Source/queue.c ****         {
 1970              	 .loc 1 1488 0
 1971 0060 FFF7FEFF 	 bl vPortEnterCritical
 1972              	.LVL215:
 1973              	.LBB215:
1492:../FreeRTOS/Source/queue.c **** 
 1974              	 .loc 1 1492 0
 1975 0064 A36B     	 ldr r3,[r4,#56]
 1976              	.LVL216:
1496:../FreeRTOS/Source/queue.c ****             {
 1977              	 .loc 1 1496 0
 1978 0066 CBB1     	 cbz r3,.L157
1502:../FreeRTOS/Source/queue.c **** 
 1979              	 .loc 1 1502 0
 1980 0068 013B     	 subs r3,r3,#1
 1981              	.LVL217:
 1982 006a A363     	 str r3,[r4,#56]
1506:../FreeRTOS/Source/queue.c ****                         {
 1983              	 .loc 1 1506 0
 1984 006c 2368     	 ldr r3,[r4]
 1985              	.LVL218:
 1986 006e 13B9     	 cbnz r3,.L158
1510:../FreeRTOS/Source/queue.c ****                         }
 1987              	 .loc 1 1510 0
 1988 0070 FFF7FEFF 	 bl pvTaskIncrementMutexHeldCount
 1989              	.LVL219:
 1990 0074 A060     	 str r0,[r4,#8]
 1991              	.L158:
1521:../FreeRTOS/Source/queue.c ****                 {
 1992              	 .loc 1 1521 0
 1993 0076 2369     	 ldr r3,[r4,#16]
 1994 0078 63B1     	 cbz r3,.L159
1523:../FreeRTOS/Source/queue.c ****                     {
 1995              	 .loc 1 1523 0
 1996 007a 04F11000 	 add r0,r4,#16
 1997 007e FFF7FEFF 	 bl xTaskRemoveFromEventList
 1998              	.LVL220:
 1999 0082 38B1     	 cbz r0,.L159
1525:../FreeRTOS/Source/queue.c ****                     }
 2000              	 .loc 1 1525 0
 2001 0084 4FF08052 	 mov r2,#268435456
 2002 0088 434B     	 ldr r3,.L178
 2003 008a 1A60     	 str r2,[r3]
 2004              	
 2005 008c BFF34F8F 	 dsb
 2006              	
 2007              	
 2008 0090 BFF36F8F 	 isb
 2009              	
 2010              	 .thumb
 2011              	.L159:
1537:../FreeRTOS/Source/queue.c ****                 return pdPASS;
 2012              	 .loc 1 1537 0
 2013 0094 FFF7FEFF 	 bl vPortExitCritical
 2014              	.LVL221:
1538:../FreeRTOS/Source/queue.c ****             }
 2015              	 .loc 1 1538 0
 2016 0098 0120     	 movs r0,#1
 2017 009a 79E0     	 b .L160
 2018              	.LVL222:
 2019              	.L157:
1542:../FreeRTOS/Source/queue.c ****                 {
 2020              	 .loc 1 1542 0
 2021 009c 019B     	 ldr r3,[sp,#4]
 2022              	.LVL223:
 2023 009e 6BB9     	 cbnz r3,.L161
1549:../FreeRTOS/Source/queue.c ****                         }
 2024              	 .loc 1 1549 0
 2025 00a0 45B1     	 cbz r5,.L162
 2026              	.LBB213:
 2027              	.LBB214:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 2028              	 .loc 2 197 0
 2029              	
 2030 00a2 4FF01403 	 mov r3,#20
 2031 00a6 83F31188 	 msr basepri,r3
 2032 00aa BFF36F8F 	 isb 
 2033 00ae BFF34F8F 	 dsb 
 2034              	
 2035              	
 2036              	.LVL224:
 2037              	 .thumb
 2038              	.L163:
 2039              	.LBE214:
 2040              	.LBE213:
1549:../FreeRTOS/Source/queue.c ****                         }
 2041              	 .loc 1 1549 0 discriminator 4
 2042 00b2 FEE7     	 b .L163
 2043              	.L162:
1555:../FreeRTOS/Source/queue.c ****                     traceQUEUE_RECEIVE_FAILED( pxQueue );
 2044              	 .loc 1 1555 0
 2045 00b4 FFF7FEFF 	 bl vPortExitCritical
 2046              	.LVL225:
1557:../FreeRTOS/Source/queue.c ****                 }
 2047              	 .loc 1 1557 0
 2048 00b8 0020     	 movs r0,#0
 2049 00ba 69E0     	 b .L160
 2050              	.L161:
1559:../FreeRTOS/Source/queue.c ****                 {
 2051              	 .loc 1 1559 0
 2052 00bc 1EB9     	 cbnz r6,.L164
1563:../FreeRTOS/Source/queue.c ****                     xEntryTimeSet = pdTRUE;
 2053              	 .loc 1 1563 0
 2054 00be 02A8     	 add r0,sp,#8
 2055 00c0 FFF7FEFF 	 bl vTaskInternalSetTimeOutState
 2056              	.LVL226:
1564:../FreeRTOS/Source/queue.c ****                 }
 2057              	 .loc 1 1564 0
 2058 00c4 4646     	 mov r6,r8
 2059              	.LVL227:
 2060              	.L164:
 2061              	.LBE215:
1573:../FreeRTOS/Source/queue.c **** 
 2062              	 .loc 1 1573 0
 2063 00c6 FFF7FEFF 	 bl vPortExitCritical
 2064              	.LVL228:
1578:../FreeRTOS/Source/queue.c ****         prvLockQueue( pxQueue );
 2065              	 .loc 1 1578 0
 2066 00ca FFF7FEFF 	 bl vTaskSuspendAll
 2067              	.LVL229:
1579:../FreeRTOS/Source/queue.c **** 
 2068              	 .loc 1 1579 0
 2069 00ce FFF7FEFF 	 bl vPortEnterCritical
 2070              	.LVL230:
 2071 00d2 94F84430 	 ldrb r3,[r4,#68]
 2072 00d6 5BB2     	 sxtb r3,r3
 2073 00d8 B3F1FF3F 	 cmp r3,#-1
 2074 00dc 04BF     	 itt eq
 2075 00de 0023     	 moveq r3,#0
 2076 00e0 84F84430 	 strbeq r3,[r4,#68]
 2077 00e4 94F84530 	 ldrb r3,[r4,#69]
 2078 00e8 5BB2     	 sxtb r3,r3
 2079 00ea B3F1FF3F 	 cmp r3,#-1
 2080 00ee 04BF     	 itt eq
 2081 00f0 0023     	 moveq r3,#0
 2082 00f2 84F84530 	 strbeq r3,[r4,#69]
 2083 00f6 FFF7FEFF 	 bl vPortExitCritical
 2084              	.LVL231:
1582:../FreeRTOS/Source/queue.c ****         {
 2085              	 .loc 1 1582 0
 2086 00fa 02A8     	 add r0,sp,#8
 2087 00fc 01A9     	 add r1,sp,#4
 2088              	.LVL232:
 2089 00fe FFF7FEFF 	 bl xTaskCheckForTimeOut
 2090              	.LVL233:
 2091 0102 38BB     	 cbnz r0,.L167
1588:../FreeRTOS/Source/queue.c ****             {
 2092              	 .loc 1 1588 0
 2093 0104 2046     	 mov r0,r4
 2094 0106 FFF7FEFF 	 bl prvIsQueueEmpty
 2095              	.LVL234:
 2096 010a E8B1     	 cbz r0,.L168
1594:../FreeRTOS/Source/queue.c ****                         {
 2097              	 .loc 1 1594 0
 2098 010c 2368     	 ldr r3,[r4]
 2099 010e 3BB9     	 cbnz r3,.L169
1596:../FreeRTOS/Source/queue.c ****                             {
 2100              	 .loc 1 1596 0
 2101 0110 FFF7FEFF 	 bl vPortEnterCritical
 2102              	.LVL235:
1598:../FreeRTOS/Source/queue.c ****                             }
 2103              	 .loc 1 1598 0
 2104 0114 A068     	 ldr r0,[r4,#8]
 2105 0116 FFF7FEFF 	 bl xTaskPriorityInherit
 2106              	.LVL236:
 2107 011a 0546     	 mov r5,r0
 2108              	.LVL237:
1600:../FreeRTOS/Source/queue.c ****                         }
 2109              	 .loc 1 1600 0
 2110 011c FFF7FEFF 	 bl vPortExitCritical
 2111              	.LVL238:
 2112              	.L169:
1609:../FreeRTOS/Source/queue.c ****                 prvUnlockQueue( pxQueue );
 2113              	 .loc 1 1609 0
 2114 0120 04F12400 	 add r0,r4,#36
 2115 0124 0199     	 ldr r1,[sp,#4]
 2116 0126 FFF7FEFF 	 bl vTaskPlaceOnEventList
 2117              	.LVL239:
1610:../FreeRTOS/Source/queue.c **** 
 2118              	 .loc 1 1610 0
 2119 012a 2046     	 mov r0,r4
 2120 012c FFF7FEFF 	 bl prvUnlockQueue
 2121              	.LVL240:
1612:../FreeRTOS/Source/queue.c ****                 {
 2122              	 .loc 1 1612 0
 2123 0130 FFF7FEFF 	 bl xTaskResumeAll
 2124              	.LVL241:
 2125 0134 0028     	 cmp r0,#0
 2126 0136 93D1     	 bne .L176
1614:../FreeRTOS/Source/queue.c ****                 }
 2127              	 .loc 1 1614 0
 2128 0138 4FF08053 	 mov r3,#268435456
 2129 013c 3B60     	 str r3,[r7]
 2130              	
 2131 013e BFF34F8F 	 dsb
 2132              	
 2133              	
 2134 0142 BFF36F8F 	 isb
 2135              	
 2136              	 .thumb
 2137 0146 8BE7     	 b .L176
 2138              	.L168:
1625:../FreeRTOS/Source/queue.c ****                 ( void ) xTaskResumeAll();
 2139              	 .loc 1 1625 0
 2140 0148 2046     	 mov r0,r4
 2141 014a FFF7FEFF 	 bl prvUnlockQueue
 2142              	.LVL242:
1626:../FreeRTOS/Source/queue.c ****             }
 2143              	 .loc 1 1626 0
 2144 014e FFF7FEFF 	 bl xTaskResumeAll
 2145              	.LVL243:
 2146 0152 85E7     	 b .L176
 2147              	.L167:
1632:../FreeRTOS/Source/queue.c ****             ( void ) xTaskResumeAll();
 2148              	 .loc 1 1632 0
 2149 0154 2046     	 mov r0,r4
 2150 0156 FFF7FEFF 	 bl prvUnlockQueue
 2151              	.LVL244:
1633:../FreeRTOS/Source/queue.c **** 
 2152              	 .loc 1 1633 0
 2153 015a FFF7FEFF 	 bl xTaskResumeAll
 2154              	.LVL245:
1639:../FreeRTOS/Source/queue.c ****             {
 2155              	 .loc 1 1639 0
 2156 015e 2046     	 mov r0,r4
 2157 0160 FFF7FEFF 	 bl prvIsQueueEmpty
 2158              	.LVL246:
 2159 0164 0028     	 cmp r0,#0
 2160 0166 3FF47BAF 	 beq .L176
1646:../FreeRTOS/Source/queue.c ****                         {
 2161              	 .loc 1 1646 0
 2162 016a 85B1     	 cbz r5,.L174
1648:../FreeRTOS/Source/queue.c ****                             {
 2163              	 .loc 1 1648 0
 2164 016c FFF7FEFF 	 bl vPortEnterCritical
 2165              	.LVL247:
 2166              	.LBB216:
 2167              	.LBB217:
 2168              	.LBB218:
2108:../FreeRTOS/Source/queue.c ****         {
 2169              	 .loc 1 2108 0
 2170 0170 636A     	 ldr r3,[r4,#36]
 2171 0172 23B1     	 cbz r3,.L175
2110:../FreeRTOS/Source/queue.c ****         }
 2172              	 .loc 1 2110 0
 2173 0174 236B     	 ldr r3,[r4,#48]
 2174 0176 1968     	 ldr r1,[r3]
 2175 0178 C1F10A01 	 rsb r1,r1,#10
 2176              	.LVL248:
 2177 017c 00E0     	 b .L171
 2178              	.LVL249:
 2179              	.L175:
2114:../FreeRTOS/Source/queue.c ****         }
 2180              	 .loc 1 2114 0
 2181 017e 0021     	 movs r1,#0
 2182              	.L171:
 2183              	.LVL250:
 2184              	.LBE218:
 2185              	.LBE217:
1658:../FreeRTOS/Source/queue.c ****                             }
 2186              	 .loc 1 1658 0
 2187 0180 A068     	 ldr r0,[r4,#8]
 2188 0182 FFF7FEFF 	 bl vTaskPriorityDisinheritAfterTimeout
 2189              	.LVL251:
 2190              	.LBE216:
1660:../FreeRTOS/Source/queue.c ****                         }
 2191              	 .loc 1 1660 0
 2192 0186 FFF7FEFF 	 bl vPortExitCritical
 2193              	.LVL252:
1666:../FreeRTOS/Source/queue.c ****             }
 2194              	 .loc 1 1666 0
 2195 018a 0020     	 movs r0,#0
 2196 018c 00E0     	 b .L160
 2197              	.LVL253:
 2198              	.L174:
 2199 018e 0020     	 movs r0,#0
 2200              	.L160:
1674:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2201              	 .loc 1 1674 0
 2202 0190 04B0     	 add sp,sp,#16
 2203              	.LCFI20:
 2204              	 .cfi_def_cfa_offset 24
 2205              	 
 2206 0192 BDE8F081 	 pop {r4,r5,r6,r7,r8,pc}
 2207              	.LVL254:
 2208              	.L179:
 2209 0196 00BF     	 .align 2
 2210              	.L178:
 2211 0198 04ED00E0 	 .word -536810236
 2212              	 .cfi_endproc
 2213              	.LFE17:
 2215              	 .section .text.xQueueTakeMutexRecursive,"ax",%progbits
 2216              	 .align 2
 2217              	 .global xQueueTakeMutexRecursive
 2218              	 .thumb
 2219              	 .thumb_func
 2221              	xQueueTakeMutexRecursive:
 2222              	.LFB11:
 670:../FreeRTOS/Source/queue.c ****         BaseType_t xReturn;
 2223              	 .loc 1 670 0
 2224              	 .cfi_startproc
 2225              	 
 2226              	 
 2227              	.LVL255:
 674:../FreeRTOS/Source/queue.c **** 
 2228              	 .loc 1 674 0
 2229 0000 40B9     	 cbnz r0,.L181
 2230              	.LBB219:
 2231              	.LBB220:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 2232              	 .loc 2 197 0
 2233              	
 2234 0002 4FF01403 	 mov r3,#20
 2235 0006 83F31188 	 msr basepri,r3
 2236 000a BFF36F8F 	 isb 
 2237 000e BFF34F8F 	 dsb 
 2238              	
 2239              	
 2240              	.LVL256:
 2241              	 .thumb
 2242              	.L182:
 2243              	.LBE220:
 2244              	.LBE219:
 674:../FreeRTOS/Source/queue.c **** 
 2245              	 .loc 1 674 0 discriminator 1
 2246 0012 FEE7     	 b .L182
 2247              	.L181:
 670:../FreeRTOS/Source/queue.c ****         BaseType_t xReturn;
 2248              	 .loc 1 670 0
 2249 0014 70B5     	 push {r4,r5,r6,lr}
 2250              	.LCFI21:
 2251              	 .cfi_def_cfa_offset 16
 2252              	 .cfi_offset 4,-16
 2253              	 .cfi_offset 5,-12
 2254              	 .cfi_offset 6,-8
 2255              	 .cfi_offset 14,-4
 2256 0016 0446     	 mov r4,r0
 2257 0018 0D46     	 mov r5,r1
 681:../FreeRTOS/Source/queue.c ****         {
 2258              	 .loc 1 681 0
 2259 001a 8668     	 ldr r6,[r0,#8]
 2260 001c FFF7FEFF 	 bl xTaskGetCurrentTaskHandle
 2261              	.LVL257:
 2262 0020 8642     	 cmp r6,r0
 2263 0022 04D1     	 bne .L183
 683:../FreeRTOS/Source/queue.c ****             xReturn = pdPASS;
 2264              	 .loc 1 683 0
 2265 0024 E368     	 ldr r3,[r4,#12]
 2266 0026 0133     	 adds r3,r3,#1
 2267 0028 E360     	 str r3,[r4,#12]
 2268              	.LVL258:
 684:../FreeRTOS/Source/queue.c ****         }
 2269              	 .loc 1 684 0
 2270 002a 0122     	 movs r2,#1
 2271 002c 08E0     	 b .L184
 2272              	.LVL259:
 2273              	.L183:
 688:../FreeRTOS/Source/queue.c **** 
 2274              	 .loc 1 688 0
 2275 002e 2046     	 mov r0,r4
 2276 0030 2946     	 mov r1,r5
 2277 0032 FFF7FEFF 	 bl xQueueSemaphoreTake
 2278              	.LVL260:
 693:../FreeRTOS/Source/queue.c ****             {
 2279              	 .loc 1 693 0
 2280 0036 0246     	 mov r2,r0
 2281 0038 10B1     	 cbz r0,.L184
 695:../FreeRTOS/Source/queue.c ****             }
 2282              	 .loc 1 695 0
 2283 003a E368     	 ldr r3,[r4,#12]
 2284 003c 0133     	 adds r3,r3,#1
 2285 003e E360     	 str r3,[r4,#12]
 2286              	.LVL261:
 2287              	.L184:
 704:../FreeRTOS/Source/queue.c **** 
 2288              	 .loc 1 704 0
 2289 0040 1046     	 mov r0,r2
 2290 0042 70BD     	 pop {r4,r5,r6,pc}
 2291              	 .cfi_endproc
 2292              	.LFE11:
 2294              	 .section .text.xQueuePeek,"ax",%progbits
 2295              	 .align 2
 2296              	 .global xQueuePeek
 2297              	 .thumb
 2298              	 .thumb_func
 2300              	xQueuePeek:
 2301              	.LFB18:
1680:../FreeRTOS/Source/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
 2302              	 .loc 1 1680 0
 2303              	 .cfi_startproc
 2304              	 
 2305              	 
 2306              	.LVL262:
 2307 0000 2DE9F041 	 push {r4,r5,r6,r7,r8,lr}
 2308              	.LCFI22:
 2309              	 .cfi_def_cfa_offset 24
 2310              	 .cfi_offset 4,-24
 2311              	 .cfi_offset 5,-20
 2312              	 .cfi_offset 6,-16
 2313              	 .cfi_offset 7,-12
 2314              	 .cfi_offset 8,-8
 2315              	 .cfi_offset 14,-4
 2316 0004 84B0     	 sub sp,sp,#16
 2317              	.LCFI23:
 2318              	 .cfi_def_cfa_offset 40
 2319 0006 0192     	 str r2,[sp,#4]
 2320              	.LVL263:
1687:../FreeRTOS/Source/queue.c **** 
 2321              	 .loc 1 1687 0
 2322 0008 40B9     	 cbnz r0,.L187
 2323              	.LBB221:
 2324              	.LBB222:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 2325              	 .loc 2 197 0
 2326              	
 2327 000a 4FF01403 	 mov r3,#20
 2328 000e 83F31188 	 msr basepri,r3
 2329 0012 BFF36F8F 	 isb 
 2330 0016 BFF34F8F 	 dsb 
 2331              	
 2332              	
 2333              	.LVL264:
 2334              	 .thumb
 2335              	.L188:
 2336              	.LBE222:
 2337              	.LBE221:
1687:../FreeRTOS/Source/queue.c **** 
 2338              	 .loc 1 1687 0 discriminator 1
 2339 001a FEE7     	 b .L188
 2340              	.L187:
 2341 001c 0446     	 mov r4,r0
1691:../FreeRTOS/Source/queue.c **** 
 2342              	 .loc 1 1691 0
 2343 001e 51B9     	 cbnz r1,.L189
1691:../FreeRTOS/Source/queue.c **** 
 2344              	 .loc 1 1691 0 is_stmt 0 discriminator 2
 2345 0020 036C     	 ldr r3,[r0,#64]
 2346 0022 43B1     	 cbz r3,.L189
 2347              	.LBB223:
 2348              	.LBB224:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 2349              	 .loc 2 197 0 is_stmt 1
 2350              	
 2351 0024 4FF01403 	 mov r3,#20
 2352 0028 83F31188 	 msr basepri,r3
 2353 002c BFF36F8F 	 isb 
 2354 0030 BFF34F8F 	 dsb 
 2355              	
 2356              	
 2357              	.LVL265:
 2358              	 .thumb
 2359              	.L190:
 2360              	.LBE224:
 2361              	.LBE223:
1691:../FreeRTOS/Source/queue.c **** 
 2362              	 .loc 1 1691 0 discriminator 2
 2363 0034 FEE7     	 b .L190
 2364              	.L189:
 2365 0036 0D46     	 mov r5,r1
1696:../FreeRTOS/Source/queue.c ****         }
 2366              	 .loc 1 1696 0
 2367 0038 FFF7FEFF 	 bl xTaskGetSchedulerState
 2368              	.LVL266:
 2369 003c 50B9     	 cbnz r0,.L203
1696:../FreeRTOS/Source/queue.c ****         }
 2370              	 .loc 1 1696 0 is_stmt 0 discriminator 2
 2371 003e 019B     	 ldr r3,[sp,#4]
 2372 0040 53B1     	 cbz r3,.L204
 2373              	.LBB225:
 2374              	.LBB226:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 2375              	 .loc 2 197 0 is_stmt 1
 2376              	
 2377 0042 4FF01403 	 mov r3,#20
 2378 0046 83F31188 	 msr basepri,r3
 2379 004a BFF36F8F 	 isb 
 2380 004e BFF34F8F 	 dsb 
 2381              	
 2382              	
 2383              	.LVL267:
 2384              	 .thumb
 2385              	.L192:
 2386              	.LBE226:
 2387              	.LBE225:
1696:../FreeRTOS/Source/queue.c ****         }
 2388              	 .loc 1 1696 0 discriminator 3
 2389 0052 FEE7     	 b .L192
 2390              	.L203:
 2391 0054 0026     	 movs r6,#0
 2392 0056 00E0     	 b .L191
 2393              	.L204:
 2394 0058 0026     	 movs r6,#0
 2395              	.L191:
 2396              	.LBB227:
1762:../FreeRTOS/Source/queue.c ****                 }
 2397              	 .loc 1 1762 0
 2398 005a 4FF00108 	 mov r8,#1
 2399              	.LBE227:
1792:../FreeRTOS/Source/queue.c ****                 }
 2400              	 .loc 1 1792 0
 2401 005e 3A4F     	 ldr r7,.L207
 2402              	.LVL268:
 2403              	.L205:
1705:../FreeRTOS/Source/queue.c ****         {
 2404              	 .loc 1 1705 0
 2405 0060 FFF7FEFF 	 bl vPortEnterCritical
 2406              	.LVL269:
 2407              	.LBB228:
1707:../FreeRTOS/Source/queue.c **** 
 2408              	 .loc 1 1707 0
 2409 0064 A36B     	 ldr r3,[r4,#56]
 2410              	.LVL270:
1711:../FreeRTOS/Source/queue.c ****             {
 2411              	 .loc 1 1711 0
 2412 0066 C3B1     	 cbz r3,.L193
1716:../FreeRTOS/Source/queue.c **** 
 2413              	 .loc 1 1716 0
 2414 0068 E668     	 ldr r6,[r4,#12]
 2415              	.LVL271:
1718:../FreeRTOS/Source/queue.c ****                 traceQUEUE_PEEK( pxQueue );
 2416              	 .loc 1 1718 0
 2417 006a 2046     	 mov r0,r4
 2418 006c 2946     	 mov r1,r5
 2419 006e FFF7FEFF 	 bl prvCopyDataFromQueue
 2420              	.LVL272:
1722:../FreeRTOS/Source/queue.c **** 
 2421              	 .loc 1 1722 0
 2422 0072 E660     	 str r6,[r4,#12]
1726:../FreeRTOS/Source/queue.c ****                 {
 2423              	 .loc 1 1726 0
 2424 0074 636A     	 ldr r3,[r4,#36]
 2425 0076 63B1     	 cbz r3,.L194
1728:../FreeRTOS/Source/queue.c ****                     {
 2426              	 .loc 1 1728 0
 2427 0078 04F12400 	 add r0,r4,#36
 2428 007c FFF7FEFF 	 bl xTaskRemoveFromEventList
 2429              	.LVL273:
 2430 0080 38B1     	 cbz r0,.L194
1731:../FreeRTOS/Source/queue.c ****                     }
 2431              	 .loc 1 1731 0
 2432 0082 4FF08052 	 mov r2,#268435456
 2433 0086 304B     	 ldr r3,.L207
 2434 0088 1A60     	 str r2,[r3]
 2435              	
 2436 008a BFF34F8F 	 dsb
 2437              	
 2438              	
 2439 008e BFF36F8F 	 isb
 2440              	
 2441              	 .thumb
 2442              	.L194:
1743:../FreeRTOS/Source/queue.c ****                 return pdPASS;
 2443              	 .loc 1 1743 0
 2444 0092 FFF7FEFF 	 bl vPortExitCritical
 2445              	.LVL274:
1744:../FreeRTOS/Source/queue.c ****             }
 2446              	 .loc 1 1744 0
 2447 0096 0120     	 movs r0,#1
 2448 0098 52E0     	 b .L195
 2449              	.LVL275:
 2450              	.L193:
1748:../FreeRTOS/Source/queue.c ****                 {
 2451              	 .loc 1 1748 0
 2452 009a 019B     	 ldr r3,[sp,#4]
 2453              	.LVL276:
 2454 009c 1BB9     	 cbnz r3,.L196
1752:../FreeRTOS/Source/queue.c ****                     traceQUEUE_PEEK_FAILED( pxQueue );
 2455              	 .loc 1 1752 0
 2456 009e FFF7FEFF 	 bl vPortExitCritical
 2457              	.LVL277:
1754:../FreeRTOS/Source/queue.c ****                 }
 2458              	 .loc 1 1754 0
 2459 00a2 0020     	 movs r0,#0
 2460 00a4 4CE0     	 b .L195
 2461              	.L196:
1756:../FreeRTOS/Source/queue.c ****                 {
 2462              	 .loc 1 1756 0
 2463 00a6 1EB9     	 cbnz r6,.L197
1761:../FreeRTOS/Source/queue.c ****                     xEntryTimeSet = pdTRUE;
 2464              	 .loc 1 1761 0
 2465 00a8 02A8     	 add r0,sp,#8
 2466 00aa FFF7FEFF 	 bl vTaskInternalSetTimeOutState
 2467              	.LVL278:
1762:../FreeRTOS/Source/queue.c ****                 }
 2468              	 .loc 1 1762 0
 2469 00ae 4646     	 mov r6,r8
 2470              	.LVL279:
 2471              	.L197:
 2472              	.LBE228:
1771:../FreeRTOS/Source/queue.c **** 
 2473              	 .loc 1 1771 0
 2474 00b0 FFF7FEFF 	 bl vPortExitCritical
 2475              	.LVL280:
1776:../FreeRTOS/Source/queue.c ****         prvLockQueue( pxQueue );
 2476              	 .loc 1 1776 0
 2477 00b4 FFF7FEFF 	 bl vTaskSuspendAll
 2478              	.LVL281:
1777:../FreeRTOS/Source/queue.c **** 
 2479              	 .loc 1 1777 0
 2480 00b8 FFF7FEFF 	 bl vPortEnterCritical
 2481              	.LVL282:
 2482 00bc 94F84430 	 ldrb r3,[r4,#68]
 2483 00c0 5BB2     	 sxtb r3,r3
 2484 00c2 B3F1FF3F 	 cmp r3,#-1
 2485 00c6 04BF     	 itt eq
 2486 00c8 0023     	 moveq r3,#0
 2487 00ca 84F84430 	 strbeq r3,[r4,#68]
 2488 00ce 94F84530 	 ldrb r3,[r4,#69]
 2489 00d2 5BB2     	 sxtb r3,r3
 2490 00d4 B3F1FF3F 	 cmp r3,#-1
 2491 00d8 04BF     	 itt eq
 2492 00da 0023     	 moveq r3,#0
 2493 00dc 84F84530 	 strbeq r3,[r4,#69]
 2494 00e0 FFF7FEFF 	 bl vPortExitCritical
 2495              	.LVL283:
1780:../FreeRTOS/Source/queue.c ****         {
 2496              	 .loc 1 1780 0
 2497 00e4 02A8     	 add r0,sp,#8
 2498 00e6 01A9     	 add r1,sp,#4
 2499              	.LVL284:
 2500 00e8 FFF7FEFF 	 bl xTaskCheckForTimeOut
 2501              	.LVL285:
 2502 00ec E8B9     	 cbnz r0,.L200
1784:../FreeRTOS/Source/queue.c ****             {
 2503              	 .loc 1 1784 0
 2504 00ee 2046     	 mov r0,r4
 2505 00f0 FFF7FEFF 	 bl prvIsQueueEmpty
 2506              	.LVL286:
 2507 00f4 98B1     	 cbz r0,.L201
1787:../FreeRTOS/Source/queue.c ****                 prvUnlockQueue( pxQueue );
 2508              	 .loc 1 1787 0
 2509 00f6 04F12400 	 add r0,r4,#36
 2510 00fa 0199     	 ldr r1,[sp,#4]
 2511 00fc FFF7FEFF 	 bl vTaskPlaceOnEventList
 2512              	.LVL287:
1788:../FreeRTOS/Source/queue.c **** 
 2513              	 .loc 1 1788 0
 2514 0100 2046     	 mov r0,r4
 2515 0102 FFF7FEFF 	 bl prvUnlockQueue
 2516              	.LVL288:
1790:../FreeRTOS/Source/queue.c ****                 {
 2517              	 .loc 1 1790 0
 2518 0106 FFF7FEFF 	 bl xTaskResumeAll
 2519              	.LVL289:
 2520 010a 0028     	 cmp r0,#0
 2521 010c A8D1     	 bne .L205
1792:../FreeRTOS/Source/queue.c ****                 }
 2522              	 .loc 1 1792 0
 2523 010e 4FF08053 	 mov r3,#268435456
 2524 0112 3B60     	 str r3,[r7]
 2525              	
 2526 0114 BFF34F8F 	 dsb
 2527              	
 2528              	
 2529 0118 BFF36F8F 	 isb
 2530              	
 2531              	 .thumb
 2532 011c A0E7     	 b .L205
 2533              	.L201:
1803:../FreeRTOS/Source/queue.c ****                 ( void ) xTaskResumeAll();
 2534              	 .loc 1 1803 0
 2535 011e 2046     	 mov r0,r4
 2536 0120 FFF7FEFF 	 bl prvUnlockQueue
 2537              	.LVL290:
1804:../FreeRTOS/Source/queue.c ****             }
 2538              	 .loc 1 1804 0
 2539 0124 FFF7FEFF 	 bl xTaskResumeAll
 2540              	.LVL291:
 2541 0128 9AE7     	 b .L205
 2542              	.L200:
1811:../FreeRTOS/Source/queue.c ****             ( void ) xTaskResumeAll();
 2543              	 .loc 1 1811 0
 2544 012a 2046     	 mov r0,r4
 2545 012c FFF7FEFF 	 bl prvUnlockQueue
 2546              	.LVL292:
1812:../FreeRTOS/Source/queue.c **** 
 2547              	 .loc 1 1812 0
 2548 0130 FFF7FEFF 	 bl xTaskResumeAll
 2549              	.LVL293:
1814:../FreeRTOS/Source/queue.c ****             {
 2550              	 .loc 1 1814 0
 2551 0134 2046     	 mov r0,r4
 2552 0136 FFF7FEFF 	 bl prvIsQueueEmpty
 2553              	.LVL294:
 2554 013a 0028     	 cmp r0,#0
 2555 013c 90D0     	 beq .L205
1817:../FreeRTOS/Source/queue.c ****             }
 2556              	 .loc 1 1817 0
 2557 013e 0020     	 movs r0,#0
 2558              	.LVL295:
 2559              	.L195:
1825:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2560              	 .loc 1 1825 0
 2561 0140 04B0     	 add sp,sp,#16
 2562              	.LCFI24:
 2563              	 .cfi_def_cfa_offset 24
 2564              	 
 2565 0142 BDE8F081 	 pop {r4,r5,r6,r7,r8,pc}
 2566              	.LVL296:
 2567              	.L208:
 2568 0146 00BF     	 .align 2
 2569              	.L207:
 2570 0148 04ED00E0 	 .word -536810236
 2571              	 .cfi_endproc
 2572              	.LFE18:
 2574              	 .section .text.xQueueReceiveFromISR,"ax",%progbits
 2575              	 .align 2
 2576              	 .global xQueueReceiveFromISR
 2577              	 .thumb
 2578              	 .thumb_func
 2580              	xQueueReceiveFromISR:
 2581              	.LFB19:
1831:../FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
 2582              	 .loc 1 1831 0
 2583              	 .cfi_startproc
 2584              	 
 2585              	 
 2586              	.LVL297:
 2587 0000 2DE9F843 	 push {r3,r4,r5,r6,r7,r8,r9,lr}
 2588              	.LCFI25:
 2589              	 .cfi_def_cfa_offset 32
 2590              	 .cfi_offset 3,-32
 2591              	 .cfi_offset 4,-28
 2592              	 .cfi_offset 5,-24
 2593              	 .cfi_offset 6,-20
 2594              	 .cfi_offset 7,-16
 2595              	 .cfi_offset 8,-12
 2596              	 .cfi_offset 9,-8
 2597              	 .cfi_offset 14,-4
 2598              	.LVL298:
1836:../FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 2599              	 .loc 1 1836 0
 2600 0004 40B9     	 cbnz r0,.L210
 2601              	.LBB229:
 2602              	.LBB230:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 2603              	 .loc 2 197 0
 2604              	
 2605 0006 4FF01403 	 mov r3,#20
 2606 000a 83F31188 	 msr basepri,r3
 2607 000e BFF36F8F 	 isb 
 2608 0012 BFF34F8F 	 dsb 
 2609              	
 2610              	
 2611              	.LVL299:
 2612              	 .thumb
 2613              	.L211:
 2614              	.LBE230:
 2615              	.LBE229:
1836:../FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 2616              	 .loc 1 1836 0 discriminator 1
 2617 0016 FEE7     	 b .L211
 2618              	.L210:
 2619 0018 0446     	 mov r4,r0
1837:../FreeRTOS/Source/queue.c **** 
 2620              	 .loc 1 1837 0
 2621 001a 51B9     	 cbnz r1,.L212
1837:../FreeRTOS/Source/queue.c **** 
 2622              	 .loc 1 1837 0 is_stmt 0 discriminator 2
 2623 001c 036C     	 ldr r3,[r0,#64]
 2624 001e 43B1     	 cbz r3,.L212
 2625              	.LBB231:
 2626              	.LBB232:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 2627              	 .loc 2 197 0 is_stmt 1
 2628              	
 2629 0020 4FF01403 	 mov r3,#20
 2630 0024 83F31188 	 msr basepri,r3
 2631 0028 BFF36F8F 	 isb 
 2632 002c BFF34F8F 	 dsb 
 2633              	
 2634              	
 2635              	.LVL300:
 2636              	 .thumb
 2637              	.L213:
 2638              	.LBE232:
 2639              	.LBE231:
1837:../FreeRTOS/Source/queue.c **** 
 2640              	 .loc 1 1837 0 discriminator 2
 2641 0030 FEE7     	 b .L213
 2642              	.L212:
 2643 0032 1646     	 mov r6,r2
 2644 0034 8946     	 mov r9,r1
1853:../FreeRTOS/Source/queue.c **** 
 2645              	 .loc 1 1853 0
 2646 0036 FFF7FEFF 	 bl vPortValidateInterruptPriority
 2647              	.LVL301:
 2648              	.LBB233:
 2649              	.LBB234:
 213:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 2650              	 .loc 2 213 0
 2651              	
 2652 003a EFF31187 	 mrs r7,basepri
 2653 003e 4FF01403 	 mov r3,#20
 2654 0042 83F31188 	 msr basepri,r3
 2655 0046 BFF36F8F 	 isb 
 2656 004a BFF34F8F 	 dsb 
 2657              	
 2658              	
 2659              	.LVL302:
 2660              	 .thumb
 2661              	.LBE234:
 2662              	.LBE233:
 2663              	.LBB235:
1857:../FreeRTOS/Source/queue.c **** 
 2664              	 .loc 1 1857 0
 2665 004e D4F83880 	 ldr r8,[r4,#56]
 2666              	.LVL303:
1860:../FreeRTOS/Source/queue.c ****         {
 2667              	 .loc 1 1860 0
 2668 0052 B8F1000F 	 cmp r8,#0
 2669 0056 2AD0     	 beq .L218
 2670              	.LBB236:
1862:../FreeRTOS/Source/queue.c **** 
 2671              	 .loc 1 1862 0
 2672 0058 94F84450 	 ldrb r5,[r4,#68]
 2673 005c EDB2     	 uxtb r5,r5
 2674              	.LVL304:
1866:../FreeRTOS/Source/queue.c ****             pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 2675              	 .loc 1 1866 0
 2676 005e 2046     	 mov r0,r4
 2677 0060 4946     	 mov r1,r9
 2678 0062 FFF7FEFF 	 bl prvCopyDataFromQueue
 2679              	.LVL305:
1867:../FreeRTOS/Source/queue.c **** 
 2680              	 .loc 1 1867 0
 2681 0066 08F1FF33 	 add r3,r8,#-1
 2682 006a A363     	 str r3,[r4,#56]
1873:../FreeRTOS/Source/queue.c ****             {
 2683              	 .loc 1 1873 0
 2684 006c 6BB2     	 sxtb r3,r5
 2685 006e B3F1FF3F 	 cmp r3,#-1
 2686 0072 0AD1     	 bne .L215
1875:../FreeRTOS/Source/queue.c ****                 {
 2687              	 .loc 1 1875 0
 2688 0074 2369     	 ldr r3,[r4,#16]
 2689 0076 E3B1     	 cbz r3,.L219
1877:../FreeRTOS/Source/queue.c ****                     {
 2690              	 .loc 1 1877 0
 2691 0078 04F11000 	 add r0,r4,#16
 2692 007c FFF7FEFF 	 bl xTaskRemoveFromEventList
 2693              	.LVL306:
 2694 0080 C8B1     	 cbz r0,.L220
1881:../FreeRTOS/Source/queue.c ****                         {
 2695              	 .loc 1 1881 0
 2696 0082 D6B1     	 cbz r6,.L221
1883:../FreeRTOS/Source/queue.c ****                         }
 2697              	 .loc 1 1883 0
 2698 0084 0120     	 movs r0,#1
 2699 0086 3060     	 str r0,[r6]
 2700 0088 18E0     	 b .L214
 2701              	.L215:
1904:../FreeRTOS/Source/queue.c **** 
 2702              	 .loc 1 1904 0
 2703 008a 6BB2     	 sxtb r3,r5
 2704 008c 7F2B     	 cmp r3,#127
 2705 008e 08D1     	 bne .L216
 2706              	.LBB237:
 2707              	.LBB238:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 2708              	 .loc 2 197 0
 2709              	
 2710 0090 4FF01403 	 mov r3,#20
 2711 0094 83F31188 	 msr basepri,r3
 2712 0098 BFF36F8F 	 isb 
 2713 009c BFF34F8F 	 dsb 
 2714              	
 2715              	
 2716              	.LVL307:
 2717              	 .thumb
 2718              	.L217:
 2719              	.LBE238:
 2720              	.LBE237:
1904:../FreeRTOS/Source/queue.c **** 
 2721              	 .loc 1 1904 0 discriminator 5
 2722 00a0 FEE7     	 b .L217
 2723              	.L216:
1906:../FreeRTOS/Source/queue.c ****             }
 2724              	 .loc 1 1906 0
 2725 00a2 6B1C     	 adds r3,r5,#1
 2726 00a4 DBB2     	 uxtb r3,r3
 2727 00a6 84F84430 	 strb r3,[r4,#68]
1909:../FreeRTOS/Source/queue.c ****         }
 2728              	 .loc 1 1909 0
 2729 00aa 0120     	 movs r0,#1
 2730 00ac 06E0     	 b .L214
 2731              	.LVL308:
 2732              	.L218:
 2733              	.LBE236:
1913:../FreeRTOS/Source/queue.c ****             traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
 2734              	 .loc 1 1913 0
 2735 00ae 0020     	 movs r0,#0
 2736 00b0 04E0     	 b .L214
 2737              	.LVL309:
 2738              	.L219:
 2739              	.LBB239:
1909:../FreeRTOS/Source/queue.c ****         }
 2740              	 .loc 1 1909 0
 2741 00b2 0120     	 movs r0,#1
 2742 00b4 02E0     	 b .L214
 2743              	.L220:
 2744 00b6 0120     	 movs r0,#1
 2745 00b8 00E0     	 b .L214
 2746              	.L221:
 2747 00ba 0120     	 movs r0,#1
 2748              	.LVL310:
 2749              	.L214:
 2750              	.LBE239:
 2751              	.LBE235:
 2752              	.LBB240:
 2753              	.LBB241:
 2754              	 .loc 2 231 0
 2755              	
 2756 00bc 87F31188 	 msr basepri,r7
 2757              	
 2758              	 .thumb
 2759              	.LBE241:
 2760              	.LBE240:
1920:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2761              	 .loc 1 1920 0
 2762 00c0 BDE8F883 	 pop {r3,r4,r5,r6,r7,r8,r9,pc}
 2763              	 .cfi_endproc
 2764              	.LFE19:
 2766              	 .section .text.xQueuePeekFromISR,"ax",%progbits
 2767              	 .align 2
 2768              	 .global xQueuePeekFromISR
 2769              	 .thumb
 2770              	 .thumb_func
 2772              	xQueuePeekFromISR:
 2773              	.LFB20:
1925:../FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
 2774              	 .loc 1 1925 0
 2775              	 .cfi_startproc
 2776              	 
 2777              	 
 2778              	.LVL311:
 2779 0000 F8B5     	 push {r3,r4,r5,r6,r7,lr}
 2780              	.LCFI26:
 2781              	 .cfi_def_cfa_offset 24
 2782              	 .cfi_offset 3,-24
 2783              	 .cfi_offset 4,-20
 2784              	 .cfi_offset 5,-16
 2785              	 .cfi_offset 6,-12
 2786              	 .cfi_offset 7,-8
 2787              	 .cfi_offset 14,-4
 2788              	.LVL312:
1931:../FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 2789              	 .loc 1 1931 0
 2790 0002 40B9     	 cbnz r0,.L224
 2791              	.LBB242:
 2792              	.LBB243:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 2793              	 .loc 2 197 0
 2794              	
 2795 0004 4FF01403 	 mov r3,#20
 2796 0008 83F31188 	 msr basepri,r3
 2797 000c BFF36F8F 	 isb 
 2798 0010 BFF34F8F 	 dsb 
 2799              	
 2800              	
 2801              	.LVL313:
 2802              	 .thumb
 2803              	.L225:
 2804              	.LBE243:
 2805              	.LBE242:
1931:../FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 2806              	 .loc 1 1931 0 discriminator 1
 2807 0014 FEE7     	 b .L225
 2808              	.L224:
 2809 0016 0446     	 mov r4,r0
1932:../FreeRTOS/Source/queue.c ****     configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
 2810              	 .loc 1 1932 0
 2811 0018 51B9     	 cbnz r1,.L226
1932:../FreeRTOS/Source/queue.c ****     configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
 2812              	 .loc 1 1932 0 is_stmt 0 discriminator 2
 2813 001a 036C     	 ldr r3,[r0,#64]
 2814 001c 53B1     	 cbz r3,.L227
 2815              	.LBB244:
 2816              	.LBB245:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 2817              	 .loc 2 197 0 is_stmt 1
 2818              	
 2819 001e 4FF01403 	 mov r3,#20
 2820 0022 83F31188 	 msr basepri,r3
 2821 0026 BFF36F8F 	 isb 
 2822 002a BFF34F8F 	 dsb 
 2823              	
 2824              	
 2825              	.LVL314:
 2826              	 .thumb
 2827              	.L228:
 2828              	.LBE245:
 2829              	.LBE244:
1932:../FreeRTOS/Source/queue.c ****     configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
 2830              	 .loc 1 1932 0 discriminator 2
 2831 002e FEE7     	 b .L228
 2832              	.L226:
1933:../FreeRTOS/Source/queue.c **** 
 2833              	 .loc 1 1933 0
 2834 0030 036C     	 ldr r3,[r0,#64]
 2835 0032 43B9     	 cbnz r3,.L229
 2836              	.L227:
 2837              	.LBB246:
 2838              	.LBB247:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 2839              	 .loc 2 197 0
 2840              	
 2841 0034 4FF01403 	 mov r3,#20
 2842 0038 83F31188 	 msr basepri,r3
 2843 003c BFF36F8F 	 isb 
 2844 0040 BFF34F8F 	 dsb 
 2845              	
 2846              	
 2847              	.LVL315:
 2848              	 .thumb
 2849              	.L230:
 2850              	.LBE247:
 2851              	.LBE246:
1933:../FreeRTOS/Source/queue.c **** 
 2852              	 .loc 1 1933 0 discriminator 3
 2853 0044 FEE7     	 b .L230
 2854              	.L229:
 2855 0046 0D46     	 mov r5,r1
1949:../FreeRTOS/Source/queue.c **** 
 2856              	 .loc 1 1949 0
 2857 0048 FFF7FEFF 	 bl vPortValidateInterruptPriority
 2858              	.LVL316:
 2859              	.LBB248:
 2860              	.LBB249:
 213:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 2861              	 .loc 2 213 0
 2862              	
 2863 004c EFF31186 	 mrs r6,basepri
 2864 0050 4FF01403 	 mov r3,#20
 2865 0054 83F31188 	 msr basepri,r3
 2866 0058 BFF36F8F 	 isb 
 2867 005c BFF34F8F 	 dsb 
 2868              	
 2869              	
 2870              	.LVL317:
 2871              	 .thumb
 2872              	.LBE249:
 2873              	.LBE248:
1954:../FreeRTOS/Source/queue.c ****         {
 2874              	 .loc 1 1954 0
 2875 0060 A36B     	 ldr r3,[r4,#56]
 2876 0062 3BB1     	 cbz r3,.L232
1960:../FreeRTOS/Source/queue.c ****             prvCopyDataFromQueue( pxQueue, pvBuffer );
 2877              	 .loc 1 1960 0
 2878 0064 E768     	 ldr r7,[r4,#12]
 2879              	.LVL318:
1961:../FreeRTOS/Source/queue.c ****             pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 2880              	 .loc 1 1961 0
 2881 0066 2046     	 mov r0,r4
 2882 0068 2946     	 mov r1,r5
 2883 006a FFF7FEFF 	 bl prvCopyDataFromQueue
 2884              	.LVL319:
1962:../FreeRTOS/Source/queue.c **** 
 2885              	 .loc 1 1962 0
 2886 006e E760     	 str r7,[r4,#12]
 2887              	.LVL320:
1964:../FreeRTOS/Source/queue.c ****         }
 2888              	 .loc 1 1964 0
 2889 0070 0120     	 movs r0,#1
 2890 0072 00E0     	 b .L231
 2891              	.LVL321:
 2892              	.L232:
1968:../FreeRTOS/Source/queue.c ****             traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
 2893              	 .loc 1 1968 0
 2894 0074 0020     	 movs r0,#0
 2895              	.L231:
 2896              	.LVL322:
 2897              	.LBB250:
 2898              	.LBB251:
 2899              	 .loc 2 231 0
 2900              	
 2901 0076 86F31188 	 msr basepri,r6
 2902              	
 2903              	 .thumb
 2904              	.LBE251:
 2905              	.LBE250:
1975:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2906              	 .loc 1 1975 0
 2907 007a F8BD     	 pop {r3,r4,r5,r6,r7,pc}
 2908              	 .cfi_endproc
 2909              	.LFE20:
 2911              	 .section .text.uxQueueMessagesWaiting,"ax",%progbits
 2912              	 .align 2
 2913              	 .global uxQueueMessagesWaiting
 2914              	 .thumb
 2915              	 .thumb_func
 2917              	uxQueueMessagesWaiting:
 2918              	.LFB21:
1979:../FreeRTOS/Source/queue.c ****     UBaseType_t uxReturn;
 2919              	 .loc 1 1979 0
 2920              	 .cfi_startproc
 2921              	 
 2922              	 
 2923              	.LVL323:
1982:../FreeRTOS/Source/queue.c **** 
 2924              	 .loc 1 1982 0
 2925 0000 40B9     	 cbnz r0,.L235
 2926              	.LBB252:
 2927              	.LBB253:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 2928              	 .loc 2 197 0
 2929              	
 2930 0002 4FF01403 	 mov r3,#20
 2931 0006 83F31188 	 msr basepri,r3
 2932 000a BFF36F8F 	 isb 
 2933 000e BFF34F8F 	 dsb 
 2934              	
 2935              	
 2936              	.LVL324:
 2937              	 .thumb
 2938              	.L236:
 2939              	.LBE253:
 2940              	.LBE252:
1982:../FreeRTOS/Source/queue.c **** 
 2941              	 .loc 1 1982 0 discriminator 1
 2942 0012 FEE7     	 b .L236
 2943              	.L235:
1979:../FreeRTOS/Source/queue.c ****     UBaseType_t uxReturn;
 2944              	 .loc 1 1979 0
 2945 0014 10B5     	 push {r4,lr}
 2946              	.LCFI27:
 2947              	 .cfi_def_cfa_offset 8
 2948              	 .cfi_offset 4,-8
 2949              	 .cfi_offset 14,-4
 2950 0016 0446     	 mov r4,r0
1984:../FreeRTOS/Source/queue.c ****     {
 2951              	 .loc 1 1984 0
 2952 0018 FFF7FEFF 	 bl vPortEnterCritical
 2953              	.LVL325:
1986:../FreeRTOS/Source/queue.c ****     }
 2954              	 .loc 1 1986 0
 2955 001c A46B     	 ldr r4,[r4,#56]
 2956              	.LVL326:
1988:../FreeRTOS/Source/queue.c **** 
 2957              	 .loc 1 1988 0
 2958 001e FFF7FEFF 	 bl vPortExitCritical
 2959              	.LVL327:
1991:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2960              	 .loc 1 1991 0
 2961 0022 2046     	 mov r0,r4
 2962 0024 10BD     	 pop {r4,pc}
 2963              	 .cfi_endproc
 2964              	.LFE21:
 2966 0026 00BF     	 .section .text.uxQueueSpacesAvailable,"ax",%progbits
 2967              	 .align 2
 2968              	 .global uxQueueSpacesAvailable
 2969              	 .thumb
 2970              	 .thumb_func
 2972              	uxQueueSpacesAvailable:
 2973              	.LFB22:
1995:../FreeRTOS/Source/queue.c ****     UBaseType_t uxReturn;
 2974              	 .loc 1 1995 0
 2975              	 .cfi_startproc
 2976              	 
 2977              	 
 2978              	.LVL328:
1999:../FreeRTOS/Source/queue.c **** 
 2979              	 .loc 1 1999 0
 2980 0000 40B9     	 cbnz r0,.L239
 2981              	.LBB254:
 2982              	.LBB255:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 2983              	 .loc 2 197 0
 2984              	
 2985 0002 4FF01403 	 mov r3,#20
 2986 0006 83F31188 	 msr basepri,r3
 2987 000a BFF36F8F 	 isb 
 2988 000e BFF34F8F 	 dsb 
 2989              	
 2990              	
 2991              	.LVL329:
 2992              	 .thumb
 2993              	.L240:
 2994              	.LBE255:
 2995              	.LBE254:
1999:../FreeRTOS/Source/queue.c **** 
 2996              	 .loc 1 1999 0 discriminator 1
 2997 0012 FEE7     	 b .L240
 2998              	.L239:
1995:../FreeRTOS/Source/queue.c ****     UBaseType_t uxReturn;
 2999              	 .loc 1 1995 0
 3000 0014 10B5     	 push {r4,lr}
 3001              	.LCFI28:
 3002              	 .cfi_def_cfa_offset 8
 3003              	 .cfi_offset 4,-8
 3004              	 .cfi_offset 14,-4
 3005 0016 0446     	 mov r4,r0
2001:../FreeRTOS/Source/queue.c ****     {
 3006              	 .loc 1 2001 0
 3007 0018 FFF7FEFF 	 bl vPortEnterCritical
 3008              	.LVL330:
2003:../FreeRTOS/Source/queue.c ****     }
 3009              	 .loc 1 2003 0
 3010 001c A26B     	 ldr r2,[r4,#56]
 3011 001e E36B     	 ldr r3,[r4,#60]
 3012 0020 9C1A     	 subs r4,r3,r2
 3013              	.LVL331:
2005:../FreeRTOS/Source/queue.c **** 
 3014              	 .loc 1 2005 0
 3015 0022 FFF7FEFF 	 bl vPortExitCritical
 3016              	.LVL332:
2008:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 3017              	 .loc 1 2008 0
 3018 0026 2046     	 mov r0,r4
 3019 0028 10BD     	 pop {r4,pc}
 3020              	 .cfi_endproc
 3021              	.LFE22:
 3023 002a 00BF     	 .section .text.uxQueueMessagesWaitingFromISR,"ax",%progbits
 3024              	 .align 2
 3025              	 .global uxQueueMessagesWaitingFromISR
 3026              	 .thumb
 3027              	 .thumb_func
 3029              	uxQueueMessagesWaitingFromISR:
 3030              	.LFB23:
2012:../FreeRTOS/Source/queue.c ****     UBaseType_t uxReturn;
 3031              	 .loc 1 2012 0
 3032              	 .cfi_startproc
 3033              	 
 3034              	 
 3035              	 
 3036              	.LVL333:
2016:../FreeRTOS/Source/queue.c ****     uxReturn = pxQueue->uxMessagesWaiting;
 3037              	 .loc 1 2016 0
 3038 0000 40B9     	 cbnz r0,.L243
 3039              	.LBB256:
 3040              	.LBB257:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 3041              	 .loc 2 197 0
 3042              	
 3043 0002 4FF01403 	 mov r3,#20
 3044 0006 83F31188 	 msr basepri,r3
 3045 000a BFF36F8F 	 isb 
 3046 000e BFF34F8F 	 dsb 
 3047              	
 3048              	
 3049              	.LVL334:
 3050              	 .thumb
 3051              	.L244:
 3052              	.LBE257:
 3053              	.LBE256:
2016:../FreeRTOS/Source/queue.c ****     uxReturn = pxQueue->uxMessagesWaiting;
 3054              	 .loc 1 2016 0 discriminator 1
 3055 0012 FEE7     	 b .L244
 3056              	.L243:
2017:../FreeRTOS/Source/queue.c **** 
 3057              	 .loc 1 2017 0
 3058 0014 806B     	 ldr r0,[r0,#56]
 3059              	.LVL335:
2020:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 3060              	 .loc 1 2020 0
 3061 0016 7047     	 bx lr
 3062              	 .cfi_endproc
 3063              	.LFE23:
 3065              	 .section .text.uxQueueGetQueueNumber,"ax",%progbits
 3066              	 .align 2
 3067              	 .global uxQueueGetQueueNumber
 3068              	 .thumb
 3069              	 .thumb_func
 3071              	uxQueueGetQueueNumber:
 3072              	.LFB25:
2068:../FreeRTOS/Source/queue.c ****         return ( ( Queue_t * ) xQueue )->uxQueueNumber;
 3073              	 .loc 1 2068 0
 3074              	 .cfi_startproc
 3075              	 
 3076              	 
 3077              	 
 3078              	.LVL336:
2070:../FreeRTOS/Source/queue.c **** 
 3079              	 .loc 1 2070 0
 3080 0000 806C     	 ldr r0,[r0,#72]
 3081              	.LVL337:
 3082 0002 7047     	 bx lr
 3083              	 .cfi_endproc
 3084              	.LFE25:
 3086              	 .section .text.vQueueSetQueueNumber,"ax",%progbits
 3087              	 .align 2
 3088              	 .global vQueueSetQueueNumber
 3089              	 .thumb
 3090              	 .thumb_func
 3092              	vQueueSetQueueNumber:
 3093              	.LFB26:
2079:../FreeRTOS/Source/queue.c ****         ( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
 3094              	 .loc 1 2079 0
 3095              	 .cfi_startproc
 3096              	 
 3097              	 
 3098              	 
 3099              	.LVL338:
2080:../FreeRTOS/Source/queue.c ****     }
 3100              	 .loc 1 2080 0
 3101 0000 8164     	 str r1,[r0,#72]
 3102 0002 7047     	 bx lr
 3103              	 .cfi_endproc
 3104              	.LFE26:
 3106              	 .section .text.ucQueueGetQueueType,"ax",%progbits
 3107              	 .align 2
 3108              	 .global ucQueueGetQueueType
 3109              	 .thumb
 3110              	 .thumb_func
 3112              	ucQueueGetQueueType:
 3113              	.LFB27:
2089:../FreeRTOS/Source/queue.c ****         return ( ( Queue_t * ) xQueue )->ucQueueType;
 3114              	 .loc 1 2089 0
 3115              	 .cfi_startproc
 3116              	 
 3117              	 
 3118              	 
 3119              	.LVL339:
2091:../FreeRTOS/Source/queue.c **** 
 3120              	 .loc 1 2091 0
 3121 0000 90F84C00 	 ldrb r0,[r0,#76]
 3122              	.LVL340:
 3123 0004 7047     	 bx lr
 3124              	 .cfi_endproc
 3125              	.LFE27:
 3127 0006 00BF     	 .section .text.xQueueIsQueueEmptyFromISR,"ax",%progbits
 3128              	 .align 2
 3129              	 .global xQueueIsQueueEmptyFromISR
 3130              	 .thumb
 3131              	 .thumb_func
 3133              	xQueueIsQueueEmptyFromISR:
 3134              	.LFB33:
2369:../FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
 3135              	 .loc 1 2369 0
 3136              	 .cfi_startproc
 3137              	 
 3138              	 
 3139              	 
 3140              	.LVL341:
2373:../FreeRTOS/Source/queue.c **** 
 3141              	 .loc 1 2373 0
 3142 0000 40B9     	 cbnz r0,.L249
 3143              	.LBB258:
 3144              	.LBB259:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 3145              	 .loc 2 197 0
 3146              	
 3147 0002 4FF01403 	 mov r3,#20
 3148 0006 83F31188 	 msr basepri,r3
 3149 000a BFF36F8F 	 isb 
 3150 000e BFF34F8F 	 dsb 
 3151              	
 3152              	
 3153              	.LVL342:
 3154              	 .thumb
 3155              	.L250:
 3156              	.LBE259:
 3157              	.LBE258:
2373:../FreeRTOS/Source/queue.c **** 
 3158              	 .loc 1 2373 0 discriminator 1
 3159 0012 FEE7     	 b .L250
 3160              	.L249:
2375:../FreeRTOS/Source/queue.c ****     {
 3161              	 .loc 1 2375 0
 3162 0014 806B     	 ldr r0,[r0,#56]
 3163              	.LVL343:
2385:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 3164              	 .loc 1 2385 0
 3165 0016 B0FA80F0 	 clz r0,r0
 3166              	.LVL344:
 3167 001a 4009     	 lsrs r0,r0,#5
 3168 001c 7047     	 bx lr
 3169              	 .cfi_endproc
 3170              	.LFE33:
 3172 001e 00BF     	 .section .text.xQueueIsQueueFullFromISR,"ax",%progbits
 3173              	 .align 2
 3174              	 .global xQueueIsQueueFullFromISR
 3175              	 .thumb
 3176              	 .thumb_func
 3178              	xQueueIsQueueFullFromISR:
 3179              	.LFB35:
2404:../FreeRTOS/Source/queue.c **** 
2405:../FreeRTOS/Source/queue.c ****     return xReturn;
2406:../FreeRTOS/Source/queue.c **** }
2407:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2408:../FreeRTOS/Source/queue.c **** 
2409:../FreeRTOS/Source/queue.c **** BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
2410:../FreeRTOS/Source/queue.c **** {
 3180              	 .loc 1 2410 0
 3181              	 .cfi_startproc
 3182              	 
 3183              	 
 3184              	 
 3185              	.LVL345:
2411:../FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
2412:../FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
2413:../FreeRTOS/Source/queue.c **** 
2414:../FreeRTOS/Source/queue.c ****     configASSERT( pxQueue );
 3186              	 .loc 1 2414 0
 3187 0000 0346     	 mov r3,r0
 3188 0002 40B9     	 cbnz r0,.L252
 3189              	.LBB260:
 3190              	.LBB261:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 3191              	 .loc 2 197 0
 3192              	
 3193 0004 4FF01403 	 mov r3,#20
 3194 0008 83F31188 	 msr basepri,r3
 3195 000c BFF36F8F 	 isb 
 3196 0010 BFF34F8F 	 dsb 
 3197              	
 3198              	
 3199              	.LVL346:
 3200              	 .thumb
 3201              	.L253:
 3202              	.LBE261:
 3203              	.LBE260:
 3204              	 .loc 1 2414 0 discriminator 1
 3205 0014 FEE7     	 b .L253
 3206              	.L252:
2415:../FreeRTOS/Source/queue.c **** 
2416:../FreeRTOS/Source/queue.c ****     if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 3207              	 .loc 1 2416 0
 3208 0016 806B     	 ldr r0,[r0,#56]
 3209              	.LVL347:
 3210 0018 DB6B     	 ldr r3,[r3,#60]
 3211              	.LVL348:
2417:../FreeRTOS/Source/queue.c ****     {
2418:../FreeRTOS/Source/queue.c ****         xReturn = pdTRUE;
2419:../FreeRTOS/Source/queue.c ****     }
2420:../FreeRTOS/Source/queue.c ****     else
2421:../FreeRTOS/Source/queue.c ****     {
2422:../FreeRTOS/Source/queue.c ****         xReturn = pdFALSE;
2423:../FreeRTOS/Source/queue.c ****     }
2424:../FreeRTOS/Source/queue.c **** 
2425:../FreeRTOS/Source/queue.c ****     return xReturn;
2426:../FreeRTOS/Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 3212              	 .loc 1 2426 0
 3213 001a 9842     	 cmp r0,r3
 3214 001c 14BF     	 ite ne
 3215 001e 0020     	 movne r0,#0
 3216              	.LVL349:
 3217 0020 0120     	 moveq r0,#1
 3218 0022 7047     	 bx lr
 3219              	 .cfi_endproc
 3220              	.LFE35:
 3222              	 .section .text.vQueueAddToRegistry,"ax",%progbits
 3223              	 .align 2
 3224              	 .global vQueueAddToRegistry
 3225              	 .thumb
 3226              	 .thumb_func
 3228              	vQueueAddToRegistry:
 3229              	.LFB36:
2427:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2428:../FreeRTOS/Source/queue.c **** 
2429:../FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2430:../FreeRTOS/Source/queue.c **** 
2431:../FreeRTOS/Source/queue.c ****     BaseType_t xQueueCRSend( QueueHandle_t xQueue,
2432:../FreeRTOS/Source/queue.c ****                              const void * pvItemToQueue,
2433:../FreeRTOS/Source/queue.c ****                              TickType_t xTicksToWait )
2434:../FreeRTOS/Source/queue.c ****     {
2435:../FreeRTOS/Source/queue.c ****         BaseType_t xReturn;
2436:../FreeRTOS/Source/queue.c ****         Queue_t * const pxQueue = xQueue;
2437:../FreeRTOS/Source/queue.c **** 
2438:../FreeRTOS/Source/queue.c ****         /* If the queue is already full we may have to block.  A critical section
2439:../FreeRTOS/Source/queue.c ****          * is required to prevent an interrupt removing something from the queue
2440:../FreeRTOS/Source/queue.c ****          * between the check to see if the queue is full and blocking on the queue. */
2441:../FreeRTOS/Source/queue.c ****         portDISABLE_INTERRUPTS();
2442:../FreeRTOS/Source/queue.c ****         {
2443:../FreeRTOS/Source/queue.c ****             if( prvIsQueueFull( pxQueue ) != pdFALSE )
2444:../FreeRTOS/Source/queue.c ****             {
2445:../FreeRTOS/Source/queue.c ****                 /* The queue is full - do we want to block or just leave without
2446:../FreeRTOS/Source/queue.c ****                  * posting? */
2447:../FreeRTOS/Source/queue.c ****                 if( xTicksToWait > ( TickType_t ) 0 )
2448:../FreeRTOS/Source/queue.c ****                 {
2449:../FreeRTOS/Source/queue.c ****                     /* As this is called from a coroutine we cannot block directly, but
2450:../FreeRTOS/Source/queue.c ****                      * return indicating that we need to block. */
2451:../FreeRTOS/Source/queue.c ****                     vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
2452:../FreeRTOS/Source/queue.c ****                     portENABLE_INTERRUPTS();
2453:../FreeRTOS/Source/queue.c ****                     return errQUEUE_BLOCKED;
2454:../FreeRTOS/Source/queue.c ****                 }
2455:../FreeRTOS/Source/queue.c ****                 else
2456:../FreeRTOS/Source/queue.c ****                 {
2457:../FreeRTOS/Source/queue.c ****                     portENABLE_INTERRUPTS();
2458:../FreeRTOS/Source/queue.c ****                     return errQUEUE_FULL;
2459:../FreeRTOS/Source/queue.c ****                 }
2460:../FreeRTOS/Source/queue.c ****             }
2461:../FreeRTOS/Source/queue.c ****         }
2462:../FreeRTOS/Source/queue.c ****         portENABLE_INTERRUPTS();
2463:../FreeRTOS/Source/queue.c **** 
2464:../FreeRTOS/Source/queue.c ****         portDISABLE_INTERRUPTS();
2465:../FreeRTOS/Source/queue.c ****         {
2466:../FreeRTOS/Source/queue.c ****             if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2467:../FreeRTOS/Source/queue.c ****             {
2468:../FreeRTOS/Source/queue.c ****                 /* There is room in the queue, copy the data into the queue. */
2469:../FreeRTOS/Source/queue.c ****                 prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2470:../FreeRTOS/Source/queue.c ****                 xReturn = pdPASS;
2471:../FreeRTOS/Source/queue.c **** 
2472:../FreeRTOS/Source/queue.c ****                 /* Were any co-routines waiting for data to become available? */
2473:../FreeRTOS/Source/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2474:../FreeRTOS/Source/queue.c ****                 {
2475:../FreeRTOS/Source/queue.c ****                     /* In this instance the co-routine could be placed directly
2476:../FreeRTOS/Source/queue.c ****                      * into the ready list as we are within a critical section.
2477:../FreeRTOS/Source/queue.c ****                      * Instead the same pending ready list mechanism is used as if
2478:../FreeRTOS/Source/queue.c ****                      * the event were caused from within an interrupt. */
2479:../FreeRTOS/Source/queue.c ****                     if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pd
2480:../FreeRTOS/Source/queue.c ****                     {
2481:../FreeRTOS/Source/queue.c ****                         /* The co-routine waiting has a higher priority so record
2482:../FreeRTOS/Source/queue.c ****                          * that a yield might be appropriate. */
2483:../FreeRTOS/Source/queue.c ****                         xReturn = errQUEUE_YIELD;
2484:../FreeRTOS/Source/queue.c ****                     }
2485:../FreeRTOS/Source/queue.c ****                     else
2486:../FreeRTOS/Source/queue.c ****                     {
2487:../FreeRTOS/Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
2488:../FreeRTOS/Source/queue.c ****                     }
2489:../FreeRTOS/Source/queue.c ****                 }
2490:../FreeRTOS/Source/queue.c ****                 else
2491:../FreeRTOS/Source/queue.c ****                 {
2492:../FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2493:../FreeRTOS/Source/queue.c ****                 }
2494:../FreeRTOS/Source/queue.c ****             }
2495:../FreeRTOS/Source/queue.c ****             else
2496:../FreeRTOS/Source/queue.c ****             {
2497:../FreeRTOS/Source/queue.c ****                 xReturn = errQUEUE_FULL;
2498:../FreeRTOS/Source/queue.c ****             }
2499:../FreeRTOS/Source/queue.c ****         }
2500:../FreeRTOS/Source/queue.c ****         portENABLE_INTERRUPTS();
2501:../FreeRTOS/Source/queue.c **** 
2502:../FreeRTOS/Source/queue.c ****         return xReturn;
2503:../FreeRTOS/Source/queue.c ****     }
2504:../FreeRTOS/Source/queue.c **** 
2505:../FreeRTOS/Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2506:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2507:../FreeRTOS/Source/queue.c **** 
2508:../FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2509:../FreeRTOS/Source/queue.c **** 
2510:../FreeRTOS/Source/queue.c ****     BaseType_t xQueueCRReceive( QueueHandle_t xQueue,
2511:../FreeRTOS/Source/queue.c ****                                 void * pvBuffer,
2512:../FreeRTOS/Source/queue.c ****                                 TickType_t xTicksToWait )
2513:../FreeRTOS/Source/queue.c ****     {
2514:../FreeRTOS/Source/queue.c ****         BaseType_t xReturn;
2515:../FreeRTOS/Source/queue.c ****         Queue_t * const pxQueue = xQueue;
2516:../FreeRTOS/Source/queue.c **** 
2517:../FreeRTOS/Source/queue.c ****         /* If the queue is already empty we may have to block.  A critical section
2518:../FreeRTOS/Source/queue.c ****          * is required to prevent an interrupt adding something to the queue
2519:../FreeRTOS/Source/queue.c ****          * between the check to see if the queue is empty and blocking on the queue. */
2520:../FreeRTOS/Source/queue.c ****         portDISABLE_INTERRUPTS();
2521:../FreeRTOS/Source/queue.c ****         {
2522:../FreeRTOS/Source/queue.c ****             if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
2523:../FreeRTOS/Source/queue.c ****             {
2524:../FreeRTOS/Source/queue.c ****                 /* There are no messages in the queue, do we want to block or just
2525:../FreeRTOS/Source/queue.c ****                  * leave with nothing? */
2526:../FreeRTOS/Source/queue.c ****                 if( xTicksToWait > ( TickType_t ) 0 )
2527:../FreeRTOS/Source/queue.c ****                 {
2528:../FreeRTOS/Source/queue.c ****                     /* As this is a co-routine we cannot block directly, but return
2529:../FreeRTOS/Source/queue.c ****                      * indicating that we need to block. */
2530:../FreeRTOS/Source/queue.c ****                     vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) 
2531:../FreeRTOS/Source/queue.c ****                     portENABLE_INTERRUPTS();
2532:../FreeRTOS/Source/queue.c ****                     return errQUEUE_BLOCKED;
2533:../FreeRTOS/Source/queue.c ****                 }
2534:../FreeRTOS/Source/queue.c ****                 else
2535:../FreeRTOS/Source/queue.c ****                 {
2536:../FreeRTOS/Source/queue.c ****                     portENABLE_INTERRUPTS();
2537:../FreeRTOS/Source/queue.c ****                     return errQUEUE_FULL;
2538:../FreeRTOS/Source/queue.c ****                 }
2539:../FreeRTOS/Source/queue.c ****             }
2540:../FreeRTOS/Source/queue.c ****             else
2541:../FreeRTOS/Source/queue.c ****             {
2542:../FreeRTOS/Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2543:../FreeRTOS/Source/queue.c ****             }
2544:../FreeRTOS/Source/queue.c ****         }
2545:../FreeRTOS/Source/queue.c ****         portENABLE_INTERRUPTS();
2546:../FreeRTOS/Source/queue.c **** 
2547:../FreeRTOS/Source/queue.c ****         portDISABLE_INTERRUPTS();
2548:../FreeRTOS/Source/queue.c ****         {
2549:../FreeRTOS/Source/queue.c ****             if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2550:../FreeRTOS/Source/queue.c ****             {
2551:../FreeRTOS/Source/queue.c ****                 /* Data is available from the queue. */
2552:../FreeRTOS/Source/queue.c ****                 pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
2553:../FreeRTOS/Source/queue.c **** 
2554:../FreeRTOS/Source/queue.c ****                 if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
2555:../FreeRTOS/Source/queue.c ****                 {
2556:../FreeRTOS/Source/queue.c ****                     pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
2557:../FreeRTOS/Source/queue.c ****                 }
2558:../FreeRTOS/Source/queue.c ****                 else
2559:../FreeRTOS/Source/queue.c ****                 {
2560:../FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2561:../FreeRTOS/Source/queue.c ****                 }
2562:../FreeRTOS/Source/queue.c **** 
2563:../FreeRTOS/Source/queue.c ****                 --( pxQueue->uxMessagesWaiting );
2564:../FreeRTOS/Source/queue.c ****                 ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( un
2565:../FreeRTOS/Source/queue.c **** 
2566:../FreeRTOS/Source/queue.c ****                 xReturn = pdPASS;
2567:../FreeRTOS/Source/queue.c **** 
2568:../FreeRTOS/Source/queue.c ****                 /* Were any co-routines waiting for space to become available? */
2569:../FreeRTOS/Source/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2570:../FreeRTOS/Source/queue.c ****                 {
2571:../FreeRTOS/Source/queue.c ****                     /* In this instance the co-routine could be placed directly
2572:../FreeRTOS/Source/queue.c ****                      * into the ready list as we are within a critical section.
2573:../FreeRTOS/Source/queue.c ****                      * Instead the same pending ready list mechanism is used as if
2574:../FreeRTOS/Source/queue.c ****                      * the event were caused from within an interrupt. */
2575:../FreeRTOS/Source/queue.c ****                     if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFAL
2576:../FreeRTOS/Source/queue.c ****                     {
2577:../FreeRTOS/Source/queue.c ****                         xReturn = errQUEUE_YIELD;
2578:../FreeRTOS/Source/queue.c ****                     }
2579:../FreeRTOS/Source/queue.c ****                     else
2580:../FreeRTOS/Source/queue.c ****                     {
2581:../FreeRTOS/Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
2582:../FreeRTOS/Source/queue.c ****                     }
2583:../FreeRTOS/Source/queue.c ****                 }
2584:../FreeRTOS/Source/queue.c ****                 else
2585:../FreeRTOS/Source/queue.c ****                 {
2586:../FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2587:../FreeRTOS/Source/queue.c ****                 }
2588:../FreeRTOS/Source/queue.c ****             }
2589:../FreeRTOS/Source/queue.c ****             else
2590:../FreeRTOS/Source/queue.c ****             {
2591:../FreeRTOS/Source/queue.c ****                 xReturn = pdFAIL;
2592:../FreeRTOS/Source/queue.c ****             }
2593:../FreeRTOS/Source/queue.c ****         }
2594:../FreeRTOS/Source/queue.c ****         portENABLE_INTERRUPTS();
2595:../FreeRTOS/Source/queue.c **** 
2596:../FreeRTOS/Source/queue.c ****         return xReturn;
2597:../FreeRTOS/Source/queue.c ****     }
2598:../FreeRTOS/Source/queue.c **** 
2599:../FreeRTOS/Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2600:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2601:../FreeRTOS/Source/queue.c **** 
2602:../FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2603:../FreeRTOS/Source/queue.c **** 
2604:../FreeRTOS/Source/queue.c ****     BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue,
2605:../FreeRTOS/Source/queue.c ****                                     const void * pvItemToQueue,
2606:../FreeRTOS/Source/queue.c ****                                     BaseType_t xCoRoutinePreviouslyWoken )
2607:../FreeRTOS/Source/queue.c ****     {
2608:../FreeRTOS/Source/queue.c ****         Queue_t * const pxQueue = xQueue;
2609:../FreeRTOS/Source/queue.c **** 
2610:../FreeRTOS/Source/queue.c ****         /* Cannot block within an ISR so if there is no space on the queue then
2611:../FreeRTOS/Source/queue.c ****          * exit without doing anything. */
2612:../FreeRTOS/Source/queue.c ****         if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2613:../FreeRTOS/Source/queue.c ****         {
2614:../FreeRTOS/Source/queue.c ****             prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2615:../FreeRTOS/Source/queue.c **** 
2616:../FreeRTOS/Source/queue.c ****             /* We only want to wake one co-routine per ISR, so check that a
2617:../FreeRTOS/Source/queue.c ****              * co-routine has not already been woken. */
2618:../FreeRTOS/Source/queue.c ****             if( xCoRoutinePreviouslyWoken == pdFALSE )
2619:../FreeRTOS/Source/queue.c ****             {
2620:../FreeRTOS/Source/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2621:../FreeRTOS/Source/queue.c ****                 {
2622:../FreeRTOS/Source/queue.c ****                     if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pd
2623:../FreeRTOS/Source/queue.c ****                     {
2624:../FreeRTOS/Source/queue.c ****                         return pdTRUE;
2625:../FreeRTOS/Source/queue.c ****                     }
2626:../FreeRTOS/Source/queue.c ****                     else
2627:../FreeRTOS/Source/queue.c ****                     {
2628:../FreeRTOS/Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
2629:../FreeRTOS/Source/queue.c ****                     }
2630:../FreeRTOS/Source/queue.c ****                 }
2631:../FreeRTOS/Source/queue.c ****                 else
2632:../FreeRTOS/Source/queue.c ****                 {
2633:../FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2634:../FreeRTOS/Source/queue.c ****                 }
2635:../FreeRTOS/Source/queue.c ****             }
2636:../FreeRTOS/Source/queue.c ****             else
2637:../FreeRTOS/Source/queue.c ****             {
2638:../FreeRTOS/Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2639:../FreeRTOS/Source/queue.c ****             }
2640:../FreeRTOS/Source/queue.c ****         }
2641:../FreeRTOS/Source/queue.c ****         else
2642:../FreeRTOS/Source/queue.c ****         {
2643:../FreeRTOS/Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
2644:../FreeRTOS/Source/queue.c ****         }
2645:../FreeRTOS/Source/queue.c **** 
2646:../FreeRTOS/Source/queue.c ****         return xCoRoutinePreviouslyWoken;
2647:../FreeRTOS/Source/queue.c ****     }
2648:../FreeRTOS/Source/queue.c **** 
2649:../FreeRTOS/Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2650:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2651:../FreeRTOS/Source/queue.c **** 
2652:../FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2653:../FreeRTOS/Source/queue.c **** 
2654:../FreeRTOS/Source/queue.c ****     BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue,
2655:../FreeRTOS/Source/queue.c ****                                        void * pvBuffer,
2656:../FreeRTOS/Source/queue.c ****                                        BaseType_t * pxCoRoutineWoken )
2657:../FreeRTOS/Source/queue.c ****     {
2658:../FreeRTOS/Source/queue.c ****         BaseType_t xReturn;
2659:../FreeRTOS/Source/queue.c ****         Queue_t * const pxQueue = xQueue;
2660:../FreeRTOS/Source/queue.c **** 
2661:../FreeRTOS/Source/queue.c ****         /* We cannot block from an ISR, so check there is data available. If
2662:../FreeRTOS/Source/queue.c ****          * not then just leave without doing anything. */
2663:../FreeRTOS/Source/queue.c ****         if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2664:../FreeRTOS/Source/queue.c ****         {
2665:../FreeRTOS/Source/queue.c ****             /* Copy the data from the queue. */
2666:../FreeRTOS/Source/queue.c ****             pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
2667:../FreeRTOS/Source/queue.c **** 
2668:../FreeRTOS/Source/queue.c ****             if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
2669:../FreeRTOS/Source/queue.c ****             {
2670:../FreeRTOS/Source/queue.c ****                 pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
2671:../FreeRTOS/Source/queue.c ****             }
2672:../FreeRTOS/Source/queue.c ****             else
2673:../FreeRTOS/Source/queue.c ****             {
2674:../FreeRTOS/Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2675:../FreeRTOS/Source/queue.c ****             }
2676:../FreeRTOS/Source/queue.c **** 
2677:../FreeRTOS/Source/queue.c ****             --( pxQueue->uxMessagesWaiting );
2678:../FreeRTOS/Source/queue.c ****             ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsign
2679:../FreeRTOS/Source/queue.c **** 
2680:../FreeRTOS/Source/queue.c ****             if( ( *pxCoRoutineWoken ) == pdFALSE )
2681:../FreeRTOS/Source/queue.c ****             {
2682:../FreeRTOS/Source/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2683:../FreeRTOS/Source/queue.c ****                 {
2684:../FreeRTOS/Source/queue.c ****                     if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFAL
2685:../FreeRTOS/Source/queue.c ****                     {
2686:../FreeRTOS/Source/queue.c ****                         *pxCoRoutineWoken = pdTRUE;
2687:../FreeRTOS/Source/queue.c ****                     }
2688:../FreeRTOS/Source/queue.c ****                     else
2689:../FreeRTOS/Source/queue.c ****                     {
2690:../FreeRTOS/Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
2691:../FreeRTOS/Source/queue.c ****                     }
2692:../FreeRTOS/Source/queue.c ****                 }
2693:../FreeRTOS/Source/queue.c ****                 else
2694:../FreeRTOS/Source/queue.c ****                 {
2695:../FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2696:../FreeRTOS/Source/queue.c ****                 }
2697:../FreeRTOS/Source/queue.c ****             }
2698:../FreeRTOS/Source/queue.c ****             else
2699:../FreeRTOS/Source/queue.c ****             {
2700:../FreeRTOS/Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2701:../FreeRTOS/Source/queue.c ****             }
2702:../FreeRTOS/Source/queue.c **** 
2703:../FreeRTOS/Source/queue.c ****             xReturn = pdPASS;
2704:../FreeRTOS/Source/queue.c ****         }
2705:../FreeRTOS/Source/queue.c ****         else
2706:../FreeRTOS/Source/queue.c ****         {
2707:../FreeRTOS/Source/queue.c ****             xReturn = pdFAIL;
2708:../FreeRTOS/Source/queue.c ****         }
2709:../FreeRTOS/Source/queue.c **** 
2710:../FreeRTOS/Source/queue.c ****         return xReturn;
2711:../FreeRTOS/Source/queue.c ****     }
2712:../FreeRTOS/Source/queue.c **** 
2713:../FreeRTOS/Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2714:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2715:../FreeRTOS/Source/queue.c **** 
2716:../FreeRTOS/Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2717:../FreeRTOS/Source/queue.c **** 
2718:../FreeRTOS/Source/queue.c ****     void vQueueAddToRegistry( QueueHandle_t xQueue,
2719:../FreeRTOS/Source/queue.c ****                               const char * pcQueueName ) /*lint !e971 Unqualified char types are al
2720:../FreeRTOS/Source/queue.c ****     {
 3230              	 .loc 1 2720 0
 3231              	 .cfi_startproc
 3232              	 
 3233              	 
 3234              	 
 3235              	.LVL350:
 3236 0000 10B4     	 push {r4}
 3237              	.LCFI29:
 3238              	 .cfi_def_cfa_offset 4
 3239              	 .cfi_offset 4,-4
 3240              	.LVL351:
2721:../FreeRTOS/Source/queue.c ****         UBaseType_t ux;
2722:../FreeRTOS/Source/queue.c **** 
2723:../FreeRTOS/Source/queue.c ****         /* See if there is an empty space in the registry.  A NULL name denotes
2724:../FreeRTOS/Source/queue.c ****          * a free slot. */
2725:../FreeRTOS/Source/queue.c ****         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
2726:../FreeRTOS/Source/queue.c ****         {
2727:../FreeRTOS/Source/queue.c ****             if( xQueueRegistry[ ux ].pcQueueName == NULL )
 3241              	 .loc 1 2727 0
 3242 0002 0B4B     	 ldr r3,.L262
 3243 0004 1B68     	 ldr r3,[r3]
 3244 0006 2BB1     	 cbz r3,.L259
 3245 0008 0123     	 movs r3,#1
 3246 000a 094C     	 ldr r4,.L262
 3247              	.LVL352:
 3248              	.L258:
 3249 000c 54F83320 	 ldr r2,[r4,r3,lsl#3]
 3250 0010 42B9     	 cbnz r2,.L256
 3251 0012 00E0     	 b .L255
 3252              	.LVL353:
 3253              	.L259:
2725:../FreeRTOS/Source/queue.c ****         {
 3254              	 .loc 1 2725 0
 3255 0014 0023     	 movs r3,#0
 3256              	.LVL354:
 3257              	.L255:
2728:../FreeRTOS/Source/queue.c ****             {
2729:../FreeRTOS/Source/queue.c ****                 /* Store the information on this queue. */
2730:../FreeRTOS/Source/queue.c ****                 xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 3258              	 .loc 1 2730 0
 3259 0016 064A     	 ldr r2,.L262
 3260 0018 42F83310 	 str r1,[r2,r3,lsl#3]
2731:../FreeRTOS/Source/queue.c ****                 xQueueRegistry[ ux ].xHandle = xQueue;
 3261              	 .loc 1 2731 0
 3262 001c 02EBC303 	 add r3,r2,r3,lsl#3
 3263 0020 5860     	 str r0,[r3,#4]
2732:../FreeRTOS/Source/queue.c **** 
2733:../FreeRTOS/Source/queue.c ****                 traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
2734:../FreeRTOS/Source/queue.c ****                 break;
 3264              	 .loc 1 2734 0
 3265 0022 02E0     	 b .L254
 3266              	.LVL355:
 3267              	.L256:
2725:../FreeRTOS/Source/queue.c ****         {
 3268              	 .loc 1 2725 0 discriminator 2
 3269 0024 0133     	 adds r3,r3,#1
 3270              	.LVL356:
 3271 0026 082B     	 cmp r3,#8
 3272 0028 F0D1     	 bne .L258
 3273              	.LVL357:
 3274              	.L254:
2735:../FreeRTOS/Source/queue.c ****             }
2736:../FreeRTOS/Source/queue.c ****             else
2737:../FreeRTOS/Source/queue.c ****             {
2738:../FreeRTOS/Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2739:../FreeRTOS/Source/queue.c ****             }
2740:../FreeRTOS/Source/queue.c ****         }
2741:../FreeRTOS/Source/queue.c ****     }
 3275              	 .loc 1 2741 0
 3276 002a 5DF8044B 	 ldr r4,[sp],#4
 3277              	.LCFI30:
 3278              	 .cfi_restore 4
 3279              	 .cfi_def_cfa_offset 0
 3280 002e 7047     	 bx lr
 3281              	.L263:
 3282              	 .align 2
 3283              	.L262:
 3284 0030 00000000 	 .word xQueueRegistry
 3285              	 .cfi_endproc
 3286              	.LFE36:
 3288              	 .section .text.pcQueueGetName,"ax",%progbits
 3289              	 .align 2
 3290              	 .global pcQueueGetName
 3291              	 .thumb
 3292              	 .thumb_func
 3294              	pcQueueGetName:
 3295              	.LFB37:
2742:../FreeRTOS/Source/queue.c **** 
2743:../FreeRTOS/Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2744:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2745:../FreeRTOS/Source/queue.c **** 
2746:../FreeRTOS/Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2747:../FreeRTOS/Source/queue.c **** 
2748:../FreeRTOS/Source/queue.c ****     const char * pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are all
2749:../FreeRTOS/Source/queue.c ****     {
 3296              	 .loc 1 2749 0
 3297              	 .cfi_startproc
 3298              	 
 3299              	 
 3300              	 
 3301              	.LVL358:
2750:../FreeRTOS/Source/queue.c ****         UBaseType_t ux;
2751:../FreeRTOS/Source/queue.c ****         const char * pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings a
2752:../FreeRTOS/Source/queue.c **** 
2753:../FreeRTOS/Source/queue.c ****         /* Note there is nothing here to protect against another task adding or
2754:../FreeRTOS/Source/queue.c ****          * removing entries from the registry while it is being searched. */
2755:../FreeRTOS/Source/queue.c **** 
2756:../FreeRTOS/Source/queue.c ****         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
2757:../FreeRTOS/Source/queue.c ****         {
2758:../FreeRTOS/Source/queue.c ****             if( xQueueRegistry[ ux ].xHandle == xQueue )
 3302              	 .loc 1 2758 0
 3303 0000 0A4B     	 ldr r3,.L271
 3304 0002 5B68     	 ldr r3,[r3,#4]
 3305 0004 8342     	 cmp r3,r0
 3306 0006 05D0     	 beq .L269
 3307 0008 084A     	 ldr r2,.L271
2756:../FreeRTOS/Source/queue.c ****         {
 3308              	 .loc 1 2756 0
 3309 000a 0123     	 movs r3,#1
 3310              	.LVL359:
 3311              	.L268:
 3312              	 .loc 1 2758 0
 3313 000c D168     	 ldr r1,[r2,#12]
 3314 000e 8142     	 cmp r1,r0
 3315 0010 05D1     	 bne .L266
 3316 0012 00E0     	 b .L265
 3317              	.LVL360:
 3318              	.L269:
2756:../FreeRTOS/Source/queue.c ****         {
 3319              	 .loc 1 2756 0
 3320 0014 0023     	 movs r3,#0
 3321              	.LVL361:
 3322              	.L265:
2759:../FreeRTOS/Source/queue.c ****             {
2760:../FreeRTOS/Source/queue.c ****                 pcReturn = xQueueRegistry[ ux ].pcQueueName;
 3323              	 .loc 1 2760 0
 3324 0016 054A     	 ldr r2,.L271
 3325 0018 52F83300 	 ldr r0,[r2,r3,lsl#3]
 3326              	.LVL362:
2761:../FreeRTOS/Source/queue.c ****                 break;
 3327              	 .loc 1 2761 0
 3328 001c 7047     	 bx lr
 3329              	.LVL363:
 3330              	.L266:
2756:../FreeRTOS/Source/queue.c ****         {
 3331              	 .loc 1 2756 0 discriminator 2
 3332 001e 0133     	 adds r3,r3,#1
 3333              	.LVL364:
 3334 0020 0832     	 adds r2,r2,#8
 3335 0022 082B     	 cmp r3,#8
 3336 0024 F2D1     	 bne .L268
2751:../FreeRTOS/Source/queue.c **** 
 3337              	 .loc 1 2751 0
 3338 0026 0020     	 movs r0,#0
 3339              	.LVL365:
2762:../FreeRTOS/Source/queue.c ****             }
2763:../FreeRTOS/Source/queue.c ****             else
2764:../FreeRTOS/Source/queue.c ****             {
2765:../FreeRTOS/Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2766:../FreeRTOS/Source/queue.c ****             }
2767:../FreeRTOS/Source/queue.c ****         }
2768:../FreeRTOS/Source/queue.c **** 
2769:../FreeRTOS/Source/queue.c ****         return pcReturn;
2770:../FreeRTOS/Source/queue.c ****     } /*lint !e818 xQueue cannot be a pointer to const because it is a typedef. */
 3340              	 .loc 1 2770 0
 3341 0028 7047     	 bx lr
 3342              	.L272:
 3343 002a 00BF     	 .align 2
 3344              	.L271:
 3345 002c 00000000 	 .word xQueueRegistry
 3346              	 .cfi_endproc
 3347              	.LFE37:
 3349              	 .section .text.vQueueUnregisterQueue,"ax",%progbits
 3350              	 .align 2
 3351              	 .global vQueueUnregisterQueue
 3352              	 .thumb
 3353              	 .thumb_func
 3355              	vQueueUnregisterQueue:
 3356              	.LFB38:
2771:../FreeRTOS/Source/queue.c **** 
2772:../FreeRTOS/Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2773:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2774:../FreeRTOS/Source/queue.c **** 
2775:../FreeRTOS/Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2776:../FreeRTOS/Source/queue.c **** 
2777:../FreeRTOS/Source/queue.c ****     void vQueueUnregisterQueue( QueueHandle_t xQueue )
2778:../FreeRTOS/Source/queue.c ****     {
 3357              	 .loc 1 2778 0
 3358              	 .cfi_startproc
 3359              	 
 3360              	 
 3361              	 
 3362              	.LVL366:
2779:../FreeRTOS/Source/queue.c ****         UBaseType_t ux;
2780:../FreeRTOS/Source/queue.c **** 
2781:../FreeRTOS/Source/queue.c ****         /* See if the handle of the queue being unregistered in actually in the
2782:../FreeRTOS/Source/queue.c ****          * registry. */
2783:../FreeRTOS/Source/queue.c ****         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
2784:../FreeRTOS/Source/queue.c ****         {
2785:../FreeRTOS/Source/queue.c ****             if( xQueueRegistry[ ux ].xHandle == xQueue )
 3363              	 .loc 1 2785 0
 3364 0000 0B4B     	 ldr r3,.L280
 3365 0002 5B68     	 ldr r3,[r3,#4]
 3366 0004 8342     	 cmp r3,r0
 3367 0006 05D0     	 beq .L278
 3368 0008 094A     	 ldr r2,.L280
2783:../FreeRTOS/Source/queue.c ****         {
 3369              	 .loc 1 2783 0
 3370 000a 0123     	 movs r3,#1
 3371              	.LVL367:
 3372              	.L277:
 3373              	 .loc 1 2785 0
 3374 000c D168     	 ldr r1,[r2,#12]
 3375 000e 8142     	 cmp r1,r0
 3376 0010 09D1     	 bne .L275
 3377 0012 00E0     	 b .L274
 3378              	.LVL368:
 3379              	.L278:
2783:../FreeRTOS/Source/queue.c ****         {
 3380              	 .loc 1 2783 0
 3381 0014 0023     	 movs r3,#0
 3382              	.LVL369:
 3383              	.L274:
2786:../FreeRTOS/Source/queue.c ****             {
2787:../FreeRTOS/Source/queue.c ****                 /* Set the name to NULL to show that this slot if free again. */
2788:../FreeRTOS/Source/queue.c ****                 xQueueRegistry[ ux ].pcQueueName = NULL;
 3384              	 .loc 1 2788 0
 3385 0016 064A     	 ldr r2,.L280
 3386 0018 0021     	 movs r1,#0
 3387 001a 42F83310 	 str r1,[r2,r3,lsl#3]
2789:../FreeRTOS/Source/queue.c **** 
2790:../FreeRTOS/Source/queue.c ****                 /* Set the handle to NULL to ensure the same queue handle cannot
2791:../FreeRTOS/Source/queue.c ****                  * appear in the registry twice if it is added, removed, then
2792:../FreeRTOS/Source/queue.c ****                  * added again. */
2793:../FreeRTOS/Source/queue.c ****                 xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
 3388              	 .loc 1 2793 0
 3389 001e 02EBC303 	 add r3,r2,r3,lsl#3
 3390 0022 5960     	 str r1,[r3,#4]
2794:../FreeRTOS/Source/queue.c ****                 break;
 3391              	 .loc 1 2794 0
 3392 0024 7047     	 bx lr
 3393              	.LVL370:
 3394              	.L275:
2783:../FreeRTOS/Source/queue.c ****         {
 3395              	 .loc 1 2783 0 discriminator 2
 3396 0026 0133     	 adds r3,r3,#1
 3397              	.LVL371:
 3398 0028 0832     	 adds r2,r2,#8
 3399 002a 082B     	 cmp r3,#8
 3400 002c EED1     	 bne .L277
 3401 002e 7047     	 bx lr
 3402              	.L281:
 3403              	 .align 2
 3404              	.L280:
 3405 0030 00000000 	 .word xQueueRegistry
 3406              	 .cfi_endproc
 3407              	.LFE38:
 3409              	 .section .text.vQueueDelete,"ax",%progbits
 3410              	 .align 2
 3411              	 .global vQueueDelete
 3412              	 .thumb
 3413              	 .thumb_func
 3415              	vQueueDelete:
 3416              	.LFB24:
2024:../FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 3417              	 .loc 1 2024 0
 3418              	 .cfi_startproc
 3419              	 
 3420              	 
 3421              	.LVL372:
2027:../FreeRTOS/Source/queue.c ****     traceQUEUE_DELETE( pxQueue );
 3422              	 .loc 1 2027 0
 3423 0000 40B9     	 cbnz r0,.L283
 3424              	.LBB262:
 3425              	.LBB263:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 3426              	 .loc 2 197 0
 3427              	
 3428 0002 4FF01403 	 mov r3,#20
 3429 0006 83F31188 	 msr basepri,r3
 3430 000a BFF36F8F 	 isb 
 3431 000e BFF34F8F 	 dsb 
 3432              	
 3433              	
 3434              	.LVL373:
 3435              	 .thumb
 3436              	.L284:
 3437              	.LBE263:
 3438              	.LBE262:
2027:../FreeRTOS/Source/queue.c ****     traceQUEUE_DELETE( pxQueue );
 3439              	 .loc 1 2027 0 discriminator 1
 3440 0012 FEE7     	 b .L284
 3441              	.L283:
2024:../FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 3442              	 .loc 1 2024 0
 3443 0014 10B5     	 push {r4,lr}
 3444              	.LCFI31:
 3445              	 .cfi_def_cfa_offset 8
 3446              	 .cfi_offset 4,-8
 3447              	 .cfi_offset 14,-4
 3448 0016 0446     	 mov r4,r0
2032:../FreeRTOS/Source/queue.c ****         }
 3449              	 .loc 1 2032 0
 3450 0018 FFF7FEFF 	 bl vQueueUnregisterQueue
 3451              	.LVL374:
2040:../FreeRTOS/Source/queue.c ****         }
 3452              	 .loc 1 2040 0
 3453 001c 2046     	 mov r0,r4
 3454 001e FFF7FEFF 	 bl vPortFree
 3455              	.LVL375:
 3456 0022 10BD     	 pop {r4,pc}
 3457              	 .cfi_endproc
 3458              	.LFE24:
 3460              	 .section .text.vQueueWaitForMessageRestricted,"ax",%progbits
 3461              	 .align 2
 3462              	 .global vQueueWaitForMessageRestricted
 3463              	 .thumb
 3464              	 .thumb_func
 3466              	vQueueWaitForMessageRestricted:
 3467              	.LFB39:
2795:../FreeRTOS/Source/queue.c ****             }
2796:../FreeRTOS/Source/queue.c ****             else
2797:../FreeRTOS/Source/queue.c ****             {
2798:../FreeRTOS/Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2799:../FreeRTOS/Source/queue.c ****             }
2800:../FreeRTOS/Source/queue.c ****         }
2801:../FreeRTOS/Source/queue.c ****     } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
2802:../FreeRTOS/Source/queue.c **** 
2803:../FreeRTOS/Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2804:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2805:../FreeRTOS/Source/queue.c **** 
2806:../FreeRTOS/Source/queue.c **** #if ( configUSE_TIMERS == 1 )
2807:../FreeRTOS/Source/queue.c **** 
2808:../FreeRTOS/Source/queue.c ****     void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
2809:../FreeRTOS/Source/queue.c ****                                          TickType_t xTicksToWait,
2810:../FreeRTOS/Source/queue.c ****                                          const BaseType_t xWaitIndefinitely )
2811:../FreeRTOS/Source/queue.c ****     {
 3468              	 .loc 1 2811 0
 3469              	 .cfi_startproc
 3470              	 
 3471              	 
 3472              	.LVL376:
 3473 0000 70B5     	 push {r4,r5,r6,lr}
 3474              	.LCFI32:
 3475              	 .cfi_def_cfa_offset 16
 3476              	 .cfi_offset 4,-16
 3477              	 .cfi_offset 5,-12
 3478              	 .cfi_offset 6,-8
 3479              	 .cfi_offset 14,-4
 3480 0002 0446     	 mov r4,r0
 3481 0004 0E46     	 mov r6,r1
 3482 0006 1546     	 mov r5,r2
 3483              	.LVL377:
2812:../FreeRTOS/Source/queue.c ****         Queue_t * const pxQueue = xQueue;
2813:../FreeRTOS/Source/queue.c **** 
2814:../FreeRTOS/Source/queue.c ****         /* This function should not be called by application code hence the
2815:../FreeRTOS/Source/queue.c ****          * 'Restricted' in its name.  It is not part of the public API.  It is
2816:../FreeRTOS/Source/queue.c ****          * designed for use by kernel code, and has special calling requirements.
2817:../FreeRTOS/Source/queue.c ****          * It can result in vListInsert() being called on a list that can only
2818:../FreeRTOS/Source/queue.c ****          * possibly ever have one item in it, so the list will be fast, but even
2819:../FreeRTOS/Source/queue.c ****          * so it should be called with the scheduler locked and not from a critical
2820:../FreeRTOS/Source/queue.c ****          * section. */
2821:../FreeRTOS/Source/queue.c **** 
2822:../FreeRTOS/Source/queue.c ****         /* Only do anything if there are no messages in the queue.  This function
2823:../FreeRTOS/Source/queue.c ****          *  will not actually cause the task to block, just place it on a blocked
2824:../FreeRTOS/Source/queue.c ****          *  list.  It will not block until the scheduler is unlocked - at which
2825:../FreeRTOS/Source/queue.c ****          *  time a yield will be performed.  If an item is added to the queue while
2826:../FreeRTOS/Source/queue.c ****          *  the queue is locked, and the calling task blocks on the queue, then the
2827:../FreeRTOS/Source/queue.c ****          *  calling task will be immediately unblocked when the queue is unlocked. */
2828:../FreeRTOS/Source/queue.c ****         prvLockQueue( pxQueue );
 3484              	 .loc 1 2828 0
 3485 0008 FFF7FEFF 	 bl vPortEnterCritical
 3486              	.LVL378:
 3487 000c 94F84430 	 ldrb r3,[r4,#68]
 3488 0010 5BB2     	 sxtb r3,r3
 3489 0012 B3F1FF3F 	 cmp r3,#-1
 3490 0016 04BF     	 itt eq
 3491 0018 0023     	 moveq r3,#0
 3492 001a 84F84430 	 strbeq r3,[r4,#68]
 3493 001e 94F84530 	 ldrb r3,[r4,#69]
 3494 0022 5BB2     	 sxtb r3,r3
 3495 0024 B3F1FF3F 	 cmp r3,#-1
 3496 0028 04BF     	 itt eq
 3497 002a 0023     	 moveq r3,#0
 3498 002c 84F84530 	 strbeq r3,[r4,#69]
 3499 0030 FFF7FEFF 	 bl vPortExitCritical
 3500              	.LVL379:
2829:../FreeRTOS/Source/queue.c **** 
2830:../FreeRTOS/Source/queue.c ****         if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 3501              	 .loc 1 2830 0
 3502 0034 A36B     	 ldr r3,[r4,#56]
 3503 0036 2BB9     	 cbnz r3,.L289
2831:../FreeRTOS/Source/queue.c ****         {
2832:../FreeRTOS/Source/queue.c ****             /* There is nothing in the queue, block for the specified period. */
2833:../FreeRTOS/Source/queue.c ****             vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xW
 3504              	 .loc 1 2833 0
 3505 0038 04F12400 	 add r0,r4,#36
 3506 003c 3146     	 mov r1,r6
 3507 003e 2A46     	 mov r2,r5
 3508 0040 FFF7FEFF 	 bl vTaskPlaceOnEventListRestricted
 3509              	.LVL380:
 3510              	.L289:
2834:../FreeRTOS/Source/queue.c ****         }
2835:../FreeRTOS/Source/queue.c ****         else
2836:../FreeRTOS/Source/queue.c ****         {
2837:../FreeRTOS/Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
2838:../FreeRTOS/Source/queue.c ****         }
2839:../FreeRTOS/Source/queue.c **** 
2840:../FreeRTOS/Source/queue.c ****         prvUnlockQueue( pxQueue );
 3511              	 .loc 1 2840 0
 3512 0044 2046     	 mov r0,r4
 3513 0046 FFF7FEFF 	 bl prvUnlockQueue
 3514              	.LVL381:
 3515 004a 70BD     	 pop {r4,r5,r6,pc}
 3516              	 .cfi_endproc
 3517              	.LFE39:
 3519              	 .comm xQueueRegistry,64,4
 3520              	 .text
 3521              	.Letext0:
 3522              	 .file 3 "e:\\embedded\\dave_4-4-2_64bit_2018-02-23\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\lib\\gcc\\arm-none-eabi\\4.9.3\\include\\stddef.h"
 3523              	 .file 4 "e:\\embedded\\dave_4-4-2_64bit_2018-02-23\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 3524              	 .file 5 "e:\\embedded\\dave_4-4-2_64bit_2018-02-23\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 3525              	 .file 6 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/include/list.h"
 3526              	 .file 7 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/include/task.h"
 3527              	 .file 8 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/include/queue.h"
 3528              	 .file 9 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/include/portable.h"
DEFINED SYMBOLS
                            *ABS*:00000000 queue.c
    {standard input}:19     .text.prvIsQueueEmpty:00000000 $t
    {standard input}:23     .text.prvIsQueueEmpty:00000000 prvIsQueueEmpty
    {standard input}:54     .text.prvCopyDataToQueue:00000000 $t
    {standard input}:58     .text.prvCopyDataToQueue:00000000 prvCopyDataToQueue
    {standard input}:177    .text.prvCopyDataFromQueue:00000000 $t
    {standard input}:181    .text.prvCopyDataFromQueue:00000000 prvCopyDataFromQueue
    {standard input}:228    .text.prvUnlockQueue:00000000 $t
    {standard input}:232    .text.prvUnlockQueue:00000000 prvUnlockQueue
    {standard input}:352    .text.xQueueGenericReset:00000000 $t
    {standard input}:357    .text.xQueueGenericReset:00000000 xQueueGenericReset
    {standard input}:461    .text.xQueueGenericReset:0000007c $d
    {standard input}:466    .text.xQueueGenericCreate:00000000 $t
    {standard input}:471    .text.xQueueGenericCreate:00000000 xQueueGenericCreate
    {standard input}:604    .text.xQueueCreateCountingSemaphore:00000000 $t
    {standard input}:609    .text.xQueueCreateCountingSemaphore:00000000 xQueueCreateCountingSemaphore
    {standard input}:684    .text.xQueueGenericSend:00000000 $t
    {standard input}:689    .text.xQueueGenericSend:00000000 xQueueGenericSend
    {standard input}:1011   .text.xQueueGenericSend:00000184 $d
    {standard input}:1016   .text.xQueueCreateMutex:00000000 $t
    {standard input}:1021   .text.xQueueCreateMutex:00000000 xQueueCreateMutex
    {standard input}:1068   .text.xQueueGiveMutexRecursive:00000000 $t
    {standard input}:1073   .text.xQueueGiveMutexRecursive:00000000 xQueueGiveMutexRecursive
    {standard input}:1147   .text.xQueueGenericSendFromISR:00000000 $t
    {standard input}:1152   .text.xQueueGenericSendFromISR:00000000 xQueueGenericSendFromISR
    {standard input}:1370   .text.xQueueGiveFromISR:00000000 $t
    {standard input}:1375   .text.xQueueGiveFromISR:00000000 xQueueGiveFromISR
    {standard input}:1583   .text.xQueueReceive:00000000 $t
    {standard input}:1588   .text.xQueueReceive:00000000 xQueueReceive
    {standard input}:1857   .text.xQueueReceive:0000014c $d
    {standard input}:1862   .text.xQueueSemaphoreTake:00000000 $t
    {standard input}:1867   .text.xQueueSemaphoreTake:00000000 xQueueSemaphoreTake
    {standard input}:2211   .text.xQueueSemaphoreTake:00000198 $d
    {standard input}:2216   .text.xQueueTakeMutexRecursive:00000000 $t
    {standard input}:2221   .text.xQueueTakeMutexRecursive:00000000 xQueueTakeMutexRecursive
    {standard input}:2295   .text.xQueuePeek:00000000 $t
    {standard input}:2300   .text.xQueuePeek:00000000 xQueuePeek
    {standard input}:2570   .text.xQueuePeek:00000148 $d
    {standard input}:2575   .text.xQueueReceiveFromISR:00000000 $t
    {standard input}:2580   .text.xQueueReceiveFromISR:00000000 xQueueReceiveFromISR
    {standard input}:2767   .text.xQueuePeekFromISR:00000000 $t
    {standard input}:2772   .text.xQueuePeekFromISR:00000000 xQueuePeekFromISR
    {standard input}:2912   .text.uxQueueMessagesWaiting:00000000 $t
    {standard input}:2917   .text.uxQueueMessagesWaiting:00000000 uxQueueMessagesWaiting
    {standard input}:2967   .text.uxQueueSpacesAvailable:00000000 $t
    {standard input}:2972   .text.uxQueueSpacesAvailable:00000000 uxQueueSpacesAvailable
    {standard input}:3024   .text.uxQueueMessagesWaitingFromISR:00000000 $t
    {standard input}:3029   .text.uxQueueMessagesWaitingFromISR:00000000 uxQueueMessagesWaitingFromISR
    {standard input}:3066   .text.uxQueueGetQueueNumber:00000000 $t
    {standard input}:3071   .text.uxQueueGetQueueNumber:00000000 uxQueueGetQueueNumber
    {standard input}:3087   .text.vQueueSetQueueNumber:00000000 $t
    {standard input}:3092   .text.vQueueSetQueueNumber:00000000 vQueueSetQueueNumber
    {standard input}:3107   .text.ucQueueGetQueueType:00000000 $t
    {standard input}:3112   .text.ucQueueGetQueueType:00000000 ucQueueGetQueueType
    {standard input}:3128   .text.xQueueIsQueueEmptyFromISR:00000000 $t
    {standard input}:3133   .text.xQueueIsQueueEmptyFromISR:00000000 xQueueIsQueueEmptyFromISR
    {standard input}:3173   .text.xQueueIsQueueFullFromISR:00000000 $t
    {standard input}:3178   .text.xQueueIsQueueFullFromISR:00000000 xQueueIsQueueFullFromISR
    {standard input}:3223   .text.vQueueAddToRegistry:00000000 $t
    {standard input}:3228   .text.vQueueAddToRegistry:00000000 vQueueAddToRegistry
    {standard input}:3284   .text.vQueueAddToRegistry:00000030 $d
                            *COM*:00000040 xQueueRegistry
    {standard input}:3289   .text.pcQueueGetName:00000000 $t
    {standard input}:3294   .text.pcQueueGetName:00000000 pcQueueGetName
    {standard input}:3345   .text.pcQueueGetName:0000002c $d
    {standard input}:3350   .text.vQueueUnregisterQueue:00000000 $t
    {standard input}:3355   .text.vQueueUnregisterQueue:00000000 vQueueUnregisterQueue
    {standard input}:3405   .text.vQueueUnregisterQueue:00000030 $d
    {standard input}:3410   .text.vQueueDelete:00000000 $t
    {standard input}:3415   .text.vQueueDelete:00000000 vQueueDelete
    {standard input}:3461   .text.vQueueWaitForMessageRestricted:00000000 $t
    {standard input}:3466   .text.vQueueWaitForMessageRestricted:00000000 vQueueWaitForMessageRestricted
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.0.3466fc6a3db32493c997d085de4c7a28
                           .group:00000000 wm4.newlib.h.8.fe7d912fc917043c98742c35eddd8cff
                           .group:00000000 wm4.features.h.22.bee0aee4a3878f51861c775df98fa3ea
                           .group:00000000 wm4.config.h.216.aad1ef7bee4fb69981cb38ce62f84d9c
                           .group:00000000 wm4._ansi.h.23.9f8fcfa20193763fcf364fb91705c94b
                           .group:00000000 wm4.stdlib.h.13.4ed386f5c1a80d71e72172885d946ef2
                           .group:00000000 wm4.stddef.h.184.aa65fb7281d578229bbad41b91862635
                           .group:00000000 wm4.stddef.h.39.dc09cac7e3f758f23d559f6b28ebbb0d
                           .group:00000000 wm4._default_types.h.6.35ee9e747940367bf2a634907d1c2382
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4._types.h.54.d3d34a3b7f3cc230cd159baf022b4b08
                           .group:00000000 wm4.stddef.h.158.61317cdbfb4026324507d123a50b0fd6
                           .group:00000000 wm4.reent.h.17.8bd9e4098e0428508c282cad794fae43
                           .group:00000000 wm4.alloca.h.8.dfc0c703c47ec3e69746825b17d9e66d
                           .group:00000000 wm4.stdlib.h.53.fe81d5186f74ee22c982a1a79f340ee8
                           .group:00000000 wm4.cdefs.h.47.4002528de975c0fcce6c551c15d87b8c
                           .group:00000000 wm4.string.h.15.dab3980bf35408a4c507182805e2de3a
                           .group:00000000 wm4.stddef.h.158.a7efb00f6cbc6f43213b50e183c9830c
                           .group:00000000 wm4._intsup.h.10.ca9f32a61b410c270a48d1161ca2c217
                           .group:00000000 wm4.stdint.h.22.f4a337c398d8b6d821a97202448bc0d0
                           .group:00000000 wm4.FreeRTOSConfig.h.30.aa43eb1cb33228d5c7e359a94d48589b
                           .group:00000000 wm4.projdefs.h.28.d6a7c9061b707820f2fcf4c2ff5d9f24
                           .group:00000000 wm4.portmacro.h.30.2ddc2eaf2e032c76c597fb78c4365041
                           .group:00000000 wm4.portable.h.63.e9cc508c3850f44ce542149380c67812
                           .group:00000000 wm4.mpu_wrappers.h.28.163fb40577cf8d1578015ea3f2ff4cdb
                           .group:00000000 wm4.FreeRTOS.h.67.9945f39eea4ddeb224c0782392206292
                           .group:00000000 wm4.list.h.57.02ec67e07eacffe5ca7cfb7326896236
                           .group:00000000 wm4.task.h.47.2d3fe49a094b8ec1e3e6aac441e8db21
                           .group:00000000 wm4.queue.h.66.45d4a3cf5de24cde7e732f8dad25383c

UNDEFINED SYMBOLS
vPortEnterCritical
vPortExitCritical
xTaskPriorityDisinherit
memcpy
xTaskRemoveFromEventList
vTaskMissedYield
vListInitialise
pvPortMalloc
xTaskGetSchedulerState
vTaskInternalSetTimeOutState
vTaskSuspendAll
xTaskCheckForTimeOut
vTaskPlaceOnEventList
xTaskResumeAll
xTaskGetCurrentTaskHandle
vPortValidateInterruptPriority
pvTaskIncrementMutexHeldCount
xTaskPriorityInherit
vTaskPriorityDisinheritAfterTimeout
vPortFree
vTaskPlaceOnEventListRestricted
