   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .eabi_attribute 28,1
   5              	 .fpu fpv4-sp-d16
   6              	 .eabi_attribute 23,1
   7              	 .eabi_attribute 24,1
   8              	 .eabi_attribute 25,1
   9              	 .eabi_attribute 26,1
  10              	 .eabi_attribute 30,1
  11              	 .eabi_attribute 34,1
  12              	 .eabi_attribute 18,4
  13              	 .thumb
  14              	 .file "timers.c"
  15              	 .text
  16              	.Ltext0:
  17              	 .cfi_sections .debug_frame
  18              	 .section .text.prvInsertTimerInActiveList,"ax",%progbits
  19              	 .align 2
  20              	 .thumb
  21              	 .thumb_func
  23              	prvInsertTimerInActiveList:
  24              	.LFB20:
  25              	 .file 1 "../FreeRTOS/Source/timers.c"
   1:../FreeRTOS/Source/timers.c **** /*
   2:../FreeRTOS/Source/timers.c ****  * FreeRTOS Kernel V10.4.1
   3:../FreeRTOS/Source/timers.c ****  * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:../FreeRTOS/Source/timers.c ****  *
   5:../FreeRTOS/Source/timers.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:../FreeRTOS/Source/timers.c ****  * this software and associated documentation files (the "Software"), to deal in
   7:../FreeRTOS/Source/timers.c ****  * the Software without restriction, including without limitation the rights to
   8:../FreeRTOS/Source/timers.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:../FreeRTOS/Source/timers.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:../FreeRTOS/Source/timers.c ****  * subject to the following conditions:
  11:../FreeRTOS/Source/timers.c ****  *
  12:../FreeRTOS/Source/timers.c ****  * The above copyright notice and this permission notice shall be included in all
  13:../FreeRTOS/Source/timers.c ****  * copies or substantial portions of the Software.
  14:../FreeRTOS/Source/timers.c ****  *
  15:../FreeRTOS/Source/timers.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:../FreeRTOS/Source/timers.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:../FreeRTOS/Source/timers.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:../FreeRTOS/Source/timers.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:../FreeRTOS/Source/timers.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:../FreeRTOS/Source/timers.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:../FreeRTOS/Source/timers.c ****  *
  22:../FreeRTOS/Source/timers.c ****  * https://www.FreeRTOS.org
  23:../FreeRTOS/Source/timers.c ****  * https://github.com/FreeRTOS
  24:../FreeRTOS/Source/timers.c ****  *
  25:../FreeRTOS/Source/timers.c ****  */
  26:../FreeRTOS/Source/timers.c **** 
  27:../FreeRTOS/Source/timers.c **** /* Standard includes. */
  28:../FreeRTOS/Source/timers.c **** #include <stdlib.h>
  29:../FreeRTOS/Source/timers.c **** 
  30:../FreeRTOS/Source/timers.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  31:../FreeRTOS/Source/timers.c ****  * all the API functions to use the MPU wrappers.  That should only be done when
  32:../FreeRTOS/Source/timers.c ****  * task.h is included from an application file. */
  33:../FreeRTOS/Source/timers.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  34:../FreeRTOS/Source/timers.c **** 
  35:../FreeRTOS/Source/timers.c **** #include "FreeRTOS.h"
  36:../FreeRTOS/Source/timers.c **** #include "task.h"
  37:../FreeRTOS/Source/timers.c **** #include "queue.h"
  38:../FreeRTOS/Source/timers.c **** #include "timers.h"
  39:../FreeRTOS/Source/timers.c **** 
  40:../FreeRTOS/Source/timers.c **** #if ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 0 )
  41:../FreeRTOS/Source/timers.c ****     #error configUSE_TIMERS must be set to 1 to make the xTimerPendFunctionCall() function availabl
  42:../FreeRTOS/Source/timers.c **** #endif
  43:../FreeRTOS/Source/timers.c **** 
  44:../FreeRTOS/Source/timers.c **** /* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
  45:../FreeRTOS/Source/timers.c ****  * because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
  46:../FreeRTOS/Source/timers.c ****  * for the header files above, but not in this file, in order to generate the
  47:../FreeRTOS/Source/timers.c ****  * correct privileged Vs unprivileged linkage and placement. */
  48:../FreeRTOS/Source/timers.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e9021 !e961 !e750. */
  49:../FreeRTOS/Source/timers.c **** 
  50:../FreeRTOS/Source/timers.c **** 
  51:../FreeRTOS/Source/timers.c **** /* This entire source file will be skipped if the application is not configured
  52:../FreeRTOS/Source/timers.c ****  * to include software timer functionality.  This #if is closed at the very bottom
  53:../FreeRTOS/Source/timers.c ****  * of this file.  If you want to include software timer functionality then ensure
  54:../FreeRTOS/Source/timers.c ****  * configUSE_TIMERS is set to 1 in FreeRTOSConfig.h. */
  55:../FreeRTOS/Source/timers.c **** #if ( configUSE_TIMERS == 1 )
  56:../FreeRTOS/Source/timers.c **** 
  57:../FreeRTOS/Source/timers.c **** /* Misc definitions. */
  58:../FreeRTOS/Source/timers.c ****     #define tmrNO_DELAY    ( TickType_t ) 0U
  59:../FreeRTOS/Source/timers.c **** 
  60:../FreeRTOS/Source/timers.c **** /* The name assigned to the timer service task.  This can be overridden by
  61:../FreeRTOS/Source/timers.c ****  * defining trmTIMER_SERVICE_TASK_NAME in FreeRTOSConfig.h. */
  62:../FreeRTOS/Source/timers.c ****     #ifndef configTIMER_SERVICE_TASK_NAME
  63:../FreeRTOS/Source/timers.c ****         #define configTIMER_SERVICE_TASK_NAME    "Tmr Svc"
  64:../FreeRTOS/Source/timers.c ****     #endif
  65:../FreeRTOS/Source/timers.c **** 
  66:../FreeRTOS/Source/timers.c **** /* Bit definitions used in the ucStatus member of a timer structure. */
  67:../FreeRTOS/Source/timers.c ****     #define tmrSTATUS_IS_ACTIVE                  ( ( uint8_t ) 0x01 )
  68:../FreeRTOS/Source/timers.c ****     #define tmrSTATUS_IS_STATICALLY_ALLOCATED    ( ( uint8_t ) 0x02 )
  69:../FreeRTOS/Source/timers.c ****     #define tmrSTATUS_IS_AUTORELOAD              ( ( uint8_t ) 0x04 )
  70:../FreeRTOS/Source/timers.c **** 
  71:../FreeRTOS/Source/timers.c **** /* The definition of the timers themselves. */
  72:../FreeRTOS/Source/timers.c ****     typedef struct tmrTimerControl                  /* The old naming convention is used to prevent
  73:../FreeRTOS/Source/timers.c ****     {
  74:../FreeRTOS/Source/timers.c ****         const char * pcTimerName;                   /*<< Text name.  This is not used by the kernel
  75:../FreeRTOS/Source/timers.c ****         ListItem_t xTimerListItem;                  /*<< Standard linked list item as used by all k
  76:../FreeRTOS/Source/timers.c ****         TickType_t xTimerPeriodInTicks;             /*<< How quickly and often the timer expires. *
  77:../FreeRTOS/Source/timers.c ****         void * pvTimerID;                           /*<< An ID to identify the timer.  This allows 
  78:../FreeRTOS/Source/timers.c ****         TimerCallbackFunction_t pxCallbackFunction; /*<< The function that will be called when the 
  79:../FreeRTOS/Source/timers.c ****         #if ( configUSE_TRACE_FACILITY == 1 )
  80:../FreeRTOS/Source/timers.c ****             UBaseType_t uxTimerNumber;              /*<< An ID assigned by trace tools such as Free
  81:../FreeRTOS/Source/timers.c ****         #endif
  82:../FreeRTOS/Source/timers.c ****         uint8_t ucStatus;                           /*<< Holds bits to say if the timer was statica
  83:../FreeRTOS/Source/timers.c ****     } xTIMER;
  84:../FreeRTOS/Source/timers.c **** 
  85:../FreeRTOS/Source/timers.c **** /* The old xTIMER name is maintained above then typedefed to the new Timer_t
  86:../FreeRTOS/Source/timers.c ****  * name below to enable the use of older kernel aware debuggers. */
  87:../FreeRTOS/Source/timers.c ****     typedef xTIMER Timer_t;
  88:../FreeRTOS/Source/timers.c **** 
  89:../FreeRTOS/Source/timers.c **** /* The definition of messages that can be sent and received on the timer queue.
  90:../FreeRTOS/Source/timers.c ****  * Two types of message can be queued - messages that manipulate a software timer,
  91:../FreeRTOS/Source/timers.c ****  * and messages that request the execution of a non-timer related callback.  The
  92:../FreeRTOS/Source/timers.c ****  * two message types are defined in two separate structures, xTimerParametersType
  93:../FreeRTOS/Source/timers.c ****  * and xCallbackParametersType respectively. */
  94:../FreeRTOS/Source/timers.c ****     typedef struct tmrTimerParameters
  95:../FreeRTOS/Source/timers.c ****     {
  96:../FreeRTOS/Source/timers.c ****         TickType_t xMessageValue; /*<< An optional value used by a subset of commands, for example,
  97:../FreeRTOS/Source/timers.c ****         Timer_t * pxTimer;        /*<< The timer to which the command will be applied. */
  98:../FreeRTOS/Source/timers.c ****     } TimerParameter_t;
  99:../FreeRTOS/Source/timers.c **** 
 100:../FreeRTOS/Source/timers.c **** 
 101:../FreeRTOS/Source/timers.c ****     typedef struct tmrCallbackParameters
 102:../FreeRTOS/Source/timers.c ****     {
 103:../FreeRTOS/Source/timers.c ****         PendedFunction_t pxCallbackFunction; /* << The callback function to execute. */
 104:../FreeRTOS/Source/timers.c ****         void * pvParameter1;                 /* << The value that will be used as the callback func
 105:../FreeRTOS/Source/timers.c ****         uint32_t ulParameter2;               /* << The value that will be used as the callback func
 106:../FreeRTOS/Source/timers.c ****     } CallbackParameters_t;
 107:../FreeRTOS/Source/timers.c **** 
 108:../FreeRTOS/Source/timers.c **** /* The structure that contains the two message types, along with an identifier
 109:../FreeRTOS/Source/timers.c ****  * that is used to determine which message type is valid. */
 110:../FreeRTOS/Source/timers.c ****     typedef struct tmrTimerQueueMessage
 111:../FreeRTOS/Source/timers.c ****     {
 112:../FreeRTOS/Source/timers.c ****         BaseType_t xMessageID; /*<< The command being sent to the timer service task. */
 113:../FreeRTOS/Source/timers.c ****         union
 114:../FreeRTOS/Source/timers.c ****         {
 115:../FreeRTOS/Source/timers.c ****             TimerParameter_t xTimerParameters;
 116:../FreeRTOS/Source/timers.c **** 
 117:../FreeRTOS/Source/timers.c ****             /* Don't include xCallbackParameters if it is not going to be used as
 118:../FreeRTOS/Source/timers.c ****              * it makes the structure (and therefore the timer queue) larger. */
 119:../FreeRTOS/Source/timers.c ****             #if ( INCLUDE_xTimerPendFunctionCall == 1 )
 120:../FreeRTOS/Source/timers.c ****                 CallbackParameters_t xCallbackParameters;
 121:../FreeRTOS/Source/timers.c ****             #endif /* INCLUDE_xTimerPendFunctionCall */
 122:../FreeRTOS/Source/timers.c ****         } u;
 123:../FreeRTOS/Source/timers.c ****     } DaemonTaskMessage_t;
 124:../FreeRTOS/Source/timers.c **** 
 125:../FreeRTOS/Source/timers.c **** /*lint -save -e956 A manual analysis and inspection has been used to determine
 126:../FreeRTOS/Source/timers.c ****  * which static variables must be declared volatile. */
 127:../FreeRTOS/Source/timers.c **** 
 128:../FreeRTOS/Source/timers.c **** /* The list in which active timers are stored.  Timers are referenced in expire
 129:../FreeRTOS/Source/timers.c ****  * time order, with the nearest expiry time at the front of the list.  Only the
 130:../FreeRTOS/Source/timers.c ****  * timer service task is allowed to access these lists.
 131:../FreeRTOS/Source/timers.c ****  * xActiveTimerList1 and xActiveTimerList2 could be at function scope but that
 132:../FreeRTOS/Source/timers.c ****  * breaks some kernel aware debuggers, and debuggers that reply on removing the
 133:../FreeRTOS/Source/timers.c ****  * static qualifier. */
 134:../FreeRTOS/Source/timers.c ****     PRIVILEGED_DATA static List_t xActiveTimerList1;
 135:../FreeRTOS/Source/timers.c ****     PRIVILEGED_DATA static List_t xActiveTimerList2;
 136:../FreeRTOS/Source/timers.c ****     PRIVILEGED_DATA static List_t * pxCurrentTimerList;
 137:../FreeRTOS/Source/timers.c ****     PRIVILEGED_DATA static List_t * pxOverflowTimerList;
 138:../FreeRTOS/Source/timers.c **** 
 139:../FreeRTOS/Source/timers.c **** /* A queue that is used to send commands to the timer service task. */
 140:../FreeRTOS/Source/timers.c ****     PRIVILEGED_DATA static QueueHandle_t xTimerQueue = NULL;
 141:../FreeRTOS/Source/timers.c ****     PRIVILEGED_DATA static TaskHandle_t xTimerTaskHandle = NULL;
 142:../FreeRTOS/Source/timers.c **** 
 143:../FreeRTOS/Source/timers.c **** /*lint -restore */
 144:../FreeRTOS/Source/timers.c **** 
 145:../FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 146:../FreeRTOS/Source/timers.c **** 
 147:../FreeRTOS/Source/timers.c **** /*
 148:../FreeRTOS/Source/timers.c ****  * Initialise the infrastructure used by the timer service task if it has not
 149:../FreeRTOS/Source/timers.c ****  * been initialised already.
 150:../FreeRTOS/Source/timers.c ****  */
 151:../FreeRTOS/Source/timers.c ****     static void prvCheckForValidListAndQueue( void ) PRIVILEGED_FUNCTION;
 152:../FreeRTOS/Source/timers.c **** 
 153:../FreeRTOS/Source/timers.c **** /*
 154:../FreeRTOS/Source/timers.c ****  * The timer service task (daemon).  Timer functionality is controlled by this
 155:../FreeRTOS/Source/timers.c ****  * task.  Other tasks communicate with the timer service task using the
 156:../FreeRTOS/Source/timers.c ****  * xTimerQueue queue.
 157:../FreeRTOS/Source/timers.c ****  */
 158:../FreeRTOS/Source/timers.c ****     static portTASK_FUNCTION_PROTO( prvTimerTask, pvParameters ) PRIVILEGED_FUNCTION;
 159:../FreeRTOS/Source/timers.c **** 
 160:../FreeRTOS/Source/timers.c **** /*
 161:../FreeRTOS/Source/timers.c ****  * Called by the timer service task to interpret and process a command it
 162:../FreeRTOS/Source/timers.c ****  * received on the timer queue.
 163:../FreeRTOS/Source/timers.c ****  */
 164:../FreeRTOS/Source/timers.c ****     static void prvProcessReceivedCommands( void ) PRIVILEGED_FUNCTION;
 165:../FreeRTOS/Source/timers.c **** 
 166:../FreeRTOS/Source/timers.c **** /*
 167:../FreeRTOS/Source/timers.c ****  * Insert the timer into either xActiveTimerList1, or xActiveTimerList2,
 168:../FreeRTOS/Source/timers.c ****  * depending on if the expire time causes a timer counter overflow.
 169:../FreeRTOS/Source/timers.c ****  */
 170:../FreeRTOS/Source/timers.c ****     static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer,
 171:../FreeRTOS/Source/timers.c ****                                                   const TickType_t xNextExpiryTime,
 172:../FreeRTOS/Source/timers.c ****                                                   const TickType_t xTimeNow,
 173:../FreeRTOS/Source/timers.c ****                                                   const TickType_t xCommandTime ) PRIVILEGED_FUNCTI
 174:../FreeRTOS/Source/timers.c **** 
 175:../FreeRTOS/Source/timers.c **** /*
 176:../FreeRTOS/Source/timers.c ****  * An active timer has reached its expire time.  Reload the timer if it is an
 177:../FreeRTOS/Source/timers.c ****  * auto-reload timer, then call its callback.
 178:../FreeRTOS/Source/timers.c ****  */
 179:../FreeRTOS/Source/timers.c ****     static void prvProcessExpiredTimer( const TickType_t xNextExpireTime,
 180:../FreeRTOS/Source/timers.c ****                                         const TickType_t xTimeNow ) PRIVILEGED_FUNCTION;
 181:../FreeRTOS/Source/timers.c **** 
 182:../FreeRTOS/Source/timers.c **** /*
 183:../FreeRTOS/Source/timers.c ****  * The tick count has overflowed.  Switch the timer lists after ensuring the
 184:../FreeRTOS/Source/timers.c ****  * current timer list does not still reference some timers.
 185:../FreeRTOS/Source/timers.c ****  */
 186:../FreeRTOS/Source/timers.c ****     static void prvSwitchTimerLists( void ) PRIVILEGED_FUNCTION;
 187:../FreeRTOS/Source/timers.c **** 
 188:../FreeRTOS/Source/timers.c **** /*
 189:../FreeRTOS/Source/timers.c ****  * Obtain the current tick count, setting *pxTimerListsWereSwitched to pdTRUE
 190:../FreeRTOS/Source/timers.c ****  * if a tick count overflow occurred since prvSampleTimeNow() was last called.
 191:../FreeRTOS/Source/timers.c ****  */
 192:../FreeRTOS/Source/timers.c ****     static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched ) PRIVILEGED_FU
 193:../FreeRTOS/Source/timers.c **** 
 194:../FreeRTOS/Source/timers.c **** /*
 195:../FreeRTOS/Source/timers.c ****  * If the timer list contains any active timers then return the expire time of
 196:../FreeRTOS/Source/timers.c ****  * the timer that will expire first and set *pxListWasEmpty to false.  If the
 197:../FreeRTOS/Source/timers.c ****  * timer list does not contain any timers then return 0 and set *pxListWasEmpty
 198:../FreeRTOS/Source/timers.c ****  * to pdTRUE.
 199:../FreeRTOS/Source/timers.c ****  */
 200:../FreeRTOS/Source/timers.c ****     static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty ) PRIVILEGED_FUNCTION
 201:../FreeRTOS/Source/timers.c **** 
 202:../FreeRTOS/Source/timers.c **** /*
 203:../FreeRTOS/Source/timers.c ****  * If a timer has expired, process it.  Otherwise, block the timer service task
 204:../FreeRTOS/Source/timers.c ****  * until either a timer does expire or a command is received.
 205:../FreeRTOS/Source/timers.c ****  */
 206:../FreeRTOS/Source/timers.c ****     static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime,
 207:../FreeRTOS/Source/timers.c ****                                             BaseType_t xListWasEmpty ) PRIVILEGED_FUNCTION;
 208:../FreeRTOS/Source/timers.c **** 
 209:../FreeRTOS/Source/timers.c **** /*
 210:../FreeRTOS/Source/timers.c ****  * Called after a Timer_t structure has been allocated either statically or
 211:../FreeRTOS/Source/timers.c ****  * dynamically to fill in the structure's members.
 212:../FreeRTOS/Source/timers.c ****  */
 213:../FreeRTOS/Source/timers.c ****     static void prvInitialiseNewTimer( const char * const pcTimerName, /*lint !e971 Unqualified cha
 214:../FreeRTOS/Source/timers.c ****                                        const TickType_t xTimerPeriodInTicks,
 215:../FreeRTOS/Source/timers.c ****                                        const UBaseType_t uxAutoReload,
 216:../FreeRTOS/Source/timers.c ****                                        void * const pvTimerID,
 217:../FreeRTOS/Source/timers.c ****                                        TimerCallbackFunction_t pxCallbackFunction,
 218:../FreeRTOS/Source/timers.c ****                                        Timer_t * pxNewTimer ) PRIVILEGED_FUNCTION;
 219:../FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 220:../FreeRTOS/Source/timers.c **** 
 221:../FreeRTOS/Source/timers.c ****     BaseType_t xTimerCreateTimerTask( void )
 222:../FreeRTOS/Source/timers.c ****     {
 223:../FreeRTOS/Source/timers.c ****         BaseType_t xReturn = pdFAIL;
 224:../FreeRTOS/Source/timers.c **** 
 225:../FreeRTOS/Source/timers.c ****         /* This function is called when the scheduler is started if
 226:../FreeRTOS/Source/timers.c ****          * configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
 227:../FreeRTOS/Source/timers.c ****          * timer service task has been created/initialised.  If timers have already
 228:../FreeRTOS/Source/timers.c ****          * been created then the initialisation will already have been performed. */
 229:../FreeRTOS/Source/timers.c ****         prvCheckForValidListAndQueue();
 230:../FreeRTOS/Source/timers.c **** 
 231:../FreeRTOS/Source/timers.c ****         if( xTimerQueue != NULL )
 232:../FreeRTOS/Source/timers.c ****         {
 233:../FreeRTOS/Source/timers.c ****             #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
 234:../FreeRTOS/Source/timers.c ****                 {
 235:../FreeRTOS/Source/timers.c ****                     StaticTask_t * pxTimerTaskTCBBuffer = NULL;
 236:../FreeRTOS/Source/timers.c ****                     StackType_t * pxTimerTaskStackBuffer = NULL;
 237:../FreeRTOS/Source/timers.c ****                     uint32_t ulTimerTaskStackSize;
 238:../FreeRTOS/Source/timers.c **** 
 239:../FreeRTOS/Source/timers.c ****                     vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer,
 240:../FreeRTOS/Source/timers.c ****                     xTimerTaskHandle = xTaskCreateStatic( prvTimerTask,
 241:../FreeRTOS/Source/timers.c ****                                                           configTIMER_SERVICE_TASK_NAME,
 242:../FreeRTOS/Source/timers.c ****                                                           ulTimerTaskStackSize,
 243:../FreeRTOS/Source/timers.c ****                                                           NULL,
 244:../FreeRTOS/Source/timers.c ****                                                           ( ( UBaseType_t ) configTIMER_TASK_PRIORI
 245:../FreeRTOS/Source/timers.c ****                                                           pxTimerTaskStackBuffer,
 246:../FreeRTOS/Source/timers.c ****                                                           pxTimerTaskTCBBuffer );
 247:../FreeRTOS/Source/timers.c **** 
 248:../FreeRTOS/Source/timers.c ****                     if( xTimerTaskHandle != NULL )
 249:../FreeRTOS/Source/timers.c ****                     {
 250:../FreeRTOS/Source/timers.c ****                         xReturn = pdPASS;
 251:../FreeRTOS/Source/timers.c ****                     }
 252:../FreeRTOS/Source/timers.c ****                 }
 253:../FreeRTOS/Source/timers.c ****             #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
 254:../FreeRTOS/Source/timers.c ****                 {
 255:../FreeRTOS/Source/timers.c ****                     xReturn = xTaskCreate( prvTimerTask,
 256:../FreeRTOS/Source/timers.c ****                                            configTIMER_SERVICE_TASK_NAME,
 257:../FreeRTOS/Source/timers.c ****                                            configTIMER_TASK_STACK_DEPTH,
 258:../FreeRTOS/Source/timers.c ****                                            NULL,
 259:../FreeRTOS/Source/timers.c ****                                            ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIV
 260:../FreeRTOS/Source/timers.c ****                                            &xTimerTaskHandle );
 261:../FreeRTOS/Source/timers.c ****                 }
 262:../FreeRTOS/Source/timers.c ****             #endif /* configSUPPORT_STATIC_ALLOCATION */
 263:../FreeRTOS/Source/timers.c ****         }
 264:../FreeRTOS/Source/timers.c ****         else
 265:../FreeRTOS/Source/timers.c ****         {
 266:../FreeRTOS/Source/timers.c ****             mtCOVERAGE_TEST_MARKER();
 267:../FreeRTOS/Source/timers.c ****         }
 268:../FreeRTOS/Source/timers.c **** 
 269:../FreeRTOS/Source/timers.c ****         configASSERT( xReturn );
 270:../FreeRTOS/Source/timers.c ****         return xReturn;
 271:../FreeRTOS/Source/timers.c ****     }
 272:../FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 273:../FreeRTOS/Source/timers.c **** 
 274:../FreeRTOS/Source/timers.c ****     #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 275:../FreeRTOS/Source/timers.c **** 
 276:../FreeRTOS/Source/timers.c ****         TimerHandle_t xTimerCreate( const char * const pcTimerName, /*lint !e971 Unqualified char t
 277:../FreeRTOS/Source/timers.c ****                                     const TickType_t xTimerPeriodInTicks,
 278:../FreeRTOS/Source/timers.c ****                                     const UBaseType_t uxAutoReload,
 279:../FreeRTOS/Source/timers.c ****                                     void * const pvTimerID,
 280:../FreeRTOS/Source/timers.c ****                                     TimerCallbackFunction_t pxCallbackFunction )
 281:../FreeRTOS/Source/timers.c ****         {
 282:../FreeRTOS/Source/timers.c ****             Timer_t * pxNewTimer;
 283:../FreeRTOS/Source/timers.c **** 
 284:../FreeRTOS/Source/timers.c ****             pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All 
 285:../FreeRTOS/Source/timers.c **** 
 286:../FreeRTOS/Source/timers.c ****             if( pxNewTimer != NULL )
 287:../FreeRTOS/Source/timers.c ****             {
 288:../FreeRTOS/Source/timers.c ****                 /* Status is thus far zero as the timer is not created statically
 289:../FreeRTOS/Source/timers.c ****                  * and has not been started.  The auto-reload bit may get set in
 290:../FreeRTOS/Source/timers.c ****                  * prvInitialiseNewTimer. */
 291:../FreeRTOS/Source/timers.c ****                 pxNewTimer->ucStatus = 0x00;
 292:../FreeRTOS/Source/timers.c ****                 prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, p
 293:../FreeRTOS/Source/timers.c ****             }
 294:../FreeRTOS/Source/timers.c **** 
 295:../FreeRTOS/Source/timers.c ****             return pxNewTimer;
 296:../FreeRTOS/Source/timers.c ****         }
 297:../FreeRTOS/Source/timers.c **** 
 298:../FreeRTOS/Source/timers.c ****     #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 299:../FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 300:../FreeRTOS/Source/timers.c **** 
 301:../FreeRTOS/Source/timers.c ****     #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
 302:../FreeRTOS/Source/timers.c **** 
 303:../FreeRTOS/Source/timers.c ****         TimerHandle_t xTimerCreateStatic( const char * const pcTimerName, /*lint !e971 Unqualified 
 304:../FreeRTOS/Source/timers.c ****                                           const TickType_t xTimerPeriodInTicks,
 305:../FreeRTOS/Source/timers.c ****                                           const UBaseType_t uxAutoReload,
 306:../FreeRTOS/Source/timers.c ****                                           void * const pvTimerID,
 307:../FreeRTOS/Source/timers.c ****                                           TimerCallbackFunction_t pxCallbackFunction,
 308:../FreeRTOS/Source/timers.c ****                                           StaticTimer_t * pxTimerBuffer )
 309:../FreeRTOS/Source/timers.c ****         {
 310:../FreeRTOS/Source/timers.c ****             Timer_t * pxNewTimer;
 311:../FreeRTOS/Source/timers.c **** 
 312:../FreeRTOS/Source/timers.c ****             #if ( configASSERT_DEFINED == 1 )
 313:../FreeRTOS/Source/timers.c ****                 {
 314:../FreeRTOS/Source/timers.c ****                     /* Sanity check that the size of the structure used to declare a
 315:../FreeRTOS/Source/timers.c ****                      * variable of type StaticTimer_t equals the size of the real timer
 316:../FreeRTOS/Source/timers.c ****                      * structure. */
 317:../FreeRTOS/Source/timers.c ****                     volatile size_t xSize = sizeof( StaticTimer_t );
 318:../FreeRTOS/Source/timers.c ****                     configASSERT( xSize == sizeof( Timer_t ) );
 319:../FreeRTOS/Source/timers.c ****                     ( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
 320:../FreeRTOS/Source/timers.c ****                 }
 321:../FreeRTOS/Source/timers.c ****             #endif /* configASSERT_DEFINED */
 322:../FreeRTOS/Source/timers.c **** 
 323:../FreeRTOS/Source/timers.c ****             /* A pointer to a StaticTimer_t structure MUST be provided, use it. */
 324:../FreeRTOS/Source/timers.c ****             configASSERT( pxTimerBuffer );
 325:../FreeRTOS/Source/timers.c ****             pxNewTimer = ( Timer_t * ) pxTimerBuffer; /*lint !e740 !e9087 StaticTimer_t is a pointe
 326:../FreeRTOS/Source/timers.c **** 
 327:../FreeRTOS/Source/timers.c ****             if( pxNewTimer != NULL )
 328:../FreeRTOS/Source/timers.c ****             {
 329:../FreeRTOS/Source/timers.c ****                 /* Timers can be created statically or dynamically so note this
 330:../FreeRTOS/Source/timers.c ****                  * timer was created statically in case it is later deleted.  The
 331:../FreeRTOS/Source/timers.c ****                  * auto-reload bit may get set in prvInitialiseNewTimer(). */
 332:../FreeRTOS/Source/timers.c ****                 pxNewTimer->ucStatus = tmrSTATUS_IS_STATICALLY_ALLOCATED;
 333:../FreeRTOS/Source/timers.c **** 
 334:../FreeRTOS/Source/timers.c ****                 prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, p
 335:../FreeRTOS/Source/timers.c ****             }
 336:../FreeRTOS/Source/timers.c **** 
 337:../FreeRTOS/Source/timers.c ****             return pxNewTimer;
 338:../FreeRTOS/Source/timers.c ****         }
 339:../FreeRTOS/Source/timers.c **** 
 340:../FreeRTOS/Source/timers.c ****     #endif /* configSUPPORT_STATIC_ALLOCATION */
 341:../FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 342:../FreeRTOS/Source/timers.c **** 
 343:../FreeRTOS/Source/timers.c ****     static void prvInitialiseNewTimer( const char * const pcTimerName, /*lint !e971 Unqualified cha
 344:../FreeRTOS/Source/timers.c ****                                        const TickType_t xTimerPeriodInTicks,
 345:../FreeRTOS/Source/timers.c ****                                        const UBaseType_t uxAutoReload,
 346:../FreeRTOS/Source/timers.c ****                                        void * const pvTimerID,
 347:../FreeRTOS/Source/timers.c ****                                        TimerCallbackFunction_t pxCallbackFunction,
 348:../FreeRTOS/Source/timers.c ****                                        Timer_t * pxNewTimer )
 349:../FreeRTOS/Source/timers.c ****     {
 350:../FreeRTOS/Source/timers.c ****         /* 0 is not a valid value for xTimerPeriodInTicks. */
 351:../FreeRTOS/Source/timers.c ****         configASSERT( ( xTimerPeriodInTicks > 0 ) );
 352:../FreeRTOS/Source/timers.c **** 
 353:../FreeRTOS/Source/timers.c ****         if( pxNewTimer != NULL )
 354:../FreeRTOS/Source/timers.c ****         {
 355:../FreeRTOS/Source/timers.c ****             /* Ensure the infrastructure used by the timer service task has been
 356:../FreeRTOS/Source/timers.c ****              * created/initialised. */
 357:../FreeRTOS/Source/timers.c ****             prvCheckForValidListAndQueue();
 358:../FreeRTOS/Source/timers.c **** 
 359:../FreeRTOS/Source/timers.c ****             /* Initialise the timer structure members using the function
 360:../FreeRTOS/Source/timers.c ****              * parameters. */
 361:../FreeRTOS/Source/timers.c ****             pxNewTimer->pcTimerName = pcTimerName;
 362:../FreeRTOS/Source/timers.c ****             pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
 363:../FreeRTOS/Source/timers.c ****             pxNewTimer->pvTimerID = pvTimerID;
 364:../FreeRTOS/Source/timers.c ****             pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 365:../FreeRTOS/Source/timers.c ****             vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 366:../FreeRTOS/Source/timers.c **** 
 367:../FreeRTOS/Source/timers.c ****             if( uxAutoReload != pdFALSE )
 368:../FreeRTOS/Source/timers.c ****             {
 369:../FreeRTOS/Source/timers.c ****                 pxNewTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
 370:../FreeRTOS/Source/timers.c ****             }
 371:../FreeRTOS/Source/timers.c **** 
 372:../FreeRTOS/Source/timers.c ****             traceTIMER_CREATE( pxNewTimer );
 373:../FreeRTOS/Source/timers.c ****         }
 374:../FreeRTOS/Source/timers.c ****     }
 375:../FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 376:../FreeRTOS/Source/timers.c **** 
 377:../FreeRTOS/Source/timers.c ****     BaseType_t xTimerGenericCommand( TimerHandle_t xTimer,
 378:../FreeRTOS/Source/timers.c ****                                      const BaseType_t xCommandID,
 379:../FreeRTOS/Source/timers.c ****                                      const TickType_t xOptionalValue,
 380:../FreeRTOS/Source/timers.c ****                                      BaseType_t * const pxHigherPriorityTaskWoken,
 381:../FreeRTOS/Source/timers.c ****                                      const TickType_t xTicksToWait )
 382:../FreeRTOS/Source/timers.c ****     {
 383:../FreeRTOS/Source/timers.c ****         BaseType_t xReturn = pdFAIL;
 384:../FreeRTOS/Source/timers.c ****         DaemonTaskMessage_t xMessage;
 385:../FreeRTOS/Source/timers.c **** 
 386:../FreeRTOS/Source/timers.c ****         configASSERT( xTimer );
 387:../FreeRTOS/Source/timers.c **** 
 388:../FreeRTOS/Source/timers.c ****         /* Send a message to the timer service task to perform a particular action
 389:../FreeRTOS/Source/timers.c ****          * on a particular timer definition. */
 390:../FreeRTOS/Source/timers.c ****         if( xTimerQueue != NULL )
 391:../FreeRTOS/Source/timers.c ****         {
 392:../FreeRTOS/Source/timers.c ****             /* Send a command to the timer service task to start the xTimer timer. */
 393:../FreeRTOS/Source/timers.c ****             xMessage.xMessageID = xCommandID;
 394:../FreeRTOS/Source/timers.c ****             xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 395:../FreeRTOS/Source/timers.c ****             xMessage.u.xTimerParameters.pxTimer = xTimer;
 396:../FreeRTOS/Source/timers.c **** 
 397:../FreeRTOS/Source/timers.c ****             if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 398:../FreeRTOS/Source/timers.c ****             {
 399:../FreeRTOS/Source/timers.c ****                 if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 400:../FreeRTOS/Source/timers.c ****                 {
 401:../FreeRTOS/Source/timers.c ****                     xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 402:../FreeRTOS/Source/timers.c ****                 }
 403:../FreeRTOS/Source/timers.c ****                 else
 404:../FreeRTOS/Source/timers.c ****                 {
 405:../FreeRTOS/Source/timers.c ****                     xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 406:../FreeRTOS/Source/timers.c ****                 }
 407:../FreeRTOS/Source/timers.c ****             }
 408:../FreeRTOS/Source/timers.c ****             else
 409:../FreeRTOS/Source/timers.c ****             {
 410:../FreeRTOS/Source/timers.c ****                 xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoke
 411:../FreeRTOS/Source/timers.c ****             }
 412:../FreeRTOS/Source/timers.c **** 
 413:../FreeRTOS/Source/timers.c ****             traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
 414:../FreeRTOS/Source/timers.c ****         }
 415:../FreeRTOS/Source/timers.c ****         else
 416:../FreeRTOS/Source/timers.c ****         {
 417:../FreeRTOS/Source/timers.c ****             mtCOVERAGE_TEST_MARKER();
 418:../FreeRTOS/Source/timers.c ****         }
 419:../FreeRTOS/Source/timers.c **** 
 420:../FreeRTOS/Source/timers.c ****         return xReturn;
 421:../FreeRTOS/Source/timers.c ****     }
 422:../FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 423:../FreeRTOS/Source/timers.c **** 
 424:../FreeRTOS/Source/timers.c ****     TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )
 425:../FreeRTOS/Source/timers.c ****     {
 426:../FreeRTOS/Source/timers.c ****         /* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
 427:../FreeRTOS/Source/timers.c ****          * started, then xTimerTaskHandle will be NULL. */
 428:../FreeRTOS/Source/timers.c ****         configASSERT( ( xTimerTaskHandle != NULL ) );
 429:../FreeRTOS/Source/timers.c ****         return xTimerTaskHandle;
 430:../FreeRTOS/Source/timers.c ****     }
 431:../FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 432:../FreeRTOS/Source/timers.c **** 
 433:../FreeRTOS/Source/timers.c ****     TickType_t xTimerGetPeriod( TimerHandle_t xTimer )
 434:../FreeRTOS/Source/timers.c ****     {
 435:../FreeRTOS/Source/timers.c ****         Timer_t * pxTimer = xTimer;
 436:../FreeRTOS/Source/timers.c **** 
 437:../FreeRTOS/Source/timers.c ****         configASSERT( xTimer );
 438:../FreeRTOS/Source/timers.c ****         return pxTimer->xTimerPeriodInTicks;
 439:../FreeRTOS/Source/timers.c ****     }
 440:../FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 441:../FreeRTOS/Source/timers.c **** 
 442:../FreeRTOS/Source/timers.c ****     void vTimerSetReloadMode( TimerHandle_t xTimer,
 443:../FreeRTOS/Source/timers.c ****                               const UBaseType_t uxAutoReload )
 444:../FreeRTOS/Source/timers.c ****     {
 445:../FreeRTOS/Source/timers.c ****         Timer_t * pxTimer = xTimer;
 446:../FreeRTOS/Source/timers.c **** 
 447:../FreeRTOS/Source/timers.c ****         configASSERT( xTimer );
 448:../FreeRTOS/Source/timers.c ****         taskENTER_CRITICAL();
 449:../FreeRTOS/Source/timers.c ****         {
 450:../FreeRTOS/Source/timers.c ****             if( uxAutoReload != pdFALSE )
 451:../FreeRTOS/Source/timers.c ****             {
 452:../FreeRTOS/Source/timers.c ****                 pxTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
 453:../FreeRTOS/Source/timers.c ****             }
 454:../FreeRTOS/Source/timers.c ****             else
 455:../FreeRTOS/Source/timers.c ****             {
 456:../FreeRTOS/Source/timers.c ****                 pxTimer->ucStatus &= ~tmrSTATUS_IS_AUTORELOAD;
 457:../FreeRTOS/Source/timers.c ****             }
 458:../FreeRTOS/Source/timers.c ****         }
 459:../FreeRTOS/Source/timers.c ****         taskEXIT_CRITICAL();
 460:../FreeRTOS/Source/timers.c ****     }
 461:../FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 462:../FreeRTOS/Source/timers.c **** 
 463:../FreeRTOS/Source/timers.c ****     UBaseType_t uxTimerGetReloadMode( TimerHandle_t xTimer )
 464:../FreeRTOS/Source/timers.c ****     {
 465:../FreeRTOS/Source/timers.c ****         Timer_t * pxTimer = xTimer;
 466:../FreeRTOS/Source/timers.c ****         UBaseType_t uxReturn;
 467:../FreeRTOS/Source/timers.c **** 
 468:../FreeRTOS/Source/timers.c ****         configASSERT( xTimer );
 469:../FreeRTOS/Source/timers.c ****         taskENTER_CRITICAL();
 470:../FreeRTOS/Source/timers.c ****         {
 471:../FreeRTOS/Source/timers.c ****             if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) == 0 )
 472:../FreeRTOS/Source/timers.c ****             {
 473:../FreeRTOS/Source/timers.c ****                 /* Not an auto-reload timer. */
 474:../FreeRTOS/Source/timers.c ****                 uxReturn = ( UBaseType_t ) pdFALSE;
 475:../FreeRTOS/Source/timers.c ****             }
 476:../FreeRTOS/Source/timers.c ****             else
 477:../FreeRTOS/Source/timers.c ****             {
 478:../FreeRTOS/Source/timers.c ****                 /* Is an auto-reload timer. */
 479:../FreeRTOS/Source/timers.c ****                 uxReturn = ( UBaseType_t ) pdTRUE;
 480:../FreeRTOS/Source/timers.c ****             }
 481:../FreeRTOS/Source/timers.c ****         }
 482:../FreeRTOS/Source/timers.c ****         taskEXIT_CRITICAL();
 483:../FreeRTOS/Source/timers.c **** 
 484:../FreeRTOS/Source/timers.c ****         return uxReturn;
 485:../FreeRTOS/Source/timers.c ****     }
 486:../FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 487:../FreeRTOS/Source/timers.c **** 
 488:../FreeRTOS/Source/timers.c ****     TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer )
 489:../FreeRTOS/Source/timers.c ****     {
 490:../FreeRTOS/Source/timers.c ****         Timer_t * pxTimer = xTimer;
 491:../FreeRTOS/Source/timers.c ****         TickType_t xReturn;
 492:../FreeRTOS/Source/timers.c **** 
 493:../FreeRTOS/Source/timers.c ****         configASSERT( xTimer );
 494:../FreeRTOS/Source/timers.c ****         xReturn = listGET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ) );
 495:../FreeRTOS/Source/timers.c ****         return xReturn;
 496:../FreeRTOS/Source/timers.c ****     }
 497:../FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 498:../FreeRTOS/Source/timers.c **** 
 499:../FreeRTOS/Source/timers.c ****     const char * pcTimerGetName( TimerHandle_t xTimer ) /*lint !e971 Unqualified char types are all
 500:../FreeRTOS/Source/timers.c ****     {
 501:../FreeRTOS/Source/timers.c ****         Timer_t * pxTimer = xTimer;
 502:../FreeRTOS/Source/timers.c **** 
 503:../FreeRTOS/Source/timers.c ****         configASSERT( xTimer );
 504:../FreeRTOS/Source/timers.c ****         return pxTimer->pcTimerName;
 505:../FreeRTOS/Source/timers.c ****     }
 506:../FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 507:../FreeRTOS/Source/timers.c **** 
 508:../FreeRTOS/Source/timers.c ****     static void prvProcessExpiredTimer( const TickType_t xNextExpireTime,
 509:../FreeRTOS/Source/timers.c ****                                         const TickType_t xTimeNow )
 510:../FreeRTOS/Source/timers.c ****     {
 511:../FreeRTOS/Source/timers.c ****         BaseType_t xResult;
 512:../FreeRTOS/Source/timers.c ****         Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); 
 513:../FreeRTOS/Source/timers.c **** 
 514:../FreeRTOS/Source/timers.c ****         /* Remove the timer from the list of active timers.  A check has already
 515:../FreeRTOS/Source/timers.c ****          * been performed to ensure the list is not empty. */
 516:../FreeRTOS/Source/timers.c **** 
 517:../FreeRTOS/Source/timers.c ****         ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 518:../FreeRTOS/Source/timers.c ****         traceTIMER_EXPIRED( pxTimer );
 519:../FreeRTOS/Source/timers.c **** 
 520:../FreeRTOS/Source/timers.c ****         /* If the timer is an auto-reload timer then calculate the next
 521:../FreeRTOS/Source/timers.c ****          * expiry time and re-insert the timer in the list of active timers. */
 522:../FreeRTOS/Source/timers.c ****         if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 523:../FreeRTOS/Source/timers.c ****         {
 524:../FreeRTOS/Source/timers.c ****             /* The timer is inserted into a list using a time relative to anything
 525:../FreeRTOS/Source/timers.c ****              * other than the current time.  It will therefore be inserted into the
 526:../FreeRTOS/Source/timers.c ****              * correct list relative to the time this task thinks it is now. */
 527:../FreeRTOS/Source/timers.c ****             if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTic
 528:../FreeRTOS/Source/timers.c ****             {
 529:../FreeRTOS/Source/timers.c ****                 /* The timer expired before it was added to the active timer
 530:../FreeRTOS/Source/timers.c ****                  * list.  Reload it now.  */
 531:../FreeRTOS/Source/timers.c ****                 xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTi
 532:../FreeRTOS/Source/timers.c ****                 configASSERT( xResult );
 533:../FreeRTOS/Source/timers.c ****                 ( void ) xResult;
 534:../FreeRTOS/Source/timers.c ****             }
 535:../FreeRTOS/Source/timers.c ****             else
 536:../FreeRTOS/Source/timers.c ****             {
 537:../FreeRTOS/Source/timers.c ****                 mtCOVERAGE_TEST_MARKER();
 538:../FreeRTOS/Source/timers.c ****             }
 539:../FreeRTOS/Source/timers.c ****         }
 540:../FreeRTOS/Source/timers.c ****         else
 541:../FreeRTOS/Source/timers.c ****         {
 542:../FreeRTOS/Source/timers.c ****             pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 543:../FreeRTOS/Source/timers.c ****             mtCOVERAGE_TEST_MARKER();
 544:../FreeRTOS/Source/timers.c ****         }
 545:../FreeRTOS/Source/timers.c **** 
 546:../FreeRTOS/Source/timers.c ****         /* Call the timer callback. */
 547:../FreeRTOS/Source/timers.c ****         pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 548:../FreeRTOS/Source/timers.c ****     }
 549:../FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 550:../FreeRTOS/Source/timers.c **** 
 551:../FreeRTOS/Source/timers.c ****     static portTASK_FUNCTION( prvTimerTask, pvParameters )
 552:../FreeRTOS/Source/timers.c ****     {
 553:../FreeRTOS/Source/timers.c ****         TickType_t xNextExpireTime;
 554:../FreeRTOS/Source/timers.c ****         BaseType_t xListWasEmpty;
 555:../FreeRTOS/Source/timers.c **** 
 556:../FreeRTOS/Source/timers.c ****         /* Just to avoid compiler warnings. */
 557:../FreeRTOS/Source/timers.c ****         ( void ) pvParameters;
 558:../FreeRTOS/Source/timers.c **** 
 559:../FreeRTOS/Source/timers.c ****         #if ( configUSE_DAEMON_TASK_STARTUP_HOOK == 1 )
 560:../FreeRTOS/Source/timers.c ****             {
 561:../FreeRTOS/Source/timers.c ****                 extern void vApplicationDaemonTaskStartupHook( void );
 562:../FreeRTOS/Source/timers.c **** 
 563:../FreeRTOS/Source/timers.c ****                 /* Allow the application writer to execute some code in the context of
 564:../FreeRTOS/Source/timers.c ****                  * this task at the point the task starts executing.  This is useful if the
 565:../FreeRTOS/Source/timers.c ****                  * application includes initialisation code that would benefit from
 566:../FreeRTOS/Source/timers.c ****                  * executing after the scheduler has been started. */
 567:../FreeRTOS/Source/timers.c ****                 vApplicationDaemonTaskStartupHook();
 568:../FreeRTOS/Source/timers.c ****             }
 569:../FreeRTOS/Source/timers.c ****         #endif /* configUSE_DAEMON_TASK_STARTUP_HOOK */
 570:../FreeRTOS/Source/timers.c **** 
 571:../FreeRTOS/Source/timers.c ****         for( ; ; )
 572:../FreeRTOS/Source/timers.c ****         {
 573:../FreeRTOS/Source/timers.c ****             /* Query the timers list to see if it contains any timers, and if so,
 574:../FreeRTOS/Source/timers.c ****              * obtain the time at which the next timer will expire. */
 575:../FreeRTOS/Source/timers.c ****             xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
 576:../FreeRTOS/Source/timers.c **** 
 577:../FreeRTOS/Source/timers.c ****             /* If a timer has expired, process it.  Otherwise, block this task
 578:../FreeRTOS/Source/timers.c ****              * until either a timer does expire, or a command is received. */
 579:../FreeRTOS/Source/timers.c ****             prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
 580:../FreeRTOS/Source/timers.c **** 
 581:../FreeRTOS/Source/timers.c ****             /* Empty the command queue. */
 582:../FreeRTOS/Source/timers.c ****             prvProcessReceivedCommands();
 583:../FreeRTOS/Source/timers.c ****         }
 584:../FreeRTOS/Source/timers.c ****     }
 585:../FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 586:../FreeRTOS/Source/timers.c **** 
 587:../FreeRTOS/Source/timers.c ****     static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime,
 588:../FreeRTOS/Source/timers.c ****                                             BaseType_t xListWasEmpty )
 589:../FreeRTOS/Source/timers.c ****     {
 590:../FreeRTOS/Source/timers.c ****         TickType_t xTimeNow;
 591:../FreeRTOS/Source/timers.c ****         BaseType_t xTimerListsWereSwitched;
 592:../FreeRTOS/Source/timers.c **** 
 593:../FreeRTOS/Source/timers.c ****         vTaskSuspendAll();
 594:../FreeRTOS/Source/timers.c ****         {
 595:../FreeRTOS/Source/timers.c ****             /* Obtain the time now to make an assessment as to whether the timer
 596:../FreeRTOS/Source/timers.c ****              * has expired or not.  If obtaining the time causes the lists to switch
 597:../FreeRTOS/Source/timers.c ****              * then don't process this timer as any timers that remained in the list
 598:../FreeRTOS/Source/timers.c ****              * when the lists were switched will have been processed within the
 599:../FreeRTOS/Source/timers.c ****              * prvSampleTimeNow() function. */
 600:../FreeRTOS/Source/timers.c ****             xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 601:../FreeRTOS/Source/timers.c **** 
 602:../FreeRTOS/Source/timers.c ****             if( xTimerListsWereSwitched == pdFALSE )
 603:../FreeRTOS/Source/timers.c ****             {
 604:../FreeRTOS/Source/timers.c ****                 /* The tick count has not overflowed, has the timer expired? */
 605:../FreeRTOS/Source/timers.c ****                 if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 606:../FreeRTOS/Source/timers.c ****                 {
 607:../FreeRTOS/Source/timers.c ****                     ( void ) xTaskResumeAll();
 608:../FreeRTOS/Source/timers.c ****                     prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
 609:../FreeRTOS/Source/timers.c ****                 }
 610:../FreeRTOS/Source/timers.c ****                 else
 611:../FreeRTOS/Source/timers.c ****                 {
 612:../FreeRTOS/Source/timers.c ****                     /* The tick count has not overflowed, and the next expire
 613:../FreeRTOS/Source/timers.c ****                      * time has not been reached yet.  This task should therefore
 614:../FreeRTOS/Source/timers.c ****                      * block to wait for the next expire time or a command to be
 615:../FreeRTOS/Source/timers.c ****                      * received - whichever comes first.  The following line cannot
 616:../FreeRTOS/Source/timers.c ****                      * be reached unless xNextExpireTime > xTimeNow, except in the
 617:../FreeRTOS/Source/timers.c ****                      * case when the current timer list is empty. */
 618:../FreeRTOS/Source/timers.c ****                     if( xListWasEmpty != pdFALSE )
 619:../FreeRTOS/Source/timers.c ****                     {
 620:../FreeRTOS/Source/timers.c ****                         /* The current timer list is empty - is the overflow list
 621:../FreeRTOS/Source/timers.c ****                          * also empty? */
 622:../FreeRTOS/Source/timers.c ****                         xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 623:../FreeRTOS/Source/timers.c ****                     }
 624:../FreeRTOS/Source/timers.c **** 
 625:../FreeRTOS/Source/timers.c ****                     vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xL
 626:../FreeRTOS/Source/timers.c **** 
 627:../FreeRTOS/Source/timers.c ****                     if( xTaskResumeAll() == pdFALSE )
 628:../FreeRTOS/Source/timers.c ****                     {
 629:../FreeRTOS/Source/timers.c ****                         /* Yield to wait for either a command to arrive, or the
 630:../FreeRTOS/Source/timers.c ****                          * block time to expire.  If a command arrived between the
 631:../FreeRTOS/Source/timers.c ****                          * critical section being exited and this yield then the yield
 632:../FreeRTOS/Source/timers.c ****                          * will not cause the task to block. */
 633:../FreeRTOS/Source/timers.c ****                         portYIELD_WITHIN_API();
 634:../FreeRTOS/Source/timers.c ****                     }
 635:../FreeRTOS/Source/timers.c ****                     else
 636:../FreeRTOS/Source/timers.c ****                     {
 637:../FreeRTOS/Source/timers.c ****                         mtCOVERAGE_TEST_MARKER();
 638:../FreeRTOS/Source/timers.c ****                     }
 639:../FreeRTOS/Source/timers.c ****                 }
 640:../FreeRTOS/Source/timers.c ****             }
 641:../FreeRTOS/Source/timers.c ****             else
 642:../FreeRTOS/Source/timers.c ****             {
 643:../FreeRTOS/Source/timers.c ****                 ( void ) xTaskResumeAll();
 644:../FreeRTOS/Source/timers.c ****             }
 645:../FreeRTOS/Source/timers.c ****         }
 646:../FreeRTOS/Source/timers.c ****     }
 647:../FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 648:../FreeRTOS/Source/timers.c **** 
 649:../FreeRTOS/Source/timers.c ****     static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
 650:../FreeRTOS/Source/timers.c ****     {
 651:../FreeRTOS/Source/timers.c ****         TickType_t xNextExpireTime;
 652:../FreeRTOS/Source/timers.c **** 
 653:../FreeRTOS/Source/timers.c ****         /* Timers are listed in expiry time order, with the head of the list
 654:../FreeRTOS/Source/timers.c ****          * referencing the task that will expire first.  Obtain the time at which
 655:../FreeRTOS/Source/timers.c ****          * the timer with the nearest expiry time will expire.  If there are no
 656:../FreeRTOS/Source/timers.c ****          * active timers then just set the next expire time to 0.  That will cause
 657:../FreeRTOS/Source/timers.c ****          * this task to unblock when the tick count overflows, at which point the
 658:../FreeRTOS/Source/timers.c ****          * timer lists will be switched and the next expiry time can be
 659:../FreeRTOS/Source/timers.c ****          * re-assessed.  */
 660:../FreeRTOS/Source/timers.c ****         *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 661:../FreeRTOS/Source/timers.c **** 
 662:../FreeRTOS/Source/timers.c ****         if( *pxListWasEmpty == pdFALSE )
 663:../FreeRTOS/Source/timers.c ****         {
 664:../FreeRTOS/Source/timers.c ****             xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 665:../FreeRTOS/Source/timers.c ****         }
 666:../FreeRTOS/Source/timers.c ****         else
 667:../FreeRTOS/Source/timers.c ****         {
 668:../FreeRTOS/Source/timers.c ****             /* Ensure the task unblocks when the tick count rolls over. */
 669:../FreeRTOS/Source/timers.c ****             xNextExpireTime = ( TickType_t ) 0U;
 670:../FreeRTOS/Source/timers.c ****         }
 671:../FreeRTOS/Source/timers.c **** 
 672:../FreeRTOS/Source/timers.c ****         return xNextExpireTime;
 673:../FreeRTOS/Source/timers.c ****     }
 674:../FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 675:../FreeRTOS/Source/timers.c **** 
 676:../FreeRTOS/Source/timers.c ****     static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
 677:../FreeRTOS/Source/timers.c ****     {
 678:../FreeRTOS/Source/timers.c ****         TickType_t xTimeNow;
 679:../FreeRTOS/Source/timers.c ****         PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is o
 680:../FreeRTOS/Source/timers.c **** 
 681:../FreeRTOS/Source/timers.c ****         xTimeNow = xTaskGetTickCount();
 682:../FreeRTOS/Source/timers.c **** 
 683:../FreeRTOS/Source/timers.c ****         if( xTimeNow < xLastTime )
 684:../FreeRTOS/Source/timers.c ****         {
 685:../FreeRTOS/Source/timers.c ****             prvSwitchTimerLists();
 686:../FreeRTOS/Source/timers.c ****             *pxTimerListsWereSwitched = pdTRUE;
 687:../FreeRTOS/Source/timers.c ****         }
 688:../FreeRTOS/Source/timers.c ****         else
 689:../FreeRTOS/Source/timers.c ****         {
 690:../FreeRTOS/Source/timers.c ****             *pxTimerListsWereSwitched = pdFALSE;
 691:../FreeRTOS/Source/timers.c ****         }
 692:../FreeRTOS/Source/timers.c **** 
 693:../FreeRTOS/Source/timers.c ****         xLastTime = xTimeNow;
 694:../FreeRTOS/Source/timers.c **** 
 695:../FreeRTOS/Source/timers.c ****         return xTimeNow;
 696:../FreeRTOS/Source/timers.c ****     }
 697:../FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 698:../FreeRTOS/Source/timers.c **** 
 699:../FreeRTOS/Source/timers.c ****     static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer,
 700:../FreeRTOS/Source/timers.c ****                                                   const TickType_t xNextExpiryTime,
 701:../FreeRTOS/Source/timers.c ****                                                   const TickType_t xTimeNow,
 702:../FreeRTOS/Source/timers.c ****                                                   const TickType_t xCommandTime )
 703:../FreeRTOS/Source/timers.c ****     {
  26              	 .loc 1 703 0
  27              	 .cfi_startproc
  28              	 
  29              	 
  30              	.LVL0:
  31 0000 10B5     	 push {r4,lr}
  32              	.LCFI0:
  33              	 .cfi_def_cfa_offset 8
  34              	 .cfi_offset 4,-8
  35              	 .cfi_offset 14,-4
  36 0002 0446     	 mov r4,r0
  37              	.LVL1:
 704:../FreeRTOS/Source/timers.c ****         BaseType_t xProcessTimerNow = pdFALSE;
 705:../FreeRTOS/Source/timers.c **** 
 706:../FreeRTOS/Source/timers.c ****         listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
  38              	 .loc 1 706 0
  39 0004 4160     	 str r1,[r0,#4]
 707:../FreeRTOS/Source/timers.c ****         listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
  40              	 .loc 1 707 0
  41 0006 2061     	 str r0,[r4,#16]
 708:../FreeRTOS/Source/timers.c **** 
 709:../FreeRTOS/Source/timers.c ****         if( xNextExpiryTime <= xTimeNow )
  42              	 .loc 1 709 0
  43 0008 9142     	 cmp r1,r2
  44 000a 0AD8     	 bhi .L2
 710:../FreeRTOS/Source/timers.c ****         {
 711:../FreeRTOS/Source/timers.c ****             /* Has the expiry time elapsed between the command to start/reset a
 712:../FreeRTOS/Source/timers.c ****              * timer was issued, and the time the command was processed? */
 713:../FreeRTOS/Source/timers.c ****             if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*
  45              	 .loc 1 713 0
  46 000c D21A     	 subs r2,r2,r3
  47              	.LVL2:
  48 000e 8369     	 ldr r3,[r0,#24]
  49              	.LVL3:
  50 0010 9A42     	 cmp r2,r3
  51 0012 11D2     	 bcs .L5
 714:../FreeRTOS/Source/timers.c ****             {
 715:../FreeRTOS/Source/timers.c ****                 /* The time between a command being issued and the command being
 716:../FreeRTOS/Source/timers.c ****                  * processed actually exceeds the timers period.  */
 717:../FreeRTOS/Source/timers.c ****                 xProcessTimerNow = pdTRUE;
 718:../FreeRTOS/Source/timers.c ****             }
 719:../FreeRTOS/Source/timers.c ****             else
 720:../FreeRTOS/Source/timers.c ****             {
 721:../FreeRTOS/Source/timers.c ****                 vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
  52              	 .loc 1 721 0
  53 0014 0A4B     	 ldr r3,.L8
  54 0016 1868     	 ldr r0,[r3]
  55              	.LVL4:
  56 0018 211D     	 adds r1,r4,#4
  57              	.LVL5:
  58 001a FFF7FEFF 	 bl vListInsert
  59              	.LVL6:
 704:../FreeRTOS/Source/timers.c **** 
  60              	 .loc 1 704 0
  61 001e 0020     	 movs r0,#0
  62 0020 10BD     	 pop {r4,pc}
  63              	.LVL7:
  64              	.L2:
 722:../FreeRTOS/Source/timers.c ****             }
 723:../FreeRTOS/Source/timers.c ****         }
 724:../FreeRTOS/Source/timers.c ****         else
 725:../FreeRTOS/Source/timers.c ****         {
 726:../FreeRTOS/Source/timers.c ****             if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
  65              	 .loc 1 726 0
  66 0022 9A42     	 cmp r2,r3
  67 0024 01D2     	 bcs .L4
  68              	 .loc 1 726 0 is_stmt 0 discriminator 1
  69 0026 9942     	 cmp r1,r3
  70 0028 08D2     	 bcs .L6
  71              	.L4:
 727:../FreeRTOS/Source/timers.c ****             {
 728:../FreeRTOS/Source/timers.c ****                 /* If, since the command was issued, the tick count has overflowed
 729:../FreeRTOS/Source/timers.c ****                  * but the expiry time has not, then the timer must have already passed
 730:../FreeRTOS/Source/timers.c ****                  * its expiry time and should be processed immediately. */
 731:../FreeRTOS/Source/timers.c ****                 xProcessTimerNow = pdTRUE;
 732:../FreeRTOS/Source/timers.c ****             }
 733:../FreeRTOS/Source/timers.c ****             else
 734:../FreeRTOS/Source/timers.c ****             {
 735:../FreeRTOS/Source/timers.c ****                 vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
  72              	 .loc 1 735 0 is_stmt 1
  73 002a 064B     	 ldr r3,.L8+4
  74              	.LVL8:
  75 002c 1868     	 ldr r0,[r3]
  76              	.LVL9:
  77 002e 211D     	 adds r1,r4,#4
  78              	.LVL10:
  79 0030 FFF7FEFF 	 bl vListInsert
  80              	.LVL11:
 704:../FreeRTOS/Source/timers.c **** 
  81              	 .loc 1 704 0
  82 0034 0020     	 movs r0,#0
  83 0036 10BD     	 pop {r4,pc}
  84              	.LVL12:
  85              	.L5:
 717:../FreeRTOS/Source/timers.c ****             }
  86              	 .loc 1 717 0
  87 0038 0120     	 movs r0,#1
  88              	.LVL13:
  89 003a 10BD     	 pop {r4,pc}
  90              	.LVL14:
  91              	.L6:
 731:../FreeRTOS/Source/timers.c ****             }
  92              	 .loc 1 731 0
  93 003c 0120     	 movs r0,#1
  94              	.LVL15:
 736:../FreeRTOS/Source/timers.c ****             }
 737:../FreeRTOS/Source/timers.c ****         }
 738:../FreeRTOS/Source/timers.c **** 
 739:../FreeRTOS/Source/timers.c ****         return xProcessTimerNow;
 740:../FreeRTOS/Source/timers.c ****     }
  95              	 .loc 1 740 0
  96 003e 10BD     	 pop {r4,pc}
  97              	.LVL16:
  98              	.L9:
  99              	 .align 2
 100              	.L8:
 101 0040 00000000 	 .word .LANCHOR0
 102 0044 00000000 	 .word .LANCHOR1
 103              	 .cfi_endproc
 104              	.LFE20:
 106              	 .section .text.prvCheckForValidListAndQueue,"ax",%progbits
 107              	 .align 2
 108              	 .thumb
 109              	 .thumb_func
 111              	prvCheckForValidListAndQueue:
 112              	.LFB23:
 741:../FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 742:../FreeRTOS/Source/timers.c **** 
 743:../FreeRTOS/Source/timers.c ****     static void prvProcessReceivedCommands( void )
 744:../FreeRTOS/Source/timers.c ****     {
 745:../FreeRTOS/Source/timers.c ****         DaemonTaskMessage_t xMessage;
 746:../FreeRTOS/Source/timers.c ****         Timer_t * pxTimer;
 747:../FreeRTOS/Source/timers.c ****         BaseType_t xTimerListsWereSwitched, xResult;
 748:../FreeRTOS/Source/timers.c ****         TickType_t xTimeNow;
 749:../FreeRTOS/Source/timers.c **** 
 750:../FreeRTOS/Source/timers.c ****         while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessa
 751:../FreeRTOS/Source/timers.c ****         {
 752:../FreeRTOS/Source/timers.c ****             #if ( INCLUDE_xTimerPendFunctionCall == 1 )
 753:../FreeRTOS/Source/timers.c ****                 {
 754:../FreeRTOS/Source/timers.c ****                     /* Negative commands are pended function calls rather than timer
 755:../FreeRTOS/Source/timers.c ****                      * commands. */
 756:../FreeRTOS/Source/timers.c ****                     if( xMessage.xMessageID < ( BaseType_t ) 0 )
 757:../FreeRTOS/Source/timers.c ****                     {
 758:../FreeRTOS/Source/timers.c ****                         const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackPara
 759:../FreeRTOS/Source/timers.c **** 
 760:../FreeRTOS/Source/timers.c ****                         /* The timer uses the xCallbackParameters member to request a
 761:../FreeRTOS/Source/timers.c ****                          * callback be executed.  Check the callback is not NULL. */
 762:../FreeRTOS/Source/timers.c ****                         configASSERT( pxCallback );
 763:../FreeRTOS/Source/timers.c **** 
 764:../FreeRTOS/Source/timers.c ****                         /* Call the function. */
 765:../FreeRTOS/Source/timers.c ****                         pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulPar
 766:../FreeRTOS/Source/timers.c ****                     }
 767:../FreeRTOS/Source/timers.c ****                     else
 768:../FreeRTOS/Source/timers.c ****                     {
 769:../FreeRTOS/Source/timers.c ****                         mtCOVERAGE_TEST_MARKER();
 770:../FreeRTOS/Source/timers.c ****                     }
 771:../FreeRTOS/Source/timers.c ****                 }
 772:../FreeRTOS/Source/timers.c ****             #endif /* INCLUDE_xTimerPendFunctionCall */
 773:../FreeRTOS/Source/timers.c **** 
 774:../FreeRTOS/Source/timers.c ****             /* Commands that are positive are timer commands rather than pended
 775:../FreeRTOS/Source/timers.c ****              * function calls. */
 776:../FreeRTOS/Source/timers.c ****             if( xMessage.xMessageID >= ( BaseType_t ) 0 )
 777:../FreeRTOS/Source/timers.c ****             {
 778:../FreeRTOS/Source/timers.c ****                 /* The messages uses the xTimerParameters member to work on a
 779:../FreeRTOS/Source/timers.c ****                  * software timer. */
 780:../FreeRTOS/Source/timers.c ****                 pxTimer = xMessage.u.xTimerParameters.pxTimer;
 781:../FreeRTOS/Source/timers.c **** 
 782:../FreeRTOS/Source/timers.c ****                 if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*li
 783:../FreeRTOS/Source/timers.c ****                 {
 784:../FreeRTOS/Source/timers.c ****                     /* The timer is in a list, remove it. */
 785:../FreeRTOS/Source/timers.c ****                     ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 786:../FreeRTOS/Source/timers.c ****                 }
 787:../FreeRTOS/Source/timers.c ****                 else
 788:../FreeRTOS/Source/timers.c ****                 {
 789:../FreeRTOS/Source/timers.c ****                     mtCOVERAGE_TEST_MARKER();
 790:../FreeRTOS/Source/timers.c ****                 }
 791:../FreeRTOS/Source/timers.c **** 
 792:../FreeRTOS/Source/timers.c ****                 traceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.u.xTimerParamet
 793:../FreeRTOS/Source/timers.c **** 
 794:../FreeRTOS/Source/timers.c ****                 /* In this case the xTimerListsWereSwitched parameter is not used, but
 795:../FreeRTOS/Source/timers.c ****                  *  it must be present in the function call.  prvSampleTimeNow() must be
 796:../FreeRTOS/Source/timers.c ****                  *  called after the message is received from xTimerQueue so there is no
 797:../FreeRTOS/Source/timers.c ****                  *  possibility of a higher priority task adding a message to the message
 798:../FreeRTOS/Source/timers.c ****                  *  queue with a time that is ahead of the timer daemon task (because it
 799:../FreeRTOS/Source/timers.c ****                  *  pre-empted the timer daemon task after the xTimeNow value was set). */
 800:../FreeRTOS/Source/timers.c ****                 xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 801:../FreeRTOS/Source/timers.c **** 
 802:../FreeRTOS/Source/timers.c ****                 switch( xMessage.xMessageID )
 803:../FreeRTOS/Source/timers.c ****                 {
 804:../FreeRTOS/Source/timers.c ****                     case tmrCOMMAND_START:
 805:../FreeRTOS/Source/timers.c ****                     case tmrCOMMAND_START_FROM_ISR:
 806:../FreeRTOS/Source/timers.c ****                     case tmrCOMMAND_RESET:
 807:../FreeRTOS/Source/timers.c ****                     case tmrCOMMAND_RESET_FROM_ISR:
 808:../FreeRTOS/Source/timers.c ****                     case tmrCOMMAND_START_DONT_TRACE:
 809:../FreeRTOS/Source/timers.c ****                         /* Start or restart a timer. */
 810:../FreeRTOS/Source/timers.c ****                         pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 811:../FreeRTOS/Source/timers.c **** 
 812:../FreeRTOS/Source/timers.c ****                         if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessa
 813:../FreeRTOS/Source/timers.c ****                         {
 814:../FreeRTOS/Source/timers.c ****                             /* The timer expired before it was added to the active
 815:../FreeRTOS/Source/timers.c ****                              * timer list.  Process it now. */
 816:../FreeRTOS/Source/timers.c ****                             pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 817:../FreeRTOS/Source/timers.c ****                             traceTIMER_EXPIRED( pxTimer );
 818:../FreeRTOS/Source/timers.c **** 
 819:../FreeRTOS/Source/timers.c ****                             if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 820:../FreeRTOS/Source/timers.c ****                             {
 821:../FreeRTOS/Source/timers.c ****                                 xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRAC
 822:../FreeRTOS/Source/timers.c ****                                 configASSERT( xResult );
 823:../FreeRTOS/Source/timers.c ****                                 ( void ) xResult;
 824:../FreeRTOS/Source/timers.c ****                             }
 825:../FreeRTOS/Source/timers.c ****                             else
 826:../FreeRTOS/Source/timers.c ****                             {
 827:../FreeRTOS/Source/timers.c ****                                 mtCOVERAGE_TEST_MARKER();
 828:../FreeRTOS/Source/timers.c ****                             }
 829:../FreeRTOS/Source/timers.c ****                         }
 830:../FreeRTOS/Source/timers.c ****                         else
 831:../FreeRTOS/Source/timers.c ****                         {
 832:../FreeRTOS/Source/timers.c ****                             mtCOVERAGE_TEST_MARKER();
 833:../FreeRTOS/Source/timers.c ****                         }
 834:../FreeRTOS/Source/timers.c **** 
 835:../FreeRTOS/Source/timers.c ****                         break;
 836:../FreeRTOS/Source/timers.c **** 
 837:../FreeRTOS/Source/timers.c ****                     case tmrCOMMAND_STOP:
 838:../FreeRTOS/Source/timers.c ****                     case tmrCOMMAND_STOP_FROM_ISR:
 839:../FreeRTOS/Source/timers.c ****                         /* The timer has already been removed from the active list. */
 840:../FreeRTOS/Source/timers.c ****                         pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 841:../FreeRTOS/Source/timers.c ****                         break;
 842:../FreeRTOS/Source/timers.c **** 
 843:../FreeRTOS/Source/timers.c ****                     case tmrCOMMAND_CHANGE_PERIOD:
 844:../FreeRTOS/Source/timers.c ****                     case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR:
 845:../FreeRTOS/Source/timers.c ****                         pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 846:../FreeRTOS/Source/timers.c ****                         pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 847:../FreeRTOS/Source/timers.c ****                         configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 848:../FreeRTOS/Source/timers.c **** 
 849:../FreeRTOS/Source/timers.c ****                         /* The new period does not really have a reference, and can
 850:../FreeRTOS/Source/timers.c ****                          * be longer or shorter than the old one.  The command time is
 851:../FreeRTOS/Source/timers.c ****                          * therefore set to the current time, and as the period cannot
 852:../FreeRTOS/Source/timers.c ****                          * be zero the next expiry time can only be in the future,
 853:../FreeRTOS/Source/timers.c ****                          * meaning (unlike for the xTimerStart() case above) there is
 854:../FreeRTOS/Source/timers.c ****                          * no fail case that needs to be handled here. */
 855:../FreeRTOS/Source/timers.c ****                         ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerP
 856:../FreeRTOS/Source/timers.c ****                         break;
 857:../FreeRTOS/Source/timers.c **** 
 858:../FreeRTOS/Source/timers.c ****                     case tmrCOMMAND_DELETE:
 859:../FreeRTOS/Source/timers.c ****                         #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 860:../FreeRTOS/Source/timers.c ****                             {
 861:../FreeRTOS/Source/timers.c ****                                 /* The timer has already been removed from the active list,
 862:../FreeRTOS/Source/timers.c ****                                  * just free up the memory if the memory was dynamically
 863:../FreeRTOS/Source/timers.c ****                                  * allocated. */
 864:../FreeRTOS/Source/timers.c ****                                 if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( 
 865:../FreeRTOS/Source/timers.c ****                                 {
 866:../FreeRTOS/Source/timers.c ****                                     vPortFree( pxTimer );
 867:../FreeRTOS/Source/timers.c ****                                 }
 868:../FreeRTOS/Source/timers.c ****                                 else
 869:../FreeRTOS/Source/timers.c ****                                 {
 870:../FreeRTOS/Source/timers.c ****                                     pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 871:../FreeRTOS/Source/timers.c ****                                 }
 872:../FreeRTOS/Source/timers.c ****                             }
 873:../FreeRTOS/Source/timers.c ****                         #else /* if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) */
 874:../FreeRTOS/Source/timers.c ****                             {
 875:../FreeRTOS/Source/timers.c ****                                 /* If dynamic allocation is not enabled, the memory
 876:../FreeRTOS/Source/timers.c ****                                  * could not have been dynamically allocated. So there is
 877:../FreeRTOS/Source/timers.c ****                                  * no need to free the memory - just mark the timer as
 878:../FreeRTOS/Source/timers.c ****                                  * "not active". */
 879:../FreeRTOS/Source/timers.c ****                                 pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 880:../FreeRTOS/Source/timers.c ****                             }
 881:../FreeRTOS/Source/timers.c ****                         #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 882:../FreeRTOS/Source/timers.c ****                         break;
 883:../FreeRTOS/Source/timers.c **** 
 884:../FreeRTOS/Source/timers.c ****                     default:
 885:../FreeRTOS/Source/timers.c ****                         /* Don't expect to get here. */
 886:../FreeRTOS/Source/timers.c ****                         break;
 887:../FreeRTOS/Source/timers.c ****                 }
 888:../FreeRTOS/Source/timers.c ****             }
 889:../FreeRTOS/Source/timers.c ****         }
 890:../FreeRTOS/Source/timers.c ****     }
 891:../FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 892:../FreeRTOS/Source/timers.c **** 
 893:../FreeRTOS/Source/timers.c ****     static void prvSwitchTimerLists( void )
 894:../FreeRTOS/Source/timers.c ****     {
 895:../FreeRTOS/Source/timers.c ****         TickType_t xNextExpireTime, xReloadTime;
 896:../FreeRTOS/Source/timers.c ****         List_t * pxTemp;
 897:../FreeRTOS/Source/timers.c ****         Timer_t * pxTimer;
 898:../FreeRTOS/Source/timers.c ****         BaseType_t xResult;
 899:../FreeRTOS/Source/timers.c **** 
 900:../FreeRTOS/Source/timers.c ****         /* The tick count has overflowed.  The timer lists must be switched.
 901:../FreeRTOS/Source/timers.c ****          * If there are any timers still referenced from the current timer list
 902:../FreeRTOS/Source/timers.c ****          * then they must have expired and should be processed before the lists
 903:../FreeRTOS/Source/timers.c ****          * are switched. */
 904:../FreeRTOS/Source/timers.c ****         while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 905:../FreeRTOS/Source/timers.c ****         {
 906:../FreeRTOS/Source/timers.c ****             xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 907:../FreeRTOS/Source/timers.c **** 
 908:../FreeRTOS/Source/timers.c ****             /* Remove the timer from the list. */
 909:../FreeRTOS/Source/timers.c ****             pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e908
 910:../FreeRTOS/Source/timers.c ****             ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 911:../FreeRTOS/Source/timers.c ****             traceTIMER_EXPIRED( pxTimer );
 912:../FreeRTOS/Source/timers.c **** 
 913:../FreeRTOS/Source/timers.c ****             /* Execute its callback, then send a command to restart the timer if
 914:../FreeRTOS/Source/timers.c ****              * it is an auto-reload timer.  It cannot be restarted here as the lists
 915:../FreeRTOS/Source/timers.c ****              * have not yet been switched. */
 916:../FreeRTOS/Source/timers.c ****             pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 917:../FreeRTOS/Source/timers.c **** 
 918:../FreeRTOS/Source/timers.c ****             if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 919:../FreeRTOS/Source/timers.c ****             {
 920:../FreeRTOS/Source/timers.c ****                 /* Calculate the reload value, and if the reload value results in
 921:../FreeRTOS/Source/timers.c ****                  * the timer going into the same timer list then it has already expired
 922:../FreeRTOS/Source/timers.c ****                  * and the timer should be re-inserted into the current list so it is
 923:../FreeRTOS/Source/timers.c ****                  * processed again within this loop.  Otherwise a command should be sent
 924:../FreeRTOS/Source/timers.c ****                  * to restart the timer to ensure it is only inserted into a list after
 925:../FreeRTOS/Source/timers.c ****                  * the lists have been swapped. */
 926:../FreeRTOS/Source/timers.c ****                 xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 927:../FreeRTOS/Source/timers.c **** 
 928:../FreeRTOS/Source/timers.c ****                 if( xReloadTime > xNextExpireTime )
 929:../FreeRTOS/Source/timers.c ****                 {
 930:../FreeRTOS/Source/timers.c ****                     listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 931:../FreeRTOS/Source/timers.c ****                     listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 932:../FreeRTOS/Source/timers.c ****                     vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 933:../FreeRTOS/Source/timers.c ****                 }
 934:../FreeRTOS/Source/timers.c ****                 else
 935:../FreeRTOS/Source/timers.c ****                 {
 936:../FreeRTOS/Source/timers.c ****                     xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpi
 937:../FreeRTOS/Source/timers.c ****                     configASSERT( xResult );
 938:../FreeRTOS/Source/timers.c ****                     ( void ) xResult;
 939:../FreeRTOS/Source/timers.c ****                 }
 940:../FreeRTOS/Source/timers.c ****             }
 941:../FreeRTOS/Source/timers.c ****             else
 942:../FreeRTOS/Source/timers.c ****             {
 943:../FreeRTOS/Source/timers.c ****                 mtCOVERAGE_TEST_MARKER();
 944:../FreeRTOS/Source/timers.c ****             }
 945:../FreeRTOS/Source/timers.c ****         }
 946:../FreeRTOS/Source/timers.c **** 
 947:../FreeRTOS/Source/timers.c ****         pxTemp = pxCurrentTimerList;
 948:../FreeRTOS/Source/timers.c ****         pxCurrentTimerList = pxOverflowTimerList;
 949:../FreeRTOS/Source/timers.c ****         pxOverflowTimerList = pxTemp;
 950:../FreeRTOS/Source/timers.c ****     }
 951:../FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 952:../FreeRTOS/Source/timers.c **** 
 953:../FreeRTOS/Source/timers.c ****     static void prvCheckForValidListAndQueue( void )
 954:../FreeRTOS/Source/timers.c ****     {
 113              	 .loc 1 954 0
 114              	 .cfi_startproc
 115              	 
 116              	 
 117 0000 38B5     	 push {r3,r4,r5,lr}
 118              	.LCFI1:
 119              	 .cfi_def_cfa_offset 16
 120              	 .cfi_offset 3,-16
 121              	 .cfi_offset 4,-12
 122              	 .cfi_offset 5,-8
 123              	 .cfi_offset 14,-4
 955:../FreeRTOS/Source/timers.c ****         /* Check that the list from which active timers are referenced, and the
 956:../FreeRTOS/Source/timers.c ****          * queue used to communicate with the timer service, have been
 957:../FreeRTOS/Source/timers.c ****          * initialised. */
 958:../FreeRTOS/Source/timers.c ****         taskENTER_CRITICAL();
 124              	 .loc 1 958 0
 125 0002 FFF7FEFF 	 bl vPortEnterCritical
 126              	.LVL17:
 959:../FreeRTOS/Source/timers.c ****         {
 960:../FreeRTOS/Source/timers.c ****             if( xTimerQueue == NULL )
 127              	 .loc 1 960 0
 128 0006 0E4B     	 ldr r3,.L13
 129 0008 1B68     	 ldr r3,[r3]
 130 000a B3B9     	 cbnz r3,.L11
 961:../FreeRTOS/Source/timers.c ****             {
 962:../FreeRTOS/Source/timers.c ****                 vListInitialise( &xActiveTimerList1 );
 131              	 .loc 1 962 0
 132 000c 0D4D     	 ldr r5,.L13+4
 133 000e 2846     	 mov r0,r5
 134 0010 FFF7FEFF 	 bl vListInitialise
 135              	.LVL18:
 963:../FreeRTOS/Source/timers.c ****                 vListInitialise( &xActiveTimerList2 );
 136              	 .loc 1 963 0
 137 0014 0C4C     	 ldr r4,.L13+8
 138 0016 2046     	 mov r0,r4
 139 0018 FFF7FEFF 	 bl vListInitialise
 140              	.LVL19:
 964:../FreeRTOS/Source/timers.c ****                 pxCurrentTimerList = &xActiveTimerList1;
 141              	 .loc 1 964 0
 142 001c 0B4B     	 ldr r3,.L13+12
 143 001e 1D60     	 str r5,[r3]
 965:../FreeRTOS/Source/timers.c ****                 pxOverflowTimerList = &xActiveTimerList2;
 144              	 .loc 1 965 0
 145 0020 0B4B     	 ldr r3,.L13+16
 146 0022 1C60     	 str r4,[r3]
 966:../FreeRTOS/Source/timers.c **** 
 967:../FreeRTOS/Source/timers.c ****                 #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
 968:../FreeRTOS/Source/timers.c ****                     {
 969:../FreeRTOS/Source/timers.c ****                         /* The timer queue is allocated statically in case
 970:../FreeRTOS/Source/timers.c ****                          * configSUPPORT_DYNAMIC_ALLOCATION is 0. */
 971:../FreeRTOS/Source/timers.c ****                         PRIVILEGED_DATA static StaticQueue_t xStaticTimerQueue;                    
 972:../FreeRTOS/Source/timers.c ****                         PRIVILEGED_DATA static uint8_t ucStaticTimerQueueStorage[ ( size_t ) config
 973:../FreeRTOS/Source/timers.c **** 
 974:../FreeRTOS/Source/timers.c ****                         xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH,
 975:../FreeRTOS/Source/timers.c ****                     }
 976:../FreeRTOS/Source/timers.c ****                 #else
 977:../FreeRTOS/Source/timers.c ****                     {
 978:../FreeRTOS/Source/timers.c ****                         xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeo
 147              	 .loc 1 978 0
 148 0024 0520     	 movs r0,#5
 149 0026 0C21     	 movs r1,#12
 150 0028 0022     	 movs r2,#0
 151 002a FFF7FEFF 	 bl xQueueGenericCreate
 152              	.LVL20:
 153 002e 044B     	 ldr r3,.L13
 154 0030 1860     	 str r0,[r3]
 979:../FreeRTOS/Source/timers.c ****                     }
 980:../FreeRTOS/Source/timers.c ****                 #endif /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
 981:../FreeRTOS/Source/timers.c **** 
 982:../FreeRTOS/Source/timers.c ****                 #if ( configQUEUE_REGISTRY_SIZE > 0 )
 983:../FreeRTOS/Source/timers.c ****                     {
 984:../FreeRTOS/Source/timers.c ****                         if( xTimerQueue != NULL )
 155              	 .loc 1 984 0
 156 0032 10B1     	 cbz r0,.L11
 985:../FreeRTOS/Source/timers.c ****                         {
 986:../FreeRTOS/Source/timers.c ****                             vQueueAddToRegistry( xTimerQueue, "TmrQ" );
 157              	 .loc 1 986 0
 158 0034 0749     	 ldr r1,.L13+20
 159 0036 FFF7FEFF 	 bl vQueueAddToRegistry
 160              	.LVL21:
 161              	.L11:
 987:../FreeRTOS/Source/timers.c ****                         }
 988:../FreeRTOS/Source/timers.c ****                         else
 989:../FreeRTOS/Source/timers.c ****                         {
 990:../FreeRTOS/Source/timers.c ****                             mtCOVERAGE_TEST_MARKER();
 991:../FreeRTOS/Source/timers.c ****                         }
 992:../FreeRTOS/Source/timers.c ****                     }
 993:../FreeRTOS/Source/timers.c ****                 #endif /* configQUEUE_REGISTRY_SIZE */
 994:../FreeRTOS/Source/timers.c ****             }
 995:../FreeRTOS/Source/timers.c ****             else
 996:../FreeRTOS/Source/timers.c ****             {
 997:../FreeRTOS/Source/timers.c ****                 mtCOVERAGE_TEST_MARKER();
 998:../FreeRTOS/Source/timers.c ****             }
 999:../FreeRTOS/Source/timers.c ****         }
1000:../FreeRTOS/Source/timers.c ****         taskEXIT_CRITICAL();
 162              	 .loc 1 1000 0
 163 003a FFF7FEFF 	 bl vPortExitCritical
 164              	.LVL22:
 165 003e 38BD     	 pop {r3,r4,r5,pc}
 166              	.L14:
 167              	 .align 2
 168              	.L13:
 169 0040 00000000 	 .word .LANCHOR2
 170 0044 00000000 	 .word .LANCHOR3
 171 0048 00000000 	 .word .LANCHOR4
 172 004c 00000000 	 .word .LANCHOR1
 173 0050 00000000 	 .word .LANCHOR0
 174 0054 00000000 	 .word .LC0
 175              	 .cfi_endproc
 176              	.LFE23:
 178              	 .section .text.xTimerCreateTimerTask,"ax",%progbits
 179              	 .align 2
 180              	 .global xTimerCreateTimerTask
 181              	 .thumb
 182              	 .thumb_func
 184              	xTimerCreateTimerTask:
 185              	.LFB5:
 222:../FreeRTOS/Source/timers.c ****         BaseType_t xReturn = pdFAIL;
 186              	 .loc 1 222 0
 187              	 .cfi_startproc
 188              	 
 189              	 
 190 0000 00B5     	 push {lr}
 191              	.LCFI2:
 192              	 .cfi_def_cfa_offset 4
 193              	 .cfi_offset 14,-4
 194 0002 83B0     	 sub sp,sp,#12
 195              	.LCFI3:
 196              	 .cfi_def_cfa_offset 16
 197              	.LVL23:
 229:../FreeRTOS/Source/timers.c **** 
 198              	 .loc 1 229 0
 199 0004 FFF7FEFF 	 bl prvCheckForValidListAndQueue
 200              	.LVL24:
 231:../FreeRTOS/Source/timers.c ****         {
 201              	 .loc 1 231 0
 202 0008 0C4B     	 ldr r3,.L20
 203 000a 1B68     	 ldr r3,[r3]
 204 000c 53B1     	 cbz r3,.L16
 255:../FreeRTOS/Source/timers.c ****                                            configTIMER_SERVICE_TASK_NAME,
 205              	 .loc 1 255 0
 206 000e 0123     	 movs r3,#1
 207 0010 0093     	 str r3,[sp]
 208 0012 0B4B     	 ldr r3,.L20+4
 209 0014 0193     	 str r3,[sp,#4]
 210 0016 0B48     	 ldr r0,.L20+8
 211 0018 0B49     	 ldr r1,.L20+12
 212 001a F022     	 movs r2,#240
 213 001c 0023     	 movs r3,#0
 214 001e FFF7FEFF 	 bl xTaskCreate
 215              	.LVL25:
 269:../FreeRTOS/Source/timers.c ****         return xReturn;
 216              	 .loc 1 269 0
 217 0022 40B9     	 cbnz r0,.L17
 218              	.LVL26:
 219              	.L16:
 220              	.LBB34:
 221              	.LBB35:
 222              	 .file 2 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h"
   1:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*
   2:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * FreeRTOS Kernel V10.4.1
   3:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
   5:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * this software and associated documentation files (the "Software"), to deal in
   7:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * the Software without restriction, including without limitation the rights to
   8:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * subject to the following conditions:
  11:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  12:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * The above copyright notice and this permission notice shall be included in all
  13:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * copies or substantial portions of the Software.
  14:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  15:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  22:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * https://www.FreeRTOS.org
  23:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * https://github.com/FreeRTOS
  24:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  25:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * 1 tab == 4 spaces!
  26:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  */
  27:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  28:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  29:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** #ifndef PORTMACRO_H
  30:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define PORTMACRO_H
  31:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  32:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifdef __cplusplus
  33:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         extern "C" {
  34:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
  35:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  36:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------
  37:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * Port specific definitions.
  38:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  39:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * The settings in this file configure FreeRTOS correctly for the
  40:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * given hardware and compiler.
  41:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  42:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * These settings should not be altered.
  43:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *-----------------------------------------------------------
  44:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  */
  45:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  46:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Type definitions. */
  47:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portCHAR          char
  48:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portFLOAT         float
  49:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portDOUBLE        double
  50:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portLONG          long
  51:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portSHORT         short
  52:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portSTACK_TYPE    uint32_t
  53:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portBASE_TYPE     long
  54:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  55:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     typedef portSTACK_TYPE   StackType_t;
  56:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     typedef long             BaseType_t;
  57:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     typedef unsigned long    UBaseType_t;
  58:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  59:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #if ( configUSE_16_BIT_TICKS == 1 )
  60:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         typedef uint16_t     TickType_t;
  61:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portMAX_DELAY              ( TickType_t ) 0xffff
  62:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #else
  63:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         typedef uint32_t     TickType_t;
  64:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portMAX_DELAY              ( TickType_t ) 0xffffffffUL
  65:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  66:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
  67:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * not need to be guarded with a critical section. */
  68:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portTICK_TYPE_IS_ATOMIC    1
  69:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
  70:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
  71:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  72:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Architecture specifics. */
  73:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portSTACK_GROWTH      ( -1 )
  74:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portTICK_PERIOD_MS    ( ( TickType_t ) 1000 / configTICK_RATE_HZ )
  75:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portBYTE_ALIGNMENT    8
  76:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portDONT_DISCARD      __attribute__( ( used ) )
  77:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
  78:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  79:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Scheduler utilities. */
  80:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portYIELD()                                 \
  81:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     {                                                   \
  82:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         /* Set a PendSV to request a context switch. */ \
  83:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT; \
  84:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****                                                         \
  85:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         /* Barriers are normally not required but do ensure the code is completely \
  86:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****          * within the specified behaviour for the architecture. */ \
  87:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile ( "dsb" ::: "memory" );                     \
  88:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile ( "isb" );                                  \
  89:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     }
  90:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  91:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portNVIC_INT_CTRL_REG     ( *( ( volatile uint32_t * ) 0xe000ed04 ) )
  92:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portNVIC_PENDSVSET_BIT    ( 1UL << 28UL )
  93:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portEND_SWITCHING_ISR( xSwitchRequired )    if( xSwitchRequired != pdFALSE ) portYIELD(
  94:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portYIELD_FROM_ISR( x )                     portEND_SWITCHING_ISR( x )
  95:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
  96:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  97:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Critical section management. */
  98:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     extern void vPortEnterCritical( void );
  99:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     extern void vPortExitCritical( void );
 100:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portSET_INTERRUPT_MASK_FROM_ISR()         ulPortRaiseBASEPRI()
 101:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portCLEAR_INTERRUPT_MASK_FROM_ISR( x )    vPortSetBASEPRI( x )
 102:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portDISABLE_INTERRUPTS()                  vPortRaiseBASEPRI()
 103:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portENABLE_INTERRUPTS()                   vPortSetBASEPRI( 0 )
 104:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portENTER_CRITICAL()                      vPortEnterCritical()
 105:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portEXIT_CRITICAL()                       vPortExitCritical()
 106:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 107:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 108:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 109:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Task function macros as described on the FreeRTOS.org WEB site.  These are
 110:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * not necessary for to use this port.  They are defined so the common demo files
 111:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * (which build with all the ports) will build. */
 112:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portTASK_FUNCTION_PROTO( vFunction, pvParameters )    void vFunction( void * pvParamete
 113:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portTASK_FUNCTION( vFunction, pvParameters )          void vFunction( void * pvParamete
 114:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 115:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 116:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Tickless idle/low power functionality. */
 117:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifndef portSUPPRESS_TICKS_AND_SLEEP
 118:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
 119:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime )    vPortSuppressTicksAndSleep( xE
 120:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
 121:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 122:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 123:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Architecture specific optimisations. */
 124:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
 125:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define configUSE_PORT_OPTIMISED_TASK_SELECTION    1
 126:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
 127:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 128:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
 129:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 130:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Generic helper function. */
 131:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t 
 132:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         {
 133:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             uint8_t ucReturn;
 134:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 135:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             __asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 136:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 137:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             return ucReturn;
 138:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         }
 139:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 140:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Check the configuration. */
 141:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #if ( configMAX_PRIORITIES > 32 )
 142:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             #error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIO
 143:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #endif
 144:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 145:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Store/clear the ready priorities in a bit map. */
 146:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities )    ( uxReadyPriorities )
 147:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities )     ( uxReadyPriorities )
 148:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 149:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 150:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 151:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities )    uxTopPriority = ( 3
 152:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 153:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 154:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 155:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 156:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 157:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifdef configASSERT
 158:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         void vPortValidateInterruptPriority( void );
 159:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portASSERT_IF_INTERRUPT_PRIORITY_INVALID()    vPortValidateInterruptPriority()
 160:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
 161:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 162:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* portNOP() is not required by this port. */
 163:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portNOP()
 164:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 165:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portINLINE              __inline
 166:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 167:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifndef portFORCE_INLINE
 168:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portFORCE_INLINE    inline __attribute__( ( always_inline ) )
 169:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
 170:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 171:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     portFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )
 172:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     {
 173:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         uint32_t ulCurrentInterrupt;
 174:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         BaseType_t xReturn;
 175:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 176:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         /* Obtain the number of the currently executing interrupt. */
 177:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile ( "mrs %0, ipsr" : "=r" ( ulCurrentInterrupt )::"memory" );
 178:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 179:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         if( ulCurrentInterrupt == 0 )
 180:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         {
 181:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             xReturn = pdFALSE;
 182:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         }
 183:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         else
 184:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         {
 185:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             xReturn = pdTRUE;
 186:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         }
 187:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 188:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         return xReturn;
 189:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     }
 190:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 191:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 192:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 193:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     portFORCE_INLINE static void vPortRaiseBASEPRI( void )
 194:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     {
 195:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         uint32_t ulNewBASEPRI;
 196:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile
 223              	 .loc 2 197 0
 224              	
 225 0024 4FF01403 	 mov r3,#20
 226 0028 83F31188 	 msr basepri,r3
 227 002c BFF36F8F 	 isb 
 228 0030 BFF34F8F 	 dsb 
 229              	
 230              	
 231              	.LVL27:
 232              	 .thumb
 233              	.L18:
 234              	.LBE35:
 235              	.LBE34:
 269:../FreeRTOS/Source/timers.c ****         return xReturn;
 236              	 .loc 1 269 0 discriminator 1
 237 0034 FEE7     	 b .L18
 238              	.LVL28:
 239              	.L17:
 271:../FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 240              	 .loc 1 271 0
 241 0036 03B0     	 add sp,sp,#12
 242              	.LCFI4:
 243              	 .cfi_def_cfa_offset 4
 244              	 
 245 0038 5DF804FB 	 ldr pc,[sp],#4
 246              	.L21:
 247              	 .align 2
 248              	.L20:
 249 003c 00000000 	 .word .LANCHOR2
 250 0040 00000000 	 .word .LANCHOR5
 251 0044 00000000 	 .word prvTimerTask
 252 0048 08000000 	 .word .LC1
 253              	 .cfi_endproc
 254              	.LFE5:
 256              	 .section .text.xTimerCreate,"ax",%progbits
 257              	 .align 2
 258              	 .global xTimerCreate
 259              	 .thumb
 260              	 .thumb_func
 262              	xTimerCreate:
 263              	.LFB6:
 281:../FreeRTOS/Source/timers.c ****             Timer_t * pxNewTimer;
 264              	 .loc 1 281 0
 265              	 .cfi_startproc
 266              	 
 267              	 
 268              	.LVL29:
 269 0000 2DE9F041 	 push {r4,r5,r6,r7,r8,lr}
 270              	.LCFI5:
 271              	 .cfi_def_cfa_offset 24
 272              	 .cfi_offset 4,-24
 273              	 .cfi_offset 5,-20
 274              	 .cfi_offset 6,-16
 275              	 .cfi_offset 7,-12
 276              	 .cfi_offset 8,-8
 277              	 .cfi_offset 14,-4
 278 0004 8046     	 mov r8,r0
 279 0006 0D46     	 mov r5,r1
 280 0008 1646     	 mov r6,r2
 281 000a 1F46     	 mov r7,r3
 284:../FreeRTOS/Source/timers.c **** 
 282              	 .loc 1 284 0
 283 000c 2C20     	 movs r0,#44
 284              	.LVL30:
 285 000e FFF7FEFF 	 bl pvPortMalloc
 286              	.LVL31:
 286:../FreeRTOS/Source/timers.c ****             {
 287              	 .loc 1 286 0
 288 0012 0446     	 mov r4,r0
 289 0014 F0B1     	 cbz r0,.L23
 291:../FreeRTOS/Source/timers.c ****                 prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, p
 290              	 .loc 1 291 0
 291 0016 0023     	 movs r3,#0
 292 0018 80F82830 	 strb r3,[r0,#40]
 293              	.LVL32:
 294              	.LBB40:
 295              	.LBB41:
 351:../FreeRTOS/Source/timers.c **** 
 296              	 .loc 1 351 0
 297 001c 45B9     	 cbnz r5,.L24
 298              	.LBB42:
 299              	.LBB43:
 300              	 .loc 2 197 0
 301              	
 302 001e 4FF01403 	 mov r3,#20
 303 0022 83F31188 	 msr basepri,r3
 304 0026 BFF36F8F 	 isb 
 305 002a BFF34F8F 	 dsb 
 306              	
 307              	
 308              	.LVL33:
 309              	 .thumb
 310              	.L25:
 311 002e FEE7     	 b .L25
 312              	.L24:
 313              	.LBE43:
 314              	.LBE42:
 357:../FreeRTOS/Source/timers.c **** 
 315              	 .loc 1 357 0
 316 0030 FFF7FEFF 	 bl prvCheckForValidListAndQueue
 317              	.LVL34:
 361:../FreeRTOS/Source/timers.c ****             pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
 318              	 .loc 1 361 0
 319 0034 C4F80080 	 str r8,[r4]
 362:../FreeRTOS/Source/timers.c ****             pxNewTimer->pvTimerID = pvTimerID;
 320              	 .loc 1 362 0
 321 0038 A561     	 str r5,[r4,#24]
 363:../FreeRTOS/Source/timers.c ****             pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 322              	 .loc 1 363 0
 323 003a E761     	 str r7,[r4,#28]
 364:../FreeRTOS/Source/timers.c ****             vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 324              	 .loc 1 364 0
 325 003c 069B     	 ldr r3,[sp,#24]
 326 003e 2362     	 str r3,[r4,#32]
 365:../FreeRTOS/Source/timers.c **** 
 327              	 .loc 1 365 0
 328 0040 201D     	 adds r0,r4,#4
 329 0042 FFF7FEFF 	 bl vListInitialiseItem
 330              	.LVL35:
 367:../FreeRTOS/Source/timers.c ****             {
 331              	 .loc 1 367 0
 332 0046 2EB1     	 cbz r6,.L23
 369:../FreeRTOS/Source/timers.c ****             }
 333              	 .loc 1 369 0
 334 0048 94F82830 	 ldrb r3,[r4,#40]
 335 004c 43F00403 	 orr r3,r3,#4
 336 0050 84F82830 	 strb r3,[r4,#40]
 337              	.LVL36:
 338              	.L23:
 339              	.LBE41:
 340              	.LBE40:
 296:../FreeRTOS/Source/timers.c **** 
 341              	 .loc 1 296 0
 342 0054 2046     	 mov r0,r4
 343 0056 BDE8F081 	 pop {r4,r5,r6,r7,r8,pc}
 344              	 .cfi_endproc
 345              	.LFE6:
 347 005a 00BF     	 .section .text.xTimerGenericCommand,"ax",%progbits
 348              	 .align 2
 349              	 .global xTimerGenericCommand
 350              	 .thumb
 351              	 .thumb_func
 353              	xTimerGenericCommand:
 354              	.LFB8:
 382:../FreeRTOS/Source/timers.c ****         BaseType_t xReturn = pdFAIL;
 355              	 .loc 1 382 0
 356              	 .cfi_startproc
 357              	 
 358              	 
 359              	.LVL37:
 386:../FreeRTOS/Source/timers.c **** 
 360              	 .loc 1 386 0
 361 0000 40B9     	 cbnz r0,.L28
 362              	.LBB44:
 363              	.LBB45:
 364              	 .loc 2 197 0
 365              	
 366 0002 4FF01403 	 mov r3,#20
 367 0006 83F31188 	 msr basepri,r3
 368 000a BFF36F8F 	 isb 
 369 000e BFF34F8F 	 dsb 
 370              	
 371              	
 372              	.LVL38:
 373              	 .thumb
 374              	.L29:
 375              	.LBE45:
 376              	.LBE44:
 386:../FreeRTOS/Source/timers.c **** 
 377              	 .loc 1 386 0 discriminator 1
 378 0012 FEE7     	 b .L29
 379              	.LVL39:
 380              	.L28:
 382:../FreeRTOS/Source/timers.c ****         BaseType_t xReturn = pdFAIL;
 381              	 .loc 1 382 0
 382 0014 30B5     	 push {r4,r5,lr}
 383              	.LCFI6:
 384              	 .cfi_def_cfa_offset 12
 385              	 .cfi_offset 4,-12
 386              	 .cfi_offset 5,-8
 387              	 .cfi_offset 14,-4
 388 0016 85B0     	 sub sp,sp,#20
 389              	.LCFI7:
 390              	 .cfi_def_cfa_offset 32
 391 0018 1546     	 mov r5,r2
 392 001a 0446     	 mov r4,r0
 390:../FreeRTOS/Source/timers.c ****         {
 393              	 .loc 1 390 0
 394 001c 0F4A     	 ldr r2,.L35
 395              	.LVL40:
 396 001e 1068     	 ldr r0,[r2]
 397              	.LVL41:
 398 0020 C0B1     	 cbz r0,.L33
 399 0022 1A46     	 mov r2,r3
 393:../FreeRTOS/Source/timers.c ****             xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 400              	 .loc 1 393 0
 401 0024 0191     	 str r1,[sp,#4]
 394:../FreeRTOS/Source/timers.c ****             xMessage.u.xTimerParameters.pxTimer = xTimer;
 402              	 .loc 1 394 0
 403 0026 0295     	 str r5,[sp,#8]
 395:../FreeRTOS/Source/timers.c **** 
 404              	 .loc 1 395 0
 405 0028 0394     	 str r4,[sp,#12]
 397:../FreeRTOS/Source/timers.c ****             {
 406              	 .loc 1 397 0
 407 002a 0529     	 cmp r1,#5
 408 002c 0DDC     	 bgt .L31
 409              	.LVL42:
 399:../FreeRTOS/Source/timers.c ****                 {
 410              	 .loc 1 399 0
 411 002e FFF7FEFF 	 bl xTaskGetSchedulerState
 412              	.LVL43:
 413 0032 0228     	 cmp r0,#2
 401:../FreeRTOS/Source/timers.c ****                 }
 414              	 .loc 1 401 0
 415 0034 094B     	 ldr r3,.L35
 416 0036 1868     	 ldr r0,[r3]
 417 0038 01A9     	 add r1,sp,#4
 418 003a 07BF     	 ittee eq
 419 003c 089A     	 ldreq r2,[sp,#32]
 420 003e 0023     	 moveq r3,#0
 405:../FreeRTOS/Source/timers.c ****                 }
 421              	 .loc 1 405 0
 422 0040 0022     	 movne r2,#0
 423 0042 1346     	 movne r3,r2
 424 0044 FFF7FEFF 	 bl xQueueGenericSend
 425              	.LVL44:
 426 0048 05E0     	 b .L30
 427              	.LVL45:
 428              	.L31:
 410:../FreeRTOS/Source/timers.c ****             }
 429              	 .loc 1 410 0
 430 004a 01A9     	 add r1,sp,#4
 431              	.LVL46:
 432 004c 0023     	 movs r3,#0
 433 004e FFF7FEFF 	 bl xQueueGenericSendFromISR
 434              	.LVL47:
 435 0052 00E0     	 b .L30
 436              	.LVL48:
 437              	.L33:
 383:../FreeRTOS/Source/timers.c ****         DaemonTaskMessage_t xMessage;
 438              	 .loc 1 383 0
 439 0054 0020     	 movs r0,#0
 440              	.LVL49:
 441              	.L30:
 421:../FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 442              	 .loc 1 421 0
 443 0056 05B0     	 add sp,sp,#20
 444              	.LCFI8:
 445              	 .cfi_def_cfa_offset 12
 446              	 
 447 0058 30BD     	 pop {r4,r5,pc}
 448              	.LVL50:
 449              	.L36:
 450 005a 00BF     	 .align 2
 451              	.L35:
 452 005c 00000000 	 .word .LANCHOR2
 453              	 .cfi_endproc
 454              	.LFE8:
 456              	 .section .text.prvSampleTimeNow,"ax",%progbits
 457              	 .align 2
 458              	 .thumb
 459              	 .thumb_func
 461              	prvSampleTimeNow:
 462              	.LFB19:
 677:../FreeRTOS/Source/timers.c ****         TickType_t xTimeNow;
 463              	 .loc 1 677 0
 464              	 .cfi_startproc
 465              	 
 466              	 
 467              	.LVL51:
 468 0000 2DE9F047 	 push {r4,r5,r6,r7,r8,r9,r10,lr}
 469              	.LCFI9:
 470              	 .cfi_def_cfa_offset 32
 471              	 .cfi_offset 4,-32
 472              	 .cfi_offset 5,-28
 473              	 .cfi_offset 6,-24
 474              	 .cfi_offset 7,-20
 475              	 .cfi_offset 8,-16
 476              	 .cfi_offset 9,-12
 477              	 .cfi_offset 10,-8
 478              	 .cfi_offset 14,-4
 479 0004 82B0     	 sub sp,sp,#8
 480              	.LCFI10:
 481              	 .cfi_def_cfa_offset 40
 482 0006 0746     	 mov r7,r0
 681:../FreeRTOS/Source/timers.c **** 
 483              	 .loc 1 681 0
 484 0008 FFF7FEFF 	 bl xTaskGetTickCount
 485              	.LVL52:
 486 000c 0646     	 mov r6,r0
 487              	.LVL53:
 683:../FreeRTOS/Source/timers.c ****         {
 488              	 .loc 1 683 0
 489 000e 254B     	 ldr r3,.L50
 490 0010 1B68     	 ldr r3,[r3]
 491 0012 9842     	 cmp r0,r3
 492 0014 3DD2     	 bcs .L48
 493 0016 2DE0     	 b .L38
 494              	.LVL54:
 495              	.L44:
 496              	.LBB50:
 497              	.LBB51:
 906:../FreeRTOS/Source/timers.c **** 
 498              	 .loc 1 906 0
 499 0018 DB68     	 ldr r3,[r3,#12]
 500 001a D3F800A0 	 ldr r10,[r3]
 501              	.LVL55:
 909:../FreeRTOS/Source/timers.c ****             ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 502              	 .loc 1 909 0
 503 001e DC68     	 ldr r4,[r3,#12]
 504              	.LVL56:
 910:../FreeRTOS/Source/timers.c ****             traceTIMER_EXPIRED( pxTimer );
 505              	 .loc 1 910 0
 506 0020 04F10409 	 add r9,r4,#4
 507 0024 4846     	 mov r0,r9
 508 0026 FFF7FEFF 	 bl uxListRemove
 509              	.LVL57:
 916:../FreeRTOS/Source/timers.c **** 
 510              	 .loc 1 916 0
 511 002a 236A     	 ldr r3,[r4,#32]
 512 002c 2046     	 mov r0,r4
 513 002e 9847     	 blx r3
 514              	.LVL58:
 918:../FreeRTOS/Source/timers.c ****             {
 515              	 .loc 1 918 0
 516 0030 94F82830 	 ldrb r3,[r4,#40]
 517 0034 13F0040F 	 tst r3,#4
 518 0038 1FD0     	 beq .L40
 926:../FreeRTOS/Source/timers.c **** 
 519              	 .loc 1 926 0
 520 003a A369     	 ldr r3,[r4,#24]
 521 003c 5344     	 add r3,r3,r10
 522              	.LVL59:
 928:../FreeRTOS/Source/timers.c ****                 {
 523              	 .loc 1 928 0
 524 003e 5345     	 cmp r3,r10
 525 0040 06D9     	 bls .L41
 930:../FreeRTOS/Source/timers.c ****                     listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 526              	 .loc 1 930 0
 527 0042 6360     	 str r3,[r4,#4]
 931:../FreeRTOS/Source/timers.c ****                     vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 528              	 .loc 1 931 0
 529 0044 2461     	 str r4,[r4,#16]
 932:../FreeRTOS/Source/timers.c ****                 }
 530              	 .loc 1 932 0
 531 0046 2868     	 ldr r0,[r5]
 532 0048 4946     	 mov r1,r9
 533 004a FFF7FEFF 	 bl vListInsert
 534              	.LVL60:
 535 004e 14E0     	 b .L40
 536              	.LVL61:
 537              	.L41:
 936:../FreeRTOS/Source/timers.c ****                     configASSERT( xResult );
 538              	 .loc 1 936 0
 539 0050 CDF80080 	 str r8,[sp]
 540 0054 2046     	 mov r0,r4
 541 0056 4146     	 mov r1,r8
 542 0058 5246     	 mov r2,r10
 543 005a 4346     	 mov r3,r8
 544              	.LVL62:
 545 005c FFF7FEFF 	 bl xTimerGenericCommand
 546              	.LVL63:
 937:../FreeRTOS/Source/timers.c ****                     ( void ) xResult;
 547              	 .loc 1 937 0
 548 0060 58B9     	 cbnz r0,.L40
 549              	.LBB52:
 550              	.LBB53:
 551              	 .loc 2 197 0
 552              	
 553 0062 4FF01403 	 mov r3,#20
 554 0066 83F31188 	 msr basepri,r3
 555 006a BFF36F8F 	 isb 
 556 006e BFF34F8F 	 dsb 
 557              	
 558              	
 559              	.LVL64:
 560              	 .thumb
 561              	.L43:
 562 0072 FEE7     	 b .L43
 563              	.LVL65:
 564              	.L38:
 565              	.LBE53:
 566              	.LBE52:
 904:../FreeRTOS/Source/timers.c ****         {
 567              	 .loc 1 904 0
 568 0074 0C4D     	 ldr r5,.L50+4
 936:../FreeRTOS/Source/timers.c ****                     configASSERT( xResult );
 569              	 .loc 1 936 0
 570 0076 4FF00008 	 mov r8,#0
 571              	.LVL66:
 572              	.L40:
 904:../FreeRTOS/Source/timers.c ****         {
 573              	 .loc 1 904 0
 574 007a 2B68     	 ldr r3,[r5]
 575 007c 1A68     	 ldr r2,[r3]
 576 007e 002A     	 cmp r2,#0
 577 0080 CAD1     	 bne .L44
 578              	.LVL67:
 948:../FreeRTOS/Source/timers.c ****         pxOverflowTimerList = pxTemp;
 579              	 .loc 1 948 0
 580 0082 0A4A     	 ldr r2,.L50+8
 581 0084 1068     	 ldr r0,[r2]
 582 0086 0849     	 ldr r1,.L50+4
 583 0088 0860     	 str r0,[r1]
 949:../FreeRTOS/Source/timers.c ****     }
 584              	 .loc 1 949 0
 585 008a 1360     	 str r3,[r2]
 586              	.LBE51:
 587              	.LBE50:
 686:../FreeRTOS/Source/timers.c ****         }
 588              	 .loc 1 686 0
 589 008c 0123     	 movs r3,#1
 590              	.LVL68:
 591 008e 3B60     	 str r3,[r7]
 592 0090 01E0     	 b .L45
 593              	.LVL69:
 594              	.L48:
 690:../FreeRTOS/Source/timers.c ****         }
 595              	 .loc 1 690 0
 596 0092 0023     	 movs r3,#0
 597 0094 3B60     	 str r3,[r7]
 598              	.LVL70:
 599              	.L45:
 693:../FreeRTOS/Source/timers.c **** 
 600              	 .loc 1 693 0
 601 0096 034B     	 ldr r3,.L50
 602 0098 1E60     	 str r6,[r3]
 696:../FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 603              	 .loc 1 696 0
 604 009a 3046     	 mov r0,r6
 605 009c 02B0     	 add sp,sp,#8
 606              	.LCFI11:
 607              	 .cfi_def_cfa_offset 32
 608              	 
 609 009e BDE8F087 	 pop {r4,r5,r6,r7,r8,r9,r10,pc}
 610              	.LVL71:
 611              	.L51:
 612 00a2 00BF     	 .align 2
 613              	.L50:
 614 00a4 00000000 	 .word .LANCHOR6
 615 00a8 00000000 	 .word .LANCHOR1
 616 00ac 00000000 	 .word .LANCHOR0
 617              	 .cfi_endproc
 618              	.LFE19:
 620              	 .section .text.prvTimerTask,"ax",%progbits
 621              	 .align 2
 622              	 .thumb
 623              	 .thumb_func
 625              	prvTimerTask:
 626              	.LFB16:
 552:../FreeRTOS/Source/timers.c ****         TickType_t xNextExpireTime;
 627              	 .loc 1 552 0
 628              	 .cfi_startproc
 629              	 
 630              	 
 631              	.LVL72:
 632 0000 2DE9F047 	 push {r4,r5,r6,r7,r8,r9,r10,lr}
 633              	.LCFI12:
 634              	 .cfi_def_cfa_offset 32
 635              	 .cfi_offset 4,-32
 636              	 .cfi_offset 5,-28
 637              	 .cfi_offset 6,-24
 638              	 .cfi_offset 7,-20
 639              	 .cfi_offset 8,-16
 640              	 .cfi_offset 9,-12
 641              	 .cfi_offset 10,-8
 642              	 .cfi_offset 14,-4
 643 0004 86B0     	 sub sp,sp,#24
 644              	.LCFI13:
 645              	 .cfi_def_cfa_offset 56
 646              	.LBB68:
 647              	.LBB69:
 660:../FreeRTOS/Source/timers.c **** 
 648              	 .loc 1 660 0
 649 0006 734E     	 ldr r6,.L82
 650              	.LBE69:
 651              	.LBE68:
 652              	.LBB72:
 653              	.LBB73:
 625:../FreeRTOS/Source/timers.c **** 
 654              	 .loc 1 625 0
 655 0008 734D     	 ldr r5,.L82+4
 633:../FreeRTOS/Source/timers.c ****                     }
 656              	 .loc 1 633 0
 657 000a DFF8D481 	 ldr r8,.L82+12
 622:../FreeRTOS/Source/timers.c ****                     }
 658              	 .loc 1 622 0
 659 000e 734F     	 ldr r7,.L82+8
 660              	.LVL73:
 661              	.L77:
 662              	.LBE73:
 663              	.LBE72:
 664              	.LBB80:
 665              	.LBB70:
 660:../FreeRTOS/Source/timers.c **** 
 666              	 .loc 1 660 0 discriminator 1
 667 0010 3368     	 ldr r3,[r6]
 668 0012 1A68     	 ldr r2,[r3]
 669              	.LVL74:
 662:../FreeRTOS/Source/timers.c ****         {
 670              	 .loc 1 662 0 discriminator 1
 671 0014 5AB1     	 cbz r2,.L53
 664:../FreeRTOS/Source/timers.c ****         }
 672              	 .loc 1 664 0
 673 0016 DB68     	 ldr r3,[r3,#12]
 674 0018 D3F80090 	 ldr r9,[r3]
 675              	.LVL75:
 676              	.LBE70:
 677              	.LBE80:
 678              	.LBB81:
 679              	.LBB78:
 593:../FreeRTOS/Source/timers.c ****         {
 680              	 .loc 1 593 0
 681 001c FFF7FEFF 	 bl vTaskSuspendAll
 682              	.LVL76:
 600:../FreeRTOS/Source/timers.c **** 
 683              	 .loc 1 600 0
 684 0020 03A8     	 add r0,sp,#12
 685 0022 FFF7FEFF 	 bl prvSampleTimeNow
 686              	.LVL77:
 687 0026 0446     	 mov r4,r0
 688              	.LVL78:
 602:../FreeRTOS/Source/timers.c ****             {
 689              	 .loc 1 602 0
 690 0028 039B     	 ldr r3,[sp,#12]
 691 002a 4BB1     	 cbz r3,.L54
 692 002c 58E0     	 b .L55
 693              	.LVL79:
 694              	.L53:
 593:../FreeRTOS/Source/timers.c ****         {
 695              	 .loc 1 593 0
 696 002e FFF7FEFF 	 bl vTaskSuspendAll
 697              	.LVL80:
 600:../FreeRTOS/Source/timers.c **** 
 698              	 .loc 1 600 0
 699 0032 03A8     	 add r0,sp,#12
 700 0034 FFF7FEFF 	 bl prvSampleTimeNow
 701              	.LVL81:
 702 0038 0446     	 mov r4,r0
 703              	.LVL82:
 602:../FreeRTOS/Source/timers.c ****             {
 704              	 .loc 1 602 0
 705 003a 039B     	 ldr r3,[sp,#12]
 706 003c B3B3     	 cbz r3,.L56
 707 003e 4FE0     	 b .L55
 708              	.LVL83:
 709              	.L54:
 605:../FreeRTOS/Source/timers.c ****                 {
 710              	 .loc 1 605 0
 711 0040 8145     	 cmp r9,r0
 712 0042 88BF     	 it hi
 713 0044 0022     	 movhi r2,#0
 714 0046 39D8     	 bhi .L57
 607:../FreeRTOS/Source/timers.c ****                     prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
 715              	 .loc 1 607 0
 716 0048 FFF7FEFF 	 bl xTaskResumeAll
 717              	.LVL84:
 718              	.LBB74:
 719              	.LBB75:
 512:../FreeRTOS/Source/timers.c **** 
 720              	 .loc 1 512 0
 721 004c 3368     	 ldr r3,[r6]
 722 004e DB68     	 ldr r3,[r3,#12]
 723 0050 D3F80CA0 	 ldr r10,[r3,#12]
 724              	.LVL85:
 517:../FreeRTOS/Source/timers.c ****         traceTIMER_EXPIRED( pxTimer );
 725              	 .loc 1 517 0
 726 0054 0AF10400 	 add r0,r10,#4
 727 0058 FFF7FEFF 	 bl uxListRemove
 728              	.LVL86:
 522:../FreeRTOS/Source/timers.c ****         {
 729              	 .loc 1 522 0
 730 005c 9AF82830 	 ldrb r3,[r10,#40]
 731 0060 13F0040F 	 tst r3,#4
 732 0064 19D0     	 beq .L58
 527:../FreeRTOS/Source/timers.c ****             {
 733              	 .loc 1 527 0
 734 0066 DAF81810 	 ldr r1,[r10,#24]
 735 006a 5046     	 mov r0,r10
 736 006c 4944     	 add r1,r1,r9
 737 006e 2246     	 mov r2,r4
 738 0070 4B46     	 mov r3,r9
 739 0072 FFF7FEFF 	 bl prvInsertTimerInActiveList
 740              	.LVL87:
 741 0076 A0B1     	 cbz r0,.L59
 531:../FreeRTOS/Source/timers.c ****                 configASSERT( xResult );
 742              	 .loc 1 531 0
 743 0078 0023     	 movs r3,#0
 744 007a 0093     	 str r3,[sp]
 745 007c 5046     	 mov r0,r10
 746 007e 1946     	 mov r1,r3
 747 0080 4A46     	 mov r2,r9
 748 0082 FFF7FEFF 	 bl xTimerGenericCommand
 749              	.LVL88:
 532:../FreeRTOS/Source/timers.c ****                 ( void ) xResult;
 750              	 .loc 1 532 0
 751 0086 60B9     	 cbnz r0,.L59
 752              	.LBB76:
 753              	.LBB77:
 754              	 .loc 2 197 0
 755              	
 756 0088 4FF01403 	 mov r3,#20
 757 008c 83F31188 	 msr basepri,r3
 758 0090 BFF36F8F 	 isb 
 759 0094 BFF34F8F 	 dsb 
 760              	
 761              	
 762              	.LVL89:
 763              	 .thumb
 764              	.L60:
 765 0098 FEE7     	 b .L60
 766              	.LVL90:
 767              	.L58:
 768              	.LBE77:
 769              	.LBE76:
 542:../FreeRTOS/Source/timers.c ****             mtCOVERAGE_TEST_MARKER();
 770              	 .loc 1 542 0
 771 009a 23F00103 	 bic r3,r3,#1
 772 009e 8AF82830 	 strb r3,[r10,#40]
 773              	.L59:
 547:../FreeRTOS/Source/timers.c ****     }
 774              	 .loc 1 547 0
 775 00a2 DAF82030 	 ldr r3,[r10,#32]
 776 00a6 5046     	 mov r0,r10
 777 00a8 9847     	 blx r3
 778              	.LVL91:
 779 00aa 8AE0     	 b .L65
 780              	.LVL92:
 781              	.L56:
 782              	.LBE75:
 783              	.LBE74:
 622:../FreeRTOS/Source/timers.c ****                     }
 784              	 .loc 1 622 0
 785 00ac 3B68     	 ldr r3,[r7]
 786 00ae 1A68     	 ldr r2,[r3]
 787 00b0 B2FA82F2 	 clz r2,r2
 788 00b4 5209     	 lsrs r2,r2,#5
 789              	.LBE78:
 790              	.LBE81:
 791              	.LBB82:
 792              	.LBB71:
 669:../FreeRTOS/Source/timers.c ****         }
 793              	 .loc 1 669 0
 794 00b6 4FF00009 	 mov r9,#0
 795 00ba FFE7     	 b .L57
 796              	.LVL93:
 797              	.L57:
 798              	.LBE71:
 799              	.LBE82:
 800              	.LBB83:
 801              	.LBB79:
 625:../FreeRTOS/Source/timers.c **** 
 802              	 .loc 1 625 0
 803 00bc 2868     	 ldr r0,[r5]
 804              	.LVL94:
 805 00be C4EB0901 	 rsb r1,r4,r9
 806 00c2 FFF7FEFF 	 bl vQueueWaitForMessageRestricted
 807              	.LVL95:
 627:../FreeRTOS/Source/timers.c ****                     {
 808              	 .loc 1 627 0
 809 00c6 FFF7FEFF 	 bl xTaskResumeAll
 810              	.LVL96:
 811 00ca 0028     	 cmp r0,#0
 812 00cc 79D1     	 bne .L65
 633:../FreeRTOS/Source/timers.c ****                     }
 813              	 .loc 1 633 0
 814 00ce 4FF08053 	 mov r3,#268435456
 815 00d2 C8F80030 	 str r3,[r8]
 816              	
 817 00d6 BFF34F8F 	 dsb
 818              	
 819              	
 820 00da BFF36F8F 	 isb
 821              	
 822              	 .thumb
 823 00de 70E0     	 b .L65
 824              	.LVL97:
 825              	.L55:
 643:../FreeRTOS/Source/timers.c ****             }
 826              	 .loc 1 643 0
 827 00e0 FFF7FEFF 	 bl xTaskResumeAll
 828              	.LVL98:
 829 00e4 6DE0     	 b .L65
 830              	.LVL99:
 831              	.L76:
 832              	.LBE79:
 833              	.LBE83:
 834              	.LBB84:
 835              	.LBB85:
 776:../FreeRTOS/Source/timers.c ****             {
 836              	 .loc 1 776 0
 837 00e6 039B     	 ldr r3,[sp,#12]
 838 00e8 002B     	 cmp r3,#0
 839 00ea 6BDB     	 blt .L63
 780:../FreeRTOS/Source/timers.c **** 
 840              	 .loc 1 780 0
 841 00ec 059C     	 ldr r4,[sp,#20]
 842              	.LVL100:
 782:../FreeRTOS/Source/timers.c ****                 {
 843              	 .loc 1 782 0
 844 00ee 6369     	 ldr r3,[r4,#20]
 845 00f0 13B1     	 cbz r3,.L64
 785:../FreeRTOS/Source/timers.c ****                 }
 846              	 .loc 1 785 0
 847 00f2 201D     	 adds r0,r4,#4
 848 00f4 FFF7FEFF 	 bl uxListRemove
 849              	.LVL101:
 850              	.L64:
 800:../FreeRTOS/Source/timers.c **** 
 851              	 .loc 1 800 0
 852 00f8 02A8     	 add r0,sp,#8
 853 00fa FFF7FEFF 	 bl prvSampleTimeNow
 854              	.LVL102:
 855 00fe 8646     	 mov lr,r0
 856              	.LVL103:
 802:../FreeRTOS/Source/timers.c ****                 {
 857              	 .loc 1 802 0
 858 0100 039A     	 ldr r2,[sp,#12]
 859 0102 092A     	 cmp r2,#9
 860 0104 5DD8     	 bhi .L65
 861 0106 DFE802F0 	 tbb [pc,r2]
 862              	.L67:
 863 010a 05       	 .byte (.L66-.L67)/2
 864 010b 05       	 .byte (.L66-.L67)/2
 865 010c 05       	 .byte (.L66-.L67)/2
 866 010d 2F       	 .byte (.L68-.L67)/2
 867 010e 36       	 .byte (.L69-.L67)/2
 868 010f 4F       	 .byte (.L70-.L67)/2
 869 0110 05       	 .byte (.L66-.L67)/2
 870 0111 05       	 .byte (.L66-.L67)/2
 871 0112 2F       	 .byte (.L68-.L67)/2
 872 0113 36       	 .byte (.L69-.L67)/2
 873              	 .p2align 1
 874              	.L66:
 810:../FreeRTOS/Source/timers.c **** 
 875              	 .loc 1 810 0
 876 0114 94F82830 	 ldrb r3,[r4,#40]
 877 0118 43F00103 	 orr r3,r3,#1
 878 011c 84F82830 	 strb r3,[r4,#40]
 812:../FreeRTOS/Source/timers.c ****                         {
 879              	 .loc 1 812 0
 880 0120 049B     	 ldr r3,[sp,#16]
 881 0122 A169     	 ldr r1,[r4,#24]
 882 0124 2046     	 mov r0,r4
 883              	.LVL104:
 884 0126 1944     	 add r1,r1,r3
 885 0128 7246     	 mov r2,lr
 886 012a FFF7FEFF 	 bl prvInsertTimerInActiveList
 887              	.LVL105:
 888 012e 0028     	 cmp r0,#0
 889 0130 47D0     	 beq .L65
 816:../FreeRTOS/Source/timers.c ****                             traceTIMER_EXPIRED( pxTimer );
 890              	 .loc 1 816 0
 891 0132 236A     	 ldr r3,[r4,#32]
 892 0134 2046     	 mov r0,r4
 893 0136 9847     	 blx r3
 894              	.LVL106:
 819:../FreeRTOS/Source/timers.c ****                             {
 895              	 .loc 1 819 0
 896 0138 94F82830 	 ldrb r3,[r4,#40]
 897 013c 13F0040F 	 tst r3,#4
 898 0140 3FD0     	 beq .L65
 821:../FreeRTOS/Source/timers.c ****                                 configASSERT( xResult );
 899              	 .loc 1 821 0
 900 0142 A269     	 ldr r2,[r4,#24]
 901 0144 0023     	 movs r3,#0
 902 0146 0093     	 str r3,[sp]
 903 0148 2046     	 mov r0,r4
 904 014a 1946     	 mov r1,r3
 905 014c 049C     	 ldr r4,[sp,#16]
 906              	.LVL107:
 907 014e 2244     	 add r2,r2,r4
 908 0150 FFF7FEFF 	 bl xTimerGenericCommand
 909              	.LVL108:
 822:../FreeRTOS/Source/timers.c ****                                 ( void ) xResult;
 910              	 .loc 1 822 0
 911 0154 A8BB     	 cbnz r0,.L65
 912              	.LBB86:
 913              	.LBB87:
 914              	 .loc 2 197 0
 915              	
 916 0156 4FF01403 	 mov r3,#20
 917 015a 83F31188 	 msr basepri,r3
 918 015e BFF36F8F 	 isb 
 919 0162 BFF34F8F 	 dsb 
 920              	
 921              	
 922              	.LVL109:
 923              	 .thumb
 924              	.L72:
 925 0166 FEE7     	 b .L72
 926              	.LVL110:
 927              	.L68:
 928              	.LBE87:
 929              	.LBE86:
 840:../FreeRTOS/Source/timers.c ****                         break;
 930              	 .loc 1 840 0
 931 0168 94F82830 	 ldrb r3,[r4,#40]
 932 016c 23F00103 	 bic r3,r3,#1
 933 0170 84F82830 	 strb r3,[r4,#40]
 934 0174 25E0     	 b .L65
 935              	.L69:
 845:../FreeRTOS/Source/timers.c ****                         pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 936              	 .loc 1 845 0
 937 0176 94F82830 	 ldrb r3,[r4,#40]
 938 017a 43F00103 	 orr r3,r3,#1
 939 017e 84F82830 	 strb r3,[r4,#40]
 846:../FreeRTOS/Source/timers.c ****                         configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 940              	 .loc 1 846 0
 941 0182 0499     	 ldr r1,[sp,#16]
 942 0184 A161     	 str r1,[r4,#24]
 847:../FreeRTOS/Source/timers.c **** 
 943              	 .loc 1 847 0
 944 0186 41B9     	 cbnz r1,.L73
 945              	.LBB88:
 946              	.LBB89:
 947              	 .loc 2 197 0
 948              	
 949 0188 4FF01403 	 mov r3,#20
 950 018c 83F31188 	 msr basepri,r3
 951 0190 BFF36F8F 	 isb 
 952 0194 BFF34F8F 	 dsb 
 953              	
 954              	
 955              	.LVL111:
 956              	 .thumb
 957              	.L74:
 958 0198 FEE7     	 b .L74
 959              	.L73:
 960              	.LBE89:
 961              	.LBE88:
 855:../FreeRTOS/Source/timers.c ****                         break;
 962              	 .loc 1 855 0
 963 019a 2046     	 mov r0,r4
 964              	.LVL112:
 965 019c 7144     	 add r1,r1,lr
 966 019e 7246     	 mov r2,lr
 967 01a0 7346     	 mov r3,lr
 968 01a2 FFF7FEFF 	 bl prvInsertTimerInActiveList
 969              	.LVL113:
 970 01a6 0CE0     	 b .L65
 971              	.LVL114:
 972              	.L70:
 864:../FreeRTOS/Source/timers.c ****                                 {
 973              	 .loc 1 864 0
 974 01a8 94F82830 	 ldrb r3,[r4,#40]
 975 01ac 13F0020F 	 tst r3,#2
 976 01b0 03D1     	 bne .L75
 866:../FreeRTOS/Source/timers.c ****                                 }
 977              	 .loc 1 866 0
 978 01b2 2046     	 mov r0,r4
 979              	.LVL115:
 980 01b4 FFF7FEFF 	 bl vPortFree
 981              	.LVL116:
 982 01b8 03E0     	 b .L65
 983              	.LVL117:
 984              	.L75:
 870:../FreeRTOS/Source/timers.c ****                                 }
 985              	 .loc 1 870 0
 986 01ba 23F00103 	 bic r3,r3,#1
 987 01be 84F82830 	 strb r3,[r4,#40]
 988              	.LVL118:
 989              	.L65:
 750:../FreeRTOS/Source/timers.c ****         {
 990              	 .loc 1 750 0
 991 01c2 0024     	 movs r4,#0
 992              	.L63:
 993 01c4 2868     	 ldr r0,[r5]
 994 01c6 03A9     	 add r1,sp,#12
 995 01c8 2246     	 mov r2,r4
 996 01ca FFF7FEFF 	 bl xQueueReceive
 997              	.LVL119:
 998 01ce 0028     	 cmp r0,#0
 999 01d0 89D1     	 bne .L76
 1000 01d2 1DE7     	 b .L77
 1001              	.L83:
 1002              	 .align 2
 1003              	.L82:
 1004 01d4 00000000 	 .word .LANCHOR1
 1005 01d8 00000000 	 .word .LANCHOR2
 1006 01dc 00000000 	 .word .LANCHOR0
 1007 01e0 04ED00E0 	 .word -536810236
 1008              	.LBE85:
 1009              	.LBE84:
 1010              	 .cfi_endproc
 1011              	.LFE16:
 1013              	 .section .text.xTimerGetTimerDaemonTaskHandle,"ax",%progbits
 1014              	 .align 2
 1015              	 .global xTimerGetTimerDaemonTaskHandle
 1016              	 .thumb
 1017              	 .thumb_func
 1019              	xTimerGetTimerDaemonTaskHandle:
 1020              	.LFB9:
 425:../FreeRTOS/Source/timers.c ****         /* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
 1021              	 .loc 1 425 0
 1022              	 .cfi_startproc
 1023              	 
 1024              	 
 1025              	 
 428:../FreeRTOS/Source/timers.c ****         return xTimerTaskHandle;
 1026              	 .loc 1 428 0
 1027 0000 064B     	 ldr r3,.L87
 1028 0002 1868     	 ldr r0,[r3]
 1029 0004 40B9     	 cbnz r0,.L85
 1030              	.LBB90:
 1031              	.LBB91:
 1032              	 .loc 2 197 0
 1033              	
 1034 0006 4FF01403 	 mov r3,#20
 1035 000a 83F31188 	 msr basepri,r3
 1036 000e BFF36F8F 	 isb 
 1037 0012 BFF34F8F 	 dsb 
 1038              	
 1039              	
 1040              	.LVL120:
 1041              	 .thumb
 1042              	.L86:
 1043              	.LBE91:
 1044              	.LBE90:
 428:../FreeRTOS/Source/timers.c ****         return xTimerTaskHandle;
 1045              	 .loc 1 428 0 discriminator 1
 1046 0016 FEE7     	 b .L86
 1047              	.L85:
 430:../FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 1048              	 .loc 1 430 0
 1049 0018 7047     	 bx lr
 1050              	.L88:
 1051 001a 00BF     	 .align 2
 1052              	.L87:
 1053 001c 00000000 	 .word .LANCHOR5
 1054              	 .cfi_endproc
 1055              	.LFE9:
 1057              	 .section .text.xTimerGetPeriod,"ax",%progbits
 1058              	 .align 2
 1059              	 .global xTimerGetPeriod
 1060              	 .thumb
 1061              	 .thumb_func
 1063              	xTimerGetPeriod:
 1064              	.LFB10:
 434:../FreeRTOS/Source/timers.c ****         Timer_t * pxTimer = xTimer;
 1065              	 .loc 1 434 0
 1066              	 .cfi_startproc
 1067              	 
 1068              	 
 1069              	 
 1070              	.LVL121:
 437:../FreeRTOS/Source/timers.c ****         return pxTimer->xTimerPeriodInTicks;
 1071              	 .loc 1 437 0
 1072 0000 40B9     	 cbnz r0,.L90
 1073              	.LBB92:
 1074              	.LBB93:
 1075              	 .loc 2 197 0
 1076              	
 1077 0002 4FF01403 	 mov r3,#20
 1078 0006 83F31188 	 msr basepri,r3
 1079 000a BFF36F8F 	 isb 
 1080 000e BFF34F8F 	 dsb 
 1081              	
 1082              	
 1083              	.LVL122:
 1084              	 .thumb
 1085              	.L91:
 1086              	.LBE93:
 1087              	.LBE92:
 437:../FreeRTOS/Source/timers.c ****         return pxTimer->xTimerPeriodInTicks;
 1088              	 .loc 1 437 0 discriminator 1
 1089 0012 FEE7     	 b .L91
 1090              	.L90:
 439:../FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 1091              	 .loc 1 439 0
 1092 0014 8069     	 ldr r0,[r0,#24]
 1093              	.LVL123:
 1094 0016 7047     	 bx lr
 1095              	 .cfi_endproc
 1096              	.LFE10:
 1098              	 .section .text.vTimerSetReloadMode,"ax",%progbits
 1099              	 .align 2
 1100              	 .global vTimerSetReloadMode
 1101              	 .thumb
 1102              	 .thumb_func
 1104              	vTimerSetReloadMode:
 1105              	.LFB11:
 444:../FreeRTOS/Source/timers.c ****         Timer_t * pxTimer = xTimer;
 1106              	 .loc 1 444 0
 1107              	 .cfi_startproc
 1108              	 
 1109              	 
 1110              	.LVL124:
 1111 0000 38B5     	 push {r3,r4,r5,lr}
 1112              	.LCFI14:
 1113              	 .cfi_def_cfa_offset 16
 1114              	 .cfi_offset 3,-16
 1115              	 .cfi_offset 4,-12
 1116              	 .cfi_offset 5,-8
 1117              	 .cfi_offset 14,-4
 1118              	.LVL125:
 447:../FreeRTOS/Source/timers.c ****         taskENTER_CRITICAL();
 1119              	 .loc 1 447 0
 1120 0002 40B9     	 cbnz r0,.L93
 1121              	.LBB94:
 1122              	.LBB95:
 1123              	 .loc 2 197 0
 1124              	
 1125 0004 4FF01403 	 mov r3,#20
 1126 0008 83F31188 	 msr basepri,r3
 1127 000c BFF36F8F 	 isb 
 1128 0010 BFF34F8F 	 dsb 
 1129              	
 1130              	
 1131              	.LVL126:
 1132              	 .thumb
 1133              	.L94:
 1134              	.LBE95:
 1135              	.LBE94:
 447:../FreeRTOS/Source/timers.c ****         taskENTER_CRITICAL();
 1136              	 .loc 1 447 0 discriminator 1
 1137 0014 FEE7     	 b .L94
 1138              	.L93:
 1139 0016 0446     	 mov r4,r0
 1140 0018 0D46     	 mov r5,r1
 448:../FreeRTOS/Source/timers.c ****         {
 1141              	 .loc 1 448 0
 1142 001a FFF7FEFF 	 bl vPortEnterCritical
 1143              	.LVL127:
 450:../FreeRTOS/Source/timers.c ****             {
 1144              	 .loc 1 450 0
 1145 001e 35B1     	 cbz r5,.L95
 452:../FreeRTOS/Source/timers.c ****             }
 1146              	 .loc 1 452 0
 1147 0020 94F82830 	 ldrb r3,[r4,#40]
 1148 0024 43F00403 	 orr r3,r3,#4
 1149 0028 84F82830 	 strb r3,[r4,#40]
 1150 002c 05E0     	 b .L96
 1151              	.L95:
 456:../FreeRTOS/Source/timers.c ****             }
 1152              	 .loc 1 456 0
 1153 002e 94F82830 	 ldrb r3,[r4,#40]
 1154 0032 23F00403 	 bic r3,r3,#4
 1155 0036 84F82830 	 strb r3,[r4,#40]
 1156              	.L96:
 459:../FreeRTOS/Source/timers.c ****     }
 1157              	 .loc 1 459 0
 1158 003a FFF7FEFF 	 bl vPortExitCritical
 1159              	.LVL128:
 1160 003e 38BD     	 pop {r3,r4,r5,pc}
 1161              	 .cfi_endproc
 1162              	.LFE11:
 1164              	 .section .text.uxTimerGetReloadMode,"ax",%progbits
 1165              	 .align 2
 1166              	 .global uxTimerGetReloadMode
 1167              	 .thumb
 1168              	 .thumb_func
 1170              	uxTimerGetReloadMode:
 1171              	.LFB12:
 464:../FreeRTOS/Source/timers.c ****         Timer_t * pxTimer = xTimer;
 1172              	 .loc 1 464 0
 1173              	 .cfi_startproc
 1174              	 
 1175              	 
 1176              	.LVL129:
 468:../FreeRTOS/Source/timers.c ****         taskENTER_CRITICAL();
 1177              	 .loc 1 468 0
 1178 0000 40B9     	 cbnz r0,.L99
 1179              	.LBB96:
 1180              	.LBB97:
 1181              	 .loc 2 197 0
 1182              	
 1183 0002 4FF01403 	 mov r3,#20
 1184 0006 83F31188 	 msr basepri,r3
 1185 000a BFF36F8F 	 isb 
 1186 000e BFF34F8F 	 dsb 
 1187              	
 1188              	
 1189              	.LVL130:
 1190              	 .thumb
 1191              	.L100:
 1192              	.LBE97:
 1193              	.LBE96:
 468:../FreeRTOS/Source/timers.c ****         taskENTER_CRITICAL();
 1194              	 .loc 1 468 0 discriminator 1
 1195 0012 FEE7     	 b .L100
 1196              	.L99:
 464:../FreeRTOS/Source/timers.c ****         Timer_t * pxTimer = xTimer;
 1197              	 .loc 1 464 0
 1198 0014 10B5     	 push {r4,lr}
 1199              	.LCFI15:
 1200              	 .cfi_def_cfa_offset 8
 1201              	 .cfi_offset 4,-8
 1202              	 .cfi_offset 14,-4
 1203 0016 0446     	 mov r4,r0
 469:../FreeRTOS/Source/timers.c ****         {
 1204              	 .loc 1 469 0
 1205 0018 FFF7FEFF 	 bl vPortEnterCritical
 1206              	.LVL131:
 471:../FreeRTOS/Source/timers.c ****             {
 1207              	 .loc 1 471 0
 1208 001c 94F82840 	 ldrb r4,[r4,#40]
 1209              	.LVL132:
 1210 0020 C4F38004 	 ubfx r4,r4,#2,#1
 1211              	.LVL133:
 482:../FreeRTOS/Source/timers.c **** 
 1212              	 .loc 1 482 0
 1213 0024 FFF7FEFF 	 bl vPortExitCritical
 1214              	.LVL134:
 485:../FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 1215              	 .loc 1 485 0
 1216 0028 2046     	 mov r0,r4
 1217 002a 10BD     	 pop {r4,pc}
 1218              	 .cfi_endproc
 1219              	.LFE12:
 1221              	 .section .text.xTimerGetExpiryTime,"ax",%progbits
 1222              	 .align 2
 1223              	 .global xTimerGetExpiryTime
 1224              	 .thumb
 1225              	 .thumb_func
 1227              	xTimerGetExpiryTime:
 1228              	.LFB13:
 489:../FreeRTOS/Source/timers.c ****         Timer_t * pxTimer = xTimer;
 1229              	 .loc 1 489 0
 1230              	 .cfi_startproc
 1231              	 
 1232              	 
 1233              	 
 1234              	.LVL135:
 493:../FreeRTOS/Source/timers.c ****         xReturn = listGET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ) );
 1235              	 .loc 1 493 0
 1236 0000 40B9     	 cbnz r0,.L103
 1237              	.LBB98:
 1238              	.LBB99:
 1239              	 .loc 2 197 0
 1240              	
 1241 0002 4FF01403 	 mov r3,#20
 1242 0006 83F31188 	 msr basepri,r3
 1243 000a BFF36F8F 	 isb 
 1244 000e BFF34F8F 	 dsb 
 1245              	
 1246              	
 1247              	.LVL136:
 1248              	 .thumb
 1249              	.L104:
 1250              	.LBE99:
 1251              	.LBE98:
 493:../FreeRTOS/Source/timers.c ****         xReturn = listGET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ) );
 1252              	 .loc 1 493 0 discriminator 1
 1253 0012 FEE7     	 b .L104
 1254              	.L103:
 1255              	.LVL137:
 496:../FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 1256              	 .loc 1 496 0
 1257 0014 4068     	 ldr r0,[r0,#4]
 1258              	.LVL138:
 1259 0016 7047     	 bx lr
 1260              	 .cfi_endproc
 1261              	.LFE13:
 1263              	 .section .text.pcTimerGetName,"ax",%progbits
 1264              	 .align 2
 1265              	 .global pcTimerGetName
 1266              	 .thumb
 1267              	 .thumb_func
 1269              	pcTimerGetName:
 1270              	.LFB14:
 500:../FreeRTOS/Source/timers.c ****         Timer_t * pxTimer = xTimer;
 1271              	 .loc 1 500 0
 1272              	 .cfi_startproc
 1273              	 
 1274              	 
 1275              	 
 1276              	.LVL139:
 503:../FreeRTOS/Source/timers.c ****         return pxTimer->pcTimerName;
 1277              	 .loc 1 503 0
 1278 0000 40B9     	 cbnz r0,.L106
 1279              	.LBB100:
 1280              	.LBB101:
 1281              	 .loc 2 197 0
 1282              	
 1283 0002 4FF01403 	 mov r3,#20
 1284 0006 83F31188 	 msr basepri,r3
 1285 000a BFF36F8F 	 isb 
 1286 000e BFF34F8F 	 dsb 
 1287              	
 1288              	
 1289              	.LVL140:
 1290              	 .thumb
 1291              	.L107:
 1292              	.LBE101:
 1293              	.LBE100:
 503:../FreeRTOS/Source/timers.c ****         return pxTimer->pcTimerName;
 1294              	 .loc 1 503 0 discriminator 1
 1295 0012 FEE7     	 b .L107
 1296              	.L106:
 505:../FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 1297              	 .loc 1 505 0
 1298 0014 0068     	 ldr r0,[r0]
 1299              	.LVL141:
 1300 0016 7047     	 bx lr
 1301              	 .cfi_endproc
 1302              	.LFE14:
 1304              	 .section .text.xTimerIsTimerActive,"ax",%progbits
 1305              	 .align 2
 1306              	 .global xTimerIsTimerActive
 1307              	 .thumb
 1308              	 .thumb_func
 1310              	xTimerIsTimerActive:
 1311              	.LFB24:
1001:../FreeRTOS/Source/timers.c ****     }
1002:../FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
1003:../FreeRTOS/Source/timers.c **** 
1004:../FreeRTOS/Source/timers.c ****     BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
1005:../FreeRTOS/Source/timers.c ****     {
 1312              	 .loc 1 1005 0
 1313              	 .cfi_startproc
 1314              	 
 1315              	 
 1316              	.LVL142:
1006:../FreeRTOS/Source/timers.c ****         BaseType_t xReturn;
1007:../FreeRTOS/Source/timers.c ****         Timer_t * pxTimer = xTimer;
1008:../FreeRTOS/Source/timers.c **** 
1009:../FreeRTOS/Source/timers.c ****         configASSERT( xTimer );
 1317              	 .loc 1 1009 0
 1318 0000 40B9     	 cbnz r0,.L109
 1319              	.LBB102:
 1320              	.LBB103:
 1321              	 .loc 2 197 0
 1322              	
 1323 0002 4FF01403 	 mov r3,#20
 1324 0006 83F31188 	 msr basepri,r3
 1325 000a BFF36F8F 	 isb 
 1326 000e BFF34F8F 	 dsb 
 1327              	
 1328              	
 1329              	.LVL143:
 1330              	 .thumb
 1331              	.L110:
 1332              	.LBE103:
 1333              	.LBE102:
 1334              	 .loc 1 1009 0 discriminator 1
 1335 0012 FEE7     	 b .L110
 1336              	.L109:
1005:../FreeRTOS/Source/timers.c ****         BaseType_t xReturn;
 1337              	 .loc 1 1005 0
 1338 0014 10B5     	 push {r4,lr}
 1339              	.LCFI16:
 1340              	 .cfi_def_cfa_offset 8
 1341              	 .cfi_offset 4,-8
 1342              	 .cfi_offset 14,-4
 1343 0016 0446     	 mov r4,r0
1010:../FreeRTOS/Source/timers.c **** 
1011:../FreeRTOS/Source/timers.c ****         /* Is the timer in the list of active timers? */
1012:../FreeRTOS/Source/timers.c ****         taskENTER_CRITICAL();
 1344              	 .loc 1 1012 0
 1345 0018 FFF7FEFF 	 bl vPortEnterCritical
 1346              	.LVL144:
1013:../FreeRTOS/Source/timers.c ****         {
1014:../FreeRTOS/Source/timers.c ****             if( ( pxTimer->ucStatus & tmrSTATUS_IS_ACTIVE ) == 0 )
 1347              	 .loc 1 1014 0
 1348 001c 94F82840 	 ldrb r4,[r4,#40]
 1349              	.LVL145:
 1350 0020 04F00104 	 and r4,r4,#1
 1351              	.LVL146:
1015:../FreeRTOS/Source/timers.c ****             {
1016:../FreeRTOS/Source/timers.c ****                 xReturn = pdFALSE;
1017:../FreeRTOS/Source/timers.c ****             }
1018:../FreeRTOS/Source/timers.c ****             else
1019:../FreeRTOS/Source/timers.c ****             {
1020:../FreeRTOS/Source/timers.c ****                 xReturn = pdTRUE;
1021:../FreeRTOS/Source/timers.c ****             }
1022:../FreeRTOS/Source/timers.c ****         }
1023:../FreeRTOS/Source/timers.c ****         taskEXIT_CRITICAL();
 1352              	 .loc 1 1023 0
 1353 0024 FFF7FEFF 	 bl vPortExitCritical
 1354              	.LVL147:
1024:../FreeRTOS/Source/timers.c **** 
1025:../FreeRTOS/Source/timers.c ****         return xReturn;
1026:../FreeRTOS/Source/timers.c ****     } /*lint !e818 Can't be pointer to const due to the typedef. */
 1355              	 .loc 1 1026 0
 1356 0028 2046     	 mov r0,r4
 1357 002a 10BD     	 pop {r4,pc}
 1358              	 .cfi_endproc
 1359              	.LFE24:
 1361              	 .section .text.pvTimerGetTimerID,"ax",%progbits
 1362              	 .align 2
 1363              	 .global pvTimerGetTimerID
 1364              	 .thumb
 1365              	 .thumb_func
 1367              	pvTimerGetTimerID:
 1368              	.LFB25:
1027:../FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
1028:../FreeRTOS/Source/timers.c **** 
1029:../FreeRTOS/Source/timers.c ****     void * pvTimerGetTimerID( const TimerHandle_t xTimer )
1030:../FreeRTOS/Source/timers.c ****     {
 1369              	 .loc 1 1030 0
 1370              	 .cfi_startproc
 1371              	 
 1372              	 
 1373              	.LVL148:
1031:../FreeRTOS/Source/timers.c ****         Timer_t * const pxTimer = xTimer;
1032:../FreeRTOS/Source/timers.c ****         void * pvReturn;
1033:../FreeRTOS/Source/timers.c **** 
1034:../FreeRTOS/Source/timers.c ****         configASSERT( xTimer );
 1374              	 .loc 1 1034 0
 1375 0000 40B9     	 cbnz r0,.L113
 1376              	.LBB104:
 1377              	.LBB105:
 1378              	 .loc 2 197 0
 1379              	
 1380 0002 4FF01403 	 mov r3,#20
 1381 0006 83F31188 	 msr basepri,r3
 1382 000a BFF36F8F 	 isb 
 1383 000e BFF34F8F 	 dsb 
 1384              	
 1385              	
 1386              	.LVL149:
 1387              	 .thumb
 1388              	.L114:
 1389              	.LBE105:
 1390              	.LBE104:
 1391              	 .loc 1 1034 0 discriminator 1
 1392 0012 FEE7     	 b .L114
 1393              	.L113:
1030:../FreeRTOS/Source/timers.c ****         Timer_t * const pxTimer = xTimer;
 1394              	 .loc 1 1030 0
 1395 0014 10B5     	 push {r4,lr}
 1396              	.LCFI17:
 1397              	 .cfi_def_cfa_offset 8
 1398              	 .cfi_offset 4,-8
 1399              	 .cfi_offset 14,-4
 1400 0016 0446     	 mov r4,r0
1035:../FreeRTOS/Source/timers.c **** 
1036:../FreeRTOS/Source/timers.c ****         taskENTER_CRITICAL();
 1401              	 .loc 1 1036 0
 1402 0018 FFF7FEFF 	 bl vPortEnterCritical
 1403              	.LVL150:
1037:../FreeRTOS/Source/timers.c ****         {
1038:../FreeRTOS/Source/timers.c ****             pvReturn = pxTimer->pvTimerID;
 1404              	 .loc 1 1038 0
 1405 001c E469     	 ldr r4,[r4,#28]
 1406              	.LVL151:
1039:../FreeRTOS/Source/timers.c ****         }
1040:../FreeRTOS/Source/timers.c ****         taskEXIT_CRITICAL();
 1407              	 .loc 1 1040 0
 1408 001e FFF7FEFF 	 bl vPortExitCritical
 1409              	.LVL152:
1041:../FreeRTOS/Source/timers.c **** 
1042:../FreeRTOS/Source/timers.c ****         return pvReturn;
1043:../FreeRTOS/Source/timers.c ****     }
 1410              	 .loc 1 1043 0
 1411 0022 2046     	 mov r0,r4
 1412 0024 10BD     	 pop {r4,pc}
 1413              	 .cfi_endproc
 1414              	.LFE25:
 1416 0026 00BF     	 .section .text.vTimerSetTimerID,"ax",%progbits
 1417              	 .align 2
 1418              	 .global vTimerSetTimerID
 1419              	 .thumb
 1420              	 .thumb_func
 1422              	vTimerSetTimerID:
 1423              	.LFB26:
1044:../FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
1045:../FreeRTOS/Source/timers.c **** 
1046:../FreeRTOS/Source/timers.c ****     void vTimerSetTimerID( TimerHandle_t xTimer,
1047:../FreeRTOS/Source/timers.c ****                            void * pvNewID )
1048:../FreeRTOS/Source/timers.c ****     {
 1424              	 .loc 1 1048 0
 1425              	 .cfi_startproc
 1426              	 
 1427              	 
 1428              	.LVL153:
 1429 0000 38B5     	 push {r3,r4,r5,lr}
 1430              	.LCFI18:
 1431              	 .cfi_def_cfa_offset 16
 1432              	 .cfi_offset 3,-16
 1433              	 .cfi_offset 4,-12
 1434              	 .cfi_offset 5,-8
 1435              	 .cfi_offset 14,-4
 1436              	.LVL154:
1049:../FreeRTOS/Source/timers.c ****         Timer_t * const pxTimer = xTimer;
1050:../FreeRTOS/Source/timers.c **** 
1051:../FreeRTOS/Source/timers.c ****         configASSERT( xTimer );
 1437              	 .loc 1 1051 0
 1438 0002 40B9     	 cbnz r0,.L117
 1439              	.LBB106:
 1440              	.LBB107:
 1441              	 .loc 2 197 0
 1442              	
 1443 0004 4FF01403 	 mov r3,#20
 1444 0008 83F31188 	 msr basepri,r3
 1445 000c BFF36F8F 	 isb 
 1446 0010 BFF34F8F 	 dsb 
 1447              	
 1448              	
 1449              	.LVL155:
 1450              	 .thumb
 1451              	.L118:
 1452              	.LBE107:
 1453              	.LBE106:
 1454              	 .loc 1 1051 0 discriminator 1
 1455 0014 FEE7     	 b .L118
 1456              	.L117:
 1457 0016 0446     	 mov r4,r0
 1458 0018 0D46     	 mov r5,r1
1052:../FreeRTOS/Source/timers.c **** 
1053:../FreeRTOS/Source/timers.c ****         taskENTER_CRITICAL();
 1459              	 .loc 1 1053 0
 1460 001a FFF7FEFF 	 bl vPortEnterCritical
 1461              	.LVL156:
1054:../FreeRTOS/Source/timers.c ****         {
1055:../FreeRTOS/Source/timers.c ****             pxTimer->pvTimerID = pvNewID;
 1462              	 .loc 1 1055 0
 1463 001e E561     	 str r5,[r4,#28]
1056:../FreeRTOS/Source/timers.c ****         }
1057:../FreeRTOS/Source/timers.c ****         taskEXIT_CRITICAL();
 1464              	 .loc 1 1057 0
 1465 0020 FFF7FEFF 	 bl vPortExitCritical
 1466              	.LVL157:
 1467 0024 38BD     	 pop {r3,r4,r5,pc}
 1468              	 .cfi_endproc
 1469              	.LFE26:
 1471 0026 00BF     	 .section .text.uxTimerGetTimerNumber,"ax",%progbits
 1472              	 .align 2
 1473              	 .global uxTimerGetTimerNumber
 1474              	 .thumb
 1475              	 .thumb_func
 1477              	uxTimerGetTimerNumber:
 1478              	.LFB27:
1058:../FreeRTOS/Source/timers.c ****     }
1059:../FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
1060:../FreeRTOS/Source/timers.c **** 
1061:../FreeRTOS/Source/timers.c ****     #if ( INCLUDE_xTimerPendFunctionCall == 1 )
1062:../FreeRTOS/Source/timers.c **** 
1063:../FreeRTOS/Source/timers.c ****         BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend,
1064:../FreeRTOS/Source/timers.c ****                                                   void * pvParameter1,
1065:../FreeRTOS/Source/timers.c ****                                                   uint32_t ulParameter2,
1066:../FreeRTOS/Source/timers.c ****                                                   BaseType_t * pxHigherPriorityTaskWoken )
1067:../FreeRTOS/Source/timers.c ****         {
1068:../FreeRTOS/Source/timers.c ****             DaemonTaskMessage_t xMessage;
1069:../FreeRTOS/Source/timers.c ****             BaseType_t xReturn;
1070:../FreeRTOS/Source/timers.c **** 
1071:../FreeRTOS/Source/timers.c ****             /* Complete the message with the function parameters and post it to the
1072:../FreeRTOS/Source/timers.c ****              * daemon task. */
1073:../FreeRTOS/Source/timers.c ****             xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR;
1074:../FreeRTOS/Source/timers.c ****             xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
1075:../FreeRTOS/Source/timers.c ****             xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
1076:../FreeRTOS/Source/timers.c ****             xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
1077:../FreeRTOS/Source/timers.c **** 
1078:../FreeRTOS/Source/timers.c ****             xReturn = xQueueSendFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
1079:../FreeRTOS/Source/timers.c **** 
1080:../FreeRTOS/Source/timers.c ****             tracePEND_FUNC_CALL_FROM_ISR( xFunctionToPend, pvParameter1, ulParameter2, xReturn );
1081:../FreeRTOS/Source/timers.c **** 
1082:../FreeRTOS/Source/timers.c ****             return xReturn;
1083:../FreeRTOS/Source/timers.c ****         }
1084:../FreeRTOS/Source/timers.c **** 
1085:../FreeRTOS/Source/timers.c ****     #endif /* INCLUDE_xTimerPendFunctionCall */
1086:../FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
1087:../FreeRTOS/Source/timers.c **** 
1088:../FreeRTOS/Source/timers.c ****     #if ( INCLUDE_xTimerPendFunctionCall == 1 )
1089:../FreeRTOS/Source/timers.c **** 
1090:../FreeRTOS/Source/timers.c ****         BaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend,
1091:../FreeRTOS/Source/timers.c ****                                            void * pvParameter1,
1092:../FreeRTOS/Source/timers.c ****                                            uint32_t ulParameter2,
1093:../FreeRTOS/Source/timers.c ****                                            TickType_t xTicksToWait )
1094:../FreeRTOS/Source/timers.c ****         {
1095:../FreeRTOS/Source/timers.c ****             DaemonTaskMessage_t xMessage;
1096:../FreeRTOS/Source/timers.c ****             BaseType_t xReturn;
1097:../FreeRTOS/Source/timers.c **** 
1098:../FreeRTOS/Source/timers.c ****             /* This function can only be called after a timer has been created or
1099:../FreeRTOS/Source/timers.c ****              * after the scheduler has been started because, until then, the timer
1100:../FreeRTOS/Source/timers.c ****              * queue does not exist. */
1101:../FreeRTOS/Source/timers.c ****             configASSERT( xTimerQueue );
1102:../FreeRTOS/Source/timers.c **** 
1103:../FreeRTOS/Source/timers.c ****             /* Complete the message with the function parameters and post it to the
1104:../FreeRTOS/Source/timers.c ****              * daemon task. */
1105:../FreeRTOS/Source/timers.c ****             xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK;
1106:../FreeRTOS/Source/timers.c ****             xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
1107:../FreeRTOS/Source/timers.c ****             xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
1108:../FreeRTOS/Source/timers.c ****             xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
1109:../FreeRTOS/Source/timers.c **** 
1110:../FreeRTOS/Source/timers.c ****             xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
1111:../FreeRTOS/Source/timers.c **** 
1112:../FreeRTOS/Source/timers.c ****             tracePEND_FUNC_CALL( xFunctionToPend, pvParameter1, ulParameter2, xReturn );
1113:../FreeRTOS/Source/timers.c **** 
1114:../FreeRTOS/Source/timers.c ****             return xReturn;
1115:../FreeRTOS/Source/timers.c ****         }
1116:../FreeRTOS/Source/timers.c **** 
1117:../FreeRTOS/Source/timers.c ****     #endif /* INCLUDE_xTimerPendFunctionCall */
1118:../FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
1119:../FreeRTOS/Source/timers.c **** 
1120:../FreeRTOS/Source/timers.c ****     #if ( configUSE_TRACE_FACILITY == 1 )
1121:../FreeRTOS/Source/timers.c **** 
1122:../FreeRTOS/Source/timers.c ****         UBaseType_t uxTimerGetTimerNumber( TimerHandle_t xTimer )
1123:../FreeRTOS/Source/timers.c ****         {
 1479              	 .loc 1 1123 0
 1480              	 .cfi_startproc
 1481              	 
 1482              	 
 1483              	 
 1484              	.LVL158:
1124:../FreeRTOS/Source/timers.c ****             return ( ( Timer_t * ) xTimer )->uxTimerNumber;
1125:../FreeRTOS/Source/timers.c ****         }
 1485              	 .loc 1 1125 0
 1486 0000 406A     	 ldr r0,[r0,#36]
 1487              	.LVL159:
 1488 0002 7047     	 bx lr
 1489              	 .cfi_endproc
 1490              	.LFE27:
 1492              	 .section .text.vTimerSetTimerNumber,"ax",%progbits
 1493              	 .align 2
 1494              	 .global vTimerSetTimerNumber
 1495              	 .thumb
 1496              	 .thumb_func
 1498              	vTimerSetTimerNumber:
 1499              	.LFB28:
1126:../FreeRTOS/Source/timers.c **** 
1127:../FreeRTOS/Source/timers.c ****     #endif /* configUSE_TRACE_FACILITY */
1128:../FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
1129:../FreeRTOS/Source/timers.c **** 
1130:../FreeRTOS/Source/timers.c ****     #if ( configUSE_TRACE_FACILITY == 1 )
1131:../FreeRTOS/Source/timers.c **** 
1132:../FreeRTOS/Source/timers.c ****         void vTimerSetTimerNumber( TimerHandle_t xTimer,
1133:../FreeRTOS/Source/timers.c ****                                    UBaseType_t uxTimerNumber )
1134:../FreeRTOS/Source/timers.c ****         {
 1500              	 .loc 1 1134 0
 1501              	 .cfi_startproc
 1502              	 
 1503              	 
 1504              	 
 1505              	.LVL160:
1135:../FreeRTOS/Source/timers.c ****             ( ( Timer_t * ) xTimer )->uxTimerNumber = uxTimerNumber;
 1506              	 .loc 1 1135 0
 1507 0000 4162     	 str r1,[r0,#36]
 1508 0002 7047     	 bx lr
 1509              	 .cfi_endproc
 1510              	.LFE28:
 1512              	 .section .bss.pxCurrentTimerList,"aw",%nobits
 1513              	 .align 2
 1514              	 .set .LANCHOR1,.+0
 1517              	pxCurrentTimerList:
 1518 0000 00000000 	 .space 4
 1519              	 .section .bss.xActiveTimerList1,"aw",%nobits
 1520              	 .align 2
 1521              	 .set .LANCHOR3,.+0
 1524              	xActiveTimerList1:
 1525 0000 00000000 	 .space 20
 1525      00000000 
 1525      00000000 
 1525      00000000 
 1525      00000000 
 1526              	 .section .bss.xActiveTimerList2,"aw",%nobits
 1527              	 .align 2
 1528              	 .set .LANCHOR4,.+0
 1531              	xActiveTimerList2:
 1532 0000 00000000 	 .space 20
 1532      00000000 
 1532      00000000 
 1532      00000000 
 1532      00000000 
 1533              	 .section .rodata.str1.4,"aMS",%progbits,1
 1534              	 .align 2
 1535              	.LC0:
 1536 0000 546D7251 	 .ascii "TmrQ\000"
 1536      00
 1537 0005 000000   	 .space 3
 1538              	.LC1:
 1539 0008 546D7220 	 .ascii "Tmr Svc\000"
 1539      53766300 
 1540              	 .section .bss.xTimerQueue,"aw",%nobits
 1541              	 .align 2
 1542              	 .set .LANCHOR2,.+0
 1545              	xTimerQueue:
 1546 0000 00000000 	 .space 4
 1547              	 .section .bss.pxOverflowTimerList,"aw",%nobits
 1548              	 .align 2
 1549              	 .set .LANCHOR0,.+0
 1552              	pxOverflowTimerList:
 1553 0000 00000000 	 .space 4
 1554              	 .section .bss.xTimerTaskHandle,"aw",%nobits
 1555              	 .align 2
 1556              	 .set .LANCHOR5,.+0
 1559              	xTimerTaskHandle:
 1560 0000 00000000 	 .space 4
 1561              	 .section .bss.xLastTime.5394,"aw",%nobits
 1562              	 .align 2
 1563              	 .set .LANCHOR6,.+0
 1566              	xLastTime.5394:
 1567 0000 00000000 	 .space 4
 1568              	 .text
 1569              	.Letext0:
 1570              	 .file 3 "e:\\embedded\\dave_4-4-2_64bit_2018-02-23\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\lib\\gcc\\arm-none-eabi\\4.9.3\\include\\stddef.h"
 1571              	 .file 4 "e:\\embedded\\dave_4-4-2_64bit_2018-02-23\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 1572              	 .file 5 "e:\\embedded\\dave_4-4-2_64bit_2018-02-23\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 1573              	 .file 6 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/include/projdefs.h"
 1574              	 .file 7 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/include/list.h"
 1575              	 .file 8 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/include/task.h"
 1576              	 .file 9 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/include/queue.h"
 1577              	 .file 10 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/include/timers.h"
 1578              	 .file 11 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/include/portable.h"
DEFINED SYMBOLS
                            *ABS*:00000000 timers.c
    {standard input}:19     .text.prvInsertTimerInActiveList:00000000 $t
    {standard input}:23     .text.prvInsertTimerInActiveList:00000000 prvInsertTimerInActiveList
    {standard input}:101    .text.prvInsertTimerInActiveList:00000040 $d
    {standard input}:107    .text.prvCheckForValidListAndQueue:00000000 $t
    {standard input}:111    .text.prvCheckForValidListAndQueue:00000000 prvCheckForValidListAndQueue
    {standard input}:169    .text.prvCheckForValidListAndQueue:00000040 $d
    {standard input}:179    .text.xTimerCreateTimerTask:00000000 $t
    {standard input}:184    .text.xTimerCreateTimerTask:00000000 xTimerCreateTimerTask
    {standard input}:249    .text.xTimerCreateTimerTask:0000003c $d
    {standard input}:625    .text.prvTimerTask:00000000 prvTimerTask
    {standard input}:257    .text.xTimerCreate:00000000 $t
    {standard input}:262    .text.xTimerCreate:00000000 xTimerCreate
    {standard input}:348    .text.xTimerGenericCommand:00000000 $t
    {standard input}:353    .text.xTimerGenericCommand:00000000 xTimerGenericCommand
    {standard input}:452    .text.xTimerGenericCommand:0000005c $d
    {standard input}:457    .text.prvSampleTimeNow:00000000 $t
    {standard input}:461    .text.prvSampleTimeNow:00000000 prvSampleTimeNow
    {standard input}:614    .text.prvSampleTimeNow:000000a4 $d
    {standard input}:621    .text.prvTimerTask:00000000 $t
    {standard input}:863    .text.prvTimerTask:0000010a $d
    {standard input}:873    .text.prvTimerTask:00000114 $t
    {standard input}:1004   .text.prvTimerTask:000001d4 $d
    {standard input}:1014   .text.xTimerGetTimerDaemonTaskHandle:00000000 $t
    {standard input}:1019   .text.xTimerGetTimerDaemonTaskHandle:00000000 xTimerGetTimerDaemonTaskHandle
    {standard input}:1053   .text.xTimerGetTimerDaemonTaskHandle:0000001c $d
    {standard input}:1058   .text.xTimerGetPeriod:00000000 $t
    {standard input}:1063   .text.xTimerGetPeriod:00000000 xTimerGetPeriod
    {standard input}:1099   .text.vTimerSetReloadMode:00000000 $t
    {standard input}:1104   .text.vTimerSetReloadMode:00000000 vTimerSetReloadMode
    {standard input}:1165   .text.uxTimerGetReloadMode:00000000 $t
    {standard input}:1170   .text.uxTimerGetReloadMode:00000000 uxTimerGetReloadMode
    {standard input}:1222   .text.xTimerGetExpiryTime:00000000 $t
    {standard input}:1227   .text.xTimerGetExpiryTime:00000000 xTimerGetExpiryTime
    {standard input}:1264   .text.pcTimerGetName:00000000 $t
    {standard input}:1269   .text.pcTimerGetName:00000000 pcTimerGetName
    {standard input}:1305   .text.xTimerIsTimerActive:00000000 $t
    {standard input}:1310   .text.xTimerIsTimerActive:00000000 xTimerIsTimerActive
    {standard input}:1362   .text.pvTimerGetTimerID:00000000 $t
    {standard input}:1367   .text.pvTimerGetTimerID:00000000 pvTimerGetTimerID
    {standard input}:1417   .text.vTimerSetTimerID:00000000 $t
    {standard input}:1422   .text.vTimerSetTimerID:00000000 vTimerSetTimerID
    {standard input}:1472   .text.uxTimerGetTimerNumber:00000000 $t
    {standard input}:1477   .text.uxTimerGetTimerNumber:00000000 uxTimerGetTimerNumber
    {standard input}:1493   .text.vTimerSetTimerNumber:00000000 $t
    {standard input}:1498   .text.vTimerSetTimerNumber:00000000 vTimerSetTimerNumber
    {standard input}:1513   .bss.pxCurrentTimerList:00000000 $d
    {standard input}:1517   .bss.pxCurrentTimerList:00000000 pxCurrentTimerList
    {standard input}:1520   .bss.xActiveTimerList1:00000000 $d
    {standard input}:1524   .bss.xActiveTimerList1:00000000 xActiveTimerList1
    {standard input}:1527   .bss.xActiveTimerList2:00000000 $d
    {standard input}:1531   .bss.xActiveTimerList2:00000000 xActiveTimerList2
    {standard input}:1534   .rodata.str1.4:00000000 $d
    {standard input}:1541   .bss.xTimerQueue:00000000 $d
    {standard input}:1545   .bss.xTimerQueue:00000000 xTimerQueue
    {standard input}:1548   .bss.pxOverflowTimerList:00000000 $d
    {standard input}:1552   .bss.pxOverflowTimerList:00000000 pxOverflowTimerList
    {standard input}:1555   .bss.xTimerTaskHandle:00000000 $d
    {standard input}:1559   .bss.xTimerTaskHandle:00000000 xTimerTaskHandle
    {standard input}:1562   .bss.xLastTime.5394:00000000 $d
    {standard input}:1566   .bss.xLastTime.5394:00000000 xLastTime.5394
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.0.3466fc6a3db32493c997d085de4c7a28
                           .group:00000000 wm4.newlib.h.8.fe7d912fc917043c98742c35eddd8cff
                           .group:00000000 wm4.features.h.22.bee0aee4a3878f51861c775df98fa3ea
                           .group:00000000 wm4.config.h.216.aad1ef7bee4fb69981cb38ce62f84d9c
                           .group:00000000 wm4._ansi.h.23.9f8fcfa20193763fcf364fb91705c94b
                           .group:00000000 wm4.stdlib.h.13.4ed386f5c1a80d71e72172885d946ef2
                           .group:00000000 wm4.stddef.h.184.aa65fb7281d578229bbad41b91862635
                           .group:00000000 wm4.stddef.h.39.dc09cac7e3f758f23d559f6b28ebbb0d
                           .group:00000000 wm4._default_types.h.6.35ee9e747940367bf2a634907d1c2382
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4._types.h.54.d3d34a3b7f3cc230cd159baf022b4b08
                           .group:00000000 wm4.stddef.h.158.61317cdbfb4026324507d123a50b0fd6
                           .group:00000000 wm4.reent.h.17.8bd9e4098e0428508c282cad794fae43
                           .group:00000000 wm4.alloca.h.8.dfc0c703c47ec3e69746825b17d9e66d
                           .group:00000000 wm4.stdlib.h.53.fe81d5186f74ee22c982a1a79f340ee8
                           .group:00000000 wm4._intsup.h.10.ca9f32a61b410c270a48d1161ca2c217
                           .group:00000000 wm4.stdint.h.22.f4a337c398d8b6d821a97202448bc0d0
                           .group:00000000 wm4.FreeRTOSConfig.h.30.aa43eb1cb33228d5c7e359a94d48589b
                           .group:00000000 wm4.projdefs.h.28.d6a7c9061b707820f2fcf4c2ff5d9f24
                           .group:00000000 wm4.portmacro.h.30.2ddc2eaf2e032c76c597fb78c4365041
                           .group:00000000 wm4.portable.h.63.e9cc508c3850f44ce542149380c67812
                           .group:00000000 wm4.mpu_wrappers.h.28.163fb40577cf8d1578015ea3f2ff4cdb
                           .group:00000000 wm4.FreeRTOS.h.67.9945f39eea4ddeb224c0782392206292
                           .group:00000000 wm4.list.h.57.02ec67e07eacffe5ca7cfb7326896236
                           .group:00000000 wm4.task.h.47.2d3fe49a094b8ec1e3e6aac441e8db21
                           .group:00000000 wm4.queue.h.66.45d4a3cf5de24cde7e732f8dad25383c
                           .group:00000000 wm4.timers.h.29.025d268d6baf57298309e7b498ee1cc7

UNDEFINED SYMBOLS
vListInsert
vPortEnterCritical
vListInitialise
xQueueGenericCreate
vQueueAddToRegistry
vPortExitCritical
xTaskCreate
pvPortMalloc
vListInitialiseItem
xTaskGetSchedulerState
xQueueGenericSend
xQueueGenericSendFromISR
xTaskGetTickCount
uxListRemove
vTaskSuspendAll
xTaskResumeAll
vQueueWaitForMessageRestricted
vPortFree
xQueueReceive
