   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .eabi_attribute 28,1
   5              	 .fpu fpv4-sp-d16
   6              	 .eabi_attribute 23,1
   7              	 .eabi_attribute 24,1
   8              	 .eabi_attribute 25,1
   9              	 .eabi_attribute 26,1
  10              	 .eabi_attribute 30,1
  11              	 .eabi_attribute 34,1
  12              	 .eabi_attribute 18,4
  13              	 .thumb
  14              	 .file "tasks.c"
  15              	 .text
  16              	.Ltext0:
  17              	 .cfi_sections .debug_frame
  18              	 .section .text.prvTaskIsTaskSuspended,"ax",%progbits
  19              	 .align 2
  20              	 .thumb
  21              	 .thumb_func
  23              	prvTaskIsTaskSuspended:
  24              	.LFB16:
  25              	 .file 1 "../FreeRTOS/Source/tasks.c"
   1:../FreeRTOS/Source/tasks.c **** /*
   2:../FreeRTOS/Source/tasks.c ****  * FreeRTOS Kernel V10.4.1
   3:../FreeRTOS/Source/tasks.c ****  * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:../FreeRTOS/Source/tasks.c ****  *
   5:../FreeRTOS/Source/tasks.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:../FreeRTOS/Source/tasks.c ****  * this software and associated documentation files (the "Software"), to deal in
   7:../FreeRTOS/Source/tasks.c ****  * the Software without restriction, including without limitation the rights to
   8:../FreeRTOS/Source/tasks.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:../FreeRTOS/Source/tasks.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:../FreeRTOS/Source/tasks.c ****  * subject to the following conditions:
  11:../FreeRTOS/Source/tasks.c ****  *
  12:../FreeRTOS/Source/tasks.c ****  * The above copyright notice and this permission notice shall be included in all
  13:../FreeRTOS/Source/tasks.c ****  * copies or substantial portions of the Software.
  14:../FreeRTOS/Source/tasks.c ****  *
  15:../FreeRTOS/Source/tasks.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:../FreeRTOS/Source/tasks.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:../FreeRTOS/Source/tasks.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:../FreeRTOS/Source/tasks.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:../FreeRTOS/Source/tasks.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:../FreeRTOS/Source/tasks.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:../FreeRTOS/Source/tasks.c ****  *
  22:../FreeRTOS/Source/tasks.c ****  * https://www.FreeRTOS.org
  23:../FreeRTOS/Source/tasks.c ****  * https://github.com/FreeRTOS
  24:../FreeRTOS/Source/tasks.c ****  *
  25:../FreeRTOS/Source/tasks.c ****  */
  26:../FreeRTOS/Source/tasks.c **** 
  27:../FreeRTOS/Source/tasks.c **** /* Standard includes. */
  28:../FreeRTOS/Source/tasks.c **** #include <stdlib.h>
  29:../FreeRTOS/Source/tasks.c **** #include <string.h>
  30:../FreeRTOS/Source/tasks.c **** 
  31:../FreeRTOS/Source/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  32:../FreeRTOS/Source/tasks.c ****  * all the API functions to use the MPU wrappers.  That should only be done when
  33:../FreeRTOS/Source/tasks.c ****  * task.h is included from an application file. */
  34:../FreeRTOS/Source/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  35:../FreeRTOS/Source/tasks.c **** 
  36:../FreeRTOS/Source/tasks.c **** /* FreeRTOS includes. */
  37:../FreeRTOS/Source/tasks.c **** #include "FreeRTOS.h"
  38:../FreeRTOS/Source/tasks.c **** #include "task.h"
  39:../FreeRTOS/Source/tasks.c **** #include "timers.h"
  40:../FreeRTOS/Source/tasks.c **** #include "stack_macros.h"
  41:../FreeRTOS/Source/tasks.c **** 
  42:../FreeRTOS/Source/tasks.c **** /* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
  43:../FreeRTOS/Source/tasks.c ****  * because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
  44:../FreeRTOS/Source/tasks.c ****  * for the header files above, but not in this file, in order to generate the
  45:../FreeRTOS/Source/tasks.c ****  * correct privileged Vs unprivileged linkage and placement. */
  46:../FreeRTOS/Source/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
  47:../FreeRTOS/Source/tasks.c **** 
  48:../FreeRTOS/Source/tasks.c **** /* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
  49:../FreeRTOS/Source/tasks.c ****  * functions but without including stdio.h here. */
  50:../FreeRTOS/Source/tasks.c **** #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
  51:../FreeRTOS/Source/tasks.c **** 
  52:../FreeRTOS/Source/tasks.c **** /* At the bottom of this file are two optional functions that can be used
  53:../FreeRTOS/Source/tasks.c ****  * to generate human readable text from the raw data generated by the
  54:../FreeRTOS/Source/tasks.c ****  * uxTaskGetSystemState() function.  Note the formatting functions are provided
  55:../FreeRTOS/Source/tasks.c ****  * for convenience only, and are NOT considered part of the kernel. */
  56:../FreeRTOS/Source/tasks.c ****     #include <stdio.h>
  57:../FreeRTOS/Source/tasks.c **** #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
  58:../FreeRTOS/Source/tasks.c **** 
  59:../FreeRTOS/Source/tasks.c **** #if ( configUSE_PREEMPTION == 0 )
  60:../FreeRTOS/Source/tasks.c **** 
  61:../FreeRTOS/Source/tasks.c **** /* If the cooperative scheduler is being used then a yield should not be
  62:../FreeRTOS/Source/tasks.c ****  * performed just because a higher priority task has been woken. */
  63:../FreeRTOS/Source/tasks.c ****     #define taskYIELD_IF_USING_PREEMPTION()
  64:../FreeRTOS/Source/tasks.c **** #else
  65:../FreeRTOS/Source/tasks.c ****     #define taskYIELD_IF_USING_PREEMPTION()    portYIELD_WITHIN_API()
  66:../FreeRTOS/Source/tasks.c **** #endif
  67:../FreeRTOS/Source/tasks.c **** 
  68:../FreeRTOS/Source/tasks.c **** /* Values that can be assigned to the ucNotifyState member of the TCB. */
  69:../FreeRTOS/Source/tasks.c **** #define taskNOT_WAITING_NOTIFICATION              ( ( uint8_t ) 0 ) /* Must be zero as it is the in
  70:../FreeRTOS/Source/tasks.c **** #define taskWAITING_NOTIFICATION                  ( ( uint8_t ) 1 )
  71:../FreeRTOS/Source/tasks.c **** #define taskNOTIFICATION_RECEIVED                 ( ( uint8_t ) 2 )
  72:../FreeRTOS/Source/tasks.c **** 
  73:../FreeRTOS/Source/tasks.c **** /*
  74:../FreeRTOS/Source/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
  75:../FreeRTOS/Source/tasks.c ****  * is used purely for checking the high water mark for tasks.
  76:../FreeRTOS/Source/tasks.c ****  */
  77:../FreeRTOS/Source/tasks.c **** #define tskSTACK_FILL_BYTE                        ( 0xa5U )
  78:../FreeRTOS/Source/tasks.c **** 
  79:../FreeRTOS/Source/tasks.c **** /* Bits used to recored how a task's stack and TCB were allocated. */
  80:../FreeRTOS/Source/tasks.c **** #define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB    ( ( uint8_t ) 0 )
  81:../FreeRTOS/Source/tasks.c **** #define tskSTATICALLY_ALLOCATED_STACK_ONLY        ( ( uint8_t ) 1 )
  82:../FreeRTOS/Source/tasks.c **** #define tskSTATICALLY_ALLOCATED_STACK_AND_TCB     ( ( uint8_t ) 2 )
  83:../FreeRTOS/Source/tasks.c **** 
  84:../FreeRTOS/Source/tasks.c **** /* If any of the following are set then task stacks are filled with a known
  85:../FreeRTOS/Source/tasks.c ****  * value so the high water mark can be determined.  If none of the following are
  86:../FreeRTOS/Source/tasks.c ****  * set then don't fill the stack so there is no unnecessary dependency on memset. */
  87:../FreeRTOS/Source/tasks.c **** #if ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTa
  88:../FreeRTOS/Source/tasks.c ****     #define tskSET_NEW_STACKS_TO_KNOWN_VALUE    1
  89:../FreeRTOS/Source/tasks.c **** #else
  90:../FreeRTOS/Source/tasks.c ****     #define tskSET_NEW_STACKS_TO_KNOWN_VALUE    0
  91:../FreeRTOS/Source/tasks.c **** #endif
  92:../FreeRTOS/Source/tasks.c **** 
  93:../FreeRTOS/Source/tasks.c **** /*
  94:../FreeRTOS/Source/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
  95:../FreeRTOS/Source/tasks.c ****  */
  96:../FreeRTOS/Source/tasks.c **** #define tskRUNNING_CHAR      ( 'X' )
  97:../FreeRTOS/Source/tasks.c **** #define tskBLOCKED_CHAR      ( 'B' )
  98:../FreeRTOS/Source/tasks.c **** #define tskREADY_CHAR        ( 'R' )
  99:../FreeRTOS/Source/tasks.c **** #define tskDELETED_CHAR      ( 'D' )
 100:../FreeRTOS/Source/tasks.c **** #define tskSUSPENDED_CHAR    ( 'S' )
 101:../FreeRTOS/Source/tasks.c **** 
 102:../FreeRTOS/Source/tasks.c **** /*
 103:../FreeRTOS/Source/tasks.c ****  * Some kernel aware debuggers require the data the debugger needs access to be
 104:../FreeRTOS/Source/tasks.c ****  * global, rather than file scope.
 105:../FreeRTOS/Source/tasks.c ****  */
 106:../FreeRTOS/Source/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 107:../FreeRTOS/Source/tasks.c ****     #define static
 108:../FreeRTOS/Source/tasks.c **** #endif
 109:../FreeRTOS/Source/tasks.c **** 
 110:../FreeRTOS/Source/tasks.c **** /* The name allocated to the Idle task.  This can be overridden by defining
 111:../FreeRTOS/Source/tasks.c ****  * configIDLE_TASK_NAME in FreeRTOSConfig.h. */
 112:../FreeRTOS/Source/tasks.c **** #ifndef configIDLE_TASK_NAME
 113:../FreeRTOS/Source/tasks.c ****     #define configIDLE_TASK_NAME    "IDLE"
 114:../FreeRTOS/Source/tasks.c **** #endif
 115:../FreeRTOS/Source/tasks.c **** 
 116:../FreeRTOS/Source/tasks.c **** #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
 117:../FreeRTOS/Source/tasks.c **** 
 118:../FreeRTOS/Source/tasks.c **** /* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
 119:../FreeRTOS/Source/tasks.c ****  * performed in a generic way that is not optimised to any particular
 120:../FreeRTOS/Source/tasks.c ****  * microcontroller architecture. */
 121:../FreeRTOS/Source/tasks.c **** 
 122:../FreeRTOS/Source/tasks.c **** /* uxTopReadyPriority holds the priority of the highest priority ready
 123:../FreeRTOS/Source/tasks.c ****  * state task. */
 124:../FreeRTOS/Source/tasks.c ****     #define taskRECORD_READY_PRIORITY( uxPriority ) \
 125:../FreeRTOS/Source/tasks.c ****     {                                               \
 126:../FreeRTOS/Source/tasks.c ****         if( ( uxPriority ) > uxTopReadyPriority )   \
 127:../FreeRTOS/Source/tasks.c ****         {                                           \
 128:../FreeRTOS/Source/tasks.c ****             uxTopReadyPriority = ( uxPriority );    \
 129:../FreeRTOS/Source/tasks.c ****         }                                           \
 130:../FreeRTOS/Source/tasks.c ****     } /* taskRECORD_READY_PRIORITY */
 131:../FreeRTOS/Source/tasks.c **** 
 132:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 133:../FreeRTOS/Source/tasks.c **** 
 134:../FreeRTOS/Source/tasks.c ****     #define taskSELECT_HIGHEST_PRIORITY_TASK()                                \
 135:../FreeRTOS/Source/tasks.c ****     {                                                                         \
 136:../FreeRTOS/Source/tasks.c ****         UBaseType_t uxTopPriority = uxTopReadyPriority;                       \
 137:../FreeRTOS/Source/tasks.c ****                                                                               \
 138:../FreeRTOS/Source/tasks.c ****         /* Find the highest priority queue that contains ready tasks. */      \
 139:../FreeRTOS/Source/tasks.c ****         while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopPriority ] ) ) ) \
 140:../FreeRTOS/Source/tasks.c ****         {                                                                     \
 141:../FreeRTOS/Source/tasks.c ****             configASSERT( uxTopPriority );                                    \
 142:../FreeRTOS/Source/tasks.c ****             --uxTopPriority;                                                  \
 143:../FreeRTOS/Source/tasks.c ****         }                                                                     \
 144:../FreeRTOS/Source/tasks.c ****                                                                               \
 145:../FreeRTOS/Source/tasks.c ****         /* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of \
 146:../FreeRTOS/Source/tasks.c ****          * the  same priority get an equal share of the processor time. */                    \
 147:../FreeRTOS/Source/tasks.c ****         listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) ); \
 148:../FreeRTOS/Source/tasks.c ****         uxTopReadyPriority = uxTopPriority;                                                   \
 149:../FreeRTOS/Source/tasks.c ****     } /* taskSELECT_HIGHEST_PRIORITY_TASK */
 150:../FreeRTOS/Source/tasks.c **** 
 151:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 152:../FreeRTOS/Source/tasks.c **** 
 153:../FreeRTOS/Source/tasks.c **** /* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
 154:../FreeRTOS/Source/tasks.c ****  * they are only required when a port optimised method of task selection is
 155:../FreeRTOS/Source/tasks.c ****  * being used. */
 156:../FreeRTOS/Source/tasks.c ****     #define taskRESET_READY_PRIORITY( uxPriority )
 157:../FreeRTOS/Source/tasks.c ****     #define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
 158:../FreeRTOS/Source/tasks.c **** 
 159:../FreeRTOS/Source/tasks.c **** #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 160:../FreeRTOS/Source/tasks.c **** 
 161:../FreeRTOS/Source/tasks.c **** /* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
 162:../FreeRTOS/Source/tasks.c ****  * performed in a way that is tailored to the particular microcontroller
 163:../FreeRTOS/Source/tasks.c ****  * architecture being used. */
 164:../FreeRTOS/Source/tasks.c **** 
 165:../FreeRTOS/Source/tasks.c **** /* A port optimised version is provided.  Call the port defined macros. */
 166:../FreeRTOS/Source/tasks.c ****     #define taskRECORD_READY_PRIORITY( uxPriority )    portRECORD_READY_PRIORITY( uxPriority, uxTop
 167:../FreeRTOS/Source/tasks.c **** 
 168:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 169:../FreeRTOS/Source/tasks.c **** 
 170:../FreeRTOS/Source/tasks.c ****     #define taskSELECT_HIGHEST_PRIORITY_TASK()                                                  \
 171:../FreeRTOS/Source/tasks.c ****     {                                                                                           \
 172:../FreeRTOS/Source/tasks.c ****         UBaseType_t uxTopPriority;                                                              \
 173:../FreeRTOS/Source/tasks.c ****                                                                                                 \
 174:../FreeRTOS/Source/tasks.c ****         /* Find the highest priority list that contains ready tasks. */                         \
 175:../FreeRTOS/Source/tasks.c ****         portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );                          \
 176:../FreeRTOS/Source/tasks.c ****         configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 ); \
 177:../FreeRTOS/Source/tasks.c ****         listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );   \
 178:../FreeRTOS/Source/tasks.c ****     } /* taskSELECT_HIGHEST_PRIORITY_TASK() */
 179:../FreeRTOS/Source/tasks.c **** 
 180:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 181:../FreeRTOS/Source/tasks.c **** 
 182:../FreeRTOS/Source/tasks.c **** /* A port optimised version is provided, call it only if the TCB being reset
 183:../FreeRTOS/Source/tasks.c ****  * is being referenced from a ready list.  If it is referenced from a delayed
 184:../FreeRTOS/Source/tasks.c ****  * or suspended list then it won't be in a ready list. */
 185:../FreeRTOS/Source/tasks.c ****     #define taskRESET_READY_PRIORITY( uxPriority )                                                 
 186:../FreeRTOS/Source/tasks.c ****     {                                                                                              
 187:../FreeRTOS/Source/tasks.c ****         if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 
 188:../FreeRTOS/Source/tasks.c ****         {                                                                                          
 189:../FreeRTOS/Source/tasks.c ****             portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );                    
 190:../FreeRTOS/Source/tasks.c ****         }                                                                                          
 191:../FreeRTOS/Source/tasks.c ****     }
 192:../FreeRTOS/Source/tasks.c **** 
 193:../FreeRTOS/Source/tasks.c **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 194:../FreeRTOS/Source/tasks.c **** 
 195:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 196:../FreeRTOS/Source/tasks.c **** 
 197:../FreeRTOS/Source/tasks.c **** /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
 198:../FreeRTOS/Source/tasks.c ****  * count overflows. */
 199:../FreeRTOS/Source/tasks.c **** #define taskSWITCH_DELAYED_LISTS()                                                \
 200:../FreeRTOS/Source/tasks.c ****     {                                                                             \
 201:../FreeRTOS/Source/tasks.c ****         List_t * pxTemp;                                                          \
 202:../FreeRTOS/Source/tasks.c ****                                                                                   \
 203:../FreeRTOS/Source/tasks.c ****         /* The delayed tasks list should be empty when the lists are switched. */ \
 204:../FreeRTOS/Source/tasks.c ****         configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );               \
 205:../FreeRTOS/Source/tasks.c ****                                                                                   \
 206:../FreeRTOS/Source/tasks.c ****         pxTemp = pxDelayedTaskList;                                               \
 207:../FreeRTOS/Source/tasks.c ****         pxDelayedTaskList = pxOverflowDelayedTaskList;                            \
 208:../FreeRTOS/Source/tasks.c ****         pxOverflowDelayedTaskList = pxTemp;                                       \
 209:../FreeRTOS/Source/tasks.c ****         xNumOfOverflows++;                                                        \
 210:../FreeRTOS/Source/tasks.c ****         prvResetNextTaskUnblockTime();                                            \
 211:../FreeRTOS/Source/tasks.c ****     }
 212:../FreeRTOS/Source/tasks.c **** 
 213:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 214:../FreeRTOS/Source/tasks.c **** 
 215:../FreeRTOS/Source/tasks.c **** /*
 216:../FreeRTOS/Source/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready list for
 217:../FreeRTOS/Source/tasks.c ****  * the task.  It is inserted at the end of the list.
 218:../FreeRTOS/Source/tasks.c ****  */
 219:../FreeRTOS/Source/tasks.c **** #define prvAddTaskToReadyList( pxTCB )                                                             
 220:../FreeRTOS/Source/tasks.c ****     traceMOVED_TASK_TO_READY_STATE( pxTCB );                                                       
 221:../FreeRTOS/Source/tasks.c ****     taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );                                            
 222:../FreeRTOS/Source/tasks.c ****     vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xStateListItem )
 223:../FreeRTOS/Source/tasks.c ****     tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
 224:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 225:../FreeRTOS/Source/tasks.c **** 
 226:../FreeRTOS/Source/tasks.c **** /*
 227:../FreeRTOS/Source/tasks.c ****  * Several functions take an TaskHandle_t parameter that can optionally be NULL,
 228:../FreeRTOS/Source/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 229:../FreeRTOS/Source/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 230:../FreeRTOS/Source/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 231:../FreeRTOS/Source/tasks.c ****  */
 232:../FreeRTOS/Source/tasks.c **** #define prvGetTCBFromHandle( pxHandle )    ( ( ( pxHandle ) == NULL ) ? pxCurrentTCB : ( pxHandle )
 233:../FreeRTOS/Source/tasks.c **** 
 234:../FreeRTOS/Source/tasks.c **** /* The item value of the event list item is normally used to hold the priority
 235:../FreeRTOS/Source/tasks.c ****  * of the task to which it belongs (coded to allow it to be held in reverse
 236:../FreeRTOS/Source/tasks.c ****  * priority order).  However, it is occasionally borrowed for other purposes.  It
 237:../FreeRTOS/Source/tasks.c ****  * is important its value is not updated due to a task priority change while it is
 238:../FreeRTOS/Source/tasks.c ****  * being used for another purpose.  The following bit definition is used to inform
 239:../FreeRTOS/Source/tasks.c ****  * the scheduler that the value should not be changed - in which case it is the
 240:../FreeRTOS/Source/tasks.c ****  * responsibility of whichever module is using the value to ensure it gets set back
 241:../FreeRTOS/Source/tasks.c ****  * to its original value when it is released. */
 242:../FreeRTOS/Source/tasks.c **** #if ( configUSE_16_BIT_TICKS == 1 )
 243:../FreeRTOS/Source/tasks.c ****     #define taskEVENT_LIST_ITEM_VALUE_IN_USE    0x8000U
 244:../FreeRTOS/Source/tasks.c **** #else
 245:../FreeRTOS/Source/tasks.c ****     #define taskEVENT_LIST_ITEM_VALUE_IN_USE    0x80000000UL
 246:../FreeRTOS/Source/tasks.c **** #endif
 247:../FreeRTOS/Source/tasks.c **** 
 248:../FreeRTOS/Source/tasks.c **** /*
 249:../FreeRTOS/Source/tasks.c ****  * Task control block.  A task control block (TCB) is allocated for each task,
 250:../FreeRTOS/Source/tasks.c ****  * and stores task state information, including a pointer to the task's context
 251:../FreeRTOS/Source/tasks.c ****  * (the task's run time environment, including register values)
 252:../FreeRTOS/Source/tasks.c ****  */
 253:../FreeRTOS/Source/tasks.c **** typedef struct tskTaskControlBlock       /* The old naming convention is used to prevent breaking k
 254:../FreeRTOS/Source/tasks.c **** {
 255:../FreeRTOS/Source/tasks.c ****     volatile StackType_t * pxTopOfStack; /*< Points to the location of the last item placed on the 
 256:../FreeRTOS/Source/tasks.c **** 
 257:../FreeRTOS/Source/tasks.c ****     #if ( portUSING_MPU_WRAPPERS == 1 )
 258:../FreeRTOS/Source/tasks.c ****         xMPU_SETTINGS xMPUSettings; /*< The MPU settings are defined as part of the port layer.  TH
 259:../FreeRTOS/Source/tasks.c ****     #endif
 260:../FreeRTOS/Source/tasks.c **** 
 261:../FreeRTOS/Source/tasks.c ****     ListItem_t xStateListItem;                  /*< The list that the state list item of a task is 
 262:../FreeRTOS/Source/tasks.c ****     ListItem_t xEventListItem;                  /*< Used to reference a task from an event list. */
 263:../FreeRTOS/Source/tasks.c ****     UBaseType_t uxPriority;                     /*< The priority of the task.  0 is the lowest prio
 264:../FreeRTOS/Source/tasks.c ****     StackType_t * pxStack;                      /*< Points to the start of the stack. */
 265:../FreeRTOS/Source/tasks.c ****     char pcTaskName[ configMAX_TASK_NAME_LEN ]; /*< Descriptive name given to the task when created
 266:../FreeRTOS/Source/tasks.c **** 
 267:../FreeRTOS/Source/tasks.c ****     #if ( ( portSTACK_GROWTH > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
 268:../FreeRTOS/Source/tasks.c ****         StackType_t * pxEndOfStack; /*< Points to the highest valid address for the stack. */
 269:../FreeRTOS/Source/tasks.c ****     #endif
 270:../FreeRTOS/Source/tasks.c **** 
 271:../FreeRTOS/Source/tasks.c ****     #if ( portCRITICAL_NESTING_IN_TCB == 1 )
 272:../FreeRTOS/Source/tasks.c ****         UBaseType_t uxCriticalNesting; /*< Holds the critical section nesting depth for ports that 
 273:../FreeRTOS/Source/tasks.c ****     #endif
 274:../FreeRTOS/Source/tasks.c **** 
 275:../FreeRTOS/Source/tasks.c ****     #if ( configUSE_TRACE_FACILITY == 1 )
 276:../FreeRTOS/Source/tasks.c ****         UBaseType_t uxTCBNumber;  /*< Stores a number that increments each time a TCB is created.  
 277:../FreeRTOS/Source/tasks.c ****         UBaseType_t uxTaskNumber; /*< Stores a number specifically for use by third party trace cod
 278:../FreeRTOS/Source/tasks.c ****     #endif
 279:../FreeRTOS/Source/tasks.c **** 
 280:../FreeRTOS/Source/tasks.c ****     #if ( configUSE_MUTEXES == 1 )
 281:../FreeRTOS/Source/tasks.c ****         UBaseType_t uxBasePriority; /*< The priority last assigned to the task - used by the priori
 282:../FreeRTOS/Source/tasks.c ****         UBaseType_t uxMutexesHeld;
 283:../FreeRTOS/Source/tasks.c ****     #endif
 284:../FreeRTOS/Source/tasks.c **** 
 285:../FreeRTOS/Source/tasks.c ****     #if ( configUSE_APPLICATION_TASK_TAG == 1 )
 286:../FreeRTOS/Source/tasks.c ****         TaskHookFunction_t pxTaskTag;
 287:../FreeRTOS/Source/tasks.c ****     #endif
 288:../FreeRTOS/Source/tasks.c **** 
 289:../FreeRTOS/Source/tasks.c ****     #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
 290:../FreeRTOS/Source/tasks.c ****         void * pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
 291:../FreeRTOS/Source/tasks.c ****     #endif
 292:../FreeRTOS/Source/tasks.c **** 
 293:../FreeRTOS/Source/tasks.c ****     #if ( configGENERATE_RUN_TIME_STATS == 1 )
 294:../FreeRTOS/Source/tasks.c ****         uint32_t ulRunTimeCounter; /*< Stores the amount of time the task has spent in the Running 
 295:../FreeRTOS/Source/tasks.c ****     #endif
 296:../FreeRTOS/Source/tasks.c **** 
 297:../FreeRTOS/Source/tasks.c ****     #if ( configUSE_NEWLIB_REENTRANT == 1 )
 298:../FreeRTOS/Source/tasks.c **** 
 299:../FreeRTOS/Source/tasks.c ****         /* Allocate a Newlib reent structure that is specific to this task.
 300:../FreeRTOS/Source/tasks.c ****          * Note Newlib support has been included by popular demand, but is not
 301:../FreeRTOS/Source/tasks.c ****          * used by the FreeRTOS maintainers themselves.  FreeRTOS is not
 302:../FreeRTOS/Source/tasks.c ****          * responsible for resulting newlib operation.  User must be familiar with
 303:../FreeRTOS/Source/tasks.c ****          * newlib and must provide system-wide implementations of the necessary
 304:../FreeRTOS/Source/tasks.c ****          * stubs. Be warned that (at the time of writing) the current newlib design
 305:../FreeRTOS/Source/tasks.c ****          * implements a system-wide malloc() that must be provided with locks.
 306:../FreeRTOS/Source/tasks.c ****          *
 307:../FreeRTOS/Source/tasks.c ****          * See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
 308:../FreeRTOS/Source/tasks.c ****          * for additional information. */
 309:../FreeRTOS/Source/tasks.c ****         struct  _reent xNewLib_reent;
 310:../FreeRTOS/Source/tasks.c ****     #endif
 311:../FreeRTOS/Source/tasks.c **** 
 312:../FreeRTOS/Source/tasks.c ****     #if ( configUSE_TASK_NOTIFICATIONS == 1 )
 313:../FreeRTOS/Source/tasks.c ****         volatile uint32_t ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];
 314:../FreeRTOS/Source/tasks.c ****         volatile uint8_t ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];
 315:../FreeRTOS/Source/tasks.c ****     #endif
 316:../FreeRTOS/Source/tasks.c **** 
 317:../FreeRTOS/Source/tasks.c ****     /* See the comments in FreeRTOS.h with the definition of
 318:../FreeRTOS/Source/tasks.c ****      * tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */
 319:../FreeRTOS/Source/tasks.c ****     #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been conso
 320:../FreeRTOS/Source/tasks.c ****         uint8_t ucStaticallyAllocated;                     /*< Set to pdTRUE if the task is a stati
 321:../FreeRTOS/Source/tasks.c ****     #endif
 322:../FreeRTOS/Source/tasks.c **** 
 323:../FreeRTOS/Source/tasks.c ****     #if ( INCLUDE_xTaskAbortDelay == 1 )
 324:../FreeRTOS/Source/tasks.c ****         uint8_t ucDelayAborted;
 325:../FreeRTOS/Source/tasks.c ****     #endif
 326:../FreeRTOS/Source/tasks.c **** 
 327:../FreeRTOS/Source/tasks.c ****     #if ( configUSE_POSIX_ERRNO == 1 )
 328:../FreeRTOS/Source/tasks.c ****         int iTaskErrno;
 329:../FreeRTOS/Source/tasks.c ****     #endif
 330:../FreeRTOS/Source/tasks.c **** } tskTCB;
 331:../FreeRTOS/Source/tasks.c **** 
 332:../FreeRTOS/Source/tasks.c **** /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
 333:../FreeRTOS/Source/tasks.c ****  * below to enable the use of older kernel aware debuggers. */
 334:../FreeRTOS/Source/tasks.c **** typedef tskTCB TCB_t;
 335:../FreeRTOS/Source/tasks.c **** 
 336:../FreeRTOS/Source/tasks.c **** /*lint -save -e956 A manual analysis and inspection has been used to determine
 337:../FreeRTOS/Source/tasks.c ****  * which static variables must be declared volatile. */
 338:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
 339:../FreeRTOS/Source/tasks.c **** 
 340:../FreeRTOS/Source/tasks.c **** /* Lists for ready and blocked tasks. --------------------
 341:../FreeRTOS/Source/tasks.c ****  * xDelayedTaskList1 and xDelayedTaskList2 could be move to function scople but
 342:../FreeRTOS/Source/tasks.c ****  * doing so breaks some kernel aware debuggers and debuggers that rely on removing
 343:../FreeRTOS/Source/tasks.c ****  * the static qualifier. */
 344:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ]; /*< Prioritised ready task
 345:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList1;                         /*< Delayed tasks. */
 346:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList2;                         /*< Delayed tasks (two lis
 347:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;              /*< Points to the delayed 
 348:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;      /*< Points to the delayed 
 349:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t xPendingReadyList;                         /*< Tasks that have been r
 350:../FreeRTOS/Source/tasks.c **** 
 351:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 352:../FreeRTOS/Source/tasks.c **** 
 353:../FreeRTOS/Source/tasks.c ****     PRIVILEGED_DATA static List_t xTasksWaitingTermination; /*< Tasks that have been deleted - but 
 354:../FreeRTOS/Source/tasks.c ****     PRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
 355:../FreeRTOS/Source/tasks.c **** 
 356:../FreeRTOS/Source/tasks.c **** #endif
 357:../FreeRTOS/Source/tasks.c **** 
 358:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 359:../FreeRTOS/Source/tasks.c **** 
 360:../FreeRTOS/Source/tasks.c ****     PRIVILEGED_DATA static List_t xSuspendedTaskList; /*< Tasks that are currently suspended. */
 361:../FreeRTOS/Source/tasks.c **** 
 362:../FreeRTOS/Source/tasks.c **** #endif
 363:../FreeRTOS/Source/tasks.c **** 
 364:../FreeRTOS/Source/tasks.c **** /* Global POSIX errno. Its value is changed upon context switching to match
 365:../FreeRTOS/Source/tasks.c ****  * the errno of the currently running task. */
 366:../FreeRTOS/Source/tasks.c **** #if ( configUSE_POSIX_ERRNO == 1 )
 367:../FreeRTOS/Source/tasks.c ****     int FreeRTOS_errno = 0;
 368:../FreeRTOS/Source/tasks.c **** #endif
 369:../FreeRTOS/Source/tasks.c **** 
 370:../FreeRTOS/Source/tasks.c **** /* Other file private variables. --------------------------------*/
 371:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
 372:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 373:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority = tskIDLE_PRIORITY;
 374:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning = pdFALSE;
 375:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xPendedTicks = ( TickType_t ) 0U;
 376:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xYieldPending = pdFALSE;
 377:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows = ( BaseType_t ) 0;
 378:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static UBaseType_t uxTaskNumber = ( UBaseType_t ) 0U;
 379:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime = ( TickType_t ) 0U; /* Initialised
 380:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle = NULL;                          /*< Holds the 
 381:../FreeRTOS/Source/tasks.c **** 
 382:../FreeRTOS/Source/tasks.c **** /* Context switches are held pending while the scheduler is suspended.  Also,
 383:../FreeRTOS/Source/tasks.c ****  * interrupts must not manipulate the xStateListItem of a TCB, or any of the
 384:../FreeRTOS/Source/tasks.c ****  * lists the xStateListItem can be referenced from, if the scheduler is suspended.
 385:../FreeRTOS/Source/tasks.c ****  * If an interrupt needs to unblock a task while the scheduler is suspended then it
 386:../FreeRTOS/Source/tasks.c ****  * moves the task's event list item into the xPendingReadyList, ready for the
 387:../FreeRTOS/Source/tasks.c ****  * kernel to move the task from the pending ready list into the real ready list
 388:../FreeRTOS/Source/tasks.c ****  * when the scheduler is unsuspended.  The pending ready list itself can only be
 389:../FreeRTOS/Source/tasks.c ****  * accessed from a critical section. */
 390:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended = ( UBaseType_t ) pdFALSE;
 391:../FreeRTOS/Source/tasks.c **** 
 392:../FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 393:../FreeRTOS/Source/tasks.c **** 
 394:../FreeRTOS/Source/tasks.c **** /* Do not move these variables to function scope as doing so prevents the
 395:../FreeRTOS/Source/tasks.c ****  * code working with debuggers that need to remove the static qualifier. */
 396:../FreeRTOS/Source/tasks.c ****     PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;    /*< Holds the value of a timer/c
 397:../FreeRTOS/Source/tasks.c ****     PRIVILEGED_DATA static volatile uint32_t ulTotalRunTime = 0UL; /*< Holds the total amount of ex
 398:../FreeRTOS/Source/tasks.c **** 
 399:../FreeRTOS/Source/tasks.c **** #endif
 400:../FreeRTOS/Source/tasks.c **** 
 401:../FreeRTOS/Source/tasks.c **** /*lint -restore */
 402:../FreeRTOS/Source/tasks.c **** 
 403:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 404:../FreeRTOS/Source/tasks.c **** 
 405:../FreeRTOS/Source/tasks.c **** /* File private functions. --------------------------------*/
 406:../FreeRTOS/Source/tasks.c **** 
 407:../FreeRTOS/Source/tasks.c **** /**
 408:../FreeRTOS/Source/tasks.c ****  * Utility task that simply returns pdTRUE if the task referenced by xTask is
 409:../FreeRTOS/Source/tasks.c ****  * currently in the Suspended state, or pdFALSE if the task referenced by xTask
 410:../FreeRTOS/Source/tasks.c ****  * is in any other state.
 411:../FreeRTOS/Source/tasks.c ****  */
 412:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 413:../FreeRTOS/Source/tasks.c **** 
 414:../FreeRTOS/Source/tasks.c ****     static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
 415:../FreeRTOS/Source/tasks.c **** 
 416:../FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
 417:../FreeRTOS/Source/tasks.c **** 
 418:../FreeRTOS/Source/tasks.c **** /*
 419:../FreeRTOS/Source/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 420:../FreeRTOS/Source/tasks.c ****  * automatically upon the creation of the first task.
 421:../FreeRTOS/Source/tasks.c ****  */
 422:../FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 423:../FreeRTOS/Source/tasks.c **** 
 424:../FreeRTOS/Source/tasks.c **** /*
 425:../FreeRTOS/Source/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 426:../FreeRTOS/Source/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 427:../FreeRTOS/Source/tasks.c ****  * creation of the first user task.
 428:../FreeRTOS/Source/tasks.c ****  *
 429:../FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 430:../FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 431:../FreeRTOS/Source/tasks.c ****  *
 432:../FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
 433:../FreeRTOS/Source/tasks.c ****  *
 434:../FreeRTOS/Source/tasks.c ****  */
 435:../FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters ) PRIVILEGED_FUNCTION;
 436:../FreeRTOS/Source/tasks.c **** 
 437:../FreeRTOS/Source/tasks.c **** /*
 438:../FreeRTOS/Source/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 439:../FreeRTOS/Source/tasks.c ****  * including the stack pointed to by the TCB.
 440:../FreeRTOS/Source/tasks.c ****  *
 441:../FreeRTOS/Source/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 442:../FreeRTOS/Source/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 443:../FreeRTOS/Source/tasks.c ****  */
 444:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 445:../FreeRTOS/Source/tasks.c **** 
 446:../FreeRTOS/Source/tasks.c ****     static void prvDeleteTCB( TCB_t * pxTCB ) PRIVILEGED_FUNCTION;
 447:../FreeRTOS/Source/tasks.c **** 
 448:../FreeRTOS/Source/tasks.c **** #endif
 449:../FreeRTOS/Source/tasks.c **** 
 450:../FreeRTOS/Source/tasks.c **** /*
 451:../FreeRTOS/Source/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 452:../FreeRTOS/Source/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 453:../FreeRTOS/Source/tasks.c ****  * and its TCB deleted.
 454:../FreeRTOS/Source/tasks.c ****  */
 455:../FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 456:../FreeRTOS/Source/tasks.c **** 
 457:../FreeRTOS/Source/tasks.c **** /*
 458:../FreeRTOS/Source/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 459:../FreeRTOS/Source/tasks.c ****  * either the current or the overflow delayed task list.
 460:../FreeRTOS/Source/tasks.c ****  */
 461:../FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
 462:../FreeRTOS/Source/tasks.c ****                                             const BaseType_t xCanBlockIndefinitely ) PRIVILEGED_FUN
 463:../FreeRTOS/Source/tasks.c **** 
 464:../FreeRTOS/Source/tasks.c **** /*
 465:../FreeRTOS/Source/tasks.c ****  * Fills an TaskStatus_t structure with information on each task that is
 466:../FreeRTOS/Source/tasks.c ****  * referenced from the pxList list (which may be a ready list, a delayed list,
 467:../FreeRTOS/Source/tasks.c ****  * a suspended list, etc.).
 468:../FreeRTOS/Source/tasks.c ****  *
 469:../FreeRTOS/Source/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 470:../FreeRTOS/Source/tasks.c ****  * NORMAL APPLICATION CODE.
 471:../FreeRTOS/Source/tasks.c ****  */
 472:../FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 473:../FreeRTOS/Source/tasks.c **** 
 474:../FreeRTOS/Source/tasks.c ****     static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t * pxTaskStatusArray,
 475:../FreeRTOS/Source/tasks.c ****                                                      List_t * pxList,
 476:../FreeRTOS/Source/tasks.c ****                                                      eTaskState eState ) PRIVILEGED_FUNCTION;
 477:../FreeRTOS/Source/tasks.c **** 
 478:../FreeRTOS/Source/tasks.c **** #endif
 479:../FreeRTOS/Source/tasks.c **** 
 480:../FreeRTOS/Source/tasks.c **** /*
 481:../FreeRTOS/Source/tasks.c ****  * Searches pxList for a task with name pcNameToQuery - returning a handle to
 482:../FreeRTOS/Source/tasks.c ****  * the task if it is found, or NULL if the task is not found.
 483:../FreeRTOS/Source/tasks.c ****  */
 484:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
 485:../FreeRTOS/Source/tasks.c **** 
 486:../FreeRTOS/Source/tasks.c ****     static TCB_t * prvSearchForNameWithinSingleList( List_t * pxList,
 487:../FreeRTOS/Source/tasks.c ****                                                      const char pcNameToQuery[] ) PRIVILEGED_FUNCTI
 488:../FreeRTOS/Source/tasks.c **** 
 489:../FreeRTOS/Source/tasks.c **** #endif
 490:../FreeRTOS/Source/tasks.c **** 
 491:../FreeRTOS/Source/tasks.c **** /*
 492:../FreeRTOS/Source/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 493:../FreeRTOS/Source/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 494:../FreeRTOS/Source/tasks.c ****  * determining how much of the stack remains at the original preset value.
 495:../FreeRTOS/Source/tasks.c ****  */
 496:../FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUD
 497:../FreeRTOS/Source/tasks.c **** 
 498:../FreeRTOS/Source/tasks.c ****     static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVIL
 499:../FreeRTOS/Source/tasks.c **** 
 500:../FreeRTOS/Source/tasks.c **** #endif
 501:../FreeRTOS/Source/tasks.c **** 
 502:../FreeRTOS/Source/tasks.c **** /*
 503:../FreeRTOS/Source/tasks.c ****  * Return the amount of time, in ticks, that will pass before the kernel will
 504:../FreeRTOS/Source/tasks.c ****  * next move a task from the Blocked state to the Running state.
 505:../FreeRTOS/Source/tasks.c ****  *
 506:../FreeRTOS/Source/tasks.c ****  * This conditional compilation should use inequality to 0, not equality to 1.
 507:../FreeRTOS/Source/tasks.c ****  * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
 508:../FreeRTOS/Source/tasks.c ****  * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
 509:../FreeRTOS/Source/tasks.c ****  * set to a value other than 1.
 510:../FreeRTOS/Source/tasks.c ****  */
 511:../FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
 512:../FreeRTOS/Source/tasks.c **** 
 513:../FreeRTOS/Source/tasks.c ****     static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
 514:../FreeRTOS/Source/tasks.c **** 
 515:../FreeRTOS/Source/tasks.c **** #endif
 516:../FreeRTOS/Source/tasks.c **** 
 517:../FreeRTOS/Source/tasks.c **** /*
 518:../FreeRTOS/Source/tasks.c ****  * Set xNextTaskUnblockTime to the time at which the next Blocked state task
 519:../FreeRTOS/Source/tasks.c ****  * will exit the Blocked state.
 520:../FreeRTOS/Source/tasks.c ****  */
 521:../FreeRTOS/Source/tasks.c **** static void prvResetNextTaskUnblockTime( void ) PRIVILEGED_FUNCTION;
 522:../FreeRTOS/Source/tasks.c **** 
 523:../FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
 524:../FreeRTOS/Source/tasks.c **** 
 525:../FreeRTOS/Source/tasks.c **** /*
 526:../FreeRTOS/Source/tasks.c ****  * Helper function used to pad task names with spaces when printing out
 527:../FreeRTOS/Source/tasks.c ****  * human readable tables of task information.
 528:../FreeRTOS/Source/tasks.c ****  */
 529:../FreeRTOS/Source/tasks.c ****     static char * prvWriteNameToBuffer( char * pcBuffer,
 530:../FreeRTOS/Source/tasks.c ****                                         const char * pcTaskName ) PRIVILEGED_FUNCTION;
 531:../FreeRTOS/Source/tasks.c **** 
 532:../FreeRTOS/Source/tasks.c **** #endif
 533:../FreeRTOS/Source/tasks.c **** 
 534:../FreeRTOS/Source/tasks.c **** /*
 535:../FreeRTOS/Source/tasks.c ****  * Called after a Task_t structure has been allocated either statically or
 536:../FreeRTOS/Source/tasks.c ****  * dynamically to fill in the structure's members.
 537:../FreeRTOS/Source/tasks.c ****  */
 538:../FreeRTOS/Source/tasks.c **** static void prvInitialiseNewTask( TaskFunction_t pxTaskCode,
 539:../FreeRTOS/Source/tasks.c ****                                   const char * const pcName, /*lint !e971 Unqualified char types ar
 540:../FreeRTOS/Source/tasks.c ****                                   const uint32_t ulStackDepth,
 541:../FreeRTOS/Source/tasks.c ****                                   void * const pvParameters,
 542:../FreeRTOS/Source/tasks.c ****                                   UBaseType_t uxPriority,
 543:../FreeRTOS/Source/tasks.c ****                                   TaskHandle_t * const pxCreatedTask,
 544:../FreeRTOS/Source/tasks.c ****                                   TCB_t * pxNewTCB,
 545:../FreeRTOS/Source/tasks.c ****                                   const MemoryRegion_t * const xRegions ) PRIVILEGED_FUNCTION;
 546:../FreeRTOS/Source/tasks.c **** 
 547:../FreeRTOS/Source/tasks.c **** /*
 548:../FreeRTOS/Source/tasks.c ****  * Called after a new task has been created and initialised to place the task
 549:../FreeRTOS/Source/tasks.c ****  * under the control of the scheduler.
 550:../FreeRTOS/Source/tasks.c ****  */
 551:../FreeRTOS/Source/tasks.c **** static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB ) PRIVILEGED_FUNCTION;
 552:../FreeRTOS/Source/tasks.c **** 
 553:../FreeRTOS/Source/tasks.c **** /*
 554:../FreeRTOS/Source/tasks.c ****  * freertos_tasks_c_additions_init() should only be called if the user definable
 555:../FreeRTOS/Source/tasks.c ****  * macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is the only macro
 556:../FreeRTOS/Source/tasks.c ****  * called by the function.
 557:../FreeRTOS/Source/tasks.c ****  */
 558:../FreeRTOS/Source/tasks.c **** #ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
 559:../FreeRTOS/Source/tasks.c **** 
 560:../FreeRTOS/Source/tasks.c ****     static void freertos_tasks_c_additions_init( void ) PRIVILEGED_FUNCTION;
 561:../FreeRTOS/Source/tasks.c **** 
 562:../FreeRTOS/Source/tasks.c **** #endif
 563:../FreeRTOS/Source/tasks.c **** 
 564:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 565:../FreeRTOS/Source/tasks.c **** 
 566:../FreeRTOS/Source/tasks.c **** #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
 567:../FreeRTOS/Source/tasks.c **** 
 568:../FreeRTOS/Source/tasks.c ****     TaskHandle_t xTaskCreateStatic( TaskFunction_t pxTaskCode,
 569:../FreeRTOS/Source/tasks.c ****                                     const char * const pcName, /*lint !e971 Unqualified char types 
 570:../FreeRTOS/Source/tasks.c ****                                     const uint32_t ulStackDepth,
 571:../FreeRTOS/Source/tasks.c ****                                     void * const pvParameters,
 572:../FreeRTOS/Source/tasks.c ****                                     UBaseType_t uxPriority,
 573:../FreeRTOS/Source/tasks.c ****                                     StackType_t * const puxStackBuffer,
 574:../FreeRTOS/Source/tasks.c ****                                     StaticTask_t * const pxTaskBuffer )
 575:../FreeRTOS/Source/tasks.c ****     {
 576:../FreeRTOS/Source/tasks.c ****         TCB_t * pxNewTCB;
 577:../FreeRTOS/Source/tasks.c ****         TaskHandle_t xReturn;
 578:../FreeRTOS/Source/tasks.c **** 
 579:../FreeRTOS/Source/tasks.c ****         configASSERT( puxStackBuffer != NULL );
 580:../FreeRTOS/Source/tasks.c ****         configASSERT( pxTaskBuffer != NULL );
 581:../FreeRTOS/Source/tasks.c **** 
 582:../FreeRTOS/Source/tasks.c ****         #if ( configASSERT_DEFINED == 1 )
 583:../FreeRTOS/Source/tasks.c ****             {
 584:../FreeRTOS/Source/tasks.c ****                 /* Sanity check that the size of the structure used to declare a
 585:../FreeRTOS/Source/tasks.c ****                  * variable of type StaticTask_t equals the size of the real task
 586:../FreeRTOS/Source/tasks.c ****                  * structure. */
 587:../FreeRTOS/Source/tasks.c ****                 volatile size_t xSize = sizeof( StaticTask_t );
 588:../FreeRTOS/Source/tasks.c ****                 configASSERT( xSize == sizeof( TCB_t ) );
 589:../FreeRTOS/Source/tasks.c ****                 ( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
 590:../FreeRTOS/Source/tasks.c ****             }
 591:../FreeRTOS/Source/tasks.c ****         #endif /* configASSERT_DEFINED */
 592:../FreeRTOS/Source/tasks.c **** 
 593:../FreeRTOS/Source/tasks.c ****         if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
 594:../FreeRTOS/Source/tasks.c ****         {
 595:../FreeRTOS/Source/tasks.c ****             /* The memory used for the task's TCB and stack are passed into this
 596:../FreeRTOS/Source/tasks.c ****              * function - use them. */
 597:../FreeRTOS/Source/tasks.c ****             pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 !e9087 Unusual cast is ok as the stru
 598:../FreeRTOS/Source/tasks.c ****             pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 599:../FreeRTOS/Source/tasks.c **** 
 600:../FreeRTOS/Source/tasks.c ****             #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has be
 601:../FreeRTOS/Source/tasks.c ****                 {
 602:../FreeRTOS/Source/tasks.c ****                     /* Tasks can be created statically or dynamically, so note this
 603:../FreeRTOS/Source/tasks.c ****                      * task was created statically in case the task is later deleted. */
 604:../FreeRTOS/Source/tasks.c ****                     pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 605:../FreeRTOS/Source/tasks.c ****                 }
 606:../FreeRTOS/Source/tasks.c ****             #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
 607:../FreeRTOS/Source/tasks.c **** 
 608:../FreeRTOS/Source/tasks.c ****             prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xRet
 609:../FreeRTOS/Source/tasks.c ****             prvAddNewTaskToReadyList( pxNewTCB );
 610:../FreeRTOS/Source/tasks.c ****         }
 611:../FreeRTOS/Source/tasks.c ****         else
 612:../FreeRTOS/Source/tasks.c ****         {
 613:../FreeRTOS/Source/tasks.c ****             xReturn = NULL;
 614:../FreeRTOS/Source/tasks.c ****         }
 615:../FreeRTOS/Source/tasks.c **** 
 616:../FreeRTOS/Source/tasks.c ****         return xReturn;
 617:../FreeRTOS/Source/tasks.c ****     }
 618:../FreeRTOS/Source/tasks.c **** 
 619:../FreeRTOS/Source/tasks.c **** #endif /* SUPPORT_STATIC_ALLOCATION */
 620:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 621:../FreeRTOS/Source/tasks.c **** 
 622:../FreeRTOS/Source/tasks.c **** #if ( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 623:../FreeRTOS/Source/tasks.c **** 
 624:../FreeRTOS/Source/tasks.c ****     BaseType_t xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition,
 625:../FreeRTOS/Source/tasks.c ****                                             TaskHandle_t * pxCreatedTask )
 626:../FreeRTOS/Source/tasks.c ****     {
 627:../FreeRTOS/Source/tasks.c ****         TCB_t * pxNewTCB;
 628:../FreeRTOS/Source/tasks.c ****         BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 629:../FreeRTOS/Source/tasks.c **** 
 630:../FreeRTOS/Source/tasks.c ****         configASSERT( pxTaskDefinition->puxStackBuffer != NULL );
 631:../FreeRTOS/Source/tasks.c ****         configASSERT( pxTaskDefinition->pxTaskBuffer != NULL );
 632:../FreeRTOS/Source/tasks.c **** 
 633:../FreeRTOS/Source/tasks.c ****         if( ( pxTaskDefinition->puxStackBuffer != NULL ) && ( pxTaskDefinition->pxTaskBuffer != NUL
 634:../FreeRTOS/Source/tasks.c ****         {
 635:../FreeRTOS/Source/tasks.c ****             /* Allocate space for the TCB.  Where the memory comes from depends
 636:../FreeRTOS/Source/tasks.c ****              * on the implementation of the port malloc function and whether or
 637:../FreeRTOS/Source/tasks.c ****              * not static allocation is being used. */
 638:../FreeRTOS/Source/tasks.c ****             pxNewTCB = ( TCB_t * ) pxTaskDefinition->pxTaskBuffer;
 639:../FreeRTOS/Source/tasks.c **** 
 640:../FreeRTOS/Source/tasks.c ****             /* Store the stack location in the TCB. */
 641:../FreeRTOS/Source/tasks.c ****             pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
 642:../FreeRTOS/Source/tasks.c **** 
 643:../FreeRTOS/Source/tasks.c ****             #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
 644:../FreeRTOS/Source/tasks.c ****                 {
 645:../FreeRTOS/Source/tasks.c ****                     /* Tasks can be created statically or dynamically, so note this
 646:../FreeRTOS/Source/tasks.c ****                      * task was created statically in case the task is later deleted. */
 647:../FreeRTOS/Source/tasks.c ****                     pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 648:../FreeRTOS/Source/tasks.c ****                 }
 649:../FreeRTOS/Source/tasks.c ****             #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
 650:../FreeRTOS/Source/tasks.c **** 
 651:../FreeRTOS/Source/tasks.c ****             prvInitialiseNewTask( pxTaskDefinition->pvTaskCode,
 652:../FreeRTOS/Source/tasks.c ****                                   pxTaskDefinition->pcName,
 653:../FreeRTOS/Source/tasks.c ****                                   ( uint32_t ) pxTaskDefinition->usStackDepth,
 654:../FreeRTOS/Source/tasks.c ****                                   pxTaskDefinition->pvParameters,
 655:../FreeRTOS/Source/tasks.c ****                                   pxTaskDefinition->uxPriority,
 656:../FreeRTOS/Source/tasks.c ****                                   pxCreatedTask, pxNewTCB,
 657:../FreeRTOS/Source/tasks.c ****                                   pxTaskDefinition->xRegions );
 658:../FreeRTOS/Source/tasks.c **** 
 659:../FreeRTOS/Source/tasks.c ****             prvAddNewTaskToReadyList( pxNewTCB );
 660:../FreeRTOS/Source/tasks.c ****             xReturn = pdPASS;
 661:../FreeRTOS/Source/tasks.c ****         }
 662:../FreeRTOS/Source/tasks.c **** 
 663:../FreeRTOS/Source/tasks.c ****         return xReturn;
 664:../FreeRTOS/Source/tasks.c ****     }
 665:../FreeRTOS/Source/tasks.c **** 
 666:../FreeRTOS/Source/tasks.c **** #endif /* ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
 667:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 668:../FreeRTOS/Source/tasks.c **** 
 669:../FreeRTOS/Source/tasks.c **** #if ( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 670:../FreeRTOS/Source/tasks.c **** 
 671:../FreeRTOS/Source/tasks.c ****     BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition,
 672:../FreeRTOS/Source/tasks.c ****                                       TaskHandle_t * pxCreatedTask )
 673:../FreeRTOS/Source/tasks.c ****     {
 674:../FreeRTOS/Source/tasks.c ****         TCB_t * pxNewTCB;
 675:../FreeRTOS/Source/tasks.c ****         BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 676:../FreeRTOS/Source/tasks.c **** 
 677:../FreeRTOS/Source/tasks.c ****         configASSERT( pxTaskDefinition->puxStackBuffer );
 678:../FreeRTOS/Source/tasks.c **** 
 679:../FreeRTOS/Source/tasks.c ****         if( pxTaskDefinition->puxStackBuffer != NULL )
 680:../FreeRTOS/Source/tasks.c ****         {
 681:../FreeRTOS/Source/tasks.c ****             /* Allocate space for the TCB.  Where the memory comes from depends
 682:../FreeRTOS/Source/tasks.c ****              * on the implementation of the port malloc function and whether or
 683:../FreeRTOS/Source/tasks.c ****              * not static allocation is being used. */
 684:../FreeRTOS/Source/tasks.c ****             pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 685:../FreeRTOS/Source/tasks.c **** 
 686:../FreeRTOS/Source/tasks.c ****             if( pxNewTCB != NULL )
 687:../FreeRTOS/Source/tasks.c ****             {
 688:../FreeRTOS/Source/tasks.c ****                 /* Store the stack location in the TCB. */
 689:../FreeRTOS/Source/tasks.c ****                 pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
 690:../FreeRTOS/Source/tasks.c **** 
 691:../FreeRTOS/Source/tasks.c ****                 #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
 692:../FreeRTOS/Source/tasks.c ****                     {
 693:../FreeRTOS/Source/tasks.c ****                         /* Tasks can be created statically or dynamically, so note
 694:../FreeRTOS/Source/tasks.c ****                          * this task had a statically allocated stack in case it is
 695:../FreeRTOS/Source/tasks.c ****                          * later deleted.  The TCB was allocated dynamically. */
 696:../FreeRTOS/Source/tasks.c ****                         pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;
 697:../FreeRTOS/Source/tasks.c ****                     }
 698:../FreeRTOS/Source/tasks.c ****                 #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
 699:../FreeRTOS/Source/tasks.c **** 
 700:../FreeRTOS/Source/tasks.c ****                 prvInitialiseNewTask( pxTaskDefinition->pvTaskCode,
 701:../FreeRTOS/Source/tasks.c ****                                       pxTaskDefinition->pcName,
 702:../FreeRTOS/Source/tasks.c ****                                       ( uint32_t ) pxTaskDefinition->usStackDepth,
 703:../FreeRTOS/Source/tasks.c ****                                       pxTaskDefinition->pvParameters,
 704:../FreeRTOS/Source/tasks.c ****                                       pxTaskDefinition->uxPriority,
 705:../FreeRTOS/Source/tasks.c ****                                       pxCreatedTask, pxNewTCB,
 706:../FreeRTOS/Source/tasks.c ****                                       pxTaskDefinition->xRegions );
 707:../FreeRTOS/Source/tasks.c **** 
 708:../FreeRTOS/Source/tasks.c ****                 prvAddNewTaskToReadyList( pxNewTCB );
 709:../FreeRTOS/Source/tasks.c ****                 xReturn = pdPASS;
 710:../FreeRTOS/Source/tasks.c ****             }
 711:../FreeRTOS/Source/tasks.c ****         }
 712:../FreeRTOS/Source/tasks.c **** 
 713:../FreeRTOS/Source/tasks.c ****         return xReturn;
 714:../FreeRTOS/Source/tasks.c ****     }
 715:../FreeRTOS/Source/tasks.c **** 
 716:../FreeRTOS/Source/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
 717:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 718:../FreeRTOS/Source/tasks.c **** 
 719:../FreeRTOS/Source/tasks.c **** #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 720:../FreeRTOS/Source/tasks.c **** 
 721:../FreeRTOS/Source/tasks.c ****     BaseType_t xTaskCreate( TaskFunction_t pxTaskCode,
 722:../FreeRTOS/Source/tasks.c ****                             const char * const pcName, /*lint !e971 Unqualified char types are allo
 723:../FreeRTOS/Source/tasks.c ****                             const configSTACK_DEPTH_TYPE usStackDepth,
 724:../FreeRTOS/Source/tasks.c ****                             void * const pvParameters,
 725:../FreeRTOS/Source/tasks.c ****                             UBaseType_t uxPriority,
 726:../FreeRTOS/Source/tasks.c ****                             TaskHandle_t * const pxCreatedTask )
 727:../FreeRTOS/Source/tasks.c ****     {
 728:../FreeRTOS/Source/tasks.c ****         TCB_t * pxNewTCB;
 729:../FreeRTOS/Source/tasks.c ****         BaseType_t xReturn;
 730:../FreeRTOS/Source/tasks.c **** 
 731:../FreeRTOS/Source/tasks.c ****         /* If the stack grows down then allocate the stack then the TCB so the stack
 732:../FreeRTOS/Source/tasks.c ****          * does not grow into the TCB.  Likewise if the stack grows up then allocate
 733:../FreeRTOS/Source/tasks.c ****          * the TCB then the stack. */
 734:../FreeRTOS/Source/tasks.c ****         #if ( portSTACK_GROWTH > 0 )
 735:../FreeRTOS/Source/tasks.c ****             {
 736:../FreeRTOS/Source/tasks.c ****                 /* Allocate space for the TCB.  Where the memory comes from depends on
 737:../FreeRTOS/Source/tasks.c ****                  * the implementation of the port malloc function and whether or not static
 738:../FreeRTOS/Source/tasks.c ****                  * allocation is being used. */
 739:../FreeRTOS/Source/tasks.c ****                 pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 740:../FreeRTOS/Source/tasks.c **** 
 741:../FreeRTOS/Source/tasks.c ****                 if( pxNewTCB != NULL )
 742:../FreeRTOS/Source/tasks.c ****                 {
 743:../FreeRTOS/Source/tasks.c ****                     /* Allocate space for the stack used by the task being created.
 744:../FreeRTOS/Source/tasks.c ****                      * The base of the stack memory stored in the TCB so the task can
 745:../FreeRTOS/Source/tasks.c ****                      * be deleted later if required. */
 746:../FreeRTOS/Source/tasks.c ****                     pxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth
 747:../FreeRTOS/Source/tasks.c **** 
 748:../FreeRTOS/Source/tasks.c ****                     if( pxNewTCB->pxStack == NULL )
 749:../FreeRTOS/Source/tasks.c ****                     {
 750:../FreeRTOS/Source/tasks.c ****                         /* Could not allocate the stack.  Delete the allocated TCB. */
 751:../FreeRTOS/Source/tasks.c ****                         vPortFree( pxNewTCB );
 752:../FreeRTOS/Source/tasks.c ****                         pxNewTCB = NULL;
 753:../FreeRTOS/Source/tasks.c ****                     }
 754:../FreeRTOS/Source/tasks.c ****                 }
 755:../FreeRTOS/Source/tasks.c ****             }
 756:../FreeRTOS/Source/tasks.c ****         #else /* portSTACK_GROWTH */
 757:../FreeRTOS/Source/tasks.c ****             {
 758:../FreeRTOS/Source/tasks.c ****                 StackType_t * pxStack;
 759:../FreeRTOS/Source/tasks.c **** 
 760:../FreeRTOS/Source/tasks.c ****                 /* Allocate space for the stack used by the task being created. */
 761:../FreeRTOS/Source/tasks.c ****                 pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); 
 762:../FreeRTOS/Source/tasks.c **** 
 763:../FreeRTOS/Source/tasks.c ****                 if( pxStack != NULL )
 764:../FreeRTOS/Source/tasks.c ****                 {
 765:../FreeRTOS/Source/tasks.c ****                     /* Allocate space for the TCB. */
 766:../FreeRTOS/Source/tasks.c ****                     pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 Al
 767:../FreeRTOS/Source/tasks.c **** 
 768:../FreeRTOS/Source/tasks.c ****                     if( pxNewTCB != NULL )
 769:../FreeRTOS/Source/tasks.c ****                     {
 770:../FreeRTOS/Source/tasks.c ****                         /* Store the stack location in the TCB. */
 771:../FreeRTOS/Source/tasks.c ****                         pxNewTCB->pxStack = pxStack;
 772:../FreeRTOS/Source/tasks.c ****                     }
 773:../FreeRTOS/Source/tasks.c ****                     else
 774:../FreeRTOS/Source/tasks.c ****                     {
 775:../FreeRTOS/Source/tasks.c ****                         /* The stack cannot be used as the TCB was not created.  Free
 776:../FreeRTOS/Source/tasks.c ****                          * it again. */
 777:../FreeRTOS/Source/tasks.c ****                         vPortFree( pxStack );
 778:../FreeRTOS/Source/tasks.c ****                     }
 779:../FreeRTOS/Source/tasks.c ****                 }
 780:../FreeRTOS/Source/tasks.c ****                 else
 781:../FreeRTOS/Source/tasks.c ****                 {
 782:../FreeRTOS/Source/tasks.c ****                     pxNewTCB = NULL;
 783:../FreeRTOS/Source/tasks.c ****                 }
 784:../FreeRTOS/Source/tasks.c ****             }
 785:../FreeRTOS/Source/tasks.c ****         #endif /* portSTACK_GROWTH */
 786:../FreeRTOS/Source/tasks.c **** 
 787:../FreeRTOS/Source/tasks.c ****         if( pxNewTCB != NULL )
 788:../FreeRTOS/Source/tasks.c ****         {
 789:../FreeRTOS/Source/tasks.c ****             #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e9029 !e731 Macro has be
 790:../FreeRTOS/Source/tasks.c ****                 {
 791:../FreeRTOS/Source/tasks.c ****                     /* Tasks can be created statically or dynamically, so note this
 792:../FreeRTOS/Source/tasks.c ****                      * task was created dynamically in case it is later deleted. */
 793:../FreeRTOS/Source/tasks.c ****                     pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 794:../FreeRTOS/Source/tasks.c ****                 }
 795:../FreeRTOS/Source/tasks.c ****             #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
 796:../FreeRTOS/Source/tasks.c **** 
 797:../FreeRTOS/Source/tasks.c ****             prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPr
 798:../FreeRTOS/Source/tasks.c ****             prvAddNewTaskToReadyList( pxNewTCB );
 799:../FreeRTOS/Source/tasks.c ****             xReturn = pdPASS;
 800:../FreeRTOS/Source/tasks.c ****         }
 801:../FreeRTOS/Source/tasks.c ****         else
 802:../FreeRTOS/Source/tasks.c ****         {
 803:../FreeRTOS/Source/tasks.c ****             xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 804:../FreeRTOS/Source/tasks.c ****         }
 805:../FreeRTOS/Source/tasks.c **** 
 806:../FreeRTOS/Source/tasks.c ****         return xReturn;
 807:../FreeRTOS/Source/tasks.c ****     }
 808:../FreeRTOS/Source/tasks.c **** 
 809:../FreeRTOS/Source/tasks.c **** #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 810:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 811:../FreeRTOS/Source/tasks.c **** 
 812:../FreeRTOS/Source/tasks.c **** static void prvInitialiseNewTask( TaskFunction_t pxTaskCode,
 813:../FreeRTOS/Source/tasks.c ****                                   const char * const pcName, /*lint !e971 Unqualified char types ar
 814:../FreeRTOS/Source/tasks.c ****                                   const uint32_t ulStackDepth,
 815:../FreeRTOS/Source/tasks.c ****                                   void * const pvParameters,
 816:../FreeRTOS/Source/tasks.c ****                                   UBaseType_t uxPriority,
 817:../FreeRTOS/Source/tasks.c ****                                   TaskHandle_t * const pxCreatedTask,
 818:../FreeRTOS/Source/tasks.c ****                                   TCB_t * pxNewTCB,
 819:../FreeRTOS/Source/tasks.c ****                                   const MemoryRegion_t * const xRegions )
 820:../FreeRTOS/Source/tasks.c **** {
 821:../FreeRTOS/Source/tasks.c ****     StackType_t * pxTopOfStack;
 822:../FreeRTOS/Source/tasks.c ****     UBaseType_t x;
 823:../FreeRTOS/Source/tasks.c **** 
 824:../FreeRTOS/Source/tasks.c ****     #if ( portUSING_MPU_WRAPPERS == 1 )
 825:../FreeRTOS/Source/tasks.c ****         /* Should the task be created in privileged mode? */
 826:../FreeRTOS/Source/tasks.c ****         BaseType_t xRunPrivileged;
 827:../FreeRTOS/Source/tasks.c **** 
 828:../FreeRTOS/Source/tasks.c ****         if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 829:../FreeRTOS/Source/tasks.c ****         {
 830:../FreeRTOS/Source/tasks.c ****             xRunPrivileged = pdTRUE;
 831:../FreeRTOS/Source/tasks.c ****         }
 832:../FreeRTOS/Source/tasks.c ****         else
 833:../FreeRTOS/Source/tasks.c ****         {
 834:../FreeRTOS/Source/tasks.c ****             xRunPrivileged = pdFALSE;
 835:../FreeRTOS/Source/tasks.c ****         }
 836:../FreeRTOS/Source/tasks.c ****         uxPriority &= ~portPRIVILEGE_BIT;
 837:../FreeRTOS/Source/tasks.c ****     #endif /* portUSING_MPU_WRAPPERS == 1 */
 838:../FreeRTOS/Source/tasks.c **** 
 839:../FreeRTOS/Source/tasks.c ****     /* Avoid dependency on memset() if it is not required. */
 840:../FreeRTOS/Source/tasks.c ****     #if ( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
 841:../FreeRTOS/Source/tasks.c ****         {
 842:../FreeRTOS/Source/tasks.c ****             /* Fill the stack with a known value to assist debugging. */
 843:../FreeRTOS/Source/tasks.c ****             ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth
 844:../FreeRTOS/Source/tasks.c ****         }
 845:../FreeRTOS/Source/tasks.c ****     #endif /* tskSET_NEW_STACKS_TO_KNOWN_VALUE */
 846:../FreeRTOS/Source/tasks.c **** 
 847:../FreeRTOS/Source/tasks.c ****     /* Calculate the top of stack address.  This depends on whether the stack
 848:../FreeRTOS/Source/tasks.c ****      * grows from high memory to low (as per the 80x86) or vice versa.
 849:../FreeRTOS/Source/tasks.c ****      * portSTACK_GROWTH is used to make the result positive or negative as required
 850:../FreeRTOS/Source/tasks.c ****      * by the port. */
 851:../FreeRTOS/Source/tasks.c ****     #if ( portSTACK_GROWTH < 0 )
 852:../FreeRTOS/Source/tasks.c ****         {
 853:../FreeRTOS/Source/tasks.c ****             pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 854:../FreeRTOS/Source/tasks.c ****             pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( 
 855:../FreeRTOS/Source/tasks.c **** 
 856:../FreeRTOS/Source/tasks.c ****             /* Check the alignment of the calculated top of stack is correct. */
 857:../FreeRTOS/Source/tasks.c ****             configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) po
 858:../FreeRTOS/Source/tasks.c **** 
 859:../FreeRTOS/Source/tasks.c ****             #if ( configRECORD_STACK_HIGH_ADDRESS == 1 )
 860:../FreeRTOS/Source/tasks.c ****                 {
 861:../FreeRTOS/Source/tasks.c ****                     /* Also record the stack's high address, which may assist
 862:../FreeRTOS/Source/tasks.c ****                      * debugging. */
 863:../FreeRTOS/Source/tasks.c ****                     pxNewTCB->pxEndOfStack = pxTopOfStack;
 864:../FreeRTOS/Source/tasks.c ****                 }
 865:../FreeRTOS/Source/tasks.c ****             #endif /* configRECORD_STACK_HIGH_ADDRESS */
 866:../FreeRTOS/Source/tasks.c ****         }
 867:../FreeRTOS/Source/tasks.c ****     #else /* portSTACK_GROWTH */
 868:../FreeRTOS/Source/tasks.c ****         {
 869:../FreeRTOS/Source/tasks.c ****             pxTopOfStack = pxNewTCB->pxStack;
 870:../FreeRTOS/Source/tasks.c **** 
 871:../FreeRTOS/Source/tasks.c ****             /* Check the alignment of the stack buffer is correct. */
 872:../FreeRTOS/Source/tasks.c ****             configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE
 873:../FreeRTOS/Source/tasks.c **** 
 874:../FreeRTOS/Source/tasks.c ****             /* The other extreme of the stack space is required if stack checking is
 875:../FreeRTOS/Source/tasks.c ****              * performed. */
 876:../FreeRTOS/Source/tasks.c ****             pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 877:../FreeRTOS/Source/tasks.c ****         }
 878:../FreeRTOS/Source/tasks.c ****     #endif /* portSTACK_GROWTH */
 879:../FreeRTOS/Source/tasks.c **** 
 880:../FreeRTOS/Source/tasks.c ****     /* Store the task name in the TCB. */
 881:../FreeRTOS/Source/tasks.c ****     if( pcName != NULL )
 882:../FreeRTOS/Source/tasks.c ****     {
 883:../FreeRTOS/Source/tasks.c ****         for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 884:../FreeRTOS/Source/tasks.c ****         {
 885:../FreeRTOS/Source/tasks.c ****             pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 886:../FreeRTOS/Source/tasks.c **** 
 887:../FreeRTOS/Source/tasks.c ****             /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
 888:../FreeRTOS/Source/tasks.c ****              * configMAX_TASK_NAME_LEN characters just in case the memory after the
 889:../FreeRTOS/Source/tasks.c ****              * string is not accessible (extremely unlikely). */
 890:../FreeRTOS/Source/tasks.c ****             if( pcName[ x ] == ( char ) 0x00 )
 891:../FreeRTOS/Source/tasks.c ****             {
 892:../FreeRTOS/Source/tasks.c ****                 break;
 893:../FreeRTOS/Source/tasks.c ****             }
 894:../FreeRTOS/Source/tasks.c ****             else
 895:../FreeRTOS/Source/tasks.c ****             {
 896:../FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
 897:../FreeRTOS/Source/tasks.c ****             }
 898:../FreeRTOS/Source/tasks.c ****         }
 899:../FreeRTOS/Source/tasks.c **** 
 900:../FreeRTOS/Source/tasks.c ****         /* Ensure the name string is terminated in the case that the string length
 901:../FreeRTOS/Source/tasks.c ****          * was greater or equal to configMAX_TASK_NAME_LEN. */
 902:../FreeRTOS/Source/tasks.c ****         pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 903:../FreeRTOS/Source/tasks.c ****     }
 904:../FreeRTOS/Source/tasks.c ****     else
 905:../FreeRTOS/Source/tasks.c ****     {
 906:../FreeRTOS/Source/tasks.c ****         /* The task has not been given a name, so just ensure there is a NULL
 907:../FreeRTOS/Source/tasks.c ****          * terminator when it is read out. */
 908:../FreeRTOS/Source/tasks.c ****         pxNewTCB->pcTaskName[ 0 ] = 0x00;
 909:../FreeRTOS/Source/tasks.c ****     }
 910:../FreeRTOS/Source/tasks.c **** 
 911:../FreeRTOS/Source/tasks.c ****     /* This is used as an array index so must ensure it's not too large.  First
 912:../FreeRTOS/Source/tasks.c ****      * remove the privilege bit if one is present. */
 913:../FreeRTOS/Source/tasks.c ****     if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 914:../FreeRTOS/Source/tasks.c ****     {
 915:../FreeRTOS/Source/tasks.c ****         uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 916:../FreeRTOS/Source/tasks.c ****     }
 917:../FreeRTOS/Source/tasks.c ****     else
 918:../FreeRTOS/Source/tasks.c ****     {
 919:../FreeRTOS/Source/tasks.c ****         mtCOVERAGE_TEST_MARKER();
 920:../FreeRTOS/Source/tasks.c ****     }
 921:../FreeRTOS/Source/tasks.c **** 
 922:../FreeRTOS/Source/tasks.c ****     pxNewTCB->uxPriority = uxPriority;
 923:../FreeRTOS/Source/tasks.c ****     #if ( configUSE_MUTEXES == 1 )
 924:../FreeRTOS/Source/tasks.c ****         {
 925:../FreeRTOS/Source/tasks.c ****             pxNewTCB->uxBasePriority = uxPriority;
 926:../FreeRTOS/Source/tasks.c ****             pxNewTCB->uxMutexesHeld = 0;
 927:../FreeRTOS/Source/tasks.c ****         }
 928:../FreeRTOS/Source/tasks.c ****     #endif /* configUSE_MUTEXES */
 929:../FreeRTOS/Source/tasks.c **** 
 930:../FreeRTOS/Source/tasks.c ****     vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 931:../FreeRTOS/Source/tasks.c ****     vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 932:../FreeRTOS/Source/tasks.c **** 
 933:../FreeRTOS/Source/tasks.c ****     /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
 934:../FreeRTOS/Source/tasks.c ****      * back to  the containing TCB from a generic item in a list. */
 935:../FreeRTOS/Source/tasks.c ****     listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 936:../FreeRTOS/Source/tasks.c **** 
 937:../FreeRTOS/Source/tasks.c ****     /* Event lists are always in priority order. */
 938:../FreeRTOS/Source/tasks.c ****     listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - (
 939:../FreeRTOS/Source/tasks.c ****     listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 940:../FreeRTOS/Source/tasks.c **** 
 941:../FreeRTOS/Source/tasks.c ****     #if ( portCRITICAL_NESTING_IN_TCB == 1 )
 942:../FreeRTOS/Source/tasks.c ****         {
 943:../FreeRTOS/Source/tasks.c ****             pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
 944:../FreeRTOS/Source/tasks.c ****         }
 945:../FreeRTOS/Source/tasks.c ****     #endif /* portCRITICAL_NESTING_IN_TCB */
 946:../FreeRTOS/Source/tasks.c **** 
 947:../FreeRTOS/Source/tasks.c ****     #if ( configUSE_APPLICATION_TASK_TAG == 1 )
 948:../FreeRTOS/Source/tasks.c ****         {
 949:../FreeRTOS/Source/tasks.c ****             pxNewTCB->pxTaskTag = NULL;
 950:../FreeRTOS/Source/tasks.c ****         }
 951:../FreeRTOS/Source/tasks.c ****     #endif /* configUSE_APPLICATION_TASK_TAG */
 952:../FreeRTOS/Source/tasks.c **** 
 953:../FreeRTOS/Source/tasks.c ****     #if ( configGENERATE_RUN_TIME_STATS == 1 )
 954:../FreeRTOS/Source/tasks.c ****         {
 955:../FreeRTOS/Source/tasks.c ****             pxNewTCB->ulRunTimeCounter = 0UL;
 956:../FreeRTOS/Source/tasks.c ****         }
 957:../FreeRTOS/Source/tasks.c ****     #endif /* configGENERATE_RUN_TIME_STATS */
 958:../FreeRTOS/Source/tasks.c **** 
 959:../FreeRTOS/Source/tasks.c ****     #if ( portUSING_MPU_WRAPPERS == 1 )
 960:../FreeRTOS/Source/tasks.c ****         {
 961:../FreeRTOS/Source/tasks.c ****             vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ul
 962:../FreeRTOS/Source/tasks.c ****         }
 963:../FreeRTOS/Source/tasks.c ****     #else
 964:../FreeRTOS/Source/tasks.c ****         {
 965:../FreeRTOS/Source/tasks.c ****             /* Avoid compiler warning about unreferenced parameter. */
 966:../FreeRTOS/Source/tasks.c ****             ( void ) xRegions;
 967:../FreeRTOS/Source/tasks.c ****         }
 968:../FreeRTOS/Source/tasks.c ****     #endif
 969:../FreeRTOS/Source/tasks.c **** 
 970:../FreeRTOS/Source/tasks.c ****     #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
 971:../FreeRTOS/Source/tasks.c ****         {
 972:../FreeRTOS/Source/tasks.c ****             memset( ( void * ) &( pxNewTCB->pvThreadLocalStoragePointers[ 0 ] ), 0x00, sizeof( pxNe
 973:../FreeRTOS/Source/tasks.c ****         }
 974:../FreeRTOS/Source/tasks.c ****     #endif
 975:../FreeRTOS/Source/tasks.c **** 
 976:../FreeRTOS/Source/tasks.c ****     #if ( configUSE_TASK_NOTIFICATIONS == 1 )
 977:../FreeRTOS/Source/tasks.c ****         {
 978:../FreeRTOS/Source/tasks.c ****             memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotif
 979:../FreeRTOS/Source/tasks.c ****             memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyS
 980:../FreeRTOS/Source/tasks.c ****         }
 981:../FreeRTOS/Source/tasks.c ****     #endif
 982:../FreeRTOS/Source/tasks.c **** 
 983:../FreeRTOS/Source/tasks.c ****     #if ( configUSE_NEWLIB_REENTRANT == 1 )
 984:../FreeRTOS/Source/tasks.c ****         {
 985:../FreeRTOS/Source/tasks.c ****             /* Initialise this task's Newlib reent structure.
 986:../FreeRTOS/Source/tasks.c ****              * See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
 987:../FreeRTOS/Source/tasks.c ****              * for additional information. */
 988:../FreeRTOS/Source/tasks.c ****             _REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
 989:../FreeRTOS/Source/tasks.c ****         }
 990:../FreeRTOS/Source/tasks.c ****     #endif
 991:../FreeRTOS/Source/tasks.c **** 
 992:../FreeRTOS/Source/tasks.c ****     #if ( INCLUDE_xTaskAbortDelay == 1 )
 993:../FreeRTOS/Source/tasks.c ****         {
 994:../FreeRTOS/Source/tasks.c ****             pxNewTCB->ucDelayAborted = pdFALSE;
 995:../FreeRTOS/Source/tasks.c ****         }
 996:../FreeRTOS/Source/tasks.c ****     #endif
 997:../FreeRTOS/Source/tasks.c **** 
 998:../FreeRTOS/Source/tasks.c ****     /* Initialize the TCB stack to look as if the task was already running,
 999:../FreeRTOS/Source/tasks.c ****      * but had been interrupted by the scheduler.  The return address is set
1000:../FreeRTOS/Source/tasks.c ****      * to the start of the task function. Once the stack has been initialised
1001:../FreeRTOS/Source/tasks.c ****      * the top of stack variable is updated. */
1002:../FreeRTOS/Source/tasks.c ****     #if ( portUSING_MPU_WRAPPERS == 1 )
1003:../FreeRTOS/Source/tasks.c ****         {
1004:../FreeRTOS/Source/tasks.c ****             /* If the port has capability to detect stack overflow,
1005:../FreeRTOS/Source/tasks.c ****              * pass the stack end address to the stack initialization
1006:../FreeRTOS/Source/tasks.c ****              * function as well. */
1007:../FreeRTOS/Source/tasks.c ****             #if ( portHAS_STACK_OVERFLOW_CHECKING == 1 )
1008:../FreeRTOS/Source/tasks.c ****                 {
1009:../FreeRTOS/Source/tasks.c ****                     #if ( portSTACK_GROWTH < 0 )
1010:../FreeRTOS/Source/tasks.c ****                         {
1011:../FreeRTOS/Source/tasks.c ****                             pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB-
1012:../FreeRTOS/Source/tasks.c ****                         }
1013:../FreeRTOS/Source/tasks.c ****                     #else /* portSTACK_GROWTH */
1014:../FreeRTOS/Source/tasks.c ****                         {
1015:../FreeRTOS/Source/tasks.c ****                             pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB-
1016:../FreeRTOS/Source/tasks.c ****                         }
1017:../FreeRTOS/Source/tasks.c ****                     #endif /* portSTACK_GROWTH */
1018:../FreeRTOS/Source/tasks.c ****                 }
1019:../FreeRTOS/Source/tasks.c ****             #else /* portHAS_STACK_OVERFLOW_CHECKING */
1020:../FreeRTOS/Source/tasks.c ****                 {
1021:../FreeRTOS/Source/tasks.c ****                     pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvPar
1022:../FreeRTOS/Source/tasks.c ****                 }
1023:../FreeRTOS/Source/tasks.c ****             #endif /* portHAS_STACK_OVERFLOW_CHECKING */
1024:../FreeRTOS/Source/tasks.c ****         }
1025:../FreeRTOS/Source/tasks.c ****     #else /* portUSING_MPU_WRAPPERS */
1026:../FreeRTOS/Source/tasks.c ****         {
1027:../FreeRTOS/Source/tasks.c ****             /* If the port has capability to detect stack overflow,
1028:../FreeRTOS/Source/tasks.c ****              * pass the stack end address to the stack initialization
1029:../FreeRTOS/Source/tasks.c ****              * function as well. */
1030:../FreeRTOS/Source/tasks.c ****             #if ( portHAS_STACK_OVERFLOW_CHECKING == 1 )
1031:../FreeRTOS/Source/tasks.c ****                 {
1032:../FreeRTOS/Source/tasks.c ****                     #if ( portSTACK_GROWTH < 0 )
1033:../FreeRTOS/Source/tasks.c ****                         {
1034:../FreeRTOS/Source/tasks.c ****                             pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB-
1035:../FreeRTOS/Source/tasks.c ****                         }
1036:../FreeRTOS/Source/tasks.c ****                     #else /* portSTACK_GROWTH */
1037:../FreeRTOS/Source/tasks.c ****                         {
1038:../FreeRTOS/Source/tasks.c ****                             pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB-
1039:../FreeRTOS/Source/tasks.c ****                         }
1040:../FreeRTOS/Source/tasks.c ****                     #endif /* portSTACK_GROWTH */
1041:../FreeRTOS/Source/tasks.c ****                 }
1042:../FreeRTOS/Source/tasks.c ****             #else /* portHAS_STACK_OVERFLOW_CHECKING */
1043:../FreeRTOS/Source/tasks.c ****                 {
1044:../FreeRTOS/Source/tasks.c ****                     pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvPar
1045:../FreeRTOS/Source/tasks.c ****                 }
1046:../FreeRTOS/Source/tasks.c ****             #endif /* portHAS_STACK_OVERFLOW_CHECKING */
1047:../FreeRTOS/Source/tasks.c ****         }
1048:../FreeRTOS/Source/tasks.c ****     #endif /* portUSING_MPU_WRAPPERS */
1049:../FreeRTOS/Source/tasks.c **** 
1050:../FreeRTOS/Source/tasks.c ****     if( pxCreatedTask != NULL )
1051:../FreeRTOS/Source/tasks.c ****     {
1052:../FreeRTOS/Source/tasks.c ****         /* Pass the handle out in an anonymous way.  The handle can be used to
1053:../FreeRTOS/Source/tasks.c ****          * change the created task's priority, delete the created task, etc.*/
1054:../FreeRTOS/Source/tasks.c ****         *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
1055:../FreeRTOS/Source/tasks.c ****     }
1056:../FreeRTOS/Source/tasks.c ****     else
1057:../FreeRTOS/Source/tasks.c ****     {
1058:../FreeRTOS/Source/tasks.c ****         mtCOVERAGE_TEST_MARKER();
1059:../FreeRTOS/Source/tasks.c ****     }
1060:../FreeRTOS/Source/tasks.c **** }
1061:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1062:../FreeRTOS/Source/tasks.c **** 
1063:../FreeRTOS/Source/tasks.c **** static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
1064:../FreeRTOS/Source/tasks.c **** {
1065:../FreeRTOS/Source/tasks.c ****     /* Ensure interrupts don't access the task lists while the lists are being
1066:../FreeRTOS/Source/tasks.c ****      * updated. */
1067:../FreeRTOS/Source/tasks.c ****     taskENTER_CRITICAL();
1068:../FreeRTOS/Source/tasks.c ****     {
1069:../FreeRTOS/Source/tasks.c ****         uxCurrentNumberOfTasks++;
1070:../FreeRTOS/Source/tasks.c **** 
1071:../FreeRTOS/Source/tasks.c ****         if( pxCurrentTCB == NULL )
1072:../FreeRTOS/Source/tasks.c ****         {
1073:../FreeRTOS/Source/tasks.c ****             /* There are no other tasks, or all the other tasks are in
1074:../FreeRTOS/Source/tasks.c ****              * the suspended state - make this the current task. */
1075:../FreeRTOS/Source/tasks.c ****             pxCurrentTCB = pxNewTCB;
1076:../FreeRTOS/Source/tasks.c **** 
1077:../FreeRTOS/Source/tasks.c ****             if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
1078:../FreeRTOS/Source/tasks.c ****             {
1079:../FreeRTOS/Source/tasks.c ****                 /* This is the first task to be created so do the preliminary
1080:../FreeRTOS/Source/tasks.c ****                  * initialisation required.  We will not recover if this call
1081:../FreeRTOS/Source/tasks.c ****                  * fails, but we will report the failure. */
1082:../FreeRTOS/Source/tasks.c ****                 prvInitialiseTaskLists();
1083:../FreeRTOS/Source/tasks.c ****             }
1084:../FreeRTOS/Source/tasks.c ****             else
1085:../FreeRTOS/Source/tasks.c ****             {
1086:../FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
1087:../FreeRTOS/Source/tasks.c ****             }
1088:../FreeRTOS/Source/tasks.c ****         }
1089:../FreeRTOS/Source/tasks.c ****         else
1090:../FreeRTOS/Source/tasks.c ****         {
1091:../FreeRTOS/Source/tasks.c ****             /* If the scheduler is not already running, make this task the
1092:../FreeRTOS/Source/tasks.c ****              * current task if it is the highest priority task to be created
1093:../FreeRTOS/Source/tasks.c ****              * so far. */
1094:../FreeRTOS/Source/tasks.c ****             if( xSchedulerRunning == pdFALSE )
1095:../FreeRTOS/Source/tasks.c ****             {
1096:../FreeRTOS/Source/tasks.c ****                 if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
1097:../FreeRTOS/Source/tasks.c ****                 {
1098:../FreeRTOS/Source/tasks.c ****                     pxCurrentTCB = pxNewTCB;
1099:../FreeRTOS/Source/tasks.c ****                 }
1100:../FreeRTOS/Source/tasks.c ****                 else
1101:../FreeRTOS/Source/tasks.c ****                 {
1102:../FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
1103:../FreeRTOS/Source/tasks.c ****                 }
1104:../FreeRTOS/Source/tasks.c ****             }
1105:../FreeRTOS/Source/tasks.c ****             else
1106:../FreeRTOS/Source/tasks.c ****             {
1107:../FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
1108:../FreeRTOS/Source/tasks.c ****             }
1109:../FreeRTOS/Source/tasks.c ****         }
1110:../FreeRTOS/Source/tasks.c **** 
1111:../FreeRTOS/Source/tasks.c ****         uxTaskNumber++;
1112:../FreeRTOS/Source/tasks.c **** 
1113:../FreeRTOS/Source/tasks.c ****         #if ( configUSE_TRACE_FACILITY == 1 )
1114:../FreeRTOS/Source/tasks.c ****             {
1115:../FreeRTOS/Source/tasks.c ****                 /* Add a counter into the TCB for tracing only. */
1116:../FreeRTOS/Source/tasks.c ****                 pxNewTCB->uxTCBNumber = uxTaskNumber;
1117:../FreeRTOS/Source/tasks.c ****             }
1118:../FreeRTOS/Source/tasks.c ****         #endif /* configUSE_TRACE_FACILITY */
1119:../FreeRTOS/Source/tasks.c ****         traceTASK_CREATE( pxNewTCB );
1120:../FreeRTOS/Source/tasks.c **** 
1121:../FreeRTOS/Source/tasks.c ****         prvAddTaskToReadyList( pxNewTCB );
1122:../FreeRTOS/Source/tasks.c **** 
1123:../FreeRTOS/Source/tasks.c ****         portSETUP_TCB( pxNewTCB );
1124:../FreeRTOS/Source/tasks.c ****     }
1125:../FreeRTOS/Source/tasks.c ****     taskEXIT_CRITICAL();
1126:../FreeRTOS/Source/tasks.c **** 
1127:../FreeRTOS/Source/tasks.c ****     if( xSchedulerRunning != pdFALSE )
1128:../FreeRTOS/Source/tasks.c ****     {
1129:../FreeRTOS/Source/tasks.c ****         /* If the created task is of a higher priority than the current task
1130:../FreeRTOS/Source/tasks.c ****          * then it should run now. */
1131:../FreeRTOS/Source/tasks.c ****         if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
1132:../FreeRTOS/Source/tasks.c ****         {
1133:../FreeRTOS/Source/tasks.c ****             taskYIELD_IF_USING_PREEMPTION();
1134:../FreeRTOS/Source/tasks.c ****         }
1135:../FreeRTOS/Source/tasks.c ****         else
1136:../FreeRTOS/Source/tasks.c ****         {
1137:../FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
1138:../FreeRTOS/Source/tasks.c ****         }
1139:../FreeRTOS/Source/tasks.c ****     }
1140:../FreeRTOS/Source/tasks.c ****     else
1141:../FreeRTOS/Source/tasks.c ****     {
1142:../FreeRTOS/Source/tasks.c ****         mtCOVERAGE_TEST_MARKER();
1143:../FreeRTOS/Source/tasks.c ****     }
1144:../FreeRTOS/Source/tasks.c **** }
1145:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1146:../FreeRTOS/Source/tasks.c **** 
1147:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
1148:../FreeRTOS/Source/tasks.c **** 
1149:../FreeRTOS/Source/tasks.c ****     void vTaskDelete( TaskHandle_t xTaskToDelete )
1150:../FreeRTOS/Source/tasks.c ****     {
1151:../FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
1152:../FreeRTOS/Source/tasks.c **** 
1153:../FreeRTOS/Source/tasks.c ****         taskENTER_CRITICAL();
1154:../FreeRTOS/Source/tasks.c ****         {
1155:../FreeRTOS/Source/tasks.c ****             /* If null is passed in here then it is the calling task that is
1156:../FreeRTOS/Source/tasks.c ****              * being deleted. */
1157:../FreeRTOS/Source/tasks.c ****             pxTCB = prvGetTCBFromHandle( xTaskToDelete );
1158:../FreeRTOS/Source/tasks.c **** 
1159:../FreeRTOS/Source/tasks.c ****             /* Remove task from the ready/delayed list. */
1160:../FreeRTOS/Source/tasks.c ****             if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1161:../FreeRTOS/Source/tasks.c ****             {
1162:../FreeRTOS/Source/tasks.c ****                 taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1163:../FreeRTOS/Source/tasks.c ****             }
1164:../FreeRTOS/Source/tasks.c ****             else
1165:../FreeRTOS/Source/tasks.c ****             {
1166:../FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
1167:../FreeRTOS/Source/tasks.c ****             }
1168:../FreeRTOS/Source/tasks.c **** 
1169:../FreeRTOS/Source/tasks.c ****             /* Is the task waiting on an event also? */
1170:../FreeRTOS/Source/tasks.c ****             if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
1171:../FreeRTOS/Source/tasks.c ****             {
1172:../FreeRTOS/Source/tasks.c ****                 ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1173:../FreeRTOS/Source/tasks.c ****             }
1174:../FreeRTOS/Source/tasks.c ****             else
1175:../FreeRTOS/Source/tasks.c ****             {
1176:../FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
1177:../FreeRTOS/Source/tasks.c ****             }
1178:../FreeRTOS/Source/tasks.c **** 
1179:../FreeRTOS/Source/tasks.c ****             /* Increment the uxTaskNumber also so kernel aware debuggers can
1180:../FreeRTOS/Source/tasks.c ****              * detect that the task lists need re-generating.  This is done before
1181:../FreeRTOS/Source/tasks.c ****              * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
1182:../FreeRTOS/Source/tasks.c ****              * not return. */
1183:../FreeRTOS/Source/tasks.c ****             uxTaskNumber++;
1184:../FreeRTOS/Source/tasks.c **** 
1185:../FreeRTOS/Source/tasks.c ****             if( pxTCB == pxCurrentTCB )
1186:../FreeRTOS/Source/tasks.c ****             {
1187:../FreeRTOS/Source/tasks.c ****                 /* A task is deleting itself.  This cannot complete within the
1188:../FreeRTOS/Source/tasks.c ****                  * task itself, as a context switch to another task is required.
1189:../FreeRTOS/Source/tasks.c ****                  * Place the task in the termination list.  The idle task will
1190:../FreeRTOS/Source/tasks.c ****                  * check the termination list and free up any memory allocated by
1191:../FreeRTOS/Source/tasks.c ****                  * the scheduler for the TCB and stack of the deleted task. */
1192:../FreeRTOS/Source/tasks.c ****                 vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
1193:../FreeRTOS/Source/tasks.c **** 
1194:../FreeRTOS/Source/tasks.c ****                 /* Increment the ucTasksDeleted variable so the idle task knows
1195:../FreeRTOS/Source/tasks.c ****                  * there is a task that has been deleted and that it should therefore
1196:../FreeRTOS/Source/tasks.c ****                  * check the xTasksWaitingTermination list. */
1197:../FreeRTOS/Source/tasks.c ****                 ++uxDeletedTasksWaitingCleanUp;
1198:../FreeRTOS/Source/tasks.c **** 
1199:../FreeRTOS/Source/tasks.c ****                 /* Call the delete hook before portPRE_TASK_DELETE_HOOK() as
1200:../FreeRTOS/Source/tasks.c ****                  * portPRE_TASK_DELETE_HOOK() does not return in the Win32 port. */
1201:../FreeRTOS/Source/tasks.c ****                 traceTASK_DELETE( pxTCB );
1202:../FreeRTOS/Source/tasks.c **** 
1203:../FreeRTOS/Source/tasks.c ****                 /* The pre-delete hook is primarily for the Windows simulator,
1204:../FreeRTOS/Source/tasks.c ****                  * in which Windows specific clean up operations are performed,
1205:../FreeRTOS/Source/tasks.c ****                  * after which it is not possible to yield away from this task -
1206:../FreeRTOS/Source/tasks.c ****                  * hence xYieldPending is used to latch that a context switch is
1207:../FreeRTOS/Source/tasks.c ****                  * required. */
1208:../FreeRTOS/Source/tasks.c ****                 portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
1209:../FreeRTOS/Source/tasks.c ****             }
1210:../FreeRTOS/Source/tasks.c ****             else
1211:../FreeRTOS/Source/tasks.c ****             {
1212:../FreeRTOS/Source/tasks.c ****                 --uxCurrentNumberOfTasks;
1213:../FreeRTOS/Source/tasks.c ****                 traceTASK_DELETE( pxTCB );
1214:../FreeRTOS/Source/tasks.c ****                 prvDeleteTCB( pxTCB );
1215:../FreeRTOS/Source/tasks.c **** 
1216:../FreeRTOS/Source/tasks.c ****                 /* Reset the next expected unblock time in case it referred to
1217:../FreeRTOS/Source/tasks.c ****                  * the task that has just been deleted. */
1218:../FreeRTOS/Source/tasks.c ****                 prvResetNextTaskUnblockTime();
1219:../FreeRTOS/Source/tasks.c ****             }
1220:../FreeRTOS/Source/tasks.c ****         }
1221:../FreeRTOS/Source/tasks.c ****         taskEXIT_CRITICAL();
1222:../FreeRTOS/Source/tasks.c **** 
1223:../FreeRTOS/Source/tasks.c ****         /* Force a reschedule if it is the currently running task that has just
1224:../FreeRTOS/Source/tasks.c ****          * been deleted. */
1225:../FreeRTOS/Source/tasks.c ****         if( xSchedulerRunning != pdFALSE )
1226:../FreeRTOS/Source/tasks.c ****         {
1227:../FreeRTOS/Source/tasks.c ****             if( pxTCB == pxCurrentTCB )
1228:../FreeRTOS/Source/tasks.c ****             {
1229:../FreeRTOS/Source/tasks.c ****                 configASSERT( uxSchedulerSuspended == 0 );
1230:../FreeRTOS/Source/tasks.c ****                 portYIELD_WITHIN_API();
1231:../FreeRTOS/Source/tasks.c ****             }
1232:../FreeRTOS/Source/tasks.c ****             else
1233:../FreeRTOS/Source/tasks.c ****             {
1234:../FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
1235:../FreeRTOS/Source/tasks.c ****             }
1236:../FreeRTOS/Source/tasks.c ****         }
1237:../FreeRTOS/Source/tasks.c ****     }
1238:../FreeRTOS/Source/tasks.c **** 
1239:../FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelete */
1240:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1241:../FreeRTOS/Source/tasks.c **** 
1242:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
1243:../FreeRTOS/Source/tasks.c **** 
1244:../FreeRTOS/Source/tasks.c ****     void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
1245:../FreeRTOS/Source/tasks.c ****                           const TickType_t xTimeIncrement )
1246:../FreeRTOS/Source/tasks.c ****     {
1247:../FreeRTOS/Source/tasks.c ****         TickType_t xTimeToWake;
1248:../FreeRTOS/Source/tasks.c ****         BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
1249:../FreeRTOS/Source/tasks.c **** 
1250:../FreeRTOS/Source/tasks.c ****         configASSERT( pxPreviousWakeTime );
1251:../FreeRTOS/Source/tasks.c ****         configASSERT( ( xTimeIncrement > 0U ) );
1252:../FreeRTOS/Source/tasks.c ****         configASSERT( uxSchedulerSuspended == 0 );
1253:../FreeRTOS/Source/tasks.c **** 
1254:../FreeRTOS/Source/tasks.c ****         vTaskSuspendAll();
1255:../FreeRTOS/Source/tasks.c ****         {
1256:../FreeRTOS/Source/tasks.c ****             /* Minor optimisation.  The tick count cannot change in this
1257:../FreeRTOS/Source/tasks.c ****              * block. */
1258:../FreeRTOS/Source/tasks.c ****             const TickType_t xConstTickCount = xTickCount;
1259:../FreeRTOS/Source/tasks.c **** 
1260:../FreeRTOS/Source/tasks.c ****             /* Generate the tick time at which the task wants to wake. */
1261:../FreeRTOS/Source/tasks.c ****             xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
1262:../FreeRTOS/Source/tasks.c **** 
1263:../FreeRTOS/Source/tasks.c ****             if( xConstTickCount < *pxPreviousWakeTime )
1264:../FreeRTOS/Source/tasks.c ****             {
1265:../FreeRTOS/Source/tasks.c ****                 /* The tick count has overflowed since this function was
1266:../FreeRTOS/Source/tasks.c ****                  * lasted called.  In this case the only time we should ever
1267:../FreeRTOS/Source/tasks.c ****                  * actually delay is if the wake time has also  overflowed,
1268:../FreeRTOS/Source/tasks.c ****                  * and the wake time is greater than the tick time.  When this
1269:../FreeRTOS/Source/tasks.c ****                  * is the case it is as if neither time had overflowed. */
1270:../FreeRTOS/Source/tasks.c ****                 if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
1271:../FreeRTOS/Source/tasks.c ****                 {
1272:../FreeRTOS/Source/tasks.c ****                     xShouldDelay = pdTRUE;
1273:../FreeRTOS/Source/tasks.c ****                 }
1274:../FreeRTOS/Source/tasks.c ****                 else
1275:../FreeRTOS/Source/tasks.c ****                 {
1276:../FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
1277:../FreeRTOS/Source/tasks.c ****                 }
1278:../FreeRTOS/Source/tasks.c ****             }
1279:../FreeRTOS/Source/tasks.c ****             else
1280:../FreeRTOS/Source/tasks.c ****             {
1281:../FreeRTOS/Source/tasks.c ****                 /* The tick time has not overflowed.  In this case we will
1282:../FreeRTOS/Source/tasks.c ****                  * delay if either the wake time has overflowed, and/or the
1283:../FreeRTOS/Source/tasks.c ****                  * tick time is less than the wake time. */
1284:../FreeRTOS/Source/tasks.c ****                 if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
1285:../FreeRTOS/Source/tasks.c ****                 {
1286:../FreeRTOS/Source/tasks.c ****                     xShouldDelay = pdTRUE;
1287:../FreeRTOS/Source/tasks.c ****                 }
1288:../FreeRTOS/Source/tasks.c ****                 else
1289:../FreeRTOS/Source/tasks.c ****                 {
1290:../FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
1291:../FreeRTOS/Source/tasks.c ****                 }
1292:../FreeRTOS/Source/tasks.c ****             }
1293:../FreeRTOS/Source/tasks.c **** 
1294:../FreeRTOS/Source/tasks.c ****             /* Update the wake time ready for the next call. */
1295:../FreeRTOS/Source/tasks.c ****             *pxPreviousWakeTime = xTimeToWake;
1296:../FreeRTOS/Source/tasks.c **** 
1297:../FreeRTOS/Source/tasks.c ****             if( xShouldDelay != pdFALSE )
1298:../FreeRTOS/Source/tasks.c ****             {
1299:../FreeRTOS/Source/tasks.c ****                 traceTASK_DELAY_UNTIL( xTimeToWake );
1300:../FreeRTOS/Source/tasks.c **** 
1301:../FreeRTOS/Source/tasks.c ****                 /* prvAddCurrentTaskToDelayedList() needs the block time, not
1302:../FreeRTOS/Source/tasks.c ****                  * the time to wake, so subtract the current tick count. */
1303:../FreeRTOS/Source/tasks.c ****                 prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
1304:../FreeRTOS/Source/tasks.c ****             }
1305:../FreeRTOS/Source/tasks.c ****             else
1306:../FreeRTOS/Source/tasks.c ****             {
1307:../FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
1308:../FreeRTOS/Source/tasks.c ****             }
1309:../FreeRTOS/Source/tasks.c ****         }
1310:../FreeRTOS/Source/tasks.c ****         xAlreadyYielded = xTaskResumeAll();
1311:../FreeRTOS/Source/tasks.c **** 
1312:../FreeRTOS/Source/tasks.c ****         /* Force a reschedule if xTaskResumeAll has not already done so, we may
1313:../FreeRTOS/Source/tasks.c ****          * have put ourselves to sleep. */
1314:../FreeRTOS/Source/tasks.c ****         if( xAlreadyYielded == pdFALSE )
1315:../FreeRTOS/Source/tasks.c ****         {
1316:../FreeRTOS/Source/tasks.c ****             portYIELD_WITHIN_API();
1317:../FreeRTOS/Source/tasks.c ****         }
1318:../FreeRTOS/Source/tasks.c ****         else
1319:../FreeRTOS/Source/tasks.c ****         {
1320:../FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
1321:../FreeRTOS/Source/tasks.c ****         }
1322:../FreeRTOS/Source/tasks.c ****     }
1323:../FreeRTOS/Source/tasks.c **** 
1324:../FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelayUntil */
1325:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1326:../FreeRTOS/Source/tasks.c **** 
1327:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
1328:../FreeRTOS/Source/tasks.c **** 
1329:../FreeRTOS/Source/tasks.c ****     void vTaskDelay( const TickType_t xTicksToDelay )
1330:../FreeRTOS/Source/tasks.c ****     {
1331:../FreeRTOS/Source/tasks.c ****         BaseType_t xAlreadyYielded = pdFALSE;
1332:../FreeRTOS/Source/tasks.c **** 
1333:../FreeRTOS/Source/tasks.c ****         /* A delay time of zero just forces a reschedule. */
1334:../FreeRTOS/Source/tasks.c ****         if( xTicksToDelay > ( TickType_t ) 0U )
1335:../FreeRTOS/Source/tasks.c ****         {
1336:../FreeRTOS/Source/tasks.c ****             configASSERT( uxSchedulerSuspended == 0 );
1337:../FreeRTOS/Source/tasks.c ****             vTaskSuspendAll();
1338:../FreeRTOS/Source/tasks.c ****             {
1339:../FreeRTOS/Source/tasks.c ****                 traceTASK_DELAY();
1340:../FreeRTOS/Source/tasks.c **** 
1341:../FreeRTOS/Source/tasks.c ****                 /* A task that is removed from the event list while the
1342:../FreeRTOS/Source/tasks.c ****                  * scheduler is suspended will not get placed in the ready
1343:../FreeRTOS/Source/tasks.c ****                  * list or removed from the blocked list until the scheduler
1344:../FreeRTOS/Source/tasks.c ****                  * is resumed.
1345:../FreeRTOS/Source/tasks.c ****                  *
1346:../FreeRTOS/Source/tasks.c ****                  * This task cannot be in an event list as it is the currently
1347:../FreeRTOS/Source/tasks.c ****                  * executing task. */
1348:../FreeRTOS/Source/tasks.c ****                 prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
1349:../FreeRTOS/Source/tasks.c ****             }
1350:../FreeRTOS/Source/tasks.c ****             xAlreadyYielded = xTaskResumeAll();
1351:../FreeRTOS/Source/tasks.c ****         }
1352:../FreeRTOS/Source/tasks.c ****         else
1353:../FreeRTOS/Source/tasks.c ****         {
1354:../FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
1355:../FreeRTOS/Source/tasks.c ****         }
1356:../FreeRTOS/Source/tasks.c **** 
1357:../FreeRTOS/Source/tasks.c ****         /* Force a reschedule if xTaskResumeAll has not already done so, we may
1358:../FreeRTOS/Source/tasks.c ****          * have put ourselves to sleep. */
1359:../FreeRTOS/Source/tasks.c ****         if( xAlreadyYielded == pdFALSE )
1360:../FreeRTOS/Source/tasks.c ****         {
1361:../FreeRTOS/Source/tasks.c ****             portYIELD_WITHIN_API();
1362:../FreeRTOS/Source/tasks.c ****         }
1363:../FreeRTOS/Source/tasks.c ****         else
1364:../FreeRTOS/Source/tasks.c ****         {
1365:../FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
1366:../FreeRTOS/Source/tasks.c ****         }
1367:../FreeRTOS/Source/tasks.c ****     }
1368:../FreeRTOS/Source/tasks.c **** 
1369:../FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelay */
1370:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1371:../FreeRTOS/Source/tasks.c **** 
1372:../FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_xTaskAbortDe
1373:../FreeRTOS/Source/tasks.c **** 
1374:../FreeRTOS/Source/tasks.c ****     eTaskState eTaskGetState( TaskHandle_t xTask )
1375:../FreeRTOS/Source/tasks.c ****     {
1376:../FreeRTOS/Source/tasks.c ****         eTaskState eReturn;
1377:../FreeRTOS/Source/tasks.c ****         List_t const * pxStateList, * pxDelayedList, * pxOverflowedDelayedList;
1378:../FreeRTOS/Source/tasks.c ****         const TCB_t * const pxTCB = xTask;
1379:../FreeRTOS/Source/tasks.c **** 
1380:../FreeRTOS/Source/tasks.c ****         configASSERT( pxTCB );
1381:../FreeRTOS/Source/tasks.c **** 
1382:../FreeRTOS/Source/tasks.c ****         if( pxTCB == pxCurrentTCB )
1383:../FreeRTOS/Source/tasks.c ****         {
1384:../FreeRTOS/Source/tasks.c ****             /* The task calling this function is querying its own state. */
1385:../FreeRTOS/Source/tasks.c ****             eReturn = eRunning;
1386:../FreeRTOS/Source/tasks.c ****         }
1387:../FreeRTOS/Source/tasks.c ****         else
1388:../FreeRTOS/Source/tasks.c ****         {
1389:../FreeRTOS/Source/tasks.c ****             taskENTER_CRITICAL();
1390:../FreeRTOS/Source/tasks.c ****             {
1391:../FreeRTOS/Source/tasks.c ****                 pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
1392:../FreeRTOS/Source/tasks.c ****                 pxDelayedList = pxDelayedTaskList;
1393:../FreeRTOS/Source/tasks.c ****                 pxOverflowedDelayedList = pxOverflowDelayedTaskList;
1394:../FreeRTOS/Source/tasks.c ****             }
1395:../FreeRTOS/Source/tasks.c ****             taskEXIT_CRITICAL();
1396:../FreeRTOS/Source/tasks.c **** 
1397:../FreeRTOS/Source/tasks.c ****             if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
1398:../FreeRTOS/Source/tasks.c ****             {
1399:../FreeRTOS/Source/tasks.c ****                 /* The task being queried is referenced from one of the Blocked
1400:../FreeRTOS/Source/tasks.c ****                  * lists. */
1401:../FreeRTOS/Source/tasks.c ****                 eReturn = eBlocked;
1402:../FreeRTOS/Source/tasks.c ****             }
1403:../FreeRTOS/Source/tasks.c **** 
1404:../FreeRTOS/Source/tasks.c ****             #if ( INCLUDE_vTaskSuspend == 1 )
1405:../FreeRTOS/Source/tasks.c ****                 else if( pxStateList == &xSuspendedTaskList )
1406:../FreeRTOS/Source/tasks.c ****                 {
1407:../FreeRTOS/Source/tasks.c ****                     /* The task being queried is referenced from the suspended
1408:../FreeRTOS/Source/tasks.c ****                      * list.  Is it genuinely suspended or is it blocked
1409:../FreeRTOS/Source/tasks.c ****                      * indefinitely? */
1410:../FreeRTOS/Source/tasks.c ****                     if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
1411:../FreeRTOS/Source/tasks.c ****                     {
1412:../FreeRTOS/Source/tasks.c ****                         #if ( configUSE_TASK_NOTIFICATIONS == 1 )
1413:../FreeRTOS/Source/tasks.c ****                             {
1414:../FreeRTOS/Source/tasks.c ****                                 BaseType_t x;
1415:../FreeRTOS/Source/tasks.c **** 
1416:../FreeRTOS/Source/tasks.c ****                                 /* The task does not appear on the event list item of
1417:../FreeRTOS/Source/tasks.c ****                                  * and of the RTOS objects, but could still be in the
1418:../FreeRTOS/Source/tasks.c ****                                  * blocked state if it is waiting on its notification
1419:../FreeRTOS/Source/tasks.c ****                                  * rather than waiting on an object.  If not, is
1420:../FreeRTOS/Source/tasks.c ****                                  * suspended. */
1421:../FreeRTOS/Source/tasks.c ****                                 eReturn = eSuspended;
1422:../FreeRTOS/Source/tasks.c **** 
1423:../FreeRTOS/Source/tasks.c ****                                 for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
1424:../FreeRTOS/Source/tasks.c ****                                 {
1425:../FreeRTOS/Source/tasks.c ****                                     if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
1426:../FreeRTOS/Source/tasks.c ****                                     {
1427:../FreeRTOS/Source/tasks.c ****                                         eReturn = eBlocked;
1428:../FreeRTOS/Source/tasks.c ****                                         break;
1429:../FreeRTOS/Source/tasks.c ****                                     }
1430:../FreeRTOS/Source/tasks.c ****                                 }
1431:../FreeRTOS/Source/tasks.c ****                             }
1432:../FreeRTOS/Source/tasks.c ****                         #else /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
1433:../FreeRTOS/Source/tasks.c ****                             {
1434:../FreeRTOS/Source/tasks.c ****                                 eReturn = eSuspended;
1435:../FreeRTOS/Source/tasks.c ****                             }
1436:../FreeRTOS/Source/tasks.c ****                         #endif /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
1437:../FreeRTOS/Source/tasks.c ****                     }
1438:../FreeRTOS/Source/tasks.c ****                     else
1439:../FreeRTOS/Source/tasks.c ****                     {
1440:../FreeRTOS/Source/tasks.c ****                         eReturn = eBlocked;
1441:../FreeRTOS/Source/tasks.c ****                     }
1442:../FreeRTOS/Source/tasks.c ****                 }
1443:../FreeRTOS/Source/tasks.c ****             #endif /* if ( INCLUDE_vTaskSuspend == 1 ) */
1444:../FreeRTOS/Source/tasks.c **** 
1445:../FreeRTOS/Source/tasks.c ****             #if ( INCLUDE_vTaskDelete == 1 )
1446:../FreeRTOS/Source/tasks.c ****                 else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
1447:../FreeRTOS/Source/tasks.c ****                 {
1448:../FreeRTOS/Source/tasks.c ****                     /* The task being queried is referenced from the deleted
1449:../FreeRTOS/Source/tasks.c ****                      * tasks list, or it is not referenced from any lists at
1450:../FreeRTOS/Source/tasks.c ****                      * all. */
1451:../FreeRTOS/Source/tasks.c ****                     eReturn = eDeleted;
1452:../FreeRTOS/Source/tasks.c ****                 }
1453:../FreeRTOS/Source/tasks.c ****             #endif
1454:../FreeRTOS/Source/tasks.c **** 
1455:../FreeRTOS/Source/tasks.c ****             else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer
1456:../FreeRTOS/Source/tasks.c ****             {
1457:../FreeRTOS/Source/tasks.c ****                 /* If the task is not in any other state, it must be in the
1458:../FreeRTOS/Source/tasks.c ****                  * Ready (including pending ready) state. */
1459:../FreeRTOS/Source/tasks.c ****                 eReturn = eReady;
1460:../FreeRTOS/Source/tasks.c ****             }
1461:../FreeRTOS/Source/tasks.c ****         }
1462:../FreeRTOS/Source/tasks.c **** 
1463:../FreeRTOS/Source/tasks.c ****         return eReturn;
1464:../FreeRTOS/Source/tasks.c ****     } /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
1465:../FreeRTOS/Source/tasks.c **** 
1466:../FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_eTaskGetState */
1467:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1468:../FreeRTOS/Source/tasks.c **** 
1469:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1470:../FreeRTOS/Source/tasks.c **** 
1471:../FreeRTOS/Source/tasks.c ****     UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
1472:../FreeRTOS/Source/tasks.c ****     {
1473:../FreeRTOS/Source/tasks.c ****         TCB_t const * pxTCB;
1474:../FreeRTOS/Source/tasks.c ****         UBaseType_t uxReturn;
1475:../FreeRTOS/Source/tasks.c **** 
1476:../FreeRTOS/Source/tasks.c ****         taskENTER_CRITICAL();
1477:../FreeRTOS/Source/tasks.c ****         {
1478:../FreeRTOS/Source/tasks.c ****             /* If null is passed in here then it is the priority of the task
1479:../FreeRTOS/Source/tasks.c ****              * that called uxTaskPriorityGet() that is being queried. */
1480:../FreeRTOS/Source/tasks.c ****             pxTCB = prvGetTCBFromHandle( xTask );
1481:../FreeRTOS/Source/tasks.c ****             uxReturn = pxTCB->uxPriority;
1482:../FreeRTOS/Source/tasks.c ****         }
1483:../FreeRTOS/Source/tasks.c ****         taskEXIT_CRITICAL();
1484:../FreeRTOS/Source/tasks.c **** 
1485:../FreeRTOS/Source/tasks.c ****         return uxReturn;
1486:../FreeRTOS/Source/tasks.c ****     }
1487:../FreeRTOS/Source/tasks.c **** 
1488:../FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1489:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1490:../FreeRTOS/Source/tasks.c **** 
1491:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1492:../FreeRTOS/Source/tasks.c **** 
1493:../FreeRTOS/Source/tasks.c ****     UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
1494:../FreeRTOS/Source/tasks.c ****     {
1495:../FreeRTOS/Source/tasks.c ****         TCB_t const * pxTCB;
1496:../FreeRTOS/Source/tasks.c ****         UBaseType_t uxReturn, uxSavedInterruptState;
1497:../FreeRTOS/Source/tasks.c **** 
1498:../FreeRTOS/Source/tasks.c ****         /* RTOS ports that support interrupt nesting have the concept of a
1499:../FreeRTOS/Source/tasks.c ****          * maximum  system call (or maximum API call) interrupt priority.
1500:../FreeRTOS/Source/tasks.c ****          * Interrupts that are  above the maximum system call priority are keep
1501:../FreeRTOS/Source/tasks.c ****          * permanently enabled, even when the RTOS kernel is in a critical section,
1502:../FreeRTOS/Source/tasks.c ****          * but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1503:../FreeRTOS/Source/tasks.c ****          * is defined in FreeRTOSConfig.h then
1504:../FreeRTOS/Source/tasks.c ****          * portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1505:../FreeRTOS/Source/tasks.c ****          * failure if a FreeRTOS API function is called from an interrupt that has
1506:../FreeRTOS/Source/tasks.c ****          * been assigned a priority above the configured maximum system call
1507:../FreeRTOS/Source/tasks.c ****          * priority.  Only FreeRTOS functions that end in FromISR can be called
1508:../FreeRTOS/Source/tasks.c ****          * from interrupts  that have been assigned a priority at or (logically)
1509:../FreeRTOS/Source/tasks.c ****          * below the maximum system call interrupt priority.  FreeRTOS maintains a
1510:../FreeRTOS/Source/tasks.c ****          * separate interrupt safe API to ensure interrupt entry is as fast and as
1511:../FreeRTOS/Source/tasks.c ****          * simple as possible.  More information (albeit Cortex-M specific) is
1512:../FreeRTOS/Source/tasks.c ****          * provided on the following link:
1513:../FreeRTOS/Source/tasks.c ****          * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
1514:../FreeRTOS/Source/tasks.c ****         portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1515:../FreeRTOS/Source/tasks.c **** 
1516:../FreeRTOS/Source/tasks.c ****         uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
1517:../FreeRTOS/Source/tasks.c ****         {
1518:../FreeRTOS/Source/tasks.c ****             /* If null is passed in here then it is the priority of the calling
1519:../FreeRTOS/Source/tasks.c ****              * task that is being queried. */
1520:../FreeRTOS/Source/tasks.c ****             pxTCB = prvGetTCBFromHandle( xTask );
1521:../FreeRTOS/Source/tasks.c ****             uxReturn = pxTCB->uxPriority;
1522:../FreeRTOS/Source/tasks.c ****         }
1523:../FreeRTOS/Source/tasks.c ****         portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
1524:../FreeRTOS/Source/tasks.c **** 
1525:../FreeRTOS/Source/tasks.c ****         return uxReturn;
1526:../FreeRTOS/Source/tasks.c ****     }
1527:../FreeRTOS/Source/tasks.c **** 
1528:../FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1529:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1530:../FreeRTOS/Source/tasks.c **** 
1531:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
1532:../FreeRTOS/Source/tasks.c **** 
1533:../FreeRTOS/Source/tasks.c ****     void vTaskPrioritySet( TaskHandle_t xTask,
1534:../FreeRTOS/Source/tasks.c ****                            UBaseType_t uxNewPriority )
1535:../FreeRTOS/Source/tasks.c ****     {
1536:../FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
1537:../FreeRTOS/Source/tasks.c ****         UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
1538:../FreeRTOS/Source/tasks.c ****         BaseType_t xYieldRequired = pdFALSE;
1539:../FreeRTOS/Source/tasks.c **** 
1540:../FreeRTOS/Source/tasks.c ****         configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
1541:../FreeRTOS/Source/tasks.c **** 
1542:../FreeRTOS/Source/tasks.c ****         /* Ensure the new priority is valid. */
1543:../FreeRTOS/Source/tasks.c ****         if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
1544:../FreeRTOS/Source/tasks.c ****         {
1545:../FreeRTOS/Source/tasks.c ****             uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
1546:../FreeRTOS/Source/tasks.c ****         }
1547:../FreeRTOS/Source/tasks.c ****         else
1548:../FreeRTOS/Source/tasks.c ****         {
1549:../FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
1550:../FreeRTOS/Source/tasks.c ****         }
1551:../FreeRTOS/Source/tasks.c **** 
1552:../FreeRTOS/Source/tasks.c ****         taskENTER_CRITICAL();
1553:../FreeRTOS/Source/tasks.c ****         {
1554:../FreeRTOS/Source/tasks.c ****             /* If null is passed in here then it is the priority of the calling
1555:../FreeRTOS/Source/tasks.c ****              * task that is being changed. */
1556:../FreeRTOS/Source/tasks.c ****             pxTCB = prvGetTCBFromHandle( xTask );
1557:../FreeRTOS/Source/tasks.c **** 
1558:../FreeRTOS/Source/tasks.c ****             traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
1559:../FreeRTOS/Source/tasks.c **** 
1560:../FreeRTOS/Source/tasks.c ****             #if ( configUSE_MUTEXES == 1 )
1561:../FreeRTOS/Source/tasks.c ****                 {
1562:../FreeRTOS/Source/tasks.c ****                     uxCurrentBasePriority = pxTCB->uxBasePriority;
1563:../FreeRTOS/Source/tasks.c ****                 }
1564:../FreeRTOS/Source/tasks.c ****             #else
1565:../FreeRTOS/Source/tasks.c ****                 {
1566:../FreeRTOS/Source/tasks.c ****                     uxCurrentBasePriority = pxTCB->uxPriority;
1567:../FreeRTOS/Source/tasks.c ****                 }
1568:../FreeRTOS/Source/tasks.c ****             #endif
1569:../FreeRTOS/Source/tasks.c **** 
1570:../FreeRTOS/Source/tasks.c ****             if( uxCurrentBasePriority != uxNewPriority )
1571:../FreeRTOS/Source/tasks.c ****             {
1572:../FreeRTOS/Source/tasks.c ****                 /* The priority change may have readied a task of higher
1573:../FreeRTOS/Source/tasks.c ****                  * priority than the calling task. */
1574:../FreeRTOS/Source/tasks.c ****                 if( uxNewPriority > uxCurrentBasePriority )
1575:../FreeRTOS/Source/tasks.c ****                 {
1576:../FreeRTOS/Source/tasks.c ****                     if( pxTCB != pxCurrentTCB )
1577:../FreeRTOS/Source/tasks.c ****                     {
1578:../FreeRTOS/Source/tasks.c ****                         /* The priority of a task other than the currently
1579:../FreeRTOS/Source/tasks.c ****                          * running task is being raised.  Is the priority being
1580:../FreeRTOS/Source/tasks.c ****                          * raised above that of the running task? */
1581:../FreeRTOS/Source/tasks.c ****                         if( uxNewPriority >= pxCurrentTCB->uxPriority )
1582:../FreeRTOS/Source/tasks.c ****                         {
1583:../FreeRTOS/Source/tasks.c ****                             xYieldRequired = pdTRUE;
1584:../FreeRTOS/Source/tasks.c ****                         }
1585:../FreeRTOS/Source/tasks.c ****                         else
1586:../FreeRTOS/Source/tasks.c ****                         {
1587:../FreeRTOS/Source/tasks.c ****                             mtCOVERAGE_TEST_MARKER();
1588:../FreeRTOS/Source/tasks.c ****                         }
1589:../FreeRTOS/Source/tasks.c ****                     }
1590:../FreeRTOS/Source/tasks.c ****                     else
1591:../FreeRTOS/Source/tasks.c ****                     {
1592:../FreeRTOS/Source/tasks.c ****                         /* The priority of the running task is being raised,
1593:../FreeRTOS/Source/tasks.c ****                          * but the running task must already be the highest
1594:../FreeRTOS/Source/tasks.c ****                          * priority task able to run so no yield is required. */
1595:../FreeRTOS/Source/tasks.c ****                     }
1596:../FreeRTOS/Source/tasks.c ****                 }
1597:../FreeRTOS/Source/tasks.c ****                 else if( pxTCB == pxCurrentTCB )
1598:../FreeRTOS/Source/tasks.c ****                 {
1599:../FreeRTOS/Source/tasks.c ****                     /* Setting the priority of the running task down means
1600:../FreeRTOS/Source/tasks.c ****                      * there may now be another task of higher priority that
1601:../FreeRTOS/Source/tasks.c ****                      * is ready to execute. */
1602:../FreeRTOS/Source/tasks.c ****                     xYieldRequired = pdTRUE;
1603:../FreeRTOS/Source/tasks.c ****                 }
1604:../FreeRTOS/Source/tasks.c ****                 else
1605:../FreeRTOS/Source/tasks.c ****                 {
1606:../FreeRTOS/Source/tasks.c ****                     /* Setting the priority of any other task down does not
1607:../FreeRTOS/Source/tasks.c ****                      * require a yield as the running task must be above the
1608:../FreeRTOS/Source/tasks.c ****                      * new priority of the task being modified. */
1609:../FreeRTOS/Source/tasks.c ****                 }
1610:../FreeRTOS/Source/tasks.c **** 
1611:../FreeRTOS/Source/tasks.c ****                 /* Remember the ready list the task might be referenced from
1612:../FreeRTOS/Source/tasks.c ****                  * before its uxPriority member is changed so the
1613:../FreeRTOS/Source/tasks.c ****                  * taskRESET_READY_PRIORITY() macro can function correctly. */
1614:../FreeRTOS/Source/tasks.c ****                 uxPriorityUsedOnEntry = pxTCB->uxPriority;
1615:../FreeRTOS/Source/tasks.c **** 
1616:../FreeRTOS/Source/tasks.c ****                 #if ( configUSE_MUTEXES == 1 )
1617:../FreeRTOS/Source/tasks.c ****                     {
1618:../FreeRTOS/Source/tasks.c ****                         /* Only change the priority being used if the task is not
1619:../FreeRTOS/Source/tasks.c ****                          * currently using an inherited priority. */
1620:../FreeRTOS/Source/tasks.c ****                         if( pxTCB->uxBasePriority == pxTCB->uxPriority )
1621:../FreeRTOS/Source/tasks.c ****                         {
1622:../FreeRTOS/Source/tasks.c ****                             pxTCB->uxPriority = uxNewPriority;
1623:../FreeRTOS/Source/tasks.c ****                         }
1624:../FreeRTOS/Source/tasks.c ****                         else
1625:../FreeRTOS/Source/tasks.c ****                         {
1626:../FreeRTOS/Source/tasks.c ****                             mtCOVERAGE_TEST_MARKER();
1627:../FreeRTOS/Source/tasks.c ****                         }
1628:../FreeRTOS/Source/tasks.c **** 
1629:../FreeRTOS/Source/tasks.c ****                         /* The base priority gets set whatever. */
1630:../FreeRTOS/Source/tasks.c ****                         pxTCB->uxBasePriority = uxNewPriority;
1631:../FreeRTOS/Source/tasks.c ****                     }
1632:../FreeRTOS/Source/tasks.c ****                 #else /* if ( configUSE_MUTEXES == 1 ) */
1633:../FreeRTOS/Source/tasks.c ****                     {
1634:../FreeRTOS/Source/tasks.c ****                         pxTCB->uxPriority = uxNewPriority;
1635:../FreeRTOS/Source/tasks.c ****                     }
1636:../FreeRTOS/Source/tasks.c ****                 #endif /* if ( configUSE_MUTEXES == 1 ) */
1637:../FreeRTOS/Source/tasks.c **** 
1638:../FreeRTOS/Source/tasks.c ****                 /* Only reset the event list item value if the value is not
1639:../FreeRTOS/Source/tasks.c ****                  * being used for anything else. */
1640:../FreeRTOS/Source/tasks.c ****                 if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_V
1641:../FreeRTOS/Source/tasks.c ****                 {
1642:../FreeRTOS/Source/tasks.c ****                     listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX
1643:../FreeRTOS/Source/tasks.c ****                 }
1644:../FreeRTOS/Source/tasks.c ****                 else
1645:../FreeRTOS/Source/tasks.c ****                 {
1646:../FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
1647:../FreeRTOS/Source/tasks.c ****                 }
1648:../FreeRTOS/Source/tasks.c **** 
1649:../FreeRTOS/Source/tasks.c ****                 /* If the task is in the blocked or suspended list we need do
1650:../FreeRTOS/Source/tasks.c ****                  * nothing more than change its priority variable. However, if
1651:../FreeRTOS/Source/tasks.c ****                  * the task is in a ready list it needs to be removed and placed
1652:../FreeRTOS/Source/tasks.c ****                  * in the list appropriate to its new priority. */
1653:../FreeRTOS/Source/tasks.c ****                 if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( px
1654:../FreeRTOS/Source/tasks.c ****                 {
1655:../FreeRTOS/Source/tasks.c ****                     /* The task is currently in its ready list - remove before
1656:../FreeRTOS/Source/tasks.c ****                      * adding it to it's new ready list.  As we are in a critical
1657:../FreeRTOS/Source/tasks.c ****                      * section we can do this even if the scheduler is suspended. */
1658:../FreeRTOS/Source/tasks.c ****                     if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1659:../FreeRTOS/Source/tasks.c ****                     {
1660:../FreeRTOS/Source/tasks.c ****                         /* It is known that the task is in its ready list so
1661:../FreeRTOS/Source/tasks.c ****                          * there is no need to check again and the port level
1662:../FreeRTOS/Source/tasks.c ****                          * reset macro can be called directly. */
1663:../FreeRTOS/Source/tasks.c ****                         portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
1664:../FreeRTOS/Source/tasks.c ****                     }
1665:../FreeRTOS/Source/tasks.c ****                     else
1666:../FreeRTOS/Source/tasks.c ****                     {
1667:../FreeRTOS/Source/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
1668:../FreeRTOS/Source/tasks.c ****                     }
1669:../FreeRTOS/Source/tasks.c **** 
1670:../FreeRTOS/Source/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
1671:../FreeRTOS/Source/tasks.c ****                 }
1672:../FreeRTOS/Source/tasks.c ****                 else
1673:../FreeRTOS/Source/tasks.c ****                 {
1674:../FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
1675:../FreeRTOS/Source/tasks.c ****                 }
1676:../FreeRTOS/Source/tasks.c **** 
1677:../FreeRTOS/Source/tasks.c ****                 if( xYieldRequired != pdFALSE )
1678:../FreeRTOS/Source/tasks.c ****                 {
1679:../FreeRTOS/Source/tasks.c ****                     taskYIELD_IF_USING_PREEMPTION();
1680:../FreeRTOS/Source/tasks.c ****                 }
1681:../FreeRTOS/Source/tasks.c ****                 else
1682:../FreeRTOS/Source/tasks.c ****                 {
1683:../FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
1684:../FreeRTOS/Source/tasks.c ****                 }
1685:../FreeRTOS/Source/tasks.c **** 
1686:../FreeRTOS/Source/tasks.c ****                 /* Remove compiler warning about unused variables when the port
1687:../FreeRTOS/Source/tasks.c ****                  * optimised task selection is not being used. */
1688:../FreeRTOS/Source/tasks.c ****                 ( void ) uxPriorityUsedOnEntry;
1689:../FreeRTOS/Source/tasks.c ****             }
1690:../FreeRTOS/Source/tasks.c ****         }
1691:../FreeRTOS/Source/tasks.c ****         taskEXIT_CRITICAL();
1692:../FreeRTOS/Source/tasks.c ****     }
1693:../FreeRTOS/Source/tasks.c **** 
1694:../FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskPrioritySet */
1695:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1696:../FreeRTOS/Source/tasks.c **** 
1697:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1698:../FreeRTOS/Source/tasks.c **** 
1699:../FreeRTOS/Source/tasks.c ****     void vTaskSuspend( TaskHandle_t xTaskToSuspend )
1700:../FreeRTOS/Source/tasks.c ****     {
1701:../FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
1702:../FreeRTOS/Source/tasks.c **** 
1703:../FreeRTOS/Source/tasks.c ****         taskENTER_CRITICAL();
1704:../FreeRTOS/Source/tasks.c ****         {
1705:../FreeRTOS/Source/tasks.c ****             /* If null is passed in here then it is the running task that is
1706:../FreeRTOS/Source/tasks.c ****              * being suspended. */
1707:../FreeRTOS/Source/tasks.c ****             pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
1708:../FreeRTOS/Source/tasks.c **** 
1709:../FreeRTOS/Source/tasks.c ****             traceTASK_SUSPEND( pxTCB );
1710:../FreeRTOS/Source/tasks.c **** 
1711:../FreeRTOS/Source/tasks.c ****             /* Remove task from the ready/delayed list and place in the
1712:../FreeRTOS/Source/tasks.c ****              * suspended list. */
1713:../FreeRTOS/Source/tasks.c ****             if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1714:../FreeRTOS/Source/tasks.c ****             {
1715:../FreeRTOS/Source/tasks.c ****                 taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1716:../FreeRTOS/Source/tasks.c ****             }
1717:../FreeRTOS/Source/tasks.c ****             else
1718:../FreeRTOS/Source/tasks.c ****             {
1719:../FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
1720:../FreeRTOS/Source/tasks.c ****             }
1721:../FreeRTOS/Source/tasks.c **** 
1722:../FreeRTOS/Source/tasks.c ****             /* Is the task waiting on an event also? */
1723:../FreeRTOS/Source/tasks.c ****             if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
1724:../FreeRTOS/Source/tasks.c ****             {
1725:../FreeRTOS/Source/tasks.c ****                 ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1726:../FreeRTOS/Source/tasks.c ****             }
1727:../FreeRTOS/Source/tasks.c ****             else
1728:../FreeRTOS/Source/tasks.c ****             {
1729:../FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
1730:../FreeRTOS/Source/tasks.c ****             }
1731:../FreeRTOS/Source/tasks.c **** 
1732:../FreeRTOS/Source/tasks.c ****             vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
1733:../FreeRTOS/Source/tasks.c **** 
1734:../FreeRTOS/Source/tasks.c ****             #if ( configUSE_TASK_NOTIFICATIONS == 1 )
1735:../FreeRTOS/Source/tasks.c ****                 {
1736:../FreeRTOS/Source/tasks.c ****                     BaseType_t x;
1737:../FreeRTOS/Source/tasks.c **** 
1738:../FreeRTOS/Source/tasks.c ****                     for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
1739:../FreeRTOS/Source/tasks.c ****                     {
1740:../FreeRTOS/Source/tasks.c ****                         if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
1741:../FreeRTOS/Source/tasks.c ****                         {
1742:../FreeRTOS/Source/tasks.c ****                             /* The task was blocked to wait for a notification, but is
1743:../FreeRTOS/Source/tasks.c ****                              * now suspended, so no notification was received. */
1744:../FreeRTOS/Source/tasks.c ****                             pxTCB->ucNotifyState[ x ] = taskNOT_WAITING_NOTIFICATION;
1745:../FreeRTOS/Source/tasks.c ****                         }
1746:../FreeRTOS/Source/tasks.c ****                     }
1747:../FreeRTOS/Source/tasks.c ****                 }
1748:../FreeRTOS/Source/tasks.c ****             #endif /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
1749:../FreeRTOS/Source/tasks.c ****         }
1750:../FreeRTOS/Source/tasks.c ****         taskEXIT_CRITICAL();
1751:../FreeRTOS/Source/tasks.c **** 
1752:../FreeRTOS/Source/tasks.c ****         if( xSchedulerRunning != pdFALSE )
1753:../FreeRTOS/Source/tasks.c ****         {
1754:../FreeRTOS/Source/tasks.c ****             /* Reset the next expected unblock time in case it referred to the
1755:../FreeRTOS/Source/tasks.c ****              * task that is now in the Suspended state. */
1756:../FreeRTOS/Source/tasks.c ****             taskENTER_CRITICAL();
1757:../FreeRTOS/Source/tasks.c ****             {
1758:../FreeRTOS/Source/tasks.c ****                 prvResetNextTaskUnblockTime();
1759:../FreeRTOS/Source/tasks.c ****             }
1760:../FreeRTOS/Source/tasks.c ****             taskEXIT_CRITICAL();
1761:../FreeRTOS/Source/tasks.c ****         }
1762:../FreeRTOS/Source/tasks.c ****         else
1763:../FreeRTOS/Source/tasks.c ****         {
1764:../FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
1765:../FreeRTOS/Source/tasks.c ****         }
1766:../FreeRTOS/Source/tasks.c **** 
1767:../FreeRTOS/Source/tasks.c ****         if( pxTCB == pxCurrentTCB )
1768:../FreeRTOS/Source/tasks.c ****         {
1769:../FreeRTOS/Source/tasks.c ****             if( xSchedulerRunning != pdFALSE )
1770:../FreeRTOS/Source/tasks.c ****             {
1771:../FreeRTOS/Source/tasks.c ****                 /* The current task has just been suspended. */
1772:../FreeRTOS/Source/tasks.c ****                 configASSERT( uxSchedulerSuspended == 0 );
1773:../FreeRTOS/Source/tasks.c ****                 portYIELD_WITHIN_API();
1774:../FreeRTOS/Source/tasks.c ****             }
1775:../FreeRTOS/Source/tasks.c ****             else
1776:../FreeRTOS/Source/tasks.c ****             {
1777:../FreeRTOS/Source/tasks.c ****                 /* The scheduler is not running, but the task that was pointed
1778:../FreeRTOS/Source/tasks.c ****                  * to by pxCurrentTCB has just been suspended and pxCurrentTCB
1779:../FreeRTOS/Source/tasks.c ****                  * must be adjusted to point to a different task. */
1780:../FreeRTOS/Source/tasks.c ****                 if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*li
1781:../FreeRTOS/Source/tasks.c ****                 {
1782:../FreeRTOS/Source/tasks.c ****                     /* No other tasks are ready, so set pxCurrentTCB back to
1783:../FreeRTOS/Source/tasks.c ****                      * NULL so when the next task is created pxCurrentTCB will
1784:../FreeRTOS/Source/tasks.c ****                      * be set to point to it no matter what its relative priority
1785:../FreeRTOS/Source/tasks.c ****                      * is. */
1786:../FreeRTOS/Source/tasks.c ****                     pxCurrentTCB = NULL;
1787:../FreeRTOS/Source/tasks.c ****                 }
1788:../FreeRTOS/Source/tasks.c ****                 else
1789:../FreeRTOS/Source/tasks.c ****                 {
1790:../FreeRTOS/Source/tasks.c ****                     vTaskSwitchContext();
1791:../FreeRTOS/Source/tasks.c ****                 }
1792:../FreeRTOS/Source/tasks.c ****             }
1793:../FreeRTOS/Source/tasks.c ****         }
1794:../FreeRTOS/Source/tasks.c ****         else
1795:../FreeRTOS/Source/tasks.c ****         {
1796:../FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
1797:../FreeRTOS/Source/tasks.c ****         }
1798:../FreeRTOS/Source/tasks.c ****     }
1799:../FreeRTOS/Source/tasks.c **** 
1800:../FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1801:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1802:../FreeRTOS/Source/tasks.c **** 
1803:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1804:../FreeRTOS/Source/tasks.c **** 
1805:../FreeRTOS/Source/tasks.c ****     static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
1806:../FreeRTOS/Source/tasks.c ****     {
  26              	 .loc 1 1806 0
  27              	 .cfi_startproc
  28              	 
  29              	 
  30              	 
  31              	.LVL0:
1807:../FreeRTOS/Source/tasks.c ****         BaseType_t xReturn = pdFALSE;
1808:../FreeRTOS/Source/tasks.c ****         const TCB_t * const pxTCB = xTask;
1809:../FreeRTOS/Source/tasks.c **** 
1810:../FreeRTOS/Source/tasks.c ****         /* Accesses xPendingReadyList so must be called from a critical
1811:../FreeRTOS/Source/tasks.c ****          * section. */
1812:../FreeRTOS/Source/tasks.c **** 
1813:../FreeRTOS/Source/tasks.c ****         /* It does not make sense to check if the calling task is suspended. */
1814:../FreeRTOS/Source/tasks.c ****         configASSERT( xTask );
  32              	 .loc 1 1814 0
  33 0000 40B9     	 cbnz r0,.L2
  34              	.LBB125:
  35              	.LBB126:
  36              	 .file 2 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h"
   1:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*
   2:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * FreeRTOS Kernel V10.4.1
   3:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
   5:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * this software and associated documentation files (the "Software"), to deal in
   7:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * the Software without restriction, including without limitation the rights to
   8:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * subject to the following conditions:
  11:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  12:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * The above copyright notice and this permission notice shall be included in all
  13:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * copies or substantial portions of the Software.
  14:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  15:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  22:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * https://www.FreeRTOS.org
  23:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * https://github.com/FreeRTOS
  24:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  25:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * 1 tab == 4 spaces!
  26:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  */
  27:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  28:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  29:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** #ifndef PORTMACRO_H
  30:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define PORTMACRO_H
  31:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  32:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifdef __cplusplus
  33:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         extern "C" {
  34:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
  35:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  36:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------
  37:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * Port specific definitions.
  38:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  39:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * The settings in this file configure FreeRTOS correctly for the
  40:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * given hardware and compiler.
  41:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  42:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * These settings should not be altered.
  43:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *-----------------------------------------------------------
  44:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  */
  45:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  46:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Type definitions. */
  47:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portCHAR          char
  48:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portFLOAT         float
  49:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portDOUBLE        double
  50:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portLONG          long
  51:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portSHORT         short
  52:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portSTACK_TYPE    uint32_t
  53:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portBASE_TYPE     long
  54:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  55:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     typedef portSTACK_TYPE   StackType_t;
  56:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     typedef long             BaseType_t;
  57:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     typedef unsigned long    UBaseType_t;
  58:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  59:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #if ( configUSE_16_BIT_TICKS == 1 )
  60:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         typedef uint16_t     TickType_t;
  61:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portMAX_DELAY              ( TickType_t ) 0xffff
  62:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #else
  63:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         typedef uint32_t     TickType_t;
  64:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portMAX_DELAY              ( TickType_t ) 0xffffffffUL
  65:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  66:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
  67:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * not need to be guarded with a critical section. */
  68:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portTICK_TYPE_IS_ATOMIC    1
  69:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
  70:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
  71:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  72:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Architecture specifics. */
  73:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portSTACK_GROWTH      ( -1 )
  74:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portTICK_PERIOD_MS    ( ( TickType_t ) 1000 / configTICK_RATE_HZ )
  75:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portBYTE_ALIGNMENT    8
  76:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portDONT_DISCARD      __attribute__( ( used ) )
  77:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
  78:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  79:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Scheduler utilities. */
  80:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portYIELD()                                 \
  81:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     {                                                   \
  82:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         /* Set a PendSV to request a context switch. */ \
  83:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT; \
  84:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****                                                         \
  85:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         /* Barriers are normally not required but do ensure the code is completely \
  86:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****          * within the specified behaviour for the architecture. */ \
  87:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile ( "dsb" ::: "memory" );                     \
  88:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile ( "isb" );                                  \
  89:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     }
  90:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  91:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portNVIC_INT_CTRL_REG     ( *( ( volatile uint32_t * ) 0xe000ed04 ) )
  92:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portNVIC_PENDSVSET_BIT    ( 1UL << 28UL )
  93:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portEND_SWITCHING_ISR( xSwitchRequired )    if( xSwitchRequired != pdFALSE ) portYIELD(
  94:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portYIELD_FROM_ISR( x )                     portEND_SWITCHING_ISR( x )
  95:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
  96:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  97:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Critical section management. */
  98:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     extern void vPortEnterCritical( void );
  99:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     extern void vPortExitCritical( void );
 100:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portSET_INTERRUPT_MASK_FROM_ISR()         ulPortRaiseBASEPRI()
 101:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portCLEAR_INTERRUPT_MASK_FROM_ISR( x )    vPortSetBASEPRI( x )
 102:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portDISABLE_INTERRUPTS()                  vPortRaiseBASEPRI()
 103:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portENABLE_INTERRUPTS()                   vPortSetBASEPRI( 0 )
 104:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portENTER_CRITICAL()                      vPortEnterCritical()
 105:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portEXIT_CRITICAL()                       vPortExitCritical()
 106:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 107:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 108:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 109:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Task function macros as described on the FreeRTOS.org WEB site.  These are
 110:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * not necessary for to use this port.  They are defined so the common demo files
 111:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * (which build with all the ports) will build. */
 112:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portTASK_FUNCTION_PROTO( vFunction, pvParameters )    void vFunction( void * pvParamete
 113:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portTASK_FUNCTION( vFunction, pvParameters )          void vFunction( void * pvParamete
 114:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 115:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 116:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Tickless idle/low power functionality. */
 117:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifndef portSUPPRESS_TICKS_AND_SLEEP
 118:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
 119:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime )    vPortSuppressTicksAndSleep( xE
 120:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
 121:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 122:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 123:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Architecture specific optimisations. */
 124:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
 125:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define configUSE_PORT_OPTIMISED_TASK_SELECTION    1
 126:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
 127:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 128:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
 129:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 130:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Generic helper function. */
 131:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t 
 132:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         {
 133:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             uint8_t ucReturn;
 134:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 135:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             __asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 136:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 137:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             return ucReturn;
 138:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         }
 139:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 140:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Check the configuration. */
 141:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #if ( configMAX_PRIORITIES > 32 )
 142:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             #error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIO
 143:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #endif
 144:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 145:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Store/clear the ready priorities in a bit map. */
 146:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities )    ( uxReadyPriorities )
 147:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities )     ( uxReadyPriorities )
 148:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 149:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 150:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 151:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities )    uxTopPriority = ( 3
 152:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 153:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 154:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 155:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 156:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 157:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifdef configASSERT
 158:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         void vPortValidateInterruptPriority( void );
 159:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portASSERT_IF_INTERRUPT_PRIORITY_INVALID()    vPortValidateInterruptPriority()
 160:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
 161:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 162:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* portNOP() is not required by this port. */
 163:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portNOP()
 164:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 165:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portINLINE              __inline
 166:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 167:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifndef portFORCE_INLINE
 168:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portFORCE_INLINE    inline __attribute__( ( always_inline ) )
 169:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
 170:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 171:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     portFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )
 172:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     {
 173:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         uint32_t ulCurrentInterrupt;
 174:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         BaseType_t xReturn;
 175:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 176:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         /* Obtain the number of the currently executing interrupt. */
 177:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile ( "mrs %0, ipsr" : "=r" ( ulCurrentInterrupt )::"memory" );
 178:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 179:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         if( ulCurrentInterrupt == 0 )
 180:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         {
 181:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             xReturn = pdFALSE;
 182:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         }
 183:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         else
 184:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         {
 185:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             xReturn = pdTRUE;
 186:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         }
 187:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 188:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         return xReturn;
 189:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     }
 190:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 191:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 192:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 193:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     portFORCE_INLINE static void vPortRaiseBASEPRI( void )
 194:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     {
 195:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         uint32_t ulNewBASEPRI;
 196:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile
  37              	 .loc 2 197 0
  38              	
  39 0002 4FF01403 	 mov r3,#20
  40 0006 83F31188 	 msr basepri,r3
  41 000a BFF36F8F 	 isb 
  42 000e BFF34F8F 	 dsb 
  43              	
  44              	
  45              	.LVL1:
  46              	 .thumb
  47              	.L3:
  48              	.LBE126:
  49              	.LBE125:
  50              	 .loc 1 1814 0 discriminator 1
  51 0012 FEE7     	 b .L3
  52              	.L2:
1815:../FreeRTOS/Source/tasks.c **** 
1816:../FreeRTOS/Source/tasks.c ****         /* Is the task being resumed actually in the suspended list? */
1817:../FreeRTOS/Source/tasks.c ****         if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
  53              	 .loc 1 1817 0
  54 0014 4169     	 ldr r1,[r0,#20]
  55 0016 074A     	 ldr r2,.L7
  56 0018 9142     	 cmp r1,r2
  57 001a 07D1     	 bne .L5
1818:../FreeRTOS/Source/tasks.c ****         {
1819:../FreeRTOS/Source/tasks.c ****             /* Has the task already been resumed from within an ISR? */
1820:../FreeRTOS/Source/tasks.c ****             if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALS
  58              	 .loc 1 1820 0
  59 001c 806A     	 ldr r0,[r0,#40]
  60              	.LVL2:
  61 001e 064B     	 ldr r3,.L7+4
  62 0020 9842     	 cmp r0,r3
  63 0022 05D0     	 beq .L6
1821:../FreeRTOS/Source/tasks.c ****             {
1822:../FreeRTOS/Source/tasks.c ****                 /* Is it in the suspended list because it is in the Suspended
1823:../FreeRTOS/Source/tasks.c ****                  * state, or because is is blocked with no timeout? */
1824:../FreeRTOS/Source/tasks.c ****                 if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint
  64              	 .loc 1 1824 0
  65 0024 B0FA80F0 	 clz r0,r0
  66 0028 4009     	 lsrs r0,r0,#5
  67 002a 7047     	 bx lr
  68              	.LVL3:
  69              	.L5:
1807:../FreeRTOS/Source/tasks.c ****         const TCB_t * const pxTCB = xTask;
  70              	 .loc 1 1807 0
  71 002c 0020     	 movs r0,#0
  72              	.LVL4:
  73 002e 7047     	 bx lr
  74              	.L6:
  75 0030 0020     	 movs r0,#0
  76              	.LVL5:
1825:../FreeRTOS/Source/tasks.c ****                 {
1826:../FreeRTOS/Source/tasks.c ****                     xReturn = pdTRUE;
1827:../FreeRTOS/Source/tasks.c ****                 }
1828:../FreeRTOS/Source/tasks.c ****                 else
1829:../FreeRTOS/Source/tasks.c ****                 {
1830:../FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
1831:../FreeRTOS/Source/tasks.c ****                 }
1832:../FreeRTOS/Source/tasks.c ****             }
1833:../FreeRTOS/Source/tasks.c ****             else
1834:../FreeRTOS/Source/tasks.c ****             {
1835:../FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
1836:../FreeRTOS/Source/tasks.c ****             }
1837:../FreeRTOS/Source/tasks.c ****         }
1838:../FreeRTOS/Source/tasks.c ****         else
1839:../FreeRTOS/Source/tasks.c ****         {
1840:../FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
1841:../FreeRTOS/Source/tasks.c ****         }
1842:../FreeRTOS/Source/tasks.c **** 
1843:../FreeRTOS/Source/tasks.c ****         return xReturn;
1844:../FreeRTOS/Source/tasks.c ****     } /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
  77              	 .loc 1 1844 0
  78 0032 7047     	 bx lr
  79              	.L8:
  80              	 .align 2
  81              	.L7:
  82 0034 00000000 	 .word .LANCHOR0
  83 0038 00000000 	 .word .LANCHOR1
  84              	 .cfi_endproc
  85              	.LFE16:
  87              	 .section .text.prvResetNextTaskUnblockTime,"ax",%progbits
  88              	 .align 2
  89              	 .thumb
  90              	 .thumb_func
  92              	prvResetNextTaskUnblockTime:
  93              	.LFB49:
1845:../FreeRTOS/Source/tasks.c **** 
1846:../FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1847:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1848:../FreeRTOS/Source/tasks.c **** 
1849:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1850:../FreeRTOS/Source/tasks.c **** 
1851:../FreeRTOS/Source/tasks.c ****     void vTaskResume( TaskHandle_t xTaskToResume )
1852:../FreeRTOS/Source/tasks.c ****     {
1853:../FreeRTOS/Source/tasks.c ****         TCB_t * const pxTCB = xTaskToResume;
1854:../FreeRTOS/Source/tasks.c **** 
1855:../FreeRTOS/Source/tasks.c ****         /* It does not make sense to resume the calling task. */
1856:../FreeRTOS/Source/tasks.c ****         configASSERT( xTaskToResume );
1857:../FreeRTOS/Source/tasks.c **** 
1858:../FreeRTOS/Source/tasks.c ****         /* The parameter cannot be NULL as it is impossible to resume the
1859:../FreeRTOS/Source/tasks.c ****          * currently executing task. */
1860:../FreeRTOS/Source/tasks.c ****         if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
1861:../FreeRTOS/Source/tasks.c ****         {
1862:../FreeRTOS/Source/tasks.c ****             taskENTER_CRITICAL();
1863:../FreeRTOS/Source/tasks.c ****             {
1864:../FreeRTOS/Source/tasks.c ****                 if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
1865:../FreeRTOS/Source/tasks.c ****                 {
1866:../FreeRTOS/Source/tasks.c ****                     traceTASK_RESUME( pxTCB );
1867:../FreeRTOS/Source/tasks.c **** 
1868:../FreeRTOS/Source/tasks.c ****                     /* The ready list can be accessed even if the scheduler is
1869:../FreeRTOS/Source/tasks.c ****                      * suspended because this is inside a critical section. */
1870:../FreeRTOS/Source/tasks.c ****                     ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
1871:../FreeRTOS/Source/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
1872:../FreeRTOS/Source/tasks.c **** 
1873:../FreeRTOS/Source/tasks.c ****                     /* A higher priority task may have just been resumed. */
1874:../FreeRTOS/Source/tasks.c ****                     if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1875:../FreeRTOS/Source/tasks.c ****                     {
1876:../FreeRTOS/Source/tasks.c ****                         /* This yield may not cause the task just resumed to run,
1877:../FreeRTOS/Source/tasks.c ****                          * but will leave the lists in the correct state for the
1878:../FreeRTOS/Source/tasks.c ****                          * next yield. */
1879:../FreeRTOS/Source/tasks.c ****                         taskYIELD_IF_USING_PREEMPTION();
1880:../FreeRTOS/Source/tasks.c ****                     }
1881:../FreeRTOS/Source/tasks.c ****                     else
1882:../FreeRTOS/Source/tasks.c ****                     {
1883:../FreeRTOS/Source/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
1884:../FreeRTOS/Source/tasks.c ****                     }
1885:../FreeRTOS/Source/tasks.c ****                 }
1886:../FreeRTOS/Source/tasks.c ****                 else
1887:../FreeRTOS/Source/tasks.c ****                 {
1888:../FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
1889:../FreeRTOS/Source/tasks.c ****                 }
1890:../FreeRTOS/Source/tasks.c ****             }
1891:../FreeRTOS/Source/tasks.c ****             taskEXIT_CRITICAL();
1892:../FreeRTOS/Source/tasks.c ****         }
1893:../FreeRTOS/Source/tasks.c ****         else
1894:../FreeRTOS/Source/tasks.c ****         {
1895:../FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
1896:../FreeRTOS/Source/tasks.c ****         }
1897:../FreeRTOS/Source/tasks.c ****     }
1898:../FreeRTOS/Source/tasks.c **** 
1899:../FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1900:../FreeRTOS/Source/tasks.c **** 
1901:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1902:../FreeRTOS/Source/tasks.c **** 
1903:../FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1904:../FreeRTOS/Source/tasks.c **** 
1905:../FreeRTOS/Source/tasks.c ****     BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
1906:../FreeRTOS/Source/tasks.c ****     {
1907:../FreeRTOS/Source/tasks.c ****         BaseType_t xYieldRequired = pdFALSE;
1908:../FreeRTOS/Source/tasks.c ****         TCB_t * const pxTCB = xTaskToResume;
1909:../FreeRTOS/Source/tasks.c ****         UBaseType_t uxSavedInterruptStatus;
1910:../FreeRTOS/Source/tasks.c **** 
1911:../FreeRTOS/Source/tasks.c ****         configASSERT( xTaskToResume );
1912:../FreeRTOS/Source/tasks.c **** 
1913:../FreeRTOS/Source/tasks.c ****         /* RTOS ports that support interrupt nesting have the concept of a
1914:../FreeRTOS/Source/tasks.c ****          * maximum  system call (or maximum API call) interrupt priority.
1915:../FreeRTOS/Source/tasks.c ****          * Interrupts that are  above the maximum system call priority are keep
1916:../FreeRTOS/Source/tasks.c ****          * permanently enabled, even when the RTOS kernel is in a critical section,
1917:../FreeRTOS/Source/tasks.c ****          * but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1918:../FreeRTOS/Source/tasks.c ****          * is defined in FreeRTOSConfig.h then
1919:../FreeRTOS/Source/tasks.c ****          * portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1920:../FreeRTOS/Source/tasks.c ****          * failure if a FreeRTOS API function is called from an interrupt that has
1921:../FreeRTOS/Source/tasks.c ****          * been assigned a priority above the configured maximum system call
1922:../FreeRTOS/Source/tasks.c ****          * priority.  Only FreeRTOS functions that end in FromISR can be called
1923:../FreeRTOS/Source/tasks.c ****          * from interrupts  that have been assigned a priority at or (logically)
1924:../FreeRTOS/Source/tasks.c ****          * below the maximum system call interrupt priority.  FreeRTOS maintains a
1925:../FreeRTOS/Source/tasks.c ****          * separate interrupt safe API to ensure interrupt entry is as fast and as
1926:../FreeRTOS/Source/tasks.c ****          * simple as possible.  More information (albeit Cortex-M specific) is
1927:../FreeRTOS/Source/tasks.c ****          * provided on the following link:
1928:../FreeRTOS/Source/tasks.c ****          * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
1929:../FreeRTOS/Source/tasks.c ****         portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1930:../FreeRTOS/Source/tasks.c **** 
1931:../FreeRTOS/Source/tasks.c ****         uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1932:../FreeRTOS/Source/tasks.c ****         {
1933:../FreeRTOS/Source/tasks.c ****             if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
1934:../FreeRTOS/Source/tasks.c ****             {
1935:../FreeRTOS/Source/tasks.c ****                 traceTASK_RESUME_FROM_ISR( pxTCB );
1936:../FreeRTOS/Source/tasks.c **** 
1937:../FreeRTOS/Source/tasks.c ****                 /* Check the ready lists can be accessed. */
1938:../FreeRTOS/Source/tasks.c ****                 if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
1939:../FreeRTOS/Source/tasks.c ****                 {
1940:../FreeRTOS/Source/tasks.c ****                     /* Ready lists can be accessed so move the task from the
1941:../FreeRTOS/Source/tasks.c ****                      * suspended list to the ready list directly. */
1942:../FreeRTOS/Source/tasks.c ****                     if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1943:../FreeRTOS/Source/tasks.c ****                     {
1944:../FreeRTOS/Source/tasks.c ****                         xYieldRequired = pdTRUE;
1945:../FreeRTOS/Source/tasks.c ****                     }
1946:../FreeRTOS/Source/tasks.c ****                     else
1947:../FreeRTOS/Source/tasks.c ****                     {
1948:../FreeRTOS/Source/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
1949:../FreeRTOS/Source/tasks.c ****                     }
1950:../FreeRTOS/Source/tasks.c **** 
1951:../FreeRTOS/Source/tasks.c ****                     ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
1952:../FreeRTOS/Source/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
1953:../FreeRTOS/Source/tasks.c ****                 }
1954:../FreeRTOS/Source/tasks.c ****                 else
1955:../FreeRTOS/Source/tasks.c ****                 {
1956:../FreeRTOS/Source/tasks.c ****                     /* The delayed or ready lists cannot be accessed so the task
1957:../FreeRTOS/Source/tasks.c ****                      * is held in the pending ready list until the scheduler is
1958:../FreeRTOS/Source/tasks.c ****                      * unsuspended. */
1959:../FreeRTOS/Source/tasks.c ****                     vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
1960:../FreeRTOS/Source/tasks.c ****                 }
1961:../FreeRTOS/Source/tasks.c ****             }
1962:../FreeRTOS/Source/tasks.c ****             else
1963:../FreeRTOS/Source/tasks.c ****             {
1964:../FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
1965:../FreeRTOS/Source/tasks.c ****             }
1966:../FreeRTOS/Source/tasks.c ****         }
1967:../FreeRTOS/Source/tasks.c ****         portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1968:../FreeRTOS/Source/tasks.c **** 
1969:../FreeRTOS/Source/tasks.c ****         return xYieldRequired;
1970:../FreeRTOS/Source/tasks.c ****     }
1971:../FreeRTOS/Source/tasks.c **** 
1972:../FreeRTOS/Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1973:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1974:../FreeRTOS/Source/tasks.c **** 
1975:../FreeRTOS/Source/tasks.c **** void vTaskStartScheduler( void )
1976:../FreeRTOS/Source/tasks.c **** {
1977:../FreeRTOS/Source/tasks.c ****     BaseType_t xReturn;
1978:../FreeRTOS/Source/tasks.c **** 
1979:../FreeRTOS/Source/tasks.c ****     /* Add the idle task at the lowest priority. */
1980:../FreeRTOS/Source/tasks.c ****     #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
1981:../FreeRTOS/Source/tasks.c ****         {
1982:../FreeRTOS/Source/tasks.c ****             StaticTask_t * pxIdleTaskTCBBuffer = NULL;
1983:../FreeRTOS/Source/tasks.c ****             StackType_t * pxIdleTaskStackBuffer = NULL;
1984:../FreeRTOS/Source/tasks.c ****             uint32_t ulIdleTaskStackSize;
1985:../FreeRTOS/Source/tasks.c **** 
1986:../FreeRTOS/Source/tasks.c ****             /* The Idle task is created using user provided RAM - obtain the
1987:../FreeRTOS/Source/tasks.c ****              * address of the RAM then create the idle task. */
1988:../FreeRTOS/Source/tasks.c ****             vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTas
1989:../FreeRTOS/Source/tasks.c ****             xIdleTaskHandle = xTaskCreateStatic( prvIdleTask,
1990:../FreeRTOS/Source/tasks.c ****                                                  configIDLE_TASK_NAME,
1991:../FreeRTOS/Source/tasks.c ****                                                  ulIdleTaskStackSize,
1992:../FreeRTOS/Source/tasks.c ****                                                  ( void * ) NULL,       /*lint !e961.  The cast is 
1993:../FreeRTOS/Source/tasks.c ****                                                  portPRIVILEGE_BIT,     /* In effect ( tskIDLE_PRIO
1994:../FreeRTOS/Source/tasks.c ****                                                  pxIdleTaskStackBuffer,
1995:../FreeRTOS/Source/tasks.c ****                                                  pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exceptio
1996:../FreeRTOS/Source/tasks.c **** 
1997:../FreeRTOS/Source/tasks.c ****             if( xIdleTaskHandle != NULL )
1998:../FreeRTOS/Source/tasks.c ****             {
1999:../FreeRTOS/Source/tasks.c ****                 xReturn = pdPASS;
2000:../FreeRTOS/Source/tasks.c ****             }
2001:../FreeRTOS/Source/tasks.c ****             else
2002:../FreeRTOS/Source/tasks.c ****             {
2003:../FreeRTOS/Source/tasks.c ****                 xReturn = pdFAIL;
2004:../FreeRTOS/Source/tasks.c ****             }
2005:../FreeRTOS/Source/tasks.c ****         }
2006:../FreeRTOS/Source/tasks.c ****     #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
2007:../FreeRTOS/Source/tasks.c ****         {
2008:../FreeRTOS/Source/tasks.c ****             /* The Idle task is being created using dynamically allocated RAM. */
2009:../FreeRTOS/Source/tasks.c ****             xReturn = xTaskCreate( prvIdleTask,
2010:../FreeRTOS/Source/tasks.c ****                                    configIDLE_TASK_NAME,
2011:../FreeRTOS/Source/tasks.c ****                                    configMINIMAL_STACK_SIZE,
2012:../FreeRTOS/Source/tasks.c ****                                    ( void * ) NULL,
2013:../FreeRTOS/Source/tasks.c ****                                    portPRIVILEGE_BIT,  /* In effect ( tskIDLE_PRIORITY | portPRIVIL
2014:../FreeRTOS/Source/tasks.c ****                                    &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as i
2015:../FreeRTOS/Source/tasks.c ****         }
2016:../FreeRTOS/Source/tasks.c ****     #endif /* configSUPPORT_STATIC_ALLOCATION */
2017:../FreeRTOS/Source/tasks.c **** 
2018:../FreeRTOS/Source/tasks.c ****     #if ( configUSE_TIMERS == 1 )
2019:../FreeRTOS/Source/tasks.c ****         {
2020:../FreeRTOS/Source/tasks.c ****             if( xReturn == pdPASS )
2021:../FreeRTOS/Source/tasks.c ****             {
2022:../FreeRTOS/Source/tasks.c ****                 xReturn = xTimerCreateTimerTask();
2023:../FreeRTOS/Source/tasks.c ****             }
2024:../FreeRTOS/Source/tasks.c ****             else
2025:../FreeRTOS/Source/tasks.c ****             {
2026:../FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
2027:../FreeRTOS/Source/tasks.c ****             }
2028:../FreeRTOS/Source/tasks.c ****         }
2029:../FreeRTOS/Source/tasks.c ****     #endif /* configUSE_TIMERS */
2030:../FreeRTOS/Source/tasks.c **** 
2031:../FreeRTOS/Source/tasks.c ****     if( xReturn == pdPASS )
2032:../FreeRTOS/Source/tasks.c ****     {
2033:../FreeRTOS/Source/tasks.c ****         /* freertos_tasks_c_additions_init() should only be called if the user
2034:../FreeRTOS/Source/tasks.c ****          * definable macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is
2035:../FreeRTOS/Source/tasks.c ****          * the only macro called by the function. */
2036:../FreeRTOS/Source/tasks.c ****         #ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
2037:../FreeRTOS/Source/tasks.c ****             {
2038:../FreeRTOS/Source/tasks.c ****                 freertos_tasks_c_additions_init();
2039:../FreeRTOS/Source/tasks.c ****             }
2040:../FreeRTOS/Source/tasks.c ****         #endif
2041:../FreeRTOS/Source/tasks.c **** 
2042:../FreeRTOS/Source/tasks.c ****         /* Interrupts are turned off here, to ensure a tick does not occur
2043:../FreeRTOS/Source/tasks.c ****          * before or during the call to xPortStartScheduler().  The stacks of
2044:../FreeRTOS/Source/tasks.c ****          * the created tasks contain a status word with interrupts switched on
2045:../FreeRTOS/Source/tasks.c ****          * so interrupts will automatically get re-enabled when the first task
2046:../FreeRTOS/Source/tasks.c ****          * starts to run. */
2047:../FreeRTOS/Source/tasks.c ****         portDISABLE_INTERRUPTS();
2048:../FreeRTOS/Source/tasks.c **** 
2049:../FreeRTOS/Source/tasks.c ****         #if ( configUSE_NEWLIB_REENTRANT == 1 )
2050:../FreeRTOS/Source/tasks.c ****             {
2051:../FreeRTOS/Source/tasks.c ****                 /* Switch Newlib's _impure_ptr variable to point to the _reent
2052:../FreeRTOS/Source/tasks.c ****                  * structure specific to the task that will run first.
2053:../FreeRTOS/Source/tasks.c ****                  * See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
2054:../FreeRTOS/Source/tasks.c ****                  * for additional information. */
2055:../FreeRTOS/Source/tasks.c ****                 _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
2056:../FreeRTOS/Source/tasks.c ****             }
2057:../FreeRTOS/Source/tasks.c ****         #endif /* configUSE_NEWLIB_REENTRANT */
2058:../FreeRTOS/Source/tasks.c **** 
2059:../FreeRTOS/Source/tasks.c ****         xNextTaskUnblockTime = portMAX_DELAY;
2060:../FreeRTOS/Source/tasks.c ****         xSchedulerRunning = pdTRUE;
2061:../FreeRTOS/Source/tasks.c ****         xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
2062:../FreeRTOS/Source/tasks.c **** 
2063:../FreeRTOS/Source/tasks.c ****         /* If configGENERATE_RUN_TIME_STATS is defined then the following
2064:../FreeRTOS/Source/tasks.c ****          * macro must be defined to configure the timer/counter used to generate
2065:../FreeRTOS/Source/tasks.c ****          * the run time counter time base.   NOTE:  If configGENERATE_RUN_TIME_STATS
2066:../FreeRTOS/Source/tasks.c ****          * is set to 0 and the following line fails to build then ensure you do not
2067:../FreeRTOS/Source/tasks.c ****          * have portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() defined in your
2068:../FreeRTOS/Source/tasks.c ****          * FreeRTOSConfig.h file. */
2069:../FreeRTOS/Source/tasks.c ****         portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
2070:../FreeRTOS/Source/tasks.c **** 
2071:../FreeRTOS/Source/tasks.c ****         traceTASK_SWITCHED_IN();
2072:../FreeRTOS/Source/tasks.c **** 
2073:../FreeRTOS/Source/tasks.c ****         /* Setting up the timer tick is hardware specific and thus in the
2074:../FreeRTOS/Source/tasks.c ****          * portable interface. */
2075:../FreeRTOS/Source/tasks.c ****         if( xPortStartScheduler() != pdFALSE )
2076:../FreeRTOS/Source/tasks.c ****         {
2077:../FreeRTOS/Source/tasks.c ****             /* Should not reach here as if the scheduler is running the
2078:../FreeRTOS/Source/tasks.c ****              * function will not return. */
2079:../FreeRTOS/Source/tasks.c ****         }
2080:../FreeRTOS/Source/tasks.c ****         else
2081:../FreeRTOS/Source/tasks.c ****         {
2082:../FreeRTOS/Source/tasks.c ****             /* Should only reach here if a task calls xTaskEndScheduler(). */
2083:../FreeRTOS/Source/tasks.c ****         }
2084:../FreeRTOS/Source/tasks.c ****     }
2085:../FreeRTOS/Source/tasks.c ****     else
2086:../FreeRTOS/Source/tasks.c ****     {
2087:../FreeRTOS/Source/tasks.c ****         /* This line will only be reached if the kernel could not be started,
2088:../FreeRTOS/Source/tasks.c ****          * because there was not enough FreeRTOS heap to create the idle task
2089:../FreeRTOS/Source/tasks.c ****          * or the timer task. */
2090:../FreeRTOS/Source/tasks.c ****         configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
2091:../FreeRTOS/Source/tasks.c ****     }
2092:../FreeRTOS/Source/tasks.c **** 
2093:../FreeRTOS/Source/tasks.c ****     /* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
2094:../FreeRTOS/Source/tasks.c ****      * meaning xIdleTaskHandle is not used anywhere else. */
2095:../FreeRTOS/Source/tasks.c ****     ( void ) xIdleTaskHandle;
2096:../FreeRTOS/Source/tasks.c **** }
2097:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2098:../FreeRTOS/Source/tasks.c **** 
2099:../FreeRTOS/Source/tasks.c **** void vTaskEndScheduler( void )
2100:../FreeRTOS/Source/tasks.c **** {
2101:../FreeRTOS/Source/tasks.c ****     /* Stop the scheduler interrupts and call the portable scheduler end
2102:../FreeRTOS/Source/tasks.c ****      * routine so the original ISRs can be restored if necessary.  The port
2103:../FreeRTOS/Source/tasks.c ****      * layer must ensure interrupts enable  bit is left in the correct state. */
2104:../FreeRTOS/Source/tasks.c ****     portDISABLE_INTERRUPTS();
2105:../FreeRTOS/Source/tasks.c ****     xSchedulerRunning = pdFALSE;
2106:../FreeRTOS/Source/tasks.c ****     vPortEndScheduler();
2107:../FreeRTOS/Source/tasks.c **** }
2108:../FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2109:../FreeRTOS/Source/tasks.c **** 
2110:../FreeRTOS/Source/tasks.c **** void vTaskSuspendAll( void )
2111:../FreeRTOS/Source/tasks.c **** {
2112:../FreeRTOS/Source/tasks.c ****     /* A critical section is not required as the variable is of type
2113:../FreeRTOS/Source/tasks.c ****      * BaseType_t.  Please read Richard Barry's reply in the following link to a
2114:../FreeRTOS/Source/tasks.c ****      * post in the FreeRTOS support forum before reporting this as a bug! -
2115:../FreeRTOS/Source/tasks.c ****      * http://goo.gl/wu4acr */
2116:../FreeRTOS/Source/tasks.c **** 
2117:../FreeRTOS/Source/tasks.c ****     /* portSOFRWARE_BARRIER() is only implemented for emulated/simulated ports that
2118:../FreeRTOS/Source/tasks.c ****      * do not otherwise exhibit real time behaviour. */
2119:../FreeRTOS/Source/tasks.c ****     portSOFTWARE_BARRIER();
2120:../FreeRTOS/Source/tasks.c **** 
2121:../FreeRTOS/Source/tasks.c ****     /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
2122:../FreeRTOS/Source/tasks.c ****      * is used to allow calls to vTaskSuspendAll() to nest. */
2123:../FreeRTOS/Source/tasks.c ****     ++uxSchedulerSuspended;
2124:../FreeRTOS/Source/tasks.c **** 
2125:../FreeRTOS/Source/tasks.c ****     /* Enforces ordering for ports and optimised compilers that may otherwise place
2126:../FreeRTOS/Source/tasks.c ****      * the above increment elsewhere. */
2127:../FreeRTOS/Source/tasks.c ****     portMEMORY_BARRIER();
2128:../FreeRTOS/Source/tasks.c **** }
2129:../FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2130:../FreeRTOS/Source/tasks.c **** 
2131:../FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
2132:../FreeRTOS/Source/tasks.c **** 
2133:../FreeRTOS/Source/tasks.c ****     static TickType_t prvGetExpectedIdleTime( void )
2134:../FreeRTOS/Source/tasks.c ****     {
2135:../FreeRTOS/Source/tasks.c ****         TickType_t xReturn;
2136:../FreeRTOS/Source/tasks.c ****         UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
2137:../FreeRTOS/Source/tasks.c **** 
2138:../FreeRTOS/Source/tasks.c ****         /* uxHigherPriorityReadyTasks takes care of the case where
2139:../FreeRTOS/Source/tasks.c ****          * configUSE_PREEMPTION is 0, so there may be tasks above the idle priority
2140:../FreeRTOS/Source/tasks.c ****          * task that are in the Ready state, even though the idle task is
2141:../FreeRTOS/Source/tasks.c ****          * running. */
2142:../FreeRTOS/Source/tasks.c ****         #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
2143:../FreeRTOS/Source/tasks.c ****             {
2144:../FreeRTOS/Source/tasks.c ****                 if( uxTopReadyPriority > tskIDLE_PRIORITY )
2145:../FreeRTOS/Source/tasks.c ****                 {
2146:../FreeRTOS/Source/tasks.c ****                     uxHigherPriorityReadyTasks = pdTRUE;
2147:../FreeRTOS/Source/tasks.c ****                 }
2148:../FreeRTOS/Source/tasks.c ****             }
2149:../FreeRTOS/Source/tasks.c ****         #else
2150:../FreeRTOS/Source/tasks.c ****             {
2151:../FreeRTOS/Source/tasks.c ****                 const UBaseType_t uxLeastSignificantBit = ( UBaseType_t ) 0x01;
2152:../FreeRTOS/Source/tasks.c **** 
2153:../FreeRTOS/Source/tasks.c ****                 /* When port optimised task selection is used the uxTopReadyPriority
2154:../FreeRTOS/Source/tasks.c ****                  * variable is used as a bit map.  If bits other than the least
2155:../FreeRTOS/Source/tasks.c ****                  * significant bit are set then there are tasks that have a priority
2156:../FreeRTOS/Source/tasks.c ****                  * above the idle priority that are in the Ready state.  This takes
2157:../FreeRTOS/Source/tasks.c ****                  * care of the case where the co-operative scheduler is in use. */
2158:../FreeRTOS/Source/tasks.c ****                 if( uxTopReadyPriority > uxLeastSignificantBit )
2159:../FreeRTOS/Source/tasks.c ****                 {
2160:../FreeRTOS/Source/tasks.c ****                     uxHigherPriorityReadyTasks = pdTRUE;
2161:../FreeRTOS/Source/tasks.c ****                 }
2162:../FreeRTOS/Source/tasks.c ****             }
2163:../FreeRTOS/Source/tasks.c ****         #endif /* if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 ) */
2164:../FreeRTOS/Source/tasks.c **** 
2165:../FreeRTOS/Source/tasks.c ****         if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
2166:../FreeRTOS/Source/tasks.c ****         {
2167:../FreeRTOS/Source/tasks.c ****             xReturn = 0;
2168:../FreeRTOS/Source/tasks.c ****         }
2169:../FreeRTOS/Source/tasks.c ****         else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
2170:../FreeRTOS/Source/tasks.c ****         {
2171:../FreeRTOS/Source/tasks.c ****             /* There are other idle priority tasks in the ready state.  If
2172:../FreeRTOS/Source/tasks.c ****              * time slicing is used then the very next tick interrupt must be
2173:../FreeRTOS/Source/tasks.c ****              * processed. */
2174:../FreeRTOS/Source/tasks.c ****             xReturn = 0;
2175:../FreeRTOS/Source/tasks.c ****         }
2176:../FreeRTOS/Source/tasks.c ****         else if( uxHigherPriorityReadyTasks != pdFALSE )
2177:../FreeRTOS/Source/tasks.c ****         {
2178:../FreeRTOS/Source/tasks.c ****             /* There are tasks in the Ready state that have a priority above the
2179:../FreeRTOS/Source/tasks.c ****              * idle priority.  This path can only be reached if
2180:../FreeRTOS/Source/tasks.c ****              * configUSE_PREEMPTION is 0. */
2181:../FreeRTOS/Source/tasks.c ****             xReturn = 0;
2182:../FreeRTOS/Source/tasks.c ****         }
2183:../FreeRTOS/Source/tasks.c ****         else
2184:../FreeRTOS/Source/tasks.c ****         {
2185:../FreeRTOS/Source/tasks.c ****             xReturn = xNextTaskUnblockTime - xTickCount;
2186:../FreeRTOS/Source/tasks.c ****         }
2187:../FreeRTOS/Source/tasks.c **** 
2188:../FreeRTOS/Source/tasks.c ****         return xReturn;
2189:../FreeRTOS/Source/tasks.c ****     }
2190:../FreeRTOS/Source/tasks.c **** 
2191:../FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2192:../FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2193:../FreeRTOS/Source/tasks.c **** 
2194:../FreeRTOS/Source/tasks.c **** BaseType_t xTaskResumeAll( void )
2195:../FreeRTOS/Source/tasks.c **** {
2196:../FreeRTOS/Source/tasks.c ****     TCB_t * pxTCB = NULL;
2197:../FreeRTOS/Source/tasks.c ****     BaseType_t xAlreadyYielded = pdFALSE;
2198:../FreeRTOS/Source/tasks.c **** 
2199:../FreeRTOS/Source/tasks.c ****     /* If uxSchedulerSuspended is zero then this function does not match a
2200:../FreeRTOS/Source/tasks.c ****      * previous call to vTaskSuspendAll(). */
2201:../FreeRTOS/Source/tasks.c ****     configASSERT( uxSchedulerSuspended );
2202:../FreeRTOS/Source/tasks.c **** 
2203:../FreeRTOS/Source/tasks.c ****     /* It is possible that an ISR caused a task to be removed from an event
2204:../FreeRTOS/Source/tasks.c ****      * list while the scheduler was suspended.  If this was the case then the
2205:../FreeRTOS/Source/tasks.c ****      * removed task will have been added to the xPendingReadyList.  Once the
2206:../FreeRTOS/Source/tasks.c ****      * scheduler has been resumed it is safe to move all the pending ready
2207:../FreeRTOS/Source/tasks.c ****      * tasks from this list into their appropriate ready list. */
2208:../FreeRTOS/Source/tasks.c ****     taskENTER_CRITICAL();
2209:../FreeRTOS/Source/tasks.c ****     {
2210:../FreeRTOS/Source/tasks.c ****         --uxSchedulerSuspended;
2211:../FreeRTOS/Source/tasks.c **** 
2212:../FreeRTOS/Source/tasks.c ****         if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
2213:../FreeRTOS/Source/tasks.c ****         {
2214:../FreeRTOS/Source/tasks.c ****             if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
2215:../FreeRTOS/Source/tasks.c ****             {
2216:../FreeRTOS/Source/tasks.c ****                 /* Move any readied tasks from the pending list into the
2217:../FreeRTOS/Source/tasks.c ****                  * appropriate ready list. */
2218:../FreeRTOS/Source/tasks.c ****                 while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
2219:../FreeRTOS/Source/tasks.c ****                 {
2220:../FreeRTOS/Source/tasks.c ****                     pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 vo
2221:../FreeRTOS/Source/tasks.c ****                     ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2222:../FreeRTOS/Source/tasks.c ****                     ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2223:../FreeRTOS/Source/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
2224:../FreeRTOS/Source/tasks.c **** 
2225:../FreeRTOS/Source/tasks.c ****                     /* If the moved task has a priority higher than the current
2226:../FreeRTOS/Source/tasks.c ****                      * task then a yield must be performed. */
2227:../FreeRTOS/Source/tasks.c ****                     if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
2228:../FreeRTOS/Source/tasks.c ****                     {
2229:../FreeRTOS/Source/tasks.c ****                         xYieldPending = pdTRUE;
2230:../FreeRTOS/Source/tasks.c ****                     }
2231:../FreeRTOS/Source/tasks.c ****                     else
2232:../FreeRTOS/Source/tasks.c ****                     {
2233:../FreeRTOS/Source/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
2234:../FreeRTOS/Source/tasks.c ****                     }
2235:../FreeRTOS/Source/tasks.c ****                 }
2236:../FreeRTOS/Source/tasks.c **** 
2237:../FreeRTOS/Source/tasks.c ****                 if( pxTCB != NULL )
2238:../FreeRTOS/Source/tasks.c ****                 {
2239:../FreeRTOS/Source/tasks.c ****                     /* A task was unblocked while the scheduler was suspended,
2240:../FreeRTOS/Source/tasks.c ****                      * which may have prevented the next unblock time from being
2241:../FreeRTOS/Source/tasks.c ****                      * re-calculated, in which case re-calculate it now.  Mainly
2242:../FreeRTOS/Source/tasks.c ****                      * important for low power tickless implementations, where
2243:../FreeRTOS/Source/tasks.c ****                      * this can prevent an unnecessary exit from low power
2244:../FreeRTOS/Source/tasks.c ****                      * state. */
2245:../FreeRTOS/Source/tasks.c ****                     prvResetNextTaskUnblockTime();
2246:../FreeRTOS/Source/tasks.c ****                 }
2247:../FreeRTOS/Source/tasks.c **** 
2248:../FreeRTOS/Source/tasks.c ****                 /* If any ticks occurred while the scheduler was suspended then
2249:../FreeRTOS/Source/tasks.c ****                  * they should be processed now.  This ensures the tick count does
2250:../FreeRTOS/Source/tasks.c ****                  * not  slip, and that any delayed tasks are resumed at the correct
2251:../FreeRTOS/Source/tasks.c ****                  * time. */
2252:../FreeRTOS/Source/tasks.c ****                 {
2253:../FreeRTOS/Source/tasks.c ****                     TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
2254:../FreeRTOS/Source/tasks.c **** 
2255:../FreeRTOS/Source/tasks.c ****                     if( xPendedCounts > ( TickType_t ) 0U )
2256:../FreeRTOS/Source/tasks.c ****                     {
2257:../FreeRTOS/Source/tasks.c ****                         do
2258:../FreeRTOS/Source/tasks.c ****                         {
2259:../FreeRTOS/Source/tasks.c ****                             if( xTaskIncrementTick() != pdFALSE )
2260:../FreeRTOS/Source/tasks.c ****                             {
2261:../FreeRTOS/Source/tasks.c ****                                 xYieldPending = pdTRUE;
2262:../FreeRTOS/Source/tasks.c ****                             }
2263:../FreeRTOS/Source/tasks.c ****                             else
2264:../FreeRTOS/Source/tasks.c ****                             {
2265:../FreeRTOS/Source/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
2266:../FreeRTOS/Source/tasks.c ****                             }
2267:../FreeRTOS/Source/tasks.c **** 
2268:../FreeRTOS/Source/tasks.c ****                             --xPendedCounts;
2269:../FreeRTOS/Source/tasks.c ****                         } while( xPendedCounts > ( TickType_t ) 0U );
2270:../FreeRTOS/Source/tasks.c **** 
2271:../FreeRTOS/Source/tasks.c ****                         xPendedTicks = 0;
2272:../FreeRTOS/Source/tasks.c ****                     }
2273:../FreeRTOS/Source/tasks.c ****                     else
2274:../FreeRTOS/Source/tasks.c ****                     {
2275:../FreeRTOS/Source/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
2276:../FreeRTOS/Source/tasks.c ****                     }
2277:../FreeRTOS/Source/tasks.c ****                 }
2278:../FreeRTOS/Source/tasks.c **** 
2279:../FreeRTOS/Source/tasks.c ****                 if( xYieldPending != pdFALSE )
2280:../FreeRTOS/Source/tasks.c ****                 {
2281:../FreeRTOS/Source/tasks.c ****                     #if ( configUSE_PREEMPTION != 0 )
2282:../FreeRTOS/Source/tasks.c ****                         {
2283:../FreeRTOS/Source/tasks.c ****                             xAlreadyYielded = pdTRUE;
2284:../FreeRTOS/Source/tasks.c ****                         }
2285:../FreeRTOS/Source/tasks.c ****                     #endif
2286:../FreeRTOS/Source/tasks.c ****                     taskYIELD_IF_USING_PREEMPTION();
2287:../FreeRTOS/Source/tasks.c ****                 }
2288:../FreeRTOS/Source/tasks.c ****                 else
2289:../FreeRTOS/Source/tasks.c ****                 {
2290:../FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
2291:../FreeRTOS/Source/tasks.c ****                 }
2292:../FreeRTOS/Source/tasks.c ****             }
2293:../FreeRTOS/Source/tasks.c ****         }
2294:../FreeRTOS/Source/tasks.c ****         else
2295:../FreeRTOS/Source/tasks.c ****         {
2296:../FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
2297:../FreeRTOS/Source/tasks.c ****         }
2298:../FreeRTOS/Source/tasks.c ****     }
2299:../FreeRTOS/Source/tasks.c ****     taskEXIT_CRITICAL();
2300:../FreeRTOS/Source/tasks.c **** 
2301:../FreeRTOS/Source/tasks.c ****     return xAlreadyYielded;
2302:../FreeRTOS/Source/tasks.c **** }
2303:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2304:../FreeRTOS/Source/tasks.c **** 
2305:../FreeRTOS/Source/tasks.c **** TickType_t xTaskGetTickCount( void )
2306:../FreeRTOS/Source/tasks.c **** {
2307:../FreeRTOS/Source/tasks.c ****     TickType_t xTicks;
2308:../FreeRTOS/Source/tasks.c **** 
2309:../FreeRTOS/Source/tasks.c ****     /* Critical section required if running on a 16 bit processor. */
2310:../FreeRTOS/Source/tasks.c ****     portTICK_TYPE_ENTER_CRITICAL();
2311:../FreeRTOS/Source/tasks.c ****     {
2312:../FreeRTOS/Source/tasks.c ****         xTicks = xTickCount;
2313:../FreeRTOS/Source/tasks.c ****     }
2314:../FreeRTOS/Source/tasks.c ****     portTICK_TYPE_EXIT_CRITICAL();
2315:../FreeRTOS/Source/tasks.c **** 
2316:../FreeRTOS/Source/tasks.c ****     return xTicks;
2317:../FreeRTOS/Source/tasks.c **** }
2318:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2319:../FreeRTOS/Source/tasks.c **** 
2320:../FreeRTOS/Source/tasks.c **** TickType_t xTaskGetTickCountFromISR( void )
2321:../FreeRTOS/Source/tasks.c **** {
2322:../FreeRTOS/Source/tasks.c ****     TickType_t xReturn;
2323:../FreeRTOS/Source/tasks.c ****     UBaseType_t uxSavedInterruptStatus;
2324:../FreeRTOS/Source/tasks.c **** 
2325:../FreeRTOS/Source/tasks.c ****     /* RTOS ports that support interrupt nesting have the concept of a maximum
2326:../FreeRTOS/Source/tasks.c ****      * system call (or maximum API call) interrupt priority.  Interrupts that are
2327:../FreeRTOS/Source/tasks.c ****      * above the maximum system call priority are kept permanently enabled, even
2328:../FreeRTOS/Source/tasks.c ****      * when the RTOS kernel is in a critical section, but cannot make any calls to
2329:../FreeRTOS/Source/tasks.c ****      * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
2330:../FreeRTOS/Source/tasks.c ****      * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
2331:../FreeRTOS/Source/tasks.c ****      * failure if a FreeRTOS API function is called from an interrupt that has been
2332:../FreeRTOS/Source/tasks.c ****      * assigned a priority above the configured maximum system call priority.
2333:../FreeRTOS/Source/tasks.c ****      * Only FreeRTOS functions that end in FromISR can be called from interrupts
2334:../FreeRTOS/Source/tasks.c ****      * that have been assigned a priority at or (logically) below the maximum
2335:../FreeRTOS/Source/tasks.c ****      * system call  interrupt priority.  FreeRTOS maintains a separate interrupt
2336:../FreeRTOS/Source/tasks.c ****      * safe API to ensure interrupt entry is as fast and as simple as possible.
2337:../FreeRTOS/Source/tasks.c ****      * More information (albeit Cortex-M specific) is provided on the following
2338:../FreeRTOS/Source/tasks.c ****      * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
2339:../FreeRTOS/Source/tasks.c ****     portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
2340:../FreeRTOS/Source/tasks.c **** 
2341:../FreeRTOS/Source/tasks.c ****     uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
2342:../FreeRTOS/Source/tasks.c ****     {
2343:../FreeRTOS/Source/tasks.c ****         xReturn = xTickCount;
2344:../FreeRTOS/Source/tasks.c ****     }
2345:../FreeRTOS/Source/tasks.c ****     portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
2346:../FreeRTOS/Source/tasks.c **** 
2347:../FreeRTOS/Source/tasks.c ****     return xReturn;
2348:../FreeRTOS/Source/tasks.c **** }
2349:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2350:../FreeRTOS/Source/tasks.c **** 
2351:../FreeRTOS/Source/tasks.c **** UBaseType_t uxTaskGetNumberOfTasks( void )
2352:../FreeRTOS/Source/tasks.c **** {
2353:../FreeRTOS/Source/tasks.c ****     /* A critical section is not required because the variables are of type
2354:../FreeRTOS/Source/tasks.c ****      * BaseType_t. */
2355:../FreeRTOS/Source/tasks.c ****     return uxCurrentNumberOfTasks;
2356:../FreeRTOS/Source/tasks.c **** }
2357:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2358:../FreeRTOS/Source/tasks.c **** 
2359:../FreeRTOS/Source/tasks.c **** char * pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed f
2360:../FreeRTOS/Source/tasks.c **** {
2361:../FreeRTOS/Source/tasks.c ****     TCB_t * pxTCB;
2362:../FreeRTOS/Source/tasks.c **** 
2363:../FreeRTOS/Source/tasks.c ****     /* If null is passed in here then the name of the calling task is being
2364:../FreeRTOS/Source/tasks.c ****      * queried. */
2365:../FreeRTOS/Source/tasks.c ****     pxTCB = prvGetTCBFromHandle( xTaskToQuery );
2366:../FreeRTOS/Source/tasks.c ****     configASSERT( pxTCB );
2367:../FreeRTOS/Source/tasks.c ****     return &( pxTCB->pcTaskName[ 0 ] );
2368:../FreeRTOS/Source/tasks.c **** }
2369:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2370:../FreeRTOS/Source/tasks.c **** 
2371:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
2372:../FreeRTOS/Source/tasks.c **** 
2373:../FreeRTOS/Source/tasks.c ****     static TCB_t * prvSearchForNameWithinSingleList( List_t * pxList,
2374:../FreeRTOS/Source/tasks.c ****                                                      const char pcNameToQuery[] )
2375:../FreeRTOS/Source/tasks.c ****     {
2376:../FreeRTOS/Source/tasks.c ****         TCB_t * pxNextTCB, * pxFirstTCB, * pxReturn = NULL;
2377:../FreeRTOS/Source/tasks.c ****         UBaseType_t x;
2378:../FreeRTOS/Source/tasks.c ****         char cNextChar;
2379:../FreeRTOS/Source/tasks.c ****         BaseType_t xBreakLoop;
2380:../FreeRTOS/Source/tasks.c **** 
2381:../FreeRTOS/Source/tasks.c ****         /* This function is called with the scheduler suspended. */
2382:../FreeRTOS/Source/tasks.c **** 
2383:../FreeRTOS/Source/tasks.c ****         if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
2384:../FreeRTOS/Source/tasks.c ****         {
2385:../FreeRTOS/Source/tasks.c ****             listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this
2386:../FreeRTOS/Source/tasks.c **** 
2387:../FreeRTOS/Source/tasks.c ****             do
2388:../FreeRTOS/Source/tasks.c ****             {
2389:../FreeRTOS/Source/tasks.c ****                 listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as t
2390:../FreeRTOS/Source/tasks.c **** 
2391:../FreeRTOS/Source/tasks.c ****                 /* Check each character in the name looking for a match or
2392:../FreeRTOS/Source/tasks.c ****                  * mismatch. */
2393:../FreeRTOS/Source/tasks.c ****                 xBreakLoop = pdFALSE;
2394:../FreeRTOS/Source/tasks.c **** 
2395:../FreeRTOS/Source/tasks.c ****                 for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
2396:../FreeRTOS/Source/tasks.c ****                 {
2397:../FreeRTOS/Source/tasks.c ****                     cNextChar = pxNextTCB->pcTaskName[ x ];
2398:../FreeRTOS/Source/tasks.c **** 
2399:../FreeRTOS/Source/tasks.c ****                     if( cNextChar != pcNameToQuery[ x ] )
2400:../FreeRTOS/Source/tasks.c ****                     {
2401:../FreeRTOS/Source/tasks.c ****                         /* Characters didn't match. */
2402:../FreeRTOS/Source/tasks.c ****                         xBreakLoop = pdTRUE;
2403:../FreeRTOS/Source/tasks.c ****                     }
2404:../FreeRTOS/Source/tasks.c ****                     else if( cNextChar == ( char ) 0x00 )
2405:../FreeRTOS/Source/tasks.c ****                     {
2406:../FreeRTOS/Source/tasks.c ****                         /* Both strings terminated, a match must have been
2407:../FreeRTOS/Source/tasks.c ****                          * found. */
2408:../FreeRTOS/Source/tasks.c ****                         pxReturn = pxNextTCB;
2409:../FreeRTOS/Source/tasks.c ****                         xBreakLoop = pdTRUE;
2410:../FreeRTOS/Source/tasks.c ****                     }
2411:../FreeRTOS/Source/tasks.c ****                     else
2412:../FreeRTOS/Source/tasks.c ****                     {
2413:../FreeRTOS/Source/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
2414:../FreeRTOS/Source/tasks.c ****                     }
2415:../FreeRTOS/Source/tasks.c **** 
2416:../FreeRTOS/Source/tasks.c ****                     if( xBreakLoop != pdFALSE )
2417:../FreeRTOS/Source/tasks.c ****                     {
2418:../FreeRTOS/Source/tasks.c ****                         break;
2419:../FreeRTOS/Source/tasks.c ****                     }
2420:../FreeRTOS/Source/tasks.c ****                 }
2421:../FreeRTOS/Source/tasks.c **** 
2422:../FreeRTOS/Source/tasks.c ****                 if( pxReturn != NULL )
2423:../FreeRTOS/Source/tasks.c ****                 {
2424:../FreeRTOS/Source/tasks.c ****                     /* The handle has been found. */
2425:../FreeRTOS/Source/tasks.c ****                     break;
2426:../FreeRTOS/Source/tasks.c ****                 }
2427:../FreeRTOS/Source/tasks.c ****             } while( pxNextTCB != pxFirstTCB );
2428:../FreeRTOS/Source/tasks.c ****         }
2429:../FreeRTOS/Source/tasks.c ****         else
2430:../FreeRTOS/Source/tasks.c ****         {
2431:../FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
2432:../FreeRTOS/Source/tasks.c ****         }
2433:../FreeRTOS/Source/tasks.c **** 
2434:../FreeRTOS/Source/tasks.c ****         return pxReturn;
2435:../FreeRTOS/Source/tasks.c ****     }
2436:../FreeRTOS/Source/tasks.c **** 
2437:../FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_xTaskGetHandle */
2438:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2439:../FreeRTOS/Source/tasks.c **** 
2440:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
2441:../FreeRTOS/Source/tasks.c **** 
2442:../FreeRTOS/Source/tasks.c ****     TaskHandle_t xTaskGetHandle( const char * pcNameToQuery ) /*lint !e971 Unqualified char types a
2443:../FreeRTOS/Source/tasks.c ****     {
2444:../FreeRTOS/Source/tasks.c ****         UBaseType_t uxQueue = configMAX_PRIORITIES;
2445:../FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
2446:../FreeRTOS/Source/tasks.c **** 
2447:../FreeRTOS/Source/tasks.c ****         /* Task names will be truncated to configMAX_TASK_NAME_LEN - 1 bytes. */
2448:../FreeRTOS/Source/tasks.c ****         configASSERT( strlen( pcNameToQuery ) < configMAX_TASK_NAME_LEN );
2449:../FreeRTOS/Source/tasks.c **** 
2450:../FreeRTOS/Source/tasks.c ****         vTaskSuspendAll();
2451:../FreeRTOS/Source/tasks.c ****         {
2452:../FreeRTOS/Source/tasks.c ****             /* Search the ready lists. */
2453:../FreeRTOS/Source/tasks.c ****             do
2454:../FreeRTOS/Source/tasks.c ****             {
2455:../FreeRTOS/Source/tasks.c ****                 uxQueue--;
2456:../FreeRTOS/Source/tasks.c ****                 pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) &( pxReadyTasksLists[ uxQueu
2457:../FreeRTOS/Source/tasks.c **** 
2458:../FreeRTOS/Source/tasks.c ****                 if( pxTCB != NULL )
2459:../FreeRTOS/Source/tasks.c ****                 {
2460:../FreeRTOS/Source/tasks.c ****                     /* Found the handle. */
2461:../FreeRTOS/Source/tasks.c ****                     break;
2462:../FreeRTOS/Source/tasks.c ****                 }
2463:../FreeRTOS/Source/tasks.c ****             } while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as 
2464:../FreeRTOS/Source/tasks.c **** 
2465:../FreeRTOS/Source/tasks.c ****             /* Search the delayed lists. */
2466:../FreeRTOS/Source/tasks.c ****             if( pxTCB == NULL )
2467:../FreeRTOS/Source/tasks.c ****             {
2468:../FreeRTOS/Source/tasks.c ****                 pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxDelayedTaskList, pcNameToQ
2469:../FreeRTOS/Source/tasks.c ****             }
2470:../FreeRTOS/Source/tasks.c **** 
2471:../FreeRTOS/Source/tasks.c ****             if( pxTCB == NULL )
2472:../FreeRTOS/Source/tasks.c ****             {
2473:../FreeRTOS/Source/tasks.c ****                 pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxOverflowDelayedTaskList, p
2474:../FreeRTOS/Source/tasks.c ****             }
2475:../FreeRTOS/Source/tasks.c **** 
2476:../FreeRTOS/Source/tasks.c ****             #if ( INCLUDE_vTaskSuspend == 1 )
2477:../FreeRTOS/Source/tasks.c ****                 {
2478:../FreeRTOS/Source/tasks.c ****                     if( pxTCB == NULL )
2479:../FreeRTOS/Source/tasks.c ****                     {
2480:../FreeRTOS/Source/tasks.c ****                         /* Search the suspended list. */
2481:../FreeRTOS/Source/tasks.c ****                         pxTCB = prvSearchForNameWithinSingleList( &xSuspendedTaskList, pcNameToQuer
2482:../FreeRTOS/Source/tasks.c ****                     }
2483:../FreeRTOS/Source/tasks.c ****                 }
2484:../FreeRTOS/Source/tasks.c ****             #endif
2485:../FreeRTOS/Source/tasks.c **** 
2486:../FreeRTOS/Source/tasks.c ****             #if ( INCLUDE_vTaskDelete == 1 )
2487:../FreeRTOS/Source/tasks.c ****                 {
2488:../FreeRTOS/Source/tasks.c ****                     if( pxTCB == NULL )
2489:../FreeRTOS/Source/tasks.c ****                     {
2490:../FreeRTOS/Source/tasks.c ****                         /* Search the deleted list. */
2491:../FreeRTOS/Source/tasks.c ****                         pxTCB = prvSearchForNameWithinSingleList( &xTasksWaitingTermination, pcName
2492:../FreeRTOS/Source/tasks.c ****                     }
2493:../FreeRTOS/Source/tasks.c ****                 }
2494:../FreeRTOS/Source/tasks.c ****             #endif
2495:../FreeRTOS/Source/tasks.c ****         }
2496:../FreeRTOS/Source/tasks.c ****         ( void ) xTaskResumeAll();
2497:../FreeRTOS/Source/tasks.c **** 
2498:../FreeRTOS/Source/tasks.c ****         return pxTCB;
2499:../FreeRTOS/Source/tasks.c ****     }
2500:../FreeRTOS/Source/tasks.c **** 
2501:../FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_xTaskGetHandle */
2502:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2503:../FreeRTOS/Source/tasks.c **** 
2504:../FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2505:../FreeRTOS/Source/tasks.c **** 
2506:../FreeRTOS/Source/tasks.c ****     UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray,
2507:../FreeRTOS/Source/tasks.c ****                                       const UBaseType_t uxArraySize,
2508:../FreeRTOS/Source/tasks.c ****                                       uint32_t * const pulTotalRunTime )
2509:../FreeRTOS/Source/tasks.c ****     {
2510:../FreeRTOS/Source/tasks.c ****         UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
2511:../FreeRTOS/Source/tasks.c **** 
2512:../FreeRTOS/Source/tasks.c ****         vTaskSuspendAll();
2513:../FreeRTOS/Source/tasks.c ****         {
2514:../FreeRTOS/Source/tasks.c ****             /* Is there a space in the array for each task in the system? */
2515:../FreeRTOS/Source/tasks.c ****             if( uxArraySize >= uxCurrentNumberOfTasks )
2516:../FreeRTOS/Source/tasks.c ****             {
2517:../FreeRTOS/Source/tasks.c ****                 /* Fill in an TaskStatus_t structure with information on each
2518:../FreeRTOS/Source/tasks.c ****                  * task in the Ready state. */
2519:../FreeRTOS/Source/tasks.c ****                 do
2520:../FreeRTOS/Source/tasks.c ****                 {
2521:../FreeRTOS/Source/tasks.c ****                     uxQueue--;
2522:../FreeRTOS/Source/tasks.c ****                     uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( px
2523:../FreeRTOS/Source/tasks.c ****                 } while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception
2524:../FreeRTOS/Source/tasks.c **** 
2525:../FreeRTOS/Source/tasks.c ****                 /* Fill in an TaskStatus_t structure with information on each
2526:../FreeRTOS/Source/tasks.c ****                  * task in the Blocked state. */
2527:../FreeRTOS/Source/tasks.c ****                 uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t 
2528:../FreeRTOS/Source/tasks.c ****                 uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t 
2529:../FreeRTOS/Source/tasks.c **** 
2530:../FreeRTOS/Source/tasks.c ****                 #if ( INCLUDE_vTaskDelete == 1 )
2531:../FreeRTOS/Source/tasks.c ****                     {
2532:../FreeRTOS/Source/tasks.c ****                         /* Fill in an TaskStatus_t structure with information on
2533:../FreeRTOS/Source/tasks.c ****                          * each task that has been deleted but not yet cleaned up. */
2534:../FreeRTOS/Source/tasks.c ****                         uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &
2535:../FreeRTOS/Source/tasks.c ****                     }
2536:../FreeRTOS/Source/tasks.c ****                 #endif
2537:../FreeRTOS/Source/tasks.c **** 
2538:../FreeRTOS/Source/tasks.c ****                 #if ( INCLUDE_vTaskSuspend == 1 )
2539:../FreeRTOS/Source/tasks.c ****                     {
2540:../FreeRTOS/Source/tasks.c ****                         /* Fill in an TaskStatus_t structure with information on
2541:../FreeRTOS/Source/tasks.c ****                          * each task in the Suspended state. */
2542:../FreeRTOS/Source/tasks.c ****                         uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &
2543:../FreeRTOS/Source/tasks.c ****                     }
2544:../FreeRTOS/Source/tasks.c ****                 #endif
2545:../FreeRTOS/Source/tasks.c **** 
2546:../FreeRTOS/Source/tasks.c ****                 #if ( configGENERATE_RUN_TIME_STATS == 1 )
2547:../FreeRTOS/Source/tasks.c ****                     {
2548:../FreeRTOS/Source/tasks.c ****                         if( pulTotalRunTime != NULL )
2549:../FreeRTOS/Source/tasks.c ****                         {
2550:../FreeRTOS/Source/tasks.c ****                             #ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2551:../FreeRTOS/Source/tasks.c ****                                 portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
2552:../FreeRTOS/Source/tasks.c ****                             #else
2553:../FreeRTOS/Source/tasks.c ****                                 *pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2554:../FreeRTOS/Source/tasks.c ****                             #endif
2555:../FreeRTOS/Source/tasks.c ****                         }
2556:../FreeRTOS/Source/tasks.c ****                     }
2557:../FreeRTOS/Source/tasks.c ****                 #else /* if ( configGENERATE_RUN_TIME_STATS == 1 ) */
2558:../FreeRTOS/Source/tasks.c ****                     {
2559:../FreeRTOS/Source/tasks.c ****                         if( pulTotalRunTime != NULL )
2560:../FreeRTOS/Source/tasks.c ****                         {
2561:../FreeRTOS/Source/tasks.c ****                             *pulTotalRunTime = 0;
2562:../FreeRTOS/Source/tasks.c ****                         }
2563:../FreeRTOS/Source/tasks.c ****                     }
2564:../FreeRTOS/Source/tasks.c ****                 #endif /* if ( configGENERATE_RUN_TIME_STATS == 1 ) */
2565:../FreeRTOS/Source/tasks.c ****             }
2566:../FreeRTOS/Source/tasks.c ****             else
2567:../FreeRTOS/Source/tasks.c ****             {
2568:../FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
2569:../FreeRTOS/Source/tasks.c ****             }
2570:../FreeRTOS/Source/tasks.c ****         }
2571:../FreeRTOS/Source/tasks.c ****         ( void ) xTaskResumeAll();
2572:../FreeRTOS/Source/tasks.c **** 
2573:../FreeRTOS/Source/tasks.c ****         return uxTask;
2574:../FreeRTOS/Source/tasks.c ****     }
2575:../FreeRTOS/Source/tasks.c **** 
2576:../FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2577:../FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2578:../FreeRTOS/Source/tasks.c **** 
2579:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
2580:../FreeRTOS/Source/tasks.c **** 
2581:../FreeRTOS/Source/tasks.c ****     TaskHandle_t xTaskGetIdleTaskHandle( void )
2582:../FreeRTOS/Source/tasks.c ****     {
2583:../FreeRTOS/Source/tasks.c ****         /* If xTaskGetIdleTaskHandle() is called before the scheduler has been
2584:../FreeRTOS/Source/tasks.c ****          * started, then xIdleTaskHandle will be NULL. */
2585:../FreeRTOS/Source/tasks.c ****         configASSERT( ( xIdleTaskHandle != NULL ) );
2586:../FreeRTOS/Source/tasks.c ****         return xIdleTaskHandle;
2587:../FreeRTOS/Source/tasks.c ****     }
2588:../FreeRTOS/Source/tasks.c **** 
2589:../FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_xTaskGetIdleTaskHandle */
2590:../FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2591:../FreeRTOS/Source/tasks.c **** 
2592:../FreeRTOS/Source/tasks.c **** /* This conditional compilation should use inequality to 0, not equality to 1.
2593:../FreeRTOS/Source/tasks.c ****  * This is to ensure vTaskStepTick() is available when user defined low power mode
2594:../FreeRTOS/Source/tasks.c ****  * implementations require configUSE_TICKLESS_IDLE to be set to a value other than
2595:../FreeRTOS/Source/tasks.c ****  * 1. */
2596:../FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
2597:../FreeRTOS/Source/tasks.c **** 
2598:../FreeRTOS/Source/tasks.c ****     void vTaskStepTick( const TickType_t xTicksToJump )
2599:../FreeRTOS/Source/tasks.c ****     {
2600:../FreeRTOS/Source/tasks.c ****         /* Correct the tick count value after a period during which the tick
2601:../FreeRTOS/Source/tasks.c ****          * was suppressed.  Note this does *not* call the tick hook function for
2602:../FreeRTOS/Source/tasks.c ****          * each stepped tick. */
2603:../FreeRTOS/Source/tasks.c ****         configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
2604:../FreeRTOS/Source/tasks.c ****         xTickCount += xTicksToJump;
2605:../FreeRTOS/Source/tasks.c ****         traceINCREASE_TICK_COUNT( xTicksToJump );
2606:../FreeRTOS/Source/tasks.c ****     }
2607:../FreeRTOS/Source/tasks.c **** 
2608:../FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2609:../FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2610:../FreeRTOS/Source/tasks.c **** 
2611:../FreeRTOS/Source/tasks.c **** BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
2612:../FreeRTOS/Source/tasks.c **** {
2613:../FreeRTOS/Source/tasks.c ****     BaseType_t xYieldOccurred;
2614:../FreeRTOS/Source/tasks.c **** 
2615:../FreeRTOS/Source/tasks.c ****     /* Must not be called with the scheduler suspended as the implementation
2616:../FreeRTOS/Source/tasks.c ****      * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
2617:../FreeRTOS/Source/tasks.c ****     configASSERT( uxSchedulerSuspended == 0 );
2618:../FreeRTOS/Source/tasks.c **** 
2619:../FreeRTOS/Source/tasks.c ****     /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
2620:../FreeRTOS/Source/tasks.c ****      * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
2621:../FreeRTOS/Source/tasks.c ****     vTaskSuspendAll();
2622:../FreeRTOS/Source/tasks.c ****     xPendedTicks += xTicksToCatchUp;
2623:../FreeRTOS/Source/tasks.c ****     xYieldOccurred = xTaskResumeAll();
2624:../FreeRTOS/Source/tasks.c **** 
2625:../FreeRTOS/Source/tasks.c ****     return xYieldOccurred;
2626:../FreeRTOS/Source/tasks.c **** }
2627:../FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2628:../FreeRTOS/Source/tasks.c **** 
2629:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskAbortDelay == 1 )
2630:../FreeRTOS/Source/tasks.c **** 
2631:../FreeRTOS/Source/tasks.c ****     BaseType_t xTaskAbortDelay( TaskHandle_t xTask )
2632:../FreeRTOS/Source/tasks.c ****     {
2633:../FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB = xTask;
2634:../FreeRTOS/Source/tasks.c ****         BaseType_t xReturn;
2635:../FreeRTOS/Source/tasks.c **** 
2636:../FreeRTOS/Source/tasks.c ****         configASSERT( pxTCB );
2637:../FreeRTOS/Source/tasks.c **** 
2638:../FreeRTOS/Source/tasks.c ****         vTaskSuspendAll();
2639:../FreeRTOS/Source/tasks.c ****         {
2640:../FreeRTOS/Source/tasks.c ****             /* A task can only be prematurely removed from the Blocked state if
2641:../FreeRTOS/Source/tasks.c ****              * it is actually in the Blocked state. */
2642:../FreeRTOS/Source/tasks.c ****             if( eTaskGetState( xTask ) == eBlocked )
2643:../FreeRTOS/Source/tasks.c ****             {
2644:../FreeRTOS/Source/tasks.c ****                 xReturn = pdPASS;
2645:../FreeRTOS/Source/tasks.c **** 
2646:../FreeRTOS/Source/tasks.c ****                 /* Remove the reference to the task from the blocked list.  An
2647:../FreeRTOS/Source/tasks.c ****                  * interrupt won't touch the xStateListItem because the
2648:../FreeRTOS/Source/tasks.c ****                  * scheduler is suspended. */
2649:../FreeRTOS/Source/tasks.c ****                 ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2650:../FreeRTOS/Source/tasks.c **** 
2651:../FreeRTOS/Source/tasks.c ****                 /* Is the task waiting on an event also?  If so remove it from
2652:../FreeRTOS/Source/tasks.c ****                  * the event list too.  Interrupts can touch the event list item,
2653:../FreeRTOS/Source/tasks.c ****                  * even though the scheduler is suspended, so a critical section
2654:../FreeRTOS/Source/tasks.c ****                  * is used. */
2655:../FreeRTOS/Source/tasks.c ****                 taskENTER_CRITICAL();
2656:../FreeRTOS/Source/tasks.c ****                 {
2657:../FreeRTOS/Source/tasks.c ****                     if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
2658:../FreeRTOS/Source/tasks.c ****                     {
2659:../FreeRTOS/Source/tasks.c ****                         ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2660:../FreeRTOS/Source/tasks.c **** 
2661:../FreeRTOS/Source/tasks.c ****                         /* This lets the task know it was forcibly removed from the
2662:../FreeRTOS/Source/tasks.c ****                          * blocked state so it should not re-evaluate its block time and
2663:../FreeRTOS/Source/tasks.c ****                          * then block again. */
2664:../FreeRTOS/Source/tasks.c ****                         pxTCB->ucDelayAborted = pdTRUE;
2665:../FreeRTOS/Source/tasks.c ****                     }
2666:../FreeRTOS/Source/tasks.c ****                     else
2667:../FreeRTOS/Source/tasks.c ****                     {
2668:../FreeRTOS/Source/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
2669:../FreeRTOS/Source/tasks.c ****                     }
2670:../FreeRTOS/Source/tasks.c ****                 }
2671:../FreeRTOS/Source/tasks.c ****                 taskEXIT_CRITICAL();
2672:../FreeRTOS/Source/tasks.c **** 
2673:../FreeRTOS/Source/tasks.c ****                 /* Place the unblocked task into the appropriate ready list. */
2674:../FreeRTOS/Source/tasks.c ****                 prvAddTaskToReadyList( pxTCB );
2675:../FreeRTOS/Source/tasks.c **** 
2676:../FreeRTOS/Source/tasks.c ****                 /* A task being unblocked cannot cause an immediate context
2677:../FreeRTOS/Source/tasks.c ****                  * switch if preemption is turned off. */
2678:../FreeRTOS/Source/tasks.c ****                 #if ( configUSE_PREEMPTION == 1 )
2679:../FreeRTOS/Source/tasks.c ****                     {
2680:../FreeRTOS/Source/tasks.c ****                         /* Preemption is on, but a context switch should only be
2681:../FreeRTOS/Source/tasks.c ****                          *  performed if the unblocked task has a priority that is
2682:../FreeRTOS/Source/tasks.c ****                          *  equal to or higher than the currently executing task. */
2683:../FreeRTOS/Source/tasks.c ****                         if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
2684:../FreeRTOS/Source/tasks.c ****                         {
2685:../FreeRTOS/Source/tasks.c ****                             /* Pend the yield to be performed when the scheduler
2686:../FreeRTOS/Source/tasks.c ****                              * is unsuspended. */
2687:../FreeRTOS/Source/tasks.c ****                             xYieldPending = pdTRUE;
2688:../FreeRTOS/Source/tasks.c ****                         }
2689:../FreeRTOS/Source/tasks.c ****                         else
2690:../FreeRTOS/Source/tasks.c ****                         {
2691:../FreeRTOS/Source/tasks.c ****                             mtCOVERAGE_TEST_MARKER();
2692:../FreeRTOS/Source/tasks.c ****                         }
2693:../FreeRTOS/Source/tasks.c ****                     }
2694:../FreeRTOS/Source/tasks.c ****                 #endif /* configUSE_PREEMPTION */
2695:../FreeRTOS/Source/tasks.c ****             }
2696:../FreeRTOS/Source/tasks.c ****             else
2697:../FreeRTOS/Source/tasks.c ****             {
2698:../FreeRTOS/Source/tasks.c ****                 xReturn = pdFAIL;
2699:../FreeRTOS/Source/tasks.c ****             }
2700:../FreeRTOS/Source/tasks.c ****         }
2701:../FreeRTOS/Source/tasks.c ****         ( void ) xTaskResumeAll();
2702:../FreeRTOS/Source/tasks.c **** 
2703:../FreeRTOS/Source/tasks.c ****         return xReturn;
2704:../FreeRTOS/Source/tasks.c ****     }
2705:../FreeRTOS/Source/tasks.c **** 
2706:../FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_xTaskAbortDelay */
2707:../FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2708:../FreeRTOS/Source/tasks.c **** 
2709:../FreeRTOS/Source/tasks.c **** BaseType_t xTaskIncrementTick( void )
2710:../FreeRTOS/Source/tasks.c **** {
2711:../FreeRTOS/Source/tasks.c ****     TCB_t * pxTCB;
2712:../FreeRTOS/Source/tasks.c ****     TickType_t xItemValue;
2713:../FreeRTOS/Source/tasks.c ****     BaseType_t xSwitchRequired = pdFALSE;
2714:../FreeRTOS/Source/tasks.c **** 
2715:../FreeRTOS/Source/tasks.c ****     /* Called by the portable layer each time a tick interrupt occurs.
2716:../FreeRTOS/Source/tasks.c ****      * Increments the tick then checks to see if the new tick value will cause any
2717:../FreeRTOS/Source/tasks.c ****      * tasks to be unblocked. */
2718:../FreeRTOS/Source/tasks.c ****     traceTASK_INCREMENT_TICK( xTickCount );
2719:../FreeRTOS/Source/tasks.c **** 
2720:../FreeRTOS/Source/tasks.c ****     if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
2721:../FreeRTOS/Source/tasks.c ****     {
2722:../FreeRTOS/Source/tasks.c ****         /* Minor optimisation.  The tick count cannot change in this
2723:../FreeRTOS/Source/tasks.c ****          * block. */
2724:../FreeRTOS/Source/tasks.c ****         const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
2725:../FreeRTOS/Source/tasks.c **** 
2726:../FreeRTOS/Source/tasks.c ****         /* Increment the RTOS tick, switching the delayed and overflowed
2727:../FreeRTOS/Source/tasks.c ****          * delayed lists if it wraps to 0. */
2728:../FreeRTOS/Source/tasks.c ****         xTickCount = xConstTickCount;
2729:../FreeRTOS/Source/tasks.c **** 
2730:../FreeRTOS/Source/tasks.c ****         if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to fa
2731:../FreeRTOS/Source/tasks.c ****         {
2732:../FreeRTOS/Source/tasks.c ****             taskSWITCH_DELAYED_LISTS();
2733:../FreeRTOS/Source/tasks.c ****         }
2734:../FreeRTOS/Source/tasks.c ****         else
2735:../FreeRTOS/Source/tasks.c ****         {
2736:../FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
2737:../FreeRTOS/Source/tasks.c ****         }
2738:../FreeRTOS/Source/tasks.c **** 
2739:../FreeRTOS/Source/tasks.c ****         /* See if this tick has made a timeout expire.  Tasks are stored in
2740:../FreeRTOS/Source/tasks.c ****          * the  queue in the order of their wake time - meaning once one task
2741:../FreeRTOS/Source/tasks.c ****          * has been found whose block time has not expired there is no need to
2742:../FreeRTOS/Source/tasks.c ****          * look any further down the list. */
2743:../FreeRTOS/Source/tasks.c ****         if( xConstTickCount >= xNextTaskUnblockTime )
2744:../FreeRTOS/Source/tasks.c ****         {
2745:../FreeRTOS/Source/tasks.c ****             for( ; ; )
2746:../FreeRTOS/Source/tasks.c ****             {
2747:../FreeRTOS/Source/tasks.c ****                 if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
2748:../FreeRTOS/Source/tasks.c ****                 {
2749:../FreeRTOS/Source/tasks.c ****                     /* The delayed list is empty.  Set xNextTaskUnblockTime
2750:../FreeRTOS/Source/tasks.c ****                      * to the maximum possible value so it is extremely
2751:../FreeRTOS/Source/tasks.c ****                      * unlikely that the
2752:../FreeRTOS/Source/tasks.c ****                      * if( xTickCount >= xNextTaskUnblockTime ) test will pass
2753:../FreeRTOS/Source/tasks.c ****                      * next time through. */
2754:../FreeRTOS/Source/tasks.c ****                     xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts
2755:../FreeRTOS/Source/tasks.c ****                     break;
2756:../FreeRTOS/Source/tasks.c ****                 }
2757:../FreeRTOS/Source/tasks.c ****                 else
2758:../FreeRTOS/Source/tasks.c ****                 {
2759:../FreeRTOS/Source/tasks.c ****                     /* The delayed list is not empty, get the value of the
2760:../FreeRTOS/Source/tasks.c ****                      * item at the head of the delayed list.  This is the time
2761:../FreeRTOS/Source/tasks.c ****                      * at which the task at the head of the delayed list must
2762:../FreeRTOS/Source/tasks.c ****                      * be removed from the Blocked state. */
2763:../FreeRTOS/Source/tasks.c ****                     pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * 
2764:../FreeRTOS/Source/tasks.c ****                     xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
2765:../FreeRTOS/Source/tasks.c **** 
2766:../FreeRTOS/Source/tasks.c ****                     if( xConstTickCount < xItemValue )
2767:../FreeRTOS/Source/tasks.c ****                     {
2768:../FreeRTOS/Source/tasks.c ****                         /* It is not time to unblock this item yet, but the
2769:../FreeRTOS/Source/tasks.c ****                          * item value is the time at which the task at the head
2770:../FreeRTOS/Source/tasks.c ****                          * of the blocked list must be removed from the Blocked
2771:../FreeRTOS/Source/tasks.c ****                          * state -  so record the item value in
2772:../FreeRTOS/Source/tasks.c ****                          * xNextTaskUnblockTime. */
2773:../FreeRTOS/Source/tasks.c ****                         xNextTaskUnblockTime = xItemValue;
2774:../FreeRTOS/Source/tasks.c ****                         break; /*lint !e9011 Code structure here is deedmed easier to understand wi
2775:../FreeRTOS/Source/tasks.c ****                     }
2776:../FreeRTOS/Source/tasks.c ****                     else
2777:../FreeRTOS/Source/tasks.c ****                     {
2778:../FreeRTOS/Source/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
2779:../FreeRTOS/Source/tasks.c ****                     }
2780:../FreeRTOS/Source/tasks.c **** 
2781:../FreeRTOS/Source/tasks.c ****                     /* It is time to remove the item from the Blocked state. */
2782:../FreeRTOS/Source/tasks.c ****                     ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2783:../FreeRTOS/Source/tasks.c **** 
2784:../FreeRTOS/Source/tasks.c ****                     /* Is the task waiting on an event also?  If so remove
2785:../FreeRTOS/Source/tasks.c ****                      * it from the event list. */
2786:../FreeRTOS/Source/tasks.c ****                     if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
2787:../FreeRTOS/Source/tasks.c ****                     {
2788:../FreeRTOS/Source/tasks.c ****                         ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2789:../FreeRTOS/Source/tasks.c ****                     }
2790:../FreeRTOS/Source/tasks.c ****                     else
2791:../FreeRTOS/Source/tasks.c ****                     {
2792:../FreeRTOS/Source/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
2793:../FreeRTOS/Source/tasks.c ****                     }
2794:../FreeRTOS/Source/tasks.c **** 
2795:../FreeRTOS/Source/tasks.c ****                     /* Place the unblocked task into the appropriate ready
2796:../FreeRTOS/Source/tasks.c ****                      * list. */
2797:../FreeRTOS/Source/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
2798:../FreeRTOS/Source/tasks.c **** 
2799:../FreeRTOS/Source/tasks.c ****                     /* A task being unblocked cannot cause an immediate
2800:../FreeRTOS/Source/tasks.c ****                      * context switch if preemption is turned off. */
2801:../FreeRTOS/Source/tasks.c ****                     #if ( configUSE_PREEMPTION == 1 )
2802:../FreeRTOS/Source/tasks.c ****                         {
2803:../FreeRTOS/Source/tasks.c ****                             /* Preemption is on, but a context switch should
2804:../FreeRTOS/Source/tasks.c ****                              * only be performed if the unblocked task has a
2805:../FreeRTOS/Source/tasks.c ****                              * priority that is equal to or higher than the
2806:../FreeRTOS/Source/tasks.c ****                              * currently executing task. */
2807:../FreeRTOS/Source/tasks.c ****                             if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
2808:../FreeRTOS/Source/tasks.c ****                             {
2809:../FreeRTOS/Source/tasks.c ****                                 xSwitchRequired = pdTRUE;
2810:../FreeRTOS/Source/tasks.c ****                             }
2811:../FreeRTOS/Source/tasks.c ****                             else
2812:../FreeRTOS/Source/tasks.c ****                             {
2813:../FreeRTOS/Source/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
2814:../FreeRTOS/Source/tasks.c ****                             }
2815:../FreeRTOS/Source/tasks.c ****                         }
2816:../FreeRTOS/Source/tasks.c ****                     #endif /* configUSE_PREEMPTION */
2817:../FreeRTOS/Source/tasks.c ****                 }
2818:../FreeRTOS/Source/tasks.c ****             }
2819:../FreeRTOS/Source/tasks.c ****         }
2820:../FreeRTOS/Source/tasks.c **** 
2821:../FreeRTOS/Source/tasks.c ****         /* Tasks of equal priority to the currently running task will share
2822:../FreeRTOS/Source/tasks.c ****          * processing time (time slice) if preemption is on, and the application
2823:../FreeRTOS/Source/tasks.c ****          * writer has not explicitly turned time slicing off. */
2824:../FreeRTOS/Source/tasks.c ****         #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
2825:../FreeRTOS/Source/tasks.c ****             {
2826:../FreeRTOS/Source/tasks.c ****                 if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) >
2827:../FreeRTOS/Source/tasks.c ****                 {
2828:../FreeRTOS/Source/tasks.c ****                     xSwitchRequired = pdTRUE;
2829:../FreeRTOS/Source/tasks.c ****                 }
2830:../FreeRTOS/Source/tasks.c ****                 else
2831:../FreeRTOS/Source/tasks.c ****                 {
2832:../FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
2833:../FreeRTOS/Source/tasks.c ****                 }
2834:../FreeRTOS/Source/tasks.c ****             }
2835:../FreeRTOS/Source/tasks.c ****         #endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
2836:../FreeRTOS/Source/tasks.c **** 
2837:../FreeRTOS/Source/tasks.c ****         #if ( configUSE_TICK_HOOK == 1 )
2838:../FreeRTOS/Source/tasks.c ****             {
2839:../FreeRTOS/Source/tasks.c ****                 /* Guard against the tick hook being called when the pended tick
2840:../FreeRTOS/Source/tasks.c ****                  * count is being unwound (when the scheduler is being unlocked). */
2841:../FreeRTOS/Source/tasks.c ****                 if( xPendedTicks == ( TickType_t ) 0 )
2842:../FreeRTOS/Source/tasks.c ****                 {
2843:../FreeRTOS/Source/tasks.c ****                     vApplicationTickHook();
2844:../FreeRTOS/Source/tasks.c ****                 }
2845:../FreeRTOS/Source/tasks.c ****                 else
2846:../FreeRTOS/Source/tasks.c ****                 {
2847:../FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
2848:../FreeRTOS/Source/tasks.c ****                 }
2849:../FreeRTOS/Source/tasks.c ****             }
2850:../FreeRTOS/Source/tasks.c ****         #endif /* configUSE_TICK_HOOK */
2851:../FreeRTOS/Source/tasks.c **** 
2852:../FreeRTOS/Source/tasks.c ****         #if ( configUSE_PREEMPTION == 1 )
2853:../FreeRTOS/Source/tasks.c ****             {
2854:../FreeRTOS/Source/tasks.c ****                 if( xYieldPending != pdFALSE )
2855:../FreeRTOS/Source/tasks.c ****                 {
2856:../FreeRTOS/Source/tasks.c ****                     xSwitchRequired = pdTRUE;
2857:../FreeRTOS/Source/tasks.c ****                 }
2858:../FreeRTOS/Source/tasks.c ****                 else
2859:../FreeRTOS/Source/tasks.c ****                 {
2860:../FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
2861:../FreeRTOS/Source/tasks.c ****                 }
2862:../FreeRTOS/Source/tasks.c ****             }
2863:../FreeRTOS/Source/tasks.c ****         #endif /* configUSE_PREEMPTION */
2864:../FreeRTOS/Source/tasks.c ****     }
2865:../FreeRTOS/Source/tasks.c ****     else
2866:../FreeRTOS/Source/tasks.c ****     {
2867:../FreeRTOS/Source/tasks.c ****         ++xPendedTicks;
2868:../FreeRTOS/Source/tasks.c **** 
2869:../FreeRTOS/Source/tasks.c ****         /* The tick hook gets called at regular intervals, even if the
2870:../FreeRTOS/Source/tasks.c ****          * scheduler is locked. */
2871:../FreeRTOS/Source/tasks.c ****         #if ( configUSE_TICK_HOOK == 1 )
2872:../FreeRTOS/Source/tasks.c ****             {
2873:../FreeRTOS/Source/tasks.c ****                 vApplicationTickHook();
2874:../FreeRTOS/Source/tasks.c ****             }
2875:../FreeRTOS/Source/tasks.c ****         #endif
2876:../FreeRTOS/Source/tasks.c ****     }
2877:../FreeRTOS/Source/tasks.c **** 
2878:../FreeRTOS/Source/tasks.c ****     return xSwitchRequired;
2879:../FreeRTOS/Source/tasks.c **** }
2880:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2881:../FreeRTOS/Source/tasks.c **** 
2882:../FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2883:../FreeRTOS/Source/tasks.c **** 
2884:../FreeRTOS/Source/tasks.c ****     void vTaskSetApplicationTaskTag( TaskHandle_t xTask,
2885:../FreeRTOS/Source/tasks.c ****                                      TaskHookFunction_t pxHookFunction )
2886:../FreeRTOS/Source/tasks.c ****     {
2887:../FreeRTOS/Source/tasks.c ****         TCB_t * xTCB;
2888:../FreeRTOS/Source/tasks.c **** 
2889:../FreeRTOS/Source/tasks.c ****         /* If xTask is NULL then it is the task hook of the calling task that is
2890:../FreeRTOS/Source/tasks.c ****          * getting set. */
2891:../FreeRTOS/Source/tasks.c ****         if( xTask == NULL )
2892:../FreeRTOS/Source/tasks.c ****         {
2893:../FreeRTOS/Source/tasks.c ****             xTCB = ( TCB_t * ) pxCurrentTCB;
2894:../FreeRTOS/Source/tasks.c ****         }
2895:../FreeRTOS/Source/tasks.c ****         else
2896:../FreeRTOS/Source/tasks.c ****         {
2897:../FreeRTOS/Source/tasks.c ****             xTCB = xTask;
2898:../FreeRTOS/Source/tasks.c ****         }
2899:../FreeRTOS/Source/tasks.c **** 
2900:../FreeRTOS/Source/tasks.c ****         /* Save the hook function in the TCB.  A critical section is required as
2901:../FreeRTOS/Source/tasks.c ****          * the value can be accessed from an interrupt. */
2902:../FreeRTOS/Source/tasks.c ****         taskENTER_CRITICAL();
2903:../FreeRTOS/Source/tasks.c ****         {
2904:../FreeRTOS/Source/tasks.c ****             xTCB->pxTaskTag = pxHookFunction;
2905:../FreeRTOS/Source/tasks.c ****         }
2906:../FreeRTOS/Source/tasks.c ****         taskEXIT_CRITICAL();
2907:../FreeRTOS/Source/tasks.c ****     }
2908:../FreeRTOS/Source/tasks.c **** 
2909:../FreeRTOS/Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2910:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2911:../FreeRTOS/Source/tasks.c **** 
2912:../FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2913:../FreeRTOS/Source/tasks.c **** 
2914:../FreeRTOS/Source/tasks.c ****     TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
2915:../FreeRTOS/Source/tasks.c ****     {
2916:../FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
2917:../FreeRTOS/Source/tasks.c ****         TaskHookFunction_t xReturn;
2918:../FreeRTOS/Source/tasks.c **** 
2919:../FreeRTOS/Source/tasks.c ****         /* If xTask is NULL then set the calling task's hook. */
2920:../FreeRTOS/Source/tasks.c ****         pxTCB = prvGetTCBFromHandle( xTask );
2921:../FreeRTOS/Source/tasks.c **** 
2922:../FreeRTOS/Source/tasks.c ****         /* Save the hook function in the TCB.  A critical section is required as
2923:../FreeRTOS/Source/tasks.c ****          * the value can be accessed from an interrupt. */
2924:../FreeRTOS/Source/tasks.c ****         taskENTER_CRITICAL();
2925:../FreeRTOS/Source/tasks.c ****         {
2926:../FreeRTOS/Source/tasks.c ****             xReturn = pxTCB->pxTaskTag;
2927:../FreeRTOS/Source/tasks.c ****         }
2928:../FreeRTOS/Source/tasks.c ****         taskEXIT_CRITICAL();
2929:../FreeRTOS/Source/tasks.c **** 
2930:../FreeRTOS/Source/tasks.c ****         return xReturn;
2931:../FreeRTOS/Source/tasks.c ****     }
2932:../FreeRTOS/Source/tasks.c **** 
2933:../FreeRTOS/Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2934:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2935:../FreeRTOS/Source/tasks.c **** 
2936:../FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2937:../FreeRTOS/Source/tasks.c **** 
2938:../FreeRTOS/Source/tasks.c ****     TaskHookFunction_t xTaskGetApplicationTaskTagFromISR( TaskHandle_t xTask )
2939:../FreeRTOS/Source/tasks.c ****     {
2940:../FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
2941:../FreeRTOS/Source/tasks.c ****         TaskHookFunction_t xReturn;
2942:../FreeRTOS/Source/tasks.c ****         UBaseType_t uxSavedInterruptStatus;
2943:../FreeRTOS/Source/tasks.c **** 
2944:../FreeRTOS/Source/tasks.c ****         /* If xTask is NULL then set the calling task's hook. */
2945:../FreeRTOS/Source/tasks.c ****         pxTCB = prvGetTCBFromHandle( xTask );
2946:../FreeRTOS/Source/tasks.c **** 
2947:../FreeRTOS/Source/tasks.c ****         /* Save the hook function in the TCB.  A critical section is required as
2948:../FreeRTOS/Source/tasks.c ****          * the value can be accessed from an interrupt. */
2949:../FreeRTOS/Source/tasks.c ****         uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
2950:../FreeRTOS/Source/tasks.c ****         {
2951:../FreeRTOS/Source/tasks.c ****             xReturn = pxTCB->pxTaskTag;
2952:../FreeRTOS/Source/tasks.c ****         }
2953:../FreeRTOS/Source/tasks.c ****         portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
2954:../FreeRTOS/Source/tasks.c **** 
2955:../FreeRTOS/Source/tasks.c ****         return xReturn;
2956:../FreeRTOS/Source/tasks.c ****     }
2957:../FreeRTOS/Source/tasks.c **** 
2958:../FreeRTOS/Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2959:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2960:../FreeRTOS/Source/tasks.c **** 
2961:../FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2962:../FreeRTOS/Source/tasks.c **** 
2963:../FreeRTOS/Source/tasks.c ****     BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask,
2964:../FreeRTOS/Source/tasks.c ****                                              void * pvParameter )
2965:../FreeRTOS/Source/tasks.c ****     {
2966:../FreeRTOS/Source/tasks.c ****         TCB_t * xTCB;
2967:../FreeRTOS/Source/tasks.c ****         BaseType_t xReturn;
2968:../FreeRTOS/Source/tasks.c **** 
2969:../FreeRTOS/Source/tasks.c ****         /* If xTask is NULL then we are calling our own task hook. */
2970:../FreeRTOS/Source/tasks.c ****         if( xTask == NULL )
2971:../FreeRTOS/Source/tasks.c ****         {
2972:../FreeRTOS/Source/tasks.c ****             xTCB = pxCurrentTCB;
2973:../FreeRTOS/Source/tasks.c ****         }
2974:../FreeRTOS/Source/tasks.c ****         else
2975:../FreeRTOS/Source/tasks.c ****         {
2976:../FreeRTOS/Source/tasks.c ****             xTCB = xTask;
2977:../FreeRTOS/Source/tasks.c ****         }
2978:../FreeRTOS/Source/tasks.c **** 
2979:../FreeRTOS/Source/tasks.c ****         if( xTCB->pxTaskTag != NULL )
2980:../FreeRTOS/Source/tasks.c ****         {
2981:../FreeRTOS/Source/tasks.c ****             xReturn = xTCB->pxTaskTag( pvParameter );
2982:../FreeRTOS/Source/tasks.c ****         }
2983:../FreeRTOS/Source/tasks.c ****         else
2984:../FreeRTOS/Source/tasks.c ****         {
2985:../FreeRTOS/Source/tasks.c ****             xReturn = pdFAIL;
2986:../FreeRTOS/Source/tasks.c ****         }
2987:../FreeRTOS/Source/tasks.c **** 
2988:../FreeRTOS/Source/tasks.c ****         return xReturn;
2989:../FreeRTOS/Source/tasks.c ****     }
2990:../FreeRTOS/Source/tasks.c **** 
2991:../FreeRTOS/Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2992:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2993:../FreeRTOS/Source/tasks.c **** 
2994:../FreeRTOS/Source/tasks.c **** void vTaskSwitchContext( void )
2995:../FreeRTOS/Source/tasks.c **** {
2996:../FreeRTOS/Source/tasks.c ****     if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
2997:../FreeRTOS/Source/tasks.c ****     {
2998:../FreeRTOS/Source/tasks.c ****         /* The scheduler is currently suspended - do not allow a context
2999:../FreeRTOS/Source/tasks.c ****          * switch. */
3000:../FreeRTOS/Source/tasks.c ****         xYieldPending = pdTRUE;
3001:../FreeRTOS/Source/tasks.c ****     }
3002:../FreeRTOS/Source/tasks.c ****     else
3003:../FreeRTOS/Source/tasks.c ****     {
3004:../FreeRTOS/Source/tasks.c ****         xYieldPending = pdFALSE;
3005:../FreeRTOS/Source/tasks.c ****         traceTASK_SWITCHED_OUT();
3006:../FreeRTOS/Source/tasks.c **** 
3007:../FreeRTOS/Source/tasks.c ****         #if ( configGENERATE_RUN_TIME_STATS == 1 )
3008:../FreeRTOS/Source/tasks.c ****             {
3009:../FreeRTOS/Source/tasks.c ****                 #ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
3010:../FreeRTOS/Source/tasks.c ****                     portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
3011:../FreeRTOS/Source/tasks.c ****                 #else
3012:../FreeRTOS/Source/tasks.c ****                     ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
3013:../FreeRTOS/Source/tasks.c ****                 #endif
3014:../FreeRTOS/Source/tasks.c **** 
3015:../FreeRTOS/Source/tasks.c ****                 /* Add the amount of time the task has been running to the
3016:../FreeRTOS/Source/tasks.c ****                  * accumulated time so far.  The time the task started running was
3017:../FreeRTOS/Source/tasks.c ****                  * stored in ulTaskSwitchedInTime.  Note that there is no overflow
3018:../FreeRTOS/Source/tasks.c ****                  * protection here so count values are only valid until the timer
3019:../FreeRTOS/Source/tasks.c ****                  * overflows.  The guard against negative values is to protect
3020:../FreeRTOS/Source/tasks.c ****                  * against suspect run time stat counter implementations - which
3021:../FreeRTOS/Source/tasks.c ****                  * are provided by the application, not the kernel. */
3022:../FreeRTOS/Source/tasks.c ****                 if( ulTotalRunTime > ulTaskSwitchedInTime )
3023:../FreeRTOS/Source/tasks.c ****                 {
3024:../FreeRTOS/Source/tasks.c ****                     pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
3025:../FreeRTOS/Source/tasks.c ****                 }
3026:../FreeRTOS/Source/tasks.c ****                 else
3027:../FreeRTOS/Source/tasks.c ****                 {
3028:../FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
3029:../FreeRTOS/Source/tasks.c ****                 }
3030:../FreeRTOS/Source/tasks.c **** 
3031:../FreeRTOS/Source/tasks.c ****                 ulTaskSwitchedInTime = ulTotalRunTime;
3032:../FreeRTOS/Source/tasks.c ****             }
3033:../FreeRTOS/Source/tasks.c ****         #endif /* configGENERATE_RUN_TIME_STATS */
3034:../FreeRTOS/Source/tasks.c **** 
3035:../FreeRTOS/Source/tasks.c ****         /* Check for stack overflow, if configured. */
3036:../FreeRTOS/Source/tasks.c ****         taskCHECK_FOR_STACK_OVERFLOW();
3037:../FreeRTOS/Source/tasks.c **** 
3038:../FreeRTOS/Source/tasks.c ****         /* Before the currently running task is switched out, save its errno. */
3039:../FreeRTOS/Source/tasks.c ****         #if ( configUSE_POSIX_ERRNO == 1 )
3040:../FreeRTOS/Source/tasks.c ****             {
3041:../FreeRTOS/Source/tasks.c ****                 pxCurrentTCB->iTaskErrno = FreeRTOS_errno;
3042:../FreeRTOS/Source/tasks.c ****             }
3043:../FreeRTOS/Source/tasks.c ****         #endif
3044:../FreeRTOS/Source/tasks.c **** 
3045:../FreeRTOS/Source/tasks.c ****         /* Select a new task to run using either the generic C or port
3046:../FreeRTOS/Source/tasks.c ****          * optimised asm code. */
3047:../FreeRTOS/Source/tasks.c ****         taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with
3048:../FreeRTOS/Source/tasks.c ****         traceTASK_SWITCHED_IN();
3049:../FreeRTOS/Source/tasks.c **** 
3050:../FreeRTOS/Source/tasks.c ****         /* After the new task is switched in, update the global errno. */
3051:../FreeRTOS/Source/tasks.c ****         #if ( configUSE_POSIX_ERRNO == 1 )
3052:../FreeRTOS/Source/tasks.c ****             {
3053:../FreeRTOS/Source/tasks.c ****                 FreeRTOS_errno = pxCurrentTCB->iTaskErrno;
3054:../FreeRTOS/Source/tasks.c ****             }
3055:../FreeRTOS/Source/tasks.c ****         #endif
3056:../FreeRTOS/Source/tasks.c **** 
3057:../FreeRTOS/Source/tasks.c ****         #if ( configUSE_NEWLIB_REENTRANT == 1 )
3058:../FreeRTOS/Source/tasks.c ****             {
3059:../FreeRTOS/Source/tasks.c ****                 /* Switch Newlib's _impure_ptr variable to point to the _reent
3060:../FreeRTOS/Source/tasks.c ****                  * structure specific to this task.
3061:../FreeRTOS/Source/tasks.c ****                  * See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
3062:../FreeRTOS/Source/tasks.c ****                  * for additional information. */
3063:../FreeRTOS/Source/tasks.c ****                 _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
3064:../FreeRTOS/Source/tasks.c ****             }
3065:../FreeRTOS/Source/tasks.c ****         #endif /* configUSE_NEWLIB_REENTRANT */
3066:../FreeRTOS/Source/tasks.c ****     }
3067:../FreeRTOS/Source/tasks.c **** }
3068:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3069:../FreeRTOS/Source/tasks.c **** 
3070:../FreeRTOS/Source/tasks.c **** void vTaskPlaceOnEventList( List_t * const pxEventList,
3071:../FreeRTOS/Source/tasks.c ****                             const TickType_t xTicksToWait )
3072:../FreeRTOS/Source/tasks.c **** {
3073:../FreeRTOS/Source/tasks.c ****     configASSERT( pxEventList );
3074:../FreeRTOS/Source/tasks.c **** 
3075:../FreeRTOS/Source/tasks.c ****     /* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
3076:../FreeRTOS/Source/tasks.c ****      * SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
3077:../FreeRTOS/Source/tasks.c **** 
3078:../FreeRTOS/Source/tasks.c ****     /* Place the event list item of the TCB in the appropriate event list.
3079:../FreeRTOS/Source/tasks.c ****      * This is placed in the list in priority order so the highest priority task
3080:../FreeRTOS/Source/tasks.c ****      * is the first to be woken by the event.  The queue that contains the event
3081:../FreeRTOS/Source/tasks.c ****      * list is locked, preventing simultaneous access from interrupts. */
3082:../FreeRTOS/Source/tasks.c ****     vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
3083:../FreeRTOS/Source/tasks.c **** 
3084:../FreeRTOS/Source/tasks.c ****     prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
3085:../FreeRTOS/Source/tasks.c **** }
3086:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3087:../FreeRTOS/Source/tasks.c **** 
3088:../FreeRTOS/Source/tasks.c **** void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
3089:../FreeRTOS/Source/tasks.c ****                                      const TickType_t xItemValue,
3090:../FreeRTOS/Source/tasks.c ****                                      const TickType_t xTicksToWait )
3091:../FreeRTOS/Source/tasks.c **** {
3092:../FreeRTOS/Source/tasks.c ****     configASSERT( pxEventList );
3093:../FreeRTOS/Source/tasks.c **** 
3094:../FreeRTOS/Source/tasks.c ****     /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
3095:../FreeRTOS/Source/tasks.c ****      * the event groups implementation. */
3096:../FreeRTOS/Source/tasks.c ****     configASSERT( uxSchedulerSuspended != 0 );
3097:../FreeRTOS/Source/tasks.c **** 
3098:../FreeRTOS/Source/tasks.c ****     /* Store the item value in the event list item.  It is safe to access the
3099:../FreeRTOS/Source/tasks.c ****      * event list item here as interrupts won't access the event list item of a
3100:../FreeRTOS/Source/tasks.c ****      * task that is not in the Blocked state. */
3101:../FreeRTOS/Source/tasks.c ****     listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VA
3102:../FreeRTOS/Source/tasks.c **** 
3103:../FreeRTOS/Source/tasks.c ****     /* Place the event list item of the TCB at the end of the appropriate event
3104:../FreeRTOS/Source/tasks.c ****      * list.  It is safe to access the event list here because it is part of an
3105:../FreeRTOS/Source/tasks.c ****      * event group implementation - and interrupts don't access event groups
3106:../FreeRTOS/Source/tasks.c ****      * directly (instead they access them indirectly by pending function calls to
3107:../FreeRTOS/Source/tasks.c ****      * the task level). */
3108:../FreeRTOS/Source/tasks.c ****     vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
3109:../FreeRTOS/Source/tasks.c **** 
3110:../FreeRTOS/Source/tasks.c ****     prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
3111:../FreeRTOS/Source/tasks.c **** }
3112:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3113:../FreeRTOS/Source/tasks.c **** 
3114:../FreeRTOS/Source/tasks.c **** #if ( configUSE_TIMERS == 1 )
3115:../FreeRTOS/Source/tasks.c **** 
3116:../FreeRTOS/Source/tasks.c ****     void vTaskPlaceOnEventListRestricted( List_t * const pxEventList,
3117:../FreeRTOS/Source/tasks.c ****                                           TickType_t xTicksToWait,
3118:../FreeRTOS/Source/tasks.c ****                                           const BaseType_t xWaitIndefinitely )
3119:../FreeRTOS/Source/tasks.c ****     {
3120:../FreeRTOS/Source/tasks.c ****         configASSERT( pxEventList );
3121:../FreeRTOS/Source/tasks.c **** 
3122:../FreeRTOS/Source/tasks.c ****         /* This function should not be called by application code hence the
3123:../FreeRTOS/Source/tasks.c ****          * 'Restricted' in its name.  It is not part of the public API.  It is
3124:../FreeRTOS/Source/tasks.c ****          * designed for use by kernel code, and has special calling requirements -
3125:../FreeRTOS/Source/tasks.c ****          * it should be called with the scheduler suspended. */
3126:../FreeRTOS/Source/tasks.c **** 
3127:../FreeRTOS/Source/tasks.c **** 
3128:../FreeRTOS/Source/tasks.c ****         /* Place the event list item of the TCB in the appropriate event list.
3129:../FreeRTOS/Source/tasks.c ****          * In this case it is assume that this is the only task that is going to
3130:../FreeRTOS/Source/tasks.c ****          * be waiting on this event list, so the faster vListInsertEnd() function
3131:../FreeRTOS/Source/tasks.c ****          * can be used in place of vListInsert. */
3132:../FreeRTOS/Source/tasks.c ****         vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
3133:../FreeRTOS/Source/tasks.c **** 
3134:../FreeRTOS/Source/tasks.c ****         /* If the task should block indefinitely then set the block time to a
3135:../FreeRTOS/Source/tasks.c ****          * value that will be recognised as an indefinite delay inside the
3136:../FreeRTOS/Source/tasks.c ****          * prvAddCurrentTaskToDelayedList() function. */
3137:../FreeRTOS/Source/tasks.c ****         if( xWaitIndefinitely != pdFALSE )
3138:../FreeRTOS/Source/tasks.c ****         {
3139:../FreeRTOS/Source/tasks.c ****             xTicksToWait = portMAX_DELAY;
3140:../FreeRTOS/Source/tasks.c ****         }
3141:../FreeRTOS/Source/tasks.c **** 
3142:../FreeRTOS/Source/tasks.c ****         traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
3143:../FreeRTOS/Source/tasks.c ****         prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
3144:../FreeRTOS/Source/tasks.c ****     }
3145:../FreeRTOS/Source/tasks.c **** 
3146:../FreeRTOS/Source/tasks.c **** #endif /* configUSE_TIMERS */
3147:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3148:../FreeRTOS/Source/tasks.c **** 
3149:../FreeRTOS/Source/tasks.c **** BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
3150:../FreeRTOS/Source/tasks.c **** {
3151:../FreeRTOS/Source/tasks.c ****     TCB_t * pxUnblockedTCB;
3152:../FreeRTOS/Source/tasks.c ****     BaseType_t xReturn;
3153:../FreeRTOS/Source/tasks.c **** 
3154:../FreeRTOS/Source/tasks.c ****     /* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
3155:../FreeRTOS/Source/tasks.c ****      * called from a critical section within an ISR. */
3156:../FreeRTOS/Source/tasks.c **** 
3157:../FreeRTOS/Source/tasks.c ****     /* The event list is sorted in priority order, so the first in the list can
3158:../FreeRTOS/Source/tasks.c ****      * be removed as it is known to be the highest priority.  Remove the TCB from
3159:../FreeRTOS/Source/tasks.c ****      * the delayed list, and add it to the ready list.
3160:../FreeRTOS/Source/tasks.c ****      *
3161:../FreeRTOS/Source/tasks.c ****      * If an event is for a queue that is locked then this function will never
3162:../FreeRTOS/Source/tasks.c ****      * get called - the lock count on the queue will get modified instead.  This
3163:../FreeRTOS/Source/tasks.c ****      * means exclusive access to the event list is guaranteed here.
3164:../FreeRTOS/Source/tasks.c ****      *
3165:../FreeRTOS/Source/tasks.c ****      * This function assumes that a check has already been made to ensure that
3166:../FreeRTOS/Source/tasks.c ****      * pxEventList is not empty. */
3167:../FreeRTOS/Source/tasks.c ****     pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as th
3168:../FreeRTOS/Source/tasks.c ****     configASSERT( pxUnblockedTCB );
3169:../FreeRTOS/Source/tasks.c ****     ( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
3170:../FreeRTOS/Source/tasks.c **** 
3171:../FreeRTOS/Source/tasks.c ****     if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
3172:../FreeRTOS/Source/tasks.c ****     {
3173:../FreeRTOS/Source/tasks.c ****         ( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
3174:../FreeRTOS/Source/tasks.c ****         prvAddTaskToReadyList( pxUnblockedTCB );
3175:../FreeRTOS/Source/tasks.c **** 
3176:../FreeRTOS/Source/tasks.c ****         #if ( configUSE_TICKLESS_IDLE != 0 )
3177:../FreeRTOS/Source/tasks.c ****             {
3178:../FreeRTOS/Source/tasks.c ****                 /* If a task is blocked on a kernel object then xNextTaskUnblockTime
3179:../FreeRTOS/Source/tasks.c ****                  * might be set to the blocked task's time out time.  If the task is
3180:../FreeRTOS/Source/tasks.c ****                  * unblocked for a reason other than a timeout xNextTaskUnblockTime is
3181:../FreeRTOS/Source/tasks.c ****                  * normally left unchanged, because it is automatically reset to a new
3182:../FreeRTOS/Source/tasks.c ****                  * value when the tick count equals xNextTaskUnblockTime.  However if
3183:../FreeRTOS/Source/tasks.c ****                  * tickless idling is used it might be more important to enter sleep mode
3184:../FreeRTOS/Source/tasks.c ****                  * at the earliest possible time - so reset xNextTaskUnblockTime here to
3185:../FreeRTOS/Source/tasks.c ****                  * ensure it is updated at the earliest possible time. */
3186:../FreeRTOS/Source/tasks.c ****                 prvResetNextTaskUnblockTime();
3187:../FreeRTOS/Source/tasks.c ****             }
3188:../FreeRTOS/Source/tasks.c ****         #endif
3189:../FreeRTOS/Source/tasks.c ****     }
3190:../FreeRTOS/Source/tasks.c ****     else
3191:../FreeRTOS/Source/tasks.c ****     {
3192:../FreeRTOS/Source/tasks.c ****         /* The delayed and ready lists cannot be accessed, so hold this task
3193:../FreeRTOS/Source/tasks.c ****          * pending until the scheduler is resumed. */
3194:../FreeRTOS/Source/tasks.c ****         vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
3195:../FreeRTOS/Source/tasks.c ****     }
3196:../FreeRTOS/Source/tasks.c **** 
3197:../FreeRTOS/Source/tasks.c ****     if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
3198:../FreeRTOS/Source/tasks.c ****     {
3199:../FreeRTOS/Source/tasks.c ****         /* Return true if the task removed from the event list has a higher
3200:../FreeRTOS/Source/tasks.c ****          * priority than the calling task.  This allows the calling task to know if
3201:../FreeRTOS/Source/tasks.c ****          * it should force a context switch now. */
3202:../FreeRTOS/Source/tasks.c ****         xReturn = pdTRUE;
3203:../FreeRTOS/Source/tasks.c **** 
3204:../FreeRTOS/Source/tasks.c ****         /* Mark that a yield is pending in case the user is not using the
3205:../FreeRTOS/Source/tasks.c ****          * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
3206:../FreeRTOS/Source/tasks.c ****         xYieldPending = pdTRUE;
3207:../FreeRTOS/Source/tasks.c ****     }
3208:../FreeRTOS/Source/tasks.c ****     else
3209:../FreeRTOS/Source/tasks.c ****     {
3210:../FreeRTOS/Source/tasks.c ****         xReturn = pdFALSE;
3211:../FreeRTOS/Source/tasks.c ****     }
3212:../FreeRTOS/Source/tasks.c **** 
3213:../FreeRTOS/Source/tasks.c ****     return xReturn;
3214:../FreeRTOS/Source/tasks.c **** }
3215:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3216:../FreeRTOS/Source/tasks.c **** 
3217:../FreeRTOS/Source/tasks.c **** void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
3218:../FreeRTOS/Source/tasks.c ****                                         const TickType_t xItemValue )
3219:../FreeRTOS/Source/tasks.c **** {
3220:../FreeRTOS/Source/tasks.c ****     TCB_t * pxUnblockedTCB;
3221:../FreeRTOS/Source/tasks.c **** 
3222:../FreeRTOS/Source/tasks.c ****     /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
3223:../FreeRTOS/Source/tasks.c ****      * the event flags implementation. */
3224:../FreeRTOS/Source/tasks.c ****     configASSERT( uxSchedulerSuspended != pdFALSE );
3225:../FreeRTOS/Source/tasks.c **** 
3226:../FreeRTOS/Source/tasks.c ****     /* Store the new item value in the event list. */
3227:../FreeRTOS/Source/tasks.c ****     listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
3228:../FreeRTOS/Source/tasks.c **** 
3229:../FreeRTOS/Source/tasks.c ****     /* Remove the event list form the event flag.  Interrupts do not access
3230:../FreeRTOS/Source/tasks.c ****      * event flags. */
3231:../FreeRTOS/Source/tasks.c ****     pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as th
3232:../FreeRTOS/Source/tasks.c ****     configASSERT( pxUnblockedTCB );
3233:../FreeRTOS/Source/tasks.c ****     ( void ) uxListRemove( pxEventListItem );
3234:../FreeRTOS/Source/tasks.c **** 
3235:../FreeRTOS/Source/tasks.c ****     #if ( configUSE_TICKLESS_IDLE != 0 )
3236:../FreeRTOS/Source/tasks.c ****         {
3237:../FreeRTOS/Source/tasks.c ****             /* If a task is blocked on a kernel object then xNextTaskUnblockTime
3238:../FreeRTOS/Source/tasks.c ****              * might be set to the blocked task's time out time.  If the task is
3239:../FreeRTOS/Source/tasks.c ****              * unblocked for a reason other than a timeout xNextTaskUnblockTime is
3240:../FreeRTOS/Source/tasks.c ****              * normally left unchanged, because it is automatically reset to a new
3241:../FreeRTOS/Source/tasks.c ****              * value when the tick count equals xNextTaskUnblockTime.  However if
3242:../FreeRTOS/Source/tasks.c ****              * tickless idling is used it might be more important to enter sleep mode
3243:../FreeRTOS/Source/tasks.c ****              * at the earliest possible time - so reset xNextTaskUnblockTime here to
3244:../FreeRTOS/Source/tasks.c ****              * ensure it is updated at the earliest possible time. */
3245:../FreeRTOS/Source/tasks.c ****             prvResetNextTaskUnblockTime();
3246:../FreeRTOS/Source/tasks.c ****         }
3247:../FreeRTOS/Source/tasks.c ****     #endif
3248:../FreeRTOS/Source/tasks.c **** 
3249:../FreeRTOS/Source/tasks.c ****     /* Remove the task from the delayed list and add it to the ready list.  The
3250:../FreeRTOS/Source/tasks.c ****      * scheduler is suspended so interrupts will not be accessing the ready
3251:../FreeRTOS/Source/tasks.c ****      * lists. */
3252:../FreeRTOS/Source/tasks.c ****     ( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
3253:../FreeRTOS/Source/tasks.c ****     prvAddTaskToReadyList( pxUnblockedTCB );
3254:../FreeRTOS/Source/tasks.c **** 
3255:../FreeRTOS/Source/tasks.c ****     if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
3256:../FreeRTOS/Source/tasks.c ****     {
3257:../FreeRTOS/Source/tasks.c ****         /* The unblocked task has a priority above that of the calling task, so
3258:../FreeRTOS/Source/tasks.c ****          * a context switch is required.  This function is called with the
3259:../FreeRTOS/Source/tasks.c ****          * scheduler suspended so xYieldPending is set so the context switch
3260:../FreeRTOS/Source/tasks.c ****          * occurs immediately that the scheduler is resumed (unsuspended). */
3261:../FreeRTOS/Source/tasks.c ****         xYieldPending = pdTRUE;
3262:../FreeRTOS/Source/tasks.c ****     }
3263:../FreeRTOS/Source/tasks.c **** }
3264:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3265:../FreeRTOS/Source/tasks.c **** 
3266:../FreeRTOS/Source/tasks.c **** void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
3267:../FreeRTOS/Source/tasks.c **** {
3268:../FreeRTOS/Source/tasks.c ****     configASSERT( pxTimeOut );
3269:../FreeRTOS/Source/tasks.c ****     taskENTER_CRITICAL();
3270:../FreeRTOS/Source/tasks.c ****     {
3271:../FreeRTOS/Source/tasks.c ****         pxTimeOut->xOverflowCount = xNumOfOverflows;
3272:../FreeRTOS/Source/tasks.c ****         pxTimeOut->xTimeOnEntering = xTickCount;
3273:../FreeRTOS/Source/tasks.c ****     }
3274:../FreeRTOS/Source/tasks.c ****     taskEXIT_CRITICAL();
3275:../FreeRTOS/Source/tasks.c **** }
3276:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3277:../FreeRTOS/Source/tasks.c **** 
3278:../FreeRTOS/Source/tasks.c **** void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
3279:../FreeRTOS/Source/tasks.c **** {
3280:../FreeRTOS/Source/tasks.c ****     /* For internal use only as it does not use a critical section. */
3281:../FreeRTOS/Source/tasks.c ****     pxTimeOut->xOverflowCount = xNumOfOverflows;
3282:../FreeRTOS/Source/tasks.c ****     pxTimeOut->xTimeOnEntering = xTickCount;
3283:../FreeRTOS/Source/tasks.c **** }
3284:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3285:../FreeRTOS/Source/tasks.c **** 
3286:../FreeRTOS/Source/tasks.c **** BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
3287:../FreeRTOS/Source/tasks.c ****                                  TickType_t * const pxTicksToWait )
3288:../FreeRTOS/Source/tasks.c **** {
3289:../FreeRTOS/Source/tasks.c ****     BaseType_t xReturn;
3290:../FreeRTOS/Source/tasks.c **** 
3291:../FreeRTOS/Source/tasks.c ****     configASSERT( pxTimeOut );
3292:../FreeRTOS/Source/tasks.c ****     configASSERT( pxTicksToWait );
3293:../FreeRTOS/Source/tasks.c **** 
3294:../FreeRTOS/Source/tasks.c ****     taskENTER_CRITICAL();
3295:../FreeRTOS/Source/tasks.c ****     {
3296:../FreeRTOS/Source/tasks.c ****         /* Minor optimisation.  The tick count cannot change in this block. */
3297:../FreeRTOS/Source/tasks.c ****         const TickType_t xConstTickCount = xTickCount;
3298:../FreeRTOS/Source/tasks.c ****         const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
3299:../FreeRTOS/Source/tasks.c **** 
3300:../FreeRTOS/Source/tasks.c ****         #if ( INCLUDE_xTaskAbortDelay == 1 )
3301:../FreeRTOS/Source/tasks.c ****             if( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE )
3302:../FreeRTOS/Source/tasks.c ****             {
3303:../FreeRTOS/Source/tasks.c ****                 /* The delay was aborted, which is not the same as a time out,
3304:../FreeRTOS/Source/tasks.c ****                  * but has the same result. */
3305:../FreeRTOS/Source/tasks.c ****                 pxCurrentTCB->ucDelayAborted = pdFALSE;
3306:../FreeRTOS/Source/tasks.c ****                 xReturn = pdTRUE;
3307:../FreeRTOS/Source/tasks.c ****             }
3308:../FreeRTOS/Source/tasks.c ****             else
3309:../FreeRTOS/Source/tasks.c ****         #endif
3310:../FreeRTOS/Source/tasks.c **** 
3311:../FreeRTOS/Source/tasks.c ****         #if ( INCLUDE_vTaskSuspend == 1 )
3312:../FreeRTOS/Source/tasks.c ****             if( *pxTicksToWait == portMAX_DELAY )
3313:../FreeRTOS/Source/tasks.c ****             {
3314:../FreeRTOS/Source/tasks.c ****                 /* If INCLUDE_vTaskSuspend is set to 1 and the block time
3315:../FreeRTOS/Source/tasks.c ****                  * specified is the maximum block time then the task should block
3316:../FreeRTOS/Source/tasks.c ****                  * indefinitely, and therefore never time out. */
3317:../FreeRTOS/Source/tasks.c ****                 xReturn = pdFALSE;
3318:../FreeRTOS/Source/tasks.c ****             }
3319:../FreeRTOS/Source/tasks.c ****             else
3320:../FreeRTOS/Source/tasks.c ****         #endif
3321:../FreeRTOS/Source/tasks.c **** 
3322:../FreeRTOS/Source/tasks.c ****         if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTi
3323:../FreeRTOS/Source/tasks.c ****         {
3324:../FreeRTOS/Source/tasks.c ****             /* The tick count is greater than the time at which
3325:../FreeRTOS/Source/tasks.c ****              * vTaskSetTimeout() was called, but has also overflowed since
3326:../FreeRTOS/Source/tasks.c ****              * vTaskSetTimeOut() was called.  It must have wrapped all the way
3327:../FreeRTOS/Source/tasks.c ****              * around and gone past again. This passed since vTaskSetTimeout()
3328:../FreeRTOS/Source/tasks.c ****              * was called. */
3329:../FreeRTOS/Source/tasks.c ****             xReturn = pdTRUE;
3330:../FreeRTOS/Source/tasks.c ****             *pxTicksToWait = ( TickType_t ) 0;
3331:../FreeRTOS/Source/tasks.c ****         }
3332:../FreeRTOS/Source/tasks.c ****         else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant wi
3333:../FreeRTOS/Source/tasks.c ****         {
3334:../FreeRTOS/Source/tasks.c ****             /* Not a genuine timeout. Adjust parameters for time remaining. */
3335:../FreeRTOS/Source/tasks.c ****             *pxTicksToWait -= xElapsedTime;
3336:../FreeRTOS/Source/tasks.c ****             vTaskInternalSetTimeOutState( pxTimeOut );
3337:../FreeRTOS/Source/tasks.c ****             xReturn = pdFALSE;
3338:../FreeRTOS/Source/tasks.c ****         }
3339:../FreeRTOS/Source/tasks.c ****         else
3340:../FreeRTOS/Source/tasks.c ****         {
3341:../FreeRTOS/Source/tasks.c ****             *pxTicksToWait = ( TickType_t ) 0;
3342:../FreeRTOS/Source/tasks.c ****             xReturn = pdTRUE;
3343:../FreeRTOS/Source/tasks.c ****         }
3344:../FreeRTOS/Source/tasks.c ****     }
3345:../FreeRTOS/Source/tasks.c ****     taskEXIT_CRITICAL();
3346:../FreeRTOS/Source/tasks.c **** 
3347:../FreeRTOS/Source/tasks.c ****     return xReturn;
3348:../FreeRTOS/Source/tasks.c **** }
3349:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3350:../FreeRTOS/Source/tasks.c **** 
3351:../FreeRTOS/Source/tasks.c **** void vTaskMissedYield( void )
3352:../FreeRTOS/Source/tasks.c **** {
3353:../FreeRTOS/Source/tasks.c ****     xYieldPending = pdTRUE;
3354:../FreeRTOS/Source/tasks.c **** }
3355:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3356:../FreeRTOS/Source/tasks.c **** 
3357:../FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3358:../FreeRTOS/Source/tasks.c **** 
3359:../FreeRTOS/Source/tasks.c ****     UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
3360:../FreeRTOS/Source/tasks.c ****     {
3361:../FreeRTOS/Source/tasks.c ****         UBaseType_t uxReturn;
3362:../FreeRTOS/Source/tasks.c ****         TCB_t const * pxTCB;
3363:../FreeRTOS/Source/tasks.c **** 
3364:../FreeRTOS/Source/tasks.c ****         if( xTask != NULL )
3365:../FreeRTOS/Source/tasks.c ****         {
3366:../FreeRTOS/Source/tasks.c ****             pxTCB = xTask;
3367:../FreeRTOS/Source/tasks.c ****             uxReturn = pxTCB->uxTaskNumber;
3368:../FreeRTOS/Source/tasks.c ****         }
3369:../FreeRTOS/Source/tasks.c ****         else
3370:../FreeRTOS/Source/tasks.c ****         {
3371:../FreeRTOS/Source/tasks.c ****             uxReturn = 0U;
3372:../FreeRTOS/Source/tasks.c ****         }
3373:../FreeRTOS/Source/tasks.c **** 
3374:../FreeRTOS/Source/tasks.c ****         return uxReturn;
3375:../FreeRTOS/Source/tasks.c ****     }
3376:../FreeRTOS/Source/tasks.c **** 
3377:../FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3378:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3379:../FreeRTOS/Source/tasks.c **** 
3380:../FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3381:../FreeRTOS/Source/tasks.c **** 
3382:../FreeRTOS/Source/tasks.c ****     void vTaskSetTaskNumber( TaskHandle_t xTask,
3383:../FreeRTOS/Source/tasks.c ****                              const UBaseType_t uxHandle )
3384:../FreeRTOS/Source/tasks.c ****     {
3385:../FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
3386:../FreeRTOS/Source/tasks.c **** 
3387:../FreeRTOS/Source/tasks.c ****         if( xTask != NULL )
3388:../FreeRTOS/Source/tasks.c ****         {
3389:../FreeRTOS/Source/tasks.c ****             pxTCB = xTask;
3390:../FreeRTOS/Source/tasks.c ****             pxTCB->uxTaskNumber = uxHandle;
3391:../FreeRTOS/Source/tasks.c ****         }
3392:../FreeRTOS/Source/tasks.c ****     }
3393:../FreeRTOS/Source/tasks.c **** 
3394:../FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3395:../FreeRTOS/Source/tasks.c **** 
3396:../FreeRTOS/Source/tasks.c **** /*
3397:../FreeRTOS/Source/tasks.c ****  * -----------------------------------------------------------
3398:../FreeRTOS/Source/tasks.c ****  * The Idle task.
3399:../FreeRTOS/Source/tasks.c ****  * ----------------------------------------------------------
3400:../FreeRTOS/Source/tasks.c ****  *
3401:../FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
3402:../FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
3403:../FreeRTOS/Source/tasks.c ****  *
3404:../FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
3405:../FreeRTOS/Source/tasks.c ****  *
3406:../FreeRTOS/Source/tasks.c ****  */
3407:../FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
3408:../FreeRTOS/Source/tasks.c **** {
3409:../FreeRTOS/Source/tasks.c ****     /* Stop warnings. */
3410:../FreeRTOS/Source/tasks.c ****     ( void ) pvParameters;
3411:../FreeRTOS/Source/tasks.c **** 
3412:../FreeRTOS/Source/tasks.c ****     /** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
3413:../FreeRTOS/Source/tasks.c ****      * SCHEDULER IS STARTED. **/
3414:../FreeRTOS/Source/tasks.c **** 
3415:../FreeRTOS/Source/tasks.c ****     /* In case a task that has a secure context deletes itself, in which case
3416:../FreeRTOS/Source/tasks.c ****      * the idle task is responsible for deleting the task's secure context, if
3417:../FreeRTOS/Source/tasks.c ****      * any. */
3418:../FreeRTOS/Source/tasks.c ****     portALLOCATE_SECURE_CONTEXT( configMINIMAL_SECURE_STACK_SIZE );
3419:../FreeRTOS/Source/tasks.c **** 
3420:../FreeRTOS/Source/tasks.c ****     for( ; ; )
3421:../FreeRTOS/Source/tasks.c ****     {
3422:../FreeRTOS/Source/tasks.c ****         /* See if any tasks have deleted themselves - if so then the idle task
3423:../FreeRTOS/Source/tasks.c ****          * is responsible for freeing the deleted task's TCB and stack. */
3424:../FreeRTOS/Source/tasks.c ****         prvCheckTasksWaitingTermination();
3425:../FreeRTOS/Source/tasks.c **** 
3426:../FreeRTOS/Source/tasks.c ****         #if ( configUSE_PREEMPTION == 0 )
3427:../FreeRTOS/Source/tasks.c ****             {
3428:../FreeRTOS/Source/tasks.c ****                 /* If we are not using preemption we keep forcing a task switch to
3429:../FreeRTOS/Source/tasks.c ****                  * see if any other task has become available.  If we are using
3430:../FreeRTOS/Source/tasks.c ****                  * preemption we don't need to do this as any task becoming available
3431:../FreeRTOS/Source/tasks.c ****                  * will automatically get the processor anyway. */
3432:../FreeRTOS/Source/tasks.c ****                 taskYIELD();
3433:../FreeRTOS/Source/tasks.c ****             }
3434:../FreeRTOS/Source/tasks.c ****         #endif /* configUSE_PREEMPTION */
3435:../FreeRTOS/Source/tasks.c **** 
3436:../FreeRTOS/Source/tasks.c ****         #if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
3437:../FreeRTOS/Source/tasks.c ****             {
3438:../FreeRTOS/Source/tasks.c ****                 /* When using preemption tasks of equal priority will be
3439:../FreeRTOS/Source/tasks.c ****                  * timesliced.  If a task that is sharing the idle priority is ready
3440:../FreeRTOS/Source/tasks.c ****                  * to run then the idle task should yield before the end of the
3441:../FreeRTOS/Source/tasks.c ****                  * timeslice.
3442:../FreeRTOS/Source/tasks.c ****                  *
3443:../FreeRTOS/Source/tasks.c ****                  * A critical region is not required here as we are just reading from
3444:../FreeRTOS/Source/tasks.c ****                  * the list, and an occasional incorrect value will not matter.  If
3445:../FreeRTOS/Source/tasks.c ****                  * the ready list at the idle priority contains more than one task
3446:../FreeRTOS/Source/tasks.c ****                  * then a task other than the idle task is ready to execute. */
3447:../FreeRTOS/Source/tasks.c ****                 if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBase
3448:../FreeRTOS/Source/tasks.c ****                 {
3449:../FreeRTOS/Source/tasks.c ****                     taskYIELD();
3450:../FreeRTOS/Source/tasks.c ****                 }
3451:../FreeRTOS/Source/tasks.c ****                 else
3452:../FreeRTOS/Source/tasks.c ****                 {
3453:../FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
3454:../FreeRTOS/Source/tasks.c ****                 }
3455:../FreeRTOS/Source/tasks.c ****             }
3456:../FreeRTOS/Source/tasks.c ****         #endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
3457:../FreeRTOS/Source/tasks.c **** 
3458:../FreeRTOS/Source/tasks.c ****         #if ( configUSE_IDLE_HOOK == 1 )
3459:../FreeRTOS/Source/tasks.c ****             {
3460:../FreeRTOS/Source/tasks.c ****                 extern void vApplicationIdleHook( void );
3461:../FreeRTOS/Source/tasks.c **** 
3462:../FreeRTOS/Source/tasks.c ****                 /* Call the user defined function from within the idle task.  This
3463:../FreeRTOS/Source/tasks.c ****                  * allows the application designer to add background functionality
3464:../FreeRTOS/Source/tasks.c ****                  * without the overhead of a separate task.
3465:../FreeRTOS/Source/tasks.c ****                  * NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
3466:../FreeRTOS/Source/tasks.c ****                  * CALL A FUNCTION THAT MIGHT BLOCK. */
3467:../FreeRTOS/Source/tasks.c ****                 vApplicationIdleHook();
3468:../FreeRTOS/Source/tasks.c ****             }
3469:../FreeRTOS/Source/tasks.c ****         #endif /* configUSE_IDLE_HOOK */
3470:../FreeRTOS/Source/tasks.c **** 
3471:../FreeRTOS/Source/tasks.c ****         /* This conditional compilation should use inequality to 0, not equality
3472:../FreeRTOS/Source/tasks.c ****          * to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
3473:../FreeRTOS/Source/tasks.c ****          * user defined low power mode  implementations require
3474:../FreeRTOS/Source/tasks.c ****          * configUSE_TICKLESS_IDLE to be set to a value other than 1. */
3475:../FreeRTOS/Source/tasks.c ****         #if ( configUSE_TICKLESS_IDLE != 0 )
3476:../FreeRTOS/Source/tasks.c ****             {
3477:../FreeRTOS/Source/tasks.c ****                 TickType_t xExpectedIdleTime;
3478:../FreeRTOS/Source/tasks.c **** 
3479:../FreeRTOS/Source/tasks.c ****                 /* It is not desirable to suspend then resume the scheduler on
3480:../FreeRTOS/Source/tasks.c ****                  * each iteration of the idle task.  Therefore, a preliminary
3481:../FreeRTOS/Source/tasks.c ****                  * test of the expected idle time is performed without the
3482:../FreeRTOS/Source/tasks.c ****                  * scheduler suspended.  The result here is not necessarily
3483:../FreeRTOS/Source/tasks.c ****                  * valid. */
3484:../FreeRTOS/Source/tasks.c ****                 xExpectedIdleTime = prvGetExpectedIdleTime();
3485:../FreeRTOS/Source/tasks.c **** 
3486:../FreeRTOS/Source/tasks.c ****                 if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3487:../FreeRTOS/Source/tasks.c ****                 {
3488:../FreeRTOS/Source/tasks.c ****                     vTaskSuspendAll();
3489:../FreeRTOS/Source/tasks.c ****                     {
3490:../FreeRTOS/Source/tasks.c ****                         /* Now the scheduler is suspended, the expected idle
3491:../FreeRTOS/Source/tasks.c ****                          * time can be sampled again, and this time its value can
3492:../FreeRTOS/Source/tasks.c ****                          * be used. */
3493:../FreeRTOS/Source/tasks.c ****                         configASSERT( xNextTaskUnblockTime >= xTickCount );
3494:../FreeRTOS/Source/tasks.c ****                         xExpectedIdleTime = prvGetExpectedIdleTime();
3495:../FreeRTOS/Source/tasks.c **** 
3496:../FreeRTOS/Source/tasks.c ****                         /* Define the following macro to set xExpectedIdleTime to 0
3497:../FreeRTOS/Source/tasks.c ****                          * if the application does not want
3498:../FreeRTOS/Source/tasks.c ****                          * portSUPPRESS_TICKS_AND_SLEEP() to be called. */
3499:../FreeRTOS/Source/tasks.c ****                         configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( xExpectedIdleTime );
3500:../FreeRTOS/Source/tasks.c **** 
3501:../FreeRTOS/Source/tasks.c ****                         if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3502:../FreeRTOS/Source/tasks.c ****                         {
3503:../FreeRTOS/Source/tasks.c ****                             traceLOW_POWER_IDLE_BEGIN();
3504:../FreeRTOS/Source/tasks.c ****                             portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
3505:../FreeRTOS/Source/tasks.c ****                             traceLOW_POWER_IDLE_END();
3506:../FreeRTOS/Source/tasks.c ****                         }
3507:../FreeRTOS/Source/tasks.c ****                         else
3508:../FreeRTOS/Source/tasks.c ****                         {
3509:../FreeRTOS/Source/tasks.c ****                             mtCOVERAGE_TEST_MARKER();
3510:../FreeRTOS/Source/tasks.c ****                         }
3511:../FreeRTOS/Source/tasks.c ****                     }
3512:../FreeRTOS/Source/tasks.c ****                     ( void ) xTaskResumeAll();
3513:../FreeRTOS/Source/tasks.c ****                 }
3514:../FreeRTOS/Source/tasks.c ****                 else
3515:../FreeRTOS/Source/tasks.c ****                 {
3516:../FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
3517:../FreeRTOS/Source/tasks.c ****                 }
3518:../FreeRTOS/Source/tasks.c ****             }
3519:../FreeRTOS/Source/tasks.c ****         #endif /* configUSE_TICKLESS_IDLE */
3520:../FreeRTOS/Source/tasks.c ****     }
3521:../FreeRTOS/Source/tasks.c **** }
3522:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3523:../FreeRTOS/Source/tasks.c **** 
3524:../FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
3525:../FreeRTOS/Source/tasks.c **** 
3526:../FreeRTOS/Source/tasks.c ****     eSleepModeStatus eTaskConfirmSleepModeStatus( void )
3527:../FreeRTOS/Source/tasks.c ****     {
3528:../FreeRTOS/Source/tasks.c ****         /* The idle task exists in addition to the application tasks. */
3529:../FreeRTOS/Source/tasks.c ****         const UBaseType_t uxNonApplicationTasks = 1;
3530:../FreeRTOS/Source/tasks.c ****         eSleepModeStatus eReturn = eStandardSleep;
3531:../FreeRTOS/Source/tasks.c **** 
3532:../FreeRTOS/Source/tasks.c ****         /* This function must be called from a critical section. */
3533:../FreeRTOS/Source/tasks.c **** 
3534:../FreeRTOS/Source/tasks.c ****         if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
3535:../FreeRTOS/Source/tasks.c ****         {
3536:../FreeRTOS/Source/tasks.c ****             /* A task was made ready while the scheduler was suspended. */
3537:../FreeRTOS/Source/tasks.c ****             eReturn = eAbortSleep;
3538:../FreeRTOS/Source/tasks.c ****         }
3539:../FreeRTOS/Source/tasks.c ****         else if( xYieldPending != pdFALSE )
3540:../FreeRTOS/Source/tasks.c ****         {
3541:../FreeRTOS/Source/tasks.c ****             /* A yield was pended while the scheduler was suspended. */
3542:../FreeRTOS/Source/tasks.c ****             eReturn = eAbortSleep;
3543:../FreeRTOS/Source/tasks.c ****         }
3544:../FreeRTOS/Source/tasks.c ****         else if( xPendedTicks != 0 )
3545:../FreeRTOS/Source/tasks.c ****         {
3546:../FreeRTOS/Source/tasks.c ****             /* A tick interrupt has already occurred but was held pending
3547:../FreeRTOS/Source/tasks.c ****              * because the scheduler is suspended. */
3548:../FreeRTOS/Source/tasks.c ****             eReturn = eAbortSleep;
3549:../FreeRTOS/Source/tasks.c ****         }
3550:../FreeRTOS/Source/tasks.c ****         else
3551:../FreeRTOS/Source/tasks.c ****         {
3552:../FreeRTOS/Source/tasks.c ****             /* If all the tasks are in the suspended list (which might mean they
3553:../FreeRTOS/Source/tasks.c ****              * have an infinite block time rather than actually being suspended)
3554:../FreeRTOS/Source/tasks.c ****              * then it is safe to turn all clocks off and just wait for external
3555:../FreeRTOS/Source/tasks.c ****              * interrupts. */
3556:../FreeRTOS/Source/tasks.c ****             if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonA
3557:../FreeRTOS/Source/tasks.c ****             {
3558:../FreeRTOS/Source/tasks.c ****                 eReturn = eNoTasksWaitingTimeout;
3559:../FreeRTOS/Source/tasks.c ****             }
3560:../FreeRTOS/Source/tasks.c ****             else
3561:../FreeRTOS/Source/tasks.c ****             {
3562:../FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
3563:../FreeRTOS/Source/tasks.c ****             }
3564:../FreeRTOS/Source/tasks.c ****         }
3565:../FreeRTOS/Source/tasks.c **** 
3566:../FreeRTOS/Source/tasks.c ****         return eReturn;
3567:../FreeRTOS/Source/tasks.c ****     }
3568:../FreeRTOS/Source/tasks.c **** 
3569:../FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
3570:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3571:../FreeRTOS/Source/tasks.c **** 
3572:../FreeRTOS/Source/tasks.c **** #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3573:../FreeRTOS/Source/tasks.c **** 
3574:../FreeRTOS/Source/tasks.c ****     void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet,
3575:../FreeRTOS/Source/tasks.c ****                                             BaseType_t xIndex,
3576:../FreeRTOS/Source/tasks.c ****                                             void * pvValue )
3577:../FreeRTOS/Source/tasks.c ****     {
3578:../FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
3579:../FreeRTOS/Source/tasks.c **** 
3580:../FreeRTOS/Source/tasks.c ****         if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
3581:../FreeRTOS/Source/tasks.c ****         {
3582:../FreeRTOS/Source/tasks.c ****             pxTCB = prvGetTCBFromHandle( xTaskToSet );
3583:../FreeRTOS/Source/tasks.c ****             configASSERT( pxTCB != NULL );
3584:../FreeRTOS/Source/tasks.c ****             pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
3585:../FreeRTOS/Source/tasks.c ****         }
3586:../FreeRTOS/Source/tasks.c ****     }
3587:../FreeRTOS/Source/tasks.c **** 
3588:../FreeRTOS/Source/tasks.c **** #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3589:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3590:../FreeRTOS/Source/tasks.c **** 
3591:../FreeRTOS/Source/tasks.c **** #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3592:../FreeRTOS/Source/tasks.c **** 
3593:../FreeRTOS/Source/tasks.c ****     void * pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery,
3594:../FreeRTOS/Source/tasks.c ****                                                BaseType_t xIndex )
3595:../FreeRTOS/Source/tasks.c ****     {
3596:../FreeRTOS/Source/tasks.c ****         void * pvReturn = NULL;
3597:../FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
3598:../FreeRTOS/Source/tasks.c **** 
3599:../FreeRTOS/Source/tasks.c ****         if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
3600:../FreeRTOS/Source/tasks.c ****         {
3601:../FreeRTOS/Source/tasks.c ****             pxTCB = prvGetTCBFromHandle( xTaskToQuery );
3602:../FreeRTOS/Source/tasks.c ****             pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
3603:../FreeRTOS/Source/tasks.c ****         }
3604:../FreeRTOS/Source/tasks.c ****         else
3605:../FreeRTOS/Source/tasks.c ****         {
3606:../FreeRTOS/Source/tasks.c ****             pvReturn = NULL;
3607:../FreeRTOS/Source/tasks.c ****         }
3608:../FreeRTOS/Source/tasks.c **** 
3609:../FreeRTOS/Source/tasks.c ****         return pvReturn;
3610:../FreeRTOS/Source/tasks.c ****     }
3611:../FreeRTOS/Source/tasks.c **** 
3612:../FreeRTOS/Source/tasks.c **** #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3613:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3614:../FreeRTOS/Source/tasks.c **** 
3615:../FreeRTOS/Source/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
3616:../FreeRTOS/Source/tasks.c **** 
3617:../FreeRTOS/Source/tasks.c ****     void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify,
3618:../FreeRTOS/Source/tasks.c ****                                   const MemoryRegion_t * const xRegions )
3619:../FreeRTOS/Source/tasks.c ****     {
3620:../FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
3621:../FreeRTOS/Source/tasks.c **** 
3622:../FreeRTOS/Source/tasks.c ****         /* If null is passed in here then we are modifying the MPU settings of
3623:../FreeRTOS/Source/tasks.c ****          * the calling task. */
3624:../FreeRTOS/Source/tasks.c ****         pxTCB = prvGetTCBFromHandle( xTaskToModify );
3625:../FreeRTOS/Source/tasks.c **** 
3626:../FreeRTOS/Source/tasks.c ****         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
3627:../FreeRTOS/Source/tasks.c ****     }
3628:../FreeRTOS/Source/tasks.c **** 
3629:../FreeRTOS/Source/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
3630:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3631:../FreeRTOS/Source/tasks.c **** 
3632:../FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void )
3633:../FreeRTOS/Source/tasks.c **** {
3634:../FreeRTOS/Source/tasks.c ****     UBaseType_t uxPriority;
3635:../FreeRTOS/Source/tasks.c **** 
3636:../FreeRTOS/Source/tasks.c ****     for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPrio
3637:../FreeRTOS/Source/tasks.c ****     {
3638:../FreeRTOS/Source/tasks.c ****         vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
3639:../FreeRTOS/Source/tasks.c ****     }
3640:../FreeRTOS/Source/tasks.c **** 
3641:../FreeRTOS/Source/tasks.c ****     vListInitialise( &xDelayedTaskList1 );
3642:../FreeRTOS/Source/tasks.c ****     vListInitialise( &xDelayedTaskList2 );
3643:../FreeRTOS/Source/tasks.c ****     vListInitialise( &xPendingReadyList );
3644:../FreeRTOS/Source/tasks.c **** 
3645:../FreeRTOS/Source/tasks.c ****     #if ( INCLUDE_vTaskDelete == 1 )
3646:../FreeRTOS/Source/tasks.c ****         {
3647:../FreeRTOS/Source/tasks.c ****             vListInitialise( &xTasksWaitingTermination );
3648:../FreeRTOS/Source/tasks.c ****         }
3649:../FreeRTOS/Source/tasks.c ****     #endif /* INCLUDE_vTaskDelete */
3650:../FreeRTOS/Source/tasks.c **** 
3651:../FreeRTOS/Source/tasks.c ****     #if ( INCLUDE_vTaskSuspend == 1 )
3652:../FreeRTOS/Source/tasks.c ****         {
3653:../FreeRTOS/Source/tasks.c ****             vListInitialise( &xSuspendedTaskList );
3654:../FreeRTOS/Source/tasks.c ****         }
3655:../FreeRTOS/Source/tasks.c ****     #endif /* INCLUDE_vTaskSuspend */
3656:../FreeRTOS/Source/tasks.c **** 
3657:../FreeRTOS/Source/tasks.c ****     /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
3658:../FreeRTOS/Source/tasks.c ****      * using list2. */
3659:../FreeRTOS/Source/tasks.c ****     pxDelayedTaskList = &xDelayedTaskList1;
3660:../FreeRTOS/Source/tasks.c ****     pxOverflowDelayedTaskList = &xDelayedTaskList2;
3661:../FreeRTOS/Source/tasks.c **** }
3662:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3663:../FreeRTOS/Source/tasks.c **** 
3664:../FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void )
3665:../FreeRTOS/Source/tasks.c **** {
3666:../FreeRTOS/Source/tasks.c ****     /** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
3667:../FreeRTOS/Source/tasks.c **** 
3668:../FreeRTOS/Source/tasks.c ****     #if ( INCLUDE_vTaskDelete == 1 )
3669:../FreeRTOS/Source/tasks.c ****         {
3670:../FreeRTOS/Source/tasks.c ****             TCB_t * pxTCB;
3671:../FreeRTOS/Source/tasks.c **** 
3672:../FreeRTOS/Source/tasks.c ****             /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
3673:../FreeRTOS/Source/tasks.c ****              * being called too often in the idle task. */
3674:../FreeRTOS/Source/tasks.c ****             while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
3675:../FreeRTOS/Source/tasks.c ****             {
3676:../FreeRTOS/Source/tasks.c ****                 taskENTER_CRITICAL();
3677:../FreeRTOS/Source/tasks.c ****                 {
3678:../FreeRTOS/Source/tasks.c ****                     pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e
3679:../FreeRTOS/Source/tasks.c ****                     ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
3680:../FreeRTOS/Source/tasks.c ****                     --uxCurrentNumberOfTasks;
3681:../FreeRTOS/Source/tasks.c ****                     --uxDeletedTasksWaitingCleanUp;
3682:../FreeRTOS/Source/tasks.c ****                 }
3683:../FreeRTOS/Source/tasks.c ****                 taskEXIT_CRITICAL();
3684:../FreeRTOS/Source/tasks.c **** 
3685:../FreeRTOS/Source/tasks.c ****                 prvDeleteTCB( pxTCB );
3686:../FreeRTOS/Source/tasks.c ****             }
3687:../FreeRTOS/Source/tasks.c ****         }
3688:../FreeRTOS/Source/tasks.c ****     #endif /* INCLUDE_vTaskDelete */
3689:../FreeRTOS/Source/tasks.c **** }
3690:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3691:../FreeRTOS/Source/tasks.c **** 
3692:../FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3693:../FreeRTOS/Source/tasks.c **** 
3694:../FreeRTOS/Source/tasks.c ****     void vTaskGetInfo( TaskHandle_t xTask,
3695:../FreeRTOS/Source/tasks.c ****                        TaskStatus_t * pxTaskStatus,
3696:../FreeRTOS/Source/tasks.c ****                        BaseType_t xGetFreeStackSpace,
3697:../FreeRTOS/Source/tasks.c ****                        eTaskState eState )
3698:../FreeRTOS/Source/tasks.c ****     {
3699:../FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
3700:../FreeRTOS/Source/tasks.c **** 
3701:../FreeRTOS/Source/tasks.c ****         /* xTask is NULL then get the state of the calling task. */
3702:../FreeRTOS/Source/tasks.c ****         pxTCB = prvGetTCBFromHandle( xTask );
3703:../FreeRTOS/Source/tasks.c **** 
3704:../FreeRTOS/Source/tasks.c ****         pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
3705:../FreeRTOS/Source/tasks.c ****         pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName[ 0 ] );
3706:../FreeRTOS/Source/tasks.c ****         pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
3707:../FreeRTOS/Source/tasks.c ****         pxTaskStatus->pxStackBase = pxTCB->pxStack;
3708:../FreeRTOS/Source/tasks.c ****         pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
3709:../FreeRTOS/Source/tasks.c **** 
3710:../FreeRTOS/Source/tasks.c ****         #if ( configUSE_MUTEXES == 1 )
3711:../FreeRTOS/Source/tasks.c ****             {
3712:../FreeRTOS/Source/tasks.c ****                 pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
3713:../FreeRTOS/Source/tasks.c ****             }
3714:../FreeRTOS/Source/tasks.c ****         #else
3715:../FreeRTOS/Source/tasks.c ****             {
3716:../FreeRTOS/Source/tasks.c ****                 pxTaskStatus->uxBasePriority = 0;
3717:../FreeRTOS/Source/tasks.c ****             }
3718:../FreeRTOS/Source/tasks.c ****         #endif
3719:../FreeRTOS/Source/tasks.c **** 
3720:../FreeRTOS/Source/tasks.c ****         #if ( configGENERATE_RUN_TIME_STATS == 1 )
3721:../FreeRTOS/Source/tasks.c ****             {
3722:../FreeRTOS/Source/tasks.c ****                 pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
3723:../FreeRTOS/Source/tasks.c ****             }
3724:../FreeRTOS/Source/tasks.c ****         #else
3725:../FreeRTOS/Source/tasks.c ****             {
3726:../FreeRTOS/Source/tasks.c ****                 pxTaskStatus->ulRunTimeCounter = 0;
3727:../FreeRTOS/Source/tasks.c ****             }
3728:../FreeRTOS/Source/tasks.c ****         #endif
3729:../FreeRTOS/Source/tasks.c **** 
3730:../FreeRTOS/Source/tasks.c ****         /* Obtaining the task state is a little fiddly, so is only done if the
3731:../FreeRTOS/Source/tasks.c ****          * value of eState passed into this function is eInvalid - otherwise the
3732:../FreeRTOS/Source/tasks.c ****          * state is just set to whatever is passed in. */
3733:../FreeRTOS/Source/tasks.c ****         if( eState != eInvalid )
3734:../FreeRTOS/Source/tasks.c ****         {
3735:../FreeRTOS/Source/tasks.c ****             if( pxTCB == pxCurrentTCB )
3736:../FreeRTOS/Source/tasks.c ****             {
3737:../FreeRTOS/Source/tasks.c ****                 pxTaskStatus->eCurrentState = eRunning;
3738:../FreeRTOS/Source/tasks.c ****             }
3739:../FreeRTOS/Source/tasks.c ****             else
3740:../FreeRTOS/Source/tasks.c ****             {
3741:../FreeRTOS/Source/tasks.c ****                 pxTaskStatus->eCurrentState = eState;
3742:../FreeRTOS/Source/tasks.c **** 
3743:../FreeRTOS/Source/tasks.c ****                 #if ( INCLUDE_vTaskSuspend == 1 )
3744:../FreeRTOS/Source/tasks.c ****                     {
3745:../FreeRTOS/Source/tasks.c ****                         /* If the task is in the suspended list then there is a
3746:../FreeRTOS/Source/tasks.c ****                          *  chance it is actually just blocked indefinitely - so really
3747:../FreeRTOS/Source/tasks.c ****                          *  it should be reported as being in the Blocked state. */
3748:../FreeRTOS/Source/tasks.c ****                         if( eState == eSuspended )
3749:../FreeRTOS/Source/tasks.c ****                         {
3750:../FreeRTOS/Source/tasks.c ****                             vTaskSuspendAll();
3751:../FreeRTOS/Source/tasks.c ****                             {
3752:../FreeRTOS/Source/tasks.c ****                                 if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
3753:../FreeRTOS/Source/tasks.c ****                                 {
3754:../FreeRTOS/Source/tasks.c ****                                     pxTaskStatus->eCurrentState = eBlocked;
3755:../FreeRTOS/Source/tasks.c ****                                 }
3756:../FreeRTOS/Source/tasks.c ****                             }
3757:../FreeRTOS/Source/tasks.c ****                             ( void ) xTaskResumeAll();
3758:../FreeRTOS/Source/tasks.c ****                         }
3759:../FreeRTOS/Source/tasks.c ****                     }
3760:../FreeRTOS/Source/tasks.c ****                 #endif /* INCLUDE_vTaskSuspend */
3761:../FreeRTOS/Source/tasks.c ****             }
3762:../FreeRTOS/Source/tasks.c ****         }
3763:../FreeRTOS/Source/tasks.c ****         else
3764:../FreeRTOS/Source/tasks.c ****         {
3765:../FreeRTOS/Source/tasks.c ****             pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
3766:../FreeRTOS/Source/tasks.c ****         }
3767:../FreeRTOS/Source/tasks.c **** 
3768:../FreeRTOS/Source/tasks.c ****         /* Obtaining the stack space takes some time, so the xGetFreeStackSpace
3769:../FreeRTOS/Source/tasks.c ****          * parameter is provided to allow it to be skipped. */
3770:../FreeRTOS/Source/tasks.c ****         if( xGetFreeStackSpace != pdFALSE )
3771:../FreeRTOS/Source/tasks.c ****         {
3772:../FreeRTOS/Source/tasks.c ****             #if ( portSTACK_GROWTH > 0 )
3773:../FreeRTOS/Source/tasks.c ****                 {
3774:../FreeRTOS/Source/tasks.c ****                     pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) 
3775:../FreeRTOS/Source/tasks.c ****                 }
3776:../FreeRTOS/Source/tasks.c ****             #else
3777:../FreeRTOS/Source/tasks.c ****                 {
3778:../FreeRTOS/Source/tasks.c ****                     pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) 
3779:../FreeRTOS/Source/tasks.c ****                 }
3780:../FreeRTOS/Source/tasks.c ****             #endif
3781:../FreeRTOS/Source/tasks.c ****         }
3782:../FreeRTOS/Source/tasks.c ****         else
3783:../FreeRTOS/Source/tasks.c ****         {
3784:../FreeRTOS/Source/tasks.c ****             pxTaskStatus->usStackHighWaterMark = 0;
3785:../FreeRTOS/Source/tasks.c ****         }
3786:../FreeRTOS/Source/tasks.c ****     }
3787:../FreeRTOS/Source/tasks.c **** 
3788:../FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3789:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3790:../FreeRTOS/Source/tasks.c **** 
3791:../FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3792:../FreeRTOS/Source/tasks.c **** 
3793:../FreeRTOS/Source/tasks.c ****     static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t * pxTaskStatusArray,
3794:../FreeRTOS/Source/tasks.c ****                                                      List_t * pxList,
3795:../FreeRTOS/Source/tasks.c ****                                                      eTaskState eState )
3796:../FreeRTOS/Source/tasks.c ****     {
3797:../FreeRTOS/Source/tasks.c ****         configLIST_VOLATILE TCB_t * pxNextTCB, * pxFirstTCB;
3798:../FreeRTOS/Source/tasks.c ****         UBaseType_t uxTask = 0;
3799:../FreeRTOS/Source/tasks.c **** 
3800:../FreeRTOS/Source/tasks.c ****         if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
3801:../FreeRTOS/Source/tasks.c ****         {
3802:../FreeRTOS/Source/tasks.c ****             listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this
3803:../FreeRTOS/Source/tasks.c **** 
3804:../FreeRTOS/Source/tasks.c ****             /* Populate an TaskStatus_t structure within the
3805:../FreeRTOS/Source/tasks.c ****              * pxTaskStatusArray array for each task that is referenced from
3806:../FreeRTOS/Source/tasks.c ****              * pxList.  See the definition of TaskStatus_t in task.h for the
3807:../FreeRTOS/Source/tasks.c ****              * meaning of each TaskStatus_t structure member. */
3808:../FreeRTOS/Source/tasks.c ****             do
3809:../FreeRTOS/Source/tasks.c ****             {
3810:../FreeRTOS/Source/tasks.c ****                 listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as t
3811:../FreeRTOS/Source/tasks.c ****                 vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE,
3812:../FreeRTOS/Source/tasks.c ****                 uxTask++;
3813:../FreeRTOS/Source/tasks.c ****             } while( pxNextTCB != pxFirstTCB );
3814:../FreeRTOS/Source/tasks.c ****         }
3815:../FreeRTOS/Source/tasks.c ****         else
3816:../FreeRTOS/Source/tasks.c ****         {
3817:../FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
3818:../FreeRTOS/Source/tasks.c ****         }
3819:../FreeRTOS/Source/tasks.c **** 
3820:../FreeRTOS/Source/tasks.c ****         return uxTask;
3821:../FreeRTOS/Source/tasks.c ****     }
3822:../FreeRTOS/Source/tasks.c **** 
3823:../FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3824:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3825:../FreeRTOS/Source/tasks.c **** 
3826:../FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUD
3827:../FreeRTOS/Source/tasks.c **** 
3828:../FreeRTOS/Source/tasks.c ****     static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
3829:../FreeRTOS/Source/tasks.c ****     {
3830:../FreeRTOS/Source/tasks.c ****         uint32_t ulCount = 0U;
3831:../FreeRTOS/Source/tasks.c **** 
3832:../FreeRTOS/Source/tasks.c ****         while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
3833:../FreeRTOS/Source/tasks.c ****         {
3834:../FreeRTOS/Source/tasks.c ****             pucStackByte -= portSTACK_GROWTH;
3835:../FreeRTOS/Source/tasks.c ****             ulCount++;
3836:../FreeRTOS/Source/tasks.c ****         }
3837:../FreeRTOS/Source/tasks.c **** 
3838:../FreeRTOS/Source/tasks.c ****         ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on sma
3839:../FreeRTOS/Source/tasks.c **** 
3840:../FreeRTOS/Source/tasks.c ****         return ( configSTACK_DEPTH_TYPE ) ulCount;
3841:../FreeRTOS/Source/tasks.c ****     }
3842:../FreeRTOS/Source/tasks.c **** 
3843:../FreeRTOS/Source/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( 
3844:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3845:../FreeRTOS/Source/tasks.c **** 
3846:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 )
3847:../FreeRTOS/Source/tasks.c **** 
3848:../FreeRTOS/Source/tasks.c **** /* uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are the
3849:../FreeRTOS/Source/tasks.c ****  * same except for their return type.  Using configSTACK_DEPTH_TYPE allows the
3850:../FreeRTOS/Source/tasks.c ****  * user to determine the return type.  It gets around the problem of the value
3851:../FreeRTOS/Source/tasks.c ****  * overflowing on 8-bit types without breaking backward compatibility for
3852:../FreeRTOS/Source/tasks.c ****  * applications that expect an 8-bit return type. */
3853:../FreeRTOS/Source/tasks.c ****     configSTACK_DEPTH_TYPE uxTaskGetStackHighWaterMark2( TaskHandle_t xTask )
3854:../FreeRTOS/Source/tasks.c ****     {
3855:../FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
3856:../FreeRTOS/Source/tasks.c ****         uint8_t * pucEndOfStack;
3857:../FreeRTOS/Source/tasks.c ****         configSTACK_DEPTH_TYPE uxReturn;
3858:../FreeRTOS/Source/tasks.c **** 
3859:../FreeRTOS/Source/tasks.c ****         /* uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are
3860:../FreeRTOS/Source/tasks.c ****          * the same except for their return type.  Using configSTACK_DEPTH_TYPE
3861:../FreeRTOS/Source/tasks.c ****          * allows the user to determine the return type.  It gets around the
3862:../FreeRTOS/Source/tasks.c ****          * problem of the value overflowing on 8-bit types without breaking
3863:../FreeRTOS/Source/tasks.c ****          * backward compatibility for applications that expect an 8-bit return
3864:../FreeRTOS/Source/tasks.c ****          * type. */
3865:../FreeRTOS/Source/tasks.c **** 
3866:../FreeRTOS/Source/tasks.c ****         pxTCB = prvGetTCBFromHandle( xTask );
3867:../FreeRTOS/Source/tasks.c **** 
3868:../FreeRTOS/Source/tasks.c ****         #if portSTACK_GROWTH < 0
3869:../FreeRTOS/Source/tasks.c ****             {
3870:../FreeRTOS/Source/tasks.c ****                 pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
3871:../FreeRTOS/Source/tasks.c ****             }
3872:../FreeRTOS/Source/tasks.c ****         #else
3873:../FreeRTOS/Source/tasks.c ****             {
3874:../FreeRTOS/Source/tasks.c ****                 pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
3875:../FreeRTOS/Source/tasks.c ****             }
3876:../FreeRTOS/Source/tasks.c ****         #endif
3877:../FreeRTOS/Source/tasks.c **** 
3878:../FreeRTOS/Source/tasks.c ****         uxReturn = prvTaskCheckFreeStackSpace( pucEndOfStack );
3879:../FreeRTOS/Source/tasks.c **** 
3880:../FreeRTOS/Source/tasks.c ****         return uxReturn;
3881:../FreeRTOS/Source/tasks.c ****     }
3882:../FreeRTOS/Source/tasks.c **** 
3883:../FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_uxTaskGetStackHighWaterMark2 */
3884:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3885:../FreeRTOS/Source/tasks.c **** 
3886:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
3887:../FreeRTOS/Source/tasks.c **** 
3888:../FreeRTOS/Source/tasks.c ****     UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
3889:../FreeRTOS/Source/tasks.c ****     {
3890:../FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
3891:../FreeRTOS/Source/tasks.c ****         uint8_t * pucEndOfStack;
3892:../FreeRTOS/Source/tasks.c ****         UBaseType_t uxReturn;
3893:../FreeRTOS/Source/tasks.c **** 
3894:../FreeRTOS/Source/tasks.c ****         pxTCB = prvGetTCBFromHandle( xTask );
3895:../FreeRTOS/Source/tasks.c **** 
3896:../FreeRTOS/Source/tasks.c ****         #if portSTACK_GROWTH < 0
3897:../FreeRTOS/Source/tasks.c ****             {
3898:../FreeRTOS/Source/tasks.c ****                 pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
3899:../FreeRTOS/Source/tasks.c ****             }
3900:../FreeRTOS/Source/tasks.c ****         #else
3901:../FreeRTOS/Source/tasks.c ****             {
3902:../FreeRTOS/Source/tasks.c ****                 pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
3903:../FreeRTOS/Source/tasks.c ****             }
3904:../FreeRTOS/Source/tasks.c ****         #endif
3905:../FreeRTOS/Source/tasks.c **** 
3906:../FreeRTOS/Source/tasks.c ****         uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
3907:../FreeRTOS/Source/tasks.c **** 
3908:../FreeRTOS/Source/tasks.c ****         return uxReturn;
3909:../FreeRTOS/Source/tasks.c ****     }
3910:../FreeRTOS/Source/tasks.c **** 
3911:../FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
3912:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3913:../FreeRTOS/Source/tasks.c **** 
3914:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
3915:../FreeRTOS/Source/tasks.c **** 
3916:../FreeRTOS/Source/tasks.c ****     static void prvDeleteTCB( TCB_t * pxTCB )
3917:../FreeRTOS/Source/tasks.c ****     {
3918:../FreeRTOS/Source/tasks.c ****         /* This call is required specifically for the TriCore port.  It must be
3919:../FreeRTOS/Source/tasks.c ****          * above the vPortFree() calls.  The call is also used by ports/demos that
3920:../FreeRTOS/Source/tasks.c ****          * want to allocate and clean RAM statically. */
3921:../FreeRTOS/Source/tasks.c ****         portCLEAN_UP_TCB( pxTCB );
3922:../FreeRTOS/Source/tasks.c **** 
3923:../FreeRTOS/Source/tasks.c ****         /* Free up the memory allocated by the scheduler for the task.  It is up
3924:../FreeRTOS/Source/tasks.c ****          * to the task to free any memory allocated at the application level.
3925:../FreeRTOS/Source/tasks.c ****          * See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
3926:../FreeRTOS/Source/tasks.c ****          * for additional information. */
3927:../FreeRTOS/Source/tasks.c ****         #if ( configUSE_NEWLIB_REENTRANT == 1 )
3928:../FreeRTOS/Source/tasks.c ****             {
3929:../FreeRTOS/Source/tasks.c ****                 _reclaim_reent( &( pxTCB->xNewLib_reent ) );
3930:../FreeRTOS/Source/tasks.c ****             }
3931:../FreeRTOS/Source/tasks.c ****         #endif /* configUSE_NEWLIB_REENTRANT */
3932:../FreeRTOS/Source/tasks.c **** 
3933:../FreeRTOS/Source/tasks.c ****         #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 )
3934:../FreeRTOS/Source/tasks.c ****             {
3935:../FreeRTOS/Source/tasks.c ****                 /* The task can only have been allocated dynamically - free both
3936:../FreeRTOS/Source/tasks.c ****                  * the stack and TCB. */
3937:../FreeRTOS/Source/tasks.c ****                 vPortFree( pxTCB->pxStack );
3938:../FreeRTOS/Source/tasks.c ****                 vPortFree( pxTCB );
3939:../FreeRTOS/Source/tasks.c ****             }
3940:../FreeRTOS/Source/tasks.c ****         #elif ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been
3941:../FreeRTOS/Source/tasks.c ****             {
3942:../FreeRTOS/Source/tasks.c ****                 /* The task could have been allocated statically or dynamically, so
3943:../FreeRTOS/Source/tasks.c ****                  * check what was statically allocated before trying to free the
3944:../FreeRTOS/Source/tasks.c ****                  * memory. */
3945:../FreeRTOS/Source/tasks.c ****                 if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
3946:../FreeRTOS/Source/tasks.c ****                 {
3947:../FreeRTOS/Source/tasks.c ****                     /* Both the stack and TCB were allocated dynamically, so both
3948:../FreeRTOS/Source/tasks.c ****                      * must be freed. */
3949:../FreeRTOS/Source/tasks.c ****                     vPortFree( pxTCB->pxStack );
3950:../FreeRTOS/Source/tasks.c ****                     vPortFree( pxTCB );
3951:../FreeRTOS/Source/tasks.c ****                 }
3952:../FreeRTOS/Source/tasks.c ****                 else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
3953:../FreeRTOS/Source/tasks.c ****                 {
3954:../FreeRTOS/Source/tasks.c ****                     /* Only the stack was statically allocated, so the TCB is the
3955:../FreeRTOS/Source/tasks.c ****                      * only memory that must be freed. */
3956:../FreeRTOS/Source/tasks.c ****                     vPortFree( pxTCB );
3957:../FreeRTOS/Source/tasks.c ****                 }
3958:../FreeRTOS/Source/tasks.c ****                 else
3959:../FreeRTOS/Source/tasks.c ****                 {
3960:../FreeRTOS/Source/tasks.c ****                     /* Neither the stack nor the TCB were allocated dynamically, so
3961:../FreeRTOS/Source/tasks.c ****                      * nothing needs to be freed. */
3962:../FreeRTOS/Source/tasks.c ****                     configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND
3963:../FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
3964:../FreeRTOS/Source/tasks.c ****                 }
3965:../FreeRTOS/Source/tasks.c ****             }
3966:../FreeRTOS/Source/tasks.c ****         #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
3967:../FreeRTOS/Source/tasks.c ****     }
3968:../FreeRTOS/Source/tasks.c **** 
3969:../FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelete */
3970:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3971:../FreeRTOS/Source/tasks.c **** 
3972:../FreeRTOS/Source/tasks.c **** static void prvResetNextTaskUnblockTime( void )
3973:../FreeRTOS/Source/tasks.c **** {
  94              	 .loc 1 3973 0
  95              	 .cfi_startproc
  96              	 
  97              	 
  98              	 
3974:../FreeRTOS/Source/tasks.c ****     if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  99              	 .loc 1 3974 0
 100 0000 074B     	 ldr r3,.L12
 101 0002 1B68     	 ldr r3,[r3]
 102 0004 1B68     	 ldr r3,[r3]
 103 0006 23B9     	 cbnz r3,.L10
3975:../FreeRTOS/Source/tasks.c ****     {
3976:../FreeRTOS/Source/tasks.c ****         /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
3977:../FreeRTOS/Source/tasks.c ****          * the maximum possible value so it is  extremely unlikely that the
3978:../FreeRTOS/Source/tasks.c ****          * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
3979:../FreeRTOS/Source/tasks.c ****          * there is an item in the delayed list. */
3980:../FreeRTOS/Source/tasks.c ****         xNextTaskUnblockTime = portMAX_DELAY;
 104              	 .loc 1 3980 0
 105 0008 4FF0FF32 	 mov r2,#-1
 106 000c 054B     	 ldr r3,.L12+4
 107 000e 1A60     	 str r2,[r3]
 108 0010 7047     	 bx lr
 109              	.L10:
3981:../FreeRTOS/Source/tasks.c ****     }
3982:../FreeRTOS/Source/tasks.c ****     else
3983:../FreeRTOS/Source/tasks.c ****     {
3984:../FreeRTOS/Source/tasks.c ****         /* The new current delayed list is not empty, get the value of
3985:../FreeRTOS/Source/tasks.c ****          * the item at the head of the delayed list.  This is the time at
3986:../FreeRTOS/Source/tasks.c ****          * which the task at the head of the delayed list should be removed
3987:../FreeRTOS/Source/tasks.c ****          * from the Blocked state. */
3988:../FreeRTOS/Source/tasks.c ****         xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
 110              	 .loc 1 3988 0
 111 0012 034B     	 ldr r3,.L12
 112 0014 1B68     	 ldr r3,[r3]
 113 0016 DB68     	 ldr r3,[r3,#12]
 114 0018 1A68     	 ldr r2,[r3]
 115 001a 024B     	 ldr r3,.L12+4
 116 001c 1A60     	 str r2,[r3]
 117 001e 7047     	 bx lr
 118              	.L13:
 119              	 .align 2
 120              	.L12:
 121 0020 00000000 	 .word .LANCHOR2
 122 0024 00000000 	 .word .LANCHOR3
 123              	 .cfi_endproc
 124              	.LFE49:
 126              	 .section .text.prvAddCurrentTaskToDelayedList,"ax",%progbits
 127              	 .align 2
 128              	 .thumb
 129              	 .thumb_func
 131              	prvAddCurrentTaskToDelayedList:
 132              	.LFB64:
3989:../FreeRTOS/Source/tasks.c ****     }
3990:../FreeRTOS/Source/tasks.c **** }
3991:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3992:../FreeRTOS/Source/tasks.c **** 
3993:../FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
3994:../FreeRTOS/Source/tasks.c **** 
3995:../FreeRTOS/Source/tasks.c ****     TaskHandle_t xTaskGetCurrentTaskHandle( void )
3996:../FreeRTOS/Source/tasks.c ****     {
3997:../FreeRTOS/Source/tasks.c ****         TaskHandle_t xReturn;
3998:../FreeRTOS/Source/tasks.c **** 
3999:../FreeRTOS/Source/tasks.c ****         /* A critical section is not required as this is not called from
4000:../FreeRTOS/Source/tasks.c ****          * an interrupt and the current TCB will always be the same for any
4001:../FreeRTOS/Source/tasks.c ****          * individual execution thread. */
4002:../FreeRTOS/Source/tasks.c ****         xReturn = pxCurrentTCB;
4003:../FreeRTOS/Source/tasks.c **** 
4004:../FreeRTOS/Source/tasks.c ****         return xReturn;
4005:../FreeRTOS/Source/tasks.c ****     }
4006:../FreeRTOS/Source/tasks.c **** 
4007:../FreeRTOS/Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
4008:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4009:../FreeRTOS/Source/tasks.c **** 
4010:../FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
4011:../FreeRTOS/Source/tasks.c **** 
4012:../FreeRTOS/Source/tasks.c ****     BaseType_t xTaskGetSchedulerState( void )
4013:../FreeRTOS/Source/tasks.c ****     {
4014:../FreeRTOS/Source/tasks.c ****         BaseType_t xReturn;
4015:../FreeRTOS/Source/tasks.c **** 
4016:../FreeRTOS/Source/tasks.c ****         if( xSchedulerRunning == pdFALSE )
4017:../FreeRTOS/Source/tasks.c ****         {
4018:../FreeRTOS/Source/tasks.c ****             xReturn = taskSCHEDULER_NOT_STARTED;
4019:../FreeRTOS/Source/tasks.c ****         }
4020:../FreeRTOS/Source/tasks.c ****         else
4021:../FreeRTOS/Source/tasks.c ****         {
4022:../FreeRTOS/Source/tasks.c ****             if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
4023:../FreeRTOS/Source/tasks.c ****             {
4024:../FreeRTOS/Source/tasks.c ****                 xReturn = taskSCHEDULER_RUNNING;
4025:../FreeRTOS/Source/tasks.c ****             }
4026:../FreeRTOS/Source/tasks.c ****             else
4027:../FreeRTOS/Source/tasks.c ****             {
4028:../FreeRTOS/Source/tasks.c ****                 xReturn = taskSCHEDULER_SUSPENDED;
4029:../FreeRTOS/Source/tasks.c ****             }
4030:../FreeRTOS/Source/tasks.c ****         }
4031:../FreeRTOS/Source/tasks.c **** 
4032:../FreeRTOS/Source/tasks.c ****         return xReturn;
4033:../FreeRTOS/Source/tasks.c ****     }
4034:../FreeRTOS/Source/tasks.c **** 
4035:../FreeRTOS/Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
4036:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4037:../FreeRTOS/Source/tasks.c **** 
4038:../FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4039:../FreeRTOS/Source/tasks.c **** 
4040:../FreeRTOS/Source/tasks.c ****     BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
4041:../FreeRTOS/Source/tasks.c ****     {
4042:../FreeRTOS/Source/tasks.c ****         TCB_t * const pxMutexHolderTCB = pxMutexHolder;
4043:../FreeRTOS/Source/tasks.c ****         BaseType_t xReturn = pdFALSE;
4044:../FreeRTOS/Source/tasks.c **** 
4045:../FreeRTOS/Source/tasks.c ****         /* If the mutex was given back by an interrupt while the queue was
4046:../FreeRTOS/Source/tasks.c ****          * locked then the mutex holder might now be NULL.  _RB_ Is this still
4047:../FreeRTOS/Source/tasks.c ****          * needed as interrupts can no longer use mutexes? */
4048:../FreeRTOS/Source/tasks.c ****         if( pxMutexHolder != NULL )
4049:../FreeRTOS/Source/tasks.c ****         {
4050:../FreeRTOS/Source/tasks.c ****             /* If the holder of the mutex has a priority below the priority of
4051:../FreeRTOS/Source/tasks.c ****              * the task attempting to obtain the mutex then it will temporarily
4052:../FreeRTOS/Source/tasks.c ****              * inherit the priority of the task attempting to obtain the mutex. */
4053:../FreeRTOS/Source/tasks.c ****             if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
4054:../FreeRTOS/Source/tasks.c ****             {
4055:../FreeRTOS/Source/tasks.c ****                 /* Adjust the mutex holder state to account for its new
4056:../FreeRTOS/Source/tasks.c ****                  * priority.  Only reset the event list item value if the value is
4057:../FreeRTOS/Source/tasks.c ****                  * not being used for anything else. */
4058:../FreeRTOS/Source/tasks.c ****                 if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_
4059:../FreeRTOS/Source/tasks.c ****                 {
4060:../FreeRTOS/Source/tasks.c ****                     listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) 
4061:../FreeRTOS/Source/tasks.c ****                 }
4062:../FreeRTOS/Source/tasks.c ****                 else
4063:../FreeRTOS/Source/tasks.c ****                 {
4064:../FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
4065:../FreeRTOS/Source/tasks.c ****                 }
4066:../FreeRTOS/Source/tasks.c **** 
4067:../FreeRTOS/Source/tasks.c ****                 /* If the task being modified is in the ready state it will need
4068:../FreeRTOS/Source/tasks.c ****                  * to be moved into a new list. */
4069:../FreeRTOS/Source/tasks.c ****                 if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] )
4070:../FreeRTOS/Source/tasks.c ****                 {
4071:../FreeRTOS/Source/tasks.c ****                     if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 
4072:../FreeRTOS/Source/tasks.c ****                     {
4073:../FreeRTOS/Source/tasks.c ****                         /* It is known that the task is in its ready list so
4074:../FreeRTOS/Source/tasks.c ****                          * there is no need to check again and the port level
4075:../FreeRTOS/Source/tasks.c ****                          * reset macro can be called directly. */
4076:../FreeRTOS/Source/tasks.c ****                         portRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority, uxTopReadyPriority 
4077:../FreeRTOS/Source/tasks.c ****                     }
4078:../FreeRTOS/Source/tasks.c ****                     else
4079:../FreeRTOS/Source/tasks.c ****                     {
4080:../FreeRTOS/Source/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
4081:../FreeRTOS/Source/tasks.c ****                     }
4082:../FreeRTOS/Source/tasks.c **** 
4083:../FreeRTOS/Source/tasks.c ****                     /* Inherit the priority before being moved into the new list. */
4084:../FreeRTOS/Source/tasks.c ****                     pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
4085:../FreeRTOS/Source/tasks.c ****                     prvAddTaskToReadyList( pxMutexHolderTCB );
4086:../FreeRTOS/Source/tasks.c ****                 }
4087:../FreeRTOS/Source/tasks.c ****                 else
4088:../FreeRTOS/Source/tasks.c ****                 {
4089:../FreeRTOS/Source/tasks.c ****                     /* Just inherit the priority. */
4090:../FreeRTOS/Source/tasks.c ****                     pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
4091:../FreeRTOS/Source/tasks.c ****                 }
4092:../FreeRTOS/Source/tasks.c **** 
4093:../FreeRTOS/Source/tasks.c ****                 traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );
4094:../FreeRTOS/Source/tasks.c **** 
4095:../FreeRTOS/Source/tasks.c ****                 /* Inheritance occurred. */
4096:../FreeRTOS/Source/tasks.c ****                 xReturn = pdTRUE;
4097:../FreeRTOS/Source/tasks.c ****             }
4098:../FreeRTOS/Source/tasks.c ****             else
4099:../FreeRTOS/Source/tasks.c ****             {
4100:../FreeRTOS/Source/tasks.c ****                 if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
4101:../FreeRTOS/Source/tasks.c ****                 {
4102:../FreeRTOS/Source/tasks.c ****                     /* The base priority of the mutex holder is lower than the
4103:../FreeRTOS/Source/tasks.c ****                      * priority of the task attempting to take the mutex, but the
4104:../FreeRTOS/Source/tasks.c ****                      * current priority of the mutex holder is not lower than the
4105:../FreeRTOS/Source/tasks.c ****                      * priority of the task attempting to take the mutex.
4106:../FreeRTOS/Source/tasks.c ****                      * Therefore the mutex holder must have already inherited a
4107:../FreeRTOS/Source/tasks.c ****                      * priority, but inheritance would have occurred if that had
4108:../FreeRTOS/Source/tasks.c ****                      * not been the case. */
4109:../FreeRTOS/Source/tasks.c ****                     xReturn = pdTRUE;
4110:../FreeRTOS/Source/tasks.c ****                 }
4111:../FreeRTOS/Source/tasks.c ****                 else
4112:../FreeRTOS/Source/tasks.c ****                 {
4113:../FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
4114:../FreeRTOS/Source/tasks.c ****                 }
4115:../FreeRTOS/Source/tasks.c ****             }
4116:../FreeRTOS/Source/tasks.c ****         }
4117:../FreeRTOS/Source/tasks.c ****         else
4118:../FreeRTOS/Source/tasks.c ****         {
4119:../FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
4120:../FreeRTOS/Source/tasks.c ****         }
4121:../FreeRTOS/Source/tasks.c **** 
4122:../FreeRTOS/Source/tasks.c ****         return xReturn;
4123:../FreeRTOS/Source/tasks.c ****     }
4124:../FreeRTOS/Source/tasks.c **** 
4125:../FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
4126:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4127:../FreeRTOS/Source/tasks.c **** 
4128:../FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4129:../FreeRTOS/Source/tasks.c **** 
4130:../FreeRTOS/Source/tasks.c ****     BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
4131:../FreeRTOS/Source/tasks.c ****     {
4132:../FreeRTOS/Source/tasks.c ****         TCB_t * const pxTCB = pxMutexHolder;
4133:../FreeRTOS/Source/tasks.c ****         BaseType_t xReturn = pdFALSE;
4134:../FreeRTOS/Source/tasks.c **** 
4135:../FreeRTOS/Source/tasks.c ****         if( pxMutexHolder != NULL )
4136:../FreeRTOS/Source/tasks.c ****         {
4137:../FreeRTOS/Source/tasks.c ****             /* A task can only have an inherited priority if it holds the mutex.
4138:../FreeRTOS/Source/tasks.c ****              * If the mutex is held by a task then it cannot be given from an
4139:../FreeRTOS/Source/tasks.c ****              * interrupt, and if a mutex is given by the holding task then it must
4140:../FreeRTOS/Source/tasks.c ****              * be the running state task. */
4141:../FreeRTOS/Source/tasks.c ****             configASSERT( pxTCB == pxCurrentTCB );
4142:../FreeRTOS/Source/tasks.c ****             configASSERT( pxTCB->uxMutexesHeld );
4143:../FreeRTOS/Source/tasks.c ****             ( pxTCB->uxMutexesHeld )--;
4144:../FreeRTOS/Source/tasks.c **** 
4145:../FreeRTOS/Source/tasks.c ****             /* Has the holder of the mutex inherited the priority of another
4146:../FreeRTOS/Source/tasks.c ****              * task? */
4147:../FreeRTOS/Source/tasks.c ****             if( pxTCB->uxPriority != pxTCB->uxBasePriority )
4148:../FreeRTOS/Source/tasks.c ****             {
4149:../FreeRTOS/Source/tasks.c ****                 /* Only disinherit if no other mutexes are held. */
4150:../FreeRTOS/Source/tasks.c ****                 if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
4151:../FreeRTOS/Source/tasks.c ****                 {
4152:../FreeRTOS/Source/tasks.c ****                     /* A task can only have an inherited priority if it holds
4153:../FreeRTOS/Source/tasks.c ****                      * the mutex.  If the mutex is held by a task then it cannot be
4154:../FreeRTOS/Source/tasks.c ****                      * given from an interrupt, and if a mutex is given by the
4155:../FreeRTOS/Source/tasks.c ****                      * holding task then it must be the running state task.  Remove
4156:../FreeRTOS/Source/tasks.c ****                      * the holding task from the ready list. */
4157:../FreeRTOS/Source/tasks.c ****                     if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4158:../FreeRTOS/Source/tasks.c ****                     {
4159:../FreeRTOS/Source/tasks.c ****                         portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
4160:../FreeRTOS/Source/tasks.c ****                     }
4161:../FreeRTOS/Source/tasks.c ****                     else
4162:../FreeRTOS/Source/tasks.c ****                     {
4163:../FreeRTOS/Source/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
4164:../FreeRTOS/Source/tasks.c ****                     }
4165:../FreeRTOS/Source/tasks.c **** 
4166:../FreeRTOS/Source/tasks.c ****                     /* Disinherit the priority before adding the task into the
4167:../FreeRTOS/Source/tasks.c ****                      * new  ready list. */
4168:../FreeRTOS/Source/tasks.c ****                     traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
4169:../FreeRTOS/Source/tasks.c ****                     pxTCB->uxPriority = pxTCB->uxBasePriority;
4170:../FreeRTOS/Source/tasks.c **** 
4171:../FreeRTOS/Source/tasks.c ****                     /* Reset the event list item value.  It cannot be in use for
4172:../FreeRTOS/Source/tasks.c ****                      * any other purpose if this task is running, and it must be
4173:../FreeRTOS/Source/tasks.c ****                      * running to give back the mutex. */
4174:../FreeRTOS/Source/tasks.c ****                     listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_P
4175:../FreeRTOS/Source/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
4176:../FreeRTOS/Source/tasks.c **** 
4177:../FreeRTOS/Source/tasks.c ****                     /* Return true to indicate that a context switch is required.
4178:../FreeRTOS/Source/tasks.c ****                      * This is only actually required in the corner case whereby
4179:../FreeRTOS/Source/tasks.c ****                      * multiple mutexes were held and the mutexes were given back
4180:../FreeRTOS/Source/tasks.c ****                      * in an order different to that in which they were taken.
4181:../FreeRTOS/Source/tasks.c ****                      * If a context switch did not occur when the first mutex was
4182:../FreeRTOS/Source/tasks.c ****                      * returned, even if a task was waiting on it, then a context
4183:../FreeRTOS/Source/tasks.c ****                      * switch should occur when the last mutex is returned whether
4184:../FreeRTOS/Source/tasks.c ****                      * a task is waiting on it or not. */
4185:../FreeRTOS/Source/tasks.c ****                     xReturn = pdTRUE;
4186:../FreeRTOS/Source/tasks.c ****                 }
4187:../FreeRTOS/Source/tasks.c ****                 else
4188:../FreeRTOS/Source/tasks.c ****                 {
4189:../FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
4190:../FreeRTOS/Source/tasks.c ****                 }
4191:../FreeRTOS/Source/tasks.c ****             }
4192:../FreeRTOS/Source/tasks.c ****             else
4193:../FreeRTOS/Source/tasks.c ****             {
4194:../FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
4195:../FreeRTOS/Source/tasks.c ****             }
4196:../FreeRTOS/Source/tasks.c ****         }
4197:../FreeRTOS/Source/tasks.c ****         else
4198:../FreeRTOS/Source/tasks.c ****         {
4199:../FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
4200:../FreeRTOS/Source/tasks.c ****         }
4201:../FreeRTOS/Source/tasks.c **** 
4202:../FreeRTOS/Source/tasks.c ****         return xReturn;
4203:../FreeRTOS/Source/tasks.c ****     }
4204:../FreeRTOS/Source/tasks.c **** 
4205:../FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
4206:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4207:../FreeRTOS/Source/tasks.c **** 
4208:../FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4209:../FreeRTOS/Source/tasks.c **** 
4210:../FreeRTOS/Source/tasks.c ****     void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder,
4211:../FreeRTOS/Source/tasks.c ****                                               UBaseType_t uxHighestPriorityWaitingTask )
4212:../FreeRTOS/Source/tasks.c ****     {
4213:../FreeRTOS/Source/tasks.c ****         TCB_t * const pxTCB = pxMutexHolder;
4214:../FreeRTOS/Source/tasks.c ****         UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
4215:../FreeRTOS/Source/tasks.c ****         const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
4216:../FreeRTOS/Source/tasks.c **** 
4217:../FreeRTOS/Source/tasks.c ****         if( pxMutexHolder != NULL )
4218:../FreeRTOS/Source/tasks.c ****         {
4219:../FreeRTOS/Source/tasks.c ****             /* If pxMutexHolder is not NULL then the holder must hold at least
4220:../FreeRTOS/Source/tasks.c ****              * one mutex. */
4221:../FreeRTOS/Source/tasks.c ****             configASSERT( pxTCB->uxMutexesHeld );
4222:../FreeRTOS/Source/tasks.c **** 
4223:../FreeRTOS/Source/tasks.c ****             /* Determine the priority to which the priority of the task that
4224:../FreeRTOS/Source/tasks.c ****              * holds the mutex should be set.  This will be the greater of the
4225:../FreeRTOS/Source/tasks.c ****              * holding task's base priority and the priority of the highest
4226:../FreeRTOS/Source/tasks.c ****              * priority task that is waiting to obtain the mutex. */
4227:../FreeRTOS/Source/tasks.c ****             if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
4228:../FreeRTOS/Source/tasks.c ****             {
4229:../FreeRTOS/Source/tasks.c ****                 uxPriorityToUse = uxHighestPriorityWaitingTask;
4230:../FreeRTOS/Source/tasks.c ****             }
4231:../FreeRTOS/Source/tasks.c ****             else
4232:../FreeRTOS/Source/tasks.c ****             {
4233:../FreeRTOS/Source/tasks.c ****                 uxPriorityToUse = pxTCB->uxBasePriority;
4234:../FreeRTOS/Source/tasks.c ****             }
4235:../FreeRTOS/Source/tasks.c **** 
4236:../FreeRTOS/Source/tasks.c ****             /* Does the priority need to change? */
4237:../FreeRTOS/Source/tasks.c ****             if( pxTCB->uxPriority != uxPriorityToUse )
4238:../FreeRTOS/Source/tasks.c ****             {
4239:../FreeRTOS/Source/tasks.c ****                 /* Only disinherit if no other mutexes are held.  This is a
4240:../FreeRTOS/Source/tasks.c ****                  * simplification in the priority inheritance implementation.  If
4241:../FreeRTOS/Source/tasks.c ****                  * the task that holds the mutex is also holding other mutexes then
4242:../FreeRTOS/Source/tasks.c ****                  * the other mutexes may have caused the priority inheritance. */
4243:../FreeRTOS/Source/tasks.c ****                 if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
4244:../FreeRTOS/Source/tasks.c ****                 {
4245:../FreeRTOS/Source/tasks.c ****                     /* If a task has timed out because it already holds the
4246:../FreeRTOS/Source/tasks.c ****                      * mutex it was trying to obtain then it cannot of inherited
4247:../FreeRTOS/Source/tasks.c ****                      * its own priority. */
4248:../FreeRTOS/Source/tasks.c ****                     configASSERT( pxTCB != pxCurrentTCB );
4249:../FreeRTOS/Source/tasks.c **** 
4250:../FreeRTOS/Source/tasks.c ****                     /* Disinherit the priority, remembering the previous
4251:../FreeRTOS/Source/tasks.c ****                      * priority to facilitate determining the subject task's
4252:../FreeRTOS/Source/tasks.c ****                      * state. */
4253:../FreeRTOS/Source/tasks.c ****                     traceTASK_PRIORITY_DISINHERIT( pxTCB, uxPriorityToUse );
4254:../FreeRTOS/Source/tasks.c ****                     uxPriorityUsedOnEntry = pxTCB->uxPriority;
4255:../FreeRTOS/Source/tasks.c ****                     pxTCB->uxPriority = uxPriorityToUse;
4256:../FreeRTOS/Source/tasks.c **** 
4257:../FreeRTOS/Source/tasks.c ****                     /* Only reset the event list item value if the value is not
4258:../FreeRTOS/Source/tasks.c ****                      * being used for anything else. */
4259:../FreeRTOS/Source/tasks.c ****                     if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_IT
4260:../FreeRTOS/Source/tasks.c ****                     {
4261:../FreeRTOS/Source/tasks.c ****                         listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configM
4262:../FreeRTOS/Source/tasks.c ****                     }
4263:../FreeRTOS/Source/tasks.c ****                     else
4264:../FreeRTOS/Source/tasks.c ****                     {
4265:../FreeRTOS/Source/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
4266:../FreeRTOS/Source/tasks.c ****                     }
4267:../FreeRTOS/Source/tasks.c **** 
4268:../FreeRTOS/Source/tasks.c ****                     /* If the running task is not the task that holds the mutex
4269:../FreeRTOS/Source/tasks.c ****                      * then the task that holds the mutex could be in either the
4270:../FreeRTOS/Source/tasks.c ****                      * Ready, Blocked or Suspended states.  Only remove the task
4271:../FreeRTOS/Source/tasks.c ****                      * from its current state list if it is in the Ready state as
4272:../FreeRTOS/Source/tasks.c ****                      * the task's priority is going to change and there is one
4273:../FreeRTOS/Source/tasks.c ****                      * Ready list per priority. */
4274:../FreeRTOS/Source/tasks.c ****                     if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &
4275:../FreeRTOS/Source/tasks.c ****                     {
4276:../FreeRTOS/Source/tasks.c ****                         if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4277:../FreeRTOS/Source/tasks.c ****                         {
4278:../FreeRTOS/Source/tasks.c ****                             /* It is known that the task is in its ready list so
4279:../FreeRTOS/Source/tasks.c ****                              * there is no need to check again and the port level
4280:../FreeRTOS/Source/tasks.c ****                              * reset macro can be called directly. */
4281:../FreeRTOS/Source/tasks.c ****                             portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
4282:../FreeRTOS/Source/tasks.c ****                         }
4283:../FreeRTOS/Source/tasks.c ****                         else
4284:../FreeRTOS/Source/tasks.c ****                         {
4285:../FreeRTOS/Source/tasks.c ****                             mtCOVERAGE_TEST_MARKER();
4286:../FreeRTOS/Source/tasks.c ****                         }
4287:../FreeRTOS/Source/tasks.c **** 
4288:../FreeRTOS/Source/tasks.c ****                         prvAddTaskToReadyList( pxTCB );
4289:../FreeRTOS/Source/tasks.c ****                     }
4290:../FreeRTOS/Source/tasks.c ****                     else
4291:../FreeRTOS/Source/tasks.c ****                     {
4292:../FreeRTOS/Source/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
4293:../FreeRTOS/Source/tasks.c ****                     }
4294:../FreeRTOS/Source/tasks.c ****                 }
4295:../FreeRTOS/Source/tasks.c ****                 else
4296:../FreeRTOS/Source/tasks.c ****                 {
4297:../FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
4298:../FreeRTOS/Source/tasks.c ****                 }
4299:../FreeRTOS/Source/tasks.c ****             }
4300:../FreeRTOS/Source/tasks.c ****             else
4301:../FreeRTOS/Source/tasks.c ****             {
4302:../FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
4303:../FreeRTOS/Source/tasks.c ****             }
4304:../FreeRTOS/Source/tasks.c ****         }
4305:../FreeRTOS/Source/tasks.c ****         else
4306:../FreeRTOS/Source/tasks.c ****         {
4307:../FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
4308:../FreeRTOS/Source/tasks.c ****         }
4309:../FreeRTOS/Source/tasks.c ****     }
4310:../FreeRTOS/Source/tasks.c **** 
4311:../FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
4312:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4313:../FreeRTOS/Source/tasks.c **** 
4314:../FreeRTOS/Source/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
4315:../FreeRTOS/Source/tasks.c **** 
4316:../FreeRTOS/Source/tasks.c ****     void vTaskEnterCritical( void )
4317:../FreeRTOS/Source/tasks.c ****     {
4318:../FreeRTOS/Source/tasks.c ****         portDISABLE_INTERRUPTS();
4319:../FreeRTOS/Source/tasks.c **** 
4320:../FreeRTOS/Source/tasks.c ****         if( xSchedulerRunning != pdFALSE )
4321:../FreeRTOS/Source/tasks.c ****         {
4322:../FreeRTOS/Source/tasks.c ****             ( pxCurrentTCB->uxCriticalNesting )++;
4323:../FreeRTOS/Source/tasks.c **** 
4324:../FreeRTOS/Source/tasks.c ****             /* This is not the interrupt safe version of the enter critical
4325:../FreeRTOS/Source/tasks.c ****              * function so  assert() if it is being called from an interrupt
4326:../FreeRTOS/Source/tasks.c ****              * context.  Only API functions that end in "FromISR" can be used in an
4327:../FreeRTOS/Source/tasks.c ****              * interrupt.  Only assert if the critical nesting count is 1 to
4328:../FreeRTOS/Source/tasks.c ****              * protect against recursive calls if the assert function also uses a
4329:../FreeRTOS/Source/tasks.c ****              * critical section. */
4330:../FreeRTOS/Source/tasks.c ****             if( pxCurrentTCB->uxCriticalNesting == 1 )
4331:../FreeRTOS/Source/tasks.c ****             {
4332:../FreeRTOS/Source/tasks.c ****                 portASSERT_IF_IN_ISR();
4333:../FreeRTOS/Source/tasks.c ****             }
4334:../FreeRTOS/Source/tasks.c ****         }
4335:../FreeRTOS/Source/tasks.c ****         else
4336:../FreeRTOS/Source/tasks.c ****         {
4337:../FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
4338:../FreeRTOS/Source/tasks.c ****         }
4339:../FreeRTOS/Source/tasks.c ****     }
4340:../FreeRTOS/Source/tasks.c **** 
4341:../FreeRTOS/Source/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
4342:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4343:../FreeRTOS/Source/tasks.c **** 
4344:../FreeRTOS/Source/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
4345:../FreeRTOS/Source/tasks.c **** 
4346:../FreeRTOS/Source/tasks.c ****     void vTaskExitCritical( void )
4347:../FreeRTOS/Source/tasks.c ****     {
4348:../FreeRTOS/Source/tasks.c ****         if( xSchedulerRunning != pdFALSE )
4349:../FreeRTOS/Source/tasks.c ****         {
4350:../FreeRTOS/Source/tasks.c ****             if( pxCurrentTCB->uxCriticalNesting > 0U )
4351:../FreeRTOS/Source/tasks.c ****             {
4352:../FreeRTOS/Source/tasks.c ****                 ( pxCurrentTCB->uxCriticalNesting )--;
4353:../FreeRTOS/Source/tasks.c **** 
4354:../FreeRTOS/Source/tasks.c ****                 if( pxCurrentTCB->uxCriticalNesting == 0U )
4355:../FreeRTOS/Source/tasks.c ****                 {
4356:../FreeRTOS/Source/tasks.c ****                     portENABLE_INTERRUPTS();
4357:../FreeRTOS/Source/tasks.c ****                 }
4358:../FreeRTOS/Source/tasks.c ****                 else
4359:../FreeRTOS/Source/tasks.c ****                 {
4360:../FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
4361:../FreeRTOS/Source/tasks.c ****                 }
4362:../FreeRTOS/Source/tasks.c ****             }
4363:../FreeRTOS/Source/tasks.c ****             else
4364:../FreeRTOS/Source/tasks.c ****             {
4365:../FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
4366:../FreeRTOS/Source/tasks.c ****             }
4367:../FreeRTOS/Source/tasks.c ****         }
4368:../FreeRTOS/Source/tasks.c ****         else
4369:../FreeRTOS/Source/tasks.c ****         {
4370:../FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
4371:../FreeRTOS/Source/tasks.c ****         }
4372:../FreeRTOS/Source/tasks.c ****     }
4373:../FreeRTOS/Source/tasks.c **** 
4374:../FreeRTOS/Source/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
4375:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4376:../FreeRTOS/Source/tasks.c **** 
4377:../FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
4378:../FreeRTOS/Source/tasks.c **** 
4379:../FreeRTOS/Source/tasks.c ****     static char * prvWriteNameToBuffer( char * pcBuffer,
4380:../FreeRTOS/Source/tasks.c ****                                         const char * pcTaskName )
4381:../FreeRTOS/Source/tasks.c ****     {
4382:../FreeRTOS/Source/tasks.c ****         size_t x;
4383:../FreeRTOS/Source/tasks.c **** 
4384:../FreeRTOS/Source/tasks.c ****         /* Start by copying the entire string. */
4385:../FreeRTOS/Source/tasks.c ****         strcpy( pcBuffer, pcTaskName );
4386:../FreeRTOS/Source/tasks.c **** 
4387:../FreeRTOS/Source/tasks.c ****         /* Pad the end of the string with spaces to ensure columns line up when
4388:../FreeRTOS/Source/tasks.c ****          * printed out. */
4389:../FreeRTOS/Source/tasks.c ****         for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
4390:../FreeRTOS/Source/tasks.c ****         {
4391:../FreeRTOS/Source/tasks.c ****             pcBuffer[ x ] = ' ';
4392:../FreeRTOS/Source/tasks.c ****         }
4393:../FreeRTOS/Source/tasks.c **** 
4394:../FreeRTOS/Source/tasks.c ****         /* Terminate. */
4395:../FreeRTOS/Source/tasks.c ****         pcBuffer[ x ] = ( char ) 0x00;
4396:../FreeRTOS/Source/tasks.c **** 
4397:../FreeRTOS/Source/tasks.c ****         /* Return the new end of string. */
4398:../FreeRTOS/Source/tasks.c ****         return &( pcBuffer[ x ] );
4399:../FreeRTOS/Source/tasks.c ****     }
4400:../FreeRTOS/Source/tasks.c **** 
4401:../FreeRTOS/Source/tasks.c **** #endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
4402:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4403:../FreeRTOS/Source/tasks.c **** 
4404:../FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( config
4405:../FreeRTOS/Source/tasks.c **** 
4406:../FreeRTOS/Source/tasks.c ****     void vTaskList( char * pcWriteBuffer )
4407:../FreeRTOS/Source/tasks.c ****     {
4408:../FreeRTOS/Source/tasks.c ****         TaskStatus_t * pxTaskStatusArray;
4409:../FreeRTOS/Source/tasks.c ****         UBaseType_t uxArraySize, x;
4410:../FreeRTOS/Source/tasks.c ****         char cStatus;
4411:../FreeRTOS/Source/tasks.c **** 
4412:../FreeRTOS/Source/tasks.c ****         /*
4413:../FreeRTOS/Source/tasks.c ****          * PLEASE NOTE:
4414:../FreeRTOS/Source/tasks.c ****          *
4415:../FreeRTOS/Source/tasks.c ****          * This function is provided for convenience only, and is used by many
4416:../FreeRTOS/Source/tasks.c ****          * of the demo applications.  Do not consider it to be part of the
4417:../FreeRTOS/Source/tasks.c ****          * scheduler.
4418:../FreeRTOS/Source/tasks.c ****          *
4419:../FreeRTOS/Source/tasks.c ****          * vTaskList() calls uxTaskGetSystemState(), then formats part of the
4420:../FreeRTOS/Source/tasks.c ****          * uxTaskGetSystemState() output into a human readable table that
4421:../FreeRTOS/Source/tasks.c ****          * displays task names, states and stack usage.
4422:../FreeRTOS/Source/tasks.c ****          *
4423:../FreeRTOS/Source/tasks.c ****          * vTaskList() has a dependency on the sprintf() C library function that
4424:../FreeRTOS/Source/tasks.c ****          * might bloat the code size, use a lot of stack, and provide different
4425:../FreeRTOS/Source/tasks.c ****          * results on different platforms.  An alternative, tiny, third party,
4426:../FreeRTOS/Source/tasks.c ****          * and limited functionality implementation of sprintf() is provided in
4427:../FreeRTOS/Source/tasks.c ****          * many of the FreeRTOS/Demo sub-directories in a file called
4428:../FreeRTOS/Source/tasks.c ****          * printf-stdarg.c (note printf-stdarg.c does not provide a full
4429:../FreeRTOS/Source/tasks.c ****          * snprintf() implementation!).
4430:../FreeRTOS/Source/tasks.c ****          *
4431:../FreeRTOS/Source/tasks.c ****          * It is recommended that production systems call uxTaskGetSystemState()
4432:../FreeRTOS/Source/tasks.c ****          * directly to get access to raw stats data, rather than indirectly
4433:../FreeRTOS/Source/tasks.c ****          * through a call to vTaskList().
4434:../FreeRTOS/Source/tasks.c ****          */
4435:../FreeRTOS/Source/tasks.c **** 
4436:../FreeRTOS/Source/tasks.c **** 
4437:../FreeRTOS/Source/tasks.c ****         /* Make sure the write buffer does not contain a string. */
4438:../FreeRTOS/Source/tasks.c ****         *pcWriteBuffer = ( char ) 0x00;
4439:../FreeRTOS/Source/tasks.c **** 
4440:../FreeRTOS/Source/tasks.c ****         /* Take a snapshot of the number of tasks in case it changes while this
4441:../FreeRTOS/Source/tasks.c ****          * function is executing. */
4442:../FreeRTOS/Source/tasks.c ****         uxArraySize = uxCurrentNumberOfTasks;
4443:../FreeRTOS/Source/tasks.c **** 
4444:../FreeRTOS/Source/tasks.c ****         /* Allocate an array index for each task.  NOTE!  if
4445:../FreeRTOS/Source/tasks.c ****          * configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
4446:../FreeRTOS/Source/tasks.c ****          * equate to NULL. */
4447:../FreeRTOS/Source/tasks.c ****         pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint
4448:../FreeRTOS/Source/tasks.c **** 
4449:../FreeRTOS/Source/tasks.c ****         if( pxTaskStatusArray != NULL )
4450:../FreeRTOS/Source/tasks.c ****         {
4451:../FreeRTOS/Source/tasks.c ****             /* Generate the (binary) data. */
4452:../FreeRTOS/Source/tasks.c ****             uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
4453:../FreeRTOS/Source/tasks.c **** 
4454:../FreeRTOS/Source/tasks.c ****             /* Create a human readable table from the binary data. */
4455:../FreeRTOS/Source/tasks.c ****             for( x = 0; x < uxArraySize; x++ )
4456:../FreeRTOS/Source/tasks.c ****             {
4457:../FreeRTOS/Source/tasks.c ****                 switch( pxTaskStatusArray[ x ].eCurrentState )
4458:../FreeRTOS/Source/tasks.c ****                 {
4459:../FreeRTOS/Source/tasks.c ****                     case eRunning:
4460:../FreeRTOS/Source/tasks.c ****                         cStatus = tskRUNNING_CHAR;
4461:../FreeRTOS/Source/tasks.c ****                         break;
4462:../FreeRTOS/Source/tasks.c **** 
4463:../FreeRTOS/Source/tasks.c ****                     case eReady:
4464:../FreeRTOS/Source/tasks.c ****                         cStatus = tskREADY_CHAR;
4465:../FreeRTOS/Source/tasks.c ****                         break;
4466:../FreeRTOS/Source/tasks.c **** 
4467:../FreeRTOS/Source/tasks.c ****                     case eBlocked:
4468:../FreeRTOS/Source/tasks.c ****                         cStatus = tskBLOCKED_CHAR;
4469:../FreeRTOS/Source/tasks.c ****                         break;
4470:../FreeRTOS/Source/tasks.c **** 
4471:../FreeRTOS/Source/tasks.c ****                     case eSuspended:
4472:../FreeRTOS/Source/tasks.c ****                         cStatus = tskSUSPENDED_CHAR;
4473:../FreeRTOS/Source/tasks.c ****                         break;
4474:../FreeRTOS/Source/tasks.c **** 
4475:../FreeRTOS/Source/tasks.c ****                     case eDeleted:
4476:../FreeRTOS/Source/tasks.c ****                         cStatus = tskDELETED_CHAR;
4477:../FreeRTOS/Source/tasks.c ****                         break;
4478:../FreeRTOS/Source/tasks.c **** 
4479:../FreeRTOS/Source/tasks.c ****                     case eInvalid: /* Fall through. */
4480:../FreeRTOS/Source/tasks.c ****                     default:       /* Should not get here, but it is included
4481:../FreeRTOS/Source/tasks.c ****                                     * to prevent static checking errors. */
4482:../FreeRTOS/Source/tasks.c ****                         cStatus = ( char ) 0x00;
4483:../FreeRTOS/Source/tasks.c ****                         break;
4484:../FreeRTOS/Source/tasks.c ****                 }
4485:../FreeRTOS/Source/tasks.c **** 
4486:../FreeRTOS/Source/tasks.c ****                 /* Write the task name to the string, padding with spaces so it
4487:../FreeRTOS/Source/tasks.c ****                  * can be printed in tabular form more easily. */
4488:../FreeRTOS/Source/tasks.c ****                 pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskN
4489:../FreeRTOS/Source/tasks.c **** 
4490:../FreeRTOS/Source/tasks.c ****                 /* Write the rest of the string. */
4491:../FreeRTOS/Source/tasks.c ****                 sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskSta
4492:../FreeRTOS/Source/tasks.c ****                 pcWriteBuffer += strlen( pcWriteBuffer );                                          
4493:../FreeRTOS/Source/tasks.c ****             }
4494:../FreeRTOS/Source/tasks.c **** 
4495:../FreeRTOS/Source/tasks.c ****             /* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4496:../FreeRTOS/Source/tasks.c ****              * is 0 then vPortFree() will be #defined to nothing. */
4497:../FreeRTOS/Source/tasks.c ****             vPortFree( pxTaskStatusArray );
4498:../FreeRTOS/Source/tasks.c ****         }
4499:../FreeRTOS/Source/tasks.c ****         else
4500:../FreeRTOS/Source/tasks.c ****         {
4501:../FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
4502:../FreeRTOS/Source/tasks.c ****         }
4503:../FreeRTOS/Source/tasks.c ****     }
4504:../FreeRTOS/Source/tasks.c **** 
4505:../FreeRTOS/Source/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( 
4506:../FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
4507:../FreeRTOS/Source/tasks.c **** 
4508:../FreeRTOS/Source/tasks.c **** #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( c
4509:../FreeRTOS/Source/tasks.c **** 
4510:../FreeRTOS/Source/tasks.c ****     void vTaskGetRunTimeStats( char * pcWriteBuffer )
4511:../FreeRTOS/Source/tasks.c ****     {
4512:../FreeRTOS/Source/tasks.c ****         TaskStatus_t * pxTaskStatusArray;
4513:../FreeRTOS/Source/tasks.c ****         UBaseType_t uxArraySize, x;
4514:../FreeRTOS/Source/tasks.c ****         uint32_t ulTotalTime, ulStatsAsPercentage;
4515:../FreeRTOS/Source/tasks.c **** 
4516:../FreeRTOS/Source/tasks.c ****         #if ( configUSE_TRACE_FACILITY != 1 )
4517:../FreeRTOS/Source/tasks.c ****             {
4518:../FreeRTOS/Source/tasks.c ****                 #error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vT
4519:../FreeRTOS/Source/tasks.c ****             }
4520:../FreeRTOS/Source/tasks.c ****         #endif
4521:../FreeRTOS/Source/tasks.c **** 
4522:../FreeRTOS/Source/tasks.c ****         /*
4523:../FreeRTOS/Source/tasks.c ****          * PLEASE NOTE:
4524:../FreeRTOS/Source/tasks.c ****          *
4525:../FreeRTOS/Source/tasks.c ****          * This function is provided for convenience only, and is used by many
4526:../FreeRTOS/Source/tasks.c ****          * of the demo applications.  Do not consider it to be part of the
4527:../FreeRTOS/Source/tasks.c ****          * scheduler.
4528:../FreeRTOS/Source/tasks.c ****          *
4529:../FreeRTOS/Source/tasks.c ****          * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
4530:../FreeRTOS/Source/tasks.c ****          * of the uxTaskGetSystemState() output into a human readable table that
4531:../FreeRTOS/Source/tasks.c ****          * displays the amount of time each task has spent in the Running state
4532:../FreeRTOS/Source/tasks.c ****          * in both absolute and percentage terms.
4533:../FreeRTOS/Source/tasks.c ****          *
4534:../FreeRTOS/Source/tasks.c ****          * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
4535:../FreeRTOS/Source/tasks.c ****          * function that might bloat the code size, use a lot of stack, and
4536:../FreeRTOS/Source/tasks.c ****          * provide different results on different platforms.  An alternative,
4537:../FreeRTOS/Source/tasks.c ****          * tiny, third party, and limited functionality implementation of
4538:../FreeRTOS/Source/tasks.c ****          * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
4539:../FreeRTOS/Source/tasks.c ****          * a file called printf-stdarg.c (note printf-stdarg.c does not provide
4540:../FreeRTOS/Source/tasks.c ****          * a full snprintf() implementation!).
4541:../FreeRTOS/Source/tasks.c ****          *
4542:../FreeRTOS/Source/tasks.c ****          * It is recommended that production systems call uxTaskGetSystemState()
4543:../FreeRTOS/Source/tasks.c ****          * directly to get access to raw stats data, rather than indirectly
4544:../FreeRTOS/Source/tasks.c ****          * through a call to vTaskGetRunTimeStats().
4545:../FreeRTOS/Source/tasks.c ****          */
4546:../FreeRTOS/Source/tasks.c **** 
4547:../FreeRTOS/Source/tasks.c ****         /* Make sure the write buffer does not contain a string. */
4548:../FreeRTOS/Source/tasks.c ****         *pcWriteBuffer = ( char ) 0x00;
4549:../FreeRTOS/Source/tasks.c **** 
4550:../FreeRTOS/Source/tasks.c ****         /* Take a snapshot of the number of tasks in case it changes while this
4551:../FreeRTOS/Source/tasks.c ****          * function is executing. */
4552:../FreeRTOS/Source/tasks.c ****         uxArraySize = uxCurrentNumberOfTasks;
4553:../FreeRTOS/Source/tasks.c **** 
4554:../FreeRTOS/Source/tasks.c ****         /* Allocate an array index for each task.  NOTE!  If
4555:../FreeRTOS/Source/tasks.c ****          * configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
4556:../FreeRTOS/Source/tasks.c ****          * equate to NULL. */
4557:../FreeRTOS/Source/tasks.c ****         pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint
4558:../FreeRTOS/Source/tasks.c **** 
4559:../FreeRTOS/Source/tasks.c ****         if( pxTaskStatusArray != NULL )
4560:../FreeRTOS/Source/tasks.c ****         {
4561:../FreeRTOS/Source/tasks.c ****             /* Generate the (binary) data. */
4562:../FreeRTOS/Source/tasks.c ****             uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
4563:../FreeRTOS/Source/tasks.c **** 
4564:../FreeRTOS/Source/tasks.c ****             /* For percentage calculations. */
4565:../FreeRTOS/Source/tasks.c ****             ulTotalTime /= 100UL;
4566:../FreeRTOS/Source/tasks.c **** 
4567:../FreeRTOS/Source/tasks.c ****             /* Avoid divide by zero errors. */
4568:../FreeRTOS/Source/tasks.c ****             if( ulTotalTime > 0UL )
4569:../FreeRTOS/Source/tasks.c ****             {
4570:../FreeRTOS/Source/tasks.c ****                 /* Create a human readable table from the binary data. */
4571:../FreeRTOS/Source/tasks.c ****                 for( x = 0; x < uxArraySize; x++ )
4572:../FreeRTOS/Source/tasks.c ****                 {
4573:../FreeRTOS/Source/tasks.c ****                     /* What percentage of the total run time has the task used?
4574:../FreeRTOS/Source/tasks.c ****                      * This will always be rounded down to the nearest integer.
4575:../FreeRTOS/Source/tasks.c ****                      * ulTotalRunTimeDiv100 has already been divided by 100. */
4576:../FreeRTOS/Source/tasks.c ****                     ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
4577:../FreeRTOS/Source/tasks.c **** 
4578:../FreeRTOS/Source/tasks.c ****                     /* Write the task name to the string, padding with
4579:../FreeRTOS/Source/tasks.c ****                      * spaces so it can be printed in tabular form more
4580:../FreeRTOS/Source/tasks.c ****                      * easily. */
4581:../FreeRTOS/Source/tasks.c ****                     pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcT
4582:../FreeRTOS/Source/tasks.c **** 
4583:../FreeRTOS/Source/tasks.c ****                     if( ulStatsAsPercentage > 0UL )
4584:../FreeRTOS/Source/tasks.c ****                     {
4585:../FreeRTOS/Source/tasks.c ****                         #ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4586:../FreeRTOS/Source/tasks.c ****                             {
4587:../FreeRTOS/Source/tasks.c ****                                 sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x 
4588:../FreeRTOS/Source/tasks.c ****                             }
4589:../FreeRTOS/Source/tasks.c ****                         #else
4590:../FreeRTOS/Source/tasks.c ****                             {
4591:../FreeRTOS/Source/tasks.c ****                                 /* sizeof( int ) == sizeof( long ) so a smaller
4592:../FreeRTOS/Source/tasks.c ****                                  * printf() library can be used. */
4593:../FreeRTOS/Source/tasks.c ****                                 sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTask
4594:../FreeRTOS/Source/tasks.c ****                             }
4595:../FreeRTOS/Source/tasks.c ****                         #endif
4596:../FreeRTOS/Source/tasks.c ****                     }
4597:../FreeRTOS/Source/tasks.c ****                     else
4598:../FreeRTOS/Source/tasks.c ****                     {
4599:../FreeRTOS/Source/tasks.c ****                         /* If the percentage is zero here then the task has
4600:../FreeRTOS/Source/tasks.c ****                          * consumed less than 1% of the total run time. */
4601:../FreeRTOS/Source/tasks.c ****                         #ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4602:../FreeRTOS/Source/tasks.c ****                             {
4603:../FreeRTOS/Source/tasks.c ****                                 sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ]
4604:../FreeRTOS/Source/tasks.c ****                             }
4605:../FreeRTOS/Source/tasks.c ****                         #else
4606:../FreeRTOS/Source/tasks.c ****                             {
4607:../FreeRTOS/Source/tasks.c ****                                 /* sizeof( int ) == sizeof( long ) so a smaller
4608:../FreeRTOS/Source/tasks.c ****                                  * printf() library can be used. */
4609:../FreeRTOS/Source/tasks.c ****                                 sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTask
4610:../FreeRTOS/Source/tasks.c ****                             }
4611:../FreeRTOS/Source/tasks.c ****                         #endif
4612:../FreeRTOS/Source/tasks.c ****                     }
4613:../FreeRTOS/Source/tasks.c **** 
4614:../FreeRTOS/Source/tasks.c ****                     pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok o
4615:../FreeRTOS/Source/tasks.c ****                 }
4616:../FreeRTOS/Source/tasks.c ****             }
4617:../FreeRTOS/Source/tasks.c ****             else
4618:../FreeRTOS/Source/tasks.c ****             {
4619:../FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
4620:../FreeRTOS/Source/tasks.c ****             }
4621:../FreeRTOS/Source/tasks.c **** 
4622:../FreeRTOS/Source/tasks.c ****             /* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4623:../FreeRTOS/Source/tasks.c ****              * is 0 then vPortFree() will be #defined to nothing. */
4624:../FreeRTOS/Source/tasks.c ****             vPortFree( pxTaskStatusArray );
4625:../FreeRTOS/Source/tasks.c ****         }
4626:../FreeRTOS/Source/tasks.c ****         else
4627:../FreeRTOS/Source/tasks.c ****         {
4628:../FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
4629:../FreeRTOS/Source/tasks.c ****         }
4630:../FreeRTOS/Source/tasks.c ****     }
4631:../FreeRTOS/Source/tasks.c **** 
4632:../FreeRTOS/Source/tasks.c **** #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) 
4633:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4634:../FreeRTOS/Source/tasks.c **** 
4635:../FreeRTOS/Source/tasks.c **** TickType_t uxTaskResetEventItemValue( void )
4636:../FreeRTOS/Source/tasks.c **** {
4637:../FreeRTOS/Source/tasks.c ****     TickType_t uxReturn;
4638:../FreeRTOS/Source/tasks.c **** 
4639:../FreeRTOS/Source/tasks.c ****     uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
4640:../FreeRTOS/Source/tasks.c **** 
4641:../FreeRTOS/Source/tasks.c ****     /* Reset the event list item to its normal value - so it can be used with
4642:../FreeRTOS/Source/tasks.c ****      * queues and semaphores. */
4643:../FreeRTOS/Source/tasks.c ****     listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITI
4644:../FreeRTOS/Source/tasks.c **** 
4645:../FreeRTOS/Source/tasks.c ****     return uxReturn;
4646:../FreeRTOS/Source/tasks.c **** }
4647:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4648:../FreeRTOS/Source/tasks.c **** 
4649:../FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4650:../FreeRTOS/Source/tasks.c **** 
4651:../FreeRTOS/Source/tasks.c ****     TaskHandle_t pvTaskIncrementMutexHeldCount( void )
4652:../FreeRTOS/Source/tasks.c ****     {
4653:../FreeRTOS/Source/tasks.c ****         /* If xSemaphoreCreateMutex() is called before any tasks have been created
4654:../FreeRTOS/Source/tasks.c ****          * then pxCurrentTCB will be NULL. */
4655:../FreeRTOS/Source/tasks.c ****         if( pxCurrentTCB != NULL )
4656:../FreeRTOS/Source/tasks.c ****         {
4657:../FreeRTOS/Source/tasks.c ****             ( pxCurrentTCB->uxMutexesHeld )++;
4658:../FreeRTOS/Source/tasks.c ****         }
4659:../FreeRTOS/Source/tasks.c **** 
4660:../FreeRTOS/Source/tasks.c ****         return pxCurrentTCB;
4661:../FreeRTOS/Source/tasks.c ****     }
4662:../FreeRTOS/Source/tasks.c **** 
4663:../FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
4664:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4665:../FreeRTOS/Source/tasks.c **** 
4666:../FreeRTOS/Source/tasks.c **** #if ( configUSE_TASK_NOTIFICATIONS == 1 )
4667:../FreeRTOS/Source/tasks.c **** 
4668:../FreeRTOS/Source/tasks.c ****     uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
4669:../FreeRTOS/Source/tasks.c ****                                       BaseType_t xClearCountOnExit,
4670:../FreeRTOS/Source/tasks.c ****                                       TickType_t xTicksToWait )
4671:../FreeRTOS/Source/tasks.c ****     {
4672:../FreeRTOS/Source/tasks.c ****         uint32_t ulReturn;
4673:../FreeRTOS/Source/tasks.c **** 
4674:../FreeRTOS/Source/tasks.c ****         configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );
4675:../FreeRTOS/Source/tasks.c **** 
4676:../FreeRTOS/Source/tasks.c ****         taskENTER_CRITICAL();
4677:../FreeRTOS/Source/tasks.c ****         {
4678:../FreeRTOS/Source/tasks.c ****             /* Only block if the notification count is not already non-zero. */
4679:../FreeRTOS/Source/tasks.c ****             if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
4680:../FreeRTOS/Source/tasks.c ****             {
4681:../FreeRTOS/Source/tasks.c ****                 /* Mark this task as waiting for a notification. */
4682:../FreeRTOS/Source/tasks.c ****                 pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
4683:../FreeRTOS/Source/tasks.c **** 
4684:../FreeRTOS/Source/tasks.c ****                 if( xTicksToWait > ( TickType_t ) 0 )
4685:../FreeRTOS/Source/tasks.c ****                 {
4686:../FreeRTOS/Source/tasks.c ****                     prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
4687:../FreeRTOS/Source/tasks.c ****                     traceTASK_NOTIFY_TAKE_BLOCK( uxIndexToWait );
4688:../FreeRTOS/Source/tasks.c **** 
4689:../FreeRTOS/Source/tasks.c ****                     /* All ports are written to allow a yield in a critical
4690:../FreeRTOS/Source/tasks.c ****                      * section (some will yield immediately, others wait until the
4691:../FreeRTOS/Source/tasks.c ****                      * critical section exits) - but it is not something that
4692:../FreeRTOS/Source/tasks.c ****                      * application code should ever do. */
4693:../FreeRTOS/Source/tasks.c ****                     portYIELD_WITHIN_API();
4694:../FreeRTOS/Source/tasks.c ****                 }
4695:../FreeRTOS/Source/tasks.c ****                 else
4696:../FreeRTOS/Source/tasks.c ****                 {
4697:../FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
4698:../FreeRTOS/Source/tasks.c ****                 }
4699:../FreeRTOS/Source/tasks.c ****             }
4700:../FreeRTOS/Source/tasks.c ****             else
4701:../FreeRTOS/Source/tasks.c ****             {
4702:../FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
4703:../FreeRTOS/Source/tasks.c ****             }
4704:../FreeRTOS/Source/tasks.c ****         }
4705:../FreeRTOS/Source/tasks.c ****         taskEXIT_CRITICAL();
4706:../FreeRTOS/Source/tasks.c **** 
4707:../FreeRTOS/Source/tasks.c ****         taskENTER_CRITICAL();
4708:../FreeRTOS/Source/tasks.c ****         {
4709:../FreeRTOS/Source/tasks.c ****             traceTASK_NOTIFY_TAKE( uxIndexToWait );
4710:../FreeRTOS/Source/tasks.c ****             ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
4711:../FreeRTOS/Source/tasks.c **** 
4712:../FreeRTOS/Source/tasks.c ****             if( ulReturn != 0UL )
4713:../FreeRTOS/Source/tasks.c ****             {
4714:../FreeRTOS/Source/tasks.c ****                 if( xClearCountOnExit != pdFALSE )
4715:../FreeRTOS/Source/tasks.c ****                 {
4716:../FreeRTOS/Source/tasks.c ****                     pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
4717:../FreeRTOS/Source/tasks.c ****                 }
4718:../FreeRTOS/Source/tasks.c ****                 else
4719:../FreeRTOS/Source/tasks.c ****                 {
4720:../FreeRTOS/Source/tasks.c ****                     pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
4721:../FreeRTOS/Source/tasks.c ****                 }
4722:../FreeRTOS/Source/tasks.c ****             }
4723:../FreeRTOS/Source/tasks.c ****             else
4724:../FreeRTOS/Source/tasks.c ****             {
4725:../FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
4726:../FreeRTOS/Source/tasks.c ****             }
4727:../FreeRTOS/Source/tasks.c **** 
4728:../FreeRTOS/Source/tasks.c ****             pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
4729:../FreeRTOS/Source/tasks.c ****         }
4730:../FreeRTOS/Source/tasks.c ****         taskEXIT_CRITICAL();
4731:../FreeRTOS/Source/tasks.c **** 
4732:../FreeRTOS/Source/tasks.c ****         return ulReturn;
4733:../FreeRTOS/Source/tasks.c ****     }
4734:../FreeRTOS/Source/tasks.c **** 
4735:../FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4736:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4737:../FreeRTOS/Source/tasks.c **** 
4738:../FreeRTOS/Source/tasks.c **** #if ( configUSE_TASK_NOTIFICATIONS == 1 )
4739:../FreeRTOS/Source/tasks.c **** 
4740:../FreeRTOS/Source/tasks.c ****     BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
4741:../FreeRTOS/Source/tasks.c ****                                        uint32_t ulBitsToClearOnEntry,
4742:../FreeRTOS/Source/tasks.c ****                                        uint32_t ulBitsToClearOnExit,
4743:../FreeRTOS/Source/tasks.c ****                                        uint32_t * pulNotificationValue,
4744:../FreeRTOS/Source/tasks.c ****                                        TickType_t xTicksToWait )
4745:../FreeRTOS/Source/tasks.c ****     {
4746:../FreeRTOS/Source/tasks.c ****         BaseType_t xReturn;
4747:../FreeRTOS/Source/tasks.c **** 
4748:../FreeRTOS/Source/tasks.c ****         configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );
4749:../FreeRTOS/Source/tasks.c **** 
4750:../FreeRTOS/Source/tasks.c ****         taskENTER_CRITICAL();
4751:../FreeRTOS/Source/tasks.c ****         {
4752:../FreeRTOS/Source/tasks.c ****             /* Only block if a notification is not already pending. */
4753:../FreeRTOS/Source/tasks.c ****             if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
4754:../FreeRTOS/Source/tasks.c ****             {
4755:../FreeRTOS/Source/tasks.c ****                 /* Clear bits in the task's notification value as bits may get
4756:../FreeRTOS/Source/tasks.c ****                  * set  by the notifying task or interrupt.  This can be used to
4757:../FreeRTOS/Source/tasks.c ****                  * clear the value to zero. */
4758:../FreeRTOS/Source/tasks.c ****                 pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
4759:../FreeRTOS/Source/tasks.c **** 
4760:../FreeRTOS/Source/tasks.c ****                 /* Mark this task as waiting for a notification. */
4761:../FreeRTOS/Source/tasks.c ****                 pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
4762:../FreeRTOS/Source/tasks.c **** 
4763:../FreeRTOS/Source/tasks.c ****                 if( xTicksToWait > ( TickType_t ) 0 )
4764:../FreeRTOS/Source/tasks.c ****                 {
4765:../FreeRTOS/Source/tasks.c ****                     prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
4766:../FreeRTOS/Source/tasks.c ****                     traceTASK_NOTIFY_WAIT_BLOCK( uxIndexToWait );
4767:../FreeRTOS/Source/tasks.c **** 
4768:../FreeRTOS/Source/tasks.c ****                     /* All ports are written to allow a yield in a critical
4769:../FreeRTOS/Source/tasks.c ****                      * section (some will yield immediately, others wait until the
4770:../FreeRTOS/Source/tasks.c ****                      * critical section exits) - but it is not something that
4771:../FreeRTOS/Source/tasks.c ****                      * application code should ever do. */
4772:../FreeRTOS/Source/tasks.c ****                     portYIELD_WITHIN_API();
4773:../FreeRTOS/Source/tasks.c ****                 }
4774:../FreeRTOS/Source/tasks.c ****                 else
4775:../FreeRTOS/Source/tasks.c ****                 {
4776:../FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
4777:../FreeRTOS/Source/tasks.c ****                 }
4778:../FreeRTOS/Source/tasks.c ****             }
4779:../FreeRTOS/Source/tasks.c ****             else
4780:../FreeRTOS/Source/tasks.c ****             {
4781:../FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
4782:../FreeRTOS/Source/tasks.c ****             }
4783:../FreeRTOS/Source/tasks.c ****         }
4784:../FreeRTOS/Source/tasks.c ****         taskEXIT_CRITICAL();
4785:../FreeRTOS/Source/tasks.c **** 
4786:../FreeRTOS/Source/tasks.c ****         taskENTER_CRITICAL();
4787:../FreeRTOS/Source/tasks.c ****         {
4788:../FreeRTOS/Source/tasks.c ****             traceTASK_NOTIFY_WAIT( uxIndexToWait );
4789:../FreeRTOS/Source/tasks.c **** 
4790:../FreeRTOS/Source/tasks.c ****             if( pulNotificationValue != NULL )
4791:../FreeRTOS/Source/tasks.c ****             {
4792:../FreeRTOS/Source/tasks.c ****                 /* Output the current notification value, which may or may not
4793:../FreeRTOS/Source/tasks.c ****                  * have changed. */
4794:../FreeRTOS/Source/tasks.c ****                 *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
4795:../FreeRTOS/Source/tasks.c ****             }
4796:../FreeRTOS/Source/tasks.c **** 
4797:../FreeRTOS/Source/tasks.c ****             /* If ucNotifyValue is set then either the task never entered the
4798:../FreeRTOS/Source/tasks.c ****              * blocked state (because a notification was already pending) or the
4799:../FreeRTOS/Source/tasks.c ****              * task unblocked because of a notification.  Otherwise the task
4800:../FreeRTOS/Source/tasks.c ****              * unblocked because of a timeout. */
4801:../FreeRTOS/Source/tasks.c ****             if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
4802:../FreeRTOS/Source/tasks.c ****             {
4803:../FreeRTOS/Source/tasks.c ****                 /* A notification was not received. */
4804:../FreeRTOS/Source/tasks.c ****                 xReturn = pdFALSE;
4805:../FreeRTOS/Source/tasks.c ****             }
4806:../FreeRTOS/Source/tasks.c ****             else
4807:../FreeRTOS/Source/tasks.c ****             {
4808:../FreeRTOS/Source/tasks.c ****                 /* A notification was already pending or a notification was
4809:../FreeRTOS/Source/tasks.c ****                  * received while the task was waiting. */
4810:../FreeRTOS/Source/tasks.c ****                 pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
4811:../FreeRTOS/Source/tasks.c ****                 xReturn = pdTRUE;
4812:../FreeRTOS/Source/tasks.c ****             }
4813:../FreeRTOS/Source/tasks.c **** 
4814:../FreeRTOS/Source/tasks.c ****             pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
4815:../FreeRTOS/Source/tasks.c ****         }
4816:../FreeRTOS/Source/tasks.c ****         taskEXIT_CRITICAL();
4817:../FreeRTOS/Source/tasks.c **** 
4818:../FreeRTOS/Source/tasks.c ****         return xReturn;
4819:../FreeRTOS/Source/tasks.c ****     }
4820:../FreeRTOS/Source/tasks.c **** 
4821:../FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4822:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4823:../FreeRTOS/Source/tasks.c **** 
4824:../FreeRTOS/Source/tasks.c **** #if ( configUSE_TASK_NOTIFICATIONS == 1 )
4825:../FreeRTOS/Source/tasks.c **** 
4826:../FreeRTOS/Source/tasks.c ****     BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
4827:../FreeRTOS/Source/tasks.c ****                                    UBaseType_t uxIndexToNotify,
4828:../FreeRTOS/Source/tasks.c ****                                    uint32_t ulValue,
4829:../FreeRTOS/Source/tasks.c ****                                    eNotifyAction eAction,
4830:../FreeRTOS/Source/tasks.c ****                                    uint32_t * pulPreviousNotificationValue )
4831:../FreeRTOS/Source/tasks.c ****     {
4832:../FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
4833:../FreeRTOS/Source/tasks.c ****         BaseType_t xReturn = pdPASS;
4834:../FreeRTOS/Source/tasks.c ****         uint8_t ucOriginalNotifyState;
4835:../FreeRTOS/Source/tasks.c **** 
4836:../FreeRTOS/Source/tasks.c ****         configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
4837:../FreeRTOS/Source/tasks.c ****         configASSERT( xTaskToNotify );
4838:../FreeRTOS/Source/tasks.c ****         pxTCB = xTaskToNotify;
4839:../FreeRTOS/Source/tasks.c **** 
4840:../FreeRTOS/Source/tasks.c ****         taskENTER_CRITICAL();
4841:../FreeRTOS/Source/tasks.c ****         {
4842:../FreeRTOS/Source/tasks.c ****             if( pulPreviousNotificationValue != NULL )
4843:../FreeRTOS/Source/tasks.c ****             {
4844:../FreeRTOS/Source/tasks.c ****                 *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
4845:../FreeRTOS/Source/tasks.c ****             }
4846:../FreeRTOS/Source/tasks.c **** 
4847:../FreeRTOS/Source/tasks.c ****             ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
4848:../FreeRTOS/Source/tasks.c **** 
4849:../FreeRTOS/Source/tasks.c ****             pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
4850:../FreeRTOS/Source/tasks.c **** 
4851:../FreeRTOS/Source/tasks.c ****             switch( eAction )
4852:../FreeRTOS/Source/tasks.c ****             {
4853:../FreeRTOS/Source/tasks.c ****                 case eSetBits:
4854:../FreeRTOS/Source/tasks.c ****                     pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
4855:../FreeRTOS/Source/tasks.c ****                     break;
4856:../FreeRTOS/Source/tasks.c **** 
4857:../FreeRTOS/Source/tasks.c ****                 case eIncrement:
4858:../FreeRTOS/Source/tasks.c ****                     ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
4859:../FreeRTOS/Source/tasks.c ****                     break;
4860:../FreeRTOS/Source/tasks.c **** 
4861:../FreeRTOS/Source/tasks.c ****                 case eSetValueWithOverwrite:
4862:../FreeRTOS/Source/tasks.c ****                     pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
4863:../FreeRTOS/Source/tasks.c ****                     break;
4864:../FreeRTOS/Source/tasks.c **** 
4865:../FreeRTOS/Source/tasks.c ****                 case eSetValueWithoutOverwrite:
4866:../FreeRTOS/Source/tasks.c **** 
4867:../FreeRTOS/Source/tasks.c ****                     if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
4868:../FreeRTOS/Source/tasks.c ****                     {
4869:../FreeRTOS/Source/tasks.c ****                         pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
4870:../FreeRTOS/Source/tasks.c ****                     }
4871:../FreeRTOS/Source/tasks.c ****                     else
4872:../FreeRTOS/Source/tasks.c ****                     {
4873:../FreeRTOS/Source/tasks.c ****                         /* The value could not be written to the task. */
4874:../FreeRTOS/Source/tasks.c ****                         xReturn = pdFAIL;
4875:../FreeRTOS/Source/tasks.c ****                     }
4876:../FreeRTOS/Source/tasks.c **** 
4877:../FreeRTOS/Source/tasks.c ****                     break;
4878:../FreeRTOS/Source/tasks.c **** 
4879:../FreeRTOS/Source/tasks.c ****                 case eNoAction:
4880:../FreeRTOS/Source/tasks.c **** 
4881:../FreeRTOS/Source/tasks.c ****                     /* The task is being notified without its notify value being
4882:../FreeRTOS/Source/tasks.c ****                      * updated. */
4883:../FreeRTOS/Source/tasks.c ****                     break;
4884:../FreeRTOS/Source/tasks.c **** 
4885:../FreeRTOS/Source/tasks.c ****                 default:
4886:../FreeRTOS/Source/tasks.c **** 
4887:../FreeRTOS/Source/tasks.c ****                     /* Should not get here if all enums are handled.
4888:../FreeRTOS/Source/tasks.c ****                      * Artificially force an assert by testing a value the
4889:../FreeRTOS/Source/tasks.c ****                      * compiler can't assume is const. */
4890:../FreeRTOS/Source/tasks.c ****                     configASSERT( xTickCount == ( TickType_t ) 0 );
4891:../FreeRTOS/Source/tasks.c **** 
4892:../FreeRTOS/Source/tasks.c ****                     break;
4893:../FreeRTOS/Source/tasks.c ****             }
4894:../FreeRTOS/Source/tasks.c **** 
4895:../FreeRTOS/Source/tasks.c ****             traceTASK_NOTIFY( uxIndexToNotify );
4896:../FreeRTOS/Source/tasks.c **** 
4897:../FreeRTOS/Source/tasks.c ****             /* If the task is in the blocked state specifically to wait for a
4898:../FreeRTOS/Source/tasks.c ****              * notification then unblock it now. */
4899:../FreeRTOS/Source/tasks.c ****             if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
4900:../FreeRTOS/Source/tasks.c ****             {
4901:../FreeRTOS/Source/tasks.c ****                 ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
4902:../FreeRTOS/Source/tasks.c ****                 prvAddTaskToReadyList( pxTCB );
4903:../FreeRTOS/Source/tasks.c **** 
4904:../FreeRTOS/Source/tasks.c ****                 /* The task should not have been on an event list. */
4905:../FreeRTOS/Source/tasks.c ****                 configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4906:../FreeRTOS/Source/tasks.c **** 
4907:../FreeRTOS/Source/tasks.c ****                 #if ( configUSE_TICKLESS_IDLE != 0 )
4908:../FreeRTOS/Source/tasks.c ****                     {
4909:../FreeRTOS/Source/tasks.c ****                         /* If a task is blocked waiting for a notification then
4910:../FreeRTOS/Source/tasks.c ****                          * xNextTaskUnblockTime might be set to the blocked task's time
4911:../FreeRTOS/Source/tasks.c ****                          * out time.  If the task is unblocked for a reason other than
4912:../FreeRTOS/Source/tasks.c ****                          * a timeout xNextTaskUnblockTime is normally left unchanged,
4913:../FreeRTOS/Source/tasks.c ****                          * because it will automatically get reset to a new value when
4914:../FreeRTOS/Source/tasks.c ****                          * the tick count equals xNextTaskUnblockTime.  However if
4915:../FreeRTOS/Source/tasks.c ****                          * tickless idling is used it might be more important to enter
4916:../FreeRTOS/Source/tasks.c ****                          * sleep mode at the earliest possible time - so reset
4917:../FreeRTOS/Source/tasks.c ****                          * xNextTaskUnblockTime here to ensure it is updated at the
4918:../FreeRTOS/Source/tasks.c ****                          * earliest possible time. */
4919:../FreeRTOS/Source/tasks.c ****                         prvResetNextTaskUnblockTime();
4920:../FreeRTOS/Source/tasks.c ****                     }
4921:../FreeRTOS/Source/tasks.c ****                 #endif
4922:../FreeRTOS/Source/tasks.c **** 
4923:../FreeRTOS/Source/tasks.c ****                 if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
4924:../FreeRTOS/Source/tasks.c ****                 {
4925:../FreeRTOS/Source/tasks.c ****                     /* The notified task has a priority above the currently
4926:../FreeRTOS/Source/tasks.c ****                      * executing task so a yield is required. */
4927:../FreeRTOS/Source/tasks.c ****                     taskYIELD_IF_USING_PREEMPTION();
4928:../FreeRTOS/Source/tasks.c ****                 }
4929:../FreeRTOS/Source/tasks.c ****                 else
4930:../FreeRTOS/Source/tasks.c ****                 {
4931:../FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
4932:../FreeRTOS/Source/tasks.c ****                 }
4933:../FreeRTOS/Source/tasks.c ****             }
4934:../FreeRTOS/Source/tasks.c ****             else
4935:../FreeRTOS/Source/tasks.c ****             {
4936:../FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
4937:../FreeRTOS/Source/tasks.c ****             }
4938:../FreeRTOS/Source/tasks.c ****         }
4939:../FreeRTOS/Source/tasks.c ****         taskEXIT_CRITICAL();
4940:../FreeRTOS/Source/tasks.c **** 
4941:../FreeRTOS/Source/tasks.c ****         return xReturn;
4942:../FreeRTOS/Source/tasks.c ****     }
4943:../FreeRTOS/Source/tasks.c **** 
4944:../FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4945:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4946:../FreeRTOS/Source/tasks.c **** 
4947:../FreeRTOS/Source/tasks.c **** #if ( configUSE_TASK_NOTIFICATIONS == 1 )
4948:../FreeRTOS/Source/tasks.c **** 
4949:../FreeRTOS/Source/tasks.c ****     BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify,
4950:../FreeRTOS/Source/tasks.c ****                                           UBaseType_t uxIndexToNotify,
4951:../FreeRTOS/Source/tasks.c ****                                           uint32_t ulValue,
4952:../FreeRTOS/Source/tasks.c ****                                           eNotifyAction eAction,
4953:../FreeRTOS/Source/tasks.c ****                                           uint32_t * pulPreviousNotificationValue,
4954:../FreeRTOS/Source/tasks.c ****                                           BaseType_t * pxHigherPriorityTaskWoken )
4955:../FreeRTOS/Source/tasks.c ****     {
4956:../FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
4957:../FreeRTOS/Source/tasks.c ****         uint8_t ucOriginalNotifyState;
4958:../FreeRTOS/Source/tasks.c ****         BaseType_t xReturn = pdPASS;
4959:../FreeRTOS/Source/tasks.c ****         UBaseType_t uxSavedInterruptStatus;
4960:../FreeRTOS/Source/tasks.c **** 
4961:../FreeRTOS/Source/tasks.c ****         configASSERT( xTaskToNotify );
4962:../FreeRTOS/Source/tasks.c ****         configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
4963:../FreeRTOS/Source/tasks.c **** 
4964:../FreeRTOS/Source/tasks.c ****         /* RTOS ports that support interrupt nesting have the concept of a
4965:../FreeRTOS/Source/tasks.c ****          * maximum  system call (or maximum API call) interrupt priority.
4966:../FreeRTOS/Source/tasks.c ****          * Interrupts that are  above the maximum system call priority are keep
4967:../FreeRTOS/Source/tasks.c ****          * permanently enabled, even when the RTOS kernel is in a critical section,
4968:../FreeRTOS/Source/tasks.c ****          * but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4969:../FreeRTOS/Source/tasks.c ****          * is defined in FreeRTOSConfig.h then
4970:../FreeRTOS/Source/tasks.c ****          * portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4971:../FreeRTOS/Source/tasks.c ****          * failure if a FreeRTOS API function is called from an interrupt that has
4972:../FreeRTOS/Source/tasks.c ****          * been assigned a priority above the configured maximum system call
4973:../FreeRTOS/Source/tasks.c ****          * priority.  Only FreeRTOS functions that end in FromISR can be called
4974:../FreeRTOS/Source/tasks.c ****          * from interrupts  that have been assigned a priority at or (logically)
4975:../FreeRTOS/Source/tasks.c ****          * below the maximum system call interrupt priority.  FreeRTOS maintains a
4976:../FreeRTOS/Source/tasks.c ****          * separate interrupt safe API to ensure interrupt entry is as fast and as
4977:../FreeRTOS/Source/tasks.c ****          * simple as possible.  More information (albeit Cortex-M specific) is
4978:../FreeRTOS/Source/tasks.c ****          * provided on the following link:
4979:../FreeRTOS/Source/tasks.c ****          * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
4980:../FreeRTOS/Source/tasks.c ****         portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
4981:../FreeRTOS/Source/tasks.c **** 
4982:../FreeRTOS/Source/tasks.c ****         pxTCB = xTaskToNotify;
4983:../FreeRTOS/Source/tasks.c **** 
4984:../FreeRTOS/Source/tasks.c ****         uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
4985:../FreeRTOS/Source/tasks.c ****         {
4986:../FreeRTOS/Source/tasks.c ****             if( pulPreviousNotificationValue != NULL )
4987:../FreeRTOS/Source/tasks.c ****             {
4988:../FreeRTOS/Source/tasks.c ****                 *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
4989:../FreeRTOS/Source/tasks.c ****             }
4990:../FreeRTOS/Source/tasks.c **** 
4991:../FreeRTOS/Source/tasks.c ****             ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
4992:../FreeRTOS/Source/tasks.c ****             pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
4993:../FreeRTOS/Source/tasks.c **** 
4994:../FreeRTOS/Source/tasks.c ****             switch( eAction )
4995:../FreeRTOS/Source/tasks.c ****             {
4996:../FreeRTOS/Source/tasks.c ****                 case eSetBits:
4997:../FreeRTOS/Source/tasks.c ****                     pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
4998:../FreeRTOS/Source/tasks.c ****                     break;
4999:../FreeRTOS/Source/tasks.c **** 
5000:../FreeRTOS/Source/tasks.c ****                 case eIncrement:
5001:../FreeRTOS/Source/tasks.c ****                     ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
5002:../FreeRTOS/Source/tasks.c ****                     break;
5003:../FreeRTOS/Source/tasks.c **** 
5004:../FreeRTOS/Source/tasks.c ****                 case eSetValueWithOverwrite:
5005:../FreeRTOS/Source/tasks.c ****                     pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
5006:../FreeRTOS/Source/tasks.c ****                     break;
5007:../FreeRTOS/Source/tasks.c **** 
5008:../FreeRTOS/Source/tasks.c ****                 case eSetValueWithoutOverwrite:
5009:../FreeRTOS/Source/tasks.c **** 
5010:../FreeRTOS/Source/tasks.c ****                     if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
5011:../FreeRTOS/Source/tasks.c ****                     {
5012:../FreeRTOS/Source/tasks.c ****                         pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
5013:../FreeRTOS/Source/tasks.c ****                     }
5014:../FreeRTOS/Source/tasks.c ****                     else
5015:../FreeRTOS/Source/tasks.c ****                     {
5016:../FreeRTOS/Source/tasks.c ****                         /* The value could not be written to the task. */
5017:../FreeRTOS/Source/tasks.c ****                         xReturn = pdFAIL;
5018:../FreeRTOS/Source/tasks.c ****                     }
5019:../FreeRTOS/Source/tasks.c **** 
5020:../FreeRTOS/Source/tasks.c ****                     break;
5021:../FreeRTOS/Source/tasks.c **** 
5022:../FreeRTOS/Source/tasks.c ****                 case eNoAction:
5023:../FreeRTOS/Source/tasks.c **** 
5024:../FreeRTOS/Source/tasks.c ****                     /* The task is being notified without its notify value being
5025:../FreeRTOS/Source/tasks.c ****                      * updated. */
5026:../FreeRTOS/Source/tasks.c ****                     break;
5027:../FreeRTOS/Source/tasks.c **** 
5028:../FreeRTOS/Source/tasks.c ****                 default:
5029:../FreeRTOS/Source/tasks.c **** 
5030:../FreeRTOS/Source/tasks.c ****                     /* Should not get here if all enums are handled.
5031:../FreeRTOS/Source/tasks.c ****                      * Artificially force an assert by testing a value the
5032:../FreeRTOS/Source/tasks.c ****                      * compiler can't assume is const. */
5033:../FreeRTOS/Source/tasks.c ****                     configASSERT( xTickCount == ( TickType_t ) 0 );
5034:../FreeRTOS/Source/tasks.c ****                     break;
5035:../FreeRTOS/Source/tasks.c ****             }
5036:../FreeRTOS/Source/tasks.c **** 
5037:../FreeRTOS/Source/tasks.c ****             traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );
5038:../FreeRTOS/Source/tasks.c **** 
5039:../FreeRTOS/Source/tasks.c ****             /* If the task is in the blocked state specifically to wait for a
5040:../FreeRTOS/Source/tasks.c ****              * notification then unblock it now. */
5041:../FreeRTOS/Source/tasks.c ****             if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
5042:../FreeRTOS/Source/tasks.c ****             {
5043:../FreeRTOS/Source/tasks.c ****                 /* The task should not have been on an event list. */
5044:../FreeRTOS/Source/tasks.c ****                 configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
5045:../FreeRTOS/Source/tasks.c **** 
5046:../FreeRTOS/Source/tasks.c ****                 if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
5047:../FreeRTOS/Source/tasks.c ****                 {
5048:../FreeRTOS/Source/tasks.c ****                     ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
5049:../FreeRTOS/Source/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
5050:../FreeRTOS/Source/tasks.c ****                 }
5051:../FreeRTOS/Source/tasks.c ****                 else
5052:../FreeRTOS/Source/tasks.c ****                 {
5053:../FreeRTOS/Source/tasks.c ****                     /* The delayed and ready lists cannot be accessed, so hold
5054:../FreeRTOS/Source/tasks.c ****                      * this task pending until the scheduler is resumed. */
5055:../FreeRTOS/Source/tasks.c ****                     vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
5056:../FreeRTOS/Source/tasks.c ****                 }
5057:../FreeRTOS/Source/tasks.c **** 
5058:../FreeRTOS/Source/tasks.c ****                 if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
5059:../FreeRTOS/Source/tasks.c ****                 {
5060:../FreeRTOS/Source/tasks.c ****                     /* The notified task has a priority above the currently
5061:../FreeRTOS/Source/tasks.c ****                      * executing task so a yield is required. */
5062:../FreeRTOS/Source/tasks.c ****                     if( pxHigherPriorityTaskWoken != NULL )
5063:../FreeRTOS/Source/tasks.c ****                     {
5064:../FreeRTOS/Source/tasks.c ****                         *pxHigherPriorityTaskWoken = pdTRUE;
5065:../FreeRTOS/Source/tasks.c ****                     }
5066:../FreeRTOS/Source/tasks.c **** 
5067:../FreeRTOS/Source/tasks.c ****                     /* Mark that a yield is pending in case the user is not
5068:../FreeRTOS/Source/tasks.c ****                      * using the "xHigherPriorityTaskWoken" parameter to an ISR
5069:../FreeRTOS/Source/tasks.c ****                      * safe FreeRTOS function. */
5070:../FreeRTOS/Source/tasks.c ****                     xYieldPending = pdTRUE;
5071:../FreeRTOS/Source/tasks.c ****                 }
5072:../FreeRTOS/Source/tasks.c ****                 else
5073:../FreeRTOS/Source/tasks.c ****                 {
5074:../FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
5075:../FreeRTOS/Source/tasks.c ****                 }
5076:../FreeRTOS/Source/tasks.c ****             }
5077:../FreeRTOS/Source/tasks.c ****         }
5078:../FreeRTOS/Source/tasks.c ****         portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
5079:../FreeRTOS/Source/tasks.c **** 
5080:../FreeRTOS/Source/tasks.c ****         return xReturn;
5081:../FreeRTOS/Source/tasks.c ****     }
5082:../FreeRTOS/Source/tasks.c **** 
5083:../FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
5084:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
5085:../FreeRTOS/Source/tasks.c **** 
5086:../FreeRTOS/Source/tasks.c **** #if ( configUSE_TASK_NOTIFICATIONS == 1 )
5087:../FreeRTOS/Source/tasks.c **** 
5088:../FreeRTOS/Source/tasks.c ****     void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
5089:../FreeRTOS/Source/tasks.c ****                                         UBaseType_t uxIndexToNotify,
5090:../FreeRTOS/Source/tasks.c ****                                         BaseType_t * pxHigherPriorityTaskWoken )
5091:../FreeRTOS/Source/tasks.c ****     {
5092:../FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
5093:../FreeRTOS/Source/tasks.c ****         uint8_t ucOriginalNotifyState;
5094:../FreeRTOS/Source/tasks.c ****         UBaseType_t uxSavedInterruptStatus;
5095:../FreeRTOS/Source/tasks.c **** 
5096:../FreeRTOS/Source/tasks.c ****         configASSERT( xTaskToNotify );
5097:../FreeRTOS/Source/tasks.c ****         configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
5098:../FreeRTOS/Source/tasks.c **** 
5099:../FreeRTOS/Source/tasks.c ****         /* RTOS ports that support interrupt nesting have the concept of a
5100:../FreeRTOS/Source/tasks.c ****          * maximum  system call (or maximum API call) interrupt priority.
5101:../FreeRTOS/Source/tasks.c ****          * Interrupts that are  above the maximum system call priority are keep
5102:../FreeRTOS/Source/tasks.c ****          * permanently enabled, even when the RTOS kernel is in a critical section,
5103:../FreeRTOS/Source/tasks.c ****          * but cannot make any calls to FreeRTOS API functions.  If configASSERT()
5104:../FreeRTOS/Source/tasks.c ****          * is defined in FreeRTOSConfig.h then
5105:../FreeRTOS/Source/tasks.c ****          * portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
5106:../FreeRTOS/Source/tasks.c ****          * failure if a FreeRTOS API function is called from an interrupt that has
5107:../FreeRTOS/Source/tasks.c ****          * been assigned a priority above the configured maximum system call
5108:../FreeRTOS/Source/tasks.c ****          * priority.  Only FreeRTOS functions that end in FromISR can be called
5109:../FreeRTOS/Source/tasks.c ****          * from interrupts  that have been assigned a priority at or (logically)
5110:../FreeRTOS/Source/tasks.c ****          * below the maximum system call interrupt priority.  FreeRTOS maintains a
5111:../FreeRTOS/Source/tasks.c ****          * separate interrupt safe API to ensure interrupt entry is as fast and as
5112:../FreeRTOS/Source/tasks.c ****          * simple as possible.  More information (albeit Cortex-M specific) is
5113:../FreeRTOS/Source/tasks.c ****          * provided on the following link:
5114:../FreeRTOS/Source/tasks.c ****          * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
5115:../FreeRTOS/Source/tasks.c ****         portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
5116:../FreeRTOS/Source/tasks.c **** 
5117:../FreeRTOS/Source/tasks.c ****         pxTCB = xTaskToNotify;
5118:../FreeRTOS/Source/tasks.c **** 
5119:../FreeRTOS/Source/tasks.c ****         uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
5120:../FreeRTOS/Source/tasks.c ****         {
5121:../FreeRTOS/Source/tasks.c ****             ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
5122:../FreeRTOS/Source/tasks.c ****             pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
5123:../FreeRTOS/Source/tasks.c **** 
5124:../FreeRTOS/Source/tasks.c ****             /* 'Giving' is equivalent to incrementing a count in a counting
5125:../FreeRTOS/Source/tasks.c ****              * semaphore. */
5126:../FreeRTOS/Source/tasks.c ****             ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
5127:../FreeRTOS/Source/tasks.c **** 
5128:../FreeRTOS/Source/tasks.c ****             traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );
5129:../FreeRTOS/Source/tasks.c **** 
5130:../FreeRTOS/Source/tasks.c ****             /* If the task is in the blocked state specifically to wait for a
5131:../FreeRTOS/Source/tasks.c ****              * notification then unblock it now. */
5132:../FreeRTOS/Source/tasks.c ****             if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
5133:../FreeRTOS/Source/tasks.c ****             {
5134:../FreeRTOS/Source/tasks.c ****                 /* The task should not have been on an event list. */
5135:../FreeRTOS/Source/tasks.c ****                 configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
5136:../FreeRTOS/Source/tasks.c **** 
5137:../FreeRTOS/Source/tasks.c ****                 if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
5138:../FreeRTOS/Source/tasks.c ****                 {
5139:../FreeRTOS/Source/tasks.c ****                     ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
5140:../FreeRTOS/Source/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
5141:../FreeRTOS/Source/tasks.c ****                 }
5142:../FreeRTOS/Source/tasks.c ****                 else
5143:../FreeRTOS/Source/tasks.c ****                 {
5144:../FreeRTOS/Source/tasks.c ****                     /* The delayed and ready lists cannot be accessed, so hold
5145:../FreeRTOS/Source/tasks.c ****                      * this task pending until the scheduler is resumed. */
5146:../FreeRTOS/Source/tasks.c ****                     vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
5147:../FreeRTOS/Source/tasks.c ****                 }
5148:../FreeRTOS/Source/tasks.c **** 
5149:../FreeRTOS/Source/tasks.c ****                 if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
5150:../FreeRTOS/Source/tasks.c ****                 {
5151:../FreeRTOS/Source/tasks.c ****                     /* The notified task has a priority above the currently
5152:../FreeRTOS/Source/tasks.c ****                      * executing task so a yield is required. */
5153:../FreeRTOS/Source/tasks.c ****                     if( pxHigherPriorityTaskWoken != NULL )
5154:../FreeRTOS/Source/tasks.c ****                     {
5155:../FreeRTOS/Source/tasks.c ****                         *pxHigherPriorityTaskWoken = pdTRUE;
5156:../FreeRTOS/Source/tasks.c ****                     }
5157:../FreeRTOS/Source/tasks.c **** 
5158:../FreeRTOS/Source/tasks.c ****                     /* Mark that a yield is pending in case the user is not
5159:../FreeRTOS/Source/tasks.c ****                      * using the "xHigherPriorityTaskWoken" parameter in an ISR
5160:../FreeRTOS/Source/tasks.c ****                      * safe FreeRTOS function. */
5161:../FreeRTOS/Source/tasks.c ****                     xYieldPending = pdTRUE;
5162:../FreeRTOS/Source/tasks.c ****                 }
5163:../FreeRTOS/Source/tasks.c ****                 else
5164:../FreeRTOS/Source/tasks.c ****                 {
5165:../FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
5166:../FreeRTOS/Source/tasks.c ****                 }
5167:../FreeRTOS/Source/tasks.c ****             }
5168:../FreeRTOS/Source/tasks.c ****         }
5169:../FreeRTOS/Source/tasks.c ****         portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
5170:../FreeRTOS/Source/tasks.c ****     }
5171:../FreeRTOS/Source/tasks.c **** 
5172:../FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
5173:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
5174:../FreeRTOS/Source/tasks.c **** 
5175:../FreeRTOS/Source/tasks.c **** #if ( configUSE_TASK_NOTIFICATIONS == 1 )
5176:../FreeRTOS/Source/tasks.c **** 
5177:../FreeRTOS/Source/tasks.c ****     BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
5178:../FreeRTOS/Source/tasks.c ****                                              UBaseType_t uxIndexToClear )
5179:../FreeRTOS/Source/tasks.c ****     {
5180:../FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
5181:../FreeRTOS/Source/tasks.c ****         BaseType_t xReturn;
5182:../FreeRTOS/Source/tasks.c **** 
5183:../FreeRTOS/Source/tasks.c ****         configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );
5184:../FreeRTOS/Source/tasks.c **** 
5185:../FreeRTOS/Source/tasks.c ****         /* If null is passed in here then it is the calling task that is having
5186:../FreeRTOS/Source/tasks.c ****          * its notification state cleared. */
5187:../FreeRTOS/Source/tasks.c ****         pxTCB = prvGetTCBFromHandle( xTask );
5188:../FreeRTOS/Source/tasks.c **** 
5189:../FreeRTOS/Source/tasks.c ****         taskENTER_CRITICAL();
5190:../FreeRTOS/Source/tasks.c ****         {
5191:../FreeRTOS/Source/tasks.c ****             if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
5192:../FreeRTOS/Source/tasks.c ****             {
5193:../FreeRTOS/Source/tasks.c ****                 pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
5194:../FreeRTOS/Source/tasks.c ****                 xReturn = pdPASS;
5195:../FreeRTOS/Source/tasks.c ****             }
5196:../FreeRTOS/Source/tasks.c ****             else
5197:../FreeRTOS/Source/tasks.c ****             {
5198:../FreeRTOS/Source/tasks.c ****                 xReturn = pdFAIL;
5199:../FreeRTOS/Source/tasks.c ****             }
5200:../FreeRTOS/Source/tasks.c ****         }
5201:../FreeRTOS/Source/tasks.c ****         taskEXIT_CRITICAL();
5202:../FreeRTOS/Source/tasks.c **** 
5203:../FreeRTOS/Source/tasks.c ****         return xReturn;
5204:../FreeRTOS/Source/tasks.c ****     }
5205:../FreeRTOS/Source/tasks.c **** 
5206:../FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
5207:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
5208:../FreeRTOS/Source/tasks.c **** 
5209:../FreeRTOS/Source/tasks.c **** #if ( configUSE_TASK_NOTIFICATIONS == 1 )
5210:../FreeRTOS/Source/tasks.c **** 
5211:../FreeRTOS/Source/tasks.c ****     uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
5212:../FreeRTOS/Source/tasks.c ****                                             UBaseType_t uxIndexToClear,
5213:../FreeRTOS/Source/tasks.c ****                                             uint32_t ulBitsToClear )
5214:../FreeRTOS/Source/tasks.c ****     {
5215:../FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
5216:../FreeRTOS/Source/tasks.c ****         uint32_t ulReturn;
5217:../FreeRTOS/Source/tasks.c **** 
5218:../FreeRTOS/Source/tasks.c ****         /* If null is passed in here then it is the calling task that is having
5219:../FreeRTOS/Source/tasks.c ****          * its notification state cleared. */
5220:../FreeRTOS/Source/tasks.c ****         pxTCB = prvGetTCBFromHandle( xTask );
5221:../FreeRTOS/Source/tasks.c **** 
5222:../FreeRTOS/Source/tasks.c ****         taskENTER_CRITICAL();
5223:../FreeRTOS/Source/tasks.c ****         {
5224:../FreeRTOS/Source/tasks.c ****             /* Return the notification as it was before the bits were cleared,
5225:../FreeRTOS/Source/tasks.c ****              * then clear the bit mask. */
5226:../FreeRTOS/Source/tasks.c ****             ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
5227:../FreeRTOS/Source/tasks.c ****             pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
5228:../FreeRTOS/Source/tasks.c ****         }
5229:../FreeRTOS/Source/tasks.c ****         taskEXIT_CRITICAL();
5230:../FreeRTOS/Source/tasks.c **** 
5231:../FreeRTOS/Source/tasks.c ****         return ulReturn;
5232:../FreeRTOS/Source/tasks.c ****     }
5233:../FreeRTOS/Source/tasks.c **** 
5234:../FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
5235:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
5236:../FreeRTOS/Source/tasks.c **** 
5237:../FreeRTOS/Source/tasks.c **** #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) )
5238:../FreeRTOS/Source/tasks.c **** 
5239:../FreeRTOS/Source/tasks.c ****     uint32_t ulTaskGetIdleRunTimeCounter( void )
5240:../FreeRTOS/Source/tasks.c ****     {
5241:../FreeRTOS/Source/tasks.c ****         return xIdleTaskHandle->ulRunTimeCounter;
5242:../FreeRTOS/Source/tasks.c ****     }
5243:../FreeRTOS/Source/tasks.c **** 
5244:../FreeRTOS/Source/tasks.c **** #endif
5245:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
5246:../FreeRTOS/Source/tasks.c **** 
5247:../FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
5248:../FreeRTOS/Source/tasks.c ****                                             const BaseType_t xCanBlockIndefinitely )
5249:../FreeRTOS/Source/tasks.c **** {
 133              	 .loc 1 5249 0
 134              	 .cfi_startproc
 135              	 
 136              	 
 137              	.LVL6:
 138 0000 70B5     	 push {r4,r5,r6,lr}
 139              	.LCFI0:
 140              	 .cfi_def_cfa_offset 16
 141              	 .cfi_offset 4,-16
 142              	 .cfi_offset 5,-12
 143              	 .cfi_offset 6,-8
 144              	 .cfi_offset 14,-4
 145 0002 0446     	 mov r4,r0
 146 0004 0E46     	 mov r6,r1
5250:../FreeRTOS/Source/tasks.c ****     TickType_t xTimeToWake;
5251:../FreeRTOS/Source/tasks.c ****     const TickType_t xConstTickCount = xTickCount;
 147              	 .loc 1 5251 0
 148 0006 1C4B     	 ldr r3,.L20
 149 0008 1D68     	 ldr r5,[r3]
 150              	.LVL7:
5252:../FreeRTOS/Source/tasks.c **** 
5253:../FreeRTOS/Source/tasks.c ****     #if ( INCLUDE_xTaskAbortDelay == 1 )
5254:../FreeRTOS/Source/tasks.c ****         {
5255:../FreeRTOS/Source/tasks.c ****             /* About to enter a delayed list, so ensure the ucDelayAborted flag is
5256:../FreeRTOS/Source/tasks.c ****              * reset to pdFALSE so it can be detected as having been set to pdTRUE
5257:../FreeRTOS/Source/tasks.c ****              * when the task leaves the Blocked state. */
5258:../FreeRTOS/Source/tasks.c ****             pxCurrentTCB->ucDelayAborted = pdFALSE;
5259:../FreeRTOS/Source/tasks.c ****         }
5260:../FreeRTOS/Source/tasks.c ****     #endif
5261:../FreeRTOS/Source/tasks.c **** 
5262:../FreeRTOS/Source/tasks.c ****     /* Remove the task from the ready list before adding it to the blocked list
5263:../FreeRTOS/Source/tasks.c ****      * as the same list item is used for both lists. */
5264:../FreeRTOS/Source/tasks.c ****     if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 151              	 .loc 1 5264 0
 152 000a 1C4B     	 ldr r3,.L20+4
 153 000c 1868     	 ldr r0,[r3]
 154              	.LVL8:
 155 000e 0430     	 adds r0,r0,#4
 156 0010 FFF7FEFF 	 bl uxListRemove
 157              	.LVL9:
 158 0014 48B9     	 cbnz r0,.L15
5265:../FreeRTOS/Source/tasks.c ****     {
5266:../FreeRTOS/Source/tasks.c ****         /* The current task must be in a ready list, so there is no need to
5267:../FreeRTOS/Source/tasks.c ****          * check, and the port reset macro can be called directly. */
5268:../FreeRTOS/Source/tasks.c ****         portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCu
 159              	 .loc 1 5268 0
 160 0016 194B     	 ldr r3,.L20+4
 161 0018 1B68     	 ldr r3,[r3]
 162 001a 1949     	 ldr r1,.L20+8
 163 001c 0A68     	 ldr r2,[r1]
 164 001e D86A     	 ldr r0,[r3,#44]
 165 0020 0123     	 movs r3,#1
 166 0022 8340     	 lsls r3,r3,r0
 167 0024 22EA0303 	 bic r3,r2,r3
 168 0028 0B60     	 str r3,[r1]
 169              	.L15:
5269:../FreeRTOS/Source/tasks.c ****     }
5270:../FreeRTOS/Source/tasks.c ****     else
5271:../FreeRTOS/Source/tasks.c ****     {
5272:../FreeRTOS/Source/tasks.c ****         mtCOVERAGE_TEST_MARKER();
5273:../FreeRTOS/Source/tasks.c ****     }
5274:../FreeRTOS/Source/tasks.c **** 
5275:../FreeRTOS/Source/tasks.c ****     #if ( INCLUDE_vTaskSuspend == 1 )
5276:../FreeRTOS/Source/tasks.c ****         {
5277:../FreeRTOS/Source/tasks.c ****             if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 170              	 .loc 1 5277 0
 171 002a B4F1FF3F 	 cmp r4,#-1
 172 002e 07D1     	 bne .L16
 173              	 .loc 1 5277 0 is_stmt 0 discriminator 1
 174 0030 36B1     	 cbz r6,.L16
5278:../FreeRTOS/Source/tasks.c ****             {
5279:../FreeRTOS/Source/tasks.c ****                 /* Add the task to the suspended task list instead of a delayed task
5280:../FreeRTOS/Source/tasks.c ****                  * list to ensure it is not woken by a timing event.  It will block
5281:../FreeRTOS/Source/tasks.c ****                  * indefinitely. */
5282:../FreeRTOS/Source/tasks.c ****                 vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 175              	 .loc 1 5282 0 is_stmt 1
 176 0032 124B     	 ldr r3,.L20+4
 177 0034 1968     	 ldr r1,[r3]
 178 0036 1348     	 ldr r0,.L20+12
 179 0038 0431     	 adds r1,r1,#4
 180 003a FFF7FEFF 	 bl vListInsertEnd
 181              	.LVL10:
 182 003e 70BD     	 pop {r4,r5,r6,pc}
 183              	.LVL11:
 184              	.L16:
5283:../FreeRTOS/Source/tasks.c ****             }
5284:../FreeRTOS/Source/tasks.c ****             else
5285:../FreeRTOS/Source/tasks.c ****             {
5286:../FreeRTOS/Source/tasks.c ****                 /* Calculate the time at which the task should be woken if the event
5287:../FreeRTOS/Source/tasks.c ****                  * does not occur.  This may overflow but this doesn't matter, the
5288:../FreeRTOS/Source/tasks.c ****                  * kernel will manage it correctly. */
5289:../FreeRTOS/Source/tasks.c ****                 xTimeToWake = xConstTickCount + xTicksToWait;
 185              	 .loc 1 5289 0
 186 0040 2C44     	 add r4,r4,r5
 187              	.LVL12:
5290:../FreeRTOS/Source/tasks.c **** 
5291:../FreeRTOS/Source/tasks.c ****                 /* The list item will be inserted in wake time order. */
5292:../FreeRTOS/Source/tasks.c ****                 listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 188              	 .loc 1 5292 0
 189 0042 0E4B     	 ldr r3,.L20+4
 190 0044 1B68     	 ldr r3,[r3]
 191 0046 5C60     	 str r4,[r3,#4]
5293:../FreeRTOS/Source/tasks.c **** 
5294:../FreeRTOS/Source/tasks.c ****                 if( xTimeToWake < xConstTickCount )
 192              	 .loc 1 5294 0
 193 0048 A542     	 cmp r5,r4
 194 004a 07D9     	 bls .L18
5295:../FreeRTOS/Source/tasks.c ****                 {
5296:../FreeRTOS/Source/tasks.c ****                     /* Wake time has overflowed.  Place this item in the overflow
5297:../FreeRTOS/Source/tasks.c ****                      * list. */
5298:../FreeRTOS/Source/tasks.c ****                     vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 195              	 .loc 1 5298 0
 196 004c 0E4B     	 ldr r3,.L20+16
 197 004e 1868     	 ldr r0,[r3]
 198 0050 0A4B     	 ldr r3,.L20+4
 199 0052 1968     	 ldr r1,[r3]
 200 0054 0431     	 adds r1,r1,#4
 201 0056 FFF7FEFF 	 bl vListInsert
 202              	.LVL13:
 203 005a 70BD     	 pop {r4,r5,r6,pc}
 204              	.LVL14:
 205              	.L18:
5299:../FreeRTOS/Source/tasks.c ****                 }
5300:../FreeRTOS/Source/tasks.c ****                 else
5301:../FreeRTOS/Source/tasks.c ****                 {
5302:../FreeRTOS/Source/tasks.c ****                     /* The wake time has not overflowed, so the current block list
5303:../FreeRTOS/Source/tasks.c ****                      * is used. */
5304:../FreeRTOS/Source/tasks.c ****                     vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 206              	 .loc 1 5304 0
 207 005c 0B4B     	 ldr r3,.L20+20
 208 005e 1868     	 ldr r0,[r3]
 209 0060 064B     	 ldr r3,.L20+4
 210 0062 1968     	 ldr r1,[r3]
 211 0064 0431     	 adds r1,r1,#4
 212 0066 FFF7FEFF 	 bl vListInsert
 213              	.LVL15:
5305:../FreeRTOS/Source/tasks.c **** 
5306:../FreeRTOS/Source/tasks.c ****                     /* If the task entering the blocked state was placed at the
5307:../FreeRTOS/Source/tasks.c ****                      * head of the list of blocked tasks then xNextTaskUnblockTime
5308:../FreeRTOS/Source/tasks.c ****                      * needs to be updated too. */
5309:../FreeRTOS/Source/tasks.c ****                     if( xTimeToWake < xNextTaskUnblockTime )
 214              	 .loc 1 5309 0
 215 006a 094B     	 ldr r3,.L20+24
 216 006c 1B68     	 ldr r3,[r3]
 217 006e 9C42     	 cmp r4,r3
5310:../FreeRTOS/Source/tasks.c ****                     {
5311:../FreeRTOS/Source/tasks.c ****                         xNextTaskUnblockTime = xTimeToWake;
 218              	 .loc 1 5311 0
 219 0070 3CBF     	 itt cc
 220 0072 074B     	 ldrcc r3,.L20+24
 221 0074 1C60     	 strcc r4,[r3]
 222 0076 70BD     	 pop {r4,r5,r6,pc}
 223              	.LVL16:
 224              	.L21:
 225              	 .align 2
 226              	.L20:
 227 0078 00000000 	 .word .LANCHOR4
 228 007c 00000000 	 .word .LANCHOR5
 229 0080 00000000 	 .word .LANCHOR6
 230 0084 00000000 	 .word .LANCHOR0
 231 0088 00000000 	 .word .LANCHOR7
 232 008c 00000000 	 .word .LANCHOR2
 233 0090 00000000 	 .word .LANCHOR3
 234              	 .cfi_endproc
 235              	.LFE64:
 237              	 .section .text.prvIdleTask,"ax",%progbits
 238              	 .align 2
 239              	 .thumb
 240              	 .thumb_func
 242              	prvIdleTask:
 243              	.LFB42:
3408:../FreeRTOS/Source/tasks.c ****     /* Stop warnings. */
 244              	 .loc 1 3408 0
 245              	 .cfi_startproc
 246              	 
 247              	 
 248              	 
 249              	.LVL17:
 250 0000 80B5     	 push {r7,lr}
 251              	.LCFI1:
 252              	 .cfi_def_cfa_offset 8
 253              	 .cfi_offset 7,-8
 254              	 .cfi_offset 14,-4
 255              	.LBB133:
 256              	.LBB134:
3674:../FreeRTOS/Source/tasks.c ****             {
 257              	 .loc 1 3674 0
 258 0002 174D     	 ldr r5,.L30
3678:../FreeRTOS/Source/tasks.c ****                     ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 259              	 .loc 1 3678 0
 260 0004 174F     	 ldr r7,.L30+4
3680:../FreeRTOS/Source/tasks.c ****                     --uxDeletedTasksWaitingCleanUp;
 261              	 .loc 1 3680 0
 262 0006 184E     	 ldr r6,.L30+8
 263              	.LBE134:
 264              	.LBE133:
3449:../FreeRTOS/Source/tasks.c ****                 }
 265              	 .loc 1 3449 0
 266 0008 DFF86480 	 ldr r8,.L30+16
 267              	.LVL18:
 268              	.L26:
 269              	.LBB138:
 270              	.LBB137:
3674:../FreeRTOS/Source/tasks.c ****             {
 271              	 .loc 1 3674 0
 272 000c 2B68     	 ldr r3,[r5]
 273 000e BBB1     	 cbz r3,.L23
 274              	.L27:
3676:../FreeRTOS/Source/tasks.c ****                 {
 275              	 .loc 1 3676 0
 276 0010 FFF7FEFF 	 bl vPortEnterCritical
 277              	.LVL19:
3678:../FreeRTOS/Source/tasks.c ****                     ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 278              	 .loc 1 3678 0
 279 0014 FB68     	 ldr r3,[r7,#12]
 280 0016 DC68     	 ldr r4,[r3,#12]
 281              	.LVL20:
3679:../FreeRTOS/Source/tasks.c ****                     --uxCurrentNumberOfTasks;
 282              	 .loc 1 3679 0
 283 0018 201D     	 adds r0,r4,#4
 284 001a FFF7FEFF 	 bl uxListRemove
 285              	.LVL21:
3680:../FreeRTOS/Source/tasks.c ****                     --uxDeletedTasksWaitingCleanUp;
 286              	 .loc 1 3680 0
 287 001e 3368     	 ldr r3,[r6]
 288 0020 013B     	 subs r3,r3,#1
 289 0022 3360     	 str r3,[r6]
3681:../FreeRTOS/Source/tasks.c ****                 }
 290              	 .loc 1 3681 0
 291 0024 2B68     	 ldr r3,[r5]
 292 0026 013B     	 subs r3,r3,#1
 293 0028 2B60     	 str r3,[r5]
3683:../FreeRTOS/Source/tasks.c **** 
 294              	 .loc 1 3683 0
 295 002a FFF7FEFF 	 bl vPortExitCritical
 296              	.LVL22:
 297              	.LBB135:
 298              	.LBB136:
3937:../FreeRTOS/Source/tasks.c ****                 vPortFree( pxTCB );
 299              	 .loc 1 3937 0
 300 002e 206B     	 ldr r0,[r4,#48]
 301 0030 FFF7FEFF 	 bl vPortFree
 302              	.LVL23:
3938:../FreeRTOS/Source/tasks.c ****             }
 303              	 .loc 1 3938 0
 304 0034 2046     	 mov r0,r4
 305 0036 FFF7FEFF 	 bl vPortFree
 306              	.LVL24:
 307              	.LBE136:
 308              	.LBE135:
3674:../FreeRTOS/Source/tasks.c ****             {
 309              	 .loc 1 3674 0
 310 003a 2B68     	 ldr r3,[r5]
 311 003c 002B     	 cmp r3,#0
 312 003e E7D1     	 bne .L27
 313              	.LVL25:
 314              	.L23:
 315              	.LBE137:
 316              	.LBE138:
3447:../FreeRTOS/Source/tasks.c ****                 {
 317              	 .loc 1 3447 0
 318 0040 0A4B     	 ldr r3,.L30+12
 319 0042 1B68     	 ldr r3,[r3]
 320 0044 012B     	 cmp r3,#1
 321 0046 07D9     	 bls .L25
3449:../FreeRTOS/Source/tasks.c ****                 }
 322              	 .loc 1 3449 0
 323 0048 4FF08053 	 mov r3,#268435456
 324 004c C8F80030 	 str r3,[r8]
 325              	
 326 0050 BFF34F8F 	 dsb
 327              	
 328              	
 329 0054 BFF36F8F 	 isb
 330              	
 331              	 .thumb
 332              	.L25:
 333              	.LBB139:
3467:../FreeRTOS/Source/tasks.c ****             }
 334              	 .loc 1 3467 0
 335 0058 FFF7FEFF 	 bl vApplicationIdleHook
 336              	.LVL26:
 337              	.LBE139:
3520:../FreeRTOS/Source/tasks.c **** }
 338              	 .loc 1 3520 0
 339 005c D6E7     	 b .L26
 340              	.L31:
 341 005e 00BF     	 .align 2
 342              	.L30:
 343 0060 00000000 	 .word .LANCHOR8
 344 0064 00000000 	 .word .LANCHOR9
 345 0068 00000000 	 .word .LANCHOR10
 346 006c 00000000 	 .word .LANCHOR11
 347 0070 04ED00E0 	 .word -536810236
 348              	 .cfi_endproc
 349              	.LFE42:
 351              	 .section .text.xTaskCreate,"ax",%progbits
 352              	 .align 2
 353              	 .global xTaskCreate
 354              	 .thumb
 355              	 .thumb_func
 357              	xTaskCreate:
 358              	.LFB5:
 727:../FreeRTOS/Source/tasks.c ****         TCB_t * pxNewTCB;
 359              	 .loc 1 727 0
 360              	 .cfi_startproc
 361              	 
 362              	 
 363              	.LVL27:
 364 0000 2DE9F84F 	 push {r3,r4,r5,r6,r7,r8,r9,r10,fp,lr}
 365              	.LCFI2:
 366              	 .cfi_def_cfa_offset 40
 367              	 .cfi_offset 3,-40
 368              	 .cfi_offset 4,-36
 369              	 .cfi_offset 5,-32
 370              	 .cfi_offset 6,-28
 371              	 .cfi_offset 7,-24
 372              	 .cfi_offset 8,-20
 373              	 .cfi_offset 9,-16
 374              	 .cfi_offset 10,-12
 375              	 .cfi_offset 11,-8
 376              	 .cfi_offset 14,-4
 377 0004 8046     	 mov r8,r0
 378 0006 0F46     	 mov r7,r1
 379 0008 9946     	 mov r9,r3
 380 000a 0B9E     	 ldr r6,[sp,#44]
 381              	.LBB147:
 761:../FreeRTOS/Source/tasks.c **** 
 382              	 .loc 1 761 0
 383 000c 9500     	 lsls r5,r2,#2
 384 000e 2846     	 mov r0,r5
 385              	.LVL28:
 386 0010 FFF7FEFF 	 bl pvPortMalloc
 387              	.LVL29:
 763:../FreeRTOS/Source/tasks.c ****                 {
 388              	 .loc 1 763 0
 389 0014 0028     	 cmp r0,#0
 390 0016 00F0C480 	 beq .L33
 391 001a 8246     	 mov r10,r0
 766:../FreeRTOS/Source/tasks.c **** 
 392              	 .loc 1 766 0
 393 001c 6020     	 movs r0,#96
 394              	.LVL30:
 395 001e FFF7FEFF 	 bl pvPortMalloc
 396              	.LVL31:
 768:../FreeRTOS/Source/tasks.c ****                     {
 397              	 .loc 1 768 0
 398 0022 0446     	 mov r4,r0
 399 0024 68B1     	 cbz r0,.L34
 771:../FreeRTOS/Source/tasks.c ****                     }
 400              	 .loc 1 771 0
 401 0026 C0F830A0 	 str r10,[r0,#48]
 402              	.LVL32:
 403              	.LBE147:
 404              	.LBB148:
 405              	.LBB149:
 843:../FreeRTOS/Source/tasks.c ****         }
 406              	 .loc 1 843 0
 407 002a 5046     	 mov r0,r10
 408              	.LVL33:
 409 002c A521     	 movs r1,#165
 410 002e 2A46     	 mov r2,r5
 411 0030 FFF7FEFF 	 bl memset
 412              	.LVL34:
 853:../FreeRTOS/Source/tasks.c ****             pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( 
 413              	 .loc 1 853 0
 414 0034 043D     	 subs r5,r5,#4
 415              	.LVL35:
 416 0036 236B     	 ldr r3,[r4,#48]
 417 0038 1D44     	 add r5,r5,r3
 418              	.LVL36:
 854:../FreeRTOS/Source/tasks.c **** 
 419              	 .loc 1 854 0
 420 003a 25F00705 	 bic r5,r5,#7
 421              	.LVL37:
 881:../FreeRTOS/Source/tasks.c ****     {
 422              	 .loc 1 881 0
 423 003e 27B9     	 cbnz r7,.L35
 424 0040 19E0     	 b .L49
 425              	.LVL38:
 426              	.L34:
 427              	.LBE149:
 428              	.LBE148:
 429              	.LBB151:
 777:../FreeRTOS/Source/tasks.c ****                     }
 430              	 .loc 1 777 0
 431 0042 5046     	 mov r0,r10
 432              	.LVL39:
 433 0044 FFF7FEFF 	 bl vPortFree
 434              	.LVL40:
 435 0048 ABE0     	 b .L33
 436              	.LVL41:
 437              	.L35:
 438              	.LBE151:
 439              	.LBB152:
 440              	.LBB150:
 885:../FreeRTOS/Source/tasks.c **** 
 441              	 .loc 1 885 0
 442 004a 3B78     	 ldrb r3,[r7]
 443 004c 84F83430 	 strb r3,[r4,#52]
 890:../FreeRTOS/Source/tasks.c ****             {
 444              	 .loc 1 890 0
 445 0050 3B78     	 ldrb r3,[r7]
 446 0052 63B1     	 cbz r3,.L37
 447 0054 3B46     	 mov r3,r7
 448 0056 04F13402 	 add r2,r4,#52
 449 005a 07F11301 	 add r1,r7,#19
 450              	.LVL42:
 451              	.L38:
 885:../FreeRTOS/Source/tasks.c **** 
 452              	 .loc 1 885 0
 453 005e 13F8010F 	 ldrb r0,[r3,#1]!
 454              	.LVL43:
 455 0062 02F8010F 	 strb r0,[r2,#1]!
 890:../FreeRTOS/Source/tasks.c ****             {
 456              	 .loc 1 890 0
 457 0066 1878     	 ldrb r0,[r3]
 458 0068 08B1     	 cbz r0,.L37
 459              	.LVL44:
 883:../FreeRTOS/Source/tasks.c ****         {
 460              	 .loc 1 883 0
 461 006a 8B42     	 cmp r3,r1
 462 006c F7D1     	 bne .L38
 463              	.LVL45:
 464              	.L37:
 902:../FreeRTOS/Source/tasks.c ****     }
 465              	 .loc 1 902 0
 466 006e 0023     	 movs r3,#0
 467 0070 84F84730 	 strb r3,[r4,#71]
 468 0074 02E0     	 b .L39
 469              	.L49:
 908:../FreeRTOS/Source/tasks.c ****     }
 470              	 .loc 1 908 0
 471 0076 0023     	 movs r3,#0
 472 0078 84F83430 	 strb r3,[r4,#52]
 473              	.L39:
 474 007c 0A9B     	 ldr r3,[sp,#40]
 475 007e 092B     	 cmp r3,#9
 476 0080 28BF     	 it cs
 477 0082 0923     	 movcs r3,#9
 478 0084 1F46     	 mov r7,r3
 479              	.LVL46:
 922:../FreeRTOS/Source/tasks.c ****     #if ( configUSE_MUTEXES == 1 )
 480              	 .loc 1 922 0
 481 0086 E362     	 str r3,[r4,#44]
 925:../FreeRTOS/Source/tasks.c ****             pxNewTCB->uxMutexesHeld = 0;
 482              	 .loc 1 925 0
 483 0088 2365     	 str r3,[r4,#80]
 926:../FreeRTOS/Source/tasks.c ****         }
 484              	 .loc 1 926 0
 485 008a 4FF0000A 	 mov r10,#0
 486              	.LVL47:
 487 008e C4F854A0 	 str r10,[r4,#84]
 930:../FreeRTOS/Source/tasks.c ****     vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 488              	 .loc 1 930 0
 489 0092 04F1040B 	 add fp,r4,#4
 490 0096 5846     	 mov r0,fp
 491 0098 FFF7FEFF 	 bl vListInitialiseItem
 492              	.LVL48:
 931:../FreeRTOS/Source/tasks.c **** 
 493              	 .loc 1 931 0
 494 009c 04F11800 	 add r0,r4,#24
 495 00a0 FFF7FEFF 	 bl vListInitialiseItem
 496              	.LVL49:
 935:../FreeRTOS/Source/tasks.c **** 
 497              	 .loc 1 935 0
 498 00a4 2461     	 str r4,[r4,#16]
 938:../FreeRTOS/Source/tasks.c ****     listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 499              	 .loc 1 938 0
 500 00a6 C7F10A03 	 rsb r3,r7,#10
 501 00aa A361     	 str r3,[r4,#24]
 939:../FreeRTOS/Source/tasks.c **** 
 502              	 .loc 1 939 0
 503 00ac 6462     	 str r4,[r4,#36]
 978:../FreeRTOS/Source/tasks.c ****             memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyS
 504              	 .loc 1 978 0
 505 00ae 84F858A0 	 strb r10,[r4,#88]
 506 00b2 84F859A0 	 strb r10,[r4,#89]
 507 00b6 84F85AA0 	 strb r10,[r4,#90]
 508 00ba 84F85BA0 	 strb r10,[r4,#91]
 979:../FreeRTOS/Source/tasks.c ****         }
 509              	 .loc 1 979 0
 510 00be 84F85CA0 	 strb r10,[r4,#92]
1044:../FreeRTOS/Source/tasks.c ****                 }
 511              	 .loc 1 1044 0
 512 00c2 2846     	 mov r0,r5
 513 00c4 4146     	 mov r1,r8
 514 00c6 4A46     	 mov r2,r9
 515 00c8 FFF7FEFF 	 bl pxPortInitialiseStack
 516              	.LVL50:
 517 00cc 2060     	 str r0,[r4]
1050:../FreeRTOS/Source/tasks.c ****     {
 518              	 .loc 1 1050 0
 519 00ce 06B1     	 cbz r6,.L40
1054:../FreeRTOS/Source/tasks.c ****     }
 520              	 .loc 1 1054 0
 521 00d0 3460     	 str r4,[r6]
 522              	.L40:
 523              	.LVL51:
 524              	.LBE150:
 525              	.LBE152:
 526              	.LBB153:
 527              	.LBB154:
1067:../FreeRTOS/Source/tasks.c ****     {
 528              	 .loc 1 1067 0
 529 00d2 FFF7FEFF 	 bl vPortEnterCritical
 530              	.LVL52:
1069:../FreeRTOS/Source/tasks.c **** 
 531              	 .loc 1 1069 0
 532 00d6 354A     	 ldr r2,.L52
 533 00d8 1368     	 ldr r3,[r2]
 534 00da 0133     	 adds r3,r3,#1
 535 00dc 1360     	 str r3,[r2]
1071:../FreeRTOS/Source/tasks.c ****         {
 536              	 .loc 1 1071 0
 537 00de 344B     	 ldr r3,.L52+4
 538 00e0 1B68     	 ldr r3,[r3]
 539 00e2 1BBB     	 cbnz r3,.L41
1075:../FreeRTOS/Source/tasks.c **** 
 540              	 .loc 1 1075 0
 541 00e4 324B     	 ldr r3,.L52+4
 542 00e6 1C60     	 str r4,[r3]
1077:../FreeRTOS/Source/tasks.c ****             {
 543              	 .loc 1 1077 0
 544 00e8 1368     	 ldr r3,[r2]
 545 00ea 012B     	 cmp r3,#1
 546 00ec 29D1     	 bne .L42
 547 00ee 314D     	 ldr r5,.L52+8
 548              	.LVL53:
 549 00f0 05F1C806 	 add r6,r5,#200
 550              	.LVL54:
 551              	.L43:
 552              	.LBB155:
 553              	.LBB156:
3638:../FreeRTOS/Source/tasks.c ****     }
 554              	 .loc 1 3638 0
 555 00f4 2846     	 mov r0,r5
 556 00f6 FFF7FEFF 	 bl vListInitialise
 557              	.LVL55:
 558 00fa 1435     	 adds r5,r5,#20
3636:../FreeRTOS/Source/tasks.c ****     {
 559              	 .loc 1 3636 0
 560 00fc B542     	 cmp r5,r6
 561 00fe F9D1     	 bne .L43
3641:../FreeRTOS/Source/tasks.c ****     vListInitialise( &xDelayedTaskList2 );
 562              	 .loc 1 3641 0
 563 0100 2D4E     	 ldr r6,.L52+12
 564 0102 3046     	 mov r0,r6
 565 0104 FFF7FEFF 	 bl vListInitialise
 566              	.LVL56:
3642:../FreeRTOS/Source/tasks.c ****     vListInitialise( &xPendingReadyList );
 567              	 .loc 1 3642 0
 568 0108 2C4D     	 ldr r5,.L52+16
 569 010a 2846     	 mov r0,r5
 570 010c FFF7FEFF 	 bl vListInitialise
 571              	.LVL57:
3643:../FreeRTOS/Source/tasks.c **** 
 572              	 .loc 1 3643 0
 573 0110 2B48     	 ldr r0,.L52+20
 574 0112 FFF7FEFF 	 bl vListInitialise
 575              	.LVL58:
3647:../FreeRTOS/Source/tasks.c ****         }
 576              	 .loc 1 3647 0
 577 0116 2B48     	 ldr r0,.L52+24
 578 0118 FFF7FEFF 	 bl vListInitialise
 579              	.LVL59:
3653:../FreeRTOS/Source/tasks.c ****         }
 580              	 .loc 1 3653 0
 581 011c 2A48     	 ldr r0,.L52+28
 582 011e FFF7FEFF 	 bl vListInitialise
 583              	.LVL60:
3659:../FreeRTOS/Source/tasks.c ****     pxOverflowDelayedTaskList = &xDelayedTaskList2;
 584              	 .loc 1 3659 0
 585 0122 2A4B     	 ldr r3,.L52+32
 586 0124 1E60     	 str r6,[r3]
3660:../FreeRTOS/Source/tasks.c **** }
 587              	 .loc 1 3660 0
 588 0126 2A4B     	 ldr r3,.L52+36
 589 0128 1D60     	 str r5,[r3]
 590 012a 0AE0     	 b .L42
 591              	.LVL61:
 592              	.L41:
 593              	.LBE156:
 594              	.LBE155:
1094:../FreeRTOS/Source/tasks.c ****             {
 595              	 .loc 1 1094 0
 596 012c 294B     	 ldr r3,.L52+40
 597 012e 1B68     	 ldr r3,[r3]
 598 0130 3BB9     	 cbnz r3,.L42
1096:../FreeRTOS/Source/tasks.c ****                 {
 599              	 .loc 1 1096 0
 600 0132 1F4B     	 ldr r3,.L52+4
 601 0134 1B68     	 ldr r3,[r3]
 602 0136 DA6A     	 ldr r2,[r3,#44]
 603 0138 E36A     	 ldr r3,[r4,#44]
 604 013a 9A42     	 cmp r2,r3
1098:../FreeRTOS/Source/tasks.c ****                 }
 605              	 .loc 1 1098 0
 606 013c 9CBF     	 itt ls
 607 013e 1C4B     	 ldrls r3,.L52+4
 608 0140 1C60     	 strls r4,[r3]
 609              	.LVL62:
 610              	.L42:
1111:../FreeRTOS/Source/tasks.c **** 
 611              	 .loc 1 1111 0
 612 0142 254A     	 ldr r2,.L52+44
 613 0144 1368     	 ldr r3,[r2]
 614 0146 0133     	 adds r3,r3,#1
 615 0148 1360     	 str r3,[r2]
1116:../FreeRTOS/Source/tasks.c ****             }
 616              	 .loc 1 1116 0
 617 014a A364     	 str r3,[r4,#72]
1121:../FreeRTOS/Source/tasks.c **** 
 618              	 .loc 1 1121 0
 619 014c E06A     	 ldr r0,[r4,#44]
 620 014e 2349     	 ldr r1,.L52+48
 621 0150 0A68     	 ldr r2,[r1]
 622 0152 0123     	 movs r3,#1
 623 0154 8340     	 lsls r3,r3,r0
 624 0156 1343     	 orrs r3,r3,r2
 625 0158 0B60     	 str r3,[r1]
 626 015a 00EB8000 	 add r0,r0,r0,lsl#2
 627 015e 154B     	 ldr r3,.L52+8
 628 0160 03EB8000 	 add r0,r3,r0,lsl#2
 629 0164 5946     	 mov r1,fp
 630 0166 FFF7FEFF 	 bl vListInsertEnd
 631              	.LVL63:
1125:../FreeRTOS/Source/tasks.c **** 
 632              	 .loc 1 1125 0
 633 016a FFF7FEFF 	 bl vPortExitCritical
 634              	.LVL64:
1127:../FreeRTOS/Source/tasks.c ****     {
 635              	 .loc 1 1127 0
 636 016e 194B     	 ldr r3,.L52+40
 637 0170 1B68     	 ldr r3,[r3]
 638 0172 83B1     	 cbz r3,.L45
1131:../FreeRTOS/Source/tasks.c ****         {
 639              	 .loc 1 1131 0
 640 0174 0E4B     	 ldr r3,.L52+4
 641 0176 1B68     	 ldr r3,[r3]
 642 0178 DA6A     	 ldr r2,[r3,#44]
 643 017a E36A     	 ldr r3,[r4,#44]
 644 017c 9A42     	 cmp r2,r3
 645 017e 0DD2     	 bcs .L46
1133:../FreeRTOS/Source/tasks.c ****         }
 646              	 .loc 1 1133 0
 647 0180 4FF08052 	 mov r2,#268435456
 648 0184 164B     	 ldr r3,.L52+52
 649 0186 1A60     	 str r2,[r3]
 650              	.LVL65:
 651              	
 652 0188 BFF34F8F 	 dsb
 653              	
 654              	
 655 018c BFF36F8F 	 isb
 656              	
 657              	 .thumb
 658              	.LBE154:
 659              	.LBE153:
 799:../FreeRTOS/Source/tasks.c ****         }
 660              	 .loc 1 799 0
 661 0190 0120     	 movs r0,#1
 662 0192 BDE8F88F 	 pop {r3,r4,r5,r6,r7,r8,r9,r10,fp,pc}
 663              	.LVL66:
 664              	.L45:
 665 0196 0120     	 movs r0,#1
 666 0198 BDE8F88F 	 pop {r3,r4,r5,r6,r7,r8,r9,r10,fp,pc}
 667              	.LVL67:
 668              	.L46:
 669 019c 0120     	 movs r0,#1
 670 019e BDE8F88F 	 pop {r3,r4,r5,r6,r7,r8,r9,r10,fp,pc}
 671              	.LVL68:
 672              	.L33:
 803:../FreeRTOS/Source/tasks.c ****         }
 673              	 .loc 1 803 0
 674 01a2 4FF0FF30 	 mov r0,#-1
 675              	.LVL69:
 807:../FreeRTOS/Source/tasks.c **** 
 676              	 .loc 1 807 0
 677 01a6 BDE8F88F 	 pop {r3,r4,r5,r6,r7,r8,r9,r10,fp,pc}
 678              	.LVL70:
 679              	.L53:
 680 01aa 00BF     	 .align 2
 681              	.L52:
 682 01ac 00000000 	 .word .LANCHOR10
 683 01b0 00000000 	 .word .LANCHOR5
 684 01b4 00000000 	 .word .LANCHOR11
 685 01b8 00000000 	 .word .LANCHOR12
 686 01bc 00000000 	 .word .LANCHOR13
 687 01c0 00000000 	 .word .LANCHOR1
 688 01c4 00000000 	 .word .LANCHOR9
 689 01c8 00000000 	 .word .LANCHOR0
 690 01cc 00000000 	 .word .LANCHOR2
 691 01d0 00000000 	 .word .LANCHOR7
 692 01d4 00000000 	 .word .LANCHOR14
 693 01d8 00000000 	 .word .LANCHOR15
 694 01dc 00000000 	 .word .LANCHOR6
 695 01e0 04ED00E0 	 .word -536810236
 696              	 .cfi_endproc
 697              	.LFE5:
 699              	 .section .text.vTaskDelete,"ax",%progbits
 700              	 .align 2
 701              	 .global vTaskDelete
 702              	 .thumb
 703              	 .thumb_func
 705              	vTaskDelete:
 706              	.LFB8:
1150:../FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
 707              	 .loc 1 1150 0
 708              	 .cfi_startproc
 709              	 
 710              	 
 711              	.LVL71:
 712 0000 38B5     	 push {r3,r4,r5,lr}
 713              	.LCFI3:
 714              	 .cfi_def_cfa_offset 16
 715              	 .cfi_offset 3,-16
 716              	 .cfi_offset 4,-12
 717              	 .cfi_offset 5,-8
 718              	 .cfi_offset 14,-4
 719 0002 0446     	 mov r4,r0
1153:../FreeRTOS/Source/tasks.c ****         {
 720              	 .loc 1 1153 0
 721 0004 FFF7FEFF 	 bl vPortEnterCritical
 722              	.LVL72:
1157:../FreeRTOS/Source/tasks.c **** 
 723              	 .loc 1 1157 0
 724 0008 0CB9     	 cbnz r4,.L55
1157:../FreeRTOS/Source/tasks.c **** 
 725              	 .loc 1 1157 0 is_stmt 0 discriminator 1
 726 000a 2B4B     	 ldr r3,.L64
 727 000c 1C68     	 ldr r4,[r3]
 728              	.LVL73:
 729              	.L55:
1160:../FreeRTOS/Source/tasks.c ****             {
 730              	 .loc 1 1160 0 is_stmt 1 discriminator 4
 731 000e 251D     	 adds r5,r4,#4
 732 0010 2846     	 mov r0,r5
 733 0012 FFF7FEFF 	 bl uxListRemove
 734              	.LVL74:
 735 0016 68B9     	 cbnz r0,.L56
1162:../FreeRTOS/Source/tasks.c ****             }
 736              	 .loc 1 1162 0
 737 0018 E16A     	 ldr r1,[r4,#44]
 738 001a 01EB8103 	 add r3,r1,r1,lsl#2
 739 001e 9B00     	 lsls r3,r3,#2
 740 0020 264A     	 ldr r2,.L64+4
 741 0022 D358     	 ldr r3,[r2,r3]
 742 0024 33B9     	 cbnz r3,.L56
1162:../FreeRTOS/Source/tasks.c ****             }
 743              	 .loc 1 1162 0 is_stmt 0 discriminator 1
 744 0026 2648     	 ldr r0,.L64+8
 745 0028 0368     	 ldr r3,[r0]
 746 002a 0122     	 movs r2,#1
 747 002c 8A40     	 lsls r2,r2,r1
 748 002e 23EA0203 	 bic r3,r3,r2
 749 0032 0360     	 str r3,[r0]
 750              	.L56:
1170:../FreeRTOS/Source/tasks.c ****             {
 751              	 .loc 1 1170 0 is_stmt 1
 752 0034 A36A     	 ldr r3,[r4,#40]
 753 0036 1BB1     	 cbz r3,.L57
1172:../FreeRTOS/Source/tasks.c ****             }
 754              	 .loc 1 1172 0
 755 0038 04F11800 	 add r0,r4,#24
 756 003c FFF7FEFF 	 bl uxListRemove
 757              	.LVL75:
 758              	.L57:
1183:../FreeRTOS/Source/tasks.c **** 
 759              	 .loc 1 1183 0
 760 0040 204A     	 ldr r2,.L64+12
 761 0042 1368     	 ldr r3,[r2]
 762 0044 0133     	 adds r3,r3,#1
 763 0046 1360     	 str r3,[r2]
1185:../FreeRTOS/Source/tasks.c ****             {
 764              	 .loc 1 1185 0
 765 0048 1B4B     	 ldr r3,.L64
 766 004a 1B68     	 ldr r3,[r3]
 767 004c 9C42     	 cmp r4,r3
 768 004e 08D1     	 bne .L58
1192:../FreeRTOS/Source/tasks.c **** 
 769              	 .loc 1 1192 0
 770 0050 1D48     	 ldr r0,.L64+16
 771 0052 2946     	 mov r1,r5
 772 0054 FFF7FEFF 	 bl vListInsertEnd
 773              	.LVL76:
1197:../FreeRTOS/Source/tasks.c **** 
 774              	 .loc 1 1197 0
 775 0058 1C4A     	 ldr r2,.L64+20
 776 005a 1368     	 ldr r3,[r2]
 777 005c 0133     	 adds r3,r3,#1
 778 005e 1360     	 str r3,[r2]
 779 0060 0BE0     	 b .L59
 780              	.L58:
1212:../FreeRTOS/Source/tasks.c ****                 traceTASK_DELETE( pxTCB );
 781              	 .loc 1 1212 0
 782 0062 1B4A     	 ldr r2,.L64+24
 783 0064 1368     	 ldr r3,[r2]
 784 0066 013B     	 subs r3,r3,#1
 785 0068 1360     	 str r3,[r2]
 786              	.LVL77:
 787              	.LBB161:
 788              	.LBB162:
3937:../FreeRTOS/Source/tasks.c ****                 vPortFree( pxTCB );
 789              	 .loc 1 3937 0
 790 006a 206B     	 ldr r0,[r4,#48]
 791 006c FFF7FEFF 	 bl vPortFree
 792              	.LVL78:
3938:../FreeRTOS/Source/tasks.c ****             }
 793              	 .loc 1 3938 0
 794 0070 2046     	 mov r0,r4
 795 0072 FFF7FEFF 	 bl vPortFree
 796              	.LVL79:
 797              	.LBE162:
 798              	.LBE161:
1218:../FreeRTOS/Source/tasks.c ****             }
 799              	 .loc 1 1218 0
 800 0076 FFF7FEFF 	 bl prvResetNextTaskUnblockTime
 801              	.LVL80:
 802              	.L59:
1221:../FreeRTOS/Source/tasks.c **** 
 803              	 .loc 1 1221 0
 804 007a FFF7FEFF 	 bl vPortExitCritical
 805              	.LVL81:
1225:../FreeRTOS/Source/tasks.c ****         {
 806              	 .loc 1 1225 0
 807 007e 154B     	 ldr r3,.L64+28
 808 0080 1B68     	 ldr r3,[r3]
 809 0082 BBB1     	 cbz r3,.L54
1227:../FreeRTOS/Source/tasks.c ****             {
 810              	 .loc 1 1227 0
 811 0084 0C4B     	 ldr r3,.L64
 812 0086 1B68     	 ldr r3,[r3]
 813 0088 9C42     	 cmp r4,r3
 814 008a 13D1     	 bne .L54
1229:../FreeRTOS/Source/tasks.c ****                 portYIELD_WITHIN_API();
 815              	 .loc 1 1229 0
 816 008c 124B     	 ldr r3,.L64+32
 817 008e 1B68     	 ldr r3,[r3]
 818 0090 43B1     	 cbz r3,.L61
 819              	.LBB163:
 820              	.LBB164:
 821              	 .loc 2 197 0
 822              	
 823 0092 4FF01403 	 mov r3,#20
 824 0096 83F31188 	 msr basepri,r3
 825 009a BFF36F8F 	 isb 
 826 009e BFF34F8F 	 dsb 
 827              	
 828              	
 829              	.LVL82:
 830              	 .thumb
 831              	.L62:
 832              	.LBE164:
 833              	.LBE163:
1229:../FreeRTOS/Source/tasks.c ****                 portYIELD_WITHIN_API();
 834              	 .loc 1 1229 0 discriminator 1
 835 00a2 FEE7     	 b .L62
 836              	.L61:
1230:../FreeRTOS/Source/tasks.c ****             }
 837              	 .loc 1 1230 0
 838 00a4 4FF08052 	 mov r2,#268435456
 839 00a8 0C4B     	 ldr r3,.L64+36
 840 00aa 1A60     	 str r2,[r3]
 841              	
 842 00ac BFF34F8F 	 dsb
 843              	
 844              	
 845 00b0 BFF36F8F 	 isb
 846              	
 847              	 .thumb
 848              	.L54:
 849 00b4 38BD     	 pop {r3,r4,r5,pc}
 850              	.LVL83:
 851              	.L65:
 852 00b6 00BF     	 .align 2
 853              	.L64:
 854 00b8 00000000 	 .word .LANCHOR5
 855 00bc 00000000 	 .word .LANCHOR11
 856 00c0 00000000 	 .word .LANCHOR6
 857 00c4 00000000 	 .word .LANCHOR15
 858 00c8 00000000 	 .word .LANCHOR9
 859 00cc 00000000 	 .word .LANCHOR8
 860 00d0 00000000 	 .word .LANCHOR10
 861 00d4 00000000 	 .word .LANCHOR14
 862 00d8 00000000 	 .word .LANCHOR16
 863 00dc 04ED00E0 	 .word -536810236
 864              	 .cfi_endproc
 865              	.LFE8:
 867              	 .section .text.eTaskGetState,"ax",%progbits
 868              	 .align 2
 869              	 .global eTaskGetState
 870              	 .thumb
 871              	 .thumb_func
 873              	eTaskGetState:
 874              	.LFB11:
1375:../FreeRTOS/Source/tasks.c ****         eTaskState eReturn;
 875              	 .loc 1 1375 0
 876              	 .cfi_startproc
 877              	 
 878              	 
 879              	.LVL84:
 880 0000 F8B5     	 push {r3,r4,r5,r6,r7,lr}
 881              	.LCFI4:
 882              	 .cfi_def_cfa_offset 24
 883              	 .cfi_offset 3,-24
 884              	 .cfi_offset 4,-20
 885              	 .cfi_offset 5,-16
 886              	 .cfi_offset 6,-12
 887              	 .cfi_offset 7,-8
 888              	 .cfi_offset 14,-4
 889              	.LVL85:
1380:../FreeRTOS/Source/tasks.c **** 
 890              	 .loc 1 1380 0
 891 0002 40B9     	 cbnz r0,.L67
 892              	.LBB165:
 893              	.LBB166:
 894              	 .loc 2 197 0
 895              	
 896 0004 4FF01403 	 mov r3,#20
 897 0008 83F31188 	 msr basepri,r3
 898 000c BFF36F8F 	 isb 
 899 0010 BFF34F8F 	 dsb 
 900              	
 901              	
 902              	.LVL86:
 903              	 .thumb
 904              	.L68:
 905              	.LBE166:
 906              	.LBE165:
1380:../FreeRTOS/Source/tasks.c **** 
 907              	 .loc 1 1380 0 discriminator 1
 908 0014 FEE7     	 b .L68
 909              	.L67:
 910 0016 0446     	 mov r4,r0
1382:../FreeRTOS/Source/tasks.c ****         {
 911              	 .loc 1 1382 0
 912 0018 174B     	 ldr r3,.L79
 913 001a 1B68     	 ldr r3,[r3]
 914 001c 9842     	 cmp r0,r3
 915 001e 21D0     	 beq .L71
1389:../FreeRTOS/Source/tasks.c ****             {
 916              	 .loc 1 1389 0
 917 0020 FFF7FEFF 	 bl vPortEnterCritical
 918              	.LVL87:
1391:../FreeRTOS/Source/tasks.c ****                 pxDelayedList = pxDelayedTaskList;
 919              	 .loc 1 1391 0
 920 0024 6569     	 ldr r5,[r4,#20]
 921              	.LVL88:
1392:../FreeRTOS/Source/tasks.c ****                 pxOverflowedDelayedList = pxOverflowDelayedTaskList;
 922              	 .loc 1 1392 0
 923 0026 154B     	 ldr r3,.L79+4
 924 0028 1F68     	 ldr r7,[r3]
 925              	.LVL89:
1393:../FreeRTOS/Source/tasks.c ****             }
 926              	 .loc 1 1393 0
 927 002a 154B     	 ldr r3,.L79+8
 928 002c 1E68     	 ldr r6,[r3]
 929              	.LVL90:
1395:../FreeRTOS/Source/tasks.c **** 
 930              	 .loc 1 1395 0
 931 002e FFF7FEFF 	 bl vPortExitCritical
 932              	.LVL91:
1397:../FreeRTOS/Source/tasks.c ****             {
 933              	 .loc 1 1397 0
 934 0032 BD42     	 cmp r5,r7
 935 0034 18D0     	 beq .L72
1397:../FreeRTOS/Source/tasks.c ****             {
 936              	 .loc 1 1397 0 is_stmt 0 discriminator 1
 937 0036 B542     	 cmp r5,r6
 938 0038 18D0     	 beq .L73
1405:../FreeRTOS/Source/tasks.c ****                 {
 939              	 .loc 1 1405 0 is_stmt 1
 940 003a 124B     	 ldr r3,.L79+12
 941 003c 9D42     	 cmp r5,r3
 942 003e 09D1     	 bne .L70
1410:../FreeRTOS/Source/tasks.c ****                     {
 943              	 .loc 1 1410 0
 944 0040 A36A     	 ldr r3,[r4,#40]
 945 0042 ABB9     	 cbnz r3,.L74
 946              	.LVL92:
 947              	.LBB167:
1425:../FreeRTOS/Source/tasks.c ****                                     {
 948              	 .loc 1 1425 0 discriminator 1
 949 0044 94F85C30 	 ldrb r3,[r4,#92]
 950 0048 DBB2     	 uxtb r3,r3
1421:../FreeRTOS/Source/tasks.c **** 
 951              	 .loc 1 1421 0 discriminator 1
 952 004a 012B     	 cmp r3,#1
 953 004c 0CBF     	 ite eq
 954 004e 0220     	 moveq r0,#2
 955 0050 0320     	 movne r0,#3
 956 0052 F8BD     	 pop {r3,r4,r5,r6,r7,pc}
 957              	.LVL93:
 958              	.L70:
 959              	.LBE167:
1446:../FreeRTOS/Source/tasks.c ****                 {
 960              	 .loc 1 1446 0
 961 0054 0C4B     	 ldr r3,.L79+16
 962 0056 9D42     	 cmp r5,r3
 963 0058 0CD0     	 beq .L76
1459:../FreeRTOS/Source/tasks.c ****             }
 964              	 .loc 1 1459 0 discriminator 1
 965 005a 002D     	 cmp r5,#0
 966 005c 0CBF     	 ite eq
 967 005e 0420     	 moveq r0,#4
 968 0060 0120     	 movne r0,#1
 969 0062 F8BD     	 pop {r3,r4,r5,r6,r7,pc}
 970              	.LVL94:
 971              	.L71:
1385:../FreeRTOS/Source/tasks.c ****         }
 972              	 .loc 1 1385 0
 973 0064 0020     	 movs r0,#0
 974              	.LVL95:
 975 0066 F8BD     	 pop {r3,r4,r5,r6,r7,pc}
 976              	.LVL96:
 977              	.L72:
1401:../FreeRTOS/Source/tasks.c ****             }
 978              	 .loc 1 1401 0
 979 0068 0220     	 movs r0,#2
 980 006a F8BD     	 pop {r3,r4,r5,r6,r7,pc}
 981              	.LVL97:
 982              	.L73:
 983 006c 0220     	 movs r0,#2
 984 006e F8BD     	 pop {r3,r4,r5,r6,r7,pc}
 985              	.LVL98:
 986              	.L74:
1440:../FreeRTOS/Source/tasks.c ****                     }
 987              	 .loc 1 1440 0
 988 0070 0220     	 movs r0,#2
 989 0072 F8BD     	 pop {r3,r4,r5,r6,r7,pc}
 990              	.LVL99:
 991              	.L76:
1451:../FreeRTOS/Source/tasks.c ****                 }
 992              	 .loc 1 1451 0
 993 0074 0420     	 movs r0,#4
 994              	.LVL100:
1464:../FreeRTOS/Source/tasks.c **** 
 995              	 .loc 1 1464 0
 996 0076 F8BD     	 pop {r3,r4,r5,r6,r7,pc}
 997              	.LVL101:
 998              	.L80:
 999              	 .align 2
 1000              	.L79:
 1001 0078 00000000 	 .word .LANCHOR5
 1002 007c 00000000 	 .word .LANCHOR2
 1003 0080 00000000 	 .word .LANCHOR7
 1004 0084 00000000 	 .word .LANCHOR0
 1005 0088 00000000 	 .word .LANCHOR9
 1006              	 .cfi_endproc
 1007              	.LFE11:
 1009              	 .section .text.uxTaskPriorityGet,"ax",%progbits
 1010              	 .align 2
 1011              	 .global uxTaskPriorityGet
 1012              	 .thumb
 1013              	 .thumb_func
 1015              	uxTaskPriorityGet:
 1016              	.LFB12:
1472:../FreeRTOS/Source/tasks.c ****         TCB_t const * pxTCB;
 1017              	 .loc 1 1472 0
 1018              	 .cfi_startproc
 1019              	 
 1020              	 
 1021              	.LVL102:
 1022 0000 10B5     	 push {r4,lr}
 1023              	.LCFI5:
 1024              	 .cfi_def_cfa_offset 8
 1025              	 .cfi_offset 4,-8
 1026              	 .cfi_offset 14,-4
 1027 0002 0446     	 mov r4,r0
1476:../FreeRTOS/Source/tasks.c ****         {
 1028              	 .loc 1 1476 0
 1029 0004 FFF7FEFF 	 bl vPortEnterCritical
 1030              	.LVL103:
1480:../FreeRTOS/Source/tasks.c ****             uxReturn = pxTCB->uxPriority;
 1031              	 .loc 1 1480 0
 1032 0008 0CB9     	 cbnz r4,.L82
1480:../FreeRTOS/Source/tasks.c ****             uxReturn = pxTCB->uxPriority;
 1033              	 .loc 1 1480 0 is_stmt 0 discriminator 1
 1034 000a 034B     	 ldr r3,.L85
 1035 000c 1C68     	 ldr r4,[r3]
 1036              	.LVL104:
 1037              	.L82:
1481:../FreeRTOS/Source/tasks.c ****         }
 1038              	 .loc 1 1481 0 is_stmt 1 discriminator 4
 1039 000e E46A     	 ldr r4,[r4,#44]
 1040              	.LVL105:
1483:../FreeRTOS/Source/tasks.c **** 
 1041              	 .loc 1 1483 0 discriminator 4
 1042 0010 FFF7FEFF 	 bl vPortExitCritical
 1043              	.LVL106:
1486:../FreeRTOS/Source/tasks.c **** 
 1044              	 .loc 1 1486 0 discriminator 4
 1045 0014 2046     	 mov r0,r4
 1046 0016 10BD     	 pop {r4,pc}
 1047              	.LVL107:
 1048              	.L86:
 1049              	 .align 2
 1050              	.L85:
 1051 0018 00000000 	 .word .LANCHOR5
 1052              	 .cfi_endproc
 1053              	.LFE12:
 1055              	 .section .text.uxTaskPriorityGetFromISR,"ax",%progbits
 1056              	 .align 2
 1057              	 .global uxTaskPriorityGetFromISR
 1058              	 .thumb
 1059              	 .thumb_func
 1061              	uxTaskPriorityGetFromISR:
 1062              	.LFB13:
1494:../FreeRTOS/Source/tasks.c ****         TCB_t const * pxTCB;
 1063              	 .loc 1 1494 0
 1064              	 .cfi_startproc
 1065              	 
 1066              	 
 1067              	.LVL108:
 1068 0000 10B5     	 push {r4,lr}
 1069              	.LCFI6:
 1070              	 .cfi_def_cfa_offset 8
 1071              	 .cfi_offset 4,-8
 1072              	 .cfi_offset 14,-4
 1073 0002 0446     	 mov r4,r0
1514:../FreeRTOS/Source/tasks.c **** 
 1074              	 .loc 1 1514 0
 1075 0004 FFF7FEFF 	 bl vPortValidateInterruptPriority
 1076              	.LVL109:
 1077              	.LBB168:
 1078              	.LBB169:
 198:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 199:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             "	mov %0, %1												\n"\
 200:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             "	msr basepri, %0											\n"\
 201:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             "	isb														\n"\
 202:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             "	dsb														\n"\
 203:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             : "=r" ( ulNewBASEPRI ) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
 204:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         );
 205:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     }
 206:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 207:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 208:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 209:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
 210:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     {
 211:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         uint32_t ulOriginalBASEPRI, ulNewBASEPRI;
 212:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 213:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile
 1079              	 .loc 2 213 0
 1080              	
 1081 0008 EFF31183 	 mrs r3,basepri
 1082 000c 4FF01402 	 mov r2,#20
 1083 0010 82F31188 	 msr basepri,r2
 1084 0014 BFF36F8F 	 isb 
 1085 0018 BFF34F8F 	 dsb 
 1086              	
 1087              	
 1088              	.LVL110:
 1089              	 .thumb
 1090              	.LBE169:
 1091              	.LBE168:
1520:../FreeRTOS/Source/tasks.c ****             uxReturn = pxTCB->uxPriority;
 1092              	 .loc 1 1520 0
 1093 001c 0CB9     	 cbnz r4,.L88
1520:../FreeRTOS/Source/tasks.c ****             uxReturn = pxTCB->uxPriority;
 1094              	 .loc 1 1520 0 is_stmt 0 discriminator 1
 1095 001e 034A     	 ldr r2,.L91
 1096 0020 1468     	 ldr r4,[r2]
 1097              	.LVL111:
 1098              	.L88:
1521:../FreeRTOS/Source/tasks.c ****         }
 1099              	 .loc 1 1521 0 is_stmt 1 discriminator 4
 1100 0022 E06A     	 ldr r0,[r4,#44]
 1101              	.LVL112:
 1102              	.LBB170:
 1103              	.LBB171:
 214:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 215:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             "	mrs %0, basepri											\n"\
 216:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             "	mov %1, %2												\n"\
 217:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             "	msr basepri, %1											\n"\
 218:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             "	isb														\n"\
 219:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             "	dsb														\n"\
 220:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             : "=r" ( ulOriginalBASEPRI ), "=r" ( ulNewBASEPRI ) : "i" ( configMAX_SYSCALL_INTERRUPT
 221:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         );
 222:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 223:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         /* This return will not be reached but is necessary to prevent compiler
 224:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****          * warnings. */
 225:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         return ulOriginalBASEPRI;
 226:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     }
 227:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 228:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 229:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
 230:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     {
 231:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile
 1104              	 .loc 2 231 0 discriminator 4
 1105              	
 1106 0024 83F31188 	 msr basepri,r3
 1107              	
 1108              	 .thumb
 1109              	.LBE171:
 1110              	.LBE170:
1526:../FreeRTOS/Source/tasks.c **** 
 1111              	 .loc 1 1526 0 discriminator 4
 1112 0028 10BD     	 pop {r4,pc}
 1113              	.LVL113:
 1114              	.L92:
 1115 002a 00BF     	 .align 2
 1116              	.L91:
 1117 002c 00000000 	 .word .LANCHOR5
 1118              	 .cfi_endproc
 1119              	.LFE13:
 1121              	 .section .text.vTaskPrioritySet,"ax",%progbits
 1122              	 .align 2
 1123              	 .global vTaskPrioritySet
 1124              	 .thumb
 1125              	 .thumb_func
 1127              	vTaskPrioritySet:
 1128              	.LFB14:
1535:../FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
 1129              	 .loc 1 1535 0
 1130              	 .cfi_startproc
 1131              	 
 1132              	 
 1133              	.LVL114:
 1134 0000 F8B5     	 push {r3,r4,r5,r6,r7,lr}
 1135              	.LCFI7:
 1136              	 .cfi_def_cfa_offset 24
 1137              	 .cfi_offset 3,-24
 1138              	 .cfi_offset 4,-20
 1139              	 .cfi_offset 5,-16
 1140              	 .cfi_offset 6,-12
 1141              	 .cfi_offset 7,-8
 1142              	 .cfi_offset 14,-4
 1143              	.LVL115:
1540:../FreeRTOS/Source/tasks.c **** 
 1144              	 .loc 1 1540 0
 1145 0002 0929     	 cmp r1,#9
 1146 0004 08D9     	 bls .L94
 1147              	.LBB172:
 1148              	.LBB173:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 1149              	 .loc 2 197 0
 1150              	
 1151 0006 4FF01403 	 mov r3,#20
 1152 000a 83F31188 	 msr basepri,r3
 1153 000e BFF36F8F 	 isb 
 1154 0012 BFF34F8F 	 dsb 
 1155              	
 1156              	
 1157              	.LVL116:
 1158              	 .thumb
 1159              	.L95:
 1160              	.LBE173:
 1161              	.LBE172:
1540:../FreeRTOS/Source/tasks.c **** 
 1162              	 .loc 1 1540 0 discriminator 1
 1163 0016 FEE7     	 b .L95
 1164              	.L94:
 1165 0018 0446     	 mov r4,r0
 1166 001a 0929     	 cmp r1,#9
 1167 001c 28BF     	 it cs
 1168 001e 0921     	 movcs r1,#9
 1169              	.LVL117:
 1170 0020 0D46     	 mov r5,r1
 1171              	.LVL118:
1552:../FreeRTOS/Source/tasks.c ****         {
 1172              	 .loc 1 1552 0
 1173 0022 FFF7FEFF 	 bl vPortEnterCritical
 1174              	.LVL119:
1556:../FreeRTOS/Source/tasks.c **** 
 1175              	 .loc 1 1556 0
 1176 0026 0CB9     	 cbnz r4,.L96
1556:../FreeRTOS/Source/tasks.c **** 
 1177              	 .loc 1 1556 0 is_stmt 0 discriminator 1
 1178 0028 294B     	 ldr r3,.L106
 1179 002a 1C68     	 ldr r4,[r3]
 1180              	.LVL120:
 1181              	.L96:
1562:../FreeRTOS/Source/tasks.c ****                 }
 1182              	 .loc 1 1562 0 is_stmt 1 discriminator 4
 1183 002c 236D     	 ldr r3,[r4,#80]
 1184              	.LVL121:
1570:../FreeRTOS/Source/tasks.c ****             {
 1185              	 .loc 1 1570 0 discriminator 4
 1186 002e AB42     	 cmp r3,r5
 1187 0030 4BD0     	 beq .L97
1574:../FreeRTOS/Source/tasks.c ****                 {
 1188              	 .loc 1 1574 0
 1189 0032 0BD2     	 bcs .L98
1576:../FreeRTOS/Source/tasks.c ****                     {
 1190              	 .loc 1 1576 0
 1191 0034 264A     	 ldr r2,.L106
 1192 0036 1268     	 ldr r2,[r2]
 1193 0038 9442     	 cmp r4,r2
 1194 003a 0ED0     	 beq .L104
1581:../FreeRTOS/Source/tasks.c ****                         {
 1195              	 .loc 1 1581 0
 1196 003c 244A     	 ldr r2,.L106
 1197 003e 1268     	 ldr r2,[r2]
 1198 0040 D66A     	 ldr r6,[r2,#44]
 1199 0042 AE42     	 cmp r6,r5
 1200 0044 8CBF     	 ite hi
 1201 0046 0026     	 movhi r6,#0
 1202 0048 0126     	 movls r6,#1
 1203 004a 07E0     	 b .L99
 1204              	.L98:
1597:../FreeRTOS/Source/tasks.c ****                 {
 1205              	 .loc 1 1597 0
 1206 004c 204A     	 ldr r2,.L106
 1207 004e 1668     	 ldr r6,[r2]
 1208 0050 B442     	 cmp r4,r6
 1209 0052 14BF     	 ite ne
 1210 0054 0026     	 movne r6,#0
 1211 0056 0126     	 moveq r6,#1
 1212 0058 00E0     	 b .L99
 1213              	.L104:
1538:../FreeRTOS/Source/tasks.c **** 
 1214              	 .loc 1 1538 0
 1215 005a 0026     	 movs r6,#0
 1216              	.L99:
 1217              	.LVL122:
1614:../FreeRTOS/Source/tasks.c **** 
 1218              	 .loc 1 1614 0
 1219 005c E76A     	 ldr r7,[r4,#44]
 1220              	.LVL123:
1620:../FreeRTOS/Source/tasks.c ****                         {
 1221              	 .loc 1 1620 0
 1222 005e BB42     	 cmp r3,r7
1622:../FreeRTOS/Source/tasks.c ****                         }
 1223              	 .loc 1 1622 0
 1224 0060 08BF     	 it eq
 1225 0062 E562     	 streq r5,[r4,#44]
1630:../FreeRTOS/Source/tasks.c ****                     }
 1226              	 .loc 1 1630 0
 1227 0064 2565     	 str r5,[r4,#80]
1640:../FreeRTOS/Source/tasks.c ****                 {
 1228              	 .loc 1 1640 0
 1229 0066 A369     	 ldr r3,[r4,#24]
 1230              	.LVL124:
 1231 0068 002B     	 cmp r3,#0
1642:../FreeRTOS/Source/tasks.c ****                 }
 1232              	 .loc 1 1642 0
 1233 006a A4BF     	 itt ge
 1234 006c C5F10A05 	 rsbge r5,r5,#10
 1235              	.LVL125:
 1236 0070 A561     	 strge r5,[r4,#24]
1653:../FreeRTOS/Source/tasks.c ****                 {
 1237              	 .loc 1 1653 0
 1238 0072 07EB8702 	 add r2,r7,r7,lsl#2
 1239 0076 174B     	 ldr r3,.L106+4
 1240 0078 03EB8203 	 add r3,r3,r2,lsl#2
 1241 007c 6269     	 ldr r2,[r4,#20]
 1242 007e 9A42     	 cmp r2,r3
 1243 0080 1AD1     	 bne .L102
1658:../FreeRTOS/Source/tasks.c ****                     {
 1244              	 .loc 1 1658 0
 1245 0082 251D     	 adds r5,r4,#4
 1246 0084 2846     	 mov r0,r5
 1247 0086 FFF7FEFF 	 bl uxListRemove
 1248              	.LVL126:
 1249 008a 30B9     	 cbnz r0,.L103
1663:../FreeRTOS/Source/tasks.c ****                     }
 1250              	 .loc 1 1663 0
 1251 008c 1249     	 ldr r1,.L106+8
 1252 008e 0B68     	 ldr r3,[r1]
 1253 0090 0122     	 movs r2,#1
 1254 0092 BA40     	 lsls r2,r2,r7
 1255 0094 23EA0203 	 bic r3,r3,r2
 1256 0098 0B60     	 str r3,[r1]
 1257              	.L103:
1670:../FreeRTOS/Source/tasks.c ****                 }
 1258              	 .loc 1 1670 0
 1259 009a E06A     	 ldr r0,[r4,#44]
 1260 009c 0E49     	 ldr r1,.L106+8
 1261 009e 0B68     	 ldr r3,[r1]
 1262 00a0 0122     	 movs r2,#1
 1263 00a2 8240     	 lsls r2,r2,r0
 1264 00a4 1343     	 orrs r3,r3,r2
 1265 00a6 0B60     	 str r3,[r1]
 1266 00a8 00EB8000 	 add r0,r0,r0,lsl#2
 1267 00ac 094B     	 ldr r3,.L106+4
 1268 00ae 03EB8000 	 add r0,r3,r0,lsl#2
 1269 00b2 2946     	 mov r1,r5
 1270 00b4 FFF7FEFF 	 bl vListInsertEnd
 1271              	.LVL127:
 1272              	.L102:
1677:../FreeRTOS/Source/tasks.c ****                 {
 1273              	 .loc 1 1677 0
 1274 00b8 3EB1     	 cbz r6,.L97
1679:../FreeRTOS/Source/tasks.c ****                 }
 1275              	 .loc 1 1679 0
 1276 00ba 4FF08052 	 mov r2,#268435456
 1277 00be 074B     	 ldr r3,.L106+12
 1278 00c0 1A60     	 str r2,[r3]
 1279              	
 1280 00c2 BFF34F8F 	 dsb
 1281              	
 1282              	
 1283 00c6 BFF36F8F 	 isb
 1284              	
 1285              	.LVL128:
 1286              	 .thumb
 1287              	.L97:
1691:../FreeRTOS/Source/tasks.c ****     }
 1288              	 .loc 1 1691 0
 1289 00ca FFF7FEFF 	 bl vPortExitCritical
 1290              	.LVL129:
 1291 00ce F8BD     	 pop {r3,r4,r5,r6,r7,pc}
 1292              	.LVL130:
 1293              	.L107:
 1294              	 .align 2
 1295              	.L106:
 1296 00d0 00000000 	 .word .LANCHOR5
 1297 00d4 00000000 	 .word .LANCHOR11
 1298 00d8 00000000 	 .word .LANCHOR6
 1299 00dc 04ED00E0 	 .word -536810236
 1300              	 .cfi_endproc
 1301              	.LFE14:
 1303              	 .section .text.vTaskResume,"ax",%progbits
 1304              	 .align 2
 1305              	 .global vTaskResume
 1306              	 .thumb
 1307              	 .thumb_func
 1309              	vTaskResume:
 1310              	.LFB17:
1852:../FreeRTOS/Source/tasks.c ****         TCB_t * const pxTCB = xTaskToResume;
 1311              	 .loc 1 1852 0
 1312              	 .cfi_startproc
 1313              	 
 1314              	 
 1315              	.LVL131:
 1316 0000 38B5     	 push {r3,r4,r5,lr}
 1317              	.LCFI8:
 1318              	 .cfi_def_cfa_offset 16
 1319              	 .cfi_offset 3,-16
 1320              	 .cfi_offset 4,-12
 1321              	 .cfi_offset 5,-8
 1322              	 .cfi_offset 14,-4
 1323              	.LVL132:
1856:../FreeRTOS/Source/tasks.c **** 
 1324              	 .loc 1 1856 0
 1325 0002 40B9     	 cbnz r0,.L109
 1326              	.LBB174:
 1327              	.LBB175:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 1328              	 .loc 2 197 0
 1329              	
 1330 0004 4FF01403 	 mov r3,#20
 1331 0008 83F31188 	 msr basepri,r3
 1332 000c BFF36F8F 	 isb 
 1333 0010 BFF34F8F 	 dsb 
 1334              	
 1335              	
 1336              	.LVL133:
 1337              	 .thumb
 1338              	.L110:
 1339              	.LBE175:
 1340              	.LBE174:
1856:../FreeRTOS/Source/tasks.c **** 
 1341              	 .loc 1 1856 0 discriminator 1
 1342 0014 FEE7     	 b .L110
 1343              	.L109:
 1344 0016 0446     	 mov r4,r0
1860:../FreeRTOS/Source/tasks.c ****         {
 1345              	 .loc 1 1860 0
 1346 0018 164B     	 ldr r3,.L114
 1347 001a 1B68     	 ldr r3,[r3]
 1348 001c 9842     	 cmp r0,r3
 1349 001e 28D0     	 beq .L108
1862:../FreeRTOS/Source/tasks.c ****             {
 1350              	 .loc 1 1862 0
 1351 0020 FFF7FEFF 	 bl vPortEnterCritical
 1352              	.LVL134:
1864:../FreeRTOS/Source/tasks.c ****                 {
 1353              	 .loc 1 1864 0
 1354 0024 2046     	 mov r0,r4
 1355 0026 FFF7FEFF 	 bl prvTaskIsTaskSuspended
 1356              	.LVL135:
 1357 002a 00B3     	 cbz r0,.L112
1870:../FreeRTOS/Source/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
 1358              	 .loc 1 1870 0
 1359 002c 251D     	 adds r5,r4,#4
 1360 002e 2846     	 mov r0,r5
 1361 0030 FFF7FEFF 	 bl uxListRemove
 1362              	.LVL136:
1871:../FreeRTOS/Source/tasks.c **** 
 1363              	 .loc 1 1871 0
 1364 0034 E06A     	 ldr r0,[r4,#44]
 1365 0036 1049     	 ldr r1,.L114+4
 1366 0038 0B68     	 ldr r3,[r1]
 1367 003a 0122     	 movs r2,#1
 1368 003c 8240     	 lsls r2,r2,r0
 1369 003e 1343     	 orrs r3,r3,r2
 1370 0040 0B60     	 str r3,[r1]
 1371 0042 00EB8000 	 add r0,r0,r0,lsl#2
 1372 0046 0D4B     	 ldr r3,.L114+8
 1373 0048 03EB8000 	 add r0,r3,r0,lsl#2
 1374 004c 2946     	 mov r1,r5
 1375 004e FFF7FEFF 	 bl vListInsertEnd
 1376              	.LVL137:
1874:../FreeRTOS/Source/tasks.c ****                     {
 1377              	 .loc 1 1874 0
 1378 0052 084B     	 ldr r3,.L114
 1379 0054 1B68     	 ldr r3,[r3]
 1380 0056 E26A     	 ldr r2,[r4,#44]
 1381 0058 DB6A     	 ldr r3,[r3,#44]
 1382 005a 9A42     	 cmp r2,r3
 1383 005c 07D3     	 bcc .L112
1879:../FreeRTOS/Source/tasks.c ****                     }
 1384              	 .loc 1 1879 0
 1385 005e 4FF08052 	 mov r2,#268435456
 1386 0062 074B     	 ldr r3,.L114+12
 1387 0064 1A60     	 str r2,[r3]
 1388              	
 1389 0066 BFF34F8F 	 dsb
 1390              	
 1391              	
 1392 006a BFF36F8F 	 isb
 1393              	
 1394              	 .thumb
 1395              	.L112:
1891:../FreeRTOS/Source/tasks.c ****         }
 1396              	 .loc 1 1891 0
 1397 006e FFF7FEFF 	 bl vPortExitCritical
 1398              	.LVL138:
 1399              	.L108:
 1400 0072 38BD     	 pop {r3,r4,r5,pc}
 1401              	.LVL139:
 1402              	.L115:
 1403              	 .align 2
 1404              	.L114:
 1405 0074 00000000 	 .word .LANCHOR5
 1406 0078 00000000 	 .word .LANCHOR6
 1407 007c 00000000 	 .word .LANCHOR11
 1408 0080 04ED00E0 	 .word -536810236
 1409              	 .cfi_endproc
 1410              	.LFE17:
 1412              	 .section .text.xTaskResumeFromISR,"ax",%progbits
 1413              	 .align 2
 1414              	 .global xTaskResumeFromISR
 1415              	 .thumb
 1416              	 .thumb_func
 1418              	xTaskResumeFromISR:
 1419              	.LFB18:
1906:../FreeRTOS/Source/tasks.c ****         BaseType_t xYieldRequired = pdFALSE;
 1420              	 .loc 1 1906 0
 1421              	 .cfi_startproc
 1422              	 
 1423              	 
 1424              	.LVL140:
 1425 0000 F8B5     	 push {r3,r4,r5,r6,r7,lr}
 1426              	.LCFI9:
 1427              	 .cfi_def_cfa_offset 24
 1428              	 .cfi_offset 3,-24
 1429              	 .cfi_offset 4,-20
 1430              	 .cfi_offset 5,-16
 1431              	 .cfi_offset 6,-12
 1432              	 .cfi_offset 7,-8
 1433              	 .cfi_offset 14,-4
 1434              	.LVL141:
1911:../FreeRTOS/Source/tasks.c **** 
 1435              	 .loc 1 1911 0
 1436 0002 40B9     	 cbnz r0,.L117
 1437              	.LBB176:
 1438              	.LBB177:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 1439              	 .loc 2 197 0
 1440              	
 1441 0004 4FF01403 	 mov r3,#20
 1442 0008 83F31188 	 msr basepri,r3
 1443 000c BFF36F8F 	 isb 
 1444 0010 BFF34F8F 	 dsb 
 1445              	
 1446              	
 1447              	.LVL142:
 1448              	 .thumb
 1449              	.L118:
 1450              	.LBE177:
 1451              	.LBE176:
1911:../FreeRTOS/Source/tasks.c **** 
 1452              	 .loc 1 1911 0 discriminator 1
 1453 0014 FEE7     	 b .L118
 1454              	.L117:
 1455 0016 0446     	 mov r4,r0
1929:../FreeRTOS/Source/tasks.c **** 
 1456              	 .loc 1 1929 0
 1457 0018 FFF7FEFF 	 bl vPortValidateInterruptPriority
 1458              	.LVL143:
 1459              	.LBB178:
 1460              	.LBB179:
 213:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 1461              	 .loc 2 213 0
 1462              	
 1463 001c EFF31187 	 mrs r7,basepri
 1464 0020 4FF01403 	 mov r3,#20
 1465 0024 83F31188 	 msr basepri,r3
 1466 0028 BFF36F8F 	 isb 
 1467 002c BFF34F8F 	 dsb 
 1468              	
 1469              	
 1470              	.LVL144:
 1471              	 .thumb
 1472              	.LBE179:
 1473              	.LBE178:
1933:../FreeRTOS/Source/tasks.c ****             {
 1474              	 .loc 1 1933 0
 1475 0030 2046     	 mov r0,r4
 1476 0032 FFF7FEFF 	 bl prvTaskIsTaskSuspended
 1477              	.LVL145:
 1478 0036 28B3     	 cbz r0,.L121
1938:../FreeRTOS/Source/tasks.c ****                 {
 1479              	 .loc 1 1938 0
 1480 0038 154B     	 ldr r3,.L123
 1481 003a 1B68     	 ldr r3,[r3]
 1482 003c DBB9     	 cbnz r3,.L120
1942:../FreeRTOS/Source/tasks.c ****                     {
 1483              	 .loc 1 1942 0
 1484 003e 154B     	 ldr r3,.L123+4
 1485 0040 1B68     	 ldr r3,[r3]
 1486 0042 E56A     	 ldr r5,[r4,#44]
 1487 0044 DB6A     	 ldr r3,[r3,#44]
 1488 0046 9D42     	 cmp r5,r3
 1489 0048 34BF     	 ite cc
 1490 004a 0025     	 movcc r5,#0
 1491 004c 0125     	 movcs r5,#1
 1492              	.LVL146:
1951:../FreeRTOS/Source/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
 1493              	 .loc 1 1951 0
 1494 004e 261D     	 adds r6,r4,#4
 1495 0050 3046     	 mov r0,r6
 1496 0052 FFF7FEFF 	 bl uxListRemove
 1497              	.LVL147:
1952:../FreeRTOS/Source/tasks.c ****                 }
 1498              	 .loc 1 1952 0
 1499 0056 E06A     	 ldr r0,[r4,#44]
 1500 0058 0F49     	 ldr r1,.L123+8
 1501 005a 0B68     	 ldr r3,[r1]
 1502 005c 0122     	 movs r2,#1
 1503 005e 8240     	 lsls r2,r2,r0
 1504 0060 1343     	 orrs r3,r3,r2
 1505 0062 0B60     	 str r3,[r1]
 1506 0064 00EB8000 	 add r0,r0,r0,lsl#2
 1507 0068 0C4B     	 ldr r3,.L123+12
 1508 006a 03EB8000 	 add r0,r3,r0,lsl#2
 1509 006e 3146     	 mov r1,r6
 1510 0070 FFF7FEFF 	 bl vListInsertEnd
 1511              	.LVL148:
 1512 0074 07E0     	 b .L119
 1513              	.LVL149:
 1514              	.L120:
1959:../FreeRTOS/Source/tasks.c ****                 }
 1515              	 .loc 1 1959 0
 1516 0076 0A48     	 ldr r0,.L123+16
 1517 0078 04F11801 	 add r1,r4,#24
 1518 007c FFF7FEFF 	 bl vListInsertEnd
 1519              	.LVL150:
1907:../FreeRTOS/Source/tasks.c ****         TCB_t * const pxTCB = xTaskToResume;
 1520              	 .loc 1 1907 0
 1521 0080 0025     	 movs r5,#0
 1522 0082 00E0     	 b .L119
 1523              	.L121:
 1524 0084 0025     	 movs r5,#0
 1525              	.LVL151:
 1526              	.L119:
 1527              	.LBB180:
 1528              	.LBB181:
 1529              	 .loc 2 231 0
 1530              	
 1531 0086 87F31188 	 msr basepri,r7
 1532              	
 1533              	 .thumb
 1534              	.LBE181:
 1535              	.LBE180:
1970:../FreeRTOS/Source/tasks.c **** 
 1536              	 .loc 1 1970 0
 1537 008a 2846     	 mov r0,r5
 1538 008c F8BD     	 pop {r3,r4,r5,r6,r7,pc}
 1539              	.LVL152:
 1540              	.L124:
 1541 008e 00BF     	 .align 2
 1542              	.L123:
 1543 0090 00000000 	 .word .LANCHOR16
 1544 0094 00000000 	 .word .LANCHOR5
 1545 0098 00000000 	 .word .LANCHOR6
 1546 009c 00000000 	 .word .LANCHOR11
 1547 00a0 00000000 	 .word .LANCHOR1
 1548              	 .cfi_endproc
 1549              	.LFE18:
 1551              	 .section .text.vTaskStartScheduler,"ax",%progbits
 1552              	 .align 2
 1553              	 .global vTaskStartScheduler
 1554              	 .thumb
 1555              	 .thumb_func
 1557              	vTaskStartScheduler:
 1558              	.LFB19:
1976:../FreeRTOS/Source/tasks.c ****     BaseType_t xReturn;
 1559              	 .loc 1 1976 0
 1560              	 .cfi_startproc
 1561              	 
 1562              	 
 1563 0000 00B5     	 push {lr}
 1564              	.LCFI10:
 1565              	 .cfi_def_cfa_offset 4
 1566              	 .cfi_offset 14,-4
 1567 0002 83B0     	 sub sp,sp,#12
 1568              	.LCFI11:
 1569              	 .cfi_def_cfa_offset 16
2009:../FreeRTOS/Source/tasks.c ****                                    configIDLE_TASK_NAME,
 1570              	 .loc 1 2009 0
 1571 0004 0023     	 movs r3,#0
 1572 0006 0093     	 str r3,[sp]
 1573 0008 184A     	 ldr r2,.L130
 1574 000a 0192     	 str r2,[sp,#4]
 1575 000c 1848     	 ldr r0,.L130+4
 1576 000e 1949     	 ldr r1,.L130+8
 1577 0010 7822     	 movs r2,#120
 1578 0012 FFF7FEFF 	 bl xTaskCreate
 1579              	.LVL153:
2020:../FreeRTOS/Source/tasks.c ****             {
 1580              	 .loc 1 2020 0
 1581 0016 0128     	 cmp r0,#1
 1582 0018 18D1     	 bne .L126
2022:../FreeRTOS/Source/tasks.c ****             }
 1583              	 .loc 1 2022 0
 1584 001a FFF7FEFF 	 bl xTimerCreateTimerTask
 1585              	.LVL154:
2031:../FreeRTOS/Source/tasks.c ****     {
 1586              	 .loc 1 2031 0
 1587 001e 0128     	 cmp r0,#1
 1588 0020 14D1     	 bne .L126
 1589              	.LBB182:
 1590              	.LBB183:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 1591              	 .loc 2 197 0
 1592              	
 1593 0022 4FF01403 	 mov r3,#20
 1594 0026 83F31188 	 msr basepri,r3
 1595 002a BFF36F8F 	 isb 
 1596 002e BFF34F8F 	 dsb 
 1597              	
 1598              	
 1599              	.LVL155:
 1600              	 .thumb
 1601              	.LBE183:
 1602              	.LBE182:
2059:../FreeRTOS/Source/tasks.c ****         xSchedulerRunning = pdTRUE;
 1603              	 .loc 1 2059 0
 1604 0032 4FF0FF32 	 mov r2,#-1
 1605 0036 104B     	 ldr r3,.L130+12
 1606 0038 1A60     	 str r2,[r3]
2060:../FreeRTOS/Source/tasks.c ****         xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 1607              	 .loc 1 2060 0
 1608 003a 0122     	 movs r2,#1
 1609 003c 0F4B     	 ldr r3,.L130+16
 1610 003e 1A60     	 str r2,[r3]
2061:../FreeRTOS/Source/tasks.c **** 
 1611              	 .loc 1 2061 0
 1612 0040 0022     	 movs r2,#0
 1613 0042 0F4B     	 ldr r3,.L130+20
 1614 0044 1A60     	 str r2,[r3]
2075:../FreeRTOS/Source/tasks.c ****         {
 1615              	 .loc 1 2075 0
 1616 0046 FFF7FEFF 	 bl xPortStartScheduler
 1617              	.LVL156:
 1618 004a 0BE0     	 b .L125
 1619              	.LVL157:
 1620              	.L126:
2090:../FreeRTOS/Source/tasks.c ****     }
 1621              	 .loc 1 2090 0
 1622 004c B0F1FF3F 	 cmp r0,#-1
 1623 0050 08D1     	 bne .L125
 1624              	.LBB184:
 1625              	.LBB185:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 1626              	 .loc 2 197 0
 1627              	
 1628 0052 4FF01403 	 mov r3,#20
 1629 0056 83F31188 	 msr basepri,r3
 1630 005a BFF36F8F 	 isb 
 1631 005e BFF34F8F 	 dsb 
 1632              	
 1633              	
 1634              	.LVL158:
 1635              	 .thumb
 1636              	.L128:
 1637              	.LBE185:
 1638              	.LBE184:
2090:../FreeRTOS/Source/tasks.c ****     }
 1639              	 .loc 1 2090 0 discriminator 2
 1640 0062 FEE7     	 b .L128
 1641              	.LVL159:
 1642              	.L125:
2096:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1643              	 .loc 1 2096 0
 1644 0064 03B0     	 add sp,sp,#12
 1645              	.LCFI12:
 1646              	 .cfi_def_cfa_offset 4
 1647              	 
 1648 0066 5DF804FB 	 ldr pc,[sp],#4
 1649              	.L131:
 1650 006a 00BF     	 .align 2
 1651              	.L130:
 1652 006c 00000000 	 .word .LANCHOR17
 1653 0070 00000000 	 .word prvIdleTask
 1654 0074 00000000 	 .word .LC0
 1655 0078 00000000 	 .word .LANCHOR3
 1656 007c 00000000 	 .word .LANCHOR14
 1657 0080 00000000 	 .word .LANCHOR4
 1658              	 .cfi_endproc
 1659              	.LFE19:
 1661              	 .section .text.vTaskEndScheduler,"ax",%progbits
 1662              	 .align 2
 1663              	 .global vTaskEndScheduler
 1664              	 .thumb
 1665              	 .thumb_func
 1667              	vTaskEndScheduler:
 1668              	.LFB20:
2100:../FreeRTOS/Source/tasks.c ****     /* Stop the scheduler interrupts and call the portable scheduler end
 1669              	 .loc 1 2100 0
 1670              	 .cfi_startproc
 1671              	 
 1672              	 
 1673 0000 08B5     	 push {r3,lr}
 1674              	.LCFI13:
 1675              	 .cfi_def_cfa_offset 8
 1676              	 .cfi_offset 3,-8
 1677              	 .cfi_offset 14,-4
 1678              	.LBB186:
 1679              	.LBB187:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 1680              	 .loc 2 197 0
 1681              	
 1682 0002 4FF01403 	 mov r3,#20
 1683 0006 83F31188 	 msr basepri,r3
 1684 000a BFF36F8F 	 isb 
 1685 000e BFF34F8F 	 dsb 
 1686              	
 1687              	
 1688              	.LVL160:
 1689              	 .thumb
 1690              	.LBE187:
 1691              	.LBE186:
2105:../FreeRTOS/Source/tasks.c ****     vPortEndScheduler();
 1692              	 .loc 1 2105 0
 1693 0012 0022     	 movs r2,#0
 1694 0014 024B     	 ldr r3,.L134
 1695 0016 1A60     	 str r2,[r3]
2106:../FreeRTOS/Source/tasks.c **** }
 1696              	 .loc 1 2106 0
 1697 0018 FFF7FEFF 	 bl vPortEndScheduler
 1698              	.LVL161:
 1699 001c 08BD     	 pop {r3,pc}
 1700              	.L135:
 1701 001e 00BF     	 .align 2
 1702              	.L134:
 1703 0020 00000000 	 .word .LANCHOR14
 1704              	 .cfi_endproc
 1705              	.LFE20:
 1707              	 .section .text.vTaskSuspendAll,"ax",%progbits
 1708              	 .align 2
 1709              	 .global vTaskSuspendAll
 1710              	 .thumb
 1711              	 .thumb_func
 1713              	vTaskSuspendAll:
 1714              	.LFB21:
2111:../FreeRTOS/Source/tasks.c ****     /* A critical section is not required as the variable is of type
 1715              	 .loc 1 2111 0
 1716              	 .cfi_startproc
 1717              	 
 1718              	 
 1719              	 
2123:../FreeRTOS/Source/tasks.c **** 
 1720              	 .loc 1 2123 0
 1721 0000 024A     	 ldr r2,.L137
 1722 0002 1368     	 ldr r3,[r2]
 1723 0004 0133     	 adds r3,r3,#1
 1724 0006 1360     	 str r3,[r2]
2127:../FreeRTOS/Source/tasks.c **** }
 1725              	 .loc 1 2127 0
 1726 0008 7047     	 bx lr
 1727              	.L138:
 1728 000a 00BF     	 .align 2
 1729              	.L137:
 1730 000c 00000000 	 .word .LANCHOR16
 1731              	 .cfi_endproc
 1732              	.LFE21:
 1734              	 .section .text.xTaskGetTickCount,"ax",%progbits
 1735              	 .align 2
 1736              	 .global xTaskGetTickCount
 1737              	 .thumb
 1738              	 .thumb_func
 1740              	xTaskGetTickCount:
 1741              	.LFB23:
2306:../FreeRTOS/Source/tasks.c ****     TickType_t xTicks;
 1742              	 .loc 1 2306 0
 1743              	 .cfi_startproc
 1744              	 
 1745              	 
 1746              	 
2312:../FreeRTOS/Source/tasks.c ****     }
 1747              	 .loc 1 2312 0
 1748 0000 014B     	 ldr r3,.L140
 1749 0002 1868     	 ldr r0,[r3]
 1750              	.LVL162:
2317:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1751              	 .loc 1 2317 0
 1752 0004 7047     	 bx lr
 1753              	.L141:
 1754 0006 00BF     	 .align 2
 1755              	.L140:
 1756 0008 00000000 	 .word .LANCHOR4
 1757              	 .cfi_endproc
 1758              	.LFE23:
 1760              	 .section .text.xTaskGetTickCountFromISR,"ax",%progbits
 1761              	 .align 2
 1762              	 .global xTaskGetTickCountFromISR
 1763              	 .thumb
 1764              	 .thumb_func
 1766              	xTaskGetTickCountFromISR:
 1767              	.LFB24:
2321:../FreeRTOS/Source/tasks.c ****     TickType_t xReturn;
 1768              	 .loc 1 2321 0
 1769              	 .cfi_startproc
 1770              	 
 1771              	 
 1772 0000 08B5     	 push {r3,lr}
 1773              	.LCFI14:
 1774              	 .cfi_def_cfa_offset 8
 1775              	 .cfi_offset 3,-8
 1776              	 .cfi_offset 14,-4
2339:../FreeRTOS/Source/tasks.c **** 
 1777              	 .loc 1 2339 0
 1778 0002 FFF7FEFF 	 bl vPortValidateInterruptPriority
 1779              	.LVL163:
2343:../FreeRTOS/Source/tasks.c ****     }
 1780              	 .loc 1 2343 0
 1781 0006 014B     	 ldr r3,.L144
 1782 0008 1868     	 ldr r0,[r3]
 1783              	.LVL164:
2348:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1784              	 .loc 1 2348 0
 1785 000a 08BD     	 pop {r3,pc}
 1786              	.L145:
 1787              	 .align 2
 1788              	.L144:
 1789 000c 00000000 	 .word .LANCHOR4
 1790              	 .cfi_endproc
 1791              	.LFE24:
 1793              	 .section .text.uxTaskGetNumberOfTasks,"ax",%progbits
 1794              	 .align 2
 1795              	 .global uxTaskGetNumberOfTasks
 1796              	 .thumb
 1797              	 .thumb_func
 1799              	uxTaskGetNumberOfTasks:
 1800              	.LFB25:
2352:../FreeRTOS/Source/tasks.c ****     /* A critical section is not required because the variables are of type
 1801              	 .loc 1 2352 0
 1802              	 .cfi_startproc
 1803              	 
 1804              	 
 1805              	 
2355:../FreeRTOS/Source/tasks.c **** }
 1806              	 .loc 1 2355 0
 1807 0000 014B     	 ldr r3,.L147
 1808 0002 1868     	 ldr r0,[r3]
2356:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1809              	 .loc 1 2356 0
 1810 0004 7047     	 bx lr
 1811              	.L148:
 1812 0006 00BF     	 .align 2
 1813              	.L147:
 1814 0008 00000000 	 .word .LANCHOR10
 1815              	 .cfi_endproc
 1816              	.LFE25:
 1818              	 .section .text.pcTaskGetName,"ax",%progbits
 1819              	 .align 2
 1820              	 .global pcTaskGetName
 1821              	 .thumb
 1822              	 .thumb_func
 1824              	pcTaskGetName:
 1825              	.LFB26:
2360:../FreeRTOS/Source/tasks.c ****     TCB_t * pxTCB;
 1826              	 .loc 1 2360 0
 1827              	 .cfi_startproc
 1828              	 
 1829              	 
 1830              	 
 1831              	.LVL165:
2365:../FreeRTOS/Source/tasks.c ****     configASSERT( pxTCB );
 1832              	 .loc 1 2365 0
 1833 0000 0346     	 mov r3,r0
 1834 0002 58B9     	 cbnz r0,.L150
2365:../FreeRTOS/Source/tasks.c ****     configASSERT( pxTCB );
 1835              	 .loc 1 2365 0 is_stmt 0 discriminator 1
 1836 0004 074B     	 ldr r3,.L152
 1837 0006 1B68     	 ldr r3,[r3]
 1838              	.LVL166:
2366:../FreeRTOS/Source/tasks.c ****     return &( pxTCB->pcTaskName[ 0 ] );
 1839              	 .loc 1 2366 0 is_stmt 1 discriminator 1
 1840 0008 43B9     	 cbnz r3,.L150
 1841              	.LBB188:
 1842              	.LBB189:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 1843              	 .loc 2 197 0
 1844              	
 1845 000a 4FF01403 	 mov r3,#20
 1846 000e 83F31188 	 msr basepri,r3
 1847 0012 BFF36F8F 	 isb 
 1848 0016 BFF34F8F 	 dsb 
 1849              	
 1850              	
 1851              	.LVL167:
 1852              	 .thumb
 1853              	.L151:
 1854              	.LBE189:
 1855              	.LBE188:
2366:../FreeRTOS/Source/tasks.c ****     return &( pxTCB->pcTaskName[ 0 ] );
 1856              	 .loc 1 2366 0 discriminator 1
 1857 001a FEE7     	 b .L151
 1858              	.L150:
 1859              	.LVL168:
2368:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1860              	 .loc 1 2368 0
 1861 001c 03F13400 	 add r0,r3,#52
 1862 0020 7047     	 bx lr
 1863              	.L153:
 1864 0022 00BF     	 .align 2
 1865              	.L152:
 1866 0024 00000000 	 .word .LANCHOR5
 1867              	 .cfi_endproc
 1868              	.LFE26:
 1870              	 .section .text.xTaskIncrementTick,"ax",%progbits
 1871              	 .align 2
 1872              	 .global xTaskIncrementTick
 1873              	 .thumb
 1874              	 .thumb_func
 1876              	xTaskIncrementTick:
 1877              	.LFB29:
2710:../FreeRTOS/Source/tasks.c ****     TCB_t * pxTCB;
 1878              	 .loc 1 2710 0
 1879              	 .cfi_startproc
 1880              	 
 1881              	 
 1882 0000 2DE9F047 	 push {r4,r5,r6,r7,r8,r9,r10,lr}
 1883              	.LCFI15:
 1884              	 .cfi_def_cfa_offset 32
 1885              	 .cfi_offset 4,-32
 1886              	 .cfi_offset 5,-28
 1887              	 .cfi_offset 6,-24
 1888              	 .cfi_offset 7,-20
 1889              	 .cfi_offset 8,-16
 1890              	 .cfi_offset 9,-12
 1891              	 .cfi_offset 10,-8
 1892              	 .cfi_offset 14,-4
 1893              	.LVL169:
2720:../FreeRTOS/Source/tasks.c ****     {
 1894              	 .loc 1 2720 0
 1895 0004 3C4B     	 ldr r3,.L169
 1896 0006 1B68     	 ldr r3,[r3]
 1897 0008 002B     	 cmp r3,#0
 1898 000a 6DD1     	 bne .L155
 1899              	.LBB190:
2724:../FreeRTOS/Source/tasks.c **** 
 1900              	 .loc 1 2724 0
 1901 000c 3B4B     	 ldr r3,.L169+4
 1902 000e 1D68     	 ldr r5,[r3]
 1903 0010 0135     	 adds r5,r5,#1
 1904              	.LVL170:
2728:../FreeRTOS/Source/tasks.c **** 
 1905              	 .loc 1 2728 0
 1906 0012 1D60     	 str r5,[r3]
2730:../FreeRTOS/Source/tasks.c ****         {
 1907              	 .loc 1 2730 0
 1908 0014 C5B9     	 cbnz r5,.L156
 1909              	.LBB191:
2732:../FreeRTOS/Source/tasks.c ****         }
 1910              	 .loc 1 2732 0
 1911 0016 3A4B     	 ldr r3,.L169+8
 1912 0018 1B68     	 ldr r3,[r3]
 1913 001a 1B68     	 ldr r3,[r3]
 1914 001c 43B1     	 cbz r3,.L157
 1915              	.LBB192:
 1916              	.LBB193:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 1917              	 .loc 2 197 0
 1918              	
 1919 001e 4FF01403 	 mov r3,#20
 1920 0022 83F31188 	 msr basepri,r3
 1921 0026 BFF36F8F 	 isb 
 1922 002a BFF34F8F 	 dsb 
 1923              	
 1924              	
 1925              	.LVL171:
 1926              	 .thumb
 1927              	.L158:
 1928              	.LBE193:
 1929              	.LBE192:
2732:../FreeRTOS/Source/tasks.c ****         }
 1930              	 .loc 1 2732 0 discriminator 1
 1931 002e FEE7     	 b .L158
 1932              	.L157:
2732:../FreeRTOS/Source/tasks.c ****         }
 1933              	 .loc 1 2732 0 is_stmt 0 discriminator 2
 1934 0030 334A     	 ldr r2,.L169+8
 1935 0032 1168     	 ldr r1,[r2]
 1936              	.LVL172:
 1937 0034 334B     	 ldr r3,.L169+12
 1938 0036 1868     	 ldr r0,[r3]
 1939 0038 1060     	 str r0,[r2]
 1940 003a 1960     	 str r1,[r3]
 1941 003c 324A     	 ldr r2,.L169+16
 1942 003e 1368     	 ldr r3,[r2]
 1943 0040 0133     	 adds r3,r3,#1
 1944 0042 1360     	 str r3,[r2]
 1945 0044 FFF7FEFF 	 bl prvResetNextTaskUnblockTime
 1946              	.LVL173:
 1947              	.L156:
 1948              	.LBE191:
2743:../FreeRTOS/Source/tasks.c ****         {
 1949              	 .loc 1 2743 0 is_stmt 1
 1950 0048 304B     	 ldr r3,.L169+20
 1951 004a 1B68     	 ldr r3,[r3]
 1952 004c 9D42     	 cmp r5,r3
 1953 004e 01D2     	 bcs .L167
 1954              	.LBE190:
2713:../FreeRTOS/Source/tasks.c **** 
 1955              	 .loc 1 2713 0
 1956 0050 0024     	 movs r4,#0
 1957 0052 38E0     	 b .L160
 1958              	.L167:
 1959              	.LBB194:
 1960 0054 0024     	 movs r4,#0
2747:../FreeRTOS/Source/tasks.c ****                 {
 1961              	 .loc 1 2747 0
 1962 0056 DFF8A880 	 ldr r8,.L169+8
2797:../FreeRTOS/Source/tasks.c **** 
 1963              	 .loc 1 2797 0
 1964 005a 2D4F     	 ldr r7,.L169+24
 1965 005c DFF8B8A0 	 ldr r10,.L169+32
 1966              	.LVL174:
 1967              	.L159:
2747:../FreeRTOS/Source/tasks.c ****                 {
 1968              	 .loc 1 2747 0
 1969 0060 D8F80030 	 ldr r3,[r8]
 1970 0064 1B68     	 ldr r3,[r3]
 1971 0066 23B9     	 cbnz r3,.L161
2754:../FreeRTOS/Source/tasks.c ****                     break;
 1972              	 .loc 1 2754 0
 1973 0068 4FF0FF32 	 mov r2,#-1
 1974 006c 274B     	 ldr r3,.L169+20
 1975 006e 1A60     	 str r2,[r3]
2755:../FreeRTOS/Source/tasks.c ****                 }
 1976              	 .loc 1 2755 0
 1977 0070 29E0     	 b .L160
 1978              	.L161:
2763:../FreeRTOS/Source/tasks.c ****                     xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 1979              	 .loc 1 2763 0
 1980 0072 D8F80030 	 ldr r3,[r8]
 1981 0076 DB68     	 ldr r3,[r3,#12]
 1982 0078 DE68     	 ldr r6,[r3,#12]
 1983              	.LVL175:
2764:../FreeRTOS/Source/tasks.c **** 
 1984              	 .loc 1 2764 0
 1985 007a 7368     	 ldr r3,[r6,#4]
 1986              	.LVL176:
2766:../FreeRTOS/Source/tasks.c ****                     {
 1987              	 .loc 1 2766 0
 1988 007c 9D42     	 cmp r5,r3
 1989 007e 02D2     	 bcs .L162
2773:../FreeRTOS/Source/tasks.c ****                         break; /*lint !e9011 Code structure here is deedmed easier to understand wi
 1990              	 .loc 1 2773 0
 1991 0080 224A     	 ldr r2,.L169+20
 1992 0082 1360     	 str r3,[r2]
2774:../FreeRTOS/Source/tasks.c ****                     }
 1993              	 .loc 1 2774 0
 1994 0084 1FE0     	 b .L160
 1995              	.L162:
2782:../FreeRTOS/Source/tasks.c **** 
 1996              	 .loc 1 2782 0
 1997 0086 06F10409 	 add r9,r6,#4
 1998 008a 4846     	 mov r0,r9
 1999 008c FFF7FEFF 	 bl uxListRemove
 2000              	.LVL177:
2786:../FreeRTOS/Source/tasks.c ****                     {
 2001              	 .loc 1 2786 0
 2002 0090 B36A     	 ldr r3,[r6,#40]
 2003 0092 1BB1     	 cbz r3,.L163
2788:../FreeRTOS/Source/tasks.c ****                     }
 2004              	 .loc 1 2788 0
 2005 0094 06F11800 	 add r0,r6,#24
 2006 0098 FFF7FEFF 	 bl uxListRemove
 2007              	.LVL178:
 2008              	.L163:
2797:../FreeRTOS/Source/tasks.c **** 
 2009              	 .loc 1 2797 0
 2010 009c F06A     	 ldr r0,[r6,#44]
 2011 009e 3B68     	 ldr r3,[r7]
 2012 00a0 0122     	 movs r2,#1
 2013 00a2 8240     	 lsls r2,r2,r0
 2014 00a4 1343     	 orrs r3,r3,r2
 2015 00a6 3B60     	 str r3,[r7]
 2016 00a8 00EB8000 	 add r0,r0,r0,lsl#2
 2017 00ac 0AEB8000 	 add r0,r10,r0,lsl#2
 2018 00b0 4946     	 mov r1,r9
 2019 00b2 FFF7FEFF 	 bl vListInsertEnd
 2020              	.LVL179:
2807:../FreeRTOS/Source/tasks.c ****                             {
 2021              	 .loc 1 2807 0
 2022 00b6 174B     	 ldr r3,.L169+28
 2023 00b8 1B68     	 ldr r3,[r3]
 2024 00ba F26A     	 ldr r2,[r6,#44]
 2025 00bc DB6A     	 ldr r3,[r3,#44]
2809:../FreeRTOS/Source/tasks.c ****                             }
 2026              	 .loc 1 2809 0
 2027 00be 9A42     	 cmp r2,r3
 2028 00c0 28BF     	 it cs
 2029 00c2 0124     	 movcs r4,#1
 2030              	.LVL180:
 2031 00c4 CCE7     	 b .L159
 2032              	.LVL181:
 2033              	.L160:
2826:../FreeRTOS/Source/tasks.c ****                 {
 2034              	 .loc 1 2826 0
 2035 00c6 134B     	 ldr r3,.L169+28
 2036 00c8 1B68     	 ldr r3,[r3]
 2037 00ca DB6A     	 ldr r3,[r3,#44]
 2038 00cc 03EB8303 	 add r3,r3,r3,lsl#2
 2039 00d0 9B00     	 lsls r3,r3,#2
 2040 00d2 114A     	 ldr r2,.L169+32
 2041 00d4 D358     	 ldr r3,[r2,r3]
2828:../FreeRTOS/Source/tasks.c ****                 }
 2042              	 .loc 1 2828 0
 2043 00d6 022B     	 cmp r3,#2
 2044 00d8 28BF     	 it cs
 2045 00da 0124     	 movcs r4,#1
 2046              	.LVL182:
2854:../FreeRTOS/Source/tasks.c ****                 {
 2047              	 .loc 1 2854 0
 2048 00dc 0F4B     	 ldr r3,.L169+36
 2049 00de 1B68     	 ldr r3,[r3]
2856:../FreeRTOS/Source/tasks.c ****                 }
 2050              	 .loc 1 2856 0
 2051 00e0 002B     	 cmp r3,#0
 2052 00e2 18BF     	 it ne
 2053 00e4 0124     	 movne r4,#1
 2054              	.LVL183:
 2055 00e6 04E0     	 b .L166
 2056              	.LVL184:
 2057              	.L155:
 2058              	.LBE194:
2867:../FreeRTOS/Source/tasks.c **** 
 2059              	 .loc 1 2867 0
 2060 00e8 0D4A     	 ldr r2,.L169+40
 2061 00ea 1368     	 ldr r3,[r2]
 2062 00ec 0133     	 adds r3,r3,#1
 2063 00ee 1360     	 str r3,[r2]
2713:../FreeRTOS/Source/tasks.c **** 
 2064              	 .loc 1 2713 0
 2065 00f0 0024     	 movs r4,#0
 2066              	.LVL185:
 2067              	.L166:
2879:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2068              	 .loc 1 2879 0
 2069 00f2 2046     	 mov r0,r4
 2070 00f4 BDE8F087 	 pop {r4,r5,r6,r7,r8,r9,r10,pc}
 2071              	.LVL186:
 2072              	.L170:
 2073              	 .align 2
 2074              	.L169:
 2075 00f8 00000000 	 .word .LANCHOR16
 2076 00fc 00000000 	 .word .LANCHOR4
 2077 0100 00000000 	 .word .LANCHOR2
 2078 0104 00000000 	 .word .LANCHOR7
 2079 0108 00000000 	 .word .LANCHOR18
 2080 010c 00000000 	 .word .LANCHOR3
 2081 0110 00000000 	 .word .LANCHOR6
 2082 0114 00000000 	 .word .LANCHOR5
 2083 0118 00000000 	 .word .LANCHOR11
 2084 011c 00000000 	 .word .LANCHOR19
 2085 0120 00000000 	 .word .LANCHOR20
 2086              	 .cfi_endproc
 2087              	.LFE29:
 2089              	 .section .text.xTaskResumeAll,"ax",%progbits
 2090              	 .align 2
 2091              	 .global xTaskResumeAll
 2092              	 .thumb
 2093              	 .thumb_func
 2095              	xTaskResumeAll:
 2096              	.LFB22:
2195:../FreeRTOS/Source/tasks.c ****     TCB_t * pxTCB = NULL;
 2097              	 .loc 1 2195 0
 2098              	 .cfi_startproc
 2099              	 
 2100              	 
 2101              	.LVL187:
2201:../FreeRTOS/Source/tasks.c **** 
 2102              	 .loc 1 2201 0
 2103 0000 354B     	 ldr r3,.L188
 2104 0002 1B68     	 ldr r3,[r3]
 2105 0004 43B9     	 cbnz r3,.L172
 2106              	.LBB195:
 2107              	.LBB196:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 2108              	 .loc 2 197 0
 2109              	
 2110 0006 4FF01403 	 mov r3,#20
 2111 000a 83F31188 	 msr basepri,r3
 2112 000e BFF36F8F 	 isb 
 2113 0012 BFF34F8F 	 dsb 
 2114              	
 2115              	
 2116              	.LVL188:
 2117              	 .thumb
 2118              	.L173:
 2119              	.LBE196:
 2120              	.LBE195:
2201:../FreeRTOS/Source/tasks.c **** 
 2121              	 .loc 1 2201 0 discriminator 1
 2122 0016 FEE7     	 b .L173
 2123              	.L172:
2195:../FreeRTOS/Source/tasks.c ****     TCB_t * pxTCB = NULL;
 2124              	 .loc 1 2195 0
 2125 0018 2DE9F041 	 push {r4,r5,r6,r7,r8,lr}
 2126              	.LCFI16:
 2127              	 .cfi_def_cfa_offset 24
 2128              	 .cfi_offset 4,-24
 2129              	 .cfi_offset 5,-20
 2130              	 .cfi_offset 6,-16
 2131              	 .cfi_offset 7,-12
 2132              	 .cfi_offset 8,-8
 2133              	 .cfi_offset 14,-4
2208:../FreeRTOS/Source/tasks.c ****     {
 2134              	 .loc 1 2208 0
 2135 001c FFF7FEFF 	 bl vPortEnterCritical
 2136              	.LVL189:
2210:../FreeRTOS/Source/tasks.c **** 
 2137              	 .loc 1 2210 0
 2138 0020 2D4B     	 ldr r3,.L188
 2139 0022 1A68     	 ldr r2,[r3]
 2140 0024 013A     	 subs r2,r2,#1
 2141 0026 1A60     	 str r2,[r3]
2212:../FreeRTOS/Source/tasks.c ****         {
 2142              	 .loc 1 2212 0
 2143 0028 1B68     	 ldr r3,[r3]
 2144 002a 002B     	 cmp r3,#0
 2145 002c 4BD1     	 bne .L182
2214:../FreeRTOS/Source/tasks.c ****             {
 2146              	 .loc 1 2214 0
 2147 002e 2B4B     	 ldr r3,.L188+4
 2148 0030 1B68     	 ldr r3,[r3]
 2149 0032 13BB     	 cbnz r3,.L183
2197:../FreeRTOS/Source/tasks.c **** 
 2150              	 .loc 1 2197 0
 2151 0034 0024     	 movs r4,#0
 2152 0036 49E0     	 b .L174
 2153              	.LVL190:
 2154              	.L177:
2220:../FreeRTOS/Source/tasks.c ****                     ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 2155              	 .loc 1 2220 0
 2156 0038 F368     	 ldr r3,[r6,#12]
 2157 003a DC68     	 ldr r4,[r3,#12]
 2158              	.LVL191:
2221:../FreeRTOS/Source/tasks.c ****                     ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 2159              	 .loc 1 2221 0
 2160 003c 04F11800 	 add r0,r4,#24
 2161 0040 FFF7FEFF 	 bl uxListRemove
 2162              	.LVL192:
2222:../FreeRTOS/Source/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
 2163              	 .loc 1 2222 0
 2164 0044 271D     	 adds r7,r4,#4
 2165 0046 3846     	 mov r0,r7
 2166 0048 FFF7FEFF 	 bl uxListRemove
 2167              	.LVL193:
2223:../FreeRTOS/Source/tasks.c **** 
 2168              	 .loc 1 2223 0
 2169 004c E06A     	 ldr r0,[r4,#44]
 2170 004e 2B68     	 ldr r3,[r5]
 2171 0050 0122     	 movs r2,#1
 2172 0052 8240     	 lsls r2,r2,r0
 2173 0054 1343     	 orrs r3,r3,r2
 2174 0056 2B60     	 str r3,[r5]
 2175 0058 00EB8000 	 add r0,r0,r0,lsl#2
 2176 005c 08EB8000 	 add r0,r8,r0,lsl#2
 2177 0060 3946     	 mov r1,r7
 2178 0062 FFF7FEFF 	 bl vListInsertEnd
 2179              	.LVL194:
2227:../FreeRTOS/Source/tasks.c ****                     {
 2180              	 .loc 1 2227 0
 2181 0066 1E4B     	 ldr r3,.L188+8
 2182 0068 1B68     	 ldr r3,[r3]
 2183 006a E26A     	 ldr r2,[r4,#44]
 2184 006c DB6A     	 ldr r3,[r3,#44]
 2185 006e 9A42     	 cmp r2,r3
 2186 0070 08D3     	 bcc .L175
2229:../FreeRTOS/Source/tasks.c ****                     }
 2187              	 .loc 1 2229 0
 2188 0072 0122     	 movs r2,#1
 2189 0074 1B4B     	 ldr r3,.L188+12
 2190 0076 1A60     	 str r2,[r3]
 2191 0078 04E0     	 b .L175
 2192              	.LVL195:
 2193              	.L183:
 2194 007a 0024     	 movs r4,#0
2218:../FreeRTOS/Source/tasks.c ****                 {
 2195              	 .loc 1 2218 0
 2196 007c 1A4E     	 ldr r6,.L188+16
2223:../FreeRTOS/Source/tasks.c **** 
 2197              	 .loc 1 2223 0
 2198 007e 1B4D     	 ldr r5,.L188+20
 2199 0080 DFF87480 	 ldr r8,.L188+32
 2200              	.LVL196:
 2201              	.L175:
2218:../FreeRTOS/Source/tasks.c ****                 {
 2202              	 .loc 1 2218 0
 2203 0084 3368     	 ldr r3,[r6]
 2204 0086 002B     	 cmp r3,#0
 2205 0088 D6D1     	 bne .L177
2237:../FreeRTOS/Source/tasks.c ****                 {
 2206              	 .loc 1 2237 0
 2207 008a 0CB1     	 cbz r4,.L178
2245:../FreeRTOS/Source/tasks.c ****                 }
 2208              	 .loc 1 2245 0
 2209 008c FFF7FEFF 	 bl prvResetNextTaskUnblockTime
 2210              	.LVL197:
 2211              	.L178:
 2212              	.LBB197:
2253:../FreeRTOS/Source/tasks.c **** 
 2213              	 .loc 1 2253 0
 2214 0090 174B     	 ldr r3,.L188+24
 2215 0092 1C68     	 ldr r4,[r3]
 2216              	.LVL198:
2255:../FreeRTOS/Source/tasks.c ****                     {
 2217              	 .loc 1 2255 0
 2218 0094 54B1     	 cbz r4,.L179
2261:../FreeRTOS/Source/tasks.c ****                             }
 2219              	 .loc 1 2261 0
 2220 0096 134E     	 ldr r6,.L188+12
 2221 0098 0125     	 movs r5,#1
 2222              	.L185:
2259:../FreeRTOS/Source/tasks.c ****                             {
 2223              	 .loc 1 2259 0
 2224 009a FFF7FEFF 	 bl xTaskIncrementTick
 2225              	.LVL199:
 2226 009e 00B1     	 cbz r0,.L180
2261:../FreeRTOS/Source/tasks.c ****                             }
 2227              	 .loc 1 2261 0
 2228 00a0 3560     	 str r5,[r6]
 2229              	.L180:
 2230              	.LVL200:
2269:../FreeRTOS/Source/tasks.c **** 
 2231              	 .loc 1 2269 0
 2232 00a2 013C     	 subs r4,r4,#1
 2233              	.LVL201:
 2234 00a4 F9D1     	 bne .L185
2271:../FreeRTOS/Source/tasks.c ****                     }
 2235              	 .loc 1 2271 0
 2236 00a6 0022     	 movs r2,#0
 2237 00a8 114B     	 ldr r3,.L188+24
 2238 00aa 1A60     	 str r2,[r3]
 2239              	.L179:
 2240              	.LBE197:
2279:../FreeRTOS/Source/tasks.c ****                 {
 2241              	 .loc 1 2279 0
 2242 00ac 0D4B     	 ldr r3,.L188+12
 2243 00ae 1B68     	 ldr r3,[r3]
 2244 00b0 5BB1     	 cbz r3,.L184
 2245              	.LVL202:
2286:../FreeRTOS/Source/tasks.c ****                 }
 2246              	 .loc 1 2286 0
 2247 00b2 4FF08052 	 mov r2,#268435456
 2248 00b6 0F4B     	 ldr r3,.L188+28
 2249 00b8 1A60     	 str r2,[r3]
 2250              	
 2251 00ba BFF34F8F 	 dsb
 2252              	
 2253              	
 2254 00be BFF36F8F 	 isb
 2255              	
2283:../FreeRTOS/Source/tasks.c ****                         }
 2256              	 .loc 1 2283 0
 2257              	 .thumb
 2258 00c2 0124     	 movs r4,#1
 2259              	.LVL203:
 2260 00c4 02E0     	 b .L174
 2261              	.LVL204:
 2262              	.L182:
2197:../FreeRTOS/Source/tasks.c **** 
 2263              	 .loc 1 2197 0
 2264 00c6 0024     	 movs r4,#0
 2265 00c8 00E0     	 b .L174
 2266              	.LVL205:
 2267              	.L184:
 2268 00ca 0024     	 movs r4,#0
 2269              	.LVL206:
 2270              	.L174:
2299:../FreeRTOS/Source/tasks.c **** 
 2271              	 .loc 1 2299 0
 2272 00cc FFF7FEFF 	 bl vPortExitCritical
 2273              	.LVL207:
2302:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2274              	 .loc 1 2302 0
 2275 00d0 2046     	 mov r0,r4
 2276 00d2 BDE8F081 	 pop {r4,r5,r6,r7,r8,pc}
 2277              	.LVL208:
 2278              	.L189:
 2279 00d6 00BF     	 .align 2
 2280              	.L188:
 2281 00d8 00000000 	 .word .LANCHOR16
 2282 00dc 00000000 	 .word .LANCHOR10
 2283 00e0 00000000 	 .word .LANCHOR5
 2284 00e4 00000000 	 .word .LANCHOR19
 2285 00e8 00000000 	 .word .LANCHOR1
 2286 00ec 00000000 	 .word .LANCHOR6
 2287 00f0 00000000 	 .word .LANCHOR20
 2288 00f4 04ED00E0 	 .word -536810236
 2289 00f8 00000000 	 .word .LANCHOR11
 2290              	 .cfi_endproc
 2291              	.LFE22:
 2293              	 .section .text.vTaskDelayUntil,"ax",%progbits
 2294              	 .align 2
 2295              	 .global vTaskDelayUntil
 2296              	 .thumb
 2297              	 .thumb_func
 2299              	vTaskDelayUntil:
 2300              	.LFB9:
1246:../FreeRTOS/Source/tasks.c ****         TickType_t xTimeToWake;
 2301              	 .loc 1 1246 0
 2302              	 .cfi_startproc
 2303              	 
 2304              	 
 2305              	.LVL209:
 2306 0000 38B5     	 push {r3,r4,r5,lr}
 2307              	.LCFI17:
 2308              	 .cfi_def_cfa_offset 16
 2309              	 .cfi_offset 3,-16
 2310              	 .cfi_offset 4,-12
 2311              	 .cfi_offset 5,-8
 2312              	 .cfi_offset 14,-4
 2313              	.LVL210:
1250:../FreeRTOS/Source/tasks.c ****         configASSERT( ( xTimeIncrement > 0U ) );
 2314              	 .loc 1 1250 0
 2315 0002 40B9     	 cbnz r0,.L191
 2316              	.LBB198:
 2317              	.LBB199:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 2318              	 .loc 2 197 0
 2319              	
 2320 0004 4FF01403 	 mov r3,#20
 2321 0008 83F31188 	 msr basepri,r3
 2322 000c BFF36F8F 	 isb 
 2323 0010 BFF34F8F 	 dsb 
 2324              	
 2325              	
 2326              	.LVL211:
 2327              	 .thumb
 2328              	.L192:
 2329              	.LBE199:
 2330              	.LBE198:
1250:../FreeRTOS/Source/tasks.c ****         configASSERT( ( xTimeIncrement > 0U ) );
 2331              	 .loc 1 1250 0 discriminator 1
 2332 0014 FEE7     	 b .L192
 2333              	.L191:
 2334 0016 0546     	 mov r5,r0
1251:../FreeRTOS/Source/tasks.c ****         configASSERT( uxSchedulerSuspended == 0 );
 2335              	 .loc 1 1251 0
 2336 0018 41B9     	 cbnz r1,.L193
 2337              	.LBB200:
 2338              	.LBB201:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 2339              	 .loc 2 197 0
 2340              	
 2341 001a 4FF01403 	 mov r3,#20
 2342 001e 83F31188 	 msr basepri,r3
 2343 0022 BFF36F8F 	 isb 
 2344 0026 BFF34F8F 	 dsb 
 2345              	
 2346              	
 2347              	.LVL212:
 2348              	 .thumb
 2349              	.L194:
 2350              	.LBE201:
 2351              	.LBE200:
1251:../FreeRTOS/Source/tasks.c ****         configASSERT( uxSchedulerSuspended == 0 );
 2352              	 .loc 1 1251 0 discriminator 2
 2353 002a FEE7     	 b .L194
 2354              	.L193:
1252:../FreeRTOS/Source/tasks.c **** 
 2355              	 .loc 1 1252 0
 2356 002c 1A4B     	 ldr r3,.L204
 2357 002e 1B68     	 ldr r3,[r3]
 2358 0030 43B1     	 cbz r3,.L195
 2359              	.LBB202:
 2360              	.LBB203:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 2361              	 .loc 2 197 0
 2362              	
 2363 0032 4FF01403 	 mov r3,#20
 2364 0036 83F31188 	 msr basepri,r3
 2365 003a BFF36F8F 	 isb 
 2366 003e BFF34F8F 	 dsb 
 2367              	
 2368              	
 2369              	.LVL213:
 2370              	 .thumb
 2371              	.L196:
 2372              	.LBE203:
 2373              	.LBE202:
1252:../FreeRTOS/Source/tasks.c **** 
 2374              	 .loc 1 1252 0 discriminator 3
 2375 0042 FEE7     	 b .L196
 2376              	.L195:
 2377 0044 0C46     	 mov r4,r1
1254:../FreeRTOS/Source/tasks.c ****         {
 2378              	 .loc 1 1254 0
 2379 0046 FFF7FEFF 	 bl vTaskSuspendAll
 2380              	.LVL214:
 2381              	.LBB204:
1258:../FreeRTOS/Source/tasks.c **** 
 2382              	 .loc 1 1258 0
 2383 004a 144B     	 ldr r3,.L204+4
 2384 004c 1868     	 ldr r0,[r3]
 2385              	.LVL215:
1261:../FreeRTOS/Source/tasks.c **** 
 2386              	 .loc 1 1261 0
 2387 004e 2A68     	 ldr r2,[r5]
 2388 0050 1319     	 adds r3,r2,r4
 2389              	.LVL216:
1263:../FreeRTOS/Source/tasks.c ****             {
 2390              	 .loc 1 1263 0
 2391 0052 9042     	 cmp r0,r2
 2392 0054 05D2     	 bcs .L197
1270:../FreeRTOS/Source/tasks.c ****                 {
 2393              	 .loc 1 1270 0
 2394 0056 9A42     	 cmp r2,r3
 2395 0058 1AD9     	 bls .L198
 2396              	.LVL217:
1295:../FreeRTOS/Source/tasks.c **** 
 2397              	 .loc 1 1295 0 discriminator 1
 2398 005a 2B60     	 str r3,[r5]
1297:../FreeRTOS/Source/tasks.c ****             {
 2399              	 .loc 1 1297 0 discriminator 1
 2400 005c 9842     	 cmp r0,r3
 2401 005e 09D2     	 bcs .L200
 2402 0060 04E0     	 b .L199
 2403              	.LVL218:
 2404              	.L197:
1284:../FreeRTOS/Source/tasks.c ****                 {
 2405              	 .loc 1 1284 0
 2406 0062 9A42     	 cmp r2,r3
 2407 0064 12D8     	 bhi .L201
1284:../FreeRTOS/Source/tasks.c ****                 {
 2408              	 .loc 1 1284 0 is_stmt 0 discriminator 1
 2409 0066 9842     	 cmp r0,r3
 2410 0068 10D3     	 bcc .L201
 2411 006a 11E0     	 b .L198
 2412              	.LVL219:
 2413              	.L199:
1303:../FreeRTOS/Source/tasks.c ****             }
 2414              	 .loc 1 1303 0 is_stmt 1
 2415 006c 181A     	 subs r0,r3,r0
 2416              	.LVL220:
 2417 006e 0021     	 movs r1,#0
 2418 0070 FFF7FEFF 	 bl prvAddCurrentTaskToDelayedList
 2419              	.LVL221:
 2420              	.L200:
 2421              	.LBE204:
1310:../FreeRTOS/Source/tasks.c **** 
 2422              	 .loc 1 1310 0
 2423 0074 FFF7FEFF 	 bl xTaskResumeAll
 2424              	.LVL222:
1314:../FreeRTOS/Source/tasks.c ****         {
 2425              	 .loc 1 1314 0
 2426 0078 60B9     	 cbnz r0,.L190
1316:../FreeRTOS/Source/tasks.c ****         }
 2427              	 .loc 1 1316 0
 2428 007a 4FF08052 	 mov r2,#268435456
 2429 007e 084B     	 ldr r3,.L204+8
 2430 0080 1A60     	 str r2,[r3]
 2431              	
 2432 0082 BFF34F8F 	 dsb
 2433              	
 2434              	
 2435 0086 BFF36F8F 	 isb
 2436              	
 2437              	 .thumb
 2438 008a 38BD     	 pop {r3,r4,r5,pc}
 2439              	.LVL223:
 2440              	.L201:
 2441              	.LBB205:
1295:../FreeRTOS/Source/tasks.c **** 
 2442              	 .loc 1 1295 0
 2443 008c 2B60     	 str r3,[r5]
 2444 008e EDE7     	 b .L199
 2445              	.LVL224:
 2446              	.L198:
 2447 0090 2B60     	 str r3,[r5]
 2448 0092 EFE7     	 b .L200
 2449              	.LVL225:
 2450              	.L190:
 2451 0094 38BD     	 pop {r3,r4,r5,pc}
 2452              	.LVL226:
 2453              	.L205:
 2454 0096 00BF     	 .align 2
 2455              	.L204:
 2456 0098 00000000 	 .word .LANCHOR16
 2457 009c 00000000 	 .word .LANCHOR4
 2458 00a0 04ED00E0 	 .word -536810236
 2459              	.LBE205:
 2460              	 .cfi_endproc
 2461              	.LFE9:
 2463              	 .section .text.vTaskDelay,"ax",%progbits
 2464              	 .align 2
 2465              	 .global vTaskDelay
 2466              	 .thumb
 2467              	 .thumb_func
 2469              	vTaskDelay:
 2470              	.LFB10:
1330:../FreeRTOS/Source/tasks.c ****         BaseType_t xAlreadyYielded = pdFALSE;
 2471              	 .loc 1 1330 0
 2472              	 .cfi_startproc
 2473              	 
 2474              	 
 2475              	.LVL227:
 2476 0000 10B5     	 push {r4,lr}
 2477              	.LCFI18:
 2478              	 .cfi_def_cfa_offset 8
 2479              	 .cfi_offset 4,-8
 2480              	 .cfi_offset 14,-4
 2481              	.LVL228:
1334:../FreeRTOS/Source/tasks.c ****         {
 2482              	 .loc 1 1334 0
 2483 0002 A8B1     	 cbz r0,.L207
 2484 0004 0446     	 mov r4,r0
1336:../FreeRTOS/Source/tasks.c ****             vTaskSuspendAll();
 2485              	 .loc 1 1336 0
 2486 0006 0F4B     	 ldr r3,.L212
 2487 0008 1B68     	 ldr r3,[r3]
 2488 000a 43B1     	 cbz r3,.L208
 2489              	.LBB206:
 2490              	.LBB207:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 2491              	 .loc 2 197 0
 2492              	
 2493 000c 4FF01403 	 mov r3,#20
 2494 0010 83F31188 	 msr basepri,r3
 2495 0014 BFF36F8F 	 isb 
 2496 0018 BFF34F8F 	 dsb 
 2497              	
 2498              	
 2499              	.LVL229:
 2500              	 .thumb
 2501              	.L209:
 2502              	.LBE207:
 2503              	.LBE206:
1336:../FreeRTOS/Source/tasks.c ****             vTaskSuspendAll();
 2504              	 .loc 1 1336 0 discriminator 1
 2505 001c FEE7     	 b .L209
 2506              	.L208:
1337:../FreeRTOS/Source/tasks.c ****             {
 2507              	 .loc 1 1337 0
 2508 001e FFF7FEFF 	 bl vTaskSuspendAll
 2509              	.LVL230:
1348:../FreeRTOS/Source/tasks.c ****             }
 2510              	 .loc 1 1348 0
 2511 0022 2046     	 mov r0,r4
 2512 0024 0021     	 movs r1,#0
 2513 0026 FFF7FEFF 	 bl prvAddCurrentTaskToDelayedList
 2514              	.LVL231:
1350:../FreeRTOS/Source/tasks.c ****         }
 2515              	 .loc 1 1350 0
 2516 002a FFF7FEFF 	 bl xTaskResumeAll
 2517              	.LVL232:
1359:../FreeRTOS/Source/tasks.c ****         {
 2518              	 .loc 1 1359 0
 2519 002e 38B9     	 cbnz r0,.L206
 2520              	.LVL233:
 2521              	.L207:
1361:../FreeRTOS/Source/tasks.c ****         }
 2522              	 .loc 1 1361 0
 2523 0030 4FF08052 	 mov r2,#268435456
 2524 0034 044B     	 ldr r3,.L212+4
 2525 0036 1A60     	 str r2,[r3]
 2526              	
 2527 0038 BFF34F8F 	 dsb
 2528              	
 2529              	
 2530 003c BFF36F8F 	 isb
 2531              	
 2532              	 .thumb
 2533              	.L206:
 2534 0040 10BD     	 pop {r4,pc}
 2535              	.L213:
 2536 0042 00BF     	 .align 2
 2537              	.L212:
 2538 0044 00000000 	 .word .LANCHOR16
 2539 0048 04ED00E0 	 .word -536810236
 2540              	 .cfi_endproc
 2541              	.LFE10:
 2543              	 .section .text.xTaskCatchUpTicks,"ax",%progbits
 2544              	 .align 2
 2545              	 .global xTaskCatchUpTicks
 2546              	 .thumb
 2547              	 .thumb_func
 2549              	xTaskCatchUpTicks:
 2550              	.LFB28:
2612:../FreeRTOS/Source/tasks.c ****     BaseType_t xYieldOccurred;
 2551              	 .loc 1 2612 0
 2552              	 .cfi_startproc
 2553              	 
 2554              	 
 2555              	.LVL234:
2617:../FreeRTOS/Source/tasks.c **** 
 2556              	 .loc 1 2617 0
 2557 0000 0B4B     	 ldr r3,.L218
 2558 0002 1B68     	 ldr r3,[r3]
 2559 0004 43B1     	 cbz r3,.L215
 2560              	.LBB208:
 2561              	.LBB209:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 2562              	 .loc 2 197 0
 2563              	
 2564 0006 4FF01403 	 mov r3,#20
 2565 000a 83F31188 	 msr basepri,r3
 2566 000e BFF36F8F 	 isb 
 2567 0012 BFF34F8F 	 dsb 
 2568              	
 2569              	
 2570              	.LVL235:
 2571              	 .thumb
 2572              	.L216:
 2573              	.LBE209:
 2574              	.LBE208:
2617:../FreeRTOS/Source/tasks.c **** 
 2575              	 .loc 1 2617 0 discriminator 1
 2576 0016 FEE7     	 b .L216
 2577              	.L215:
2612:../FreeRTOS/Source/tasks.c ****     BaseType_t xYieldOccurred;
 2578              	 .loc 1 2612 0
 2579 0018 10B5     	 push {r4,lr}
 2580              	.LCFI19:
 2581              	 .cfi_def_cfa_offset 8
 2582              	 .cfi_offset 4,-8
 2583              	 .cfi_offset 14,-4
 2584 001a 0446     	 mov r4,r0
2621:../FreeRTOS/Source/tasks.c ****     xPendedTicks += xTicksToCatchUp;
 2585              	 .loc 1 2621 0
 2586 001c FFF7FEFF 	 bl vTaskSuspendAll
 2587              	.LVL236:
2622:../FreeRTOS/Source/tasks.c ****     xYieldOccurred = xTaskResumeAll();
 2588              	 .loc 1 2622 0
 2589 0020 044A     	 ldr r2,.L218+4
 2590 0022 1368     	 ldr r3,[r2]
 2591 0024 2344     	 add r3,r3,r4
 2592 0026 1360     	 str r3,[r2]
2623:../FreeRTOS/Source/tasks.c **** 
 2593              	 .loc 1 2623 0
 2594 0028 FFF7FEFF 	 bl xTaskResumeAll
 2595              	.LVL237:
2626:../FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
 2596              	 .loc 1 2626 0
 2597 002c 10BD     	 pop {r4,pc}
 2598              	.LVL238:
 2599              	.L219:
 2600 002e 00BF     	 .align 2
 2601              	.L218:
 2602 0030 00000000 	 .word .LANCHOR16
 2603 0034 00000000 	 .word .LANCHOR20
 2604              	 .cfi_endproc
 2605              	.LFE28:
 2607              	 .section .text.vTaskSwitchContext,"ax",%progbits
 2608              	 .align 2
 2609              	 .global vTaskSwitchContext
 2610              	 .thumb
 2611              	 .thumb_func
 2613              	vTaskSwitchContext:
 2614              	.LFB30:
2995:../FreeRTOS/Source/tasks.c ****     if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 2615              	 .loc 1 2995 0
 2616              	 .cfi_startproc
 2617              	 
 2618              	 
2996:../FreeRTOS/Source/tasks.c ****     {
 2619              	 .loc 1 2996 0
 2620 0000 254B     	 ldr r3,.L228
 2621 0002 1B68     	 ldr r3,[r3]
 2622 0004 1BB1     	 cbz r3,.L221
3000:../FreeRTOS/Source/tasks.c ****     }
 2623              	 .loc 1 3000 0
 2624 0006 0122     	 movs r2,#1
 2625 0008 244B     	 ldr r3,.L228+4
 2626 000a 1A60     	 str r2,[r3]
 2627 000c 7047     	 bx lr
 2628              	.L221:
2995:../FreeRTOS/Source/tasks.c ****     if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 2629              	 .loc 1 2995 0
 2630 000e 10B5     	 push {r4,lr}
 2631              	.LCFI20:
 2632              	 .cfi_def_cfa_offset 8
 2633              	 .cfi_offset 4,-8
 2634              	 .cfi_offset 14,-4
3004:../FreeRTOS/Source/tasks.c ****         traceTASK_SWITCHED_OUT();
 2635              	 .loc 1 3004 0
 2636 0010 0022     	 movs r2,#0
 2637 0012 224B     	 ldr r3,.L228+4
 2638 0014 1A60     	 str r2,[r3]
3036:../FreeRTOS/Source/tasks.c **** 
 2639              	 .loc 1 3036 0
 2640 0016 224B     	 ldr r3,.L228+8
 2641 0018 1A68     	 ldr r2,[r3]
 2642 001a 1B68     	 ldr r3,[r3]
 2643 001c 1268     	 ldr r2,[r2]
 2644 001e 1B6B     	 ldr r3,[r3,#48]
 2645 0020 9A42     	 cmp r2,r3
 2646 0022 05D8     	 bhi .L223
3036:../FreeRTOS/Source/tasks.c **** 
 2647              	 .loc 1 3036 0 is_stmt 0 discriminator 1
 2648 0024 1E4B     	 ldr r3,.L228+8
 2649 0026 1868     	 ldr r0,[r3]
 2650 0028 1968     	 ldr r1,[r3]
 2651 002a 3431     	 adds r1,r1,#52
 2652 002c FFF7FEFF 	 bl vApplicationStackOverflowHook
 2653              	.LVL239:
 2654              	.L223:
 2655              	.LBB210:
3047:../FreeRTOS/Source/tasks.c ****         traceTASK_SWITCHED_IN();
 2656              	 .loc 1 3047 0 is_stmt 1
 2657 0030 1C4B     	 ldr r3,.L228+12
 2658 0032 1B68     	 ldr r3,[r3]
 2659              	.LVL240:
 2660              	.LBB211:
 2661              	.LBB212:
 135:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 2662              	 .loc 2 135 0
 2663              	
 2664 0034 B3FA83F3 	 clz r3,r3
 2665              	
 2666              	.LVL241:
 2667              	 .thumb
 2668 0038 DBB2     	 uxtb r3,r3
 2669              	.LVL242:
 2670              	.LBE212:
 2671              	.LBE211:
3047:../FreeRTOS/Source/tasks.c ****         traceTASK_SWITCHED_IN();
 2672              	 .loc 1 3047 0
 2673 003a C3F11F03 	 rsb r3,r3,#31
 2674              	.LVL243:
 2675 003e 03EB8302 	 add r2,r3,r3,lsl#2
 2676 0042 9200     	 lsls r2,r2,#2
 2677 0044 1849     	 ldr r1,.L228+16
 2678 0046 8A58     	 ldr r2,[r1,r2]
 2679 0048 42B9     	 cbnz r2,.L224
 2680              	.LBB213:
 2681              	.LBB214:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 2682              	 .loc 2 197 0
 2683              	
 2684 004a 4FF01403 	 mov r3,#20
 2685 004e 83F31188 	 msr basepri,r3
 2686 0052 BFF36F8F 	 isb 
 2687 0056 BFF34F8F 	 dsb 
 2688              	
 2689              	
 2690              	.LVL244:
 2691              	 .thumb
 2692              	.L225:
 2693              	.LBE214:
 2694              	.LBE213:
3047:../FreeRTOS/Source/tasks.c ****         traceTASK_SWITCHED_IN();
 2695              	 .loc 1 3047 0 discriminator 1
 2696 005a FEE7     	 b .L225
 2697              	.LVL245:
 2698              	.L224:
 2699              	.LBB215:
3047:../FreeRTOS/Source/tasks.c ****         traceTASK_SWITCHED_IN();
 2700              	 .loc 1 3047 0 is_stmt 0 discriminator 2
 2701 005c 124A     	 ldr r2,.L228+16
 2702 005e 9900     	 lsls r1,r3,#2
 2703 0060 C818     	 adds r0,r1,r3
 2704 0062 02EB8000 	 add r0,r2,r0,lsl#2
 2705 0066 4468     	 ldr r4,[r0,#4]
 2706 0068 6468     	 ldr r4,[r4,#4]
 2707 006a 4460     	 str r4,[r0,#4]
 2708 006c 0246     	 mov r2,r0
 2709 006e 0832     	 adds r2,r2,#8
 2710 0070 9442     	 cmp r4,r2
 2711 0072 06D1     	 bne .L226
3047:../FreeRTOS/Source/tasks.c ****         traceTASK_SWITCHED_IN();
 2712              	 .loc 1 3047 0 discriminator 3
 2713 0074 6068     	 ldr r0,[r4,#4]
 2714 0076 03EB8301 	 add r1,r3,r3,lsl#2
 2715 007a 0B4A     	 ldr r2,.L228+16
 2716 007c 02EB8102 	 add r2,r2,r1,lsl#2
 2717 0080 5060     	 str r0,[r2,#4]
 2718              	.L226:
3047:../FreeRTOS/Source/tasks.c ****         traceTASK_SWITCHED_IN();
 2719              	 .loc 1 3047 0 discriminator 5
 2720 0082 03EB8303 	 add r3,r3,r3,lsl#2
 2721              	.LVL246:
 2722 0086 084A     	 ldr r2,.L228+16
 2723 0088 02EB8303 	 add r3,r2,r3,lsl#2
 2724 008c 5B68     	 ldr r3,[r3,#4]
 2725 008e DA68     	 ldr r2,[r3,#12]
 2726 0090 034B     	 ldr r3,.L228+8
 2727 0092 1A60     	 str r2,[r3]
 2728 0094 10BD     	 pop {r4,pc}
 2729              	.L229:
 2730 0096 00BF     	 .align 2
 2731              	.L228:
 2732 0098 00000000 	 .word .LANCHOR16
 2733 009c 00000000 	 .word .LANCHOR19
 2734 00a0 00000000 	 .word .LANCHOR5
 2735 00a4 00000000 	 .word .LANCHOR6
 2736 00a8 00000000 	 .word .LANCHOR11
 2737              	.LBE215:
 2738              	.LBE210:
 2739              	 .cfi_endproc
 2740              	.LFE30:
 2742              	 .section .text.vTaskSuspend,"ax",%progbits
 2743              	 .align 2
 2744              	 .global vTaskSuspend
 2745              	 .thumb
 2746              	 .thumb_func
 2748              	vTaskSuspend:
 2749              	.LFB15:
1700:../FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
 2750              	 .loc 1 1700 0 is_stmt 1
 2751              	 .cfi_startproc
 2752              	 
 2753              	 
 2754              	.LVL247:
 2755 0000 38B5     	 push {r3,r4,r5,lr}
 2756              	.LCFI21:
 2757              	 .cfi_def_cfa_offset 16
 2758              	 .cfi_offset 3,-16
 2759              	 .cfi_offset 4,-12
 2760              	 .cfi_offset 5,-8
 2761              	 .cfi_offset 14,-4
 2762 0002 0446     	 mov r4,r0
1703:../FreeRTOS/Source/tasks.c ****         {
 2763              	 .loc 1 1703 0
 2764 0004 FFF7FEFF 	 bl vPortEnterCritical
 2765              	.LVL248:
1707:../FreeRTOS/Source/tasks.c **** 
 2766              	 .loc 1 1707 0
 2767 0008 0CB9     	 cbnz r4,.L231
1707:../FreeRTOS/Source/tasks.c **** 
 2768              	 .loc 1 1707 0 is_stmt 0 discriminator 1
 2769 000a 2D4B     	 ldr r3,.L242
 2770 000c 1C68     	 ldr r4,[r3]
 2771              	.LVL249:
 2772              	.L231:
1713:../FreeRTOS/Source/tasks.c ****             {
 2773              	 .loc 1 1713 0 is_stmt 1 discriminator 4
 2774 000e 251D     	 adds r5,r4,#4
 2775 0010 2846     	 mov r0,r5
 2776 0012 FFF7FEFF 	 bl uxListRemove
 2777              	.LVL250:
 2778 0016 68B9     	 cbnz r0,.L232
1715:../FreeRTOS/Source/tasks.c ****             }
 2779              	 .loc 1 1715 0
 2780 0018 E16A     	 ldr r1,[r4,#44]
 2781 001a 01EB8103 	 add r3,r1,r1,lsl#2
 2782 001e 9B00     	 lsls r3,r3,#2
 2783 0020 284A     	 ldr r2,.L242+4
 2784 0022 D358     	 ldr r3,[r2,r3]
 2785 0024 33B9     	 cbnz r3,.L232
1715:../FreeRTOS/Source/tasks.c ****             }
 2786              	 .loc 1 1715 0 is_stmt 0 discriminator 1
 2787 0026 2848     	 ldr r0,.L242+8
 2788 0028 0368     	 ldr r3,[r0]
 2789 002a 0122     	 movs r2,#1
 2790 002c 8A40     	 lsls r2,r2,r1
 2791 002e 23EA0203 	 bic r3,r3,r2
 2792 0032 0360     	 str r3,[r0]
 2793              	.L232:
1723:../FreeRTOS/Source/tasks.c ****             {
 2794              	 .loc 1 1723 0 is_stmt 1
 2795 0034 A36A     	 ldr r3,[r4,#40]
 2796 0036 1BB1     	 cbz r3,.L233
1725:../FreeRTOS/Source/tasks.c ****             }
 2797              	 .loc 1 1725 0
 2798 0038 04F11800 	 add r0,r4,#24
 2799 003c FFF7FEFF 	 bl uxListRemove
 2800              	.LVL251:
 2801              	.L233:
1732:../FreeRTOS/Source/tasks.c **** 
 2802              	 .loc 1 1732 0
 2803 0040 2248     	 ldr r0,.L242+12
 2804 0042 2946     	 mov r1,r5
 2805 0044 FFF7FEFF 	 bl vListInsertEnd
 2806              	.LVL252:
 2807              	.LBB216:
1740:../FreeRTOS/Source/tasks.c ****                         {
 2808              	 .loc 1 1740 0
 2809 0048 94F85C30 	 ldrb r3,[r4,#92]
 2810 004c DBB2     	 uxtb r3,r3
 2811 004e 012B     	 cmp r3,#1
1744:../FreeRTOS/Source/tasks.c ****                         }
 2812              	 .loc 1 1744 0
 2813 0050 04BF     	 itt eq
 2814 0052 0023     	 moveq r3,#0
 2815 0054 84F85C30 	 strbeq r3,[r4,#92]
 2816              	.LVL253:
 2817              	.LBE216:
1750:../FreeRTOS/Source/tasks.c **** 
 2818              	 .loc 1 1750 0
 2819 0058 FFF7FEFF 	 bl vPortExitCritical
 2820              	.LVL254:
1752:../FreeRTOS/Source/tasks.c ****         {
 2821              	 .loc 1 1752 0
 2822 005c 1C4B     	 ldr r3,.L242+16
 2823 005e 1B68     	 ldr r3,[r3]
 2824 0060 2BB1     	 cbz r3,.L235
1756:../FreeRTOS/Source/tasks.c ****             {
 2825              	 .loc 1 1756 0
 2826 0062 FFF7FEFF 	 bl vPortEnterCritical
 2827              	.LVL255:
1758:../FreeRTOS/Source/tasks.c ****             }
 2828              	 .loc 1 1758 0
 2829 0066 FFF7FEFF 	 bl prvResetNextTaskUnblockTime
 2830              	.LVL256:
1760:../FreeRTOS/Source/tasks.c ****         }
 2831              	 .loc 1 1760 0
 2832 006a FFF7FEFF 	 bl vPortExitCritical
 2833              	.LVL257:
 2834              	.L235:
1767:../FreeRTOS/Source/tasks.c ****         {
 2835              	 .loc 1 1767 0
 2836 006e 144B     	 ldr r3,.L242
 2837 0070 1B68     	 ldr r3,[r3]
 2838 0072 9C42     	 cmp r4,r3
 2839 0074 23D1     	 bne .L230
1769:../FreeRTOS/Source/tasks.c ****             {
 2840              	 .loc 1 1769 0
 2841 0076 164B     	 ldr r3,.L242+16
 2842 0078 1B68     	 ldr r3,[r3]
 2843 007a A3B1     	 cbz r3,.L237
1772:../FreeRTOS/Source/tasks.c ****                 portYIELD_WITHIN_API();
 2844              	 .loc 1 1772 0
 2845 007c 154B     	 ldr r3,.L242+20
 2846 007e 1B68     	 ldr r3,[r3]
 2847 0080 43B1     	 cbz r3,.L238
 2848              	.LBB217:
 2849              	.LBB218:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 2850              	 .loc 2 197 0
 2851              	
 2852 0082 4FF01403 	 mov r3,#20
 2853 0086 83F31188 	 msr basepri,r3
 2854 008a BFF36F8F 	 isb 
 2855 008e BFF34F8F 	 dsb 
 2856              	
 2857              	
 2858              	.LVL258:
 2859              	 .thumb
 2860              	.L239:
 2861              	.LBE218:
 2862              	.LBE217:
1772:../FreeRTOS/Source/tasks.c ****                 portYIELD_WITHIN_API();
 2863              	 .loc 1 1772 0 discriminator 1
 2864 0092 FEE7     	 b .L239
 2865              	.L238:
1773:../FreeRTOS/Source/tasks.c ****             }
 2866              	 .loc 1 1773 0
 2867 0094 4FF08052 	 mov r2,#268435456
 2868 0098 0F4B     	 ldr r3,.L242+24
 2869 009a 1A60     	 str r2,[r3]
 2870              	
 2871 009c BFF34F8F 	 dsb
 2872              	
 2873              	
 2874 00a0 BFF36F8F 	 isb
 2875              	
 2876              	 .thumb
 2877 00a4 38BD     	 pop {r3,r4,r5,pc}
 2878              	.LVL259:
 2879              	.L237:
1780:../FreeRTOS/Source/tasks.c ****                 {
 2880              	 .loc 1 1780 0
 2881 00a6 094B     	 ldr r3,.L242+12
 2882 00a8 1A68     	 ldr r2,[r3]
 2883 00aa 0C4B     	 ldr r3,.L242+28
 2884 00ac 1B68     	 ldr r3,[r3]
 2885 00ae 9A42     	 cmp r2,r3
 2886 00b0 03D1     	 bne .L240
1786:../FreeRTOS/Source/tasks.c ****                 }
 2887              	 .loc 1 1786 0
 2888 00b2 0022     	 movs r2,#0
 2889 00b4 024B     	 ldr r3,.L242
 2890 00b6 1A60     	 str r2,[r3]
 2891 00b8 38BD     	 pop {r3,r4,r5,pc}
 2892              	.LVL260:
 2893              	.L240:
1790:../FreeRTOS/Source/tasks.c ****                 }
 2894              	 .loc 1 1790 0
 2895 00ba FFF7FEFF 	 bl vTaskSwitchContext
 2896              	.LVL261:
 2897              	.L230:
 2898 00be 38BD     	 pop {r3,r4,r5,pc}
 2899              	.LVL262:
 2900              	.L243:
 2901              	 .align 2
 2902              	.L242:
 2903 00c0 00000000 	 .word .LANCHOR5
 2904 00c4 00000000 	 .word .LANCHOR11
 2905 00c8 00000000 	 .word .LANCHOR6
 2906 00cc 00000000 	 .word .LANCHOR0
 2907 00d0 00000000 	 .word .LANCHOR14
 2908 00d4 00000000 	 .word .LANCHOR16
 2909 00d8 04ED00E0 	 .word -536810236
 2910 00dc 00000000 	 .word .LANCHOR10
 2911              	 .cfi_endproc
 2912              	.LFE15:
 2914              	 .section .text.vTaskPlaceOnEventList,"ax",%progbits
 2915              	 .align 2
 2916              	 .global vTaskPlaceOnEventList
 2917              	 .thumb
 2918              	 .thumb_func
 2920              	vTaskPlaceOnEventList:
 2921              	.LFB31:
3072:../FreeRTOS/Source/tasks.c ****     configASSERT( pxEventList );
 2922              	 .loc 1 3072 0
 2923              	 .cfi_startproc
 2924              	 
 2925              	 
 2926              	.LVL263:
3073:../FreeRTOS/Source/tasks.c **** 
 2927              	 .loc 1 3073 0
 2928 0000 40B9     	 cbnz r0,.L245
 2929              	.LBB219:
 2930              	.LBB220:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 2931              	 .loc 2 197 0
 2932              	
 2933 0002 4FF01403 	 mov r3,#20
 2934 0006 83F31188 	 msr basepri,r3
 2935 000a BFF36F8F 	 isb 
 2936 000e BFF34F8F 	 dsb 
 2937              	
 2938              	
 2939              	.LVL264:
 2940              	 .thumb
 2941              	.L246:
 2942              	.LBE220:
 2943              	.LBE219:
3073:../FreeRTOS/Source/tasks.c **** 
 2944              	 .loc 1 3073 0 discriminator 1
 2945 0012 FEE7     	 b .L246
 2946              	.L245:
3072:../FreeRTOS/Source/tasks.c ****     configASSERT( pxEventList );
 2947              	 .loc 1 3072 0
 2948 0014 10B5     	 push {r4,lr}
 2949              	.LCFI22:
 2950              	 .cfi_def_cfa_offset 8
 2951              	 .cfi_offset 4,-8
 2952              	 .cfi_offset 14,-4
 2953 0016 0C46     	 mov r4,r1
3082:../FreeRTOS/Source/tasks.c **** 
 2954              	 .loc 1 3082 0
 2955 0018 044B     	 ldr r3,.L248
 2956 001a 1968     	 ldr r1,[r3]
 2957              	.LVL265:
 2958 001c 1831     	 adds r1,r1,#24
 2959 001e FFF7FEFF 	 bl vListInsert
 2960              	.LVL266:
3084:../FreeRTOS/Source/tasks.c **** }
 2961              	 .loc 1 3084 0
 2962 0022 2046     	 mov r0,r4
 2963 0024 0121     	 movs r1,#1
 2964 0026 FFF7FEFF 	 bl prvAddCurrentTaskToDelayedList
 2965              	.LVL267:
 2966 002a 10BD     	 pop {r4,pc}
 2967              	.LVL268:
 2968              	.L249:
 2969              	 .align 2
 2970              	.L248:
 2971 002c 00000000 	 .word .LANCHOR5
 2972              	 .cfi_endproc
 2973              	.LFE31:
 2975              	 .section .text.vTaskPlaceOnUnorderedEventList,"ax",%progbits
 2976              	 .align 2
 2977              	 .global vTaskPlaceOnUnorderedEventList
 2978              	 .thumb
 2979              	 .thumb_func
 2981              	vTaskPlaceOnUnorderedEventList:
 2982              	.LFB32:
3091:../FreeRTOS/Source/tasks.c ****     configASSERT( pxEventList );
 2983              	 .loc 1 3091 0
 2984              	 .cfi_startproc
 2985              	 
 2986              	 
 2987              	.LVL269:
3092:../FreeRTOS/Source/tasks.c **** 
 2988              	 .loc 1 3092 0
 2989 0000 40B9     	 cbnz r0,.L251
 2990              	.LBB221:
 2991              	.LBB222:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 2992              	 .loc 2 197 0
 2993              	
 2994 0002 4FF01403 	 mov r3,#20
 2995 0006 83F31188 	 msr basepri,r3
 2996 000a BFF36F8F 	 isb 
 2997 000e BFF34F8F 	 dsb 
 2998              	
 2999              	
 3000              	.LVL270:
 3001              	 .thumb
 3002              	.L252:
 3003              	.LBE222:
 3004              	.LBE221:
3092:../FreeRTOS/Source/tasks.c **** 
 3005              	 .loc 1 3092 0 discriminator 1
 3006 0012 FEE7     	 b .L252
 3007              	.L251:
 3008 0014 0346     	 mov r3,r0
3096:../FreeRTOS/Source/tasks.c **** 
 3009              	 .loc 1 3096 0
 3010 0016 0F48     	 ldr r0,.L256
 3011              	.LVL271:
 3012 0018 0068     	 ldr r0,[r0]
 3013 001a 40B9     	 cbnz r0,.L253
 3014              	.LBB223:
 3015              	.LBB224:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 3016              	 .loc 2 197 0
 3017              	
 3018 001c 4FF01403 	 mov r3,#20
 3019 0020 83F31188 	 msr basepri,r3
 3020 0024 BFF36F8F 	 isb 
 3021 0028 BFF34F8F 	 dsb 
 3022              	
 3023              	
 3024              	.LVL272:
 3025              	 .thumb
 3026              	.L254:
 3027              	.LBE224:
 3028              	.LBE223:
3096:../FreeRTOS/Source/tasks.c **** 
 3029              	 .loc 1 3096 0 discriminator 2
 3030 002c FEE7     	 b .L254
 3031              	.LVL273:
 3032              	.L253:
3091:../FreeRTOS/Source/tasks.c ****     configASSERT( pxEventList );
 3033              	 .loc 1 3091 0
 3034 002e 10B5     	 push {r4,lr}
 3035              	.LCFI23:
 3036              	 .cfi_def_cfa_offset 8
 3037              	 .cfi_offset 4,-8
 3038              	 .cfi_offset 14,-4
 3039 0030 1846     	 mov r0,r3
 3040 0032 1446     	 mov r4,r2
 3041 0034 0B46     	 mov r3,r1
 3042              	.LVL274:
3101:../FreeRTOS/Source/tasks.c **** 
 3043              	 .loc 1 3101 0
 3044 0036 084A     	 ldr r2,.L256+4
 3045              	.LVL275:
 3046 0038 1168     	 ldr r1,[r2]
 3047              	.LVL276:
 3048 003a 43F00043 	 orr r3,r3,#-2147483648
 3049              	.LVL277:
 3050 003e 8B61     	 str r3,[r1,#24]
3108:../FreeRTOS/Source/tasks.c **** 
 3051              	 .loc 1 3108 0
 3052 0040 1168     	 ldr r1,[r2]
 3053 0042 1831     	 adds r1,r1,#24
 3054 0044 FFF7FEFF 	 bl vListInsertEnd
 3055              	.LVL278:
3110:../FreeRTOS/Source/tasks.c **** }
 3056              	 .loc 1 3110 0
 3057 0048 2046     	 mov r0,r4
 3058 004a 0121     	 movs r1,#1
 3059 004c FFF7FEFF 	 bl prvAddCurrentTaskToDelayedList
 3060              	.LVL279:
 3061 0050 10BD     	 pop {r4,pc}
 3062              	.LVL280:
 3063              	.L257:
 3064 0052 00BF     	 .align 2
 3065              	.L256:
 3066 0054 00000000 	 .word .LANCHOR16
 3067 0058 00000000 	 .word .LANCHOR5
 3068              	 .cfi_endproc
 3069              	.LFE32:
 3071              	 .section .text.vTaskPlaceOnEventListRestricted,"ax",%progbits
 3072              	 .align 2
 3073              	 .global vTaskPlaceOnEventListRestricted
 3074              	 .thumb
 3075              	 .thumb_func
 3077              	vTaskPlaceOnEventListRestricted:
 3078              	.LFB33:
3119:../FreeRTOS/Source/tasks.c ****         configASSERT( pxEventList );
 3079              	 .loc 1 3119 0
 3080              	 .cfi_startproc
 3081              	 
 3082              	 
 3083              	.LVL281:
 3084 0000 38B5     	 push {r3,r4,r5,lr}
 3085              	.LCFI24:
 3086              	 .cfi_def_cfa_offset 16
 3087              	 .cfi_offset 3,-16
 3088              	 .cfi_offset 4,-12
 3089              	 .cfi_offset 5,-8
 3090              	 .cfi_offset 14,-4
3120:../FreeRTOS/Source/tasks.c **** 
 3091              	 .loc 1 3120 0
 3092 0002 40B9     	 cbnz r0,.L259
 3093              	.LBB225:
 3094              	.LBB226:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 3095              	 .loc 2 197 0
 3096              	
 3097 0004 4FF01403 	 mov r3,#20
 3098 0008 83F31188 	 msr basepri,r3
 3099 000c BFF36F8F 	 isb 
 3100 0010 BFF34F8F 	 dsb 
 3101              	
 3102              	
 3103              	.LVL282:
 3104              	 .thumb
 3105              	.L260:
 3106              	.LBE226:
 3107              	.LBE225:
3120:../FreeRTOS/Source/tasks.c **** 
 3108              	 .loc 1 3120 0 discriminator 1
 3109 0014 FEE7     	 b .L260
 3110              	.L259:
 3111 0016 1446     	 mov r4,r2
 3112 0018 0D46     	 mov r5,r1
3132:../FreeRTOS/Source/tasks.c **** 
 3113              	 .loc 1 3132 0
 3114 001a 074B     	 ldr r3,.L263
 3115 001c 1968     	 ldr r1,[r3]
 3116              	.LVL283:
 3117 001e 1831     	 adds r1,r1,#24
 3118 0020 FFF7FEFF 	 bl vListInsertEnd
 3119              	.LVL284:
3139:../FreeRTOS/Source/tasks.c ****         }
 3120              	 .loc 1 3139 0
 3121 0024 002C     	 cmp r4,#0
 3122              	.LVL285:
3143:../FreeRTOS/Source/tasks.c ****     }
 3123              	 .loc 1 3143 0
 3124 0026 0CBF     	 ite eq
 3125 0028 2846     	 moveq r0,r5
 3126 002a 4FF0FF30 	 movne r0,#-1
 3127 002e 2146     	 mov r1,r4
 3128 0030 FFF7FEFF 	 bl prvAddCurrentTaskToDelayedList
 3129              	.LVL286:
 3130 0034 38BD     	 pop {r3,r4,r5,pc}
 3131              	.LVL287:
 3132              	.L264:
 3133 0036 00BF     	 .align 2
 3134              	.L263:
 3135 0038 00000000 	 .word .LANCHOR5
 3136              	 .cfi_endproc
 3137              	.LFE33:
 3139              	 .section .text.xTaskRemoveFromEventList,"ax",%progbits
 3140              	 .align 2
 3141              	 .global xTaskRemoveFromEventList
 3142              	 .thumb
 3143              	 .thumb_func
 3145              	xTaskRemoveFromEventList:
 3146              	.LFB34:
3150:../FreeRTOS/Source/tasks.c ****     TCB_t * pxUnblockedTCB;
 3147              	 .loc 1 3150 0
 3148              	 .cfi_startproc
 3149              	 
 3150              	 
 3151              	.LVL288:
 3152 0000 38B5     	 push {r3,r4,r5,lr}
 3153              	.LCFI25:
 3154              	 .cfi_def_cfa_offset 16
 3155              	 .cfi_offset 3,-16
 3156              	 .cfi_offset 4,-12
 3157              	 .cfi_offset 5,-8
 3158              	 .cfi_offset 14,-4
3167:../FreeRTOS/Source/tasks.c ****     configASSERT( pxUnblockedTCB );
 3159              	 .loc 1 3167 0
 3160 0002 C368     	 ldr r3,[r0,#12]
 3161 0004 DC68     	 ldr r4,[r3,#12]
 3162              	.LVL289:
3168:../FreeRTOS/Source/tasks.c ****     ( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 3163              	 .loc 1 3168 0
 3164 0006 44B9     	 cbnz r4,.L266
 3165              	.LBB227:
 3166              	.LBB228:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 3167              	 .loc 2 197 0
 3168              	
 3169 0008 4FF01403 	 mov r3,#20
 3170 000c 83F31188 	 msr basepri,r3
 3171 0010 BFF36F8F 	 isb 
 3172 0014 BFF34F8F 	 dsb 
 3173              	
 3174              	
 3175              	.LVL290:
 3176              	 .thumb
 3177              	.L267:
 3178              	.LBE228:
 3179              	.LBE227:
3168:../FreeRTOS/Source/tasks.c ****     ( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 3180              	 .loc 1 3168 0 discriminator 1
 3181 0018 FEE7     	 b .L267
 3182              	.L266:
3169:../FreeRTOS/Source/tasks.c **** 
 3183              	 .loc 1 3169 0
 3184 001a 04F11805 	 add r5,r4,#24
 3185 001e 2846     	 mov r0,r5
 3186              	.LVL291:
 3187 0020 FFF7FEFF 	 bl uxListRemove
 3188              	.LVL292:
3171:../FreeRTOS/Source/tasks.c ****     {
 3189              	 .loc 1 3171 0
 3190 0024 124B     	 ldr r3,.L273
 3191 0026 1B68     	 ldr r3,[r3]
 3192 0028 9BB9     	 cbnz r3,.L268
3173:../FreeRTOS/Source/tasks.c ****         prvAddTaskToReadyList( pxUnblockedTCB );
 3193              	 .loc 1 3173 0
 3194 002a 251D     	 adds r5,r4,#4
 3195 002c 2846     	 mov r0,r5
 3196 002e FFF7FEFF 	 bl uxListRemove
 3197              	.LVL293:
3174:../FreeRTOS/Source/tasks.c **** 
 3198              	 .loc 1 3174 0
 3199 0032 E06A     	 ldr r0,[r4,#44]
 3200 0034 0F49     	 ldr r1,.L273+4
 3201 0036 0B68     	 ldr r3,[r1]
 3202 0038 0122     	 movs r2,#1
 3203 003a 8240     	 lsls r2,r2,r0
 3204 003c 1343     	 orrs r3,r3,r2
 3205 003e 0B60     	 str r3,[r1]
 3206 0040 00EB8000 	 add r0,r0,r0,lsl#2
 3207 0044 0C4B     	 ldr r3,.L273+8
 3208 0046 03EB8000 	 add r0,r3,r0,lsl#2
 3209 004a 2946     	 mov r1,r5
 3210 004c FFF7FEFF 	 bl vListInsertEnd
 3211              	.LVL294:
 3212 0050 03E0     	 b .L269
 3213              	.L268:
3194:../FreeRTOS/Source/tasks.c ****     }
 3214              	 .loc 1 3194 0
 3215 0052 0A48     	 ldr r0,.L273+12
 3216 0054 2946     	 mov r1,r5
 3217 0056 FFF7FEFF 	 bl vListInsertEnd
 3218              	.LVL295:
 3219              	.L269:
3197:../FreeRTOS/Source/tasks.c ****     {
 3220              	 .loc 1 3197 0
 3221 005a 094B     	 ldr r3,.L273+16
 3222 005c 1B68     	 ldr r3,[r3]
 3223 005e E26A     	 ldr r2,[r4,#44]
 3224 0060 DB6A     	 ldr r3,[r3,#44]
 3225 0062 9A42     	 cmp r2,r3
 3226              	.LVL296:
3206:../FreeRTOS/Source/tasks.c ****     }
 3227              	 .loc 1 3206 0
 3228 0064 83BF     	 ittte hi
 3229 0066 0120     	 movhi r0,#1
 3230 0068 064B     	 ldrhi r3,.L273+20
 3231 006a 1860     	 strhi r0,[r3]
3210:../FreeRTOS/Source/tasks.c ****     }
 3232              	 .loc 1 3210 0
 3233 006c 0020     	 movls r0,#0
 3234              	.LVL297:
3214:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 3235              	 .loc 1 3214 0
 3236 006e 38BD     	 pop {r3,r4,r5,pc}
 3237              	.LVL298:
 3238              	.L274:
 3239              	 .align 2
 3240              	.L273:
 3241 0070 00000000 	 .word .LANCHOR16
 3242 0074 00000000 	 .word .LANCHOR6
 3243 0078 00000000 	 .word .LANCHOR11
 3244 007c 00000000 	 .word .LANCHOR1
 3245 0080 00000000 	 .word .LANCHOR5
 3246 0084 00000000 	 .word .LANCHOR19
 3247              	 .cfi_endproc
 3248              	.LFE34:
 3250              	 .section .text.vTaskRemoveFromUnorderedEventList,"ax",%progbits
 3251              	 .align 2
 3252              	 .global vTaskRemoveFromUnorderedEventList
 3253              	 .thumb
 3254              	 .thumb_func
 3256              	vTaskRemoveFromUnorderedEventList:
 3257              	.LFB35:
3219:../FreeRTOS/Source/tasks.c ****     TCB_t * pxUnblockedTCB;
 3258              	 .loc 1 3219 0
 3259              	 .cfi_startproc
 3260              	 
 3261              	 
 3262              	.LVL299:
 3263 0000 38B5     	 push {r3,r4,r5,lr}
 3264              	.LCFI26:
 3265              	 .cfi_def_cfa_offset 16
 3266              	 .cfi_offset 3,-16
 3267              	 .cfi_offset 4,-12
 3268              	 .cfi_offset 5,-8
 3269              	 .cfi_offset 14,-4
3224:../FreeRTOS/Source/tasks.c **** 
 3270              	 .loc 1 3224 0
 3271 0002 1C4B     	 ldr r3,.L282
 3272 0004 1B68     	 ldr r3,[r3]
 3273 0006 43B9     	 cbnz r3,.L276
 3274              	.LBB229:
 3275              	.LBB230:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 3276              	 .loc 2 197 0
 3277              	
 3278 0008 4FF01403 	 mov r3,#20
 3279 000c 83F31188 	 msr basepri,r3
 3280 0010 BFF36F8F 	 isb 
 3281 0014 BFF34F8F 	 dsb 
 3282              	
 3283              	
 3284              	.LVL300:
 3285              	 .thumb
 3286              	.L277:
 3287              	.LBE230:
 3288              	.LBE229:
3224:../FreeRTOS/Source/tasks.c **** 
 3289              	 .loc 1 3224 0 discriminator 1
 3290 0018 FEE7     	 b .L277
 3291              	.L276:
3227:../FreeRTOS/Source/tasks.c **** 
 3292              	 .loc 1 3227 0
 3293 001a 41F00043 	 orr r3,r1,#-2147483648
 3294 001e 0360     	 str r3,[r0]
3231:../FreeRTOS/Source/tasks.c ****     configASSERT( pxUnblockedTCB );
 3295              	 .loc 1 3231 0
 3296 0020 C468     	 ldr r4,[r0,#12]
 3297              	.LVL301:
3232:../FreeRTOS/Source/tasks.c ****     ( void ) uxListRemove( pxEventListItem );
 3298              	 .loc 1 3232 0
 3299 0022 44B9     	 cbnz r4,.L278
 3300              	.LBB231:
 3301              	.LBB232:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 3302              	 .loc 2 197 0
 3303              	
 3304 0024 4FF01403 	 mov r3,#20
 3305 0028 83F31188 	 msr basepri,r3
 3306 002c BFF36F8F 	 isb 
 3307 0030 BFF34F8F 	 dsb 
 3308              	
 3309              	
 3310              	.LVL302:
 3311              	 .thumb
 3312              	.L279:
 3313              	.LBE232:
 3314              	.LBE231:
3232:../FreeRTOS/Source/tasks.c ****     ( void ) uxListRemove( pxEventListItem );
 3315              	 .loc 1 3232 0 discriminator 2
 3316 0034 FEE7     	 b .L279
 3317              	.L278:
3233:../FreeRTOS/Source/tasks.c **** 
 3318              	 .loc 1 3233 0
 3319 0036 FFF7FEFF 	 bl uxListRemove
 3320              	.LVL303:
3252:../FreeRTOS/Source/tasks.c ****     prvAddTaskToReadyList( pxUnblockedTCB );
 3321              	 .loc 1 3252 0
 3322 003a 251D     	 adds r5,r4,#4
 3323 003c 2846     	 mov r0,r5
 3324 003e FFF7FEFF 	 bl uxListRemove
 3325              	.LVL304:
3253:../FreeRTOS/Source/tasks.c **** 
 3326              	 .loc 1 3253 0
 3327 0042 E06A     	 ldr r0,[r4,#44]
 3328 0044 0C49     	 ldr r1,.L282+4
 3329 0046 0B68     	 ldr r3,[r1]
 3330 0048 0122     	 movs r2,#1
 3331 004a 8240     	 lsls r2,r2,r0
 3332 004c 1343     	 orrs r3,r3,r2
 3333 004e 0B60     	 str r3,[r1]
 3334 0050 00EB8000 	 add r0,r0,r0,lsl#2
 3335 0054 094B     	 ldr r3,.L282+8
 3336 0056 03EB8000 	 add r0,r3,r0,lsl#2
 3337 005a 2946     	 mov r1,r5
 3338 005c FFF7FEFF 	 bl vListInsertEnd
 3339              	.LVL305:
3255:../FreeRTOS/Source/tasks.c ****     {
 3340              	 .loc 1 3255 0
 3341 0060 074B     	 ldr r3,.L282+12
 3342 0062 1B68     	 ldr r3,[r3]
 3343 0064 E26A     	 ldr r2,[r4,#44]
 3344 0066 DB6A     	 ldr r3,[r3,#44]
 3345 0068 9A42     	 cmp r2,r3
 3346 006a 02D9     	 bls .L275
3261:../FreeRTOS/Source/tasks.c ****     }
 3347              	 .loc 1 3261 0
 3348 006c 0122     	 movs r2,#1
 3349 006e 054B     	 ldr r3,.L282+16
 3350 0070 1A60     	 str r2,[r3]
 3351              	.L275:
 3352 0072 38BD     	 pop {r3,r4,r5,pc}
 3353              	.LVL306:
 3354              	.L283:
 3355              	 .align 2
 3356              	.L282:
 3357 0074 00000000 	 .word .LANCHOR16
 3358 0078 00000000 	 .word .LANCHOR6
 3359 007c 00000000 	 .word .LANCHOR11
 3360 0080 00000000 	 .word .LANCHOR5
 3361 0084 00000000 	 .word .LANCHOR19
 3362              	 .cfi_endproc
 3363              	.LFE35:
 3365              	 .section .text.vTaskSetTimeOutState,"ax",%progbits
 3366              	 .align 2
 3367              	 .global vTaskSetTimeOutState
 3368              	 .thumb
 3369              	 .thumb_func
 3371              	vTaskSetTimeOutState:
 3372              	.LFB36:
3267:../FreeRTOS/Source/tasks.c ****     configASSERT( pxTimeOut );
 3373              	 .loc 1 3267 0
 3374              	 .cfi_startproc
 3375              	 
 3376              	 
 3377              	.LVL307:
3268:../FreeRTOS/Source/tasks.c ****     taskENTER_CRITICAL();
 3378              	 .loc 1 3268 0
 3379 0000 40B9     	 cbnz r0,.L285
 3380              	.LBB233:
 3381              	.LBB234:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 3382              	 .loc 2 197 0
 3383              	
 3384 0002 4FF01403 	 mov r3,#20
 3385 0006 83F31188 	 msr basepri,r3
 3386 000a BFF36F8F 	 isb 
 3387 000e BFF34F8F 	 dsb 
 3388              	
 3389              	
 3390              	.LVL308:
 3391              	 .thumb
 3392              	.L286:
 3393              	.LBE234:
 3394              	.LBE233:
3268:../FreeRTOS/Source/tasks.c ****     taskENTER_CRITICAL();
 3395              	 .loc 1 3268 0 discriminator 1
 3396 0012 FEE7     	 b .L286
 3397              	.L285:
3267:../FreeRTOS/Source/tasks.c ****     configASSERT( pxTimeOut );
 3398              	 .loc 1 3267 0
 3399 0014 10B5     	 push {r4,lr}
 3400              	.LCFI27:
 3401              	 .cfi_def_cfa_offset 8
 3402              	 .cfi_offset 4,-8
 3403              	 .cfi_offset 14,-4
 3404 0016 0446     	 mov r4,r0
3269:../FreeRTOS/Source/tasks.c ****     {
 3405              	 .loc 1 3269 0
 3406 0018 FFF7FEFF 	 bl vPortEnterCritical
 3407              	.LVL309:
3271:../FreeRTOS/Source/tasks.c ****         pxTimeOut->xTimeOnEntering = xTickCount;
 3408              	 .loc 1 3271 0
 3409 001c 044B     	 ldr r3,.L288
 3410 001e 1B68     	 ldr r3,[r3]
 3411 0020 2360     	 str r3,[r4]
3272:../FreeRTOS/Source/tasks.c ****     }
 3412              	 .loc 1 3272 0
 3413 0022 044B     	 ldr r3,.L288+4
 3414 0024 1B68     	 ldr r3,[r3]
 3415 0026 6360     	 str r3,[r4,#4]
3274:../FreeRTOS/Source/tasks.c **** }
 3416              	 .loc 1 3274 0
 3417 0028 FFF7FEFF 	 bl vPortExitCritical
 3418              	.LVL310:
 3419 002c 10BD     	 pop {r4,pc}
 3420              	.LVL311:
 3421              	.L289:
 3422 002e 00BF     	 .align 2
 3423              	.L288:
 3424 0030 00000000 	 .word .LANCHOR18
 3425 0034 00000000 	 .word .LANCHOR4
 3426              	 .cfi_endproc
 3427              	.LFE36:
 3429              	 .section .text.vTaskInternalSetTimeOutState,"ax",%progbits
 3430              	 .align 2
 3431              	 .global vTaskInternalSetTimeOutState
 3432              	 .thumb
 3433              	 .thumb_func
 3435              	vTaskInternalSetTimeOutState:
 3436              	.LFB37:
3279:../FreeRTOS/Source/tasks.c ****     /* For internal use only as it does not use a critical section. */
 3437              	 .loc 1 3279 0
 3438              	 .cfi_startproc
 3439              	 
 3440              	 
 3441              	 
 3442              	.LVL312:
3281:../FreeRTOS/Source/tasks.c ****     pxTimeOut->xTimeOnEntering = xTickCount;
 3443              	 .loc 1 3281 0
 3444 0000 034B     	 ldr r3,.L291
 3445 0002 1B68     	 ldr r3,[r3]
 3446 0004 0360     	 str r3,[r0]
3282:../FreeRTOS/Source/tasks.c **** }
 3447              	 .loc 1 3282 0
 3448 0006 034B     	 ldr r3,.L291+4
 3449 0008 1B68     	 ldr r3,[r3]
 3450 000a 4360     	 str r3,[r0,#4]
 3451 000c 7047     	 bx lr
 3452              	.L292:
 3453 000e 00BF     	 .align 2
 3454              	.L291:
 3455 0010 00000000 	 .word .LANCHOR18
 3456 0014 00000000 	 .word .LANCHOR4
 3457              	 .cfi_endproc
 3458              	.LFE37:
 3460              	 .section .text.xTaskCheckForTimeOut,"ax",%progbits
 3461              	 .align 2
 3462              	 .global xTaskCheckForTimeOut
 3463              	 .thumb
 3464              	 .thumb_func
 3466              	xTaskCheckForTimeOut:
 3467              	.LFB38:
3288:../FreeRTOS/Source/tasks.c ****     BaseType_t xReturn;
 3468              	 .loc 1 3288 0
 3469              	 .cfi_startproc
 3470              	 
 3471              	 
 3472              	.LVL313:
3291:../FreeRTOS/Source/tasks.c ****     configASSERT( pxTicksToWait );
 3473              	 .loc 1 3291 0
 3474 0000 40B9     	 cbnz r0,.L294
 3475              	.LBB235:
 3476              	.LBB236:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 3477              	 .loc 2 197 0
 3478              	
 3479 0002 4FF01403 	 mov r3,#20
 3480 0006 83F31188 	 msr basepri,r3
 3481 000a BFF36F8F 	 isb 
 3482 000e BFF34F8F 	 dsb 
 3483              	
 3484              	
 3485              	.LVL314:
 3486              	 .thumb
 3487              	.L295:
 3488              	.LBE236:
 3489              	.LBE235:
3291:../FreeRTOS/Source/tasks.c ****     configASSERT( pxTicksToWait );
 3490              	 .loc 1 3291 0 discriminator 1
 3491 0012 FEE7     	 b .L295
 3492              	.L294:
3288:../FreeRTOS/Source/tasks.c ****     BaseType_t xReturn;
 3493              	 .loc 1 3288 0
 3494 0014 70B5     	 push {r4,r5,r6,lr}
 3495              	.LCFI28:
 3496              	 .cfi_def_cfa_offset 16
 3497              	 .cfi_offset 4,-16
 3498              	 .cfi_offset 5,-12
 3499              	 .cfi_offset 6,-8
 3500              	 .cfi_offset 14,-4
 3501 0016 0546     	 mov r5,r0
3292:../FreeRTOS/Source/tasks.c **** 
 3502              	 .loc 1 3292 0
 3503 0018 41B9     	 cbnz r1,.L296
 3504              	.LBB237:
 3505              	.LBB238:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 3506              	 .loc 2 197 0
 3507              	
 3508 001a 4FF01403 	 mov r3,#20
 3509 001e 83F31188 	 msr basepri,r3
 3510 0022 BFF36F8F 	 isb 
 3511 0026 BFF34F8F 	 dsb 
 3512              	
 3513              	
 3514              	.LVL315:
 3515              	 .thumb
 3516              	.L297:
 3517              	.LBE238:
 3518              	.LBE237:
3292:../FreeRTOS/Source/tasks.c **** 
 3519              	 .loc 1 3292 0 discriminator 2
 3520 002a FEE7     	 b .L297
 3521              	.L296:
 3522 002c 0C46     	 mov r4,r1
3294:../FreeRTOS/Source/tasks.c ****     {
 3523              	 .loc 1 3294 0
 3524 002e FFF7FEFF 	 bl vPortEnterCritical
 3525              	.LVL316:
 3526              	.LBB239:
3297:../FreeRTOS/Source/tasks.c ****         const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 3527              	 .loc 1 3297 0
 3528 0032 124B     	 ldr r3,.L303
 3529 0034 1A68     	 ldr r2,[r3]
 3530              	.LVL317:
3298:../FreeRTOS/Source/tasks.c **** 
 3531              	 .loc 1 3298 0
 3532 0036 6968     	 ldr r1,[r5,#4]
 3533              	.LVL318:
3312:../FreeRTOS/Source/tasks.c ****             {
 3534              	 .loc 1 3312 0
 3535 0038 2368     	 ldr r3,[r4]
 3536 003a B3F1FF3F 	 cmp r3,#-1
 3537 003e 18D0     	 beq .L301
3322:../FreeRTOS/Source/tasks.c ****         {
 3538              	 .loc 1 3322 0
 3539 0040 0F48     	 ldr r0,.L303+4
 3540 0042 0068     	 ldr r0,[r0]
 3541 0044 2E68     	 ldr r6,[r5]
 3542 0046 8642     	 cmp r6,r0
 3543 0048 05D0     	 beq .L299
3322:../FreeRTOS/Source/tasks.c ****         {
 3544              	 .loc 1 3322 0 is_stmt 0 discriminator 1
 3545 004a 8A42     	 cmp r2,r1
 3546 004c 03D3     	 bcc .L299
 3547              	.LVL319:
3330:../FreeRTOS/Source/tasks.c ****         }
 3548              	 .loc 1 3330 0 is_stmt 1
 3549 004e 0023     	 movs r3,#0
 3550 0050 2360     	 str r3,[r4]
3329:../FreeRTOS/Source/tasks.c ****             *pxTicksToWait = ( TickType_t ) 0;
 3551              	 .loc 1 3329 0
 3552 0052 0124     	 movs r4,#1
 3553              	.LVL320:
3330:../FreeRTOS/Source/tasks.c ****         }
 3554              	 .loc 1 3330 0
 3555 0054 0EE0     	 b .L298
 3556              	.LVL321:
 3557              	.L299:
3298:../FreeRTOS/Source/tasks.c **** 
 3558              	 .loc 1 3298 0
 3559 0056 521A     	 subs r2,r2,r1
 3560              	.LVL322:
3332:../FreeRTOS/Source/tasks.c ****         {
 3561              	 .loc 1 3332 0
 3562 0058 9A42     	 cmp r2,r3
 3563 005a 06D2     	 bcs .L300
3335:../FreeRTOS/Source/tasks.c ****             vTaskInternalSetTimeOutState( pxTimeOut );
 3564              	 .loc 1 3335 0
 3565 005c 9B1A     	 subs r3,r3,r2
 3566 005e 2360     	 str r3,[r4]
3336:../FreeRTOS/Source/tasks.c ****             xReturn = pdFALSE;
 3567              	 .loc 1 3336 0
 3568 0060 2846     	 mov r0,r5
 3569 0062 FFF7FEFF 	 bl vTaskInternalSetTimeOutState
 3570              	.LVL323:
3337:../FreeRTOS/Source/tasks.c ****         }
 3571              	 .loc 1 3337 0
 3572 0066 0024     	 movs r4,#0
 3573              	.LVL324:
 3574 0068 04E0     	 b .L298
 3575              	.LVL325:
 3576              	.L300:
3341:../FreeRTOS/Source/tasks.c ****             xReturn = pdTRUE;
 3577              	 .loc 1 3341 0
 3578 006a 0023     	 movs r3,#0
 3579 006c 2360     	 str r3,[r4]
 3580              	.LVL326:
3342:../FreeRTOS/Source/tasks.c ****         }
 3581              	 .loc 1 3342 0
 3582 006e 0124     	 movs r4,#1
 3583              	.LVL327:
 3584 0070 00E0     	 b .L298
 3585              	.LVL328:
 3586              	.L301:
3317:../FreeRTOS/Source/tasks.c ****             }
 3587              	 .loc 1 3317 0
 3588 0072 0024     	 movs r4,#0
 3589              	.LVL329:
 3590              	.L298:
 3591              	.LBE239:
3345:../FreeRTOS/Source/tasks.c **** 
 3592              	 .loc 1 3345 0
 3593 0074 FFF7FEFF 	 bl vPortExitCritical
 3594              	.LVL330:
3348:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 3595              	 .loc 1 3348 0
 3596 0078 2046     	 mov r0,r4
 3597 007a 70BD     	 pop {r4,r5,r6,pc}
 3598              	.LVL331:
 3599              	.L304:
 3600              	 .align 2
 3601              	.L303:
 3602 007c 00000000 	 .word .LANCHOR4
 3603 0080 00000000 	 .word .LANCHOR18
 3604              	 .cfi_endproc
 3605              	.LFE38:
 3607              	 .section .text.vTaskMissedYield,"ax",%progbits
 3608              	 .align 2
 3609              	 .global vTaskMissedYield
 3610              	 .thumb
 3611              	 .thumb_func
 3613              	vTaskMissedYield:
 3614              	.LFB39:
3352:../FreeRTOS/Source/tasks.c ****     xYieldPending = pdTRUE;
 3615              	 .loc 1 3352 0
 3616              	 .cfi_startproc
 3617              	 
 3618              	 
 3619              	 
3353:../FreeRTOS/Source/tasks.c **** }
 3620              	 .loc 1 3353 0
 3621 0000 0122     	 movs r2,#1
 3622 0002 014B     	 ldr r3,.L306
 3623 0004 1A60     	 str r2,[r3]
 3624 0006 7047     	 bx lr
 3625              	.L307:
 3626              	 .align 2
 3627              	.L306:
 3628 0008 00000000 	 .word .LANCHOR19
 3629              	 .cfi_endproc
 3630              	.LFE39:
 3632              	 .section .text.uxTaskGetTaskNumber,"ax",%progbits
 3633              	 .align 2
 3634              	 .global uxTaskGetTaskNumber
 3635              	 .thumb
 3636              	 .thumb_func
 3638              	uxTaskGetTaskNumber:
 3639              	.LFB40:
3360:../FreeRTOS/Source/tasks.c ****         UBaseType_t uxReturn;
 3640              	 .loc 1 3360 0
 3641              	 .cfi_startproc
 3642              	 
 3643              	 
 3644              	 
 3645              	.LVL332:
3364:../FreeRTOS/Source/tasks.c ****         {
 3646              	 .loc 1 3364 0
 3647 0000 08B1     	 cbz r0,.L310
 3648              	.LVL333:
3367:../FreeRTOS/Source/tasks.c ****         }
 3649              	 .loc 1 3367 0
 3650 0002 C06C     	 ldr r0,[r0,#76]
 3651              	.LVL334:
 3652 0004 7047     	 bx lr
 3653              	.LVL335:
 3654              	.L310:
3371:../FreeRTOS/Source/tasks.c ****         }
 3655              	 .loc 1 3371 0
 3656 0006 0020     	 movs r0,#0
 3657              	.LVL336:
3375:../FreeRTOS/Source/tasks.c **** 
 3658              	 .loc 1 3375 0
 3659 0008 7047     	 bx lr
 3660              	 .cfi_endproc
 3661              	.LFE40:
 3663 000a 00BF     	 .section .text.vTaskSetTaskNumber,"ax",%progbits
 3664              	 .align 2
 3665              	 .global vTaskSetTaskNumber
 3666              	 .thumb
 3667              	 .thumb_func
 3669              	vTaskSetTaskNumber:
 3670              	.LFB41:
3384:../FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
 3671              	 .loc 1 3384 0
 3672              	 .cfi_startproc
 3673              	 
 3674              	 
 3675              	 
 3676              	.LVL337:
3387:../FreeRTOS/Source/tasks.c ****         {
 3677              	 .loc 1 3387 0
 3678 0000 00B1     	 cbz r0,.L311
 3679              	.LVL338:
3390:../FreeRTOS/Source/tasks.c ****         }
 3680              	 .loc 1 3390 0
 3681 0002 C164     	 str r1,[r0,#76]
 3682              	.LVL339:
 3683              	.L311:
 3684 0004 7047     	 bx lr
 3685              	 .cfi_endproc
 3686              	.LFE41:
 3688 0006 00BF     	 .section .text.vTaskGetInfo,"ax",%progbits
 3689              	 .align 2
 3690              	 .global vTaskGetInfo
 3691              	 .thumb
 3692              	 .thumb_func
 3694              	vTaskGetInfo:
 3695              	.LFB45:
3698:../FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
 3696              	 .loc 1 3698 0
 3697              	 .cfi_startproc
 3698              	 
 3699              	 
 3700              	.LVL340:
 3701 0000 70B5     	 push {r4,r5,r6,lr}
 3702              	.LCFI29:
 3703              	 .cfi_def_cfa_offset 16
 3704              	 .cfi_offset 4,-16
 3705              	 .cfi_offset 5,-12
 3706              	 .cfi_offset 6,-8
 3707              	 .cfi_offset 14,-4
 3708 0002 0C46     	 mov r4,r1
 3709 0004 1646     	 mov r6,r2
3702:../FreeRTOS/Source/tasks.c **** 
 3710              	 .loc 1 3702 0
 3711 0006 0546     	 mov r5,r0
 3712 0008 08B9     	 cbnz r0,.L314
3702:../FreeRTOS/Source/tasks.c **** 
 3713              	 .loc 1 3702 0 is_stmt 0 discriminator 1
 3714 000a 1E4A     	 ldr r2,.L326
 3715              	.LVL341:
 3716 000c 1568     	 ldr r5,[r2]
 3717              	.LVL342:
 3718              	.L314:
3704:../FreeRTOS/Source/tasks.c ****         pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName[ 0 ] );
 3719              	 .loc 1 3704 0 is_stmt 1 discriminator 4
 3720 000e 2560     	 str r5,[r4]
3705:../FreeRTOS/Source/tasks.c ****         pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
 3721              	 .loc 1 3705 0 discriminator 4
 3722 0010 05F13402 	 add r2,r5,#52
 3723 0014 6260     	 str r2,[r4,#4]
3706:../FreeRTOS/Source/tasks.c ****         pxTaskStatus->pxStackBase = pxTCB->pxStack;
 3724              	 .loc 1 3706 0 discriminator 4
 3725 0016 EA6A     	 ldr r2,[r5,#44]
 3726 0018 2261     	 str r2,[r4,#16]
3707:../FreeRTOS/Source/tasks.c ****         pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
 3727              	 .loc 1 3707 0 discriminator 4
 3728 001a 2A6B     	 ldr r2,[r5,#48]
 3729 001c E261     	 str r2,[r4,#28]
3708:../FreeRTOS/Source/tasks.c **** 
 3730              	 .loc 1 3708 0 discriminator 4
 3731 001e AA6C     	 ldr r2,[r5,#72]
 3732 0020 A260     	 str r2,[r4,#8]
3712:../FreeRTOS/Source/tasks.c ****             }
 3733              	 .loc 1 3712 0 discriminator 4
 3734 0022 2A6D     	 ldr r2,[r5,#80]
 3735 0024 6261     	 str r2,[r4,#20]
3726:../FreeRTOS/Source/tasks.c ****             }
 3736              	 .loc 1 3726 0 discriminator 4
 3737 0026 0022     	 movs r2,#0
 3738 0028 A261     	 str r2,[r4,#24]
3733:../FreeRTOS/Source/tasks.c ****         {
 3739              	 .loc 1 3733 0 discriminator 4
 3740 002a 052B     	 cmp r3,#5
 3741 002c 12D0     	 beq .L315
3735:../FreeRTOS/Source/tasks.c ****             {
 3742              	 .loc 1 3735 0
 3743 002e 154A     	 ldr r2,.L326
 3744 0030 1268     	 ldr r2,[r2]
 3745 0032 9542     	 cmp r5,r2
 3746 0034 02D1     	 bne .L316
3737:../FreeRTOS/Source/tasks.c ****             }
 3747              	 .loc 1 3737 0
 3748 0036 0023     	 movs r3,#0
 3749              	.LVL343:
 3750 0038 2373     	 strb r3,[r4,#12]
 3751 003a 0FE0     	 b .L317
 3752              	.LVL344:
 3753              	.L316:
3741:../FreeRTOS/Source/tasks.c **** 
 3754              	 .loc 1 3741 0
 3755 003c 2373     	 strb r3,[r4,#12]
3748:../FreeRTOS/Source/tasks.c ****                         {
 3756              	 .loc 1 3748 0
 3757 003e 032B     	 cmp r3,#3
 3758 0040 0CD1     	 bne .L317
3750:../FreeRTOS/Source/tasks.c ****                             {
 3759              	 .loc 1 3750 0
 3760 0042 FFF7FEFF 	 bl vTaskSuspendAll
 3761              	.LVL345:
3752:../FreeRTOS/Source/tasks.c ****                                 {
 3762              	 .loc 1 3752 0
 3763 0046 AB6A     	 ldr r3,[r5,#40]
 3764 0048 0BB1     	 cbz r3,.L318
3754:../FreeRTOS/Source/tasks.c ****                                 }
 3765              	 .loc 1 3754 0
 3766 004a 0223     	 movs r3,#2
 3767 004c 2373     	 strb r3,[r4,#12]
 3768              	.L318:
3757:../FreeRTOS/Source/tasks.c ****                         }
 3769              	 .loc 1 3757 0
 3770 004e FFF7FEFF 	 bl xTaskResumeAll
 3771              	.LVL346:
 3772 0052 03E0     	 b .L317
 3773              	.LVL347:
 3774              	.L315:
3765:../FreeRTOS/Source/tasks.c ****         }
 3775              	 .loc 1 3765 0
 3776 0054 2846     	 mov r0,r5
 3777 0056 FFF7FEFF 	 bl eTaskGetState
 3778              	.LVL348:
 3779 005a 2073     	 strb r0,[r4,#12]
 3780              	.L317:
3770:../FreeRTOS/Source/tasks.c ****         {
 3781              	 .loc 1 3770 0
 3782 005c 76B1     	 cbz r6,.L319
3778:../FreeRTOS/Source/tasks.c ****                 }
 3783              	 .loc 1 3778 0
 3784 005e 286B     	 ldr r0,[r5,#48]
 3785              	.LVL349:
 3786              	.LBB242:
 3787              	.LBB243:
3832:../FreeRTOS/Source/tasks.c ****         {
 3788              	 .loc 1 3832 0
 3789 0060 0378     	 ldrb r3,[r0]
 3790 0062 A52B     	 cmp r3,#165
 3791 0064 06D1     	 bne .L323
 3792 0066 431C     	 adds r3,r0,#1
 3793              	.LVL350:
 3794              	.L321:
 3795 0068 191A     	 subs r1,r3,r0
 3796              	.LVL351:
 3797 006a 13F8012B 	 ldrb r2,[r3],#1
 3798              	.LVL352:
 3799 006e A52A     	 cmp r2,#165
 3800 0070 FAD0     	 beq .L321
 3801 0072 00E0     	 b .L320
 3802              	.LVL353:
 3803              	.L323:
3830:../FreeRTOS/Source/tasks.c **** 
 3804              	 .loc 1 3830 0
 3805 0074 0021     	 movs r1,#0
 3806              	.LVL354:
 3807              	.L320:
3838:../FreeRTOS/Source/tasks.c **** 
 3808              	 .loc 1 3838 0
 3809 0076 8908     	 lsrs r1,r1,#2
 3810              	.LVL355:
3840:../FreeRTOS/Source/tasks.c ****     }
 3811              	 .loc 1 3840 0
 3812 0078 2184     	 strh r1,[r4,#32]
 3813              	.LBE243:
 3814              	.LBE242:
 3815 007a 70BD     	 pop {r4,r5,r6,pc}
 3816              	.LVL356:
 3817              	.L319:
3784:../FreeRTOS/Source/tasks.c ****         }
 3818              	 .loc 1 3784 0
 3819 007c 0023     	 movs r3,#0
 3820 007e 2384     	 strh r3,[r4,#32]
 3821 0080 70BD     	 pop {r4,r5,r6,pc}
 3822              	.LVL357:
 3823              	.L327:
 3824 0082 00BF     	 .align 2
 3825              	.L326:
 3826 0084 00000000 	 .word .LANCHOR5
 3827              	 .cfi_endproc
 3828              	.LFE45:
 3830              	 .section .text.prvListTasksWithinSingleList,"ax",%progbits
 3831              	 .align 2
 3832              	 .thumb
 3833              	 .thumb_func
 3835              	prvListTasksWithinSingleList:
 3836              	.LFB46:
3796:../FreeRTOS/Source/tasks.c ****         configLIST_VOLATILE TCB_t * pxNextTCB, * pxFirstTCB;
 3837              	 .loc 1 3796 0
 3838              	 .cfi_startproc
 3839              	 
 3840              	 
 3841              	.LVL358:
 3842 0000 2DE9F84F 	 push {r3,r4,r5,r6,r7,r8,r9,r10,fp,lr}
 3843              	.LCFI30:
 3844              	 .cfi_def_cfa_offset 40
 3845              	 .cfi_offset 3,-40
 3846              	 .cfi_offset 4,-36
 3847              	 .cfi_offset 5,-32
 3848              	 .cfi_offset 6,-28
 3849              	 .cfi_offset 7,-24
 3850              	 .cfi_offset 8,-20
 3851              	 .cfi_offset 9,-16
 3852              	 .cfi_offset 10,-12
 3853              	 .cfi_offset 11,-8
 3854              	 .cfi_offset 14,-4
 3855              	.LVL359:
3800:../FreeRTOS/Source/tasks.c ****         {
 3856              	 .loc 1 3800 0
 3857 0004 0B68     	 ldr r3,[r1]
 3858 0006 2BB3     	 cbz r3,.L333
 3859              	.LVL360:
 3860              	.LBB244:
3802:../FreeRTOS/Source/tasks.c **** 
 3861              	 .loc 1 3802 0
 3862 0008 4B68     	 ldr r3,[r1,#4]
 3863 000a 5B68     	 ldr r3,[r3,#4]
 3864 000c 4B60     	 str r3,[r1,#4]
 3865 000e 01F10809 	 add r9,r1,#8
 3866 0012 4B45     	 cmp r3,r9
 3867 0014 04BF     	 itt eq
 3868 0016 5B68     	 ldreq r3,[r3,#4]
 3869 0018 4B60     	 streq r3,[r1,#4]
 3870 001a 9046     	 mov r8,r2
 3871 001c 0C46     	 mov r4,r1
 3872 001e 4B68     	 ldr r3,[r1,#4]
 3873 0020 D3F80CB0 	 ldr fp,[r3,#12]
 3874              	.LVL361:
 3875 0024 0546     	 mov r5,r0
 3876              	.LBE244:
3798:../FreeRTOS/Source/tasks.c **** 
 3877              	 .loc 1 3798 0
 3878 0026 0027     	 movs r7,#0
3811:../FreeRTOS/Source/tasks.c ****                 uxTask++;
 3879              	 .loc 1 3811 0
 3880 0028 4FF0010A 	 mov r10,#1
 3881              	.LVL362:
 3882              	.L332:
 3883              	.LBB245:
3810:../FreeRTOS/Source/tasks.c ****                 vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE,
 3884              	 .loc 1 3810 0
 3885 002c 6368     	 ldr r3,[r4,#4]
 3886 002e 5B68     	 ldr r3,[r3,#4]
 3887 0030 6360     	 str r3,[r4,#4]
 3888 0032 9945     	 cmp r9,r3
 3889 0034 04BF     	 itt eq
 3890 0036 E368     	 ldreq r3,[r4,#12]
 3891 0038 6360     	 streq r3,[r4,#4]
 3892 003a 6368     	 ldr r3,[r4,#4]
 3893 003c DE68     	 ldr r6,[r3,#12]
 3894              	.LVL363:
 3895              	.LBE245:
3811:../FreeRTOS/Source/tasks.c ****                 uxTask++;
 3896              	 .loc 1 3811 0
 3897 003e 3046     	 mov r0,r6
 3898 0040 2946     	 mov r1,r5
 3899 0042 5246     	 mov r2,r10
 3900 0044 4346     	 mov r3,r8
 3901 0046 FFF7FEFF 	 bl vTaskGetInfo
 3902              	.LVL364:
3812:../FreeRTOS/Source/tasks.c ****             } while( pxNextTCB != pxFirstTCB );
 3903              	 .loc 1 3812 0
 3904 004a 0137     	 adds r7,r7,#1
 3905              	.LVL365:
 3906 004c 2435     	 adds r5,r5,#36
3813:../FreeRTOS/Source/tasks.c ****         }
 3907              	 .loc 1 3813 0
 3908 004e 5E45     	 cmp r6,fp
 3909 0050 ECD1     	 bne .L332
 3910 0052 00E0     	 b .L329
 3911              	.LVL366:
 3912              	.L333:
3798:../FreeRTOS/Source/tasks.c **** 
 3913              	 .loc 1 3798 0
 3914 0054 0027     	 movs r7,#0
 3915              	.LVL367:
 3916              	.L329:
3821:../FreeRTOS/Source/tasks.c **** 
 3917              	 .loc 1 3821 0
 3918 0056 3846     	 mov r0,r7
 3919 0058 BDE8F88F 	 pop {r3,r4,r5,r6,r7,r8,r9,r10,fp,pc}
 3920              	 .cfi_endproc
 3921              	.LFE46:
 3923              	 .section .text.uxTaskGetSystemState,"ax",%progbits
 3924              	 .align 2
 3925              	 .global uxTaskGetSystemState
 3926              	 .thumb
 3927              	 .thumb_func
 3929              	uxTaskGetSystemState:
 3930              	.LFB27:
2509:../FreeRTOS/Source/tasks.c ****         UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
 3931              	 .loc 1 2509 0
 3932              	 .cfi_startproc
 3933              	 
 3934              	 
 3935              	.LVL368:
 3936 0000 2DE9F843 	 push {r3,r4,r5,r6,r7,r8,r9,lr}
 3937              	.LCFI31:
 3938              	 .cfi_def_cfa_offset 32
 3939              	 .cfi_offset 3,-32
 3940              	 .cfi_offset 4,-28
 3941              	 .cfi_offset 5,-24
 3942              	 .cfi_offset 6,-20
 3943              	 .cfi_offset 7,-16
 3944              	 .cfi_offset 8,-12
 3945              	 .cfi_offset 9,-8
 3946              	 .cfi_offset 14,-4
 3947 0004 0746     	 mov r7,r0
 3948 0006 0C46     	 mov r4,r1
 3949 0008 1646     	 mov r6,r2
 3950              	.LVL369:
2512:../FreeRTOS/Source/tasks.c ****         {
 3951              	 .loc 1 2512 0
 3952 000a FFF7FEFF 	 bl vTaskSuspendAll
 3953              	.LVL370:
2515:../FreeRTOS/Source/tasks.c ****             {
 3954              	 .loc 1 2515 0
 3955 000e 244B     	 ldr r3,.L342
 3956 0010 1B68     	 ldr r3,[r3]
 3957 0012 A342     	 cmp r3,r4
 3958 0014 3DD8     	 bhi .L339
 3959 0016 234B     	 ldr r3,.L342+4
 3960 0018 03F1B405 	 add r5,r3,#180
 3961 001c A3F11408 	 sub r8,r3,#20
 3962 0020 0024     	 movs r4,#0
 3963              	.LVL371:
2522:../FreeRTOS/Source/tasks.c ****                 } while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception
 3964              	 .loc 1 2522 0
 3965 0022 4FF00109 	 mov r9,#1
 3966              	.LVL372:
 3967              	.L338:
2522:../FreeRTOS/Source/tasks.c ****                 } while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception
 3968              	 .loc 1 2522 0 is_stmt 0 discriminator 1
 3969 0026 04EBC400 	 add r0,r4,r4,lsl#3
 3970 002a 07EB8000 	 add r0,r7,r0,lsl#2
 3971 002e 2946     	 mov r1,r5
 3972 0030 4A46     	 mov r2,r9
 3973 0032 FFF7FEFF 	 bl prvListTasksWithinSingleList
 3974              	.LVL373:
 3975 0036 0444     	 add r4,r4,r0
 3976              	.LVL374:
 3977 0038 143D     	 subs r5,r5,#20
2523:../FreeRTOS/Source/tasks.c **** 
 3978              	 .loc 1 2523 0 is_stmt 1 discriminator 1
 3979 003a 4545     	 cmp r5,r8
 3980 003c F3D1     	 bne .L338
2527:../FreeRTOS/Source/tasks.c ****                 uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t 
 3981              	 .loc 1 2527 0
 3982 003e 1A4B     	 ldr r3,.L342+8
 3983 0040 1968     	 ldr r1,[r3]
 3984 0042 04EBC400 	 add r0,r4,r4,lsl#3
 3985 0046 07EB8000 	 add r0,r7,r0,lsl#2
 3986 004a 0222     	 movs r2,#2
 3987 004c FFF7FEFF 	 bl prvListTasksWithinSingleList
 3988              	.LVL375:
 3989 0050 0444     	 add r4,r4,r0
 3990              	.LVL376:
2528:../FreeRTOS/Source/tasks.c **** 
 3991              	 .loc 1 2528 0
 3992 0052 164B     	 ldr r3,.L342+12
 3993 0054 1968     	 ldr r1,[r3]
 3994 0056 04EBC400 	 add r0,r4,r4,lsl#3
 3995 005a 07EB8000 	 add r0,r7,r0,lsl#2
 3996 005e 0222     	 movs r2,#2
 3997 0060 FFF7FEFF 	 bl prvListTasksWithinSingleList
 3998              	.LVL377:
 3999 0064 0444     	 add r4,r4,r0
 4000              	.LVL378:
2534:../FreeRTOS/Source/tasks.c ****                     }
 4001              	 .loc 1 2534 0
 4002 0066 04EBC400 	 add r0,r4,r4,lsl#3
 4003 006a 07EB8000 	 add r0,r7,r0,lsl#2
 4004 006e 1049     	 ldr r1,.L342+16
 4005 0070 0422     	 movs r2,#4
 4006 0072 FFF7FEFF 	 bl prvListTasksWithinSingleList
 4007              	.LVL379:
 4008 0076 0444     	 add r4,r4,r0
 4009              	.LVL380:
2542:../FreeRTOS/Source/tasks.c ****                     }
 4010              	 .loc 1 2542 0
 4011 0078 04EBC400 	 add r0,r4,r4,lsl#3
 4012 007c 07EB8000 	 add r0,r7,r0,lsl#2
 4013 0080 0C49     	 ldr r1,.L342+20
 4014 0082 0322     	 movs r2,#3
 4015 0084 FFF7FEFF 	 bl prvListTasksWithinSingleList
 4016              	.LVL381:
 4017 0088 0444     	 add r4,r4,r0
 4018              	.LVL382:
2559:../FreeRTOS/Source/tasks.c ****                         {
 4019              	 .loc 1 2559 0
 4020 008a 1EB1     	 cbz r6,.L337
2561:../FreeRTOS/Source/tasks.c ****                         }
 4021              	 .loc 1 2561 0
 4022 008c 0023     	 movs r3,#0
 4023 008e 3360     	 str r3,[r6]
 4024 0090 00E0     	 b .L337
 4025              	.LVL383:
 4026              	.L339:
2510:../FreeRTOS/Source/tasks.c **** 
 4027              	 .loc 1 2510 0
 4028 0092 0024     	 movs r4,#0
 4029              	.LVL384:
 4030              	.L337:
2571:../FreeRTOS/Source/tasks.c **** 
 4031              	 .loc 1 2571 0
 4032 0094 FFF7FEFF 	 bl xTaskResumeAll
 4033              	.LVL385:
2574:../FreeRTOS/Source/tasks.c **** 
 4034              	 .loc 1 2574 0
 4035 0098 2046     	 mov r0,r4
 4036 009a BDE8F883 	 pop {r3,r4,r5,r6,r7,r8,r9,pc}
 4037              	.LVL386:
 4038              	.L343:
 4039 009e 00BF     	 .align 2
 4040              	.L342:
 4041 00a0 00000000 	 .word .LANCHOR10
 4042 00a4 00000000 	 .word .LANCHOR11
 4043 00a8 00000000 	 .word .LANCHOR2
 4044 00ac 00000000 	 .word .LANCHOR7
 4045 00b0 00000000 	 .word .LANCHOR9
 4046 00b4 00000000 	 .word .LANCHOR0
 4047              	 .cfi_endproc
 4048              	.LFE27:
 4050              	 .section .text.xTaskGetCurrentTaskHandle,"ax",%progbits
 4051              	 .align 2
 4052              	 .global xTaskGetCurrentTaskHandle
 4053              	 .thumb
 4054              	 .thumb_func
 4056              	xTaskGetCurrentTaskHandle:
 4057              	.LFB50:
3996:../FreeRTOS/Source/tasks.c ****         TaskHandle_t xReturn;
 4058              	 .loc 1 3996 0
 4059              	 .cfi_startproc
 4060              	 
 4061              	 
 4062              	 
4002:../FreeRTOS/Source/tasks.c **** 
 4063              	 .loc 1 4002 0
 4064 0000 014B     	 ldr r3,.L345
 4065 0002 1868     	 ldr r0,[r3]
 4066              	.LVL387:
4005:../FreeRTOS/Source/tasks.c **** 
 4067              	 .loc 1 4005 0
 4068 0004 7047     	 bx lr
 4069              	.L346:
 4070 0006 00BF     	 .align 2
 4071              	.L345:
 4072 0008 00000000 	 .word .LANCHOR5
 4073              	 .cfi_endproc
 4074              	.LFE50:
 4076              	 .section .text.xTaskGetSchedulerState,"ax",%progbits
 4077              	 .align 2
 4078              	 .global xTaskGetSchedulerState
 4079              	 .thumb
 4080              	 .thumb_func
 4082              	xTaskGetSchedulerState:
 4083              	.LFB51:
4013:../FreeRTOS/Source/tasks.c ****         BaseType_t xReturn;
 4084              	 .loc 1 4013 0
 4085              	 .cfi_startproc
 4086              	 
 4087              	 
 4088              	 
4016:../FreeRTOS/Source/tasks.c ****         {
 4089              	 .loc 1 4016 0
 4090 0000 054B     	 ldr r3,.L351
 4091 0002 1B68     	 ldr r3,[r3]
 4092 0004 33B1     	 cbz r3,.L349
4022:../FreeRTOS/Source/tasks.c ****             {
 4093              	 .loc 1 4022 0
 4094 0006 054B     	 ldr r3,.L351+4
 4095 0008 1B68     	 ldr r3,[r3]
4028:../FreeRTOS/Source/tasks.c ****             }
 4096              	 .loc 1 4028 0
 4097 000a 002B     	 cmp r3,#0
 4098 000c 0CBF     	 ite eq
 4099 000e 0220     	 moveq r0,#2
 4100 0010 0020     	 movne r0,#0
 4101 0012 7047     	 bx lr
 4102              	.L349:
4018:../FreeRTOS/Source/tasks.c ****         }
 4103              	 .loc 1 4018 0
 4104 0014 0120     	 movs r0,#1
 4105              	.LVL388:
4033:../FreeRTOS/Source/tasks.c **** 
 4106              	 .loc 1 4033 0
 4107 0016 7047     	 bx lr
 4108              	.L352:
 4109              	 .align 2
 4110              	.L351:
 4111 0018 00000000 	 .word .LANCHOR14
 4112 001c 00000000 	 .word .LANCHOR16
 4113              	 .cfi_endproc
 4114              	.LFE51:
 4116              	 .section .text.xTaskPriorityInherit,"ax",%progbits
 4117              	 .align 2
 4118              	 .global xTaskPriorityInherit
 4119              	 .thumb
 4120              	 .thumb_func
 4122              	xTaskPriorityInherit:
 4123              	.LFB52:
4041:../FreeRTOS/Source/tasks.c ****         TCB_t * const pxMutexHolderTCB = pxMutexHolder;
 4124              	 .loc 1 4041 0
 4125              	 .cfi_startproc
 4126              	 
 4127              	 
 4128              	.LVL389:
4048:../FreeRTOS/Source/tasks.c ****         {
 4129              	 .loc 1 4048 0
 4130 0000 0028     	 cmp r0,#0
 4131 0002 4AD0     	 beq .L359
4041:../FreeRTOS/Source/tasks.c ****         TCB_t * const pxMutexHolderTCB = pxMutexHolder;
 4132              	 .loc 1 4041 0
 4133 0004 38B5     	 push {r3,r4,r5,lr}
 4134              	.LCFI32:
 4135              	 .cfi_def_cfa_offset 16
 4136              	 .cfi_offset 3,-16
 4137              	 .cfi_offset 4,-12
 4138              	 .cfi_offset 5,-8
 4139              	 .cfi_offset 14,-4
 4140 0006 0346     	 mov r3,r0
4053:../FreeRTOS/Source/tasks.c ****             {
 4141              	 .loc 1 4053 0
 4142 0008 C26A     	 ldr r2,[r0,#44]
 4143 000a 2549     	 ldr r1,.L362
 4144 000c 0968     	 ldr r1,[r1]
 4145 000e C96A     	 ldr r1,[r1,#44]
 4146 0010 8A42     	 cmp r2,r1
 4147 0012 39D2     	 bcs .L355
4058:../FreeRTOS/Source/tasks.c ****                 {
 4148              	 .loc 1 4058 0
 4149 0014 8169     	 ldr r1,[r0,#24]
 4150 0016 0029     	 cmp r1,#0
 4151 0018 05DB     	 blt .L356
4060:../FreeRTOS/Source/tasks.c ****                 }
 4152              	 .loc 1 4060 0
 4153 001a 2149     	 ldr r1,.L362
 4154 001c 0968     	 ldr r1,[r1]
 4155 001e C96A     	 ldr r1,[r1,#44]
 4156 0020 C1F10A01 	 rsb r1,r1,#10
 4157 0024 8161     	 str r1,[r0,#24]
 4158              	.L356:
4069:../FreeRTOS/Source/tasks.c ****                 {
 4159              	 .loc 1 4069 0
 4160 0026 02EB8202 	 add r2,r2,r2,lsl#2
 4161 002a 1E49     	 ldr r1,.L362+4
 4162 002c 01EB8202 	 add r2,r1,r2,lsl#2
 4163 0030 5969     	 ldr r1,[r3,#20]
 4164 0032 9142     	 cmp r1,r2
 4165 0034 22D1     	 bne .L357
 4166 0036 1C46     	 mov r4,r3
4071:../FreeRTOS/Source/tasks.c ****                     {
 4167              	 .loc 1 4071 0
 4168 0038 1D1D     	 adds r5,r3,#4
 4169 003a 2846     	 mov r0,r5
 4170              	.LVL390:
 4171 003c FFF7FEFF 	 bl uxListRemove
 4172              	.LVL391:
 4173 0040 38B9     	 cbnz r0,.L358
4076:../FreeRTOS/Source/tasks.c ****                     }
 4174              	 .loc 1 4076 0
 4175 0042 1949     	 ldr r1,.L362+8
 4176 0044 0A68     	 ldr r2,[r1]
 4177 0046 E06A     	 ldr r0,[r4,#44]
 4178 0048 0123     	 movs r3,#1
 4179 004a 8340     	 lsls r3,r3,r0
 4180 004c 22EA0303 	 bic r3,r2,r3
 4181 0050 0B60     	 str r3,[r1]
 4182              	.L358:
4084:../FreeRTOS/Source/tasks.c ****                     prvAddTaskToReadyList( pxMutexHolderTCB );
 4183              	 .loc 1 4084 0
 4184 0052 134B     	 ldr r3,.L362
 4185 0054 1B68     	 ldr r3,[r3]
 4186 0056 D86A     	 ldr r0,[r3,#44]
 4187 0058 E062     	 str r0,[r4,#44]
4085:../FreeRTOS/Source/tasks.c ****                 }
 4188              	 .loc 1 4085 0
 4189 005a 134A     	 ldr r2,.L362+8
 4190 005c 1368     	 ldr r3,[r2]
 4191 005e 0124     	 movs r4,#1
 4192              	.LVL392:
 4193 0060 04FA00F1 	 lsl r1,r4,r0
 4194 0064 0B43     	 orrs r3,r3,r1
 4195 0066 1360     	 str r3,[r2]
 4196 0068 00EB8000 	 add r0,r0,r0,lsl#2
 4197 006c 0D4B     	 ldr r3,.L362+4
 4198 006e 03EB8000 	 add r0,r3,r0,lsl#2
 4199 0072 2946     	 mov r1,r5
 4200 0074 FFF7FEFF 	 bl vListInsertEnd
 4201              	.LVL393:
4096:../FreeRTOS/Source/tasks.c ****             }
 4202              	 .loc 1 4096 0
 4203 0078 2046     	 mov r0,r4
 4204 007a 38BD     	 pop {r3,r4,r5,pc}
 4205              	.LVL394:
 4206              	.L357:
4090:../FreeRTOS/Source/tasks.c ****                 }
 4207              	 .loc 1 4090 0
 4208 007c 084A     	 ldr r2,.L362
 4209 007e 1268     	 ldr r2,[r2]
 4210 0080 D26A     	 ldr r2,[r2,#44]
 4211 0082 DA62     	 str r2,[r3,#44]
4096:../FreeRTOS/Source/tasks.c ****             }
 4212              	 .loc 1 4096 0
 4213 0084 0120     	 movs r0,#1
 4214              	.LVL395:
 4215 0086 38BD     	 pop {r3,r4,r5,pc}
 4216              	.LVL396:
 4217              	.L355:
4100:../FreeRTOS/Source/tasks.c ****                 {
 4218              	 .loc 1 4100 0
 4219 0088 054A     	 ldr r2,.L362
 4220 008a 1268     	 ldr r2,[r2]
 4221 008c 036D     	 ldr r3,[r0,#80]
 4222 008e D06A     	 ldr r0,[r2,#44]
 4223              	.LVL397:
 4224 0090 8342     	 cmp r3,r0
 4225 0092 2CBF     	 ite cs
 4226 0094 0020     	 movcs r0,#0
 4227 0096 0120     	 movcc r0,#1
 4228 0098 38BD     	 pop {r3,r4,r5,pc}
 4229              	.LVL398:
 4230              	.L359:
 4231              	.LCFI33:
 4232              	 .cfi_def_cfa_offset 0
 4233              	 .cfi_restore 3
 4234              	 .cfi_restore 4
 4235              	 .cfi_restore 5
 4236              	 .cfi_restore 14
4043:../FreeRTOS/Source/tasks.c **** 
 4237              	 .loc 1 4043 0
 4238 009a 0020     	 movs r0,#0
 4239              	.LVL399:
 4240 009c 7047     	 bx lr
 4241              	.L363:
 4242 009e 00BF     	 .align 2
 4243              	.L362:
 4244 00a0 00000000 	 .word .LANCHOR5
 4245 00a4 00000000 	 .word .LANCHOR11
 4246 00a8 00000000 	 .word .LANCHOR6
 4247              	 .cfi_endproc
 4248              	.LFE52:
 4250              	 .section .text.xTaskPriorityDisinherit,"ax",%progbits
 4251              	 .align 2
 4252              	 .global xTaskPriorityDisinherit
 4253              	 .thumb
 4254              	 .thumb_func
 4256              	xTaskPriorityDisinherit:
 4257              	.LFB53:
4131:../FreeRTOS/Source/tasks.c ****         TCB_t * const pxTCB = pxMutexHolder;
 4258              	 .loc 1 4131 0
 4259              	 .cfi_startproc
 4260              	 
 4261              	 
 4262              	.LVL400:
4135:../FreeRTOS/Source/tasks.c ****         {
 4263              	 .loc 1 4135 0
 4264 0000 0028     	 cmp r0,#0
 4265 0002 44D0     	 beq .L371
4131:../FreeRTOS/Source/tasks.c ****         TCB_t * const pxTCB = pxMutexHolder;
 4266              	 .loc 1 4131 0
 4267 0004 38B5     	 push {r3,r4,r5,lr}
 4268              	.LCFI34:
 4269              	 .cfi_def_cfa_offset 16
 4270              	 .cfi_offset 3,-16
 4271              	 .cfi_offset 4,-12
 4272              	 .cfi_offset 5,-8
 4273              	 .cfi_offset 14,-4
 4274 0006 0346     	 mov r3,r0
4141:../FreeRTOS/Source/tasks.c ****             configASSERT( pxTCB->uxMutexesHeld );
 4275              	 .loc 1 4141 0
 4276 0008 244A     	 ldr r2,.L375
 4277 000a 1268     	 ldr r2,[r2]
 4278 000c 9042     	 cmp r0,r2
 4279 000e 08D0     	 beq .L366
 4280              	.LBB246:
 4281              	.LBB247:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 4282              	 .loc 2 197 0
 4283              	
 4284 0010 4FF01403 	 mov r3,#20
 4285 0014 83F31188 	 msr basepri,r3
 4286 0018 BFF36F8F 	 isb 
 4287 001c BFF34F8F 	 dsb 
 4288              	
 4289              	
 4290              	.LVL401:
 4291              	 .thumb
 4292              	.L367:
 4293              	.LBE247:
 4294              	.LBE246:
4141:../FreeRTOS/Source/tasks.c ****             configASSERT( pxTCB->uxMutexesHeld );
 4295              	 .loc 1 4141 0 discriminator 1
 4296 0020 FEE7     	 b .L367
 4297              	.L366:
4142:../FreeRTOS/Source/tasks.c ****             ( pxTCB->uxMutexesHeld )--;
 4298              	 .loc 1 4142 0
 4299 0022 426D     	 ldr r2,[r0,#84]
 4300 0024 42B9     	 cbnz r2,.L368
 4301              	.LBB248:
 4302              	.LBB249:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 4303              	 .loc 2 197 0
 4304              	
 4305 0026 4FF01403 	 mov r3,#20
 4306 002a 83F31188 	 msr basepri,r3
 4307 002e BFF36F8F 	 isb 
 4308 0032 BFF34F8F 	 dsb 
 4309              	
 4310              	
 4311              	.LVL402:
 4312              	 .thumb
 4313              	.L369:
 4314              	.LBE249:
 4315              	.LBE248:
4142:../FreeRTOS/Source/tasks.c ****             ( pxTCB->uxMutexesHeld )--;
 4316              	 .loc 1 4142 0 discriminator 2
 4317 0036 FEE7     	 b .L369
 4318              	.L368:
4143:../FreeRTOS/Source/tasks.c **** 
 4319              	 .loc 1 4143 0
 4320 0038 013A     	 subs r2,r2,#1
 4321 003a 4265     	 str r2,[r0,#84]
4147:../FreeRTOS/Source/tasks.c ****             {
 4322              	 .loc 1 4147 0
 4323 003c C06A     	 ldr r0,[r0,#44]
 4324              	.LVL403:
 4325 003e 196D     	 ldr r1,[r3,#80]
 4326 0040 8842     	 cmp r0,r1
 4327 0042 26D0     	 beq .L372
4150:../FreeRTOS/Source/tasks.c ****                 {
 4328              	 .loc 1 4150 0
 4329 0044 3ABB     	 cbnz r2,.L373
 4330 0046 1C46     	 mov r4,r3
4157:../FreeRTOS/Source/tasks.c ****                     {
 4331              	 .loc 1 4157 0
 4332 0048 1D1D     	 adds r5,r3,#4
 4333 004a 2846     	 mov r0,r5
 4334 004c FFF7FEFF 	 bl uxListRemove
 4335              	.LVL404:
 4336 0050 38B9     	 cbnz r0,.L370
4159:../FreeRTOS/Source/tasks.c ****                     }
 4337              	 .loc 1 4159 0
 4338 0052 1349     	 ldr r1,.L375+4
 4339 0054 0B68     	 ldr r3,[r1]
 4340 0056 E06A     	 ldr r0,[r4,#44]
 4341 0058 0122     	 movs r2,#1
 4342 005a 8240     	 lsls r2,r2,r0
 4343 005c 23EA0203 	 bic r3,r3,r2
 4344 0060 0B60     	 str r3,[r1]
 4345              	.L370:
4169:../FreeRTOS/Source/tasks.c **** 
 4346              	 .loc 1 4169 0
 4347 0062 206D     	 ldr r0,[r4,#80]
 4348 0064 E062     	 str r0,[r4,#44]
4174:../FreeRTOS/Source/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
 4349              	 .loc 1 4174 0
 4350 0066 C0F10A03 	 rsb r3,r0,#10
 4351 006a A361     	 str r3,[r4,#24]
4175:../FreeRTOS/Source/tasks.c **** 
 4352              	 .loc 1 4175 0
 4353 006c 0C4A     	 ldr r2,.L375+4
 4354 006e 1368     	 ldr r3,[r2]
 4355 0070 0124     	 movs r4,#1
 4356              	.LVL405:
 4357 0072 04FA00F1 	 lsl r1,r4,r0
 4358 0076 0B43     	 orrs r3,r3,r1
 4359 0078 1360     	 str r3,[r2]
 4360 007a 00EB8000 	 add r0,r0,r0,lsl#2
 4361 007e 094B     	 ldr r3,.L375+8
 4362 0080 03EB8000 	 add r0,r3,r0,lsl#2
 4363 0084 2946     	 mov r1,r5
 4364 0086 FFF7FEFF 	 bl vListInsertEnd
 4365              	.LVL406:
4185:../FreeRTOS/Source/tasks.c ****                 }
 4366              	 .loc 1 4185 0
 4367 008a 2046     	 mov r0,r4
 4368 008c 38BD     	 pop {r3,r4,r5,pc}
 4369              	.LVL407:
 4370              	.L371:
 4371              	.LCFI35:
 4372              	 .cfi_def_cfa_offset 0
 4373              	 .cfi_restore 3
 4374              	 .cfi_restore 4
 4375              	 .cfi_restore 5
 4376              	 .cfi_restore 14
4133:../FreeRTOS/Source/tasks.c **** 
 4377              	 .loc 1 4133 0
 4378 008e 0020     	 movs r0,#0
 4379              	.LVL408:
4203:../FreeRTOS/Source/tasks.c **** 
 4380              	 .loc 1 4203 0
 4381 0090 7047     	 bx lr
 4382              	.LVL409:
 4383              	.L372:
 4384              	.LCFI36:
 4385              	 .cfi_def_cfa_offset 16
 4386              	 .cfi_offset 3,-16
 4387              	 .cfi_offset 4,-12
 4388              	 .cfi_offset 5,-8
 4389              	 .cfi_offset 14,-4
4133:../FreeRTOS/Source/tasks.c **** 
 4390              	 .loc 1 4133 0
 4391 0092 0020     	 movs r0,#0
 4392 0094 38BD     	 pop {r3,r4,r5,pc}
 4393              	.LVL410:
 4394              	.L373:
 4395 0096 0020     	 movs r0,#0
 4396              	.LVL411:
4203:../FreeRTOS/Source/tasks.c **** 
 4397              	 .loc 1 4203 0
 4398 0098 38BD     	 pop {r3,r4,r5,pc}
 4399              	.LVL412:
 4400              	.L376:
 4401 009a 00BF     	 .align 2
 4402              	.L375:
 4403 009c 00000000 	 .word .LANCHOR5
 4404 00a0 00000000 	 .word .LANCHOR6
 4405 00a4 00000000 	 .word .LANCHOR11
 4406              	 .cfi_endproc
 4407              	.LFE53:
 4409              	 .section .text.vTaskPriorityDisinheritAfterTimeout,"ax",%progbits
 4410              	 .align 2
 4411              	 .global vTaskPriorityDisinheritAfterTimeout
 4412              	 .thumb
 4413              	 .thumb_func
 4415              	vTaskPriorityDisinheritAfterTimeout:
 4416              	.LFB54:
4212:../FreeRTOS/Source/tasks.c ****         TCB_t * const pxTCB = pxMutexHolder;
 4417              	 .loc 1 4212 0
 4418              	 .cfi_startproc
 4419              	 
 4420              	 
 4421              	.LVL413:
4217:../FreeRTOS/Source/tasks.c ****         {
 4422              	 .loc 1 4217 0
 4423 0000 0028     	 cmp r0,#0
 4424 0002 4FD0     	 beq .L386
4212:../FreeRTOS/Source/tasks.c ****         TCB_t * const pxTCB = pxMutexHolder;
 4425              	 .loc 1 4212 0
 4426 0004 38B5     	 push {r3,r4,r5,lr}
 4427              	.LCFI37:
 4428              	 .cfi_def_cfa_offset 16
 4429              	 .cfi_offset 3,-16
 4430              	 .cfi_offset 4,-12
 4431              	 .cfi_offset 5,-8
 4432              	 .cfi_offset 14,-4
 4433 0006 0346     	 mov r3,r0
4221:../FreeRTOS/Source/tasks.c **** 
 4434              	 .loc 1 4221 0
 4435 0008 406D     	 ldr r0,[r0,#84]
 4436              	.LVL414:
 4437 000a 40B9     	 cbnz r0,.L379
 4438              	.LBB250:
 4439              	.LBB251:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 4440              	 .loc 2 197 0
 4441              	
 4442 000c 4FF01403 	 mov r3,#20
 4443 0010 83F31188 	 msr basepri,r3
 4444 0014 BFF36F8F 	 isb 
 4445 0018 BFF34F8F 	 dsb 
 4446              	
 4447              	
 4448              	.LVL415:
 4449              	 .thumb
 4450              	.L380:
 4451              	.LBE251:
 4452              	.LBE250:
4221:../FreeRTOS/Source/tasks.c **** 
 4453              	 .loc 1 4221 0 discriminator 1
 4454 001c FEE7     	 b .L380
 4455              	.LVL416:
 4456              	.L379:
4227:../FreeRTOS/Source/tasks.c ****             {
 4457              	 .loc 1 4227 0
 4458 001e 1A6D     	 ldr r2,[r3,#80]
 4459 0020 8A42     	 cmp r2,r1
 4460 0022 38BF     	 it cc
 4461 0024 0A46     	 movcc r2,r1
 4462              	.LVL417:
4237:../FreeRTOS/Source/tasks.c ****             {
 4463              	 .loc 1 4237 0
 4464 0026 D96A     	 ldr r1,[r3,#44]
 4465              	.LVL418:
 4466 0028 9142     	 cmp r1,r2
 4467 002a 3AD0     	 beq .L377
4243:../FreeRTOS/Source/tasks.c ****                 {
 4468              	 .loc 1 4243 0
 4469 002c 0128     	 cmp r0,#1
 4470 002e 38D1     	 bne .L377
4248:../FreeRTOS/Source/tasks.c **** 
 4471              	 .loc 1 4248 0
 4472 0030 1D48     	 ldr r0,.L387
 4473 0032 0068     	 ldr r0,[r0]
 4474 0034 8342     	 cmp r3,r0
 4475 0036 08D1     	 bne .L381
 4476              	.LBB252:
 4477              	.LBB253:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 4478              	 .loc 2 197 0
 4479              	
 4480 0038 4FF01403 	 mov r3,#20
 4481 003c 83F31188 	 msr basepri,r3
 4482 0040 BFF36F8F 	 isb 
 4483 0044 BFF34F8F 	 dsb 
 4484              	
 4485              	
 4486              	.LVL419:
 4487              	 .thumb
 4488              	.L382:
 4489              	.LBE253:
 4490              	.LBE252:
4248:../FreeRTOS/Source/tasks.c **** 
 4491              	 .loc 1 4248 0 discriminator 2
 4492 0048 FEE7     	 b .L382
 4493              	.LVL420:
 4494              	.L381:
4255:../FreeRTOS/Source/tasks.c **** 
 4495              	 .loc 1 4255 0
 4496 004a DA62     	 str r2,[r3,#44]
4259:../FreeRTOS/Source/tasks.c ****                     {
 4497              	 .loc 1 4259 0
 4498 004c 9869     	 ldr r0,[r3,#24]
 4499 004e 0028     	 cmp r0,#0
4261:../FreeRTOS/Source/tasks.c ****                     }
 4500              	 .loc 1 4261 0
 4501 0050 A4BF     	 itt ge
 4502 0052 C2F10A02 	 rsbge r2,r2,#10
 4503              	.LVL421:
 4504 0056 9A61     	 strge r2,[r3,#24]
4274:../FreeRTOS/Source/tasks.c ****                     {
 4505              	 .loc 1 4274 0
 4506 0058 01EB8101 	 add r1,r1,r1,lsl#2
 4507              	.LVL422:
 4508 005c 134A     	 ldr r2,.L387+4
 4509 005e 02EB8101 	 add r1,r2,r1,lsl#2
 4510 0062 5A69     	 ldr r2,[r3,#20]
 4511 0064 8A42     	 cmp r2,r1
 4512 0066 1CD1     	 bne .L377
 4513 0068 1C46     	 mov r4,r3
4276:../FreeRTOS/Source/tasks.c ****                         {
 4514              	 .loc 1 4276 0
 4515 006a 1D1D     	 adds r5,r3,#4
 4516 006c 2846     	 mov r0,r5
 4517 006e FFF7FEFF 	 bl uxListRemove
 4518              	.LVL423:
 4519 0072 38B9     	 cbnz r0,.L384
4281:../FreeRTOS/Source/tasks.c ****                         }
 4520              	 .loc 1 4281 0
 4521 0074 0E49     	 ldr r1,.L387+8
 4522 0076 0B68     	 ldr r3,[r1]
 4523 0078 E06A     	 ldr r0,[r4,#44]
 4524 007a 0122     	 movs r2,#1
 4525 007c 8240     	 lsls r2,r2,r0
 4526 007e 23EA0203 	 bic r3,r3,r2
 4527 0082 0B60     	 str r3,[r1]
 4528              	.L384:
4288:../FreeRTOS/Source/tasks.c ****                     }
 4529              	 .loc 1 4288 0
 4530 0084 E06A     	 ldr r0,[r4,#44]
 4531 0086 0A49     	 ldr r1,.L387+8
 4532 0088 0B68     	 ldr r3,[r1]
 4533 008a 0122     	 movs r2,#1
 4534 008c 8240     	 lsls r2,r2,r0
 4535 008e 1343     	 orrs r3,r3,r2
 4536 0090 0B60     	 str r3,[r1]
 4537 0092 00EB8000 	 add r0,r0,r0,lsl#2
 4538 0096 054B     	 ldr r3,.L387+4
 4539 0098 03EB8000 	 add r0,r3,r0,lsl#2
 4540 009c 2946     	 mov r1,r5
 4541 009e FFF7FEFF 	 bl vListInsertEnd
 4542              	.LVL424:
 4543              	.L377:
 4544 00a2 38BD     	 pop {r3,r4,r5,pc}
 4545              	.LVL425:
 4546              	.L386:
 4547              	.LCFI38:
 4548              	 .cfi_def_cfa_offset 0
 4549              	 .cfi_restore 3
 4550              	 .cfi_restore 4
 4551              	 .cfi_restore 5
 4552              	 .cfi_restore 14
 4553 00a4 7047     	 bx lr
 4554              	.L388:
 4555 00a6 00BF     	 .align 2
 4556              	.L387:
 4557 00a8 00000000 	 .word .LANCHOR5
 4558 00ac 00000000 	 .word .LANCHOR11
 4559 00b0 00000000 	 .word .LANCHOR6
 4560              	 .cfi_endproc
 4561              	.LFE54:
 4563              	 .section .text.uxTaskResetEventItemValue,"ax",%progbits
 4564              	 .align 2
 4565              	 .global uxTaskResetEventItemValue
 4566              	 .thumb
 4567              	 .thumb_func
 4569              	uxTaskResetEventItemValue:
 4570              	.LFB55:
4636:../FreeRTOS/Source/tasks.c ****     TickType_t uxReturn;
 4571              	 .loc 1 4636 0
 4572              	 .cfi_startproc
 4573              	 
 4574              	 
 4575              	 
4639:../FreeRTOS/Source/tasks.c **** 
 4576              	 .loc 1 4639 0
 4577 0000 044B     	 ldr r3,.L390
 4578 0002 1A68     	 ldr r2,[r3]
 4579 0004 9069     	 ldr r0,[r2,#24]
 4580              	.LVL426:
4643:../FreeRTOS/Source/tasks.c **** 
 4581              	 .loc 1 4643 0
 4582 0006 1A68     	 ldr r2,[r3]
 4583 0008 1B68     	 ldr r3,[r3]
 4584 000a DB6A     	 ldr r3,[r3,#44]
 4585 000c C3F10A03 	 rsb r3,r3,#10
 4586 0010 9361     	 str r3,[r2,#24]
4646:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 4587              	 .loc 1 4646 0
 4588 0012 7047     	 bx lr
 4589              	.L391:
 4590              	 .align 2
 4591              	.L390:
 4592 0014 00000000 	 .word .LANCHOR5
 4593              	 .cfi_endproc
 4594              	.LFE55:
 4596              	 .section .text.pvTaskIncrementMutexHeldCount,"ax",%progbits
 4597              	 .align 2
 4598              	 .global pvTaskIncrementMutexHeldCount
 4599              	 .thumb
 4600              	 .thumb_func
 4602              	pvTaskIncrementMutexHeldCount:
 4603              	.LFB56:
4652:../FreeRTOS/Source/tasks.c ****         /* If xSemaphoreCreateMutex() is called before any tasks have been created
 4604              	 .loc 1 4652 0
 4605              	 .cfi_startproc
 4606              	 
 4607              	 
 4608              	 
4655:../FreeRTOS/Source/tasks.c ****         {
 4609              	 .loc 1 4655 0
 4610 0000 054B     	 ldr r3,.L394
 4611 0002 1B68     	 ldr r3,[r3]
 4612 0004 23B1     	 cbz r3,.L393
4657:../FreeRTOS/Source/tasks.c ****         }
 4613              	 .loc 1 4657 0
 4614 0006 044B     	 ldr r3,.L394
 4615 0008 1A68     	 ldr r2,[r3]
 4616 000a 536D     	 ldr r3,[r2,#84]
 4617 000c 0133     	 adds r3,r3,#1
 4618 000e 5365     	 str r3,[r2,#84]
 4619              	.L393:
4660:../FreeRTOS/Source/tasks.c ****     }
 4620              	 .loc 1 4660 0
 4621 0010 014B     	 ldr r3,.L394
 4622 0012 1868     	 ldr r0,[r3]
4661:../FreeRTOS/Source/tasks.c **** 
 4623              	 .loc 1 4661 0
 4624 0014 7047     	 bx lr
 4625              	.L395:
 4626 0016 00BF     	 .align 2
 4627              	.L394:
 4628 0018 00000000 	 .word .LANCHOR5
 4629              	 .cfi_endproc
 4630              	.LFE56:
 4632              	 .section .text.ulTaskGenericNotifyTake,"ax",%progbits
 4633              	 .align 2
 4634              	 .global ulTaskGenericNotifyTake
 4635              	 .thumb
 4636              	 .thumb_func
 4638              	ulTaskGenericNotifyTake:
 4639              	.LFB57:
4671:../FreeRTOS/Source/tasks.c ****         uint32_t ulReturn;
 4640              	 .loc 1 4671 0
 4641              	 .cfi_startproc
 4642              	 
 4643              	 
 4644              	.LVL427:
 4645 0000 38B5     	 push {r3,r4,r5,lr}
 4646              	.LCFI39:
 4647              	 .cfi_def_cfa_offset 16
 4648              	 .cfi_offset 3,-16
 4649              	 .cfi_offset 4,-12
 4650              	 .cfi_offset 5,-8
 4651              	 .cfi_offset 14,-4
4674:../FreeRTOS/Source/tasks.c **** 
 4652              	 .loc 1 4674 0
 4653 0002 40B1     	 cbz r0,.L397
 4654              	.LBB254:
 4655              	.LBB255:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 4656              	 .loc 2 197 0
 4657              	
 4658 0004 4FF01403 	 mov r3,#20
 4659 0008 83F31188 	 msr basepri,r3
 4660 000c BFF36F8F 	 isb 
 4661 0010 BFF34F8F 	 dsb 
 4662              	
 4663              	
 4664              	.LVL428:
 4665              	 .thumb
 4666              	.L398:
 4667              	.LBE255:
 4668              	.LBE254:
4674:../FreeRTOS/Source/tasks.c **** 
 4669              	 .loc 1 4674 0 discriminator 1
 4670 0014 FEE7     	 b .L398
 4671              	.L397:
 4672 0016 1446     	 mov r4,r2
 4673 0018 0D46     	 mov r5,r1
4676:../FreeRTOS/Source/tasks.c ****         {
 4674              	 .loc 1 4676 0
 4675 001a FFF7FEFF 	 bl vPortEnterCritical
 4676              	.LVL429:
4679:../FreeRTOS/Source/tasks.c ****             {
 4677              	 .loc 1 4679 0
 4678 001e 184B     	 ldr r3,.L403
 4679 0020 1B68     	 ldr r3,[r3]
 4680 0022 9B6D     	 ldr r3,[r3,#88]
 4681 0024 8BB9     	 cbnz r3,.L399
4682:../FreeRTOS/Source/tasks.c **** 
 4682              	 .loc 1 4682 0
 4683 0026 164B     	 ldr r3,.L403
 4684 0028 1B68     	 ldr r3,[r3]
 4685 002a 0122     	 movs r2,#1
 4686 002c 83F85C20 	 strb r2,[r3,#92]
4684:../FreeRTOS/Source/tasks.c ****                 {
 4687              	 .loc 1 4684 0
 4688 0030 5CB1     	 cbz r4,.L399
4686:../FreeRTOS/Source/tasks.c ****                     traceTASK_NOTIFY_TAKE_BLOCK( uxIndexToWait );
 4689              	 .loc 1 4686 0
 4690 0032 2046     	 mov r0,r4
 4691 0034 1146     	 mov r1,r2
 4692 0036 FFF7FEFF 	 bl prvAddCurrentTaskToDelayedList
 4693              	.LVL430:
4693:../FreeRTOS/Source/tasks.c ****                 }
 4694              	 .loc 1 4693 0
 4695 003a 4FF08052 	 mov r2,#268435456
 4696 003e 114B     	 ldr r3,.L403+4
 4697 0040 1A60     	 str r2,[r3]
 4698              	
 4699 0042 BFF34F8F 	 dsb
 4700              	
 4701              	
 4702 0046 BFF36F8F 	 isb
 4703              	
 4704              	 .thumb
 4705              	.L399:
4705:../FreeRTOS/Source/tasks.c **** 
 4706              	 .loc 1 4705 0
 4707 004a FFF7FEFF 	 bl vPortExitCritical
 4708              	.LVL431:
4707:../FreeRTOS/Source/tasks.c ****         {
 4709              	 .loc 1 4707 0
 4710 004e FFF7FEFF 	 bl vPortEnterCritical
 4711              	.LVL432:
4710:../FreeRTOS/Source/tasks.c **** 
 4712              	 .loc 1 4710 0
 4713 0052 0B4B     	 ldr r3,.L403
 4714 0054 1B68     	 ldr r3,[r3]
 4715 0056 9C6D     	 ldr r4,[r3,#88]
 4716              	.LVL433:
4712:../FreeRTOS/Source/tasks.c ****             {
 4717              	 .loc 1 4712 0
 4718 0058 4CB1     	 cbz r4,.L400
4714:../FreeRTOS/Source/tasks.c ****                 {
 4719              	 .loc 1 4714 0
 4720 005a 25B1     	 cbz r5,.L401
4716:../FreeRTOS/Source/tasks.c ****                 }
 4721              	 .loc 1 4716 0
 4722 005c 084B     	 ldr r3,.L403
 4723 005e 1B68     	 ldr r3,[r3]
 4724 0060 0022     	 movs r2,#0
 4725 0062 9A65     	 str r2,[r3,#88]
 4726 0064 03E0     	 b .L400
 4727              	.L401:
4720:../FreeRTOS/Source/tasks.c ****                 }
 4728              	 .loc 1 4720 0
 4729 0066 064B     	 ldr r3,.L403
 4730 0068 1B68     	 ldr r3,[r3]
 4731 006a 621E     	 subs r2,r4,#1
 4732 006c 9A65     	 str r2,[r3,#88]
 4733              	.L400:
4728:../FreeRTOS/Source/tasks.c ****         }
 4734              	 .loc 1 4728 0
 4735 006e 044B     	 ldr r3,.L403
 4736 0070 1B68     	 ldr r3,[r3]
 4737 0072 0022     	 movs r2,#0
 4738 0074 83F85C20 	 strb r2,[r3,#92]
4730:../FreeRTOS/Source/tasks.c **** 
 4739              	 .loc 1 4730 0
 4740 0078 FFF7FEFF 	 bl vPortExitCritical
 4741              	.LVL434:
4733:../FreeRTOS/Source/tasks.c **** 
 4742              	 .loc 1 4733 0
 4743 007c 2046     	 mov r0,r4
 4744 007e 38BD     	 pop {r3,r4,r5,pc}
 4745              	.LVL435:
 4746              	.L404:
 4747              	 .align 2
 4748              	.L403:
 4749 0080 00000000 	 .word .LANCHOR5
 4750 0084 04ED00E0 	 .word -536810236
 4751              	 .cfi_endproc
 4752              	.LFE57:
 4754              	 .section .text.xTaskGenericNotifyWait,"ax",%progbits
 4755              	 .align 2
 4756              	 .global xTaskGenericNotifyWait
 4757              	 .thumb
 4758              	 .thumb_func
 4760              	xTaskGenericNotifyWait:
 4761              	.LFB58:
4745:../FreeRTOS/Source/tasks.c ****         BaseType_t xReturn;
 4762              	 .loc 1 4745 0
 4763              	 .cfi_startproc
 4764              	 
 4765              	 
 4766              	.LVL436:
 4767 0000 F8B5     	 push {r3,r4,r5,r6,r7,lr}
 4768              	.LCFI40:
 4769              	 .cfi_def_cfa_offset 24
 4770              	 .cfi_offset 3,-24
 4771              	 .cfi_offset 4,-20
 4772              	 .cfi_offset 5,-16
 4773              	 .cfi_offset 6,-12
 4774              	 .cfi_offset 7,-8
 4775              	 .cfi_offset 14,-4
 4776 0002 069E     	 ldr r6,[sp,#24]
4748:../FreeRTOS/Source/tasks.c **** 
 4777              	 .loc 1 4748 0
 4778 0004 40B1     	 cbz r0,.L406
 4779              	.LBB256:
 4780              	.LBB257:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 4781              	 .loc 2 197 0
 4782              	
 4783 0006 4FF01403 	 mov r3,#20
 4784 000a 83F31188 	 msr basepri,r3
 4785 000e BFF36F8F 	 isb 
 4786 0012 BFF34F8F 	 dsb 
 4787              	
 4788              	
 4789              	.LVL437:
 4790              	 .thumb
 4791              	.L407:
 4792              	.LBE257:
 4793              	.LBE256:
4748:../FreeRTOS/Source/tasks.c **** 
 4794              	 .loc 1 4748 0 discriminator 1
 4795 0016 FEE7     	 b .L407
 4796              	.LVL438:
 4797              	.L406:
 4798 0018 1C46     	 mov r4,r3
 4799 001a 1546     	 mov r5,r2
 4800 001c 0F46     	 mov r7,r1
4750:../FreeRTOS/Source/tasks.c ****         {
 4801              	 .loc 1 4750 0
 4802 001e FFF7FEFF 	 bl vPortEnterCritical
 4803              	.LVL439:
4753:../FreeRTOS/Source/tasks.c ****             {
 4804              	 .loc 1 4753 0
 4805 0022 204B     	 ldr r3,.L413
 4806 0024 1B68     	 ldr r3,[r3]
 4807 0026 93F85C30 	 ldrb r3,[r3,#92]
 4808 002a DBB2     	 uxtb r3,r3
 4809 002c 022B     	 cmp r3,#2
 4810 002e 16D0     	 beq .L408
4758:../FreeRTOS/Source/tasks.c **** 
 4811              	 .loc 1 4758 0
 4812 0030 1C4A     	 ldr r2,.L413
 4813 0032 1168     	 ldr r1,[r2]
 4814 0034 8B6D     	 ldr r3,[r1,#88]
 4815 0036 23EA0703 	 bic r3,r3,r7
 4816 003a 8B65     	 str r3,[r1,#88]
4761:../FreeRTOS/Source/tasks.c **** 
 4817              	 .loc 1 4761 0
 4818 003c 1368     	 ldr r3,[r2]
 4819 003e 0122     	 movs r2,#1
 4820 0040 83F85C20 	 strb r2,[r3,#92]
4763:../FreeRTOS/Source/tasks.c ****                 {
 4821              	 .loc 1 4763 0
 4822 0044 5EB1     	 cbz r6,.L408
4765:../FreeRTOS/Source/tasks.c ****                     traceTASK_NOTIFY_WAIT_BLOCK( uxIndexToWait );
 4823              	 .loc 1 4765 0
 4824 0046 3046     	 mov r0,r6
 4825 0048 1146     	 mov r1,r2
 4826 004a FFF7FEFF 	 bl prvAddCurrentTaskToDelayedList
 4827              	.LVL440:
4772:../FreeRTOS/Source/tasks.c ****                 }
 4828              	 .loc 1 4772 0
 4829 004e 4FF08052 	 mov r2,#268435456
 4830 0052 154B     	 ldr r3,.L413+4
 4831 0054 1A60     	 str r2,[r3]
 4832              	
 4833 0056 BFF34F8F 	 dsb
 4834              	
 4835              	
 4836 005a BFF36F8F 	 isb
 4837              	
 4838              	 .thumb
 4839              	.L408:
4784:../FreeRTOS/Source/tasks.c **** 
 4840              	 .loc 1 4784 0
 4841 005e FFF7FEFF 	 bl vPortExitCritical
 4842              	.LVL441:
4786:../FreeRTOS/Source/tasks.c ****         {
 4843              	 .loc 1 4786 0
 4844 0062 FFF7FEFF 	 bl vPortEnterCritical
 4845              	.LVL442:
4790:../FreeRTOS/Source/tasks.c ****             {
 4846              	 .loc 1 4790 0
 4847 0066 1CB1     	 cbz r4,.L409
4794:../FreeRTOS/Source/tasks.c ****             }
 4848              	 .loc 1 4794 0
 4849 0068 0E4B     	 ldr r3,.L413
 4850 006a 1B68     	 ldr r3,[r3]
 4851 006c 9B6D     	 ldr r3,[r3,#88]
 4852 006e 2360     	 str r3,[r4]
 4853              	.L409:
4801:../FreeRTOS/Source/tasks.c ****             {
 4854              	 .loc 1 4801 0
 4855 0070 0C4B     	 ldr r3,.L413
 4856 0072 1B68     	 ldr r3,[r3]
 4857 0074 93F85C30 	 ldrb r3,[r3,#92]
 4858 0078 DBB2     	 uxtb r3,r3
 4859 007a 022B     	 cmp r3,#2
 4860 007c 07D1     	 bne .L411
4810:../FreeRTOS/Source/tasks.c ****                 xReturn = pdTRUE;
 4861              	 .loc 1 4810 0
 4862 007e 094B     	 ldr r3,.L413
 4863 0080 1A68     	 ldr r2,[r3]
 4864 0082 936D     	 ldr r3,[r2,#88]
 4865 0084 23EA0503 	 bic r3,r3,r5
 4866 0088 9365     	 str r3,[r2,#88]
 4867              	.LVL443:
4811:../FreeRTOS/Source/tasks.c ****             }
 4868              	 .loc 1 4811 0
 4869 008a 0124     	 movs r4,#1
 4870              	.LVL444:
 4871 008c 00E0     	 b .L410
 4872              	.LVL445:
 4873              	.L411:
4804:../FreeRTOS/Source/tasks.c ****             }
 4874              	 .loc 1 4804 0
 4875 008e 0024     	 movs r4,#0
 4876              	.LVL446:
 4877              	.L410:
4814:../FreeRTOS/Source/tasks.c ****         }
 4878              	 .loc 1 4814 0
 4879 0090 044B     	 ldr r3,.L413
 4880 0092 1B68     	 ldr r3,[r3]
 4881 0094 0022     	 movs r2,#0
 4882 0096 83F85C20 	 strb r2,[r3,#92]
4816:../FreeRTOS/Source/tasks.c **** 
 4883              	 .loc 1 4816 0
 4884 009a FFF7FEFF 	 bl vPortExitCritical
 4885              	.LVL447:
4819:../FreeRTOS/Source/tasks.c **** 
 4886              	 .loc 1 4819 0
 4887 009e 2046     	 mov r0,r4
 4888 00a0 F8BD     	 pop {r3,r4,r5,r6,r7,pc}
 4889              	.LVL448:
 4890              	.L414:
 4891 00a2 00BF     	 .align 2
 4892              	.L413:
 4893 00a4 00000000 	 .word .LANCHOR5
 4894 00a8 04ED00E0 	 .word -536810236
 4895              	 .cfi_endproc
 4896              	.LFE58:
 4898              	 .section .text.xTaskGenericNotify,"ax",%progbits
 4899              	 .align 2
 4900              	 .global xTaskGenericNotify
 4901              	 .thumb
 4902              	 .thumb_func
 4904              	xTaskGenericNotify:
 4905              	.LFB59:
4831:../FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
 4906              	 .loc 1 4831 0
 4907              	 .cfi_startproc
 4908              	 
 4909              	 
 4910              	.LVL449:
 4911 0000 F8B5     	 push {r3,r4,r5,r6,r7,lr}
 4912              	.LCFI41:
 4913              	 .cfi_def_cfa_offset 24
 4914              	 .cfi_offset 3,-24
 4915              	 .cfi_offset 4,-20
 4916              	 .cfi_offset 5,-16
 4917              	 .cfi_offset 6,-12
 4918              	 .cfi_offset 7,-8
 4919              	 .cfi_offset 14,-4
 4920 0002 069F     	 ldr r7,[sp,#24]
 4921              	.LVL450:
4836:../FreeRTOS/Source/tasks.c ****         configASSERT( xTaskToNotify );
 4922              	 .loc 1 4836 0
 4923 0004 41B1     	 cbz r1,.L416
 4924              	.LBB258:
 4925              	.LBB259:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 4926              	 .loc 2 197 0
 4927              	
 4928 0006 4FF01403 	 mov r3,#20
 4929 000a 83F31188 	 msr basepri,r3
 4930 000e BFF36F8F 	 isb 
 4931 0012 BFF34F8F 	 dsb 
 4932              	
 4933              	
 4934              	.LVL451:
 4935              	 .thumb
 4936              	.L417:
 4937              	.LBE259:
 4938              	.LBE258:
4836:../FreeRTOS/Source/tasks.c ****         configASSERT( xTaskToNotify );
 4939              	 .loc 1 4836 0 discriminator 1
 4940 0016 FEE7     	 b .L417
 4941              	.LVL452:
 4942              	.L416:
4837:../FreeRTOS/Source/tasks.c ****         pxTCB = xTaskToNotify;
 4943              	 .loc 1 4837 0
 4944 0018 40B9     	 cbnz r0,.L418
 4945              	.LBB260:
 4946              	.LBB261:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 4947              	 .loc 2 197 0
 4948              	
 4949 001a 4FF01403 	 mov r3,#20
 4950 001e 83F31188 	 msr basepri,r3
 4951 0022 BFF36F8F 	 isb 
 4952 0026 BFF34F8F 	 dsb 
 4953              	
 4954              	
 4955              	.LVL453:
 4956              	 .thumb
 4957              	.L419:
 4958              	.LBE261:
 4959              	.LBE260:
4837:../FreeRTOS/Source/tasks.c ****         pxTCB = xTaskToNotify;
 4960              	 .loc 1 4837 0 discriminator 2
 4961 002a FEE7     	 b .L419
 4962              	.LVL454:
 4963              	.L418:
 4964 002c 1E46     	 mov r6,r3
 4965 002e 1546     	 mov r5,r2
 4966 0030 0446     	 mov r4,r0
 4967              	.LVL455:
4840:../FreeRTOS/Source/tasks.c ****         {
 4968              	 .loc 1 4840 0
 4969 0032 FFF7FEFF 	 bl vPortEnterCritical
 4970              	.LVL456:
4842:../FreeRTOS/Source/tasks.c ****             {
 4971              	 .loc 1 4842 0
 4972 0036 0FB1     	 cbz r7,.L420
4844:../FreeRTOS/Source/tasks.c ****             }
 4973              	 .loc 1 4844 0
 4974 0038 A36D     	 ldr r3,[r4,#88]
 4975 003a 3B60     	 str r3,[r7]
 4976              	.L420:
4847:../FreeRTOS/Source/tasks.c **** 
 4977              	 .loc 1 4847 0
 4978 003c 94F85C30 	 ldrb r3,[r4,#92]
 4979 0040 DBB2     	 uxtb r3,r3
 4980              	.LVL457:
4849:../FreeRTOS/Source/tasks.c **** 
 4981              	 .loc 1 4849 0
 4982 0042 0222     	 movs r2,#2
 4983 0044 84F85C20 	 strb r2,[r4,#92]
4851:../FreeRTOS/Source/tasks.c ****             {
 4984              	 .loc 1 4851 0
 4985 0048 042E     	 cmp r6,#4
 4986 004a 12D8     	 bhi .L421
 4987 004c DFE806F0 	 tbb [pc,r6]
 4988              	.L423:
 4989 0050 1D       	 .byte (.L422-.L423)/2
 4990 0051 03       	 .byte (.L424-.L423)/2
 4991 0052 07       	 .byte (.L425-.L423)/2
 4992 0053 0B       	 .byte (.L426-.L423)/2
 4993 0054 0D       	 .byte (.L427-.L423)/2
 4994 0055 00       	 .p2align 1
 4995              	.L424:
4854:../FreeRTOS/Source/tasks.c ****                     break;
 4996              	 .loc 1 4854 0
 4997 0056 A26D     	 ldr r2,[r4,#88]
 4998 0058 1543     	 orrs r5,r5,r2
 4999              	.LVL458:
 5000 005a A565     	 str r5,[r4,#88]
4855:../FreeRTOS/Source/tasks.c **** 
 5001              	 .loc 1 4855 0
 5002 005c 15E0     	 b .L422
 5003              	.LVL459:
 5004              	.L425:
4858:../FreeRTOS/Source/tasks.c ****                     break;
 5005              	 .loc 1 4858 0
 5006 005e A26D     	 ldr r2,[r4,#88]
 5007 0060 0132     	 adds r2,r2,#1
 5008 0062 A265     	 str r2,[r4,#88]
4859:../FreeRTOS/Source/tasks.c **** 
 5009              	 .loc 1 4859 0
 5010 0064 11E0     	 b .L422
 5011              	.L426:
4862:../FreeRTOS/Source/tasks.c ****                     break;
 5012              	 .loc 1 4862 0
 5013 0066 A565     	 str r5,[r4,#88]
4863:../FreeRTOS/Source/tasks.c **** 
 5014              	 .loc 1 4863 0
 5015 0068 0FE0     	 b .L422
 5016              	.L427:
4867:../FreeRTOS/Source/tasks.c ****                     {
 5017              	 .loc 1 4867 0
 5018 006a 022B     	 cmp r3,#2
 5019 006c 3DD0     	 beq .L432
4869:../FreeRTOS/Source/tasks.c ****                     }
 5020              	 .loc 1 4869 0
 5021 006e A565     	 str r5,[r4,#88]
 5022 0070 0BE0     	 b .L422
 5023              	.L421:
4890:../FreeRTOS/Source/tasks.c **** 
 5024              	 .loc 1 4890 0
 5025 0072 224A     	 ldr r2,.L436
 5026 0074 1268     	 ldr r2,[r2]
 5027 0076 42B1     	 cbz r2,.L422
 5028              	.LBB262:
 5029              	.LBB263:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 5030              	 .loc 2 197 0
 5031              	
 5032 0078 4FF01403 	 mov r3,#20
 5033 007c 83F31188 	 msr basepri,r3
 5034 0080 BFF36F8F 	 isb 
 5035 0084 BFF34F8F 	 dsb 
 5036              	
 5037              	
 5038              	.LVL460:
 5039              	 .thumb
 5040              	.L429:
 5041              	.LBE263:
 5042              	.LBE262:
4890:../FreeRTOS/Source/tasks.c **** 
 5043              	 .loc 1 4890 0 discriminator 3
 5044 0088 FEE7     	 b .L429
 5045              	.LVL461:
 5046              	.L422:
4899:../FreeRTOS/Source/tasks.c ****             {
 5047              	 .loc 1 4899 0
 5048 008a 012B     	 cmp r3,#1
 5049 008c 2FD1     	 bne .L433
4901:../FreeRTOS/Source/tasks.c ****                 prvAddTaskToReadyList( pxTCB );
 5050              	 .loc 1 4901 0
 5051 008e 251D     	 adds r5,r4,#4
 5052 0090 2846     	 mov r0,r5
 5053 0092 FFF7FEFF 	 bl uxListRemove
 5054              	.LVL462:
4902:../FreeRTOS/Source/tasks.c **** 
 5055              	 .loc 1 4902 0
 5056 0096 E06A     	 ldr r0,[r4,#44]
 5057 0098 1949     	 ldr r1,.L436+4
 5058 009a 0B68     	 ldr r3,[r1]
 5059 009c 0122     	 movs r2,#1
 5060 009e 8240     	 lsls r2,r2,r0
 5061 00a0 1343     	 orrs r3,r3,r2
 5062 00a2 0B60     	 str r3,[r1]
 5063 00a4 00EB8000 	 add r0,r0,r0,lsl#2
 5064 00a8 164B     	 ldr r3,.L436+8
 5065 00aa 03EB8000 	 add r0,r3,r0,lsl#2
 5066 00ae 2946     	 mov r1,r5
 5067 00b0 FFF7FEFF 	 bl vListInsertEnd
 5068              	.LVL463:
4905:../FreeRTOS/Source/tasks.c **** 
 5069              	 .loc 1 4905 0
 5070 00b4 A36A     	 ldr r3,[r4,#40]
 5071 00b6 43B1     	 cbz r3,.L430
 5072              	.LBB264:
 5073              	.LBB265:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 5074              	 .loc 2 197 0
 5075              	
 5076 00b8 4FF01403 	 mov r3,#20
 5077 00bc 83F31188 	 msr basepri,r3
 5078 00c0 BFF36F8F 	 isb 
 5079 00c4 BFF34F8F 	 dsb 
 5080              	
 5081              	
 5082              	.LVL464:
 5083              	 .thumb
 5084              	.L431:
 5085              	.LBE265:
 5086              	.LBE264:
4905:../FreeRTOS/Source/tasks.c **** 
 5087              	 .loc 1 4905 0 discriminator 4
 5088 00c8 FEE7     	 b .L431
 5089              	.L430:
4923:../FreeRTOS/Source/tasks.c ****                 {
 5090              	 .loc 1 4923 0
 5091 00ca 0F4B     	 ldr r3,.L436+12
 5092 00cc 1B68     	 ldr r3,[r3]
 5093 00ce E26A     	 ldr r2,[r4,#44]
 5094 00d0 DB6A     	 ldr r3,[r3,#44]
 5095 00d2 9A42     	 cmp r2,r3
 5096 00d4 0DD9     	 bls .L434
4927:../FreeRTOS/Source/tasks.c ****                 }
 5097              	 .loc 1 4927 0
 5098 00d6 4FF08052 	 mov r2,#268435456
 5099 00da 0C4B     	 ldr r3,.L436+16
 5100 00dc 1A60     	 str r2,[r3]
 5101              	
 5102 00de BFF34F8F 	 dsb
 5103              	
 5104              	
 5105 00e2 BFF36F8F 	 isb
 5106              	
 5107              	 .thumb
 5108 00e6 0124     	 movs r4,#1
 5109              	.LVL465:
 5110 00e8 04E0     	 b .L428
 5111              	.LVL466:
 5112              	.L432:
4874:../FreeRTOS/Source/tasks.c ****                     }
 5113              	 .loc 1 4874 0
 5114 00ea 0024     	 movs r4,#0
 5115              	.LVL467:
 5116 00ec 02E0     	 b .L428
 5117              	.LVL468:
 5118              	.L433:
 5119 00ee 0124     	 movs r4,#1
 5120              	.LVL469:
 5121 00f0 00E0     	 b .L428
 5122              	.LVL470:
 5123              	.L434:
 5124 00f2 0124     	 movs r4,#1
 5125              	.LVL471:
 5126              	.L428:
4939:../FreeRTOS/Source/tasks.c **** 
 5127              	 .loc 1 4939 0
 5128 00f4 FFF7FEFF 	 bl vPortExitCritical
 5129              	.LVL472:
4942:../FreeRTOS/Source/tasks.c **** 
 5130              	 .loc 1 4942 0
 5131 00f8 2046     	 mov r0,r4
 5132 00fa F8BD     	 pop {r3,r4,r5,r6,r7,pc}
 5133              	.LVL473:
 5134              	.L437:
 5135              	 .align 2
 5136              	.L436:
 5137 00fc 00000000 	 .word .LANCHOR4
 5138 0100 00000000 	 .word .LANCHOR6
 5139 0104 00000000 	 .word .LANCHOR11
 5140 0108 00000000 	 .word .LANCHOR5
 5141 010c 04ED00E0 	 .word -536810236
 5142              	 .cfi_endproc
 5143              	.LFE59:
 5145              	 .section .text.xTaskGenericNotifyFromISR,"ax",%progbits
 5146              	 .align 2
 5147              	 .global xTaskGenericNotifyFromISR
 5148              	 .thumb
 5149              	 .thumb_func
 5151              	xTaskGenericNotifyFromISR:
 5152              	.LFB60:
4955:../FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
 5153              	 .loc 1 4955 0
 5154              	 .cfi_startproc
 5155              	 
 5156              	 
 5157              	.LVL474:
 5158 0000 2DE9F843 	 push {r3,r4,r5,r6,r7,r8,r9,lr}
 5159              	.LCFI42:
 5160              	 .cfi_def_cfa_offset 32
 5161              	 .cfi_offset 3,-32
 5162              	 .cfi_offset 4,-28
 5163              	 .cfi_offset 5,-24
 5164              	 .cfi_offset 6,-20
 5165              	 .cfi_offset 7,-16
 5166              	 .cfi_offset 8,-12
 5167              	 .cfi_offset 9,-8
 5168              	 .cfi_offset 14,-4
 5169 0004 DDF82090 	 ldr r9,[sp,#32]
 5170 0008 099F     	 ldr r7,[sp,#36]
 5171              	.LVL475:
4961:../FreeRTOS/Source/tasks.c ****         configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 5172              	 .loc 1 4961 0
 5173 000a 40B9     	 cbnz r0,.L439
 5174              	.LBB266:
 5175              	.LBB267:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 5176              	 .loc 2 197 0
 5177              	
 5178 000c 4FF01403 	 mov r3,#20
 5179 0010 83F31188 	 msr basepri,r3
 5180 0014 BFF36F8F 	 isb 
 5181 0018 BFF34F8F 	 dsb 
 5182              	
 5183              	
 5184              	.LVL476:
 5185              	 .thumb
 5186              	.L440:
 5187              	.LBE267:
 5188              	.LBE266:
4961:../FreeRTOS/Source/tasks.c ****         configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 5189              	 .loc 1 4961 0 discriminator 1
 5190 001c FEE7     	 b .L440
 5191              	.LVL477:
 5192              	.L439:
 5193 001e 0446     	 mov r4,r0
4962:../FreeRTOS/Source/tasks.c **** 
 5194              	 .loc 1 4962 0
 5195 0020 41B1     	 cbz r1,.L441
 5196              	.LBB268:
 5197              	.LBB269:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 5198              	 .loc 2 197 0
 5199              	
 5200 0022 4FF01403 	 mov r3,#20
 5201 0026 83F31188 	 msr basepri,r3
 5202 002a BFF36F8F 	 isb 
 5203 002e BFF34F8F 	 dsb 
 5204              	
 5205              	
 5206              	.LVL478:
 5207              	 .thumb
 5208              	.L442:
 5209              	.LBE269:
 5210              	.LBE268:
4962:../FreeRTOS/Source/tasks.c **** 
 5211              	 .loc 1 4962 0 discriminator 2
 5212 0032 FEE7     	 b .L442
 5213              	.LVL479:
 5214              	.L441:
 5215 0034 9846     	 mov r8,r3
 5216 0036 1546     	 mov r5,r2
4980:../FreeRTOS/Source/tasks.c **** 
 5217              	 .loc 1 4980 0
 5218 0038 FFF7FEFF 	 bl vPortValidateInterruptPriority
 5219              	.LVL480:
 5220              	.LBB270:
 5221              	.LBB271:
 213:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 5222              	 .loc 2 213 0
 5223              	
 5224 003c EFF31186 	 mrs r6,basepri
 5225 0040 4FF01403 	 mov r3,#20
 5226 0044 83F31188 	 msr basepri,r3
 5227 0048 BFF36F8F 	 isb 
 5228 004c BFF34F8F 	 dsb 
 5229              	
 5230              	
 5231              	.LVL481:
 5232              	 .thumb
 5233              	.LBE271:
 5234              	.LBE270:
4986:../FreeRTOS/Source/tasks.c ****             {
 5235              	 .loc 1 4986 0
 5236 0050 B9F1000F 	 cmp r9,#0
 5237 0054 02D0     	 beq .L443
4988:../FreeRTOS/Source/tasks.c ****             }
 5238              	 .loc 1 4988 0
 5239 0056 A36D     	 ldr r3,[r4,#88]
 5240 0058 C9F80030 	 str r3,[r9]
 5241              	.L443:
4991:../FreeRTOS/Source/tasks.c ****             pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 5242              	 .loc 1 4991 0
 5243 005c 94F85C30 	 ldrb r3,[r4,#92]
 5244 0060 DBB2     	 uxtb r3,r3
 5245              	.LVL482:
4992:../FreeRTOS/Source/tasks.c **** 
 5246              	 .loc 1 4992 0
 5247 0062 0222     	 movs r2,#2
 5248 0064 84F85C20 	 strb r2,[r4,#92]
4994:../FreeRTOS/Source/tasks.c ****             {
 5249              	 .loc 1 4994 0
 5250 0068 B8F1040F 	 cmp r8,#4
 5251 006c 12D8     	 bhi .L444
 5252 006e DFE808F0 	 tbb [pc,r8]
 5253              	.L446:
 5254 0072 1D       	 .byte (.L445-.L446)/2
 5255 0073 03       	 .byte (.L447-.L446)/2
 5256 0074 07       	 .byte (.L448-.L446)/2
 5257 0075 0B       	 .byte (.L449-.L446)/2
 5258 0076 0D       	 .byte (.L450-.L446)/2
 5259 0077 00       	 .p2align 1
 5260              	.L447:
4997:../FreeRTOS/Source/tasks.c ****                     break;
 5261              	 .loc 1 4997 0
 5262 0078 A26D     	 ldr r2,[r4,#88]
 5263 007a 1543     	 orrs r5,r5,r2
 5264              	.LVL483:
 5265 007c A565     	 str r5,[r4,#88]
4998:../FreeRTOS/Source/tasks.c **** 
 5266              	 .loc 1 4998 0
 5267 007e 15E0     	 b .L445
 5268              	.LVL484:
 5269              	.L448:
5001:../FreeRTOS/Source/tasks.c ****                     break;
 5270              	 .loc 1 5001 0
 5271 0080 A26D     	 ldr r2,[r4,#88]
 5272 0082 0132     	 adds r2,r2,#1
 5273 0084 A265     	 str r2,[r4,#88]
5002:../FreeRTOS/Source/tasks.c **** 
 5274              	 .loc 1 5002 0
 5275 0086 11E0     	 b .L445
 5276              	.L449:
5005:../FreeRTOS/Source/tasks.c ****                     break;
 5277              	 .loc 1 5005 0
 5278 0088 A565     	 str r5,[r4,#88]
5006:../FreeRTOS/Source/tasks.c **** 
 5279              	 .loc 1 5006 0
 5280 008a 0FE0     	 b .L445
 5281              	.L450:
5010:../FreeRTOS/Source/tasks.c ****                     {
 5282              	 .loc 1 5010 0
 5283 008c 022B     	 cmp r3,#2
 5284 008e 43D0     	 beq .L458
5012:../FreeRTOS/Source/tasks.c ****                     }
 5285              	 .loc 1 5012 0
 5286 0090 A565     	 str r5,[r4,#88]
 5287 0092 0BE0     	 b .L445
 5288              	.L444:
5033:../FreeRTOS/Source/tasks.c ****                     break;
 5289              	 .loc 1 5033 0
 5290 0094 254A     	 ldr r2,.L462
 5291 0096 1268     	 ldr r2,[r2]
 5292 0098 42B1     	 cbz r2,.L445
 5293              	.LBB272:
 5294              	.LBB273:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 5295              	 .loc 2 197 0
 5296              	
 5297 009a 4FF01403 	 mov r3,#20
 5298 009e 83F31188 	 msr basepri,r3
 5299 00a2 BFF36F8F 	 isb 
 5300 00a6 BFF34F8F 	 dsb 
 5301              	
 5302              	
 5303              	.LVL485:
 5304              	 .thumb
 5305              	.L452:
 5306              	.LBE273:
 5307              	.LBE272:
5033:../FreeRTOS/Source/tasks.c ****                     break;
 5308              	 .loc 1 5033 0 discriminator 3
 5309 00aa FEE7     	 b .L452
 5310              	.LVL486:
 5311              	.L445:
5041:../FreeRTOS/Source/tasks.c ****             {
 5312              	 .loc 1 5041 0
 5313 00ac 012B     	 cmp r3,#1
 5314 00ae 35D1     	 bne .L459
5044:../FreeRTOS/Source/tasks.c **** 
 5315              	 .loc 1 5044 0
 5316 00b0 A36A     	 ldr r3,[r4,#40]
 5317              	.LVL487:
 5318 00b2 43B1     	 cbz r3,.L453
 5319              	.LBB274:
 5320              	.LBB275:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 5321              	 .loc 2 197 0
 5322              	
 5323 00b4 4FF01403 	 mov r3,#20
 5324 00b8 83F31188 	 msr basepri,r3
 5325 00bc BFF36F8F 	 isb 
 5326 00c0 BFF34F8F 	 dsb 
 5327              	
 5328              	
 5329              	.LVL488:
 5330              	 .thumb
 5331              	.L454:
 5332              	.LBE275:
 5333              	.LBE274:
5044:../FreeRTOS/Source/tasks.c **** 
 5334              	 .loc 1 5044 0 discriminator 4
 5335 00c4 FEE7     	 b .L454
 5336              	.L453:
5046:../FreeRTOS/Source/tasks.c ****                 {
 5337              	 .loc 1 5046 0
 5338 00c6 1A4B     	 ldr r3,.L462+4
 5339 00c8 1B68     	 ldr r3,[r3]
 5340 00ca 9BB9     	 cbnz r3,.L455
5048:../FreeRTOS/Source/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
 5341              	 .loc 1 5048 0
 5342 00cc 251D     	 adds r5,r4,#4
 5343 00ce 2846     	 mov r0,r5
 5344 00d0 FFF7FEFF 	 bl uxListRemove
 5345              	.LVL489:
5049:../FreeRTOS/Source/tasks.c ****                 }
 5346              	 .loc 1 5049 0
 5347 00d4 E06A     	 ldr r0,[r4,#44]
 5348 00d6 1749     	 ldr r1,.L462+8
 5349 00d8 0B68     	 ldr r3,[r1]
 5350 00da 0122     	 movs r2,#1
 5351 00dc 8240     	 lsls r2,r2,r0
 5352 00de 1343     	 orrs r3,r3,r2
 5353 00e0 0B60     	 str r3,[r1]
 5354 00e2 00EB8000 	 add r0,r0,r0,lsl#2
 5355 00e6 144B     	 ldr r3,.L462+12
 5356 00e8 03EB8000 	 add r0,r3,r0,lsl#2
 5357 00ec 2946     	 mov r1,r5
 5358 00ee FFF7FEFF 	 bl vListInsertEnd
 5359              	.LVL490:
 5360 00f2 04E0     	 b .L456
 5361              	.L455:
5055:../FreeRTOS/Source/tasks.c ****                 }
 5362              	 .loc 1 5055 0
 5363 00f4 1148     	 ldr r0,.L462+16
 5364 00f6 04F11801 	 add r1,r4,#24
 5365 00fa FFF7FEFF 	 bl vListInsertEnd
 5366              	.LVL491:
 5367              	.L456:
5058:../FreeRTOS/Source/tasks.c ****                 {
 5368              	 .loc 1 5058 0
 5369 00fe 104B     	 ldr r3,.L462+20
 5370 0100 1B68     	 ldr r3,[r3]
 5371 0102 E26A     	 ldr r2,[r4,#44]
 5372 0104 DB6A     	 ldr r3,[r3,#44]
 5373 0106 9A42     	 cmp r2,r3
 5374 0108 0AD9     	 bls .L460
5062:../FreeRTOS/Source/tasks.c ****                     {
 5375              	 .loc 1 5062 0
 5376 010a 0FB1     	 cbz r7,.L457
5064:../FreeRTOS/Source/tasks.c ****                     }
 5377              	 .loc 1 5064 0
 5378 010c 0123     	 movs r3,#1
 5379 010e 3B60     	 str r3,[r7]
 5380              	.L457:
5070:../FreeRTOS/Source/tasks.c ****                 }
 5381              	 .loc 1 5070 0
 5382 0110 0120     	 movs r0,#1
 5383 0112 0C4B     	 ldr r3,.L462+24
 5384 0114 1860     	 str r0,[r3]
 5385 0116 04E0     	 b .L451
 5386              	.LVL492:
 5387              	.L458:
5017:../FreeRTOS/Source/tasks.c ****                     }
 5388              	 .loc 1 5017 0
 5389 0118 0020     	 movs r0,#0
 5390 011a 02E0     	 b .L451
 5391              	.LVL493:
 5392              	.L459:
 5393 011c 0120     	 movs r0,#1
 5394 011e 00E0     	 b .L451
 5395              	.LVL494:
 5396              	.L460:
 5397 0120 0120     	 movs r0,#1
 5398              	.L451:
 5399              	.LVL495:
 5400              	.LBB276:
 5401              	.LBB277:
 5402              	 .loc 2 231 0
 5403              	
 5404 0122 86F31188 	 msr basepri,r6
 5405              	
 5406              	 .thumb
 5407              	.LBE277:
 5408              	.LBE276:
5081:../FreeRTOS/Source/tasks.c **** 
 5409              	 .loc 1 5081 0
 5410 0126 BDE8F883 	 pop {r3,r4,r5,r6,r7,r8,r9,pc}
 5411              	.LVL496:
 5412              	.L463:
 5413 012a 00BF     	 .align 2
 5414              	.L462:
 5415 012c 00000000 	 .word .LANCHOR4
 5416 0130 00000000 	 .word .LANCHOR16
 5417 0134 00000000 	 .word .LANCHOR6
 5418 0138 00000000 	 .word .LANCHOR11
 5419 013c 00000000 	 .word .LANCHOR1
 5420 0140 00000000 	 .word .LANCHOR5
 5421 0144 00000000 	 .word .LANCHOR19
 5422              	 .cfi_endproc
 5423              	.LFE60:
 5425              	 .section .text.vTaskGenericNotifyGiveFromISR,"ax",%progbits
 5426              	 .align 2
 5427              	 .global vTaskGenericNotifyGiveFromISR
 5428              	 .thumb
 5429              	 .thumb_func
 5431              	vTaskGenericNotifyGiveFromISR:
 5432              	.LFB61:
5091:../FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
 5433              	 .loc 1 5091 0
 5434              	 .cfi_startproc
 5435              	 
 5436              	 
 5437              	.LVL497:
 5438 0000 F8B5     	 push {r3,r4,r5,r6,r7,lr}
 5439              	.LCFI43:
 5440              	 .cfi_def_cfa_offset 24
 5441              	 .cfi_offset 3,-24
 5442              	 .cfi_offset 4,-20
 5443              	 .cfi_offset 5,-16
 5444              	 .cfi_offset 6,-12
 5445              	 .cfi_offset 7,-8
 5446              	 .cfi_offset 14,-4
5096:../FreeRTOS/Source/tasks.c ****         configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 5447              	 .loc 1 5096 0
 5448 0002 40B9     	 cbnz r0,.L465
 5449              	.LBB278:
 5450              	.LBB279:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 5451              	 .loc 2 197 0
 5452              	
 5453 0004 4FF01403 	 mov r3,#20
 5454 0008 83F31188 	 msr basepri,r3
 5455 000c BFF36F8F 	 isb 
 5456 0010 BFF34F8F 	 dsb 
 5457              	
 5458              	
 5459              	.LVL498:
 5460              	 .thumb
 5461              	.L466:
 5462              	.LBE279:
 5463              	.LBE278:
5096:../FreeRTOS/Source/tasks.c ****         configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 5464              	 .loc 1 5096 0 discriminator 1
 5465 0014 FEE7     	 b .L466
 5466              	.L465:
 5467 0016 0446     	 mov r4,r0
5097:../FreeRTOS/Source/tasks.c **** 
 5468              	 .loc 1 5097 0
 5469 0018 41B1     	 cbz r1,.L467
 5470              	.LBB280:
 5471              	.LBB281:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 5472              	 .loc 2 197 0
 5473              	
 5474 001a 4FF01403 	 mov r3,#20
 5475 001e 83F31188 	 msr basepri,r3
 5476 0022 BFF36F8F 	 isb 
 5477 0026 BFF34F8F 	 dsb 
 5478              	
 5479              	
 5480              	.LVL499:
 5481              	 .thumb
 5482              	.L468:
 5483              	.LBE281:
 5484              	.LBE280:
5097:../FreeRTOS/Source/tasks.c **** 
 5485              	 .loc 1 5097 0 discriminator 2
 5486 002a FEE7     	 b .L468
 5487              	.L467:
 5488 002c 1546     	 mov r5,r2
5115:../FreeRTOS/Source/tasks.c **** 
 5489              	 .loc 1 5115 0
 5490 002e FFF7FEFF 	 bl vPortValidateInterruptPriority
 5491              	.LVL500:
 5492              	.LBB282:
 5493              	.LBB283:
 213:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 5494              	 .loc 2 213 0
 5495              	
 5496 0032 EFF31187 	 mrs r7,basepri
 5497 0036 4FF01403 	 mov r3,#20
 5498 003a 83F31188 	 msr basepri,r3
 5499 003e BFF36F8F 	 isb 
 5500 0042 BFF34F8F 	 dsb 
 5501              	
 5502              	
 5503              	.LVL501:
 5504              	 .thumb
 5505              	.LBE283:
 5506              	.LBE282:
5121:../FreeRTOS/Source/tasks.c ****             pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 5507              	 .loc 1 5121 0
 5508 0046 94F85C30 	 ldrb r3,[r4,#92]
 5509 004a DBB2     	 uxtb r3,r3
 5510              	.LVL502:
5122:../FreeRTOS/Source/tasks.c **** 
 5511              	 .loc 1 5122 0
 5512 004c 0222     	 movs r2,#2
 5513 004e 84F85C20 	 strb r2,[r4,#92]
5126:../FreeRTOS/Source/tasks.c **** 
 5514              	 .loc 1 5126 0
 5515 0052 A26D     	 ldr r2,[r4,#88]
 5516 0054 0132     	 adds r2,r2,#1
 5517 0056 A265     	 str r2,[r4,#88]
5132:../FreeRTOS/Source/tasks.c ****             {
 5518              	 .loc 1 5132 0
 5519 0058 012B     	 cmp r3,#1
 5520 005a 32D1     	 bne .L469
5135:../FreeRTOS/Source/tasks.c **** 
 5521              	 .loc 1 5135 0
 5522 005c A36A     	 ldr r3,[r4,#40]
 5523              	.LVL503:
 5524 005e 43B1     	 cbz r3,.L470
 5525              	.LBB284:
 5526              	.LBB285:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 5527              	 .loc 2 197 0
 5528              	
 5529 0060 4FF01403 	 mov r3,#20
 5530 0064 83F31188 	 msr basepri,r3
 5531 0068 BFF36F8F 	 isb 
 5532 006c BFF34F8F 	 dsb 
 5533              	
 5534              	
 5535              	.LVL504:
 5536              	 .thumb
 5537              	.L471:
 5538              	.LBE285:
 5539              	.LBE284:
5135:../FreeRTOS/Source/tasks.c **** 
 5540              	 .loc 1 5135 0 discriminator 3
 5541 0070 FEE7     	 b .L471
 5542              	.L470:
5137:../FreeRTOS/Source/tasks.c ****                 {
 5543              	 .loc 1 5137 0
 5544 0072 154B     	 ldr r3,.L476
 5545 0074 1B68     	 ldr r3,[r3]
 5546 0076 9BB9     	 cbnz r3,.L472
5139:../FreeRTOS/Source/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
 5547              	 .loc 1 5139 0
 5548 0078 261D     	 adds r6,r4,#4
 5549 007a 3046     	 mov r0,r6
 5550 007c FFF7FEFF 	 bl uxListRemove
 5551              	.LVL505:
5140:../FreeRTOS/Source/tasks.c ****                 }
 5552              	 .loc 1 5140 0
 5553 0080 E06A     	 ldr r0,[r4,#44]
 5554 0082 1249     	 ldr r1,.L476+4
 5555 0084 0B68     	 ldr r3,[r1]
 5556 0086 0122     	 movs r2,#1
 5557 0088 8240     	 lsls r2,r2,r0
 5558 008a 1343     	 orrs r3,r3,r2
 5559 008c 0B60     	 str r3,[r1]
 5560 008e 00EB8000 	 add r0,r0,r0,lsl#2
 5561 0092 0F4B     	 ldr r3,.L476+8
 5562 0094 03EB8000 	 add r0,r3,r0,lsl#2
 5563 0098 3146     	 mov r1,r6
 5564 009a FFF7FEFF 	 bl vListInsertEnd
 5565              	.LVL506:
 5566 009e 04E0     	 b .L473
 5567              	.L472:
5146:../FreeRTOS/Source/tasks.c ****                 }
 5568              	 .loc 1 5146 0
 5569 00a0 0C48     	 ldr r0,.L476+12
 5570 00a2 04F11801 	 add r1,r4,#24
 5571 00a6 FFF7FEFF 	 bl vListInsertEnd
 5572              	.LVL507:
 5573              	.L473:
5149:../FreeRTOS/Source/tasks.c ****                 {
 5574              	 .loc 1 5149 0
 5575 00aa 0B4B     	 ldr r3,.L476+16
 5576 00ac 1B68     	 ldr r3,[r3]
 5577 00ae E26A     	 ldr r2,[r4,#44]
 5578 00b0 DB6A     	 ldr r3,[r3,#44]
 5579 00b2 9A42     	 cmp r2,r3
 5580 00b4 05D9     	 bls .L469
5153:../FreeRTOS/Source/tasks.c ****                     {
 5581              	 .loc 1 5153 0
 5582 00b6 0DB1     	 cbz r5,.L474
5155:../FreeRTOS/Source/tasks.c ****                     }
 5583              	 .loc 1 5155 0
 5584 00b8 0123     	 movs r3,#1
 5585 00ba 2B60     	 str r3,[r5]
 5586              	.L474:
5161:../FreeRTOS/Source/tasks.c ****                 }
 5587              	 .loc 1 5161 0
 5588 00bc 0122     	 movs r2,#1
 5589 00be 074B     	 ldr r3,.L476+20
 5590 00c0 1A60     	 str r2,[r3]
 5591              	.L469:
 5592              	.LVL508:
 5593              	.LBB286:
 5594              	.LBB287:
 5595              	 .loc 2 231 0
 5596              	
 5597 00c2 87F31188 	 msr basepri,r7
 5598              	
 5599              	 .thumb
 5600 00c6 F8BD     	 pop {r3,r4,r5,r6,r7,pc}
 5601              	.LVL509:
 5602              	.L477:
 5603              	 .align 2
 5604              	.L476:
 5605 00c8 00000000 	 .word .LANCHOR16
 5606 00cc 00000000 	 .word .LANCHOR6
 5607 00d0 00000000 	 .word .LANCHOR11
 5608 00d4 00000000 	 .word .LANCHOR1
 5609 00d8 00000000 	 .word .LANCHOR5
 5610 00dc 00000000 	 .word .LANCHOR19
 5611              	.LBE287:
 5612              	.LBE286:
 5613              	 .cfi_endproc
 5614              	.LFE61:
 5616              	 .section .text.xTaskGenericNotifyStateClear,"ax",%progbits
 5617              	 .align 2
 5618              	 .global xTaskGenericNotifyStateClear
 5619              	 .thumb
 5620              	 .thumb_func
 5622              	xTaskGenericNotifyStateClear:
 5623              	.LFB62:
5179:../FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
 5624              	 .loc 1 5179 0
 5625              	 .cfi_startproc
 5626              	 
 5627              	 
 5628              	.LVL510:
5183:../FreeRTOS/Source/tasks.c **** 
 5629              	 .loc 1 5183 0
 5630 0000 41B1     	 cbz r1,.L479
 5631              	.LBB288:
 5632              	.LBB289:
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         (
 5633              	 .loc 2 197 0
 5634              	
 5635 0002 4FF01403 	 mov r3,#20
 5636 0006 83F31188 	 msr basepri,r3
 5637 000a BFF36F8F 	 isb 
 5638 000e BFF34F8F 	 dsb 
 5639              	
 5640              	
 5641              	.LVL511:
 5642              	 .thumb
 5643              	.L480:
 5644              	.LBE289:
 5645              	.LBE288:
5183:../FreeRTOS/Source/tasks.c **** 
 5646              	 .loc 1 5183 0 discriminator 1
 5647 0012 FEE7     	 b .L480
 5648              	.L479:
5179:../FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
 5649              	 .loc 1 5179 0
 5650 0014 10B5     	 push {r4,lr}
 5651              	.LCFI44:
 5652              	 .cfi_def_cfa_offset 8
 5653              	 .cfi_offset 4,-8
 5654              	 .cfi_offset 14,-4
 5655 0016 0446     	 mov r4,r0
5187:../FreeRTOS/Source/tasks.c **** 
 5656              	 .loc 1 5187 0
 5657 0018 08B9     	 cbnz r0,.L481
5187:../FreeRTOS/Source/tasks.c **** 
 5658              	 .loc 1 5187 0 is_stmt 0 discriminator 1
 5659 001a 094B     	 ldr r3,.L485
 5660 001c 1C68     	 ldr r4,[r3]
 5661              	.LVL512:
 5662              	.L481:
5189:../FreeRTOS/Source/tasks.c ****         {
 5663              	 .loc 1 5189 0 is_stmt 1 discriminator 4
 5664 001e FFF7FEFF 	 bl vPortEnterCritical
 5665              	.LVL513:
5191:../FreeRTOS/Source/tasks.c ****             {
 5666              	 .loc 1 5191 0 discriminator 4
 5667 0022 94F85C30 	 ldrb r3,[r4,#92]
 5668 0026 DBB2     	 uxtb r3,r3
 5669 0028 022B     	 cmp r3,#2
5193:../FreeRTOS/Source/tasks.c ****                 xReturn = pdPASS;
 5670              	 .loc 1 5193 0 discriminator 4
 5671 002a 03BF     	 ittte eq
 5672 002c 0023     	 moveq r3,#0
 5673 002e 84F85C30 	 strbeq r3,[r4,#92]
 5674              	.LVL514:
5194:../FreeRTOS/Source/tasks.c ****             }
 5675              	 .loc 1 5194 0 discriminator 4
 5676 0032 0124     	 moveq r4,#1
 5677              	.LVL515:
5198:../FreeRTOS/Source/tasks.c ****             }
 5678              	 .loc 1 5198 0 discriminator 4
 5679 0034 0024     	 movne r4,#0
 5680              	.LVL516:
5201:../FreeRTOS/Source/tasks.c **** 
 5681              	 .loc 1 5201 0 discriminator 4
 5682 0036 FFF7FEFF 	 bl vPortExitCritical
 5683              	.LVL517:
5204:../FreeRTOS/Source/tasks.c **** 
 5684              	 .loc 1 5204 0 discriminator 4
 5685 003a 2046     	 mov r0,r4
 5686 003c 10BD     	 pop {r4,pc}
 5687              	.LVL518:
 5688              	.L486:
 5689 003e 00BF     	 .align 2
 5690              	.L485:
 5691 0040 00000000 	 .word .LANCHOR5
 5692              	 .cfi_endproc
 5693              	.LFE62:
 5695              	 .section .text.ulTaskGenericNotifyValueClear,"ax",%progbits
 5696              	 .align 2
 5697              	 .global ulTaskGenericNotifyValueClear
 5698              	 .thumb
 5699              	 .thumb_func
 5701              	ulTaskGenericNotifyValueClear:
 5702              	.LFB63:
5214:../FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
 5703              	 .loc 1 5214 0
 5704              	 .cfi_startproc
 5705              	 
 5706              	 
 5707              	.LVL519:
 5708 0000 70B5     	 push {r4,r5,r6,lr}
 5709              	.LCFI45:
 5710              	 .cfi_def_cfa_offset 16
 5711              	 .cfi_offset 4,-16
 5712              	 .cfi_offset 5,-12
 5713              	 .cfi_offset 6,-8
 5714              	 .cfi_offset 14,-4
 5715 0002 0E46     	 mov r6,r1
 5716 0004 1546     	 mov r5,r2
5220:../FreeRTOS/Source/tasks.c **** 
 5717              	 .loc 1 5220 0
 5718 0006 0446     	 mov r4,r0
 5719 0008 08B9     	 cbnz r0,.L488
5220:../FreeRTOS/Source/tasks.c **** 
 5720              	 .loc 1 5220 0 is_stmt 0 discriminator 1
 5721 000a 074B     	 ldr r3,.L490
 5722 000c 1C68     	 ldr r4,[r3]
 5723              	.LVL520:
 5724              	.L488:
5222:../FreeRTOS/Source/tasks.c ****         {
 5725              	 .loc 1 5222 0 is_stmt 1 discriminator 4
 5726 000e FFF7FEFF 	 bl vPortEnterCritical
 5727              	.LVL521:
 5728 0012 04EB8601 	 add r1,r4,r6,lsl#2
5226:../FreeRTOS/Source/tasks.c ****             pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
 5729              	 .loc 1 5226 0 discriminator 4
 5730 0016 8C6D     	 ldr r4,[r1,#88]
 5731              	.LVL522:
5227:../FreeRTOS/Source/tasks.c ****         }
 5732              	 .loc 1 5227 0 discriminator 4
 5733 0018 8A6D     	 ldr r2,[r1,#88]
 5734 001a 22EA0502 	 bic r2,r2,r5
 5735 001e 8A65     	 str r2,[r1,#88]
5229:../FreeRTOS/Source/tasks.c **** 
 5736              	 .loc 1 5229 0 discriminator 4
 5737 0020 FFF7FEFF 	 bl vPortExitCritical
 5738              	.LVL523:
5232:../FreeRTOS/Source/tasks.c **** 
 5739              	 .loc 1 5232 0 discriminator 4
 5740 0024 2046     	 mov r0,r4
 5741 0026 70BD     	 pop {r4,r5,r6,pc}
 5742              	.LVL524:
 5743              	.L491:
 5744              	 .align 2
 5745              	.L490:
 5746 0028 00000000 	 .word .LANCHOR5
 5747              	 .cfi_endproc
 5748              	.LFE63:
 5750              	 .global pxCurrentTCB
 5751              	 .section .bss.xNumOfOverflows,"aw",%nobits
 5752              	 .align 2
 5753              	 .set .LANCHOR18,.+0
 5756              	xNumOfOverflows:
 5757 0000 00000000 	 .space 4
 5758              	 .section .bss.pxDelayedTaskList,"aw",%nobits
 5759              	 .align 2
 5760              	 .set .LANCHOR2,.+0
 5763              	pxDelayedTaskList:
 5764 0000 00000000 	 .space 4
 5765              	 .section .rodata.str1.4,"aMS",%progbits,1
 5766              	 .align 2
 5767              	.LC0:
 5768 0000 49444C45 	 .ascii "IDLE\000"
 5768      00
 5769 0005 000000   	 .section .bss.xSchedulerRunning,"aw",%nobits
 5770              	 .align 2
 5771              	 .set .LANCHOR14,.+0
 5774              	xSchedulerRunning:
 5775 0000 00000000 	 .space 4
 5776              	 .section .bss.xTasksWaitingTermination,"aw",%nobits
 5777              	 .align 2
 5778              	 .set .LANCHOR9,.+0
 5781              	xTasksWaitingTermination:
 5782 0000 00000000 	 .space 20
 5782      00000000 
 5782      00000000 
 5782      00000000 
 5782      00000000 
 5783              	 .section .bss.pxOverflowDelayedTaskList,"aw",%nobits
 5784              	 .align 2
 5785              	 .set .LANCHOR7,.+0
 5788              	pxOverflowDelayedTaskList:
 5789 0000 00000000 	 .space 4
 5790              	 .section .bss.xPendedTicks,"aw",%nobits
 5791              	 .align 2
 5792              	 .set .LANCHOR20,.+0
 5795              	xPendedTicks:
 5796 0000 00000000 	 .space 4
 5797              	 .section .bss.pxReadyTasksLists,"aw",%nobits
 5798              	 .align 2
 5799              	 .set .LANCHOR11,.+0
 5802              	pxReadyTasksLists:
 5803 0000 00000000 	 .space 200
 5803      00000000 
 5803      00000000 
 5803      00000000 
 5803      00000000 
 5804              	 .section .bss.uxSchedulerSuspended,"aw",%nobits
 5805              	 .align 2
 5806              	 .set .LANCHOR16,.+0
 5809              	uxSchedulerSuspended:
 5810 0000 00000000 	 .space 4
 5811              	 .section .bss.pxCurrentTCB,"aw",%nobits
 5812              	 .align 2
 5813              	 .set .LANCHOR5,.+0
 5816              	pxCurrentTCB:
 5817 0000 00000000 	 .space 4
 5818              	 .section .bss.xPendingReadyList,"aw",%nobits
 5819              	 .align 2
 5820              	 .set .LANCHOR1,.+0
 5823              	xPendingReadyList:
 5824 0000 00000000 	 .space 20
 5824      00000000 
 5824      00000000 
 5824      00000000 
 5824      00000000 
 5825              	 .section .bss.xDelayedTaskList1,"aw",%nobits
 5826              	 .align 2
 5827              	 .set .LANCHOR12,.+0
 5830              	xDelayedTaskList1:
 5831 0000 00000000 	 .space 20
 5831      00000000 
 5831      00000000 
 5831      00000000 
 5831      00000000 
 5832              	 .section .bss.xTickCount,"aw",%nobits
 5833              	 .align 2
 5834              	 .set .LANCHOR4,.+0
 5837              	xTickCount:
 5838 0000 00000000 	 .space 4
 5839              	 .section .bss.xNextTaskUnblockTime,"aw",%nobits
 5840              	 .align 2
 5841              	 .set .LANCHOR3,.+0
 5844              	xNextTaskUnblockTime:
 5845 0000 00000000 	 .space 4
 5846              	 .section .bss.xDelayedTaskList2,"aw",%nobits
 5847              	 .align 2
 5848              	 .set .LANCHOR13,.+0
 5851              	xDelayedTaskList2:
 5852 0000 00000000 	 .space 20
 5852      00000000 
 5852      00000000 
 5852      00000000 
 5852      00000000 
 5853              	 .section .bss.uxTaskNumber,"aw",%nobits
 5854              	 .align 2
 5855              	 .set .LANCHOR15,.+0
 5858              	uxTaskNumber:
 5859 0000 00000000 	 .space 4
 5860              	 .section .bss.uxCurrentNumberOfTasks,"aw",%nobits
 5861              	 .align 2
 5862              	 .set .LANCHOR10,.+0
 5865              	uxCurrentNumberOfTasks:
 5866 0000 00000000 	 .space 4
 5867              	 .section .bss.uxDeletedTasksWaitingCleanUp,"aw",%nobits
 5868              	 .align 2
 5869              	 .set .LANCHOR8,.+0
 5872              	uxDeletedTasksWaitingCleanUp:
 5873 0000 00000000 	 .space 4
 5874              	 .section .bss.xIdleTaskHandle,"aw",%nobits
 5875              	 .align 2
 5876              	 .set .LANCHOR17,.+0
 5879              	xIdleTaskHandle:
 5880 0000 00000000 	 .space 4
 5881              	 .section .bss.xSuspendedTaskList,"aw",%nobits
 5882              	 .align 2
 5883              	 .set .LANCHOR0,.+0
 5886              	xSuspendedTaskList:
 5887 0000 00000000 	 .space 20
 5887      00000000 
 5887      00000000 
 5887      00000000 
 5887      00000000 
 5888              	 .section .bss.uxTopReadyPriority,"aw",%nobits
 5889              	 .align 2
 5890              	 .set .LANCHOR6,.+0
 5893              	uxTopReadyPriority:
 5894 0000 00000000 	 .space 4
 5895              	 .section .bss.xYieldPending,"aw",%nobits
 5896              	 .align 2
 5897              	 .set .LANCHOR19,.+0
 5900              	xYieldPending:
 5901 0000 00000000 	 .space 4
 5902              	 .text
 5903              	.Letext0:
 5904              	 .file 3 "e:\\embedded\\dave_4-4-2_64bit_2018-02-23\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\lib\\gcc\\arm-none-eabi\\4.9.3\\include\\stddef.h"
 5905              	 .file 4 "e:\\embedded\\dave_4-4-2_64bit_2018-02-23\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 5906              	 .file 5 "e:\\embedded\\dave_4-4-2_64bit_2018-02-23\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 5907              	 .file 6 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/include/projdefs.h"
 5908              	 .file 7 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/include/list.h"
 5909              	 .file 8 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/include/task.h"
 5910              	 .file 9 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/include/portable.h"
 5911              	 .file 10 "e:\\embedded\\dave_4-4-2_64bit_2018-02-23\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\string.h"
 5912              	 .file 11 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/include/timers.h"
DEFINED SYMBOLS
                            *ABS*:00000000 tasks.c
    {standard input}:19     .text.prvTaskIsTaskSuspended:00000000 $t
    {standard input}:23     .text.prvTaskIsTaskSuspended:00000000 prvTaskIsTaskSuspended
    {standard input}:82     .text.prvTaskIsTaskSuspended:00000034 $d
    {standard input}:88     .text.prvResetNextTaskUnblockTime:00000000 $t
    {standard input}:92     .text.prvResetNextTaskUnblockTime:00000000 prvResetNextTaskUnblockTime
    {standard input}:121    .text.prvResetNextTaskUnblockTime:00000020 $d
    {standard input}:127    .text.prvAddCurrentTaskToDelayedList:00000000 $t
    {standard input}:131    .text.prvAddCurrentTaskToDelayedList:00000000 prvAddCurrentTaskToDelayedList
    {standard input}:227    .text.prvAddCurrentTaskToDelayedList:00000078 $d
    {standard input}:238    .text.prvIdleTask:00000000 $t
    {standard input}:242    .text.prvIdleTask:00000000 prvIdleTask
    {standard input}:343    .text.prvIdleTask:00000060 $d
    {standard input}:352    .text.xTaskCreate:00000000 $t
    {standard input}:357    .text.xTaskCreate:00000000 xTaskCreate
    {standard input}:682    .text.xTaskCreate:000001ac $d
    {standard input}:700    .text.vTaskDelete:00000000 $t
    {standard input}:705    .text.vTaskDelete:00000000 vTaskDelete
    {standard input}:854    .text.vTaskDelete:000000b8 $d
    {standard input}:868    .text.eTaskGetState:00000000 $t
    {standard input}:873    .text.eTaskGetState:00000000 eTaskGetState
    {standard input}:1001   .text.eTaskGetState:00000078 $d
    {standard input}:1010   .text.uxTaskPriorityGet:00000000 $t
    {standard input}:1015   .text.uxTaskPriorityGet:00000000 uxTaskPriorityGet
    {standard input}:1051   .text.uxTaskPriorityGet:00000018 $d
    {standard input}:1056   .text.uxTaskPriorityGetFromISR:00000000 $t
    {standard input}:1061   .text.uxTaskPriorityGetFromISR:00000000 uxTaskPriorityGetFromISR
    {standard input}:1117   .text.uxTaskPriorityGetFromISR:0000002c $d
    {standard input}:1122   .text.vTaskPrioritySet:00000000 $t
    {standard input}:1127   .text.vTaskPrioritySet:00000000 vTaskPrioritySet
    {standard input}:1296   .text.vTaskPrioritySet:000000d0 $d
    {standard input}:1304   .text.vTaskResume:00000000 $t
    {standard input}:1309   .text.vTaskResume:00000000 vTaskResume
    {standard input}:1405   .text.vTaskResume:00000074 $d
    {standard input}:1413   .text.xTaskResumeFromISR:00000000 $t
    {standard input}:1418   .text.xTaskResumeFromISR:00000000 xTaskResumeFromISR
    {standard input}:1543   .text.xTaskResumeFromISR:00000090 $d
    {standard input}:1552   .text.vTaskStartScheduler:00000000 $t
    {standard input}:1557   .text.vTaskStartScheduler:00000000 vTaskStartScheduler
    {standard input}:1652   .text.vTaskStartScheduler:0000006c $d
    {standard input}:1662   .text.vTaskEndScheduler:00000000 $t
    {standard input}:1667   .text.vTaskEndScheduler:00000000 vTaskEndScheduler
    {standard input}:1703   .text.vTaskEndScheduler:00000020 $d
    {standard input}:1708   .text.vTaskSuspendAll:00000000 $t
    {standard input}:1713   .text.vTaskSuspendAll:00000000 vTaskSuspendAll
    {standard input}:1730   .text.vTaskSuspendAll:0000000c $d
    {standard input}:1735   .text.xTaskGetTickCount:00000000 $t
    {standard input}:1740   .text.xTaskGetTickCount:00000000 xTaskGetTickCount
    {standard input}:1756   .text.xTaskGetTickCount:00000008 $d
    {standard input}:1761   .text.xTaskGetTickCountFromISR:00000000 $t
    {standard input}:1766   .text.xTaskGetTickCountFromISR:00000000 xTaskGetTickCountFromISR
    {standard input}:1789   .text.xTaskGetTickCountFromISR:0000000c $d
    {standard input}:1794   .text.uxTaskGetNumberOfTasks:00000000 $t
    {standard input}:1799   .text.uxTaskGetNumberOfTasks:00000000 uxTaskGetNumberOfTasks
    {standard input}:1814   .text.uxTaskGetNumberOfTasks:00000008 $d
    {standard input}:1819   .text.pcTaskGetName:00000000 $t
    {standard input}:1824   .text.pcTaskGetName:00000000 pcTaskGetName
    {standard input}:1866   .text.pcTaskGetName:00000024 $d
    {standard input}:1871   .text.xTaskIncrementTick:00000000 $t
    {standard input}:1876   .text.xTaskIncrementTick:00000000 xTaskIncrementTick
    {standard input}:2075   .text.xTaskIncrementTick:000000f8 $d
    {standard input}:2090   .text.xTaskResumeAll:00000000 $t
    {standard input}:2095   .text.xTaskResumeAll:00000000 xTaskResumeAll
    {standard input}:2281   .text.xTaskResumeAll:000000d8 $d
    {standard input}:2294   .text.vTaskDelayUntil:00000000 $t
    {standard input}:2299   .text.vTaskDelayUntil:00000000 vTaskDelayUntil
    {standard input}:2456   .text.vTaskDelayUntil:00000098 $d
    {standard input}:2464   .text.vTaskDelay:00000000 $t
    {standard input}:2469   .text.vTaskDelay:00000000 vTaskDelay
    {standard input}:2538   .text.vTaskDelay:00000044 $d
    {standard input}:2544   .text.xTaskCatchUpTicks:00000000 $t
    {standard input}:2549   .text.xTaskCatchUpTicks:00000000 xTaskCatchUpTicks
    {standard input}:2602   .text.xTaskCatchUpTicks:00000030 $d
    {standard input}:2608   .text.vTaskSwitchContext:00000000 $t
    {standard input}:2613   .text.vTaskSwitchContext:00000000 vTaskSwitchContext
    {standard input}:2732   .text.vTaskSwitchContext:00000098 $d
    {standard input}:2743   .text.vTaskSuspend:00000000 $t
    {standard input}:2748   .text.vTaskSuspend:00000000 vTaskSuspend
    {standard input}:2903   .text.vTaskSuspend:000000c0 $d
    {standard input}:2915   .text.vTaskPlaceOnEventList:00000000 $t
    {standard input}:2920   .text.vTaskPlaceOnEventList:00000000 vTaskPlaceOnEventList
    {standard input}:2971   .text.vTaskPlaceOnEventList:0000002c $d
    {standard input}:2976   .text.vTaskPlaceOnUnorderedEventList:00000000 $t
    {standard input}:2981   .text.vTaskPlaceOnUnorderedEventList:00000000 vTaskPlaceOnUnorderedEventList
    {standard input}:3066   .text.vTaskPlaceOnUnorderedEventList:00000054 $d
    {standard input}:3072   .text.vTaskPlaceOnEventListRestricted:00000000 $t
    {standard input}:3077   .text.vTaskPlaceOnEventListRestricted:00000000 vTaskPlaceOnEventListRestricted
    {standard input}:3135   .text.vTaskPlaceOnEventListRestricted:00000038 $d
    {standard input}:3140   .text.xTaskRemoveFromEventList:00000000 $t
    {standard input}:3145   .text.xTaskRemoveFromEventList:00000000 xTaskRemoveFromEventList
    {standard input}:3241   .text.xTaskRemoveFromEventList:00000070 $d
    {standard input}:3251   .text.vTaskRemoveFromUnorderedEventList:00000000 $t
    {standard input}:3256   .text.vTaskRemoveFromUnorderedEventList:00000000 vTaskRemoveFromUnorderedEventList
    {standard input}:3357   .text.vTaskRemoveFromUnorderedEventList:00000074 $d
    {standard input}:3366   .text.vTaskSetTimeOutState:00000000 $t
    {standard input}:3371   .text.vTaskSetTimeOutState:00000000 vTaskSetTimeOutState
    {standard input}:3424   .text.vTaskSetTimeOutState:00000030 $d
    {standard input}:3430   .text.vTaskInternalSetTimeOutState:00000000 $t
    {standard input}:3435   .text.vTaskInternalSetTimeOutState:00000000 vTaskInternalSetTimeOutState
    {standard input}:3455   .text.vTaskInternalSetTimeOutState:00000010 $d
    {standard input}:3461   .text.xTaskCheckForTimeOut:00000000 $t
    {standard input}:3466   .text.xTaskCheckForTimeOut:00000000 xTaskCheckForTimeOut
    {standard input}:3602   .text.xTaskCheckForTimeOut:0000007c $d
    {standard input}:3608   .text.vTaskMissedYield:00000000 $t
    {standard input}:3613   .text.vTaskMissedYield:00000000 vTaskMissedYield
    {standard input}:3628   .text.vTaskMissedYield:00000008 $d
    {standard input}:3633   .text.uxTaskGetTaskNumber:00000000 $t
    {standard input}:3638   .text.uxTaskGetTaskNumber:00000000 uxTaskGetTaskNumber
    {standard input}:3664   .text.vTaskSetTaskNumber:00000000 $t
    {standard input}:3669   .text.vTaskSetTaskNumber:00000000 vTaskSetTaskNumber
    {standard input}:3689   .text.vTaskGetInfo:00000000 $t
    {standard input}:3694   .text.vTaskGetInfo:00000000 vTaskGetInfo
    {standard input}:3826   .text.vTaskGetInfo:00000084 $d
    {standard input}:3831   .text.prvListTasksWithinSingleList:00000000 $t
    {standard input}:3835   .text.prvListTasksWithinSingleList:00000000 prvListTasksWithinSingleList
    {standard input}:3924   .text.uxTaskGetSystemState:00000000 $t
    {standard input}:3929   .text.uxTaskGetSystemState:00000000 uxTaskGetSystemState
    {standard input}:4041   .text.uxTaskGetSystemState:000000a0 $d
    {standard input}:4051   .text.xTaskGetCurrentTaskHandle:00000000 $t
    {standard input}:4056   .text.xTaskGetCurrentTaskHandle:00000000 xTaskGetCurrentTaskHandle
    {standard input}:4072   .text.xTaskGetCurrentTaskHandle:00000008 $d
    {standard input}:4077   .text.xTaskGetSchedulerState:00000000 $t
    {standard input}:4082   .text.xTaskGetSchedulerState:00000000 xTaskGetSchedulerState
    {standard input}:4111   .text.xTaskGetSchedulerState:00000018 $d
    {standard input}:4117   .text.xTaskPriorityInherit:00000000 $t
    {standard input}:4122   .text.xTaskPriorityInherit:00000000 xTaskPriorityInherit
    {standard input}:4244   .text.xTaskPriorityInherit:000000a0 $d
    {standard input}:4251   .text.xTaskPriorityDisinherit:00000000 $t
    {standard input}:4256   .text.xTaskPriorityDisinherit:00000000 xTaskPriorityDisinherit
    {standard input}:4403   .text.xTaskPriorityDisinherit:0000009c $d
    {standard input}:4410   .text.vTaskPriorityDisinheritAfterTimeout:00000000 $t
    {standard input}:4415   .text.vTaskPriorityDisinheritAfterTimeout:00000000 vTaskPriorityDisinheritAfterTimeout
    {standard input}:4557   .text.vTaskPriorityDisinheritAfterTimeout:000000a8 $d
    {standard input}:4564   .text.uxTaskResetEventItemValue:00000000 $t
    {standard input}:4569   .text.uxTaskResetEventItemValue:00000000 uxTaskResetEventItemValue
    {standard input}:4592   .text.uxTaskResetEventItemValue:00000014 $d
    {standard input}:4597   .text.pvTaskIncrementMutexHeldCount:00000000 $t
    {standard input}:4602   .text.pvTaskIncrementMutexHeldCount:00000000 pvTaskIncrementMutexHeldCount
    {standard input}:4628   .text.pvTaskIncrementMutexHeldCount:00000018 $d
    {standard input}:4633   .text.ulTaskGenericNotifyTake:00000000 $t
    {standard input}:4638   .text.ulTaskGenericNotifyTake:00000000 ulTaskGenericNotifyTake
    {standard input}:4749   .text.ulTaskGenericNotifyTake:00000080 $d
    {standard input}:4755   .text.xTaskGenericNotifyWait:00000000 $t
    {standard input}:4760   .text.xTaskGenericNotifyWait:00000000 xTaskGenericNotifyWait
    {standard input}:4893   .text.xTaskGenericNotifyWait:000000a4 $d
    {standard input}:4899   .text.xTaskGenericNotify:00000000 $t
    {standard input}:4904   .text.xTaskGenericNotify:00000000 xTaskGenericNotify
    {standard input}:4989   .text.xTaskGenericNotify:00000050 $d
    {standard input}:5137   .text.xTaskGenericNotify:000000fc $d
    {standard input}:5146   .text.xTaskGenericNotifyFromISR:00000000 $t
    {standard input}:5151   .text.xTaskGenericNotifyFromISR:00000000 xTaskGenericNotifyFromISR
    {standard input}:5254   .text.xTaskGenericNotifyFromISR:00000072 $d
    {standard input}:5415   .text.xTaskGenericNotifyFromISR:0000012c $d
    {standard input}:5426   .text.vTaskGenericNotifyGiveFromISR:00000000 $t
    {standard input}:5431   .text.vTaskGenericNotifyGiveFromISR:00000000 vTaskGenericNotifyGiveFromISR
    {standard input}:5605   .text.vTaskGenericNotifyGiveFromISR:000000c8 $d
    {standard input}:5617   .text.xTaskGenericNotifyStateClear:00000000 $t
    {standard input}:5622   .text.xTaskGenericNotifyStateClear:00000000 xTaskGenericNotifyStateClear
    {standard input}:5691   .text.xTaskGenericNotifyStateClear:00000040 $d
    {standard input}:5696   .text.ulTaskGenericNotifyValueClear:00000000 $t
    {standard input}:5701   .text.ulTaskGenericNotifyValueClear:00000000 ulTaskGenericNotifyValueClear
    {standard input}:5746   .text.ulTaskGenericNotifyValueClear:00000028 $d
    {standard input}:5816   .bss.pxCurrentTCB:00000000 pxCurrentTCB
    {standard input}:5752   .bss.xNumOfOverflows:00000000 $d
    {standard input}:5756   .bss.xNumOfOverflows:00000000 xNumOfOverflows
    {standard input}:5759   .bss.pxDelayedTaskList:00000000 $d
    {standard input}:5763   .bss.pxDelayedTaskList:00000000 pxDelayedTaskList
    {standard input}:5766   .rodata.str1.4:00000000 $d
    {standard input}:5770   .bss.xSchedulerRunning:00000000 $d
    {standard input}:5774   .bss.xSchedulerRunning:00000000 xSchedulerRunning
    {standard input}:5777   .bss.xTasksWaitingTermination:00000000 $d
    {standard input}:5781   .bss.xTasksWaitingTermination:00000000 xTasksWaitingTermination
    {standard input}:5784   .bss.pxOverflowDelayedTaskList:00000000 $d
    {standard input}:5788   .bss.pxOverflowDelayedTaskList:00000000 pxOverflowDelayedTaskList
    {standard input}:5791   .bss.xPendedTicks:00000000 $d
    {standard input}:5795   .bss.xPendedTicks:00000000 xPendedTicks
    {standard input}:5798   .bss.pxReadyTasksLists:00000000 $d
    {standard input}:5802   .bss.pxReadyTasksLists:00000000 pxReadyTasksLists
    {standard input}:5805   .bss.uxSchedulerSuspended:00000000 $d
    {standard input}:5809   .bss.uxSchedulerSuspended:00000000 uxSchedulerSuspended
    {standard input}:5812   .bss.pxCurrentTCB:00000000 $d
    {standard input}:5819   .bss.xPendingReadyList:00000000 $d
    {standard input}:5823   .bss.xPendingReadyList:00000000 xPendingReadyList
    {standard input}:5826   .bss.xDelayedTaskList1:00000000 $d
    {standard input}:5830   .bss.xDelayedTaskList1:00000000 xDelayedTaskList1
    {standard input}:5833   .bss.xTickCount:00000000 $d
    {standard input}:5837   .bss.xTickCount:00000000 xTickCount
    {standard input}:5840   .bss.xNextTaskUnblockTime:00000000 $d
    {standard input}:5844   .bss.xNextTaskUnblockTime:00000000 xNextTaskUnblockTime
    {standard input}:5847   .bss.xDelayedTaskList2:00000000 $d
    {standard input}:5851   .bss.xDelayedTaskList2:00000000 xDelayedTaskList2
    {standard input}:5854   .bss.uxTaskNumber:00000000 $d
    {standard input}:5858   .bss.uxTaskNumber:00000000 uxTaskNumber
    {standard input}:5861   .bss.uxCurrentNumberOfTasks:00000000 $d
    {standard input}:5865   .bss.uxCurrentNumberOfTasks:00000000 uxCurrentNumberOfTasks
    {standard input}:5868   .bss.uxDeletedTasksWaitingCleanUp:00000000 $d
    {standard input}:5872   .bss.uxDeletedTasksWaitingCleanUp:00000000 uxDeletedTasksWaitingCleanUp
    {standard input}:5875   .bss.xIdleTaskHandle:00000000 $d
    {standard input}:5879   .bss.xIdleTaskHandle:00000000 xIdleTaskHandle
    {standard input}:5882   .bss.xSuspendedTaskList:00000000 $d
    {standard input}:5886   .bss.xSuspendedTaskList:00000000 xSuspendedTaskList
    {standard input}:5889   .bss.uxTopReadyPriority:00000000 $d
    {standard input}:5893   .bss.uxTopReadyPriority:00000000 uxTopReadyPriority
    {standard input}:5896   .bss.xYieldPending:00000000 $d
    {standard input}:5900   .bss.xYieldPending:00000000 xYieldPending
                     .debug_frame:00000010 $d
    {standard input}:4994   .text.xTaskGenericNotify:00000055 $d
    {standard input}:4994   .text.xTaskGenericNotify:00000056 $t
    {standard input}:5259   .text.xTaskGenericNotifyFromISR:00000077 $d
    {standard input}:5259   .text.xTaskGenericNotifyFromISR:00000078 $t
                           .group:00000000 wm4.0.3466fc6a3db32493c997d085de4c7a28
                           .group:00000000 wm4.newlib.h.8.fe7d912fc917043c98742c35eddd8cff
                           .group:00000000 wm4.features.h.22.bee0aee4a3878f51861c775df98fa3ea
                           .group:00000000 wm4.config.h.216.aad1ef7bee4fb69981cb38ce62f84d9c
                           .group:00000000 wm4._ansi.h.23.9f8fcfa20193763fcf364fb91705c94b
                           .group:00000000 wm4.stdlib.h.13.4ed386f5c1a80d71e72172885d946ef2
                           .group:00000000 wm4.stddef.h.184.aa65fb7281d578229bbad41b91862635
                           .group:00000000 wm4.stddef.h.39.dc09cac7e3f758f23d559f6b28ebbb0d
                           .group:00000000 wm4._default_types.h.6.35ee9e747940367bf2a634907d1c2382
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4._types.h.54.d3d34a3b7f3cc230cd159baf022b4b08
                           .group:00000000 wm4.stddef.h.158.61317cdbfb4026324507d123a50b0fd6
                           .group:00000000 wm4.reent.h.17.8bd9e4098e0428508c282cad794fae43
                           .group:00000000 wm4.alloca.h.8.dfc0c703c47ec3e69746825b17d9e66d
                           .group:00000000 wm4.stdlib.h.53.fe81d5186f74ee22c982a1a79f340ee8
                           .group:00000000 wm4.cdefs.h.47.4002528de975c0fcce6c551c15d87b8c
                           .group:00000000 wm4.string.h.15.dab3980bf35408a4c507182805e2de3a
                           .group:00000000 wm4.stddef.h.158.a7efb00f6cbc6f43213b50e183c9830c
                           .group:00000000 wm4._intsup.h.10.ca9f32a61b410c270a48d1161ca2c217
                           .group:00000000 wm4.stdint.h.22.f4a337c398d8b6d821a97202448bc0d0
                           .group:00000000 wm4.FreeRTOSConfig.h.30.aa43eb1cb33228d5c7e359a94d48589b
                           .group:00000000 wm4.projdefs.h.28.d6a7c9061b707820f2fcf4c2ff5d9f24
                           .group:00000000 wm4.portmacro.h.30.2ddc2eaf2e032c76c597fb78c4365041
                           .group:00000000 wm4.portable.h.63.e9cc508c3850f44ce542149380c67812
                           .group:00000000 wm4.mpu_wrappers.h.28.163fb40577cf8d1578015ea3f2ff4cdb
                           .group:00000000 wm4.FreeRTOS.h.67.9945f39eea4ddeb224c0782392206292
                           .group:00000000 wm4.list.h.57.02ec67e07eacffe5ca7cfb7326896236
                           .group:00000000 wm4.task.h.47.2d3fe49a094b8ec1e3e6aac441e8db21
                           .group:00000000 wm4.timers.h.55.5dc360ab39e4b575b2753deeda01a480
                           .group:00000000 wm4.stack_macros.h.28.c1ea95e71701ddf64f7fe546c6e79909

UNDEFINED SYMBOLS
uxListRemove
vListInsertEnd
vListInsert
vPortEnterCritical
vPortExitCritical
vPortFree
vApplicationIdleHook
pvPortMalloc
memset
vListInitialiseItem
pxPortInitialiseStack
vListInitialise
vPortValidateInterruptPriority
xTimerCreateTimerTask
xPortStartScheduler
vPortEndScheduler
vApplicationStackOverflowHook
