   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .eabi_attribute 28,1
   5              	 .fpu fpv4-sp-d16
   6              	 .eabi_attribute 23,1
   7              	 .eabi_attribute 24,1
   8              	 .eabi_attribute 25,1
   9              	 .eabi_attribute 26,1
  10              	 .eabi_attribute 30,1
  11              	 .eabi_attribute 34,1
  12              	 .eabi_attribute 18,4
  13              	 .thumb
  14              	 .file "heap_4.c"
  15              	 .text
  16              	.Ltext0:
  17              	 .cfi_sections .debug_frame
  18              	 .section .text.prvInsertBlockIntoFreeList,"ax",%progbits
  19              	 .align 2
  20              	 .thumb
  21              	 .thumb_func
  23              	prvInsertBlockIntoFreeList:
  24              	.LFB11:
  25              	 .file 1 "../FreeRTOS/MemMang/heap_4.c"
   1:../FreeRTOS/MemMang/heap_4.c **** /*
   2:../FreeRTOS/MemMang/heap_4.c ****  * FreeRTOS Kernel V10.4.1
   3:../FreeRTOS/MemMang/heap_4.c ****  * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:../FreeRTOS/MemMang/heap_4.c ****  *
   5:../FreeRTOS/MemMang/heap_4.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:../FreeRTOS/MemMang/heap_4.c ****  * this software and associated documentation files (the "Software"), to deal in
   7:../FreeRTOS/MemMang/heap_4.c ****  * the Software without restriction, including without limitation the rights to
   8:../FreeRTOS/MemMang/heap_4.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:../FreeRTOS/MemMang/heap_4.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:../FreeRTOS/MemMang/heap_4.c ****  * subject to the following conditions:
  11:../FreeRTOS/MemMang/heap_4.c ****  *
  12:../FreeRTOS/MemMang/heap_4.c ****  * The above copyright notice and this permission notice shall be included in all
  13:../FreeRTOS/MemMang/heap_4.c ****  * copies or substantial portions of the Software.
  14:../FreeRTOS/MemMang/heap_4.c ****  *
  15:../FreeRTOS/MemMang/heap_4.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:../FreeRTOS/MemMang/heap_4.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:../FreeRTOS/MemMang/heap_4.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:../FreeRTOS/MemMang/heap_4.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:../FreeRTOS/MemMang/heap_4.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:../FreeRTOS/MemMang/heap_4.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:../FreeRTOS/MemMang/heap_4.c ****  *
  22:../FreeRTOS/MemMang/heap_4.c ****  * https://www.FreeRTOS.org
  23:../FreeRTOS/MemMang/heap_4.c ****  * https://github.com/FreeRTOS
  24:../FreeRTOS/MemMang/heap_4.c ****  *
  25:../FreeRTOS/MemMang/heap_4.c ****  */
  26:../FreeRTOS/MemMang/heap_4.c **** 
  27:../FreeRTOS/MemMang/heap_4.c **** /*
  28:../FreeRTOS/MemMang/heap_4.c ****  * A sample implementation of pvPortMalloc() and vPortFree() that combines
  29:../FreeRTOS/MemMang/heap_4.c ****  * (coalescences) adjacent memory blocks as they are freed, and in so doing
  30:../FreeRTOS/MemMang/heap_4.c ****  * limits memory fragmentation.
  31:../FreeRTOS/MemMang/heap_4.c ****  *
  32:../FreeRTOS/MemMang/heap_4.c ****  * See heap_1.c, heap_2.c and heap_3.c for alternative implementations, and the
  33:../FreeRTOS/MemMang/heap_4.c ****  * memory management pages of https://www.FreeRTOS.org for more information.
  34:../FreeRTOS/MemMang/heap_4.c ****  */
  35:../FreeRTOS/MemMang/heap_4.c **** #include <stdlib.h>
  36:../FreeRTOS/MemMang/heap_4.c **** 
  37:../FreeRTOS/MemMang/heap_4.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  38:../FreeRTOS/MemMang/heap_4.c ****  * all the API functions to use the MPU wrappers.  That should only be done when
  39:../FreeRTOS/MemMang/heap_4.c ****  * task.h is included from an application file. */
  40:../FreeRTOS/MemMang/heap_4.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  41:../FreeRTOS/MemMang/heap_4.c **** 
  42:../FreeRTOS/MemMang/heap_4.c **** #include "FreeRTOS.h"
  43:../FreeRTOS/MemMang/heap_4.c **** #include "task.h"
  44:../FreeRTOS/MemMang/heap_4.c **** 
  45:../FreeRTOS/MemMang/heap_4.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  46:../FreeRTOS/MemMang/heap_4.c **** 
  47:../FreeRTOS/MemMang/heap_4.c **** #if ( configSUPPORT_DYNAMIC_ALLOCATION == 0 )
  48:../FreeRTOS/MemMang/heap_4.c ****     #error This file must not be used if configSUPPORT_DYNAMIC_ALLOCATION is 0
  49:../FreeRTOS/MemMang/heap_4.c **** #endif
  50:../FreeRTOS/MemMang/heap_4.c **** 
  51:../FreeRTOS/MemMang/heap_4.c **** /* Block sizes must not get too small. */
  52:../FreeRTOS/MemMang/heap_4.c **** #define heapMINIMUM_BLOCK_SIZE    ( ( size_t ) ( xHeapStructSize << 1 ) )
  53:../FreeRTOS/MemMang/heap_4.c **** 
  54:../FreeRTOS/MemMang/heap_4.c **** /* Assumes 8bit bytes! */
  55:../FreeRTOS/MemMang/heap_4.c **** #define heapBITS_PER_BYTE         ( ( size_t ) 8 )
  56:../FreeRTOS/MemMang/heap_4.c **** 
  57:../FreeRTOS/MemMang/heap_4.c **** /* Allocate the memory for the heap. */
  58:../FreeRTOS/MemMang/heap_4.c **** #if ( configAPPLICATION_ALLOCATED_HEAP == 1 )
  59:../FreeRTOS/MemMang/heap_4.c **** 
  60:../FreeRTOS/MemMang/heap_4.c **** /* The application writer has already defined the array used for the RTOS
  61:../FreeRTOS/MemMang/heap_4.c **** * heap - probably so it can be placed in a special segment or address. */
  62:../FreeRTOS/MemMang/heap_4.c ****     extern uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
  63:../FreeRTOS/MemMang/heap_4.c **** #else
  64:../FreeRTOS/MemMang/heap_4.c ****     PRIVILEGED_DATA static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
  65:../FreeRTOS/MemMang/heap_4.c **** #endif /* configAPPLICATION_ALLOCATED_HEAP */
  66:../FreeRTOS/MemMang/heap_4.c **** 
  67:../FreeRTOS/MemMang/heap_4.c **** /* Define the linked list structure.  This is used to link free blocks in order
  68:../FreeRTOS/MemMang/heap_4.c ****  * of their memory address. */
  69:../FreeRTOS/MemMang/heap_4.c **** typedef struct A_BLOCK_LINK
  70:../FreeRTOS/MemMang/heap_4.c **** {
  71:../FreeRTOS/MemMang/heap_4.c ****     struct A_BLOCK_LINK * pxNextFreeBlock; /*<< The next free block in the list. */
  72:../FreeRTOS/MemMang/heap_4.c ****     size_t xBlockSize;                     /*<< The size of the free block. */
  73:../FreeRTOS/MemMang/heap_4.c **** } BlockLink_t;
  74:../FreeRTOS/MemMang/heap_4.c **** 
  75:../FreeRTOS/MemMang/heap_4.c **** /*-----------------------------------------------------------*/
  76:../FreeRTOS/MemMang/heap_4.c **** 
  77:../FreeRTOS/MemMang/heap_4.c **** /*
  78:../FreeRTOS/MemMang/heap_4.c ****  * Inserts a block of memory that is being freed into the correct position in
  79:../FreeRTOS/MemMang/heap_4.c ****  * the list of free memory blocks.  The block being freed will be merged with
  80:../FreeRTOS/MemMang/heap_4.c ****  * the block in front it and/or the block behind it if the memory blocks are
  81:../FreeRTOS/MemMang/heap_4.c ****  * adjacent to each other.
  82:../FreeRTOS/MemMang/heap_4.c ****  */
  83:../FreeRTOS/MemMang/heap_4.c **** static void prvInsertBlockIntoFreeList( BlockLink_t * pxBlockToInsert ) PRIVILEGED_FUNCTION;
  84:../FreeRTOS/MemMang/heap_4.c **** 
  85:../FreeRTOS/MemMang/heap_4.c **** /*
  86:../FreeRTOS/MemMang/heap_4.c ****  * Called automatically to setup the required heap structures the first time
  87:../FreeRTOS/MemMang/heap_4.c ****  * pvPortMalloc() is called.
  88:../FreeRTOS/MemMang/heap_4.c ****  */
  89:../FreeRTOS/MemMang/heap_4.c **** static void prvHeapInit( void ) PRIVILEGED_FUNCTION;
  90:../FreeRTOS/MemMang/heap_4.c **** 
  91:../FreeRTOS/MemMang/heap_4.c **** /*-----------------------------------------------------------*/
  92:../FreeRTOS/MemMang/heap_4.c **** 
  93:../FreeRTOS/MemMang/heap_4.c **** /* The size of the structure placed at the beginning of each allocated memory
  94:../FreeRTOS/MemMang/heap_4.c ****  * block must by correctly byte aligned. */
  95:../FreeRTOS/MemMang/heap_4.c **** static const size_t xHeapStructSize = ( sizeof( BlockLink_t ) + ( ( size_t ) ( portBYTE_ALIGNMENT -
  96:../FreeRTOS/MemMang/heap_4.c **** 
  97:../FreeRTOS/MemMang/heap_4.c **** /* Create a couple of list links to mark the start and end of the list. */
  98:../FreeRTOS/MemMang/heap_4.c **** PRIVILEGED_DATA static BlockLink_t xStart, * pxEnd = NULL;
  99:../FreeRTOS/MemMang/heap_4.c **** 
 100:../FreeRTOS/MemMang/heap_4.c **** /* Keeps track of the number of calls to allocate and free memory as well as the
 101:../FreeRTOS/MemMang/heap_4.c ****  * number of free bytes remaining, but says nothing about fragmentation. */
 102:../FreeRTOS/MemMang/heap_4.c **** PRIVILEGED_DATA static size_t xFreeBytesRemaining = 0U;
 103:../FreeRTOS/MemMang/heap_4.c **** PRIVILEGED_DATA static size_t xMinimumEverFreeBytesRemaining = 0U;
 104:../FreeRTOS/MemMang/heap_4.c **** PRIVILEGED_DATA static size_t xNumberOfSuccessfulAllocations = 0;
 105:../FreeRTOS/MemMang/heap_4.c **** PRIVILEGED_DATA static size_t xNumberOfSuccessfulFrees = 0;
 106:../FreeRTOS/MemMang/heap_4.c **** 
 107:../FreeRTOS/MemMang/heap_4.c **** /* Gets set to the top bit of an size_t type.  When this bit in the xBlockSize
 108:../FreeRTOS/MemMang/heap_4.c ****  * member of an BlockLink_t structure is set then the block belongs to the
 109:../FreeRTOS/MemMang/heap_4.c ****  * application.  When the bit is free the block is still part of the free heap
 110:../FreeRTOS/MemMang/heap_4.c ****  * space. */
 111:../FreeRTOS/MemMang/heap_4.c **** PRIVILEGED_DATA static size_t xBlockAllocatedBit = 0;
 112:../FreeRTOS/MemMang/heap_4.c **** 
 113:../FreeRTOS/MemMang/heap_4.c **** /*-----------------------------------------------------------*/
 114:../FreeRTOS/MemMang/heap_4.c **** 
 115:../FreeRTOS/MemMang/heap_4.c **** void * pvPortMalloc( size_t xWantedSize )
 116:../FreeRTOS/MemMang/heap_4.c **** {
 117:../FreeRTOS/MemMang/heap_4.c ****     BlockLink_t * pxBlock, * pxPreviousBlock, * pxNewBlockLink;
 118:../FreeRTOS/MemMang/heap_4.c ****     void * pvReturn = NULL;
 119:../FreeRTOS/MemMang/heap_4.c **** 
 120:../FreeRTOS/MemMang/heap_4.c ****     vTaskSuspendAll();
 121:../FreeRTOS/MemMang/heap_4.c ****     {
 122:../FreeRTOS/MemMang/heap_4.c ****         /* If this is the first call to malloc then the heap will require
 123:../FreeRTOS/MemMang/heap_4.c ****          * initialisation to setup the list of free blocks. */
 124:../FreeRTOS/MemMang/heap_4.c ****         if( pxEnd == NULL )
 125:../FreeRTOS/MemMang/heap_4.c ****         {
 126:../FreeRTOS/MemMang/heap_4.c ****             prvHeapInit();
 127:../FreeRTOS/MemMang/heap_4.c ****         }
 128:../FreeRTOS/MemMang/heap_4.c ****         else
 129:../FreeRTOS/MemMang/heap_4.c ****         {
 130:../FreeRTOS/MemMang/heap_4.c ****             mtCOVERAGE_TEST_MARKER();
 131:../FreeRTOS/MemMang/heap_4.c ****         }
 132:../FreeRTOS/MemMang/heap_4.c **** 
 133:../FreeRTOS/MemMang/heap_4.c ****         /* Check the requested block size is not so large that the top bit is
 134:../FreeRTOS/MemMang/heap_4.c ****          * set.  The top bit of the block size member of the BlockLink_t structure
 135:../FreeRTOS/MemMang/heap_4.c ****          * is used to determine who owns the block - the application or the
 136:../FreeRTOS/MemMang/heap_4.c ****          * kernel, so it must be free. */
 137:../FreeRTOS/MemMang/heap_4.c ****         if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 138:../FreeRTOS/MemMang/heap_4.c ****         {
 139:../FreeRTOS/MemMang/heap_4.c ****             /* The wanted size is increased so it can contain a BlockLink_t
 140:../FreeRTOS/MemMang/heap_4.c ****              * structure in addition to the requested amount of bytes. */
 141:../FreeRTOS/MemMang/heap_4.c ****             if( xWantedSize > 0 )
 142:../FreeRTOS/MemMang/heap_4.c ****             {
 143:../FreeRTOS/MemMang/heap_4.c ****                 xWantedSize += xHeapStructSize;
 144:../FreeRTOS/MemMang/heap_4.c **** 
 145:../FreeRTOS/MemMang/heap_4.c ****                 /* Ensure that blocks are always aligned to the required number
 146:../FreeRTOS/MemMang/heap_4.c ****                  * of bytes. */
 147:../FreeRTOS/MemMang/heap_4.c ****                 if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 148:../FreeRTOS/MemMang/heap_4.c ****                 {
 149:../FreeRTOS/MemMang/heap_4.c ****                     /* Byte alignment required. */
 150:../FreeRTOS/MemMang/heap_4.c ****                     xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK )
 151:../FreeRTOS/MemMang/heap_4.c ****                     configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
 152:../FreeRTOS/MemMang/heap_4.c ****                 }
 153:../FreeRTOS/MemMang/heap_4.c ****                 else
 154:../FreeRTOS/MemMang/heap_4.c ****                 {
 155:../FreeRTOS/MemMang/heap_4.c ****                     mtCOVERAGE_TEST_MARKER();
 156:../FreeRTOS/MemMang/heap_4.c ****                 }
 157:../FreeRTOS/MemMang/heap_4.c ****             }
 158:../FreeRTOS/MemMang/heap_4.c ****             else
 159:../FreeRTOS/MemMang/heap_4.c ****             {
 160:../FreeRTOS/MemMang/heap_4.c ****                 mtCOVERAGE_TEST_MARKER();
 161:../FreeRTOS/MemMang/heap_4.c ****             }
 162:../FreeRTOS/MemMang/heap_4.c **** 
 163:../FreeRTOS/MemMang/heap_4.c ****             if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 164:../FreeRTOS/MemMang/heap_4.c ****             {
 165:../FreeRTOS/MemMang/heap_4.c ****                 /* Traverse the list from the start	(lowest address) block until
 166:../FreeRTOS/MemMang/heap_4.c ****                  * one	of adequate size is found. */
 167:../FreeRTOS/MemMang/heap_4.c ****                 pxPreviousBlock = &xStart;
 168:../FreeRTOS/MemMang/heap_4.c ****                 pxBlock = xStart.pxNextFreeBlock;
 169:../FreeRTOS/MemMang/heap_4.c **** 
 170:../FreeRTOS/MemMang/heap_4.c ****                 while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL 
 171:../FreeRTOS/MemMang/heap_4.c ****                 {
 172:../FreeRTOS/MemMang/heap_4.c ****                     pxPreviousBlock = pxBlock;
 173:../FreeRTOS/MemMang/heap_4.c ****                     pxBlock = pxBlock->pxNextFreeBlock;
 174:../FreeRTOS/MemMang/heap_4.c ****                 }
 175:../FreeRTOS/MemMang/heap_4.c **** 
 176:../FreeRTOS/MemMang/heap_4.c ****                 /* If the end marker was reached then a block of adequate size
 177:../FreeRTOS/MemMang/heap_4.c ****                  * was	not found. */
 178:../FreeRTOS/MemMang/heap_4.c ****                 if( pxBlock != pxEnd )
 179:../FreeRTOS/MemMang/heap_4.c ****                 {
 180:../FreeRTOS/MemMang/heap_4.c ****                     /* Return the memory space pointed to - jumping over the
 181:../FreeRTOS/MemMang/heap_4.c ****                      * BlockLink_t structure at its start. */
 182:../FreeRTOS/MemMang/heap_4.c ****                     pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xH
 183:../FreeRTOS/MemMang/heap_4.c **** 
 184:../FreeRTOS/MemMang/heap_4.c ****                     /* This block is being returned for use so must be taken out
 185:../FreeRTOS/MemMang/heap_4.c ****                      * of the list of free blocks. */
 186:../FreeRTOS/MemMang/heap_4.c ****                     pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 187:../FreeRTOS/MemMang/heap_4.c **** 
 188:../FreeRTOS/MemMang/heap_4.c ****                     /* If the block is larger than required it can be split into
 189:../FreeRTOS/MemMang/heap_4.c ****                      * two. */
 190:../FreeRTOS/MemMang/heap_4.c ****                     if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 191:../FreeRTOS/MemMang/heap_4.c ****                     {
 192:../FreeRTOS/MemMang/heap_4.c ****                         /* This block is to be split into two.  Create a new
 193:../FreeRTOS/MemMang/heap_4.c ****                          * block following the number of bytes requested. The void
 194:../FreeRTOS/MemMang/heap_4.c ****                          * cast is used to prevent byte alignment warnings from the
 195:../FreeRTOS/MemMang/heap_4.c ****                          * compiler. */
 196:../FreeRTOS/MemMang/heap_4.c ****                         pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 197:../FreeRTOS/MemMang/heap_4.c ****                         configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) =
 198:../FreeRTOS/MemMang/heap_4.c **** 
 199:../FreeRTOS/MemMang/heap_4.c ****                         /* Calculate the sizes of two blocks split from the
 200:../FreeRTOS/MemMang/heap_4.c ****                          * single block. */
 201:../FreeRTOS/MemMang/heap_4.c ****                         pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 202:../FreeRTOS/MemMang/heap_4.c ****                         pxBlock->xBlockSize = xWantedSize;
 203:../FreeRTOS/MemMang/heap_4.c **** 
 204:../FreeRTOS/MemMang/heap_4.c ****                         /* Insert the new block into the list of free blocks. */
 205:../FreeRTOS/MemMang/heap_4.c ****                         prvInsertBlockIntoFreeList( pxNewBlockLink );
 206:../FreeRTOS/MemMang/heap_4.c ****                     }
 207:../FreeRTOS/MemMang/heap_4.c ****                     else
 208:../FreeRTOS/MemMang/heap_4.c ****                     {
 209:../FreeRTOS/MemMang/heap_4.c ****                         mtCOVERAGE_TEST_MARKER();
 210:../FreeRTOS/MemMang/heap_4.c ****                     }
 211:../FreeRTOS/MemMang/heap_4.c **** 
 212:../FreeRTOS/MemMang/heap_4.c ****                     xFreeBytesRemaining -= pxBlock->xBlockSize;
 213:../FreeRTOS/MemMang/heap_4.c **** 
 214:../FreeRTOS/MemMang/heap_4.c ****                     if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 215:../FreeRTOS/MemMang/heap_4.c ****                     {
 216:../FreeRTOS/MemMang/heap_4.c ****                         xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 217:../FreeRTOS/MemMang/heap_4.c ****                     }
 218:../FreeRTOS/MemMang/heap_4.c ****                     else
 219:../FreeRTOS/MemMang/heap_4.c ****                     {
 220:../FreeRTOS/MemMang/heap_4.c ****                         mtCOVERAGE_TEST_MARKER();
 221:../FreeRTOS/MemMang/heap_4.c ****                     }
 222:../FreeRTOS/MemMang/heap_4.c **** 
 223:../FreeRTOS/MemMang/heap_4.c ****                     /* The block is being returned - it is allocated and owned
 224:../FreeRTOS/MemMang/heap_4.c ****                      * by the application and has no "next" block. */
 225:../FreeRTOS/MemMang/heap_4.c ****                     pxBlock->xBlockSize |= xBlockAllocatedBit;
 226:../FreeRTOS/MemMang/heap_4.c ****                     pxBlock->pxNextFreeBlock = NULL;
 227:../FreeRTOS/MemMang/heap_4.c ****                     xNumberOfSuccessfulAllocations++;
 228:../FreeRTOS/MemMang/heap_4.c ****                 }
 229:../FreeRTOS/MemMang/heap_4.c ****                 else
 230:../FreeRTOS/MemMang/heap_4.c ****                 {
 231:../FreeRTOS/MemMang/heap_4.c ****                     mtCOVERAGE_TEST_MARKER();
 232:../FreeRTOS/MemMang/heap_4.c ****                 }
 233:../FreeRTOS/MemMang/heap_4.c ****             }
 234:../FreeRTOS/MemMang/heap_4.c ****             else
 235:../FreeRTOS/MemMang/heap_4.c ****             {
 236:../FreeRTOS/MemMang/heap_4.c ****                 mtCOVERAGE_TEST_MARKER();
 237:../FreeRTOS/MemMang/heap_4.c ****             }
 238:../FreeRTOS/MemMang/heap_4.c ****         }
 239:../FreeRTOS/MemMang/heap_4.c ****         else
 240:../FreeRTOS/MemMang/heap_4.c ****         {
 241:../FreeRTOS/MemMang/heap_4.c ****             mtCOVERAGE_TEST_MARKER();
 242:../FreeRTOS/MemMang/heap_4.c ****         }
 243:../FreeRTOS/MemMang/heap_4.c **** 
 244:../FreeRTOS/MemMang/heap_4.c ****         traceMALLOC( pvReturn, xWantedSize );
 245:../FreeRTOS/MemMang/heap_4.c ****     }
 246:../FreeRTOS/MemMang/heap_4.c ****     ( void ) xTaskResumeAll();
 247:../FreeRTOS/MemMang/heap_4.c **** 
 248:../FreeRTOS/MemMang/heap_4.c ****     #if ( configUSE_MALLOC_FAILED_HOOK == 1 )
 249:../FreeRTOS/MemMang/heap_4.c ****         {
 250:../FreeRTOS/MemMang/heap_4.c ****             if( pvReturn == NULL )
 251:../FreeRTOS/MemMang/heap_4.c ****             {
 252:../FreeRTOS/MemMang/heap_4.c ****                 extern void vApplicationMallocFailedHook( void );
 253:../FreeRTOS/MemMang/heap_4.c ****                 vApplicationMallocFailedHook();
 254:../FreeRTOS/MemMang/heap_4.c ****             }
 255:../FreeRTOS/MemMang/heap_4.c ****             else
 256:../FreeRTOS/MemMang/heap_4.c ****             {
 257:../FreeRTOS/MemMang/heap_4.c ****                 mtCOVERAGE_TEST_MARKER();
 258:../FreeRTOS/MemMang/heap_4.c ****             }
 259:../FreeRTOS/MemMang/heap_4.c ****         }
 260:../FreeRTOS/MemMang/heap_4.c ****     #endif /* if ( configUSE_MALLOC_FAILED_HOOK == 1 ) */
 261:../FreeRTOS/MemMang/heap_4.c **** 
 262:../FreeRTOS/MemMang/heap_4.c ****     configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 263:../FreeRTOS/MemMang/heap_4.c ****     return pvReturn;
 264:../FreeRTOS/MemMang/heap_4.c **** }
 265:../FreeRTOS/MemMang/heap_4.c **** /*-----------------------------------------------------------*/
 266:../FreeRTOS/MemMang/heap_4.c **** 
 267:../FreeRTOS/MemMang/heap_4.c **** void vPortFree( void * pv )
 268:../FreeRTOS/MemMang/heap_4.c **** {
 269:../FreeRTOS/MemMang/heap_4.c ****     uint8_t * puc = ( uint8_t * ) pv;
 270:../FreeRTOS/MemMang/heap_4.c ****     BlockLink_t * pxLink;
 271:../FreeRTOS/MemMang/heap_4.c **** 
 272:../FreeRTOS/MemMang/heap_4.c ****     if( pv != NULL )
 273:../FreeRTOS/MemMang/heap_4.c ****     {
 274:../FreeRTOS/MemMang/heap_4.c ****         /* The memory being freed will have an BlockLink_t structure immediately
 275:../FreeRTOS/MemMang/heap_4.c ****          * before it. */
 276:../FreeRTOS/MemMang/heap_4.c ****         puc -= xHeapStructSize;
 277:../FreeRTOS/MemMang/heap_4.c **** 
 278:../FreeRTOS/MemMang/heap_4.c ****         /* This casting is to keep the compiler from issuing warnings. */
 279:../FreeRTOS/MemMang/heap_4.c ****         pxLink = ( void * ) puc;
 280:../FreeRTOS/MemMang/heap_4.c **** 
 281:../FreeRTOS/MemMang/heap_4.c ****         /* Check the block is actually allocated. */
 282:../FreeRTOS/MemMang/heap_4.c ****         configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 283:../FreeRTOS/MemMang/heap_4.c ****         configASSERT( pxLink->pxNextFreeBlock == NULL );
 284:../FreeRTOS/MemMang/heap_4.c **** 
 285:../FreeRTOS/MemMang/heap_4.c ****         if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
 286:../FreeRTOS/MemMang/heap_4.c ****         {
 287:../FreeRTOS/MemMang/heap_4.c ****             if( pxLink->pxNextFreeBlock == NULL )
 288:../FreeRTOS/MemMang/heap_4.c ****             {
 289:../FreeRTOS/MemMang/heap_4.c ****                 /* The block is being returned to the heap - it is no longer
 290:../FreeRTOS/MemMang/heap_4.c ****                  * allocated. */
 291:../FreeRTOS/MemMang/heap_4.c ****                 pxLink->xBlockSize &= ~xBlockAllocatedBit;
 292:../FreeRTOS/MemMang/heap_4.c **** 
 293:../FreeRTOS/MemMang/heap_4.c ****                 vTaskSuspendAll();
 294:../FreeRTOS/MemMang/heap_4.c ****                 {
 295:../FreeRTOS/MemMang/heap_4.c ****                     /* Add this block to the list of free blocks. */
 296:../FreeRTOS/MemMang/heap_4.c ****                     xFreeBytesRemaining += pxLink->xBlockSize;
 297:../FreeRTOS/MemMang/heap_4.c ****                     traceFREE( pv, pxLink->xBlockSize );
 298:../FreeRTOS/MemMang/heap_4.c ****                     prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 299:../FreeRTOS/MemMang/heap_4.c ****                     xNumberOfSuccessfulFrees++;
 300:../FreeRTOS/MemMang/heap_4.c ****                 }
 301:../FreeRTOS/MemMang/heap_4.c ****                 ( void ) xTaskResumeAll();
 302:../FreeRTOS/MemMang/heap_4.c ****             }
 303:../FreeRTOS/MemMang/heap_4.c ****             else
 304:../FreeRTOS/MemMang/heap_4.c ****             {
 305:../FreeRTOS/MemMang/heap_4.c ****                 mtCOVERAGE_TEST_MARKER();
 306:../FreeRTOS/MemMang/heap_4.c ****             }
 307:../FreeRTOS/MemMang/heap_4.c ****         }
 308:../FreeRTOS/MemMang/heap_4.c ****         else
 309:../FreeRTOS/MemMang/heap_4.c ****         {
 310:../FreeRTOS/MemMang/heap_4.c ****             mtCOVERAGE_TEST_MARKER();
 311:../FreeRTOS/MemMang/heap_4.c ****         }
 312:../FreeRTOS/MemMang/heap_4.c ****     }
 313:../FreeRTOS/MemMang/heap_4.c **** }
 314:../FreeRTOS/MemMang/heap_4.c **** /*-----------------------------------------------------------*/
 315:../FreeRTOS/MemMang/heap_4.c **** 
 316:../FreeRTOS/MemMang/heap_4.c **** size_t xPortGetFreeHeapSize( void )
 317:../FreeRTOS/MemMang/heap_4.c **** {
 318:../FreeRTOS/MemMang/heap_4.c ****     return xFreeBytesRemaining;
 319:../FreeRTOS/MemMang/heap_4.c **** }
 320:../FreeRTOS/MemMang/heap_4.c **** /*-----------------------------------------------------------*/
 321:../FreeRTOS/MemMang/heap_4.c **** 
 322:../FreeRTOS/MemMang/heap_4.c **** size_t xPortGetMinimumEverFreeHeapSize( void )
 323:../FreeRTOS/MemMang/heap_4.c **** {
 324:../FreeRTOS/MemMang/heap_4.c ****     return xMinimumEverFreeBytesRemaining;
 325:../FreeRTOS/MemMang/heap_4.c **** }
 326:../FreeRTOS/MemMang/heap_4.c **** /*-----------------------------------------------------------*/
 327:../FreeRTOS/MemMang/heap_4.c **** 
 328:../FreeRTOS/MemMang/heap_4.c **** void vPortInitialiseBlocks( void )
 329:../FreeRTOS/MemMang/heap_4.c **** {
 330:../FreeRTOS/MemMang/heap_4.c ****     /* This just exists to keep the linker quiet. */
 331:../FreeRTOS/MemMang/heap_4.c **** }
 332:../FreeRTOS/MemMang/heap_4.c **** /*-----------------------------------------------------------*/
 333:../FreeRTOS/MemMang/heap_4.c **** 
 334:../FreeRTOS/MemMang/heap_4.c **** static void prvHeapInit( void ) /* PRIVILEGED_FUNCTION */
 335:../FreeRTOS/MemMang/heap_4.c **** {
 336:../FreeRTOS/MemMang/heap_4.c ****     BlockLink_t * pxFirstFreeBlock;
 337:../FreeRTOS/MemMang/heap_4.c ****     uint8_t * pucAlignedHeap;
 338:../FreeRTOS/MemMang/heap_4.c ****     size_t uxAddress;
 339:../FreeRTOS/MemMang/heap_4.c ****     size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
 340:../FreeRTOS/MemMang/heap_4.c **** 
 341:../FreeRTOS/MemMang/heap_4.c ****     /* Ensure the heap starts on a correctly aligned boundary. */
 342:../FreeRTOS/MemMang/heap_4.c ****     uxAddress = ( size_t ) ucHeap;
 343:../FreeRTOS/MemMang/heap_4.c **** 
 344:../FreeRTOS/MemMang/heap_4.c ****     if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 345:../FreeRTOS/MemMang/heap_4.c ****     {
 346:../FreeRTOS/MemMang/heap_4.c ****         uxAddress += ( portBYTE_ALIGNMENT - 1 );
 347:../FreeRTOS/MemMang/heap_4.c ****         uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 348:../FreeRTOS/MemMang/heap_4.c ****         xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 349:../FreeRTOS/MemMang/heap_4.c ****     }
 350:../FreeRTOS/MemMang/heap_4.c **** 
 351:../FreeRTOS/MemMang/heap_4.c ****     pucAlignedHeap = ( uint8_t * ) uxAddress;
 352:../FreeRTOS/MemMang/heap_4.c **** 
 353:../FreeRTOS/MemMang/heap_4.c ****     /* xStart is used to hold a pointer to the first item in the list of free
 354:../FreeRTOS/MemMang/heap_4.c ****      * blocks.  The void cast is used to prevent compiler warnings. */
 355:../FreeRTOS/MemMang/heap_4.c ****     xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 356:../FreeRTOS/MemMang/heap_4.c ****     xStart.xBlockSize = ( size_t ) 0;
 357:../FreeRTOS/MemMang/heap_4.c **** 
 358:../FreeRTOS/MemMang/heap_4.c ****     /* pxEnd is used to mark the end of the list of free blocks and is inserted
 359:../FreeRTOS/MemMang/heap_4.c ****      * at the end of the heap space. */
 360:../FreeRTOS/MemMang/heap_4.c ****     uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
 361:../FreeRTOS/MemMang/heap_4.c ****     uxAddress -= xHeapStructSize;
 362:../FreeRTOS/MemMang/heap_4.c ****     uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 363:../FreeRTOS/MemMang/heap_4.c ****     pxEnd = ( void * ) uxAddress;
 364:../FreeRTOS/MemMang/heap_4.c ****     pxEnd->xBlockSize = 0;
 365:../FreeRTOS/MemMang/heap_4.c ****     pxEnd->pxNextFreeBlock = NULL;
 366:../FreeRTOS/MemMang/heap_4.c **** 
 367:../FreeRTOS/MemMang/heap_4.c ****     /* To start with there is a single free block that is sized to take up the
 368:../FreeRTOS/MemMang/heap_4.c ****      * entire heap space, minus the space taken by pxEnd. */
 369:../FreeRTOS/MemMang/heap_4.c ****     pxFirstFreeBlock = ( void * ) pucAlignedHeap;
 370:../FreeRTOS/MemMang/heap_4.c ****     pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 371:../FreeRTOS/MemMang/heap_4.c ****     pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 372:../FreeRTOS/MemMang/heap_4.c **** 
 373:../FreeRTOS/MemMang/heap_4.c ****     /* Only one block exists - and it covers the entire usable heap space. */
 374:../FreeRTOS/MemMang/heap_4.c ****     xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 375:../FreeRTOS/MemMang/heap_4.c ****     xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 376:../FreeRTOS/MemMang/heap_4.c **** 
 377:../FreeRTOS/MemMang/heap_4.c ****     /* Work out the position of the top bit in a size_t variable. */
 378:../FreeRTOS/MemMang/heap_4.c ****     xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 379:../FreeRTOS/MemMang/heap_4.c **** }
 380:../FreeRTOS/MemMang/heap_4.c **** /*-----------------------------------------------------------*/
 381:../FreeRTOS/MemMang/heap_4.c **** 
 382:../FreeRTOS/MemMang/heap_4.c **** static void prvInsertBlockIntoFreeList( BlockLink_t * pxBlockToInsert ) /* PRIVILEGED_FUNCTION */
 383:../FreeRTOS/MemMang/heap_4.c **** {
  26              	 .loc 1 383 0
  27              	 .cfi_startproc
  28              	 
  29              	 
  30              	 
  31              	.LVL0:
 384:../FreeRTOS/MemMang/heap_4.c ****     BlockLink_t * pxIterator;
 385:../FreeRTOS/MemMang/heap_4.c ****     uint8_t * puc;
 386:../FreeRTOS/MemMang/heap_4.c **** 
 387:../FreeRTOS/MemMang/heap_4.c ****     /* Iterate through the list until a block is found that has a higher address
 388:../FreeRTOS/MemMang/heap_4.c ****      * than the block being inserted. */
 389:../FreeRTOS/MemMang/heap_4.c ****     for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterat
  32              	 .loc 1 389 0
  33 0000 134A     	 ldr r2,.L10
  34 0002 00E0     	 b .L2
  35              	.LVL1:
  36              	.L8:
  37 0004 1A46     	 mov r2,r3
  38              	.LVL2:
  39              	.L2:
  40              	 .loc 1 389 0 is_stmt 0 discriminator 1
  41 0006 1368     	 ldr r3,[r2]
  42 0008 8342     	 cmp r3,r0
  43 000a FBD3     	 bcc .L8
 383:../FreeRTOS/MemMang/heap_4.c ****     BlockLink_t * pxIterator;
  44              	 .loc 1 383 0 is_stmt 1
  45 000c 30B4     	 push {r4,r5}
  46              	.LCFI0:
  47              	 .cfi_def_cfa_offset 8
  48              	 .cfi_offset 4,-8
  49              	 .cfi_offset 5,-4
  50 000e 1146     	 mov r1,r2
  51              	.LVL3:
 390:../FreeRTOS/MemMang/heap_4.c ****     {
 391:../FreeRTOS/MemMang/heap_4.c ****         /* Nothing to do here, just iterate to the right position. */
 392:../FreeRTOS/MemMang/heap_4.c ****     }
 393:../FreeRTOS/MemMang/heap_4.c **** 
 394:../FreeRTOS/MemMang/heap_4.c ****     /* Do the block being inserted, and the block it is being inserted after
 395:../FreeRTOS/MemMang/heap_4.c ****      * make a contiguous block of memory? */
 396:../FreeRTOS/MemMang/heap_4.c ****     puc = ( uint8_t * ) pxIterator;
 397:../FreeRTOS/MemMang/heap_4.c **** 
 398:../FreeRTOS/MemMang/heap_4.c ****     if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
  52              	 .loc 1 398 0
  53 0010 5468     	 ldr r4,[r2,#4]
  54 0012 1519     	 adds r5,r2,r4
  55 0014 8542     	 cmp r5,r0
  56 0016 03D1     	 bne .L3
 399:../FreeRTOS/MemMang/heap_4.c ****     {
 400:../FreeRTOS/MemMang/heap_4.c ****         pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
  57              	 .loc 1 400 0
  58 0018 6868     	 ldr r0,[r5,#4]
  59              	.LVL4:
  60 001a 0444     	 add r4,r4,r0
  61 001c 5460     	 str r4,[r2,#4]
  62              	.LVL5:
  63 001e 1046     	 mov r0,r2
  64              	.LVL6:
  65              	.L3:
 401:../FreeRTOS/MemMang/heap_4.c ****         pxBlockToInsert = pxIterator;
 402:../FreeRTOS/MemMang/heap_4.c ****     }
 403:../FreeRTOS/MemMang/heap_4.c ****     else
 404:../FreeRTOS/MemMang/heap_4.c ****     {
 405:../FreeRTOS/MemMang/heap_4.c ****         mtCOVERAGE_TEST_MARKER();
 406:../FreeRTOS/MemMang/heap_4.c ****     }
 407:../FreeRTOS/MemMang/heap_4.c **** 
 408:../FreeRTOS/MemMang/heap_4.c ****     /* Do the block being inserted, and the block it is being inserted before
 409:../FreeRTOS/MemMang/heap_4.c ****      * make a contiguous block of memory? */
 410:../FreeRTOS/MemMang/heap_4.c ****     puc = ( uint8_t * ) pxBlockToInsert;
 411:../FreeRTOS/MemMang/heap_4.c **** 
 412:../FreeRTOS/MemMang/heap_4.c ****     if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
  66              	 .loc 1 412 0
  67 0020 4268     	 ldr r2,[r0,#4]
  68 0022 8418     	 adds r4,r0,r2
  69 0024 9C42     	 cmp r4,r3
  70 0026 0CD1     	 bne .L4
 413:../FreeRTOS/MemMang/heap_4.c ****     {
 414:../FreeRTOS/MemMang/heap_4.c ****         if( pxIterator->pxNextFreeBlock != pxEnd )
  71              	 .loc 1 414 0
  72 0028 0A4B     	 ldr r3,.L10+4
  73 002a 1B68     	 ldr r3,[r3]
  74 002c 9C42     	 cmp r4,r3
  75 002e 06D0     	 beq .L5
 415:../FreeRTOS/MemMang/heap_4.c ****         {
 416:../FreeRTOS/MemMang/heap_4.c ****             /* Form one big block from the two blocks. */
 417:../FreeRTOS/MemMang/heap_4.c ****             pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
  76              	 .loc 1 417 0
  77 0030 6368     	 ldr r3,[r4,#4]
  78 0032 1A44     	 add r2,r2,r3
  79 0034 4260     	 str r2,[r0,#4]
 418:../FreeRTOS/MemMang/heap_4.c ****             pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
  80              	 .loc 1 418 0
  81 0036 0B68     	 ldr r3,[r1]
  82 0038 1B68     	 ldr r3,[r3]
  83 003a 0360     	 str r3,[r0]
  84 003c 02E0     	 b .L6
  85              	.L5:
 419:../FreeRTOS/MemMang/heap_4.c ****         }
 420:../FreeRTOS/MemMang/heap_4.c ****         else
 421:../FreeRTOS/MemMang/heap_4.c ****         {
 422:../FreeRTOS/MemMang/heap_4.c ****             pxBlockToInsert->pxNextFreeBlock = pxEnd;
  86              	 .loc 1 422 0
  87 003e 0460     	 str r4,[r0]
  88 0040 00E0     	 b .L6
  89              	.L4:
 423:../FreeRTOS/MemMang/heap_4.c ****         }
 424:../FreeRTOS/MemMang/heap_4.c ****     }
 425:../FreeRTOS/MemMang/heap_4.c ****     else
 426:../FreeRTOS/MemMang/heap_4.c ****     {
 427:../FreeRTOS/MemMang/heap_4.c ****         pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
  90              	 .loc 1 427 0
  91 0042 0360     	 str r3,[r0]
  92              	.L6:
 428:../FreeRTOS/MemMang/heap_4.c ****     }
 429:../FreeRTOS/MemMang/heap_4.c **** 
 430:../FreeRTOS/MemMang/heap_4.c ****     /* If the block being inserted plugged a gab, so was merged with the block
 431:../FreeRTOS/MemMang/heap_4.c ****      * before and the block after, then it's pxNextFreeBlock pointer will have
 432:../FreeRTOS/MemMang/heap_4.c ****      * already been set, and should not be set here as that would make it point
 433:../FreeRTOS/MemMang/heap_4.c ****      * to itself. */
 434:../FreeRTOS/MemMang/heap_4.c ****     if( pxIterator != pxBlockToInsert )
  93              	 .loc 1 434 0
  94 0044 8142     	 cmp r1,r0
 435:../FreeRTOS/MemMang/heap_4.c ****     {
 436:../FreeRTOS/MemMang/heap_4.c ****         pxIterator->pxNextFreeBlock = pxBlockToInsert;
  95              	 .loc 1 436 0
  96 0046 18BF     	 it ne
  97 0048 0860     	 strne r0,[r1]
 437:../FreeRTOS/MemMang/heap_4.c ****     }
 438:../FreeRTOS/MemMang/heap_4.c ****     else
 439:../FreeRTOS/MemMang/heap_4.c ****     {
 440:../FreeRTOS/MemMang/heap_4.c ****         mtCOVERAGE_TEST_MARKER();
 441:../FreeRTOS/MemMang/heap_4.c ****     }
 442:../FreeRTOS/MemMang/heap_4.c **** }
  98              	 .loc 1 442 0
  99 004a 30BC     	 pop {r4,r5}
 100              	.LCFI1:
 101              	 .cfi_restore 5
 102              	 .cfi_restore 4
 103              	 .cfi_def_cfa_offset 0
 104 004c 7047     	 bx lr
 105              	.L11:
 106 004e 00BF     	 .align 2
 107              	.L10:
 108 0050 00000000 	 .word .LANCHOR0
 109 0054 00000000 	 .word .LANCHOR1
 110              	 .cfi_endproc
 111              	.LFE11:
 113              	 .section .text.pvPortMalloc,"ax",%progbits
 114              	 .align 2
 115              	 .global pvPortMalloc
 116              	 .thumb
 117              	 .thumb_func
 119              	pvPortMalloc:
 120              	.LFB5:
 116:../FreeRTOS/MemMang/heap_4.c ****     BlockLink_t * pxBlock, * pxPreviousBlock, * pxNewBlockLink;
 121              	 .loc 1 116 0
 122              	 .cfi_startproc
 123              	 
 124              	 
 125              	.LVL7:
 126 0000 F8B5     	 push {r3,r4,r5,r6,r7,lr}
 127              	.LCFI2:
 128              	 .cfi_def_cfa_offset 24
 129              	 .cfi_offset 3,-24
 130              	 .cfi_offset 4,-20
 131              	 .cfi_offset 5,-16
 132              	 .cfi_offset 6,-12
 133              	 .cfi_offset 7,-8
 134              	 .cfi_offset 14,-4
 135 0002 0446     	 mov r4,r0
 136              	.LVL8:
 120:../FreeRTOS/MemMang/heap_4.c ****     {
 137              	 .loc 1 120 0
 138 0004 FFF7FEFF 	 bl vTaskSuspendAll
 139              	.LVL9:
 124:../FreeRTOS/MemMang/heap_4.c ****         {
 140              	 .loc 1 124 0
 141 0008 484B     	 ldr r3,.L32
 142 000a 1B68     	 ldr r3,[r3]
 143 000c 23BB     	 cbnz r3,.L13
 144              	.LVL10:
 145              	.LBB20:
 146              	.LBB21:
 342:../FreeRTOS/MemMang/heap_4.c **** 
 147              	 .loc 1 342 0
 148 000e 484A     	 ldr r2,.L32+4
 149              	.LVL11:
 344:../FreeRTOS/MemMang/heap_4.c ****     {
 150              	 .loc 1 344 0
 151 0010 12F0070F 	 tst r2,#7
 152 0014 07D0     	 beq .L28
 346:../FreeRTOS/MemMang/heap_4.c ****         uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 153              	 .loc 1 346 0
 154 0016 D11D     	 adds r1,r2,#7
 155              	.LVL12:
 347:../FreeRTOS/MemMang/heap_4.c ****         xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 156              	 .loc 1 347 0
 157 0018 21F00701 	 bic r1,r1,#7
 158              	.LVL13:
 159 001c 02F54043 	 add r3,r2,#49152
 348:../FreeRTOS/MemMang/heap_4.c ****     }
 160              	 .loc 1 348 0
 161 0020 5B1A     	 subs r3,r3,r1
 162              	.LVL14:
 347:../FreeRTOS/MemMang/heap_4.c ****         xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 163              	 .loc 1 347 0
 164 0022 0A46     	 mov r2,r1
 165 0024 01E0     	 b .L14
 166              	.LVL15:
 167              	.L28:
 339:../FreeRTOS/MemMang/heap_4.c **** 
 168              	 .loc 1 339 0
 169 0026 4FF44043 	 mov r3,#49152
 170              	.LVL16:
 171              	.L14:
 355:../FreeRTOS/MemMang/heap_4.c ****     xStart.xBlockSize = ( size_t ) 0;
 172              	 .loc 1 355 0
 173 002a 4248     	 ldr r0,.L32+8
 174 002c 0260     	 str r2,[r0]
 356:../FreeRTOS/MemMang/heap_4.c **** 
 175              	 .loc 1 356 0
 176 002e 0021     	 movs r1,#0
 177 0030 4160     	 str r1,[r0,#4]
 360:../FreeRTOS/MemMang/heap_4.c ****     uxAddress -= xHeapStructSize;
 178              	 .loc 1 360 0
 179 0032 1344     	 add r3,r3,r2
 180              	.LVL17:
 361:../FreeRTOS/MemMang/heap_4.c ****     uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 181              	 .loc 1 361 0
 182 0034 083B     	 subs r3,r3,#8
 183              	.LVL18:
 362:../FreeRTOS/MemMang/heap_4.c ****     pxEnd = ( void * ) uxAddress;
 184              	 .loc 1 362 0
 185 0036 23F00703 	 bic r3,r3,#7
 186              	.LVL19:
 363:../FreeRTOS/MemMang/heap_4.c ****     pxEnd->xBlockSize = 0;
 187              	 .loc 1 363 0
 188 003a 3C48     	 ldr r0,.L32
 189 003c 0360     	 str r3,[r0]
 364:../FreeRTOS/MemMang/heap_4.c ****     pxEnd->pxNextFreeBlock = NULL;
 190              	 .loc 1 364 0
 191 003e 5960     	 str r1,[r3,#4]
 365:../FreeRTOS/MemMang/heap_4.c **** 
 192              	 .loc 1 365 0
 193 0040 1960     	 str r1,[r3]
 194              	.LVL20:
 370:../FreeRTOS/MemMang/heap_4.c ****     pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 195              	 .loc 1 370 0
 196 0042 991A     	 subs r1,r3,r2
 197 0044 5160     	 str r1,[r2,#4]
 371:../FreeRTOS/MemMang/heap_4.c **** 
 198              	 .loc 1 371 0
 199 0046 1360     	 str r3,[r2]
 374:../FreeRTOS/MemMang/heap_4.c ****     xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 200              	 .loc 1 374 0
 201 0048 3B4B     	 ldr r3,.L32+12
 202              	.LVL21:
 203 004a 1960     	 str r1,[r3]
 375:../FreeRTOS/MemMang/heap_4.c **** 
 204              	 .loc 1 375 0
 205 004c 3B4B     	 ldr r3,.L32+16
 206 004e 1960     	 str r1,[r3]
 378:../FreeRTOS/MemMang/heap_4.c **** }
 207              	 .loc 1 378 0
 208 0050 4FF00042 	 mov r2,#-2147483648
 209              	.LVL22:
 210 0054 3A4B     	 ldr r3,.L32+20
 211 0056 1A60     	 str r2,[r3]
 212              	.LVL23:
 213              	.L13:
 214              	.LBE21:
 215              	.LBE20:
 137:../FreeRTOS/MemMang/heap_4.c ****         {
 216              	 .loc 1 137 0
 217 0058 394B     	 ldr r3,.L32+20
 218 005a 1E68     	 ldr r6,[r3]
 219 005c 3442     	 tst r4,r6
 220 005e 5CD1     	 bne .L15
 141:../FreeRTOS/MemMang/heap_4.c ****             {
 221              	 .loc 1 141 0
 222 0060 002C     	 cmp r4,#0
 223 0062 5DD0     	 beq .L16
 143:../FreeRTOS/MemMang/heap_4.c **** 
 224              	 .loc 1 143 0
 225 0064 04F10803 	 add r3,r4,#8
 226              	.LVL24:
 147:../FreeRTOS/MemMang/heap_4.c ****                 {
 227              	 .loc 1 147 0
 228 0068 13F0070F 	 tst r3,#7
 150:../FreeRTOS/MemMang/heap_4.c ****                     configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
 229              	 .loc 1 150 0
 230 006c 1CBF     	 itt ne
 231 006e 23F00703 	 bicne r3,r3,#7
 232              	.LVL25:
 233 0072 0833     	 addne r3,r3,#8
 234              	.LVL26:
 163:../FreeRTOS/MemMang/heap_4.c ****             {
 235              	 .loc 1 163 0
 236 0074 002B     	 cmp r3,#0
 237 0076 50D0     	 beq .L15
 163:../FreeRTOS/MemMang/heap_4.c ****             {
 238              	 .loc 1 163 0 is_stmt 0 discriminator 1
 239 0078 304A     	 ldr r2,.L32+16
 240 007a 1768     	 ldr r7,[r2]
 241 007c BB42     	 cmp r3,r7
 242 007e 4CD8     	 bhi .L15
 243              	.LVL27:
 168:../FreeRTOS/MemMang/heap_4.c **** 
 244              	 .loc 1 168 0 is_stmt 1
 245 0080 2C4A     	 ldr r2,.L32+8
 246 0082 1468     	 ldr r4,[r2]
 247              	.LVL28:
 170:../FreeRTOS/MemMang/heap_4.c ****                 {
 248              	 .loc 1 170 0
 249 0084 01E0     	 b .L19
 250              	.LVL29:
 251              	.L29:
 252 0086 2246     	 mov r2,r4
 173:../FreeRTOS/MemMang/heap_4.c ****                 }
 253              	 .loc 1 173 0
 254 0088 0C46     	 mov r4,r1
 255              	.LVL30:
 256              	.L19:
 170:../FreeRTOS/MemMang/heap_4.c ****                 {
 257              	 .loc 1 170 0
 258 008a 6168     	 ldr r1,[r4,#4]
 259 008c 8B42     	 cmp r3,r1
 260 008e 02D9     	 bls .L18
 170:../FreeRTOS/MemMang/heap_4.c ****                 {
 261              	 .loc 1 170 0 is_stmt 0 discriminator 1
 262 0090 2168     	 ldr r1,[r4]
 263 0092 0029     	 cmp r1,#0
 264 0094 F7D1     	 bne .L29
 265              	.L18:
 178:../FreeRTOS/MemMang/heap_4.c ****                 {
 266              	 .loc 1 178 0 is_stmt 1
 267 0096 2549     	 ldr r1,.L32
 268 0098 0968     	 ldr r1,[r1]
 269 009a 8C42     	 cmp r4,r1
 270 009c 3DD0     	 beq .L15
 182:../FreeRTOS/MemMang/heap_4.c **** 
 271              	 .loc 1 182 0
 272 009e 1568     	 ldr r5,[r2]
 273              	.LVL31:
 186:../FreeRTOS/MemMang/heap_4.c **** 
 274              	 .loc 1 186 0
 275 00a0 2168     	 ldr r1,[r4]
 276 00a2 1160     	 str r1,[r2]
 190:../FreeRTOS/MemMang/heap_4.c ****                     {
 277              	 .loc 1 190 0
 278 00a4 6268     	 ldr r2,[r4,#4]
 279 00a6 D21A     	 subs r2,r2,r3
 280 00a8 102A     	 cmp r2,#16
 281 00aa 10D9     	 bls .L20
 196:../FreeRTOS/MemMang/heap_4.c ****                         configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) =
 282              	 .loc 1 196 0
 283 00ac E018     	 adds r0,r4,r3
 284              	.LVL32:
 197:../FreeRTOS/MemMang/heap_4.c **** 
 285              	 .loc 1 197 0
 286 00ae 10F0070F 	 tst r0,#7
 287 00b2 08D0     	 beq .L21
 288              	.LBB22:
 289              	.LBB23:
 290              	 .file 2 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h"
   1:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*
   2:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * FreeRTOS Kernel V10.4.1
   3:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
   5:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * this software and associated documentation files (the "Software"), to deal in
   7:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * the Software without restriction, including without limitation the rights to
   8:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * subject to the following conditions:
  11:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  12:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * The above copyright notice and this permission notice shall be included in all
  13:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * copies or substantial portions of the Software.
  14:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  15:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  22:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * https://www.FreeRTOS.org
  23:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * https://github.com/FreeRTOS
  24:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  25:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * 1 tab == 4 spaces!
  26:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  */
  27:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  28:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  29:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** #ifndef PORTMACRO_H
  30:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define PORTMACRO_H
  31:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  32:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifdef __cplusplus
  33:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         extern "C" {
  34:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
  35:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  36:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------
  37:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * Port specific definitions.
  38:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  39:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * The settings in this file configure FreeRTOS correctly for the
  40:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * given hardware and compiler.
  41:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *
  42:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * These settings should not be altered.
  43:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  *-----------------------------------------------------------
  44:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  */
  45:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  46:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Type definitions. */
  47:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portCHAR          char
  48:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portFLOAT         float
  49:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portDOUBLE        double
  50:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portLONG          long
  51:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portSHORT         short
  52:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portSTACK_TYPE    uint32_t
  53:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portBASE_TYPE     long
  54:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  55:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     typedef portSTACK_TYPE   StackType_t;
  56:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     typedef long             BaseType_t;
  57:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     typedef unsigned long    UBaseType_t;
  58:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  59:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #if ( configUSE_16_BIT_TICKS == 1 )
  60:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         typedef uint16_t     TickType_t;
  61:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portMAX_DELAY              ( TickType_t ) 0xffff
  62:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #else
  63:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         typedef uint32_t     TickType_t;
  64:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portMAX_DELAY              ( TickType_t ) 0xffffffffUL
  65:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  66:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
  67:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * not need to be guarded with a critical section. */
  68:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portTICK_TYPE_IS_ATOMIC    1
  69:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
  70:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
  71:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  72:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Architecture specifics. */
  73:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portSTACK_GROWTH      ( -1 )
  74:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portTICK_PERIOD_MS    ( ( TickType_t ) 1000 / configTICK_RATE_HZ )
  75:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portBYTE_ALIGNMENT    8
  76:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portDONT_DISCARD      __attribute__( ( used ) )
  77:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
  78:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  79:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Scheduler utilities. */
  80:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portYIELD()                                 \
  81:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     {                                                   \
  82:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         /* Set a PendSV to request a context switch. */ \
  83:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT; \
  84:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****                                                         \
  85:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         /* Barriers are normally not required but do ensure the code is completely \
  86:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****          * within the specified behaviour for the architecture. */ \
  87:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile ( "dsb" ::: "memory" );                     \
  88:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile ( "isb" );                                  \
  89:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     }
  90:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  91:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portNVIC_INT_CTRL_REG     ( *( ( volatile uint32_t * ) 0xe000ed04 ) )
  92:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portNVIC_PENDSVSET_BIT    ( 1UL << 28UL )
  93:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portEND_SWITCHING_ISR( xSwitchRequired )    if( xSwitchRequired != pdFALSE ) portYIELD(
  94:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portYIELD_FROM_ISR( x )                     portEND_SWITCHING_ISR( x )
  95:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
  96:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
  97:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Critical section management. */
  98:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     extern void vPortEnterCritical( void );
  99:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     extern void vPortExitCritical( void );
 100:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portSET_INTERRUPT_MASK_FROM_ISR()         ulPortRaiseBASEPRI()
 101:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portCLEAR_INTERRUPT_MASK_FROM_ISR( x )    vPortSetBASEPRI( x )
 102:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portDISABLE_INTERRUPTS()                  vPortRaiseBASEPRI()
 103:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portENABLE_INTERRUPTS()                   vPortSetBASEPRI( 0 )
 104:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portENTER_CRITICAL()                      vPortEnterCritical()
 105:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portEXIT_CRITICAL()                       vPortExitCritical()
 106:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 107:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 108:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 109:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Task function macros as described on the FreeRTOS.org WEB site.  These are
 110:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * not necessary for to use this port.  They are defined so the common demo files
 111:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****  * (which build with all the ports) will build. */
 112:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portTASK_FUNCTION_PROTO( vFunction, pvParameters )    void vFunction( void * pvParamete
 113:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portTASK_FUNCTION( vFunction, pvParameters )          void vFunction( void * pvParamete
 114:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 115:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 116:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Tickless idle/low power functionality. */
 117:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifndef portSUPPRESS_TICKS_AND_SLEEP
 118:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
 119:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime )    vPortSuppressTicksAndSleep( xE
 120:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
 121:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 122:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 123:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Architecture specific optimisations. */
 124:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
 125:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define configUSE_PORT_OPTIMISED_TASK_SELECTION    1
 126:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
 127:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 128:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
 129:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 130:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Generic helper function. */
 131:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t 
 132:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         {
 133:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             uint8_t ucReturn;
 134:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 135:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             __asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 136:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 137:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             return ucReturn;
 138:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         }
 139:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 140:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Check the configuration. */
 141:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #if ( configMAX_PRIORITIES > 32 )
 142:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             #error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIO
 143:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #endif
 144:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 145:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* Store/clear the ready priorities in a bit map. */
 146:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities )    ( uxReadyPriorities )
 147:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities )     ( uxReadyPriorities )
 148:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 149:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 150:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 151:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities )    uxTopPriority = ( 3
 152:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 153:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 154:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 155:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 156:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 157:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifdef configASSERT
 158:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         void vPortValidateInterruptPriority( void );
 159:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portASSERT_IF_INTERRUPT_PRIORITY_INVALID()    vPortValidateInterruptPriority()
 160:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
 161:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 162:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /* portNOP() is not required by this port. */
 163:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portNOP()
 164:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 165:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #define portINLINE              __inline
 166:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 167:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #ifndef portFORCE_INLINE
 168:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         #define portFORCE_INLINE    inline __attribute__( ( always_inline ) )
 169:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     #endif
 170:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 171:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     portFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )
 172:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     {
 173:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         uint32_t ulCurrentInterrupt;
 174:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         BaseType_t xReturn;
 175:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 176:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         /* Obtain the number of the currently executing interrupt. */
 177:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile ( "mrs %0, ipsr" : "=r" ( ulCurrentInterrupt )::"memory" );
 178:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 179:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         if( ulCurrentInterrupt == 0 )
 180:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         {
 181:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             xReturn = pdFALSE;
 182:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         }
 183:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         else
 184:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         {
 185:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****             xReturn = pdTRUE;
 186:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         }
 187:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 188:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         return xReturn;
 189:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     }
 190:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 191:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** /*-----------------------------------------------------------*/
 192:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 193:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     portFORCE_INLINE static void vPortRaiseBASEPRI( void )
 194:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****     {
 195:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         uint32_t ulNewBASEPRI;
 196:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h **** 
 197:E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/portable/GCC/ARM_CM4F\portmacro.h ****         __asm volatile
 291              	 .loc 2 197 0
 292              	
 293 00b4 4FF01403 	 mov r3,#20
 294 00b8 83F31188 	 msr basepri,r3
 295 00bc BFF36F8F 	 isb 
 296 00c0 BFF34F8F 	 dsb 
 297              	
 298              	
 299              	.LVL33:
 300              	 .thumb
 301              	.L22:
 302              	.LBE23:
 303              	.LBE22:
 197:../FreeRTOS/MemMang/heap_4.c **** 
 304              	 .loc 1 197 0 discriminator 3
 305 00c4 FEE7     	 b .L22
 306              	.LVL34:
 307              	.L21:
 201:../FreeRTOS/MemMang/heap_4.c ****                         pxBlock->xBlockSize = xWantedSize;
 308              	 .loc 1 201 0
 309 00c6 4260     	 str r2,[r0,#4]
 202:../FreeRTOS/MemMang/heap_4.c **** 
 310              	 .loc 1 202 0
 311 00c8 6360     	 str r3,[r4,#4]
 205:../FreeRTOS/MemMang/heap_4.c ****                     }
 312              	 .loc 1 205 0
 313 00ca FFF7FEFF 	 bl prvInsertBlockIntoFreeList
 314              	.LVL35:
 315              	.L20:
 212:../FreeRTOS/MemMang/heap_4.c **** 
 316              	 .loc 1 212 0
 317 00ce 6268     	 ldr r2,[r4,#4]
 318 00d0 BB1A     	 subs r3,r7,r2
 319 00d2 1A49     	 ldr r1,.L32+16
 320 00d4 0B60     	 str r3,[r1]
 214:../FreeRTOS/MemMang/heap_4.c ****                     {
 321              	 .loc 1 214 0
 322 00d6 1849     	 ldr r1,.L32+12
 323 00d8 0968     	 ldr r1,[r1]
 324 00da 8B42     	 cmp r3,r1
 216:../FreeRTOS/MemMang/heap_4.c ****                     }
 325              	 .loc 1 216 0
 326 00dc 3CBF     	 itt cc
 327 00de 1649     	 ldrcc r1,.L32+12
 328 00e0 0B60     	 strcc r3,[r1]
 182:../FreeRTOS/MemMang/heap_4.c **** 
 329              	 .loc 1 182 0
 330 00e2 0835     	 adds r5,r5,#8
 331              	.LVL36:
 225:../FreeRTOS/MemMang/heap_4.c ****                     pxBlock->pxNextFreeBlock = NULL;
 332              	 .loc 1 225 0
 333 00e4 1643     	 orrs r6,r6,r2
 334 00e6 6660     	 str r6,[r4,#4]
 226:../FreeRTOS/MemMang/heap_4.c ****                     xNumberOfSuccessfulAllocations++;
 335              	 .loc 1 226 0
 336 00e8 0023     	 movs r3,#0
 337 00ea 2360     	 str r3,[r4]
 227:../FreeRTOS/MemMang/heap_4.c ****                 }
 338              	 .loc 1 227 0
 339 00ec 154A     	 ldr r2,.L32+24
 340 00ee 1368     	 ldr r3,[r2]
 341 00f0 0133     	 adds r3,r3,#1
 342 00f2 1360     	 str r3,[r2]
 246:../FreeRTOS/MemMang/heap_4.c **** 
 343              	 .loc 1 246 0
 344 00f4 FFF7FEFF 	 bl xTaskResumeAll
 345              	.LVL37:
 250:../FreeRTOS/MemMang/heap_4.c ****             {
 346              	 .loc 1 250 0
 347 00f8 1DB9     	 cbnz r5,.L24
 348              	.LVL38:
 349              	.L27:
 350              	.LBB24:
 253:../FreeRTOS/MemMang/heap_4.c ****             }
 351              	 .loc 1 253 0
 352 00fa FFF7FEFF 	 bl vApplicationMallocFailedHook
 353              	.LVL39:
 354 00fe 0025     	 movs r5,#0
 355 0100 11E0     	 b .L30
 356              	.LVL40:
 357              	.L24:
 358              	.LBE24:
 262:../FreeRTOS/MemMang/heap_4.c ****     return pvReturn;
 359              	 .loc 1 262 0
 360 0102 15F0070F 	 tst r5,#7
 361 0106 0ED0     	 beq .L30
 362              	.LBB25:
 363              	.LBB26:
 364              	 .loc 2 197 0
 365              	
 366 0108 4FF01403 	 mov r3,#20
 367 010c 83F31188 	 msr basepri,r3
 368 0110 BFF36F8F 	 isb 
 369 0114 BFF34F8F 	 dsb 
 370              	
 371              	
 372              	.LVL41:
 373              	 .thumb
 374              	.L26:
 375              	.LBE26:
 376              	.LBE25:
 262:../FreeRTOS/MemMang/heap_4.c ****     return pvReturn;
 377              	 .loc 1 262 0 discriminator 5
 378 0118 FEE7     	 b .L26
 379              	.LVL42:
 380              	.L15:
 246:../FreeRTOS/MemMang/heap_4.c **** 
 381              	 .loc 1 246 0
 382 011a FFF7FEFF 	 bl xTaskResumeAll
 383              	.LVL43:
 384 011e ECE7     	 b .L27
 385              	.LVL44:
 386              	.L16:
 387 0120 FFF7FEFF 	 bl xTaskResumeAll
 388              	.LVL45:
 389 0124 E9E7     	 b .L27
 390              	.LVL46:
 391              	.L30:
 264:../FreeRTOS/MemMang/heap_4.c **** /*-----------------------------------------------------------*/
 392              	 .loc 1 264 0
 393 0126 2846     	 mov r0,r5
 394 0128 F8BD     	 pop {r3,r4,r5,r6,r7,pc}
 395              	.L33:
 396 012a 00BF     	 .align 2
 397              	.L32:
 398 012c 00000000 	 .word .LANCHOR1
 399 0130 00000000 	 .word .LANCHOR2
 400 0134 00000000 	 .word .LANCHOR0
 401 0138 00000000 	 .word .LANCHOR3
 402 013c 00000000 	 .word .LANCHOR4
 403 0140 00000000 	 .word .LANCHOR5
 404 0144 00000000 	 .word .LANCHOR6
 405              	 .cfi_endproc
 406              	.LFE5:
 408              	 .section .text.vPortFree,"ax",%progbits
 409              	 .align 2
 410              	 .global vPortFree
 411              	 .thumb
 412              	 .thumb_func
 414              	vPortFree:
 415              	.LFB6:
 268:../FreeRTOS/MemMang/heap_4.c ****     uint8_t * puc = ( uint8_t * ) pv;
 416              	 .loc 1 268 0
 417              	 .cfi_startproc
 418              	 
 419              	 
 420              	.LVL47:
 272:../FreeRTOS/MemMang/heap_4.c ****     {
 421              	 .loc 1 272 0
 422 0000 0028     	 cmp r0,#0
 423 0002 33D0     	 beq .L41
 268:../FreeRTOS/MemMang/heap_4.c ****     uint8_t * puc = ( uint8_t * ) pv;
 424              	 .loc 1 268 0
 425 0004 10B5     	 push {r4,lr}
 426              	.LCFI3:
 427              	 .cfi_def_cfa_offset 8
 428              	 .cfi_offset 4,-8
 429              	 .cfi_offset 14,-4
 430 0006 0446     	 mov r4,r0
 431              	.LVL48:
 282:../FreeRTOS/MemMang/heap_4.c ****         configASSERT( pxLink->pxNextFreeBlock == NULL );
 432              	 .loc 1 282 0
 433 0008 50F8043C 	 ldr r3,[r0,#-4]
 434 000c 184A     	 ldr r2,.L42
 435 000e 1268     	 ldr r2,[r2]
 436 0010 1A42     	 tst r2,r3
 437 0012 08D1     	 bne .L36
 438              	.LBB27:
 439              	.LBB28:
 440              	 .loc 2 197 0
 441              	
 442 0014 4FF01403 	 mov r3,#20
 443 0018 83F31188 	 msr basepri,r3
 444 001c BFF36F8F 	 isb 
 445 0020 BFF34F8F 	 dsb 
 446              	
 447              	
 448              	.LVL49:
 449              	 .thumb
 450              	.L37:
 451              	.LBE28:
 452              	.LBE27:
 282:../FreeRTOS/MemMang/heap_4.c ****         configASSERT( pxLink->pxNextFreeBlock == NULL );
 453              	 .loc 1 282 0 discriminator 1
 454 0024 FEE7     	 b .L37
 455              	.L36:
 283:../FreeRTOS/MemMang/heap_4.c **** 
 456              	 .loc 1 283 0
 457 0026 50F8081C 	 ldr r1,[r0,#-8]
 458 002a 41B1     	 cbz r1,.L38
 459              	.LBB29:
 460              	.LBB30:
 461              	 .loc 2 197 0
 462              	
 463 002c 4FF01403 	 mov r3,#20
 464 0030 83F31188 	 msr basepri,r3
 465 0034 BFF36F8F 	 isb 
 466 0038 BFF34F8F 	 dsb 
 467              	
 468              	
 469              	.LVL50:
 470              	 .thumb
 471              	.L39:
 472              	.LBE30:
 473              	.LBE29:
 283:../FreeRTOS/MemMang/heap_4.c **** 
 474              	 .loc 1 283 0 discriminator 2
 475 003c FEE7     	 b .L39
 476              	.L38:
 291:../FreeRTOS/MemMang/heap_4.c **** 
 477              	 .loc 1 291 0
 478 003e 23EA0203 	 bic r3,r3,r2
 479 0042 40F8043C 	 str r3,[r0,#-4]
 293:../FreeRTOS/MemMang/heap_4.c ****                 {
 480              	 .loc 1 293 0
 481 0046 FFF7FEFF 	 bl vTaskSuspendAll
 482              	.LVL51:
 296:../FreeRTOS/MemMang/heap_4.c ****                     traceFREE( pv, pxLink->xBlockSize );
 483              	 .loc 1 296 0
 484 004a 0A4A     	 ldr r2,.L42+4
 485 004c 1168     	 ldr r1,[r2]
 486 004e 54F8043C 	 ldr r3,[r4,#-4]
 487 0052 0B44     	 add r3,r3,r1
 488 0054 1360     	 str r3,[r2]
 298:../FreeRTOS/MemMang/heap_4.c ****                     xNumberOfSuccessfulFrees++;
 489              	 .loc 1 298 0
 490 0056 A4F10800 	 sub r0,r4,#8
 491 005a FFF7FEFF 	 bl prvInsertBlockIntoFreeList
 492              	.LVL52:
 299:../FreeRTOS/MemMang/heap_4.c ****                 }
 493              	 .loc 1 299 0
 494 005e 064A     	 ldr r2,.L42+8
 495 0060 1368     	 ldr r3,[r2]
 496 0062 0133     	 adds r3,r3,#1
 497 0064 1360     	 str r3,[r2]
 301:../FreeRTOS/MemMang/heap_4.c ****             }
 498              	 .loc 1 301 0
 499 0066 FFF7FEFF 	 bl xTaskResumeAll
 500              	.LVL53:
 501 006a 10BD     	 pop {r4,pc}
 502              	.LVL54:
 503              	.L41:
 504              	.LCFI4:
 505              	 .cfi_def_cfa_offset 0
 506              	 .cfi_restore 4
 507              	 .cfi_restore 14
 508 006c 7047     	 bx lr
 509              	.L43:
 510 006e 00BF     	 .align 2
 511              	.L42:
 512 0070 00000000 	 .word .LANCHOR5
 513 0074 00000000 	 .word .LANCHOR4
 514 0078 00000000 	 .word .LANCHOR7
 515              	 .cfi_endproc
 516              	.LFE6:
 518              	 .section .text.xPortGetFreeHeapSize,"ax",%progbits
 519              	 .align 2
 520              	 .global xPortGetFreeHeapSize
 521              	 .thumb
 522              	 .thumb_func
 524              	xPortGetFreeHeapSize:
 525              	.LFB7:
 317:../FreeRTOS/MemMang/heap_4.c ****     return xFreeBytesRemaining;
 526              	 .loc 1 317 0
 527              	 .cfi_startproc
 528              	 
 529              	 
 530              	 
 319:../FreeRTOS/MemMang/heap_4.c **** /*-----------------------------------------------------------*/
 531              	 .loc 1 319 0
 532 0000 014B     	 ldr r3,.L45
 533 0002 1868     	 ldr r0,[r3]
 534 0004 7047     	 bx lr
 535              	.L46:
 536 0006 00BF     	 .align 2
 537              	.L45:
 538 0008 00000000 	 .word .LANCHOR4
 539              	 .cfi_endproc
 540              	.LFE7:
 542              	 .section .text.xPortGetMinimumEverFreeHeapSize,"ax",%progbits
 543              	 .align 2
 544              	 .global xPortGetMinimumEverFreeHeapSize
 545              	 .thumb
 546              	 .thumb_func
 548              	xPortGetMinimumEverFreeHeapSize:
 549              	.LFB8:
 323:../FreeRTOS/MemMang/heap_4.c ****     return xMinimumEverFreeBytesRemaining;
 550              	 .loc 1 323 0
 551              	 .cfi_startproc
 552              	 
 553              	 
 554              	 
 325:../FreeRTOS/MemMang/heap_4.c **** /*-----------------------------------------------------------*/
 555              	 .loc 1 325 0
 556 0000 014B     	 ldr r3,.L48
 557 0002 1868     	 ldr r0,[r3]
 558 0004 7047     	 bx lr
 559              	.L49:
 560 0006 00BF     	 .align 2
 561              	.L48:
 562 0008 00000000 	 .word .LANCHOR3
 563              	 .cfi_endproc
 564              	.LFE8:
 566              	 .section .text.vPortInitialiseBlocks,"ax",%progbits
 567              	 .align 2
 568              	 .global vPortInitialiseBlocks
 569              	 .thumb
 570              	 .thumb_func
 572              	vPortInitialiseBlocks:
 573              	.LFB9:
 329:../FreeRTOS/MemMang/heap_4.c ****     /* This just exists to keep the linker quiet. */
 574              	 .loc 1 329 0
 575              	 .cfi_startproc
 576              	 
 577              	 
 578              	 
 579 0000 7047     	 bx lr
 580              	 .cfi_endproc
 581              	.LFE9:
 583 0002 00BF     	 .section .text.vPortGetHeapStats,"ax",%progbits
 584              	 .align 2
 585              	 .global vPortGetHeapStats
 586              	 .thumb
 587              	 .thumb_func
 589              	vPortGetHeapStats:
 590              	.LFB12:
 443:../FreeRTOS/MemMang/heap_4.c **** /*-----------------------------------------------------------*/
 444:../FreeRTOS/MemMang/heap_4.c **** 
 445:../FreeRTOS/MemMang/heap_4.c **** void vPortGetHeapStats( HeapStats_t * pxHeapStats )
 446:../FreeRTOS/MemMang/heap_4.c **** {
 591              	 .loc 1 446 0
 592              	 .cfi_startproc
 593              	 
 594              	 
 595              	.LVL55:
 596              	 .loc 1 446 0
 597 0000 F8B5     	 push {r3,r4,r5,r6,r7,lr}
 598              	.LCFI5:
 599              	 .cfi_def_cfa_offset 24
 600              	 .cfi_offset 3,-24
 601              	 .cfi_offset 4,-20
 602              	 .cfi_offset 5,-16
 603              	 .cfi_offset 6,-12
 604              	 .cfi_offset 7,-8
 605              	 .cfi_offset 14,-4
 606 0002 0746     	 mov r7,r0
 607              	.LVL56:
 447:../FreeRTOS/MemMang/heap_4.c ****     BlockLink_t * pxBlock;
 448:../FreeRTOS/MemMang/heap_4.c ****     size_t xBlocks = 0, xMaxSize = 0, xMinSize = portMAX_DELAY; /* portMAX_DELAY used as a portable
 449:../FreeRTOS/MemMang/heap_4.c **** 
 450:../FreeRTOS/MemMang/heap_4.c ****     vTaskSuspendAll();
 608              	 .loc 1 450 0
 609 0004 FFF7FEFF 	 bl vTaskSuspendAll
 610              	.LVL57:
 451:../FreeRTOS/MemMang/heap_4.c ****     {
 452:../FreeRTOS/MemMang/heap_4.c ****         pxBlock = xStart.pxNextFreeBlock;
 611              	 .loc 1 452 0
 612 0008 174B     	 ldr r3,.L57
 613 000a 1B68     	 ldr r3,[r3]
 614              	.LVL58:
 453:../FreeRTOS/MemMang/heap_4.c **** 
 454:../FreeRTOS/MemMang/heap_4.c ****         /* pxBlock will be NULL if the heap has not been initialised.  The heap
 455:../FreeRTOS/MemMang/heap_4.c ****          * is initialised automatically when the first allocation is made. */
 456:../FreeRTOS/MemMang/heap_4.c ****         if( pxBlock != NULL )
 615              	 .loc 1 456 0
 616 000c 8BB1     	 cbz r3,.L54
 457:../FreeRTOS/MemMang/heap_4.c ****         {
 458:../FreeRTOS/MemMang/heap_4.c ****             do
 459:../FreeRTOS/MemMang/heap_4.c ****             {
 460:../FreeRTOS/MemMang/heap_4.c ****                 /* Increment the number of blocks and record the largest block seen
 461:../FreeRTOS/MemMang/heap_4.c ****                  * so far. */
 462:../FreeRTOS/MemMang/heap_4.c ****                 xBlocks++;
 463:../FreeRTOS/MemMang/heap_4.c **** 
 464:../FreeRTOS/MemMang/heap_4.c ****                 if( pxBlock->xBlockSize > xMaxSize )
 465:../FreeRTOS/MemMang/heap_4.c ****                 {
 466:../FreeRTOS/MemMang/heap_4.c ****                     xMaxSize = pxBlock->xBlockSize;
 467:../FreeRTOS/MemMang/heap_4.c ****                 }
 468:../FreeRTOS/MemMang/heap_4.c **** 
 469:../FreeRTOS/MemMang/heap_4.c ****                 if( pxBlock->xBlockSize < xMinSize )
 470:../FreeRTOS/MemMang/heap_4.c ****                 {
 471:../FreeRTOS/MemMang/heap_4.c ****                     xMinSize = pxBlock->xBlockSize;
 472:../FreeRTOS/MemMang/heap_4.c ****                 }
 473:../FreeRTOS/MemMang/heap_4.c **** 
 474:../FreeRTOS/MemMang/heap_4.c ****                 /* Move to the next block in the chain until the last block is
 475:../FreeRTOS/MemMang/heap_4.c ****                  * reached. */
 476:../FreeRTOS/MemMang/heap_4.c ****                 pxBlock = pxBlock->pxNextFreeBlock;
 477:../FreeRTOS/MemMang/heap_4.c ****             } while( pxBlock != pxEnd );
 617              	 .loc 1 477 0
 618 000e 174A     	 ldr r2,.L57+4
 619 0010 1168     	 ldr r1,[r2]
 620 0012 4FF0FF36 	 mov r6,#-1
 621 0016 0024     	 movs r4,#0
 622 0018 2546     	 mov r5,r4
 623              	.LVL59:
 624              	.L53:
 462:../FreeRTOS/MemMang/heap_4.c **** 
 625              	 .loc 1 462 0
 626 001a 0135     	 adds r5,r5,#1
 627              	.LVL60:
 464:../FreeRTOS/MemMang/heap_4.c ****                 {
 628              	 .loc 1 464 0
 629 001c 5A68     	 ldr r2,[r3,#4]
 630 001e 9442     	 cmp r4,r2
 631 0020 38BF     	 it cc
 632 0022 1446     	 movcc r4,r2
 633              	.LVL61:
 634 0024 9642     	 cmp r6,r2
 635 0026 28BF     	 it cs
 636 0028 1646     	 movcs r6,r2
 637              	.LVL62:
 476:../FreeRTOS/MemMang/heap_4.c ****             } while( pxBlock != pxEnd );
 638              	 .loc 1 476 0
 639 002a 1B68     	 ldr r3,[r3]
 640              	.LVL63:
 641              	 .loc 1 477 0
 642 002c 8B42     	 cmp r3,r1
 643 002e F4D1     	 bne .L53
 644 0030 03E0     	 b .L52
 645              	.LVL64:
 646              	.L54:
 448:../FreeRTOS/MemMang/heap_4.c **** 
 647              	 .loc 1 448 0
 648 0032 4FF0FF36 	 mov r6,#-1
 649 0036 0024     	 movs r4,#0
 650 0038 2546     	 mov r5,r4
 651              	.LVL65:
 652              	.L52:
 478:../FreeRTOS/MemMang/heap_4.c ****         }
 479:../FreeRTOS/MemMang/heap_4.c ****     }
 480:../FreeRTOS/MemMang/heap_4.c ****     ( void ) xTaskResumeAll();
 653              	 .loc 1 480 0
 654 003a FFF7FEFF 	 bl xTaskResumeAll
 655              	.LVL66:
 481:../FreeRTOS/MemMang/heap_4.c **** 
 482:../FreeRTOS/MemMang/heap_4.c ****     pxHeapStats->xSizeOfLargestFreeBlockInBytes = xMaxSize;
 656              	 .loc 1 482 0
 657 003e 7C60     	 str r4,[r7,#4]
 483:../FreeRTOS/MemMang/heap_4.c ****     pxHeapStats->xSizeOfSmallestFreeBlockInBytes = xMinSize;
 658              	 .loc 1 483 0
 659 0040 BE60     	 str r6,[r7,#8]
 484:../FreeRTOS/MemMang/heap_4.c ****     pxHeapStats->xNumberOfFreeBlocks = xBlocks;
 660              	 .loc 1 484 0
 661 0042 FD60     	 str r5,[r7,#12]
 485:../FreeRTOS/MemMang/heap_4.c **** 
 486:../FreeRTOS/MemMang/heap_4.c ****     taskENTER_CRITICAL();
 662              	 .loc 1 486 0
 663 0044 FFF7FEFF 	 bl vPortEnterCritical
 664              	.LVL67:
 487:../FreeRTOS/MemMang/heap_4.c ****     {
 488:../FreeRTOS/MemMang/heap_4.c ****         pxHeapStats->xAvailableHeapSpaceInBytes = xFreeBytesRemaining;
 665              	 .loc 1 488 0
 666 0048 094B     	 ldr r3,.L57+8
 667 004a 1B68     	 ldr r3,[r3]
 668 004c 3B60     	 str r3,[r7]
 489:../FreeRTOS/MemMang/heap_4.c ****         pxHeapStats->xNumberOfSuccessfulAllocations = xNumberOfSuccessfulAllocations;
 669              	 .loc 1 489 0
 670 004e 094B     	 ldr r3,.L57+12
 671 0050 1B68     	 ldr r3,[r3]
 672 0052 7B61     	 str r3,[r7,#20]
 490:../FreeRTOS/MemMang/heap_4.c ****         pxHeapStats->xNumberOfSuccessfulFrees = xNumberOfSuccessfulFrees;
 673              	 .loc 1 490 0
 674 0054 084B     	 ldr r3,.L57+16
 675 0056 1B68     	 ldr r3,[r3]
 676 0058 BB61     	 str r3,[r7,#24]
 491:../FreeRTOS/MemMang/heap_4.c ****         pxHeapStats->xMinimumEverFreeBytesRemaining = xMinimumEverFreeBytesRemaining;
 677              	 .loc 1 491 0
 678 005a 084B     	 ldr r3,.L57+20
 679 005c 1B68     	 ldr r3,[r3]
 680 005e 3B61     	 str r3,[r7,#16]
 492:../FreeRTOS/MemMang/heap_4.c ****     }
 493:../FreeRTOS/MemMang/heap_4.c ****     taskEXIT_CRITICAL();
 681              	 .loc 1 493 0
 682 0060 FFF7FEFF 	 bl vPortExitCritical
 683              	.LVL68:
 684 0064 F8BD     	 pop {r3,r4,r5,r6,r7,pc}
 685              	.LVL69:
 686              	.L58:
 687 0066 00BF     	 .align 2
 688              	.L57:
 689 0068 00000000 	 .word .LANCHOR0
 690 006c 00000000 	 .word .LANCHOR1
 691 0070 00000000 	 .word .LANCHOR4
 692 0074 00000000 	 .word .LANCHOR6
 693 0078 00000000 	 .word .LANCHOR7
 694 007c 00000000 	 .word .LANCHOR3
 695              	 .cfi_endproc
 696              	.LFE12:
 698              	 .section .bss.xNumberOfSuccessfulAllocations,"aw",%nobits
 699              	 .align 2
 700              	 .set .LANCHOR6,.+0
 703              	xNumberOfSuccessfulAllocations:
 704 0000 00000000 	 .space 4
 705              	 .section .bss.xFreeBytesRemaining,"aw",%nobits
 706              	 .align 2
 707              	 .set .LANCHOR4,.+0
 710              	xFreeBytesRemaining:
 711 0000 00000000 	 .space 4
 712              	 .section .bss.pxEnd,"aw",%nobits
 713              	 .align 2
 714              	 .set .LANCHOR1,.+0
 717              	pxEnd:
 718 0000 00000000 	 .space 4
 719              	 .section .bss.xStart,"aw",%nobits
 720              	 .align 2
 721              	 .set .LANCHOR0,.+0
 724              	xStart:
 725 0000 00000000 	 .space 8
 725      00000000 
 726              	 .section .bss.xNumberOfSuccessfulFrees,"aw",%nobits
 727              	 .align 2
 728              	 .set .LANCHOR7,.+0
 731              	xNumberOfSuccessfulFrees:
 732 0000 00000000 	 .space 4
 733              	 .section .bss.ucHeap,"aw",%nobits
 734              	 .align 2
 735              	 .set .LANCHOR2,.+0
 738              	ucHeap:
 739 0000 00000000 	 .space 49152
 739      00000000 
 739      00000000 
 739      00000000 
 739      00000000 
 740              	 .section .bss.xBlockAllocatedBit,"aw",%nobits
 741              	 .align 2
 742              	 .set .LANCHOR5,.+0
 745              	xBlockAllocatedBit:
 746 0000 00000000 	 .space 4
 747              	 .section .bss.xMinimumEverFreeBytesRemaining,"aw",%nobits
 748              	 .align 2
 749              	 .set .LANCHOR3,.+0
 752              	xMinimumEverFreeBytesRemaining:
 753 0000 00000000 	 .space 4
 754              	 .text
 755              	.Letext0:
 756              	 .file 3 "e:\\embedded\\dave_4-4-2_64bit_2018-02-23\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\lib\\gcc\\arm-none-eabi\\4.9.3\\include\\stddef.h"
 757              	 .file 4 "e:\\embedded\\dave_4-4-2_64bit_2018-02-23\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 758              	 .file 5 "e:\\embedded\\dave_4-4-2_64bit_2018-02-23\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 759              	 .file 6 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/include/portable.h"
 760              	 .file 7 "E:/Embedded/Projects/XMC4500/Ethernet_CAN_XMC4500/FreeRTOS/Source/include/task.h"
DEFINED SYMBOLS
                            *ABS*:00000000 heap_4.c
    {standard input}:19     .text.prvInsertBlockIntoFreeList:00000000 $t
    {standard input}:23     .text.prvInsertBlockIntoFreeList:00000000 prvInsertBlockIntoFreeList
    {standard input}:108    .text.prvInsertBlockIntoFreeList:00000050 $d
    {standard input}:114    .text.pvPortMalloc:00000000 $t
    {standard input}:119    .text.pvPortMalloc:00000000 pvPortMalloc
    {standard input}:398    .text.pvPortMalloc:0000012c $d
    {standard input}:409    .text.vPortFree:00000000 $t
    {standard input}:414    .text.vPortFree:00000000 vPortFree
    {standard input}:512    .text.vPortFree:00000070 $d
    {standard input}:519    .text.xPortGetFreeHeapSize:00000000 $t
    {standard input}:524    .text.xPortGetFreeHeapSize:00000000 xPortGetFreeHeapSize
    {standard input}:538    .text.xPortGetFreeHeapSize:00000008 $d
    {standard input}:543    .text.xPortGetMinimumEverFreeHeapSize:00000000 $t
    {standard input}:548    .text.xPortGetMinimumEverFreeHeapSize:00000000 xPortGetMinimumEverFreeHeapSize
    {standard input}:562    .text.xPortGetMinimumEverFreeHeapSize:00000008 $d
    {standard input}:567    .text.vPortInitialiseBlocks:00000000 $t
    {standard input}:572    .text.vPortInitialiseBlocks:00000000 vPortInitialiseBlocks
    {standard input}:584    .text.vPortGetHeapStats:00000000 $t
    {standard input}:589    .text.vPortGetHeapStats:00000000 vPortGetHeapStats
    {standard input}:689    .text.vPortGetHeapStats:00000068 $d
    {standard input}:699    .bss.xNumberOfSuccessfulAllocations:00000000 $d
    {standard input}:703    .bss.xNumberOfSuccessfulAllocations:00000000 xNumberOfSuccessfulAllocations
    {standard input}:706    .bss.xFreeBytesRemaining:00000000 $d
    {standard input}:710    .bss.xFreeBytesRemaining:00000000 xFreeBytesRemaining
    {standard input}:713    .bss.pxEnd:00000000 $d
    {standard input}:717    .bss.pxEnd:00000000 pxEnd
    {standard input}:720    .bss.xStart:00000000 $d
    {standard input}:724    .bss.xStart:00000000 xStart
    {standard input}:727    .bss.xNumberOfSuccessfulFrees:00000000 $d
    {standard input}:731    .bss.xNumberOfSuccessfulFrees:00000000 xNumberOfSuccessfulFrees
    {standard input}:734    .bss.ucHeap:00000000 $d
    {standard input}:738    .bss.ucHeap:00000000 ucHeap
    {standard input}:741    .bss.xBlockAllocatedBit:00000000 $d
    {standard input}:745    .bss.xBlockAllocatedBit:00000000 xBlockAllocatedBit
    {standard input}:748    .bss.xMinimumEverFreeBytesRemaining:00000000 $d
    {standard input}:752    .bss.xMinimumEverFreeBytesRemaining:00000000 xMinimumEverFreeBytesRemaining
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.0.3466fc6a3db32493c997d085de4c7a28
                           .group:00000000 wm4.newlib.h.8.fe7d912fc917043c98742c35eddd8cff
                           .group:00000000 wm4.features.h.22.bee0aee4a3878f51861c775df98fa3ea
                           .group:00000000 wm4.config.h.216.aad1ef7bee4fb69981cb38ce62f84d9c
                           .group:00000000 wm4._ansi.h.23.9f8fcfa20193763fcf364fb91705c94b
                           .group:00000000 wm4.stdlib.h.13.4ed386f5c1a80d71e72172885d946ef2
                           .group:00000000 wm4.stddef.h.184.aa65fb7281d578229bbad41b91862635
                           .group:00000000 wm4.stddef.h.39.dc09cac7e3f758f23d559f6b28ebbb0d
                           .group:00000000 wm4._default_types.h.6.35ee9e747940367bf2a634907d1c2382
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4._types.h.54.d3d34a3b7f3cc230cd159baf022b4b08
                           .group:00000000 wm4.stddef.h.158.61317cdbfb4026324507d123a50b0fd6
                           .group:00000000 wm4.reent.h.17.8bd9e4098e0428508c282cad794fae43
                           .group:00000000 wm4.alloca.h.8.dfc0c703c47ec3e69746825b17d9e66d
                           .group:00000000 wm4.stdlib.h.53.fe81d5186f74ee22c982a1a79f340ee8
                           .group:00000000 wm4._intsup.h.10.ca9f32a61b410c270a48d1161ca2c217
                           .group:00000000 wm4.stdint.h.22.f4a337c398d8b6d821a97202448bc0d0
                           .group:00000000 wm4.FreeRTOSConfig.h.30.aa43eb1cb33228d5c7e359a94d48589b
                           .group:00000000 wm4.projdefs.h.28.d6a7c9061b707820f2fcf4c2ff5d9f24
                           .group:00000000 wm4.portmacro.h.30.2ddc2eaf2e032c76c597fb78c4365041
                           .group:00000000 wm4.portable.h.63.e9cc508c3850f44ce542149380c67812
                           .group:00000000 wm4.mpu_wrappers.h.28.163fb40577cf8d1578015ea3f2ff4cdb
                           .group:00000000 wm4.FreeRTOS.h.67.9945f39eea4ddeb224c0782392206292
                           .group:00000000 wm4.list.h.57.02ec67e07eacffe5ca7cfb7326896236
                           .group:00000000 wm4.task.h.47.2d3fe49a094b8ec1e3e6aac441e8db21

UNDEFINED SYMBOLS
vTaskSuspendAll
xTaskResumeAll
vApplicationMallocFailedHook
vPortEnterCritical
vPortExitCritical
